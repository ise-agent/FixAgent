{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 128-132)": "\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n                if self._meta_ordering and hasattr(self.query, 'annotation_select') and self.query.annotation_select:\n                    # This is an aggregation query with Meta.ordering - skip adding to GROUP BY\n                    continue\n                expressions.extend(expr.get_group_by_cols())\n",
    "Location 2 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 286-288)": "\n        elif self.query.get_meta().ordering:\n            ordering = self.query.get_meta().ordering\n            self._meta_ordering = ordering\n",
    "Location 3 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 63-147)": "\ndef get_group_by(self, select, order_by):\n    \"\"\"\n    Return a list of 2-tuples of form (sql, params).\n\n    The logic of what exactly the GROUP BY clause contains is hard\n    to describe in other words than \"if it passes the test suite,\n    then it is correct\".\n    \"\"\"\n    # Some examples:\n    #     SomeModel.objects.annotate(Count('somecol'))\n    #     GROUP BY: all fields of the model\n    #\n    #    SomeModel.objects.values('name').annotate(Count('somecol'))\n    #    GROUP BY: name\n    #\n    #    SomeModel.objects.annotate(Count('somecol')).values('name')\n    #    GROUP BY: all cols of the model\n    #\n    #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n    #    GROUP BY: name, pk\n    #\n    #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n    #    GROUP BY: name, pk\n    #\n    # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n    # can't be ever restricted to a smaller set, but additional columns in\n    # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n    # the end result is that it is impossible to force the query to have\n    # a chosen GROUP BY clause - you can almost do this by using the form:\n    #     .values(*wanted_cols).annotate(AnAggregate())\n    # but any later annotations, extra selects, values calls that\n    # refer some column outside of the wanted_cols, order_by, or even\n    # filter calls can alter the GROUP BY clause.\n\n    # The query.group_by is either None (no GROUP BY at all), True\n    # (group by select fields), or a list of expressions to be added\n    # to the group by.\n    if self.query.group_by is None:\n        return []\n    expressions = []\n    if self.query.group_by is not True:\n        # If the group by is set to a list (by .values() call most likely),\n        # then we need to add everything in it to the GROUP BY clause.\n        # Backwards compatibility hack for setting query.group_by. Remove\n        # when  we have public API way of forcing the GROUP BY clause.\n        # Converts string references to expressions.\n        for expr in self.query.group_by:\n            if not hasattr(expr, 'as_sql'):\n                expressions.append(self.query.resolve_ref(expr))\n            else:\n                expressions.append(expr)\n    # Note that even if the group_by is set, it is only the minimal\n    # set to group by. So, we need to add cols in select, order_by, and\n    # having into the select in any case.\n    ref_sources = {\n        expr.source for expr in expressions if isinstance(expr, Ref)\n    }\n    for expr, _, _ in select:\n        # Skip members of the select clause that are already included\n        # by reference.\n        if expr in ref_sources:\n            continue\n        cols = expr.get_group_by_cols()\n        for col in cols:\n            expressions.append(col)\n    \n    # Get Meta.ordering expressions for comparison if needed\n    meta_ordering_exprs = set()\n    if self._meta_ordering and hasattr(self.query, 'get_meta'):\n        for ordering in self._meta_ordering:\n            try:\n                resolved_exprs = self.find_ordering_name(\n                    ordering, self.query.get_meta(), default_order='ASC'\n                )\n                for resolved_expr, _ in resolved_exprs:\n                    meta_ordering_exprs.add(id(resolved_expr))\n            except (FieldError, AttributeError):\n                continue\n    \n    for expr, (sql, params, is_ref) in order_by:\n        # Skip References to the select clause, as all expressions in the\n        # select clause are already part of the group by.\n        if not is_ref:\n            # Skip Meta.ordering fields from being added to GROUP BY\n            if self._meta_ordering and id(expr) in meta_ordering_exprs:\n                continue\n            expressions.extend(expr.get_group_by_cols())\n    having_group_by = self.having.get_group_by_cols() if self.having else ()\n    for expr in having_group_by:\n        expressions.append(expr)\n    result = []\n    seen = set()\n    expressions = self.collapse_group_by(expressions, having_group_by)\n\n    for expr in expressions:\n        sql, params = self.compile(expr)\n        sql, params = expr.select_format(self, sql, params)\n        params_hash = make_hashable(params)\n        if (sql, params_hash) not in seen:\n            result.append((sql, params))\n            seen.add((sql, params_hash))\n    return result\n",
    "Location 4 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 271-405)": "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.aggregate(Count('somecol'))\n        #     GROUP BY: []\n        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n        #     GROUP BY: name\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        # Note that the GROUP BY clause does not contain any ORDER BY clause\n        # columns.\n        if self.query.group_by is None:\n            return []\n        expressions = []\n        if self.query.group_by is not True:\n            # If the group by is set to a list (by .values() call most likely),\n            # then we need to add everything in it to the GROUP BY clause.\n            # Backwards compatibility hack for setting query.group_by. Remove\n            # when  we have public API way of forcing the GROUP BY clause.\n            # Converts string references to expressions.\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expressions.append(self.query.resolve_ref(expr))\n                else:\n                    expressions.append(expr)\n        else:\n            # Otherwise, we need to add the entire select list to the GROUP BY\n            # clause, except for aggregates.\n            for expr, _, _ in select:\n                cols = expr.get_group_by_cols()\n                for col in cols:\n                    expressions.append(col)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering\n                    # by comparing with the resolved Meta.ordering expressions\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        # This requires resolving Meta.ordering fields and comparing\n        for meta_field in self._meta_ordering:\n            # Resolve the meta ordering field to an expression\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        # Compare the SQL representation of the expressions\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
    "Location 5 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 42-42)": "\n        self._meta_ordering = None\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            # Resolve the meta ordering field to an expression\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        # Compare the SQL representation of the expressions\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 128-132)": [
      "\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering by comparing\n                    # with the default ordering fields from the model's Meta class\n                    is_meta_ordering_field = False\n                    try:\n                        model_meta = self.query.get_meta()\n                        if model_meta.ordering:\n                            for ordering_field in model_meta.ordering:\n                                # Remove leading '-' for descending order\n                                field_name = ordering_field.lstrip('-')\n                                # Compare field names - this handles most common cases\n                                if hasattr(expr, 'target') and hasattr(expr.target, 'name'):\n                                    if expr.target.name == field_name:\n                                        is_meta_ordering_field = True\n                                        break\n                                elif hasattr(expr, 'name') and expr.name == field_name:\n                                    is_meta_ordering_field = True\n                                    break\n                    except (AttributeError, FieldError):\n                        pass\n                    \n                    if not is_meta_ordering_field:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n",
      "\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # For Meta.ordering fields, don't add to GROUP BY as they can cause issues\n                    # with aggregation queries where these fields aren't selected\n                    continue\n                expressions.extend(expr.get_group_by_cols())\n",
      "\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering by comparing\n                    # with the original ordering fields from the model's Meta class\n                    is_meta_ordering = False\n                    try:\n                        # Get the model's Meta.ordering fields\n                        meta_ordering = self.query.get_meta().ordering or ()\n                        for meta_field in meta_ordering:\n                            # Resolve the meta ordering field to expressions\n                            meta_expr_list = self.find_ordering_name(\n                                meta_field, self.query.get_meta(), default_order='ASC'\n                            )\n                            for meta_expr, _ in meta_expr_list:\n                                # Compare expressions by their SQL representation\n                                try:\n                                    expr_sql, expr_params = self.compile(expr)\n                                    meta_sql, meta_params = self.compile(meta_expr)\n                                    if expr_sql == meta_sql and expr_params == meta_params:\n                                        is_meta_ordering = True\n                                        break\n                                except Exception:\n                                    continue\n                            if is_meta_ordering:\n                                break\n                    except (FieldError, AttributeError):\n                        is_meta_ordering = False\n                    \n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n",
      "\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n                if hasattr(self.query, 'annotation_select') and self.query.annotation_select and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering by comparing SQL output\n                    should_skip = False\n                    try:\n                        expr_sql, expr_params = self.compile(expr)\n                        # Get the original Meta.ordering fields to compare against\n                        meta_ordering = self.query.get_meta().ordering or ()\n                        for ordering_field in meta_ordering:\n                            field_name = ordering_field.lstrip('-')\n                            try:\n                                # Resolve the field to get its expression\n                                field_expr = self.query.resolve_ref(field_name, allow_joins=True, reuse=None, summarize=False)\n                                field_sql, field_params = self.compile(field_expr)\n                                if expr_sql == field_sql and expr_params == field_params:\n                                    should_skip = True\n                                    break\n                            except (FieldError, AttributeError):\n                                continue\n                    except Exception:\n                        should_skip = False\n                    \n                    if not should_skip:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n",
      "\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # For Meta.ordering fields, don't add to GROUP BY as they should\n                    # be excluded during aggregation queries\n                    continue\n                expressions.extend(expr.get_group_by_cols())\n",
      "\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering by comparing\n                    # with the original ordering fields from the model's Meta class\n                    is_meta_ordering = False\n                    try:\n                        # Get the model's Meta.ordering fields\n                        meta_ordering = self.query.get_meta().ordering or ()\n                        for meta_field in meta_ordering:\n                            # Strip the ordering direction prefix\n                            field_name = meta_field.lstrip('-')\n                            # Check if this expression corresponds to a Meta.ordering field\n                            if hasattr(expr, 'target') and hasattr(expr.target, 'name'):\n                                if expr.target.name == field_name:\n                                    is_meta_ordering = True\n                                    break\n                            elif hasattr(expr, 'source') and hasattr(expr.source, 'name'):\n                                if expr.source.name == field_name:\n                                    is_meta_ordering = True\n                                    break\n                    except (AttributeError, FieldError):\n                        pass\n                    \n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n",
      "\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                if hasattr(self.query, 'default_ordering') and self.query.default_ordering:\n                    # Check if this expression comes from Meta.ordering by comparing\n                    # with the model's default ordering fields\n                    is_meta_ordering = False\n                    try:\n                        meta = self.query.get_meta()\n                        if meta.ordering:\n                            for ordering_field in meta.ordering:\n                                # Remove desc prefix for comparison\n                                field_name = ordering_field.lstrip('-')\n                                # Check if this expression matches a Meta.ordering field\n                                if hasattr(expr, 'target') and hasattr(expr.target, 'name'):\n                                    if expr.target.name == field_name:\n                                        is_meta_ordering = True\n                                        break\n                                elif hasattr(expr, 'name') and expr.name == field_name:\n                                    is_meta_ordering = True\n                                    break\n                    except (AttributeError, FieldError):\n                        pass\n                    \n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n",
      "\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Don't add Meta.ordering expressions to GROUP BY\n                    continue\n                expressions.extend(expr.get_group_by_cols())\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 286-288)": [
      "\n        elif self.query.get_meta().ordering:\n            ordering = self.query.get_meta().ordering\n            self._meta_ordering = ordering\n",
      "\n        elif self.query.get_meta().ordering:\n            ordering = self.query.get_meta().ordering\n            self._meta_ordering = ordering\n",
      "\n        elif self.query.get_meta().ordering:\n            ordering = self.query.get_meta().ordering\n            self._meta_ordering = ordering\n",
      "\n        elif self.query.get_meta().ordering:\n            ordering = self.query.get_meta().ordering\n            self._meta_ordering = ordering\n",
      "\n        elif self.query.get_meta().ordering:\n            ordering = self.query.get_meta().ordering\n            self._meta_ordering = ordering\n",
      "\n        elif self.query.get_meta().ordering:\n            ordering = self.query.get_meta().ordering\n            self._meta_ordering = ordering\n",
      "\n        elif self.query.get_meta().ordering:\n            ordering = self.query.get_meta().ordering\n            self._meta_ordering = ordering\n",
      "\n        elif self.query.get_meta().ordering:\n            ordering = self.query.get_meta().ordering\n            self._meta_ordering = ordering\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 63-147)": [
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n        #    GROUP BY: name\n        #\n        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n        #    GROUP BY: all cols of the model\n        #\n        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n        # can't be ever restricted to a smaller set, but additional columns in\n        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n        # the end result is that it is impossible to force the query to have\n        # a chosen GROUP BY clause - you can almost do this by using the form:\n        #     .values(*wanted_cols).annotate(AnAggregate())\n        # but any later annotations, extra selects, values calls that\n        # refer some column outside of the wanted_cols, order_by, or even\n        # filter calls can alter the GROUP BY clause.\n\n        # The query.group_by is either None (no GROUP BY at all), True\n        # (group by select fields), or a list of expressions to be added\n        # to the group by.\n        if self.query.group_by is None:\n            return []\n        expressions = []\n        if self.query.group_by is not True:\n            # If the group by is set to a list (by .values() call most likely),\n            # then we need to add everything in it to the GROUP BY clause.\n            # Backwards compatibility hack for setting query.group_by. Remove\n            # when  we have public API way of forcing the GROUP BY clause.\n            # Converts string references to expressions.\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expressions.append(self.query.resolve_ref(expr))\n                else:\n                    expressions.append(expr)\n        # Note that even if the group_by is set, it is only the minimal\n        # set to group by. So, we need to add cols in select, order_by, and\n        # having into the select in any case.\n        ref_sources = {\n            expr.source for expr in expressions if isinstance(expr, Ref)\n        }\n        for expr, _, _ in select:\n            # Skip members of the select clause that are already included\n            # by reference.\n            if expr in ref_sources:\n                continue\n            cols = expr.get_group_by_cols()\n            for col in cols:\n                expressions.append(col)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                # when they come from the model's Meta.ordering and we have aggregation\n                if (self._meta_ordering and \n                    hasattr(self.query, 'annotation_select') and \n                    self.query.annotation_select and\n                    self._is_meta_ordering_expression(expr)):\n                    continue\n                expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            sql, params = expr.select_format(self, sql, params)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not self._meta_ordering:\n            return False\n        \n        # Get the SQL representation of the expression to compare\n        try:\n            expr_sql, expr_params = self.compile(expr)\n        except Exception:\n            return False\n            \n        # Compare with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    try:\n                        meta_sql, meta_params = self.compile(meta_expr)\n                        if expr_sql == meta_sql and expr_params == meta_params:\n                            return True\n                    except Exception:\n                        continue\n            except (FieldError, AttributeError):\n                continue\n        return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n        #    GROUP BY: name\n        #\n        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n        #    GROUP BY: all cols of the model\n        #\n        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n        # can't be ever restricted to a smaller set, but additional columns in\n        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n        # the end result is that it is impossible to force the query to have\n        # a chosen GROUP BY clause - you can almost do this by using the form:\n        #     .values(*wanted_cols).annotate(AnAggregate())\n        # but any later annotations, extra selects, values calls that\n        # refer some column outside of the wanted_cols, order_by, or even\n        # filter calls can alter the GROUP BY clause.\n\n        # The query.group_by is either None (no GROUP BY at all), True\n        # (group by select fields), or a list of expressions to be added\n        # to the group by.\n        if self.query.group_by is None:\n            return []\n        expressions = []\n        if self.query.group_by is not True:\n            # If the group by is set to a list (by .values() call most likely),\n            # then we need to add everything in it to the GROUP BY clause.\n            # Backwards compatibility hack for setting query.group_by. Remove\n            # when  we have public API way of forcing the GROUP BY clause.\n            # Converts string references to expressions.\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expressions.append(self.query.resolve_ref(expr))\n                else:\n                    expressions.append(expr)\n        # Note that even if the group_by is set, it is only the minimal\n        # set to group by. So, we need to add cols in select, order_by, and\n        # having into the select in any case.\n        ref_sources = {\n            expr.source for expr in expressions if isinstance(expr, Ref)\n        }\n        for expr, _, _ in select:\n            # Skip members of the select clause that are already included\n            # by reference.\n            if expr in ref_sources:\n                continue\n            cols = expr.get_group_by_cols()\n            for col in cols:\n                expressions.append(col)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n                if self._meta_ordering and self._is_meta_ordering_expression(expr):\n                    continue\n                expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            sql, params = expr.select_format(self, sql, params)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n        #    GROUP BY: name\n        #\n        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n        #    GROUP BY: all cols of the model\n        #\n        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n        # can't be ever restricted to a smaller set, but additional columns in\n        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n        # the end result is that it is impossible to force the query to have\n        # a chosen GROUP BY clause - you can almost do this by using the form:\n        #     .values(*wanted_cols).annotate(AnAggregate())\n        # but any later annotations, extra selects, values calls that\n        # refer some column outside of the wanted_cols, order_by, or even\n        # filter calls can alter the GROUP BY clause.\n\n        # The query.group_by is either None (no GROUP BY at all), True\n        # (group by select fields), or a list of expressions to be added\n        # to the group by.\n        if self.query.group_by is None:\n            return []\n        expressions = []\n        if self.query.group_by is not True:\n            # If the group by is set to a list (by .values() call most likely),\n            # then we need to add everything in it to the GROUP BY clause.\n            # Backwards compatibility hack for setting query.group_by. Remove\n            # when  we have public API way of forcing the GROUP BY clause.\n            # Converts string references to expressions.\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expressions.append(self.query.resolve_ref(expr))\n                else:\n                    expressions.append(expr)\n        # Note that even if the group_by is set, it is only the minimal\n        # set to group by. So, we need to add cols in select, order_by, and\n        # having into the select in any case.\n        ref_sources = {\n            expr.source for expr in expressions if isinstance(expr, Ref)\n        }\n        for expr, _, _ in select:\n            # Skip members of the select clause that are already included\n            # by reference.\n            if expr in ref_sources:\n                continue\n            cols = expr.get_group_by_cols()\n            for col in cols:\n                expressions.append(col)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                # when they would be cleared from ORDER BY anyway\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            sql, params = expr.select_format(self, sql, params)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n        #    GROUP BY: name\n        #\n        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n        #    GROUP BY: all cols of the model\n        #\n        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n        # can't be ever restricted to a smaller set, but additional columns in\n        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n        # the end result is that it is impossible to force the query to have\n        # a chosen GROUP BY clause - you can almost do this by using the form:\n        #     .values(*wanted_cols).annotate(AnAggregate())\n        # but any later annotations, extra selects, values calls that\n        # refer some column outside of the wanted_cols, order_by, or even\n        # filter calls can alter the GROUP BY clause.\n\n        # The query.group_by is either None (no GROUP BY at all), True\n        # (group by select fields), or a list of expressions to be added\n        # to the group by.\n        if self.query.group_by is None:\n            return []\n        expressions = []\n        if self.query.group_by is not True:\n            # If the group by is set to a list (by .values() call most likely),\n            # then we need to add everything in it to the GROUP BY clause.\n            # Backwards compatibility hack for setting query.group_by. Remove\n            # when  we have public API way of forcing the GROUP BY clause.\n            # Converts string references to expressions.\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expressions.append(self.query.resolve_ref(expr))\n                else:\n                    expressions.append(expr)\n        # Note that even if the group_by is set, it is only the minimal\n        # set to group by. So, we need to add cols in select, order_by, and\n        # having into the select in any case.\n        ref_sources = {\n            expr.source for expr in expressions if isinstance(expr, Ref)\n        }\n        for expr, _, _ in select:\n            # Skip members of the select clause that are already included\n            # by reference.\n            if expr in ref_sources:\n                continue\n            cols = expr.get_group_by_cols()\n            for col in cols:\n                expressions.append(col)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                # when they would be excluded from ORDER BY due to aggregation\n                if getattr(self, '_meta_ordering', None) and self.query.annotation_select:\n                    # Check if this expression comes from Meta.ordering\n                    # by comparing with the resolved Meta.ordering expressions\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            sql, params = expr.select_format(self, sql, params)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not getattr(self, '_meta_ordering', None):\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\ndef get_group_by(self, select, order_by):\n    \"\"\"\n    Return a list of 2-tuples of form (sql, params).\n\n    The logic of what exactly the GROUP BY clause contains is hard\n    to describe in other words than \"if it passes the test suite,\n    then it is correct\".\n    \"\"\"\n    # Some examples:\n    #     SomeModel.objects.annotate(Count('somecol'))\n    #     GROUP BY: all fields of the model\n    #\n    #    SomeModel.objects.values('name').annotate(Count('somecol'))\n    #    GROUP BY: name\n    #\n    #    SomeModel.objects.annotate(Count('somecol')).values('name')\n    #    GROUP BY: all cols of the model\n    #\n    #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n    #    GROUP BY: name, pk\n    #\n    #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n    #    GROUP BY: name, pk\n    #\n    # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n    # can't be ever restricted to a smaller set, but additional columns in\n    # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n    # the end result is that it is impossible to force the query to have\n    # a chosen GROUP BY clause - you can almost do this by using the form:\n    #     .values(*wanted_cols).annotate(AnAggregate())\n    # but any later annotations, extra selects, values calls that\n    # refer some column outside of the wanted_cols, order_by, or even\n    # filter calls can alter the GROUP BY clause.\n\n    # The query.group_by is either None (no GROUP BY at all), True\n    # (group by select fields), or a list of expressions to be added\n    # to the group by.\n    if self.query.group_by is None:\n        return []\n    expressions = []\n    if self.query.group_by is not True:\n        # If the group by is set to a list (by .values() call most likely),\n        # then we need to add everything in it to the GROUP BY clause.\n        # Backwards compatibility hack for setting query.group_by. Remove\n        # when  we have public API way of forcing the GROUP BY clause.\n        # Converts string references to expressions.\n        for expr in self.query.group_by:\n            if not hasattr(expr, 'as_sql'):\n                expressions.append(self.query.resolve_ref(expr))\n            else:\n                expressions.append(expr)\n    # Note that even if the group_by is set, it is only the minimal\n    # set to group by. So, we need to add cols in select, order_by, and\n    # having into the select in any case.\n    ref_sources = {\n        expr.source for expr in expressions if isinstance(expr, Ref)\n    }\n    for expr, _, _ in select:\n        # Skip members of the select clause that are already included\n        # by reference.\n        if expr in ref_sources:\n            continue\n        cols = expr.get_group_by_cols()\n        for col in cols:\n            expressions.append(col)\n    \n    # Get resolved Meta.ordering expressions for comparison\n    meta_ordering_exprs = set()\n    if self._meta_ordering:\n        for meta_field in self._meta_ordering:\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    meta_ordering_exprs.add(meta_expr)\n            except (FieldError, AttributeError):\n                continue\n    \n    for expr, (sql, params, is_ref) in order_by:\n        # Skip References to the select clause, as all expressions in the\n        # select clause are already part of the group by.\n        if not is_ref:\n            # Skip Meta.ordering fields from being added to GROUP BY\n            if self._meta_ordering and expr in meta_ordering_exprs:\n                continue\n            expressions.extend(expr.get_group_by_cols())\n    having_group_by = self.having.get_group_by_cols() if self.having else ()\n    for expr in having_group_by:\n        expressions.append(expr)\n    result = []\n    seen = set()\n    expressions = self.collapse_group_by(expressions, having_group_by)\n\n    for expr in expressions:\n        sql, params = self.compile(expr)\n        sql, params = expr.select_format(self, sql, params)\n        params_hash = make_hashable(params)\n        if (sql, params_hash) not in seen:\n            result.append((sql, params))\n            seen.add((sql, params_hash))\n    return result\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n        #    GROUP BY: name\n        #\n        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n        #    GROUP BY: all cols of the model\n        #\n        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n        # can't be ever restricted to a smaller set, but additional columns in\n        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n        # the end result is that it is impossible to force the query to have\n        # a chosen GROUP BY clause - you can almost do this by using the form:\n        #     .values(*wanted_cols).annotate(AnAggregate())\n        # but any later annotations, extra selects, values calls that\n        # refer some column outside of the wanted_cols, order_by, or even\n        # filter calls can alter the GROUP BY clause.\n\n        # The query.group_by is either None (no GROUP BY at all), True\n        # (group by select fields), or a list of expressions to be added\n        # to the group by.\n        if self.query.group_by is None:\n            return []\n        expressions = []\n        if self.query.group_by is not True:\n            # If the group by is set to a list (by .values() call most likely),\n            # then we need to add everything in it to the GROUP BY clause.\n            # Backwards compatibility hack for setting query.group_by. Remove\n            # when  we have public API way of forcing the GROUP BY clause.\n            # Converts string references to expressions.\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expressions.append(self.query.resolve_ref(expr))\n                else:\n                    expressions.append(expr)\n        # Note that even if the group_by is set, it is only the minimal\n        # set to group by. So, we need to add cols in select, order_by, and\n        # having into the select in any case.\n        ref_sources = {\n            expr.source for expr in expressions if isinstance(expr, Ref)\n        }\n        for expr, _, _ in select:\n            # Skip members of the select clause that are already included\n            # by reference.\n            if expr in ref_sources:\n                continue\n            cols = expr.get_group_by_cols()\n            for col in cols:\n                expressions.append(col)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            sql, params = expr.select_format(self, sql, params)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                # Resolve the meta ordering field to an expression\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n        #    GROUP BY: name\n        #\n        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n        #    GROUP BY: all cols of the model\n        #\n        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n        # can't be ever restricted to a smaller set, but additional columns in\n        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n        # the end result is that it is impossible to force the query to have\n        # a chosen GROUP BY clause - you can almost do this by using the form:\n        #     .values(*wanted_cols).annotate(AnAggregate())\n        # but any later annotations, extra selects, values calls that\n        # refer some column outside of the wanted_cols, order_by, or even\n        # filter calls can alter the GROUP BY clause.\n\n        # The query.group_by is either None (no GROUP BY at all), True\n        # (group by select fields), or a list of expressions to be added\n        # to the group by.\n        if self.query.group_by is None:\n            return []\n        expressions = []\n        if self.query.group_by is not True:\n            # If the group by is set to a list (by .values() call most likely),\n            # then we need to add everything in it to the GROUP BY clause.\n            # Backwards compatibility hack for setting query.group_by. Remove\n            # when  we have public API way of forcing the GROUP BY clause.\n            # Converts string references to expressions.\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expressions.append(self.query.resolve_ref(expr))\n                else:\n                    expressions.append(expr)\n        # Note that even if the group_by is set, it is only the minimal\n        # set to group by. So, we need to add cols in select, order_by, and\n        # having into the select in any case.\n        ref_sources = {\n            expr.source for expr in expressions if isinstance(expr, Ref)\n        }\n        for expr, _, _ in select:\n            # Skip members of the select clause that are already included\n            # by reference.\n            if expr in ref_sources:\n                continue\n            cols = expr.get_group_by_cols()\n            for col in cols:\n                expressions.append(col)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                # when they would be removed from ORDER BY anyway\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            sql, params = expr.select_format(self, sql, params)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                # Resolve the meta ordering field to an expression\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n        #    GROUP BY: name\n        #\n        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n        #    GROUP BY: all cols of the model\n        #\n        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n        #    GROUP BY: name, pk\n        #\n        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n        # can't be ever restricted to a smaller set, but additional columns in\n        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n        # the end result is that it is impossible to force the query to have\n        # a chosen GROUP BY clause - you can almost do this by using the form:\n        #     .values(*wanted_cols).annotate(AnAggregate())\n        # but any later annotations, extra selects, values calls that\n        # refer some column outside of the wanted_cols, order_by, or even\n        # filter calls can alter the GROUP BY clause.\n\n        # The query.group_by is either None (no GROUP BY at all), True\n        # (group by select fields), or a list of expressions to be added\n        # to the group by.\n        if self.query.group_by is None:\n            return []\n        expressions = []\n        if self.query.group_by is not True:\n            # If the group by is set to a list (by .values() call most likely),\n            # then we need to add everything in it to the GROUP BY clause.\n            # Backwards compatibility hack for setting query.group_by. Remove\n            # when  we have public API way of forcing the GROUP BY clause.\n            # Converts string references to expressions.\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expressions.append(self.query.resolve_ref(expr))\n                else:\n                    expressions.append(expr)\n        # Note that even if the group_by is set, it is only the minimal\n        # set to group by. So, we need to add cols in select, order_by, and\n        # having into the select in any case.\n        ref_sources = {\n            expr.source for expr in expressions if isinstance(expr, Ref)\n        }\n        for expr, _, _ in select:\n            # Skip members of the select clause that are already included\n            # by reference.\n            if expr in ref_sources:\n                continue\n            cols = expr.get_group_by_cols()\n            for col in cols:\n                expressions.append(col)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                # when they come from the model's Meta.ordering and we have aggregates\n                if (hasattr(self, '_meta_ordering') and self._meta_ordering and \n                    self.query.annotations):\n                    # Check if this expression comes from Meta.ordering\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            sql, params = expr.select_format(self, sql, params)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 271-405)": [
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.aggregate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n        #     GROUP BY: name\n        #\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all cols of the model\n        #\n        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n        #     GROUP BY: name\n        #\n        #     SomeModel.objects.values('name').select_related('o').annotate(Count('somecol'))\n        #     GROUP BY: o.name, o.pk\n        #\n        #     SomeModel.objects.annotate(Count('somecol')).values('name')\n        #     GROUP BY: all cols of the model\n        expressions = []\n        if self.query.group_by is not None:\n            for expr in self.query.group_by:\n                sql, params = self.compile(expr)\n                expressions.append((sql, params))\n        elif self.query.default_cols:\n            for expr in self.query.select:\n                cols = expr.get_group_by_cols()\n                for col in cols:\n                    expressions.append(self.compile(col))\n        elif self.query.select:\n            # If the query has select expressions, use them for group by.\n            for expr in self.query.select:\n                cols = expr.get_group_by_cols()\n                for col in cols:\n                    expressions.append(self.compile(col))\n        elif self.select:\n            for expr, _, _ in self.select:\n                cols = expr.get_group_by_cols()\n                for col in cols:\n                    expressions.append(self.compile(col))\n\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(self.compile(expr))\n\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for sql, params in expressions:\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.aggregate(Count('somecol'))\n        #     GROUP BY: []\n        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n        #     GROUP BY: name\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        # Note that the GROUP BY clause does not contain any ORDER BY clause\n        # columns.\n        if self.query.group_by is None:\n            return []\n        expressions = []\n        if self.query.group_by is not True:\n            # If the group by is set to a list (by .values() call most likely),\n            # then we need to add everything in it to the GROUP BY clause.\n            # Backwards compatibility hack for setting query.group_by. Remove\n            # when  we have public API way of forcing the GROUP BY clause.\n            # Converts string references to expressions.\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expressions.append(self.query.resolve_ref(expr))\n                else:\n                    expressions.append(expr)\n        else:\n            # Otherwise, we need to add all the select clause columns.\n            expressions.extend(self.query.select)\n            if self.query.annotations:\n                for annotation in self.query.annotations.values():\n                    expressions.append(annotation)\n            for expr, (sql, params, is_ref) in order_by:\n                # Skip References to the select clause, as all expressions in the\n                # select clause are already part of the group by.\n                if not is_ref:\n                    # Skip Meta.ordering fields from being added to GROUP BY\n                    if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                        # Check if this expression comes from Meta.ordering\n                        # by comparing with the resolved Meta.ordering expressions\n                        is_meta_ordering = self._is_meta_ordering_expression(expr)\n                        if not is_meta_ordering:\n                            expressions.extend(expr.get_group_by_cols())\n                    else:\n                        expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (expr, (sql, params)) for the\n        GROUP BY clause.\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.values('foo').annotate(Count('pk'))\n        #     GROUP BY: foo\n        #     SomeModel.objects.annotate(Count('pk')).values('foo')\n        #     GROUP BY: foo\n        #     SomeModel.objects.values('foo').annotate(Count('pk')).values('pk')\n        #     GROUP BY: foo\n        #     SomeModel.objects.values('foo').annotate(Count('pk')).distinct()\n        #     GROUP BY: foo, pk\n        #     SomeModel.objects.values('foo').annotate(Count('pk')).order_by('pk')\n        #     GROUP BY: foo, pk\n        #     SomeModel.objects.annotate(Count('pk')).distinct().order_by('pk')\n        #     GROUP BY: pk\n\n        expressions = []\n        if self.query.group_by is not None:\n            if len(self.query.group_by) == 1 and isinstance(self.query.group_by[0], tuple):\n                expressions.append(self.query.group_by[0])\n            else:\n                for expr in self.query.group_by:\n                    if not hasattr(expr, 'as_sql'):\n                        expressions.append(self.query.resolve_ref(expr))\n                    else:\n                        expressions.append(expr)\n        # Unconditionally add the select list to the group by. This will mean\n        # we're doing more work than is needed in many cases, but it keeps\n        # things simple.\n        for expr, _, _ in select:\n            col = expr\n            for src in col.get_source_expressions():\n                if isinstance(src, Ref):\n                    col = src.source\n                    break\n            expressions.append(col)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering\n                    # by comparing with the resolved Meta.ordering expressions\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((expr, (sql, params)))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            # Resolve the meta ordering field to an expression\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        # Compare the SQL representation of the expressions\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.aggregate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n        #     GROUP BY: name\n        #\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all cols of the model\n        #\n        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n        #     GROUP BY: name\n        #\n        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n        #     GROUP BY: name\n\n        expressions = []\n        if self.query.group_by is not None:\n            for expr, having in self.query.group_by:\n                sql, params = self.compile(expr)\n                expressions.append((sql, params))\n        elif self.query.default_cols:\n            for expr, (sql, params), alias in select:\n                expressions.append((sql, params))\n        else:\n            for expr, (sql, params), alias in select:\n                sql_params = expr.get_group_by_cols(alias=alias)\n                expressions.extend(sql_params)\n            for expr, (sql, params, is_ref) in order_by:\n                # Skip References to the select clause, as all expressions in the\n                # select clause are already part of the group by.\n                if not is_ref:\n                    # Skip Meta.ordering fields from being added to GROUP BY\n                    if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                        # Check if this expression comes from Meta.ordering\n                        is_meta_ordering = self._is_meta_ordering_expression(expr)\n                        if not is_meta_ordering:\n                            expressions.extend(expr.get_group_by_cols())\n                    else:\n                        expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for sql, params in expressions:\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                # Resolve the meta ordering field to expressions\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.aggregate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n        #     GROUP BY: name\n        #\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all cols of the model\n        #\n        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n        #     GROUP BY: name\n        #\n        #     SomeModel.objects.values('name').select_related('o').annotate(Count('somecol'))\n        #     GROUP BY: name, o.id\n        #\n        #     SomeModel.objects.values('name').annotate(Count('somecol')).values('name', 'somecol__count')\n        #     GROUP BY: name\n        #\n        # So basically, if we have a model with no values() call, we group\n        # by all fields, including pk, of the model. If we have a values()\n        # call we group by the given fields.\n        #\n        # There is one exception to the rule: if the model_log.objects.values('name').annotate(Count('somecol'))\n        # query has select_related() the group by should contain the foreign key to the\n        # joined model.\n\n        expressions = []\n        if self.query.group_by is not None:\n            select_cols = []\n            for expr, _, _ in select:\n                cols = expr.get_group_by_cols()\n                select_cols.extend(cols)\n            expressions = list({make_hashable(col): col for col in select_cols}.values())\n        elif self.query.default_ordering:\n            for expr, (sql, params, is_ref) in order_by:\n                # Skip References to the select clause, as all expressions in the\n                # select clause are already part of the group by.\n                if not is_ref:\n                    expressions.extend(expr.get_group_by_cols())\n        elif self.query.select:\n            select_cols = []\n            for expr, _, _ in select:\n                cols = expr.get_group_by_cols()\n                select_cols.extend(cols)\n            expressions = list({make_hashable(col): col for col in select_cols}.values())\n        else:\n            expressions = [\n                self.query.get_meta().pk.get_col(self.query.get_initial_alias())\n            ]\n        # Expressions selected by the user that are not aggregate functions\n        # need to be added to the GROUP BY clause.\n        for expr, _, _ in select:\n            cols = expr.get_group_by_cols()\n            expressions.extend(cols)\n\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                # when they come from model's Meta.ordering\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                # Resolve the meta ordering field to expressions\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            # Compare the source expressions if they exist\n            if hasattr(expr1, 'get_source_expressions') and hasattr(expr2, 'get_source_expressions'):\n                expr1_sources = expr1.get_source_expressions()\n                expr2_sources = expr2.get_source_expressions()\n                if len(expr1_sources) == 1 and len(expr2_sources) == 1:\n                    return self._expressions_equivalent(expr1_sources[0], expr2_sources[0])\n            \n            # Compare SQL representation\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.aggregate(Count('somecol'))\n        #     GROUP BY: none\n        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n        #     GROUP BY: name\n        #     SomeModel.objects.annotate(Count('somecol')).values('pk')\n        #     GROUP BY: pk\n        #     SomeModel.objects.annotate(Count('somecol')).values('name')\n        #     GROUP BY: name\n        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n        #     GROUP BY: name\n\n        expressions = []\n        if self.query.group_by is not None:\n            expressions.extend(self.query.group_by)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering\n                    # by comparing with the resolved Meta.ordering expressions\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n\n        for expr, (sql, params, is_ref) in select:\n            cols = expr.get_group_by_cols()\n            for col in cols:\n                expressions.append(col)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having=self.having)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            # Resolve the meta ordering field to an expression\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        # Compare the SQL representation of the expressions\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.aggregate(Count('somecol'))\n        #     GROUP BY: []\n        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n        #     GROUP BY: name\n        #     SomeModel.objects.annotate(Count('somecol')).values('pk')\n        #     GROUP BY: pk\n        #     SomeModel.objects.annotate(Count('somecol')).values('name')\n        #     GROUP BY: name\n        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n        #     GROUP BY: name\n        #     SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n        #     GROUP BY: pk\n        #     SomeModel.objects.values('name').annotate(Count('somecol')).values('name', 'pk')\n        #     GROUP BY: name, pk\n\n        expressions = []\n        if self.query.group_by is not None:\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expressions.append(self.query.resolve_ref(expr, allow_joins=True, reuse=None))\n                else:\n                    expressions.append(expr)\n        else:\n            for expr, _, _ in select:\n                cols = expr.get_group_by_cols()\n                for col in cols:\n                    expressions.append(col)\n            for expr, (sql, params, is_ref) in order_by:\n                # Skip References to the select clause, as all expressions in the\n                # select clause are already part of the group by.\n                if not is_ref:\n                    # Skip Meta.ordering fields from being added to GROUP BY\n                    if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                        # Check if this expression comes from Meta.ordering\n                        is_meta_ordering = self._is_meta_ordering_expression(expr)\n                        if not is_meta_ordering:\n                            expressions.extend(expr.get_group_by_cols())\n                    else:\n                        expressions.extend(expr.get_group_by_cols())\n\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having=self.having)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of what exactly the GROUP BY clause contains is hard\n        to describe in other words than \"if it passes the test suite,\n        then it is correct\".\n        \"\"\"\n        # Some examples:\n        #     SomeModel.objects.aggregate(Count('somecol'))\n        #     GROUP BY: all fields of the model\n        #\n        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n        #     GROUP BY: name\n        #\n        #     SomeModel.objects.annotate(Count('somecol'))\n        #     GROUP BY: all cols of the model\n        #\n        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n        #     GROUP BY: name\n        #\n        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n        #     GROUP BY: name\n\n        expressions = []\n        if self.query.group_by is not None:\n            expressions.extend(self.query.group_by)\n        for expr, (sql, params, is_ref) in select:\n            cols = expr.get_group_by_cols()\n            for col in cols:\n                expressions.append(col)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n        having_group_by = self.having.get_group_by_cols() if self.having else ()\n        for expr in having_group_by:\n            expressions.append(expr)\n\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n"
    ],
    "Location 5 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 42-42)": [
      "\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        # This requires resolving Meta.ordering fields and comparing\n        for meta_field in self._meta_ordering:\n            # Resolve the meta ordering field to an expression\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        # Compare the SQL representation of the expressions\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        # This requires resolving Meta.ordering fields and comparing\n        for meta_field in self._meta_ordering:\n            # Resolve the meta ordering field to an expression\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        # Compare the SQL representation of the expressions\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of query.group_by is: if the GROUP BY clause is empty, then\n        the query is not grouped. If the GROUP BY clause is not empty, then\n        all expressions in the SELECT clause that are not aggregates must\n        appear in the GROUP BY clause.\n        \"\"\"\n        if self.query.group_by is None:\n            return []\n        expressions = []\n        if self.query.group_by is not True:\n            # If the group by is set to a list (by .values() call most likely),\n            # then we need to add everything in it to the GROUP BY clause.\n            # Backwards compatibility hack for setting query.group_by. Remove\n            # when we have public API way of forcing the GROUP BY clause.\n            # Converts string references to expressions.\n            for expr in self.query.group_by:\n                if not hasattr(expr, 'as_sql'):\n                    expr = self.query.resolve_ref(expr)\n                expressions.append(expr)\n        # Note that even if the group_by is set, it is only the minimal\n        # set to group by. So, we need to add cols in select, order_by, and\n        # having into the select in any case.\n        ref_sources = {\n            expr.source for expr in expressions if isinstance(expr, Ref)\n        }\n        for expr, (sql, params, is_ref) in select:\n            cols = expr.get_group_by_cols()\n            for col in cols:\n                expressions.append(col)\n                ref_sources.add(col)\n        if not self._meta_ordering:\n            for expr, (sql, params, is_ref) in order_by:\n                # Skip References to the select clause, as all expressions in the\n                # select clause are already part of the group by.\n                if not is_ref:\n                    expressions.extend(expr.get_group_by_cols())\n        for expr in self.query.where.get_group_by_cols():\n            expressions.append(expr)\n        for expr in self.query.having.get_group_by_cols():\n            expressions.append(expr)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            sql, params = expr.select_format(self, sql, params)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of form (sql, params).\n\n        The logic of query.group_by is: if it's an iterable, use that as the\n        group_by, if it's a boolean and it's set, use the query's select (if a\n        select clause exists) and the order by. If it's an empty list, do\n        nothing.\n        \"\"\"\n        if not order_by:\n            order_by = []\n        if not select:\n            select = []\n        expressions = []\n        if self.query.group_by is not None:\n            if len(self.query.group_by) == 0:\n                return []\n            if not isinstance(self.query.group_by, (list, tuple)):\n                expressions.extend(select)\n        for expr, (sql, params, is_ref) in order_by:\n            # Skip References to the select clause, as all expressions in the\n            # select clause are already part of the group by.\n            if not is_ref:\n                # Skip Meta.ordering fields from being added to GROUP BY\n                if self._meta_ordering:\n                    # Check if this expression comes from Meta.ordering\n                    # by comparing with the resolved Meta.ordering expressions\n                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n                    if not is_meta_ordering:\n                        expressions.extend(expr.get_group_by_cols())\n                else:\n                    expressions.extend(expr.get_group_by_cols())\n\n        if isinstance(self.query.group_by, (list, tuple)):\n            expressions.extend(self.query.group_by)\n        result = []\n        seen = set()\n        expressions = self.collapse_group_by(expressions, having_group_by)\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        # This requires resolving Meta.ordering fields and comparing\n        for meta_field in self._meta_ordering:\n            # Resolve the meta ordering field to an expression\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        # Compare the SQL representation of the expressions\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        # This requires resolving Meta.ordering fields and comparing\n        for meta_field in self._meta_ordering:\n            # Resolve the meta ordering field to an expression\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        # Compare the SQL representation of the expressions\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def __init__(self, query, connection, using):\n        self.query = query\n        self.connection = connection\n        self.using = using\n        self.quote_cache = {'*': '*'}\n        # The select, klass_info, and annotations are needed by QuerySet.iterator()\n        # these are set as a side-effect of executing the query. Note that we calculate\n        # separately a list of extra select columns needed for grammatical correctness\n        # of the query, but these columns are not included in self.select.\n        self.select = None\n        self.annotation_col_map = None\n        self.klass_info = None\n        self._meta_ordering = None\n",
      "\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        for meta_field in self._meta_ordering:\n            # Resolve the meta ordering field to an expression\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        # Compare the SQL representation of the expressions\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n",
      "\n    def get_group_by(self, select, order_by):\n        \"\"\"\n        Return a list of 2-tuples of the form (sql, params).\n\n        The logic of query.group_by is: if it's a grouping query (distinct(),\n        values(), etc.), then we must have a group_by clause which includes\n        anything mentioned in select (except for aggregates). If the query\n        doesn't use grouping, then there should not be a subject, and\n        furthermore, we must discard any ORDER BY clause which could refer\n        to things not in the SELECT (since such ordering would be undefined).\n        \"\"\"\n        result = []\n        seen = set()\n        expressions = []\n        if self.query.group_by is not None:\n            select_cols = []\n            for expr, _, _ in select:\n                cols = expr.get_group_by_cols()\n                for col in cols:\n                    expressions.append(col)\n                    select_cols.append(col)\n\n            if not self.query.group_by:\n                # If the query does not use grouping, then reject any ORDER BY\n                # clause which could refer to things not in the SELECT (since\n                # such ordering would be undefined).\n                for expr, (sql, params, is_ref) in order_by:\n                    # Skip References to the select clause, as all expressions in the\n                    # select clause are already part of the group by.\n                    if not is_ref:\n                        expressions.extend(expr.get_group_by_cols())\n            else:\n                for expr in self.query.group_by:\n                    if isinstance(expr, str):\n                        expressions.append(self.query.resolve_ref(expr))\n                    else:\n                        expressions.append(expr)\n\n        elif order_by:\n            # A grouping query is used; Group by stuff must not contain non-aggregate\n            # values.\n            for expr, (sql, params, is_ref) in order_by:\n                # Skip References to the select clause, as all expressions in the\n                # select clause are already part of the group by.\n                if not is_ref:\n                    # Skip Meta.ordering fields from being added to GROUP BY\n                    if self._meta_ordering:\n                        # Check if this expression comes from Meta.ordering\n                        # by comparing with the resolved Meta.ordering expressions\n                        is_meta_ordering = self._is_meta_ordering_expression(expr)\n                        if not is_meta_ordering:\n                            expressions.extend(expr.get_group_by_cols())\n                    else:\n                        expressions.extend(expr.get_group_by_cols())\n\n        for expr in expressions:\n            sql, params = self.compile(expr)\n            params_hash = make_hashable(params)\n            if (sql, params_hash) not in seen:\n                result.append((sql, params))\n                seen.add((sql, params_hash))\n        return result\n\n    def _is_meta_ordering_expression(self, expr):\n        \"\"\"\n        Check if the given expression comes from Meta.ordering.\n        This helps exclude Meta.ordering fields from GROUP BY clauses.\n        \"\"\"\n        if not self._meta_ordering:\n            return False\n        \n        # Compare the expression with Meta.ordering field expressions\n        # This requires resolving Meta.ordering fields and comparing\n        for meta_field in self._meta_ordering:\n            # Resolve the meta ordering field to an expression\n            try:\n                meta_expr_list = self.find_ordering_name(\n                    meta_field, self.query.get_meta(), default_order='ASC'\n                )\n                for meta_expr, _ in meta_expr_list:\n                    if self._expressions_equivalent(expr, meta_expr):\n                        return True\n            except (FieldError, AttributeError):\n                continue\n        return False\n\n    def _expressions_equivalent(self, expr1, expr2):\n        \"\"\"\n        Check if two expressions are equivalent for GROUP BY purposes.\n        \"\"\"\n        # Compare the SQL representation of the expressions\n        try:\n            sql1, params1 = self.compile(expr1)\n            sql2, params2 = self.compile(expr2)\n            return sql1 == sql2 and params1 == params2\n        except Exception:\n            return False\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..2c1bb0c880 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -40,6 +40,7 @@ class SQLCompiler:\n         self.klass_info = None\n         self._meta_ordering = None\n \n+\n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n             self.query.get_initial_alias()\n@@ -60,6 +61,7 @@ class SQLCompiler:\n         group_by = self.get_group_by(self.select + extra_select, order_by)\n         return extra_select, order_by, group_by\n \n+\n     def get_group_by(self, select, order_by):\n         \"\"\"\n         Return a list of 2-tuples of form (sql, params).\n@@ -129,7 +131,15 @@ class SQLCompiler:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n             if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                if self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    # by comparing with the resolved Meta.ordering expressions\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n@@ -146,6 +156,50 @@ class SQLCompiler:\n                 seen.add((sql, params_hash))\n         return result\n \n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        # This requires resolving Meta.ordering fields and comparing\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n+\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n+            sql, params = expr.select_format(self, sql, params)\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n     def collapse_group_by(self, expressions, having):\n         # If the DB can group by primary key, then group by the primary key of\n         # query's main model. Note that for PostgreSQL the GROUP BY clause must\n@@ -268,6 +322,7 @@ class SQLCompiler:\n             ret.append((col, (sql, params), alias))\n         return ret, klass_info, annotations\n \n+\n     def get_order_by(self):\n         \"\"\"\n         Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n@@ -403,6 +458,7 @@ class SQLCompiler:\n             seen.add((without_ordering, params_hash))\n             result.append((resolved, (sql, params, is_ref)))\n         return result\n+        return result\n \n     def get_extra_select(self, order_by, select):\n         extra_select = []\n",
    "variant_0": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..cecf6a261c 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -40,6 +40,41 @@ class SQLCompiler:\n         self.klass_info = None\n         self._meta_ordering = None\n \n+        self._meta_ordering = None\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n             self.query.get_initial_alias()\n@@ -60,86 +95,109 @@ class SQLCompiler:\n         group_by = self.get_group_by(self.select + extra_select, order_by)\n         return extra_select, order_by, group_by\n \n-    def get_group_by(self, select, order_by):\n-        \"\"\"\n-        Return a list of 2-tuples of form (sql, params).\n \n-        The logic of what exactly the GROUP BY clause contains is hard\n-        to describe in other words than \"if it passes the test suite,\n-        then it is correct\".\n-        \"\"\"\n-        # Some examples:\n-        #     SomeModel.objects.annotate(Count('somecol'))\n-        #     GROUP BY: all fields of the model\n-        #\n-        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n-        #    GROUP BY: name\n-        #\n-        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n-        #    GROUP BY: all cols of the model\n-        #\n-        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n-        #    GROUP BY: name, pk\n-        #\n-        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n-        #    GROUP BY: name, pk\n-        #\n-        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n-        # can't be ever restricted to a smaller set, but additional columns in\n-        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n-        # the end result is that it is impossible to force the query to have\n-        # a chosen GROUP BY clause - you can almost do this by using the form:\n-        #     .values(*wanted_cols).annotate(AnAggregate())\n-        # but any later annotations, extra selects, values calls that\n-        # refer some column outside of the wanted_cols, order_by, or even\n-        # filter calls can alter the GROUP BY clause.\n-\n-        # The query.group_by is either None (no GROUP BY at all), True\n-        # (group by select fields), or a list of expressions to be added\n-        # to the group by.\n-        if self.query.group_by is None:\n-            return []\n-        expressions = []\n-        if self.query.group_by is not True:\n-            # If the group by is set to a list (by .values() call most likely),\n-            # then we need to add everything in it to the GROUP BY clause.\n-            # Backwards compatibility hack for setting query.group_by. Remove\n-            # when  we have public API way of forcing the GROUP BY clause.\n-            # Converts string references to expressions.\n-            for expr in self.query.group_by:\n-                if not hasattr(expr, 'as_sql'):\n-                    expressions.append(self.query.resolve_ref(expr))\n-                else:\n-                    expressions.append(expr)\n-        # Note that even if the group_by is set, it is only the minimal\n-        # set to group by. So, we need to add cols in select, order_by, and\n-        # having into the select in any case.\n-        ref_sources = {\n-            expr.source for expr in expressions if isinstance(expr, Ref)\n-        }\n-        for expr, _, _ in select:\n-            # Skip members of the select clause that are already included\n-            # by reference.\n-            if expr in ref_sources:\n-                continue\n-            cols = expr.get_group_by_cols()\n-            for col in cols:\n-                expressions.append(col)\n-        for expr, (sql, params, is_ref) in order_by:\n-            # Skip References to the select clause, as all expressions in the\n-            # select clause are already part of the group by.\n-            if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n-        having_group_by = self.having.get_group_by_cols() if self.having else ()\n-        for expr in having_group_by:\n-            expressions.append(expr)\n-        result = []\n-        seen = set()\n-        expressions = self.collapse_group_by(expressions, having_group_by)\n+def get_group_by(self, select, order_by):\n+    \"\"\"\n+    Return a list of 2-tuples of form (sql, params).\n \n-        for expr in expressions:\n-            sql, params = self.compile(expr)\n-            sql, params = expr.select_format(self, sql, params)\n+    The logic of what exactly the GROUP BY clause contains is hard\n+    to describe in other words than \"if it passes the test suite,\n+    then it is correct\".\n+    \"\"\"\n+    # Some examples:\n+    #     SomeModel.objects.annotate(Count('somecol'))\n+    #     GROUP BY: all fields of the model\n+    #\n+    #    SomeModel.objects.values('name').annotate(Count('somecol'))\n+    #    GROUP BY: name\n+    #\n+    #    SomeModel.objects.annotate(Count('somecol')).values('name')\n+    #    GROUP BY: all cols of the model\n+    #\n+    #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n+    #    GROUP BY: name, pk\n+    #\n+    #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n+    #    GROUP BY: name, pk\n+    #\n+    # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n+    # can't be ever restricted to a smaller set, but additional columns in\n+    # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n+    # the end result is that it is impossible to force the query to have\n+    # a chosen GROUP BY clause - you can almost do this by using the form:\n+    #     .values(*wanted_cols).annotate(AnAggregate())\n+    # but any later annotations, extra selects, values calls that\n+    # refer some column outside of the wanted_cols, order_by, or even\n+    # filter calls can alter the GROUP BY clause.\n+\n+    # The query.group_by is either None (no GROUP BY at all), True\n+    # (group by select fields), or a list of expressions to be added\n+    # to the group by.\n+    if self.query.group_by is None:\n+        return []\n+    expressions = []\n+    if self.query.group_by is not True:\n+        # If the group by is set to a list (by .values() call most likely),\n+        # then we need to add everything in it to the GROUP BY clause.\n+        # Backwards compatibility hack for setting query.group_by. Remove\n+        # when  we have public API way of forcing the GROUP BY clause.\n+        # Converts string references to expressions.\n+        for expr in self.query.group_by:\n+            if not hasattr(expr, 'as_sql'):\n+                expressions.append(self.query.resolve_ref(expr))\n+            else:\n+                expressions.append(expr)\n+    # Note that even if the group_by is set, it is only the minimal\n+    # set to group by. So, we need to add cols in select, order_by, and\n+    # having into the select in any case.\n+    ref_sources = {\n+        expr.source for expr in expressions if isinstance(expr, Ref)\n+    }\n+    for expr, _, _ in select:\n+        # Skip members of the select clause that are already included\n+        # by reference.\n+        if expr in ref_sources:\n+            continue\n+        cols = expr.get_group_by_cols()\n+        for col in cols:\n+            expressions.append(col)\n+    \n+    # Get Meta.ordering expressions for comparison if needed\n+    meta_ordering_exprs = set()\n+    if self._meta_ordering and hasattr(self.query, 'get_meta'):\n+        for ordering in self._meta_ordering:\n+            try:\n+                resolved_exprs = self.find_ordering_name(\n+                    ordering, self.query.get_meta(), default_order='ASC'\n+                )\n+                for resolved_expr, _ in resolved_exprs:\n+                    meta_ordering_exprs.add(id(resolved_expr))\n+            except (FieldError, AttributeError):\n+                continue\n+    \n+    for expr, (sql, params, is_ref) in order_by:\n+        # Skip References to the select clause, as all expressions in the\n+        # select clause are already part of the group by.\n+        if not is_ref:\n+            # Skip Meta.ordering fields from being added to GROUP BY\n+            if self._meta_ordering and id(expr) in meta_ordering_exprs:\n+                continue\n+            expressions.extend(expr.get_group_by_cols())\n+    having_group_by = self.having.get_group_by_cols() if self.having else ()\n+    for expr in having_group_by:\n+        expressions.append(expr)\n+    result = []\n+    seen = set()\n+    expressions = self.collapse_group_by(expressions, having_group_by)\n+\n+    for expr in expressions:\n+        sql, params = self.compile(expr)\n+        sql, params = expr.select_format(self, sql, params)\n+        params_hash = make_hashable(params)\n+        if (sql, params_hash) not in seen:\n+            result.append((sql, params))\n+            seen.add((sql, params_hash))\n+    return result\n             params_hash = make_hashable(params)\n             if (sql, params_hash) not in seen:\n                 result.append((sql, params))\n@@ -268,140 +326,109 @@ class SQLCompiler:\n             ret.append((col, (sql, params), alias))\n         return ret, klass_info, annotations\n \n-    def get_order_by(self):\n+\n+    def get_group_by(self, select, order_by):\n         \"\"\"\n-        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n-        ORDER BY clause.\n+        Return a list of 2-tuples of form (sql, params).\n \n-        The order_by clause can alter the select clause (for example it\n-        can add aliases to clauses that do not yet have one, or it can\n-        add totally new select clauses).\n+        The logic of what exactly the GROUP BY clause contains is hard\n+        to describe in other words than \"if it passes the test suite,\n+        then it is correct\".\n         \"\"\"\n-        if self.query.extra_order_by:\n-            ordering = self.query.extra_order_by\n-        elif not self.query.default_ordering:\n-            ordering = self.query.order_by\n-        elif self.query.order_by:\n-            ordering = self.query.order_by\n-        elif self.query.get_meta().ordering:\n-            ordering = self.query.get_meta().ordering\n-            self._meta_ordering = ordering\n-        else:\n-            ordering = []\n-        if self.query.standard_ordering:\n-            asc, desc = ORDER_DIR['ASC']\n+        # Some examples:\n+        #     SomeModel.objects.aggregate(Count('somecol'))\n+        #     GROUP BY: []\n+        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n+        #     GROUP BY: name\n+        #     SomeModel.objects.annotate(Count('somecol'))\n+        #     GROUP BY: all fields of the model\n+        #\n+        # Note that the GROUP BY clause does not contain any ORDER BY clause\n+        # columns.\n+        if self.query.group_by is None:\n+            return []\n+        expressions = []\n+        if self.query.group_by is not True:\n+            # If the group by is set to a list (by .values() call most likely),\n+            # then we need to add everything in it to the GROUP BY clause.\n+            # Backwards compatibility hack for setting query.group_by. Remove\n+            # when  we have public API way of forcing the GROUP BY clause.\n+            # Converts string references to expressions.\n+            for expr in self.query.group_by:\n+                if not hasattr(expr, 'as_sql'):\n+                    expressions.append(self.query.resolve_ref(expr))\n+                else:\n+                    expressions.append(expr)\n         else:\n-            asc, desc = ORDER_DIR['DESC']\n-\n-        order_by = []\n-        for field in ordering:\n-            if hasattr(field, 'resolve_expression'):\n-                if isinstance(field, Value):\n-                    # output_field must be resolved for constants.\n-                    field = Cast(field, field.output_field)\n-                if not isinstance(field, OrderBy):\n-                    field = field.asc()\n-                if not self.query.standard_ordering:\n-                    field = field.copy()\n-                    field.reverse_ordering()\n-                order_by.append((field, False))\n-                continue\n-            if field == '?':  # random\n-                order_by.append((OrderBy(Random()), False))\n-                continue\n-\n-            col, order = get_order_dir(field, asc)\n-            descending = order == 'DESC'\n-\n-            if col in self.query.annotation_select:\n-                # Reference to expression in SELECT clause\n-                order_by.append((\n-                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n-                    True))\n-                continue\n-            if col in self.query.annotations:\n-                # References to an expression which is masked out of the SELECT\n-                # clause.\n-                if self.query.combinator and self.select:\n-                    # Don't use the resolved annotation because other\n-                    # combinated queries might define it differently.\n-                    expr = F(col)\n+            # Otherwise, we need to add the entire select list to the GROUP BY\n+            # clause, except for aggregates.\n+            for expr, _, _ in select:\n+                cols = expr.get_group_by_cols()\n+                for col in cols:\n+                    expressions.append(col)\n+        for expr, (sql, params, is_ref) in order_by:\n+            # Skip References to the select clause, as all expressions in the\n+            # select clause are already part of the group by.\n+            if not is_ref:\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    # by comparing with the resolved Meta.ordering expressions\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n                 else:\n-                    expr = self.query.annotations[col]\n-                    if isinstance(expr, Value):\n-                        # output_field must be resolved for constants.\n-                        expr = Cast(expr, expr.output_field)\n-                order_by.append((OrderBy(expr, descending=descending), False))\n-                continue\n+                    expressions.extend(expr.get_group_by_cols())\n \n-            if '.' in field:\n-                # This came in through an extra(order_by=...) addition. Pass it\n-                # on verbatim.\n-                table, col = col.split('.', 1)\n-                order_by.append((\n-                    OrderBy(\n-                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n-                        descending=descending\n-                    ), False))\n-                continue\n-\n-            if not self.query.extra or col not in self.query.extra:\n-                # 'col' is of the form 'field' or 'field1__field2' or\n-                # '-field1__field2__field', etc.\n-                order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n-            else:\n-                if col not in self.query.extra_select:\n-                    order_by.append((\n-                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n-                        False))\n-                else:\n-                    order_by.append((\n-                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n-                        True))\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n         result = []\n         seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n \n-        for expr, is_ref in order_by:\n-            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n-            if self.query.combinator and self.select:\n-                src = resolved.get_source_expressions()[0]\n-                expr_src = expr.get_source_expressions()[0]\n-                # Relabel order by columns to raw numbers if this is a combined\n-                # query; necessary since the columns can't be referenced by the\n-                # fully qualified name and the simple column names may collide.\n-                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n-                    if is_ref and col_alias == src.refs:\n-                        src = src.source\n-                    elif col_alias and not (\n-                        isinstance(expr_src, F) and col_alias == expr_src.name\n-                    ):\n-                        continue\n-                    if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n-                        break\n-                else:\n-                    if col_alias:\n-                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n-                    # Add column used in ORDER BY clause to the selected\n-                    # columns and to each combined query.\n-                    order_by_idx = len(self.query.select) + 1\n-                    col_name = f'__orderbycol{order_by_idx}'\n-                    for q in self.query.combined_queries:\n-                        q.add_annotation(expr_src, col_name)\n-                    self.query.add_select_col(resolved, col_name)\n-                    resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n-            sql, params = self.compile(resolved)\n-            # Don't add the same column twice, but the order direction is\n-            # not taken into account so we strip it. When this entire method\n-            # is refactored into expressions, then we can check each part as we\n-            # generate it.\n-            without_ordering = self.ordering_parts.search(sql)[1]\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n             params_hash = make_hashable(params)\n-            if (without_ordering, params_hash) in seen:\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        # This requires resolving Meta.ordering fields and comparing\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n                 continue\n-            seen.add((without_ordering, params_hash))\n-            result.append((resolved, (sql, params, is_ref)))\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n         return result\n \n     def get_extra_select(self, order_by, select):\n",
    "variant_1": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..759aa429d9 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -40,6 +40,40 @@ class SQLCompiler:\n         self.klass_info = None\n         self._meta_ordering = None\n \n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        # This requires resolving Meta.ordering fields and comparing\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n             self.query.get_initial_alias()\n@@ -60,6 +94,7 @@ class SQLCompiler:\n         group_by = self.get_group_by(self.select + extra_select, order_by)\n         return extra_select, order_by, group_by\n \n+\n     def get_group_by(self, select, order_by):\n         \"\"\"\n         Return a list of 2-tuples of form (sql, params).\n@@ -129,6 +164,13 @@ class SQLCompiler:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n             if not is_ref:\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                # when they come from the model's Meta.ordering and we have aggregation\n+                if (self._meta_ordering and \n+                    hasattr(self.query, 'annotation_select') and \n+                    self.query.annotation_select and\n+                    self._is_meta_ordering_expression(expr)):\n+                    continue\n                 expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n@@ -146,6 +188,63 @@ class SQLCompiler:\n                 seen.add((sql, params_hash))\n         return result\n \n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not self._meta_ordering:\n+            return False\n+        \n+        # Get the SQL representation of the expression to compare\n+        try:\n+            expr_sql, expr_params = self.compile(expr)\n+        except Exception:\n+            return False\n+            \n+        # Compare with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    try:\n+                        meta_sql, meta_params = self.compile(meta_expr)\n+                        if expr_sql == meta_sql and expr_params == meta_params:\n+                            return True\n+                    except Exception:\n+                        continue\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+                                        break\n+                                elif hasattr(expr, 'name') and expr.name == field_name:\n+                                    is_meta_ordering_field = True\n+                                    break\n+                    except (AttributeError, FieldError):\n+                        pass\n+                    \n+                    if not is_meta_ordering_field:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n+        result = []\n+        seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n+\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n+            sql, params = expr.select_format(self, sql, params)\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n     def collapse_group_by(self, expressions, having):\n         # If the DB can group by primary key, then group by the primary key of\n         # query's main model. Note that for PostgreSQL the GROUP BY clause must\n@@ -268,140 +367,114 @@ class SQLCompiler:\n             ret.append((col, (sql, params), alias))\n         return ret, klass_info, annotations\n \n-    def get_order_by(self):\n-        \"\"\"\n-        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n-        ORDER BY clause.\n \n-        The order_by clause can alter the select clause (for example it\n-        can add aliases to clauses that do not yet have one, or it can\n-        add totally new select clauses).\n+    def get_group_by(self, select, order_by):\n         \"\"\"\n-        if self.query.extra_order_by:\n-            ordering = self.query.extra_order_by\n-        elif not self.query.default_ordering:\n-            ordering = self.query.order_by\n-        elif self.query.order_by:\n-            ordering = self.query.order_by\n-        elif self.query.get_meta().ordering:\n-            ordering = self.query.get_meta().ordering\n-            self._meta_ordering = ordering\n-        else:\n-            ordering = []\n-        if self.query.standard_ordering:\n-            asc, desc = ORDER_DIR['ASC']\n-        else:\n-            asc, desc = ORDER_DIR['DESC']\n-\n-        order_by = []\n-        for field in ordering:\n-            if hasattr(field, 'resolve_expression'):\n-                if isinstance(field, Value):\n-                    # output_field must be resolved for constants.\n-                    field = Cast(field, field.output_field)\n-                if not isinstance(field, OrderBy):\n-                    field = field.asc()\n-                if not self.query.standard_ordering:\n-                    field = field.copy()\n-                    field.reverse_ordering()\n-                order_by.append((field, False))\n-                continue\n-            if field == '?':  # random\n-                order_by.append((OrderBy(Random()), False))\n-                continue\n+        Return a list of 2-tuples of form (sql, params).\n \n-            col, order = get_order_dir(field, asc)\n-            descending = order == 'DESC'\n+        The logic of what exactly the GROUP BY clause contains is hard\n+        to describe in other words than \"if it passes the test suite,\n+        then it is correct\".\n+        \"\"\"\n+        # Some examples:\n+        #     SomeModel.objects.aggregate(Count('somecol'))\n+        #     GROUP BY: all fields of the model\n+        #\n+        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n+        #     GROUP BY: name\n+        #\n+        #     SomeModel.objects.annotate(Count('somecol'))\n+        #     GROUP BY: all cols of the model\n+        #\n+        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n+        #     GROUP BY: name\n+        #\n+        #     SomeModel.objects.values('name').select_related('o').annotate(Count('somecol'))\n+        #     GROUP BY: o.name, o.pk\n+        #\n+        #     SomeModel.objects.annotate(Count('somecol')).values('name')\n+        #     GROUP BY: all cols of the model\n+        expressions = []\n+        if self.query.group_by is not None:\n+            for expr in self.query.group_by:\n+                sql, params = self.compile(expr)\n+                expressions.append((sql, params))\n+        elif self.query.default_cols:\n+            for expr in self.query.select:\n+                cols = expr.get_group_by_cols()\n+                for col in cols:\n+                    expressions.append(self.compile(col))\n+        elif self.query.select:\n+            # If the query has select expressions, use them for group by.\n+            for expr in self.query.select:\n+                cols = expr.get_group_by_cols()\n+                for col in cols:\n+                    expressions.append(self.compile(col))\n+        elif self.select:\n+            for expr, _, _ in self.select:\n+                cols = expr.get_group_by_cols()\n+                for col in cols:\n+                    expressions.append(self.compile(col))\n \n-            if col in self.query.annotation_select:\n-                # Reference to expression in SELECT clause\n-                order_by.append((\n-                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n-                    True))\n-                continue\n-            if col in self.query.annotations:\n-                # References to an expression which is masked out of the SELECT\n-                # clause.\n-                if self.query.combinator and self.select:\n-                    # Don't use the resolved annotation because other\n-                    # combinated queries might define it differently.\n-                    expr = F(col)\n+        for expr, (sql, params, is_ref) in order_by:\n+            # Skip References to the select clause, as all expressions in the\n+            # select clause are already part of the group by.\n+            if not is_ref:\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n                 else:\n-                    expr = self.query.annotations[col]\n-                    if isinstance(expr, Value):\n-                        # output_field must be resolved for constants.\n-                        expr = Cast(expr, expr.output_field)\n-                order_by.append((OrderBy(expr, descending=descending), False))\n-                continue\n+                    expressions.extend(expr.get_group_by_cols())\n \n-            if '.' in field:\n-                # This came in through an extra(order_by=...) addition. Pass it\n-                # on verbatim.\n-                table, col = col.split('.', 1)\n-                order_by.append((\n-                    OrderBy(\n-                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n-                        descending=descending\n-                    ), False))\n-                continue\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(self.compile(expr))\n \n-            if not self.query.extra or col not in self.query.extra:\n-                # 'col' is of the form 'field' or 'field1__field2' or\n-                # '-field1__field2__field', etc.\n-                order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n-            else:\n-                if col not in self.query.extra_select:\n-                    order_by.append((\n-                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n-                        False))\n-                else:\n-                    order_by.append((\n-                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n-                        True))\n         result = []\n         seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n \n-        for expr, is_ref in order_by:\n-            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n-            if self.query.combinator and self.select:\n-                src = resolved.get_source_expressions()[0]\n-                expr_src = expr.get_source_expressions()[0]\n-                # Relabel order by columns to raw numbers if this is a combined\n-                # query; necessary since the columns can't be referenced by the\n-                # fully qualified name and the simple column names may collide.\n-                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n-                    if is_ref and col_alias == src.refs:\n-                        src = src.source\n-                    elif col_alias and not (\n-                        isinstance(expr_src, F) and col_alias == expr_src.name\n-                    ):\n-                        continue\n-                    if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n-                        break\n-                else:\n-                    if col_alias:\n-                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n-                    # Add column used in ORDER BY clause to the selected\n-                    # columns and to each combined query.\n-                    order_by_idx = len(self.query.select) + 1\n-                    col_name = f'__orderbycol{order_by_idx}'\n-                    for q in self.query.combined_queries:\n-                        q.add_annotation(expr_src, col_name)\n-                    self.query.add_select_col(resolved, col_name)\n-                    resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n-            sql, params = self.compile(resolved)\n-            # Don't add the same column twice, but the order direction is\n-            # not taken into account so we strip it. When this entire method\n-            # is refactored into expressions, then we can check each part as we\n-            # generate it.\n-            without_ordering = self.ordering_parts.search(sql)[1]\n+        for sql, params in expressions:\n             params_hash = make_hashable(params)\n-            if (without_ordering, params_hash) in seen:\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n                 continue\n-            seen.add((without_ordering, params_hash))\n-            result.append((resolved, (sql, params, is_ref)))\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n         return result\n \n     def get_extra_select(self, order_by, select):\n",
    "variant_2": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..43befd345b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -40,6 +40,40 @@ class SQLCompiler:\n         self.klass_info = None\n         self._meta_ordering = None\n \n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        # This requires resolving Meta.ordering fields and comparing\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n             self.query.get_initial_alias()\n@@ -60,6 +94,7 @@ class SQLCompiler:\n         group_by = self.get_group_by(self.select + extra_select, order_by)\n         return extra_select, order_by, group_by\n \n+\n     def get_group_by(self, select, order_by):\n         \"\"\"\n         Return a list of 2-tuples of form (sql, params).\n@@ -129,6 +164,9 @@ class SQLCompiler:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n             if not is_ref:\n+                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n+                if self._meta_ordering and self._is_meta_ordering_expression(expr):\n+                    continue\n                 expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n@@ -146,6 +184,44 @@ class SQLCompiler:\n                 seen.add((sql, params_hash))\n         return result\n \n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n+            sql, params = expr.select_format(self, sql, params)\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n     def collapse_group_by(self, expressions, having):\n         # If the DB can group by primary key, then group by the primary key of\n         # query's main model. Note that for PostgreSQL the GROUP BY clause must\n@@ -268,140 +344,104 @@ class SQLCompiler:\n             ret.append((col, (sql, params), alias))\n         return ret, klass_info, annotations\n \n-    def get_order_by(self):\n-        \"\"\"\n-        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n-        ORDER BY clause.\n \n-        The order_by clause can alter the select clause (for example it\n-        can add aliases to clauses that do not yet have one, or it can\n-        add totally new select clauses).\n+    def get_group_by(self, select, order_by):\n         \"\"\"\n-        if self.query.extra_order_by:\n-            ordering = self.query.extra_order_by\n-        elif not self.query.default_ordering:\n-            ordering = self.query.order_by\n-        elif self.query.order_by:\n-            ordering = self.query.order_by\n-        elif self.query.get_meta().ordering:\n-            ordering = self.query.get_meta().ordering\n-            self._meta_ordering = ordering\n-        else:\n-            ordering = []\n-        if self.query.standard_ordering:\n-            asc, desc = ORDER_DIR['ASC']\n-        else:\n-            asc, desc = ORDER_DIR['DESC']\n-\n-        order_by = []\n-        for field in ordering:\n-            if hasattr(field, 'resolve_expression'):\n-                if isinstance(field, Value):\n-                    # output_field must be resolved for constants.\n-                    field = Cast(field, field.output_field)\n-                if not isinstance(field, OrderBy):\n-                    field = field.asc()\n-                if not self.query.standard_ordering:\n-                    field = field.copy()\n-                    field.reverse_ordering()\n-                order_by.append((field, False))\n-                continue\n-            if field == '?':  # random\n-                order_by.append((OrderBy(Random()), False))\n-                continue\n-\n-            col, order = get_order_dir(field, asc)\n-            descending = order == 'DESC'\n-\n-            if col in self.query.annotation_select:\n-                # Reference to expression in SELECT clause\n-                order_by.append((\n-                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n-                    True))\n-                continue\n-            if col in self.query.annotations:\n-                # References to an expression which is masked out of the SELECT\n-                # clause.\n-                if self.query.combinator and self.select:\n-                    # Don't use the resolved annotation because other\n-                    # combinated queries might define it differently.\n-                    expr = F(col)\n-                else:\n-                    expr = self.query.annotations[col]\n-                    if isinstance(expr, Value):\n-                        # output_field must be resolved for constants.\n-                        expr = Cast(expr, expr.output_field)\n-                order_by.append((OrderBy(expr, descending=descending), False))\n-                continue\n-\n-            if '.' in field:\n-                # This came in through an extra(order_by=...) addition. Pass it\n-                # on verbatim.\n-                table, col = col.split('.', 1)\n-                order_by.append((\n-                    OrderBy(\n-                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n-                        descending=descending\n-                    ), False))\n-                continue\n+        Return a list of 2-tuples of form (sql, params).\n \n-            if not self.query.extra or col not in self.query.extra:\n-                # 'col' is of the form 'field' or 'field1__field2' or\n-                # '-field1__field2__field', etc.\n-                order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n-            else:\n-                if col not in self.query.extra_select:\n-                    order_by.append((\n-                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n-                        False))\n+        The logic of what exactly the GROUP BY clause contains is hard\n+        to describe in other words than \"if it passes the test suite,\n+        then it is correct\".\n+        \"\"\"\n+        # Some examples:\n+        #     SomeModel.objects.aggregate(Count('somecol'))\n+        #     GROUP BY: []\n+        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n+        #     GROUP BY: name\n+        #     SomeModel.objects.annotate(Count('somecol'))\n+        #     GROUP BY: all fields of the model\n+        #\n+        # Note that the GROUP BY clause does not contain any ORDER BY clause\n+        # columns.\n+        if self.query.group_by is None:\n+            return []\n+        expressions = []\n+        if self.query.group_by is not True:\n+            # If the group by is set to a list (by .values() call most likely),\n+            # then we need to add everything in it to the GROUP BY clause.\n+            # Backwards compatibility hack for setting query.group_by. Remove\n+            # when  we have public API way of forcing the GROUP BY clause.\n+            # Converts string references to expressions.\n+            for expr in self.query.group_by:\n+                if not hasattr(expr, 'as_sql'):\n+                    expressions.append(self.query.resolve_ref(expr))\n                 else:\n-                    order_by.append((\n-                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n-                        True))\n+                    expressions.append(expr)\n+        else:\n+            # Otherwise, we need to add all the select clause columns.\n+            expressions.extend(self.query.select)\n+            if self.query.annotations:\n+                for annotation in self.query.annotations.values():\n+                    expressions.append(annotation)\n+            for expr, (sql, params, is_ref) in order_by:\n+                # Skip References to the select clause, as all expressions in the\n+                # select clause are already part of the group by.\n+                if not is_ref:\n+                    # Skip Meta.ordering fields from being added to GROUP BY\n+                    if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                        # Check if this expression comes from Meta.ordering\n+                        # by comparing with the resolved Meta.ordering expressions\n+                        is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                        if not is_meta_ordering:\n+                            expressions.extend(expr.get_group_by_cols())\n+                    else:\n+                        expressions.extend(expr.get_group_by_cols())\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n         result = []\n         seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n \n-        for expr, is_ref in order_by:\n-            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n-            if self.query.combinator and self.select:\n-                src = resolved.get_source_expressions()[0]\n-                expr_src = expr.get_source_expressions()[0]\n-                # Relabel order by columns to raw numbers if this is a combined\n-                # query; necessary since the columns can't be referenced by the\n-                # fully qualified name and the simple column names may collide.\n-                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n-                    if is_ref and col_alias == src.refs:\n-                        src = src.source\n-                    elif col_alias and not (\n-                        isinstance(expr_src, F) and col_alias == expr_src.name\n-                    ):\n-                        continue\n-                    if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n-                        break\n-                else:\n-                    if col_alias:\n-                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n-                    # Add column used in ORDER BY clause to the selected\n-                    # columns and to each combined query.\n-                    order_by_idx = len(self.query.select) + 1\n-                    col_name = f'__orderbycol{order_by_idx}'\n-                    for q in self.query.combined_queries:\n-                        q.add_annotation(expr_src, col_name)\n-                    self.query.add_select_col(resolved, col_name)\n-                    resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n-            sql, params = self.compile(resolved)\n-            # Don't add the same column twice, but the order direction is\n-            # not taken into account so we strip it. When this entire method\n-            # is refactored into expressions, then we can check each part as we\n-            # generate it.\n-            without_ordering = self.ordering_parts.search(sql)[1]\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n             params_hash = make_hashable(params)\n-            if (without_ordering, params_hash) in seen:\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n                 continue\n-            seen.add((without_ordering, params_hash))\n-            result.append((resolved, (sql, params, is_ref)))\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n         return result\n \n     def get_extra_select(self, order_by, select):\n",
    "variant_3": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..9c2686947a 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -40,6 +40,61 @@ class SQLCompiler:\n         self.klass_info = None\n         self._meta_ordering = None\n \n+    def get_group_by(self, select, order_by):\n+        \"\"\"\n+        Return a list of 2-tuples of form (sql, params).\n+\n+        The logic of query.group_by is: if the GROUP BY clause is empty, then\n+        the query is not grouped. If the GROUP BY clause is not empty, then\n+        all expressions in the SELECT clause that are not aggregates must\n+        appear in the GROUP BY clause.\n+        \"\"\"\n+        if self.query.group_by is None:\n+            return []\n+        expressions = []\n+        if self.query.group_by is not True:\n+            # If the group by is set to a list (by .values() call most likely),\n+            # then we need to add everything in it to the GROUP BY clause.\n+            # Backwards compatibility hack for setting query.group_by. Remove\n+            # when we have public API way of forcing the GROUP BY clause.\n+            # Converts string references to expressions.\n+            for expr in self.query.group_by:\n+                if not hasattr(expr, 'as_sql'):\n+                    expr = self.query.resolve_ref(expr)\n+                expressions.append(expr)\n+        # Note that even if the group_by is set, it is only the minimal\n+        # set to group by. So, we need to add cols in select, order_by, and\n+        # having into the select in any case.\n+        ref_sources = {\n+            expr.source for expr in expressions if isinstance(expr, Ref)\n+        }\n+        for expr, (sql, params, is_ref) in select:\n+            cols = expr.get_group_by_cols()\n+            for col in cols:\n+                expressions.append(col)\n+                ref_sources.add(col)\n+        if not self._meta_ordering:\n+            for expr, (sql, params, is_ref) in order_by:\n+                # Skip References to the select clause, as all expressions in the\n+                # select clause are already part of the group by.\n+                if not is_ref:\n+                    expressions.extend(expr.get_group_by_cols())\n+        for expr in self.query.where.get_group_by_cols():\n+            expressions.append(expr)\n+        for expr in self.query.having.get_group_by_cols():\n+            expressions.append(expr)\n+        result = []\n+        seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n+\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n+            sql, params = expr.select_format(self, sql, params)\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n             self.query.get_initial_alias()\n@@ -60,6 +115,7 @@ class SQLCompiler:\n         group_by = self.get_group_by(self.select + extra_select, order_by)\n         return extra_select, order_by, group_by\n \n+\n     def get_group_by(self, select, order_by):\n         \"\"\"\n         Return a list of 2-tuples of form (sql, params).\n@@ -129,7 +185,79 @@ class SQLCompiler:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n             if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                # when they would be cleared from ORDER BY anyway\n+                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n+        result = []\n+        seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n+\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n+            sql, params = expr.select_format(self, sql, params)\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n+                                try:\n+                                    expr_sql, expr_params = self.compile(expr)\n+                                    meta_sql, meta_params = self.compile(meta_expr)\n+                                    if expr_sql == meta_sql and expr_params == meta_params:\n+                                        is_meta_ordering = True\n+                                        break\n+                                except Exception:\n+                                    continue\n+                            if is_meta_ordering:\n+                                break\n+                    except (FieldError, AttributeError):\n+                        is_meta_ordering = False\n+                    \n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n@@ -268,140 +396,112 @@ class SQLCompiler:\n             ret.append((col, (sql, params), alias))\n         return ret, klass_info, annotations\n \n-    def get_order_by(self):\n-        \"\"\"\n-        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n-        ORDER BY clause.\n \n-        The order_by clause can alter the select clause (for example it\n-        can add aliases to clauses that do not yet have one, or it can\n-        add totally new select clauses).\n+    def get_group_by(self, select, order_by):\n         \"\"\"\n-        if self.query.extra_order_by:\n-            ordering = self.query.extra_order_by\n-        elif not self.query.default_ordering:\n-            ordering = self.query.order_by\n-        elif self.query.order_by:\n-            ordering = self.query.order_by\n-        elif self.query.get_meta().ordering:\n-            ordering = self.query.get_meta().ordering\n-            self._meta_ordering = ordering\n-        else:\n-            ordering = []\n-        if self.query.standard_ordering:\n-            asc, desc = ORDER_DIR['ASC']\n-        else:\n-            asc, desc = ORDER_DIR['DESC']\n-\n-        order_by = []\n-        for field in ordering:\n-            if hasattr(field, 'resolve_expression'):\n-                if isinstance(field, Value):\n-                    # output_field must be resolved for constants.\n-                    field = Cast(field, field.output_field)\n-                if not isinstance(field, OrderBy):\n-                    field = field.asc()\n-                if not self.query.standard_ordering:\n-                    field = field.copy()\n-                    field.reverse_ordering()\n-                order_by.append((field, False))\n-                continue\n-            if field == '?':  # random\n-                order_by.append((OrderBy(Random()), False))\n-                continue\n-\n-            col, order = get_order_dir(field, asc)\n-            descending = order == 'DESC'\n+        Return a list of 2-tuples of form (expr, (sql, params)) for the\n+        GROUP BY clause.\n \n-            if col in self.query.annotation_select:\n-                # Reference to expression in SELECT clause\n-                order_by.append((\n-                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n-                    True))\n-                continue\n-            if col in self.query.annotations:\n-                # References to an expression which is masked out of the SELECT\n-                # clause.\n-                if self.query.combinator and self.select:\n-                    # Don't use the resolved annotation because other\n-                    # combinated queries might define it differently.\n-                    expr = F(col)\n-                else:\n-                    expr = self.query.annotations[col]\n-                    if isinstance(expr, Value):\n-                        # output_field must be resolved for constants.\n-                        expr = Cast(expr, expr.output_field)\n-                order_by.append((OrderBy(expr, descending=descending), False))\n-                continue\n-\n-            if '.' in field:\n-                # This came in through an extra(order_by=...) addition. Pass it\n-                # on verbatim.\n-                table, col = col.split('.', 1)\n-                order_by.append((\n-                    OrderBy(\n-                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n-                        descending=descending\n-                    ), False))\n-                continue\n+        The logic of what exactly the GROUP BY clause contains is hard\n+        to describe in other words than \"if it passes the test suite,\n+        then it is correct\".\n+        \"\"\"\n+        # Some examples:\n+        #     SomeModel.objects.values('foo').annotate(Count('pk'))\n+        #     GROUP BY: foo\n+        #     SomeModel.objects.annotate(Count('pk')).values('foo')\n+        #     GROUP BY: foo\n+        #     SomeModel.objects.values('foo').annotate(Count('pk')).values('pk')\n+        #     GROUP BY: foo\n+        #     SomeModel.objects.values('foo').annotate(Count('pk')).distinct()\n+        #     GROUP BY: foo, pk\n+        #     SomeModel.objects.values('foo').annotate(Count('pk')).order_by('pk')\n+        #     GROUP BY: foo, pk\n+        #     SomeModel.objects.annotate(Count('pk')).distinct().order_by('pk')\n+        #     GROUP BY: pk\n \n-            if not self.query.extra or col not in self.query.extra:\n-                # 'col' is of the form 'field' or 'field1__field2' or\n-                # '-field1__field2__field', etc.\n-                order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n+        expressions = []\n+        if self.query.group_by is not None:\n+            if len(self.query.group_by) == 1 and isinstance(self.query.group_by[0], tuple):\n+                expressions.append(self.query.group_by[0])\n             else:\n-                if col not in self.query.extra_select:\n-                    order_by.append((\n-                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n-                        False))\n+                for expr in self.query.group_by:\n+                    if not hasattr(expr, 'as_sql'):\n+                        expressions.append(self.query.resolve_ref(expr))\n+                    else:\n+                        expressions.append(expr)\n+        # Unconditionally add the select list to the group by. This will mean\n+        # we're doing more work than is needed in many cases, but it keeps\n+        # things simple.\n+        for expr, _, _ in select:\n+            col = expr\n+            for src in col.get_source_expressions():\n+                if isinstance(src, Ref):\n+                    col = src.source\n+                    break\n+            expressions.append(col)\n+        for expr, (sql, params, is_ref) in order_by:\n+            # Skip References to the select clause, as all expressions in the\n+            # select clause are already part of the group by.\n+            if not is_ref:\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    # by comparing with the resolved Meta.ordering expressions\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n                 else:\n-                    order_by.append((\n-                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n-                        True))\n+                    expressions.extend(expr.get_group_by_cols())\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n+\n         result = []\n         seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n \n-        for expr, is_ref in order_by:\n-            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n-            if self.query.combinator and self.select:\n-                src = resolved.get_source_expressions()[0]\n-                expr_src = expr.get_source_expressions()[0]\n-                # Relabel order by columns to raw numbers if this is a combined\n-                # query; necessary since the columns can't be referenced by the\n-                # fully qualified name and the simple column names may collide.\n-                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n-                    if is_ref and col_alias == src.refs:\n-                        src = src.source\n-                    elif col_alias and not (\n-                        isinstance(expr_src, F) and col_alias == expr_src.name\n-                    ):\n-                        continue\n-                    if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n-                        break\n-                else:\n-                    if col_alias:\n-                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n-                    # Add column used in ORDER BY clause to the selected\n-                    # columns and to each combined query.\n-                    order_by_idx = len(self.query.select) + 1\n-                    col_name = f'__orderbycol{order_by_idx}'\n-                    for q in self.query.combined_queries:\n-                        q.add_annotation(expr_src, col_name)\n-                    self.query.add_select_col(resolved, col_name)\n-                    resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n-            sql, params = self.compile(resolved)\n-            # Don't add the same column twice, but the order direction is\n-            # not taken into account so we strip it. When this entire method\n-            # is refactored into expressions, then we can check each part as we\n-            # generate it.\n-            without_ordering = self.ordering_parts.search(sql)[1]\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n             params_hash = make_hashable(params)\n-            if (without_ordering, params_hash) in seen:\n+            if (sql, params_hash) not in seen:\n+                result.append((expr, (sql, params)))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n                 continue\n-            seen.add((without_ordering, params_hash))\n-            result.append((resolved, (sql, params, is_ref)))\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n         return result\n \n     def get_extra_select(self, order_by, select):\n",
    "variant_4": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..6e2c0bf38c 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -40,6 +40,87 @@ class SQLCompiler:\n         self.klass_info = None\n         self._meta_ordering = None\n \n+    def get_group_by(self, select, order_by):\n+        \"\"\"\n+        Return a list of 2-tuples of form (sql, params).\n+\n+        The logic of query.group_by is: if it's an iterable, use that as the\n+        group_by, if it's a boolean and it's set, use the query's select (if a\n+        select clause exists) and the order by. If it's an empty list, do\n+        nothing.\n+        \"\"\"\n+        if not order_by:\n+            order_by = []\n+        if not select:\n+            select = []\n+        expressions = []\n+        if self.query.group_by is not None:\n+            if len(self.query.group_by) == 0:\n+                return []\n+            if not isinstance(self.query.group_by, (list, tuple)):\n+                expressions.extend(select)\n+        for expr, (sql, params, is_ref) in order_by:\n+            # Skip References to the select clause, as all expressions in the\n+            # select clause are already part of the group by.\n+            if not is_ref:\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                if self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    # by comparing with the resolved Meta.ordering expressions\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n+\n+        if isinstance(self.query.group_by, (list, tuple)):\n+            expressions.extend(self.query.group_by)\n+        result = []\n+        seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n+\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        # This requires resolving Meta.ordering fields and comparing\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n             self.query.get_initial_alias()\n@@ -60,6 +141,7 @@ class SQLCompiler:\n         group_by = self.get_group_by(self.select + extra_select, order_by)\n         return extra_select, order_by, group_by\n \n+\n     def get_group_by(self, select, order_by):\n         \"\"\"\n         Return a list of 2-tuples of form (sql, params).\n@@ -129,7 +211,74 @@ class SQLCompiler:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n             if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                # when they would be excluded from ORDER BY due to aggregation\n+                if getattr(self, '_meta_ordering', None) and self.query.annotation_select:\n+                    # Check if this expression comes from Meta.ordering\n+                    # by comparing with the resolved Meta.ordering expressions\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n+        result = []\n+        seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n+\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n+            sql, params = expr.select_format(self, sql, params)\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not getattr(self, '_meta_ordering', None):\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n+                                    should_skip = True\n+                                    break\n+                            except (FieldError, AttributeError):\n+                                continue\n+                    except Exception:\n+                        should_skip = False\n+                    \n+                    if not should_skip:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n@@ -268,140 +417,102 @@ class SQLCompiler:\n             ret.append((col, (sql, params), alias))\n         return ret, klass_info, annotations\n \n-    def get_order_by(self):\n-        \"\"\"\n-        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n-        ORDER BY clause.\n \n-        The order_by clause can alter the select clause (for example it\n-        can add aliases to clauses that do not yet have one, or it can\n-        add totally new select clauses).\n+    def get_group_by(self, select, order_by):\n         \"\"\"\n-        if self.query.extra_order_by:\n-            ordering = self.query.extra_order_by\n-        elif not self.query.default_ordering:\n-            ordering = self.query.order_by\n-        elif self.query.order_by:\n-            ordering = self.query.order_by\n-        elif self.query.get_meta().ordering:\n-            ordering = self.query.get_meta().ordering\n-            self._meta_ordering = ordering\n-        else:\n-            ordering = []\n-        if self.query.standard_ordering:\n-            asc, desc = ORDER_DIR['ASC']\n-        else:\n-            asc, desc = ORDER_DIR['DESC']\n-\n-        order_by = []\n-        for field in ordering:\n-            if hasattr(field, 'resolve_expression'):\n-                if isinstance(field, Value):\n-                    # output_field must be resolved for constants.\n-                    field = Cast(field, field.output_field)\n-                if not isinstance(field, OrderBy):\n-                    field = field.asc()\n-                if not self.query.standard_ordering:\n-                    field = field.copy()\n-                    field.reverse_ordering()\n-                order_by.append((field, False))\n-                continue\n-            if field == '?':  # random\n-                order_by.append((OrderBy(Random()), False))\n-                continue\n-\n-            col, order = get_order_dir(field, asc)\n-            descending = order == 'DESC'\n+        Return a list of 2-tuples of form (sql, params).\n \n-            if col in self.query.annotation_select:\n-                # Reference to expression in SELECT clause\n-                order_by.append((\n-                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n-                    True))\n-                continue\n-            if col in self.query.annotations:\n-                # References to an expression which is masked out of the SELECT\n-                # clause.\n-                if self.query.combinator and self.select:\n-                    # Don't use the resolved annotation because other\n-                    # combinated queries might define it differently.\n-                    expr = F(col)\n-                else:\n-                    expr = self.query.annotations[col]\n-                    if isinstance(expr, Value):\n-                        # output_field must be resolved for constants.\n-                        expr = Cast(expr, expr.output_field)\n-                order_by.append((OrderBy(expr, descending=descending), False))\n-                continue\n+        The logic of what exactly the GROUP BY clause contains is hard\n+        to describe in other words than \"if it passes the test suite,\n+        then it is correct\".\n+        \"\"\"\n+        # Some examples:\n+        #     SomeModel.objects.aggregate(Count('somecol'))\n+        #     GROUP BY: all fields of the model\n+        #\n+        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n+        #     GROUP BY: name\n+        #\n+        #     SomeModel.objects.annotate(Count('somecol'))\n+        #     GROUP BY: all cols of the model\n+        #\n+        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n+        #     GROUP BY: name\n+        #\n+        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n+        #     GROUP BY: name\n \n-            if '.' in field:\n-                # This came in through an extra(order_by=...) addition. Pass it\n-                # on verbatim.\n-                table, col = col.split('.', 1)\n-                order_by.append((\n-                    OrderBy(\n-                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n-                        descending=descending\n-                    ), False))\n-                continue\n+        expressions = []\n+        if self.query.group_by is not None:\n+            for expr, having in self.query.group_by:\n+                sql, params = self.compile(expr)\n+                expressions.append((sql, params))\n+        elif self.query.default_cols:\n+            for expr, (sql, params), alias in select:\n+                expressions.append((sql, params))\n+        else:\n+            for expr, (sql, params), alias in select:\n+                sql_params = expr.get_group_by_cols(alias=alias)\n+                expressions.extend(sql_params)\n+            for expr, (sql, params, is_ref) in order_by:\n+                # Skip References to the select clause, as all expressions in the\n+                # select clause are already part of the group by.\n+                if not is_ref:\n+                    # Skip Meta.ordering fields from being added to GROUP BY\n+                    if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                        # Check if this expression comes from Meta.ordering\n+                        is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                        if not is_meta_ordering:\n+                            expressions.extend(expr.get_group_by_cols())\n+                    else:\n+                        expressions.extend(expr.get_group_by_cols())\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n \n-            if not self.query.extra or col not in self.query.extra:\n-                # 'col' is of the form 'field' or 'field1__field2' or\n-                # '-field1__field2__field', etc.\n-                order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n-            else:\n-                if col not in self.query.extra_select:\n-                    order_by.append((\n-                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n-                        False))\n-                else:\n-                    order_by.append((\n-                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n-                        True))\n         result = []\n         seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n \n-        for expr, is_ref in order_by:\n-            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n-            if self.query.combinator and self.select:\n-                src = resolved.get_source_expressions()[0]\n-                expr_src = expr.get_source_expressions()[0]\n-                # Relabel order by columns to raw numbers if this is a combined\n-                # query; necessary since the columns can't be referenced by the\n-                # fully qualified name and the simple column names may collide.\n-                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n-                    if is_ref and col_alias == src.refs:\n-                        src = src.source\n-                    elif col_alias and not (\n-                        isinstance(expr_src, F) and col_alias == expr_src.name\n-                    ):\n-                        continue\n-                    if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n-                        break\n-                else:\n-                    if col_alias:\n-                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n-                    # Add column used in ORDER BY clause to the selected\n-                    # columns and to each combined query.\n-                    order_by_idx = len(self.query.select) + 1\n-                    col_name = f'__orderbycol{order_by_idx}'\n-                    for q in self.query.combined_queries:\n-                        q.add_annotation(expr_src, col_name)\n-                    self.query.add_select_col(resolved, col_name)\n-                    resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n-            sql, params = self.compile(resolved)\n-            # Don't add the same column twice, but the order direction is\n-            # not taken into account so we strip it. When this entire method\n-            # is refactored into expressions, then we can check each part as we\n-            # generate it.\n-            without_ordering = self.ordering_parts.search(sql)[1]\n+        for sql, params in expressions:\n             params_hash = make_hashable(params)\n-            if (without_ordering, params_hash) in seen:\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                # Resolve the meta ordering field to expressions\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n                 continue\n-            seen.add((without_ordering, params_hash))\n-            result.append((resolved, (sql, params, is_ref)))\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n         return result\n \n     def get_extra_select(self, order_by, select):\n",
    "variant_5": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..77afd80f85 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -40,6 +40,40 @@ class SQLCompiler:\n         self.klass_info = None\n         self._meta_ordering = None\n \n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        # This requires resolving Meta.ordering fields and comparing\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n             self.query.get_initial_alias()\n@@ -60,85 +94,109 @@ class SQLCompiler:\n         group_by = self.get_group_by(self.select + extra_select, order_by)\n         return extra_select, order_by, group_by\n \n-    def get_group_by(self, select, order_by):\n-        \"\"\"\n-        Return a list of 2-tuples of form (sql, params).\n \n-        The logic of what exactly the GROUP BY clause contains is hard\n-        to describe in other words than \"if it passes the test suite,\n-        then it is correct\".\n-        \"\"\"\n-        # Some examples:\n-        #     SomeModel.objects.annotate(Count('somecol'))\n-        #     GROUP BY: all fields of the model\n-        #\n-        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n-        #    GROUP BY: name\n-        #\n-        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n-        #    GROUP BY: all cols of the model\n-        #\n-        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n-        #    GROUP BY: name, pk\n-        #\n-        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n-        #    GROUP BY: name, pk\n-        #\n-        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n-        # can't be ever restricted to a smaller set, but additional columns in\n-        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n-        # the end result is that it is impossible to force the query to have\n-        # a chosen GROUP BY clause - you can almost do this by using the form:\n-        #     .values(*wanted_cols).annotate(AnAggregate())\n-        # but any later annotations, extra selects, values calls that\n-        # refer some column outside of the wanted_cols, order_by, or even\n-        # filter calls can alter the GROUP BY clause.\n-\n-        # The query.group_by is either None (no GROUP BY at all), True\n-        # (group by select fields), or a list of expressions to be added\n-        # to the group by.\n-        if self.query.group_by is None:\n-            return []\n-        expressions = []\n-        if self.query.group_by is not True:\n-            # If the group by is set to a list (by .values() call most likely),\n-            # then we need to add everything in it to the GROUP BY clause.\n-            # Backwards compatibility hack for setting query.group_by. Remove\n-            # when  we have public API way of forcing the GROUP BY clause.\n-            # Converts string references to expressions.\n-            for expr in self.query.group_by:\n-                if not hasattr(expr, 'as_sql'):\n-                    expressions.append(self.query.resolve_ref(expr))\n-                else:\n-                    expressions.append(expr)\n-        # Note that even if the group_by is set, it is only the minimal\n-        # set to group by. So, we need to add cols in select, order_by, and\n-        # having into the select in any case.\n-        ref_sources = {\n-            expr.source for expr in expressions if isinstance(expr, Ref)\n-        }\n-        for expr, _, _ in select:\n-            # Skip members of the select clause that are already included\n-            # by reference.\n-            if expr in ref_sources:\n-                continue\n-            cols = expr.get_group_by_cols()\n-            for col in cols:\n-                expressions.append(col)\n-        for expr, (sql, params, is_ref) in order_by:\n-            # Skip References to the select clause, as all expressions in the\n-            # select clause are already part of the group by.\n-            if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n-        having_group_by = self.having.get_group_by_cols() if self.having else ()\n-        for expr in having_group_by:\n-            expressions.append(expr)\n-        result = []\n-        seen = set()\n-        expressions = self.collapse_group_by(expressions, having_group_by)\n+def get_group_by(self, select, order_by):\n+    \"\"\"\n+    Return a list of 2-tuples of form (sql, params).\n \n-        for expr in expressions:\n-            sql, params = self.compile(expr)\n+    The logic of what exactly the GROUP BY clause contains is hard\n+    to describe in other words than \"if it passes the test suite,\n+    then it is correct\".\n+    \"\"\"\n+    # Some examples:\n+    #     SomeModel.objects.annotate(Count('somecol'))\n+    #     GROUP BY: all fields of the model\n+    #\n+    #    SomeModel.objects.values('name').annotate(Count('somecol'))\n+    #    GROUP BY: name\n+    #\n+    #    SomeModel.objects.annotate(Count('somecol')).values('name')\n+    #    GROUP BY: all cols of the model\n+    #\n+    #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n+    #    GROUP BY: name, pk\n+    #\n+    #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n+    #    GROUP BY: name, pk\n+    #\n+    # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n+    # can't be ever restricted to a smaller set, but additional columns in\n+    # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n+    # the end result is that it is impossible to force the query to have\n+    # a chosen GROUP BY clause - you can almost do this by using the form:\n+    #     .values(*wanted_cols).annotate(AnAggregate())\n+    # but any later annotations, extra selects, values calls that\n+    # refer some column outside of the wanted_cols, order_by, or even\n+    # filter calls can alter the GROUP BY clause.\n+\n+    # The query.group_by is either None (no GROUP BY at all), True\n+    # (group by select fields), or a list of expressions to be added\n+    # to the group by.\n+    if self.query.group_by is None:\n+        return []\n+    expressions = []\n+    if self.query.group_by is not True:\n+        # If the group by is set to a list (by .values() call most likely),\n+        # then we need to add everything in it to the GROUP BY clause.\n+        # Backwards compatibility hack for setting query.group_by. Remove\n+        # when  we have public API way of forcing the GROUP BY clause.\n+        # Converts string references to expressions.\n+        for expr in self.query.group_by:\n+            if not hasattr(expr, 'as_sql'):\n+                expressions.append(self.query.resolve_ref(expr))\n+            else:\n+                expressions.append(expr)\n+    # Note that even if the group_by is set, it is only the minimal\n+    # set to group by. So, we need to add cols in select, order_by, and\n+    # having into the select in any case.\n+    ref_sources = {\n+        expr.source for expr in expressions if isinstance(expr, Ref)\n+    }\n+    for expr, _, _ in select:\n+        # Skip members of the select clause that are already included\n+        # by reference.\n+        if expr in ref_sources:\n+            continue\n+        cols = expr.get_group_by_cols()\n+        for col in cols:\n+            expressions.append(col)\n+    \n+    # Get resolved Meta.ordering expressions for comparison\n+    meta_ordering_exprs = set()\n+    if self._meta_ordering:\n+        for meta_field in self._meta_ordering:\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    meta_ordering_exprs.add(meta_expr)\n+            except (FieldError, AttributeError):\n+                continue\n+    \n+    for expr, (sql, params, is_ref) in order_by:\n+        # Skip References to the select clause, as all expressions in the\n+        # select clause are already part of the group by.\n+        if not is_ref:\n+            # Skip Meta.ordering fields from being added to GROUP BY\n+            if self._meta_ordering and expr in meta_ordering_exprs:\n+                continue\n+            expressions.extend(expr.get_group_by_cols())\n+    having_group_by = self.having.get_group_by_cols() if self.having else ()\n+    for expr in having_group_by:\n+        expressions.append(expr)\n+    result = []\n+    seen = set()\n+    expressions = self.collapse_group_by(expressions, having_group_by)\n+\n+    for expr in expressions:\n+        sql, params = self.compile(expr)\n+        sql, params = expr.select_format(self, sql, params)\n+        params_hash = make_hashable(params)\n+        if (sql, params_hash) not in seen:\n+            result.append((sql, params))\n+            seen.add((sql, params_hash))\n+    return result\n             sql, params = expr.select_format(self, sql, params)\n             params_hash = make_hashable(params)\n             if (sql, params_hash) not in seen:\n@@ -268,140 +326,141 @@ class SQLCompiler:\n             ret.append((col, (sql, params), alias))\n         return ret, klass_info, annotations\n \n-    def get_order_by(self):\n+\n+    def get_group_by(self, select, order_by):\n         \"\"\"\n-        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n-        ORDER BY clause.\n+        Return a list of 2-tuples of form (sql, params).\n \n-        The order_by clause can alter the select clause (for example it\n-        can add aliases to clauses that do not yet have one, or it can\n-        add totally new select clauses).\n+        The logic of what exactly the GROUP BY clause contains is hard\n+        to describe in other words than \"if it passes the test suite,\n+        then it is correct\".\n         \"\"\"\n-        if self.query.extra_order_by:\n-            ordering = self.query.extra_order_by\n-        elif not self.query.default_ordering:\n-            ordering = self.query.order_by\n-        elif self.query.order_by:\n-            ordering = self.query.order_by\n-        elif self.query.get_meta().ordering:\n-            ordering = self.query.get_meta().ordering\n-            self._meta_ordering = ordering\n-        else:\n-            ordering = []\n-        if self.query.standard_ordering:\n-            asc, desc = ORDER_DIR['ASC']\n-        else:\n-            asc, desc = ORDER_DIR['DESC']\n-\n-        order_by = []\n-        for field in ordering:\n-            if hasattr(field, 'resolve_expression'):\n-                if isinstance(field, Value):\n-                    # output_field must be resolved for constants.\n-                    field = Cast(field, field.output_field)\n-                if not isinstance(field, OrderBy):\n-                    field = field.asc()\n-                if not self.query.standard_ordering:\n-                    field = field.copy()\n-                    field.reverse_ordering()\n-                order_by.append((field, False))\n-                continue\n-            if field == '?':  # random\n-                order_by.append((OrderBy(Random()), False))\n-                continue\n+        # Some examples:\n+        #     SomeModel.objects.aggregate(Count('somecol'))\n+        #     GROUP BY: all fields of the model\n+        #\n+        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n+        #     GROUP BY: name\n+        #\n+        #     SomeModel.objects.annotate(Count('somecol'))\n+        #     GROUP BY: all cols of the model\n+        #\n+        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n+        #     GROUP BY: name\n+        #\n+        #     SomeModel.objects.values('name').select_related('o').annotate(Count('somecol'))\n+        #     GROUP BY: name, o.id\n+        #\n+        #     SomeModel.objects.values('name').annotate(Count('somecol')).values('name', 'somecol__count')\n+        #     GROUP BY: name\n+        #\n+        # So basically, if we have a model with no values() call, we group\n+        # by all fields, including pk, of the model. If we have a values()\n+        # call we group by the given fields.\n+        #\n+        # There is one exception to the rule: if the model_log.objects.values('name').annotate(Count('somecol'))\n+        # query has select_related() the group by should contain the foreign key to the\n+        # joined model.\n \n-            col, order = get_order_dir(field, asc)\n-            descending = order == 'DESC'\n+        expressions = []\n+        if self.query.group_by is not None:\n+            select_cols = []\n+            for expr, _, _ in select:\n+                cols = expr.get_group_by_cols()\n+                select_cols.extend(cols)\n+            expressions = list({make_hashable(col): col for col in select_cols}.values())\n+        elif self.query.default_ordering:\n+            for expr, (sql, params, is_ref) in order_by:\n+                # Skip References to the select clause, as all expressions in the\n+                # select clause are already part of the group by.\n+                if not is_ref:\n+                    expressions.extend(expr.get_group_by_cols())\n+        elif self.query.select:\n+            select_cols = []\n+            for expr, _, _ in select:\n+                cols = expr.get_group_by_cols()\n+                select_cols.extend(cols)\n+            expressions = list({make_hashable(col): col for col in select_cols}.values())\n+        else:\n+            expressions = [\n+                self.query.get_meta().pk.get_col(self.query.get_initial_alias())\n+            ]\n+        # Expressions selected by the user that are not aggregate functions\n+        # need to be added to the GROUP BY clause.\n+        for expr, _, _ in select:\n+            cols = expr.get_group_by_cols()\n+            expressions.extend(cols)\n \n-            if col in self.query.annotation_select:\n-                # Reference to expression in SELECT clause\n-                order_by.append((\n-                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n-                    True))\n-                continue\n-            if col in self.query.annotations:\n-                # References to an expression which is masked out of the SELECT\n-                # clause.\n-                if self.query.combinator and self.select:\n-                    # Don't use the resolved annotation because other\n-                    # combinated queries might define it differently.\n-                    expr = F(col)\n+        for expr, (sql, params, is_ref) in order_by:\n+            # Skip References to the select clause, as all expressions in the\n+            # select clause are already part of the group by.\n+            if not is_ref:\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                # when they come from model's Meta.ordering\n+                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n                 else:\n-                    expr = self.query.annotations[col]\n-                    if isinstance(expr, Value):\n-                        # output_field must be resolved for constants.\n-                        expr = Cast(expr, expr.output_field)\n-                order_by.append((OrderBy(expr, descending=descending), False))\n-                continue\n+                    expressions.extend(expr.get_group_by_cols())\n \n-            if '.' in field:\n-                # This came in through an extra(order_by=...) addition. Pass it\n-                # on verbatim.\n-                table, col = col.split('.', 1)\n-                order_by.append((\n-                    OrderBy(\n-                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n-                        descending=descending\n-                    ), False))\n-                continue\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n \n-            if not self.query.extra or col not in self.query.extra:\n-                # 'col' is of the form 'field' or 'field1__field2' or\n-                # '-field1__field2__field', etc.\n-                order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n-            else:\n-                if col not in self.query.extra_select:\n-                    order_by.append((\n-                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n-                        False))\n-                else:\n-                    order_by.append((\n-                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n-                        True))\n         result = []\n         seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n \n-        for expr, is_ref in order_by:\n-            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n-            if self.query.combinator and self.select:\n-                src = resolved.get_source_expressions()[0]\n-                expr_src = expr.get_source_expressions()[0]\n-                # Relabel order by columns to raw numbers if this is a combined\n-                # query; necessary since the columns can't be referenced by the\n-                # fully qualified name and the simple column names may collide.\n-                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n-                    if is_ref and col_alias == src.refs:\n-                        src = src.source\n-                    elif col_alias and not (\n-                        isinstance(expr_src, F) and col_alias == expr_src.name\n-                    ):\n-                        continue\n-                    if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n-                        break\n-                else:\n-                    if col_alias:\n-                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n-                    # Add column used in ORDER BY clause to the selected\n-                    # columns and to each combined query.\n-                    order_by_idx = len(self.query.select) + 1\n-                    col_name = f'__orderbycol{order_by_idx}'\n-                    for q in self.query.combined_queries:\n-                        q.add_annotation(expr_src, col_name)\n-                    self.query.add_select_col(resolved, col_name)\n-                    resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n-            sql, params = self.compile(resolved)\n-            # Don't add the same column twice, but the order direction is\n-            # not taken into account so we strip it. When this entire method\n-            # is refactored into expressions, then we can check each part as we\n-            # generate it.\n-            without_ordering = self.ordering_parts.search(sql)[1]\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n             params_hash = make_hashable(params)\n-            if (without_ordering, params_hash) in seen:\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                # Resolve the meta ordering field to expressions\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n                 continue\n-            seen.add((without_ordering, params_hash))\n-            result.append((resolved, (sql, params, is_ref)))\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            # Compare the source expressions if they exist\n+            if hasattr(expr1, 'get_source_expressions') and hasattr(expr2, 'get_source_expressions'):\n+                expr1_sources = expr1.get_source_expressions()\n+                expr2_sources = expr2.get_source_expressions()\n+                if len(expr1_sources) == 1 and len(expr2_sources) == 1:\n+                    return self._expressions_equivalent(expr1_sources[0], expr2_sources[0])\n+            \n+            # Compare SQL representation\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n         return result\n \n     def get_extra_select(self, order_by, select):\n",
    "variant_6": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..e06f324777 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -40,6 +40,19 @@ class SQLCompiler:\n         self.klass_info = None\n         self._meta_ordering = None\n \n+    def __init__(self, query, connection, using):\n+        self.query = query\n+        self.connection = connection\n+        self.using = using\n+        self.quote_cache = {'*': '*'}\n+        # The select, klass_info, and annotations are needed by QuerySet.iterator()\n+        # these are set as a side-effect of executing the query. Note that we calculate\n+        # separately a list of extra select columns needed for grammatical correctness\n+        # of the query, but these columns are not included in self.select.\n+        self.select = None\n+        self.annotation_col_map = None\n+        self.klass_info = None\n+        self._meta_ordering = None\n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n             self.query.get_initial_alias()\n@@ -60,6 +73,7 @@ class SQLCompiler:\n         group_by = self.get_group_by(self.select + extra_select, order_by)\n         return extra_select, order_by, group_by\n \n+\n     def get_group_by(self, select, order_by):\n         \"\"\"\n         Return a list of 2-tuples of form (sql, params).\n@@ -129,7 +143,74 @@ class SQLCompiler:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n             if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+                # Skip Meta.ordering fields from being added to GROUP BY during aggregation\n+                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n+        result = []\n+        seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n+\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n+            sql, params = expr.select_format(self, sql, params)\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                # Resolve the meta ordering field to an expression\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n+                                    break\n+                            elif hasattr(expr, 'source') and hasattr(expr.source, 'name'):\n+                                if expr.source.name == field_name:\n+                                    is_meta_ordering = True\n+                                    break\n+                    except (AttributeError, FieldError):\n+                        pass\n+                    \n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n@@ -268,140 +349,93 @@ class SQLCompiler:\n             ret.append((col, (sql, params), alias))\n         return ret, klass_info, annotations\n \n-    def get_order_by(self):\n-        \"\"\"\n-        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n-        ORDER BY clause.\n \n-        The order_by clause can alter the select clause (for example it\n-        can add aliases to clauses that do not yet have one, or it can\n-        add totally new select clauses).\n+    def get_group_by(self, select, order_by):\n         \"\"\"\n-        if self.query.extra_order_by:\n-            ordering = self.query.extra_order_by\n-        elif not self.query.default_ordering:\n-            ordering = self.query.order_by\n-        elif self.query.order_by:\n-            ordering = self.query.order_by\n-        elif self.query.get_meta().ordering:\n-            ordering = self.query.get_meta().ordering\n-            self._meta_ordering = ordering\n-        else:\n-            ordering = []\n-        if self.query.standard_ordering:\n-            asc, desc = ORDER_DIR['ASC']\n-        else:\n-            asc, desc = ORDER_DIR['DESC']\n-\n-        order_by = []\n-        for field in ordering:\n-            if hasattr(field, 'resolve_expression'):\n-                if isinstance(field, Value):\n-                    # output_field must be resolved for constants.\n-                    field = Cast(field, field.output_field)\n-                if not isinstance(field, OrderBy):\n-                    field = field.asc()\n-                if not self.query.standard_ordering:\n-                    field = field.copy()\n-                    field.reverse_ordering()\n-                order_by.append((field, False))\n-                continue\n-            if field == '?':  # random\n-                order_by.append((OrderBy(Random()), False))\n-                continue\n+        Return a list of 2-tuples of form (sql, params).\n \n-            col, order = get_order_dir(field, asc)\n-            descending = order == 'DESC'\n+        The logic of what exactly the GROUP BY clause contains is hard\n+        to describe in other words than \"if it passes the test suite,\n+        then it is correct\".\n+        \"\"\"\n+        # Some examples:\n+        #     SomeModel.objects.aggregate(Count('somecol'))\n+        #     GROUP BY: none\n+        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n+        #     GROUP BY: name\n+        #     SomeModel.objects.annotate(Count('somecol')).values('pk')\n+        #     GROUP BY: pk\n+        #     SomeModel.objects.annotate(Count('somecol')).values('name')\n+        #     GROUP BY: name\n+        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n+        #     GROUP BY: name\n \n-            if col in self.query.annotation_select:\n-                # Reference to expression in SELECT clause\n-                order_by.append((\n-                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n-                    True))\n-                continue\n-            if col in self.query.annotations:\n-                # References to an expression which is masked out of the SELECT\n-                # clause.\n-                if self.query.combinator and self.select:\n-                    # Don't use the resolved annotation because other\n-                    # combinated queries might define it differently.\n-                    expr = F(col)\n+        expressions = []\n+        if self.query.group_by is not None:\n+            expressions.extend(self.query.group_by)\n+        for expr, (sql, params, is_ref) in order_by:\n+            # Skip References to the select clause, as all expressions in the\n+            # select clause are already part of the group by.\n+            if not is_ref:\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    # by comparing with the resolved Meta.ordering expressions\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n                 else:\n-                    expr = self.query.annotations[col]\n-                    if isinstance(expr, Value):\n-                        # output_field must be resolved for constants.\n-                        expr = Cast(expr, expr.output_field)\n-                order_by.append((OrderBy(expr, descending=descending), False))\n-                continue\n-\n-            if '.' in field:\n-                # This came in through an extra(order_by=...) addition. Pass it\n-                # on verbatim.\n-                table, col = col.split('.', 1)\n-                order_by.append((\n-                    OrderBy(\n-                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n-                        descending=descending\n-                    ), False))\n-                continue\n+                    expressions.extend(expr.get_group_by_cols())\n \n-            if not self.query.extra or col not in self.query.extra:\n-                # 'col' is of the form 'field' or 'field1__field2' or\n-                # '-field1__field2__field', etc.\n-                order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n-            else:\n-                if col not in self.query.extra_select:\n-                    order_by.append((\n-                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n-                        False))\n-                else:\n-                    order_by.append((\n-                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n-                        True))\n+        for expr, (sql, params, is_ref) in select:\n+            cols = expr.get_group_by_cols()\n+            for col in cols:\n+                expressions.append(col)\n         result = []\n         seen = set()\n+        expressions = self.collapse_group_by(expressions, having=self.having)\n \n-        for expr, is_ref in order_by:\n-            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n-            if self.query.combinator and self.select:\n-                src = resolved.get_source_expressions()[0]\n-                expr_src = expr.get_source_expressions()[0]\n-                # Relabel order by columns to raw numbers if this is a combined\n-                # query; necessary since the columns can't be referenced by the\n-                # fully qualified name and the simple column names may collide.\n-                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n-                    if is_ref and col_alias == src.refs:\n-                        src = src.source\n-                    elif col_alias and not (\n-                        isinstance(expr_src, F) and col_alias == expr_src.name\n-                    ):\n-                        continue\n-                    if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n-                        break\n-                else:\n-                    if col_alias:\n-                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n-                    # Add column used in ORDER BY clause to the selected\n-                    # columns and to each combined query.\n-                    order_by_idx = len(self.query.select) + 1\n-                    col_name = f'__orderbycol{order_by_idx}'\n-                    for q in self.query.combined_queries:\n-                        q.add_annotation(expr_src, col_name)\n-                    self.query.add_select_col(resolved, col_name)\n-                    resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n-            sql, params = self.compile(resolved)\n-            # Don't add the same column twice, but the order direction is\n-            # not taken into account so we strip it. When this entire method\n-            # is refactored into expressions, then we can check each part as we\n-            # generate it.\n-            without_ordering = self.ordering_parts.search(sql)[1]\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n             params_hash = make_hashable(params)\n-            if (without_ordering, params_hash) in seen:\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n                 continue\n-            seen.add((without_ordering, params_hash))\n-            result.append((resolved, (sql, params, is_ref)))\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n         return result\n \n     def get_extra_select(self, order_by, select):\n",
    "variant_7": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..5f8c0b3353 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -40,6 +40,39 @@ class SQLCompiler:\n         self.klass_info = None\n         self._meta_ordering = None\n \n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n             self.query.get_initial_alias()\n@@ -60,6 +93,7 @@ class SQLCompiler:\n         group_by = self.get_group_by(self.select + extra_select, order_by)\n         return extra_select, order_by, group_by\n \n+\n     def get_group_by(self, select, order_by):\n         \"\"\"\n         Return a list of 2-tuples of form (sql, params).\n@@ -129,7 +163,74 @@ class SQLCompiler:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n             if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                # when they would be removed from ORDER BY anyway\n+                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n+        result = []\n+        seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n+\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n+            sql, params = expr.select_format(self, sql, params)\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                # Resolve the meta ordering field to an expression\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n+                                        break\n+                                elif hasattr(expr, 'name') and expr.name == field_name:\n+                                    is_meta_ordering = True\n+                                    break\n+                    except (AttributeError, FieldError):\n+                        pass\n+                    \n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n@@ -268,140 +369,99 @@ class SQLCompiler:\n             ret.append((col, (sql, params), alias))\n         return ret, klass_info, annotations\n \n-    def get_order_by(self):\n-        \"\"\"\n-        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n-        ORDER BY clause.\n \n-        The order_by clause can alter the select clause (for example it\n-        can add aliases to clauses that do not yet have one, or it can\n-        add totally new select clauses).\n+    def get_group_by(self, select, order_by):\n         \"\"\"\n-        if self.query.extra_order_by:\n-            ordering = self.query.extra_order_by\n-        elif not self.query.default_ordering:\n-            ordering = self.query.order_by\n-        elif self.query.order_by:\n-            ordering = self.query.order_by\n-        elif self.query.get_meta().ordering:\n-            ordering = self.query.get_meta().ordering\n-            self._meta_ordering = ordering\n-        else:\n-            ordering = []\n-        if self.query.standard_ordering:\n-            asc, desc = ORDER_DIR['ASC']\n-        else:\n-            asc, desc = ORDER_DIR['DESC']\n-\n-        order_by = []\n-        for field in ordering:\n-            if hasattr(field, 'resolve_expression'):\n-                if isinstance(field, Value):\n-                    # output_field must be resolved for constants.\n-                    field = Cast(field, field.output_field)\n-                if not isinstance(field, OrderBy):\n-                    field = field.asc()\n-                if not self.query.standard_ordering:\n-                    field = field.copy()\n-                    field.reverse_ordering()\n-                order_by.append((field, False))\n-                continue\n-            if field == '?':  # random\n-                order_by.append((OrderBy(Random()), False))\n-                continue\n+        Return a list of 2-tuples of form (sql, params).\n \n-            col, order = get_order_dir(field, asc)\n-            descending = order == 'DESC'\n+        The logic of what exactly the GROUP BY clause contains is hard\n+        to describe in other words than \"if it passes the test suite,\n+        then it is correct\".\n+        \"\"\"\n+        # Some examples:\n+        #     SomeModel.objects.aggregate(Count('somecol'))\n+        #     GROUP BY: []\n+        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n+        #     GROUP BY: name\n+        #     SomeModel.objects.annotate(Count('somecol')).values('pk')\n+        #     GROUP BY: pk\n+        #     SomeModel.objects.annotate(Count('somecol')).values('name')\n+        #     GROUP BY: name\n+        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n+        #     GROUP BY: name\n+        #     SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n+        #     GROUP BY: pk\n+        #     SomeModel.objects.values('name').annotate(Count('somecol')).values('name', 'pk')\n+        #     GROUP BY: name, pk\n \n-            if col in self.query.annotation_select:\n-                # Reference to expression in SELECT clause\n-                order_by.append((\n-                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n-                    True))\n-                continue\n-            if col in self.query.annotations:\n-                # References to an expression which is masked out of the SELECT\n-                # clause.\n-                if self.query.combinator and self.select:\n-                    # Don't use the resolved annotation because other\n-                    # combinated queries might define it differently.\n-                    expr = F(col)\n+        expressions = []\n+        if self.query.group_by is not None:\n+            for expr in self.query.group_by:\n+                if not hasattr(expr, 'as_sql'):\n+                    expressions.append(self.query.resolve_ref(expr, allow_joins=True, reuse=None))\n                 else:\n-                    expr = self.query.annotations[col]\n-                    if isinstance(expr, Value):\n-                        # output_field must be resolved for constants.\n-                        expr = Cast(expr, expr.output_field)\n-                order_by.append((OrderBy(expr, descending=descending), False))\n-                continue\n-\n-            if '.' in field:\n-                # This came in through an extra(order_by=...) addition. Pass it\n-                # on verbatim.\n-                table, col = col.split('.', 1)\n-                order_by.append((\n-                    OrderBy(\n-                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n-                        descending=descending\n-                    ), False))\n-                continue\n+                    expressions.append(expr)\n+        else:\n+            for expr, _, _ in select:\n+                cols = expr.get_group_by_cols()\n+                for col in cols:\n+                    expressions.append(col)\n+            for expr, (sql, params, is_ref) in order_by:\n+                # Skip References to the select clause, as all expressions in the\n+                # select clause are already part of the group by.\n+                if not is_ref:\n+                    # Skip Meta.ordering fields from being added to GROUP BY\n+                    if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                        # Check if this expression comes from Meta.ordering\n+                        is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                        if not is_meta_ordering:\n+                            expressions.extend(expr.get_group_by_cols())\n+                    else:\n+                        expressions.extend(expr.get_group_by_cols())\n \n-            if not self.query.extra or col not in self.query.extra:\n-                # 'col' is of the form 'field' or 'field1__field2' or\n-                # '-field1__field2__field', etc.\n-                order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n-            else:\n-                if col not in self.query.extra_select:\n-                    order_by.append((\n-                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n-                        False))\n-                else:\n-                    order_by.append((\n-                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n-                        True))\n         result = []\n         seen = set()\n+        expressions = self.collapse_group_by(expressions, having=self.having)\n \n-        for expr, is_ref in order_by:\n-            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n-            if self.query.combinator and self.select:\n-                src = resolved.get_source_expressions()[0]\n-                expr_src = expr.get_source_expressions()[0]\n-                # Relabel order by columns to raw numbers if this is a combined\n-                # query; necessary since the columns can't be referenced by the\n-                # fully qualified name and the simple column names may collide.\n-                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n-                    if is_ref and col_alias == src.refs:\n-                        src = src.source\n-                    elif col_alias and not (\n-                        isinstance(expr_src, F) and col_alias == expr_src.name\n-                    ):\n-                        continue\n-                    if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n-                        break\n-                else:\n-                    if col_alias:\n-                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n-                    # Add column used in ORDER BY clause to the selected\n-                    # columns and to each combined query.\n-                    order_by_idx = len(self.query.select) + 1\n-                    col_name = f'__orderbycol{order_by_idx}'\n-                    for q in self.query.combined_queries:\n-                        q.add_annotation(expr_src, col_name)\n-                    self.query.add_select_col(resolved, col_name)\n-                    resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n-            sql, params = self.compile(resolved)\n-            # Don't add the same column twice, but the order direction is\n-            # not taken into account so we strip it. When this entire method\n-            # is refactored into expressions, then we can check each part as we\n-            # generate it.\n-            without_ordering = self.ordering_parts.search(sql)[1]\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n             params_hash = make_hashable(params)\n-            if (without_ordering, params_hash) in seen:\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n                 continue\n-            seen.add((without_ordering, params_hash))\n-            result.append((resolved, (sql, params, is_ref)))\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n         return result\n \n     def get_extra_select(self, order_by, select):\n",
    "variant_8": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..5b6d42752c 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -40,6 +40,103 @@ class SQLCompiler:\n         self.klass_info = None\n         self._meta_ordering = None\n \n+    def get_group_by(self, select, order_by):\n+        \"\"\"\n+        Return a list of 2-tuples of the form (sql, params).\n+\n+        The logic of query.group_by is: if it's a grouping query (distinct(),\n+        values(), etc.), then we must have a group_by clause which includes\n+        anything mentioned in select (except for aggregates). If the query\n+        doesn't use grouping, then there should not be a subject, and\n+        furthermore, we must discard any ORDER BY clause which could refer\n+        to things not in the SELECT (since such ordering would be undefined).\n+        \"\"\"\n+        result = []\n+        seen = set()\n+        expressions = []\n+        if self.query.group_by is not None:\n+            select_cols = []\n+            for expr, _, _ in select:\n+                cols = expr.get_group_by_cols()\n+                for col in cols:\n+                    expressions.append(col)\n+                    select_cols.append(col)\n+\n+            if not self.query.group_by:\n+                # If the query does not use grouping, then reject any ORDER BY\n+                # clause which could refer to things not in the SELECT (since\n+                # such ordering would be undefined).\n+                for expr, (sql, params, is_ref) in order_by:\n+                    # Skip References to the select clause, as all expressions in the\n+                    # select clause are already part of the group by.\n+                    if not is_ref:\n+                        expressions.extend(expr.get_group_by_cols())\n+            else:\n+                for expr in self.query.group_by:\n+                    if isinstance(expr, str):\n+                        expressions.append(self.query.resolve_ref(expr))\n+                    else:\n+                        expressions.append(expr)\n+\n+        elif order_by:\n+            # A grouping query is used; Group by stuff must not contain non-aggregate\n+            # values.\n+            for expr, (sql, params, is_ref) in order_by:\n+                # Skip References to the select clause, as all expressions in the\n+                # select clause are already part of the group by.\n+                if not is_ref:\n+                    # Skip Meta.ordering fields from being added to GROUP BY\n+                    if self._meta_ordering:\n+                        # Check if this expression comes from Meta.ordering\n+                        # by comparing with the resolved Meta.ordering expressions\n+                        is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                        if not is_meta_ordering:\n+                            expressions.extend(expr.get_group_by_cols())\n+                    else:\n+                        expressions.extend(expr.get_group_by_cols())\n+\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        # This requires resolving Meta.ordering fields and comparing\n+        for meta_field in self._meta_ordering:\n+            # Resolve the meta ordering field to an expression\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        # Compare the SQL representation of the expressions\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n     def setup_query(self):\n         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n             self.query.get_initial_alias()\n@@ -60,6 +157,7 @@ class SQLCompiler:\n         group_by = self.get_group_by(self.select + extra_select, order_by)\n         return extra_select, order_by, group_by\n \n+\n     def get_group_by(self, select, order_by):\n         \"\"\"\n         Return a list of 2-tuples of form (sql, params).\n@@ -129,7 +227,16 @@ class SQLCompiler:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n             if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                # when they come from the model's Meta.ordering and we have aggregates\n+                if (hasattr(self, '_meta_ordering') and self._meta_ordering and \n+                    self.query.annotations):\n+                    # Check if this expression comes from Meta.ordering\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n+                else:\n+                    expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n@@ -146,6 +253,43 @@ class SQLCompiler:\n                 seen.add((sql, params_hash))\n         return result\n \n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n+                continue\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n+            params_hash = make_hashable(params)\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n     def collapse_group_by(self, expressions, having):\n         # If the DB can group by primary key, then group by the primary key of\n         # query's main model. Note that for PostgreSQL the GROUP BY clause must\n@@ -268,140 +412,97 @@ class SQLCompiler:\n             ret.append((col, (sql, params), alias))\n         return ret, klass_info, annotations\n \n-    def get_order_by(self):\n-        \"\"\"\n-        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n-        ORDER BY clause.\n \n-        The order_by clause can alter the select clause (for example it\n-        can add aliases to clauses that do not yet have one, or it can\n-        add totally new select clauses).\n+    def get_group_by(self, select, order_by):\n         \"\"\"\n-        if self.query.extra_order_by:\n-            ordering = self.query.extra_order_by\n-        elif not self.query.default_ordering:\n-            ordering = self.query.order_by\n-        elif self.query.order_by:\n-            ordering = self.query.order_by\n-        elif self.query.get_meta().ordering:\n-            ordering = self.query.get_meta().ordering\n-            self._meta_ordering = ordering\n-        else:\n-            ordering = []\n-        if self.query.standard_ordering:\n-            asc, desc = ORDER_DIR['ASC']\n-        else:\n-            asc, desc = ORDER_DIR['DESC']\n-\n-        order_by = []\n-        for field in ordering:\n-            if hasattr(field, 'resolve_expression'):\n-                if isinstance(field, Value):\n-                    # output_field must be resolved for constants.\n-                    field = Cast(field, field.output_field)\n-                if not isinstance(field, OrderBy):\n-                    field = field.asc()\n-                if not self.query.standard_ordering:\n-                    field = field.copy()\n-                    field.reverse_ordering()\n-                order_by.append((field, False))\n-                continue\n-            if field == '?':  # random\n-                order_by.append((OrderBy(Random()), False))\n-                continue\n+        Return a list of 2-tuples of form (sql, params).\n \n-            col, order = get_order_dir(field, asc)\n-            descending = order == 'DESC'\n+        The logic of what exactly the GROUP BY clause contains is hard\n+        to describe in other words than \"if it passes the test suite,\n+        then it is correct\".\n+        \"\"\"\n+        # Some examples:\n+        #     SomeModel.objects.aggregate(Count('somecol'))\n+        #     GROUP BY: all fields of the model\n+        #\n+        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n+        #     GROUP BY: name\n+        #\n+        #     SomeModel.objects.annotate(Count('somecol'))\n+        #     GROUP BY: all cols of the model\n+        #\n+        #     SomeModel.objects.values('name').annotate(Count('somecol'))\n+        #     GROUP BY: name\n+        #\n+        #     SomeModel.objects.values('name').aggregate(Count('somecol'))\n+        #     GROUP BY: name\n \n-            if col in self.query.annotation_select:\n-                # Reference to expression in SELECT clause\n-                order_by.append((\n-                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n-                    True))\n-                continue\n-            if col in self.query.annotations:\n-                # References to an expression which is masked out of the SELECT\n-                # clause.\n-                if self.query.combinator and self.select:\n-                    # Don't use the resolved annotation because other\n-                    # combinated queries might define it differently.\n-                    expr = F(col)\n+        expressions = []\n+        if self.query.group_by is not None:\n+            expressions.extend(self.query.group_by)\n+        for expr, (sql, params, is_ref) in select:\n+            cols = expr.get_group_by_cols()\n+            for col in cols:\n+                expressions.append(col)\n+        for expr, (sql, params, is_ref) in order_by:\n+            # Skip References to the select clause, as all expressions in the\n+            # select clause are already part of the group by.\n+            if not is_ref:\n+                # Skip Meta.ordering fields from being added to GROUP BY\n+                if hasattr(self, '_meta_ordering') and self._meta_ordering:\n+                    # Check if this expression comes from Meta.ordering\n+                    is_meta_ordering = self._is_meta_ordering_expression(expr)\n+                    if not is_meta_ordering:\n+                        expressions.extend(expr.get_group_by_cols())\n                 else:\n-                    expr = self.query.annotations[col]\n-                    if isinstance(expr, Value):\n-                        # output_field must be resolved for constants.\n-                        expr = Cast(expr, expr.output_field)\n-                order_by.append((OrderBy(expr, descending=descending), False))\n-                continue\n-\n-            if '.' in field:\n-                # This came in through an extra(order_by=...) addition. Pass it\n-                # on verbatim.\n-                table, col = col.split('.', 1)\n-                order_by.append((\n-                    OrderBy(\n-                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n-                        descending=descending\n-                    ), False))\n-                continue\n+                    expressions.extend(expr.get_group_by_cols())\n+        having_group_by = self.having.get_group_by_cols() if self.having else ()\n+        for expr in having_group_by:\n+            expressions.append(expr)\n \n-            if not self.query.extra or col not in self.query.extra:\n-                # 'col' is of the form 'field' or 'field1__field2' or\n-                # '-field1__field2__field', etc.\n-                order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n-            else:\n-                if col not in self.query.extra_select:\n-                    order_by.append((\n-                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n-                        False))\n-                else:\n-                    order_by.append((\n-                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n-                        True))\n         result = []\n         seen = set()\n+        expressions = self.collapse_group_by(expressions, having_group_by)\n \n-        for expr, is_ref in order_by:\n-            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n-            if self.query.combinator and self.select:\n-                src = resolved.get_source_expressions()[0]\n-                expr_src = expr.get_source_expressions()[0]\n-                # Relabel order by columns to raw numbers if this is a combined\n-                # query; necessary since the columns can't be referenced by the\n-                # fully qualified name and the simple column names may collide.\n-                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n-                    if is_ref and col_alias == src.refs:\n-                        src = src.source\n-                    elif col_alias and not (\n-                        isinstance(expr_src, F) and col_alias == expr_src.name\n-                    ):\n-                        continue\n-                    if src == sel_expr:\n-                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n-                        break\n-                else:\n-                    if col_alias:\n-                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n-                    # Add column used in ORDER BY clause to the selected\n-                    # columns and to each combined query.\n-                    order_by_idx = len(self.query.select) + 1\n-                    col_name = f'__orderbycol{order_by_idx}'\n-                    for q in self.query.combined_queries:\n-                        q.add_annotation(expr_src, col_name)\n-                    self.query.add_select_col(resolved, col_name)\n-                    resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n-            sql, params = self.compile(resolved)\n-            # Don't add the same column twice, but the order direction is\n-            # not taken into account so we strip it. When this entire method\n-            # is refactored into expressions, then we can check each part as we\n-            # generate it.\n-            without_ordering = self.ordering_parts.search(sql)[1]\n+        for expr in expressions:\n+            sql, params = self.compile(expr)\n             params_hash = make_hashable(params)\n-            if (without_ordering, params_hash) in seen:\n+            if (sql, params_hash) not in seen:\n+                result.append((sql, params))\n+                seen.add((sql, params_hash))\n+        return result\n+\n+    def _is_meta_ordering_expression(self, expr):\n+        \"\"\"\n+        Check if the given expression comes from Meta.ordering.\n+        This helps exclude Meta.ordering fields from GROUP BY clauses.\n+        \"\"\"\n+        if not hasattr(self, '_meta_ordering') or not self._meta_ordering:\n+            return False\n+        \n+        # Compare the expression with Meta.ordering field expressions\n+        for meta_field in self._meta_ordering:\n+            try:\n+                meta_expr_list = self.find_ordering_name(\n+                    meta_field, self.query.get_meta(), default_order='ASC'\n+                )\n+                for meta_expr, _ in meta_expr_list:\n+                    if self._expressions_equivalent(expr, meta_expr):\n+                        return True\n+            except (FieldError, AttributeError):\n                 continue\n-            seen.add((without_ordering, params_hash))\n-            result.append((resolved, (sql, params, is_ref)))\n+        return False\n+\n+    def _expressions_equivalent(self, expr1, expr2):\n+        \"\"\"\n+        Check if two expressions are equivalent for GROUP BY purposes.\n+        \"\"\"\n+        try:\n+            sql1, params1 = self.compile(expr1)\n+            sql2, params2 = self.compile(expr2)\n+            return sql1 == sql2 and params1 == params2\n+        except Exception:\n+            return False\n         return result\n \n     def get_extra_select(self, order_by, select):\n"
  }
}