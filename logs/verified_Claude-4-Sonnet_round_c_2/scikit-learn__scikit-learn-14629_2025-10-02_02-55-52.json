{
  "zero_patches": {
    "Location 1 (/root/hy/projects/scikit-learn/sklearn/model_selection/_validation.py lines 857-861)": "\n    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n        if isinstance(predictions, list):\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                predictions = [_enforce_prediction_order(\n                    estimator.estimators_[i_label].classes_, predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n            else:\n                predictions = [_enforce_prediction_order(\n                    estimator.classes_[i_label], predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # since this is the non-list case (single output)\n                classes = estimator.estimators_[0].classes_\n            else:\n                classes = estimator.classes_\n            predictions = _enforce_prediction_order(\n                classes, predictions, n_classes, method)\n",
    "Location 2 (/root/hy/projects/scikit-learn/sklearn/model_selection/_validation.py lines 862-866)": "\n        else:\n            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, we need to handle each output separately\n                # but since this is the non-list case, predictions should be 2D\n                # where each column corresponds to an output\n                n_classes = y.shape[1] if y.ndim > 1 else len(set(y))\n                # For MultiOutputClassifier in non-list case, we can't use _enforce_prediction_order\n                # as it expects a single classes_ array, but we have multiple estimators\n                # Just return predictions as-is since they should already be in correct format\n                pass\n            else:\n                # A 2D y array should be a binary label indicator matrix\n                n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n                predictions = _enforce_prediction_order(\n                    estimator.classes_, predictions, n_classes, method)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/scikit-learn/sklearn/model_selection/_validation.py lines 857-861)": [
      "\n    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n        if isinstance(predictions, list):\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                predictions = [_enforce_prediction_order(\n                    estimator.estimators_[i_label].classes_, predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n            else:\n                predictions = [_enforce_prediction_order(\n                    estimator.classes_[i_label], predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # as they should be consistent across all estimators\n                predictions = _enforce_prediction_order(\n                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n            else:\n                predictions = _enforce_prediction_order(\n                    estimator.classes_, predictions, n_classes, method)\n",
      "\n    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n        if isinstance(predictions, list):\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                predictions = [_enforce_prediction_order(\n                    estimator.estimators_[i_label].classes_, predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n            else:\n                predictions = [_enforce_prediction_order(\n                    estimator.classes_[i_label], predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # as all estimators should have same classes for single output case\n                predictions = _enforce_prediction_order(\n                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n            else:\n                predictions = _enforce_prediction_order(\n                    estimator.classes_, predictions, n_classes, method)\n",
      "\n    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n        if isinstance(predictions, list):\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                predictions = [_enforce_prediction_order(\n                    estimator.estimators_[i_label].classes_, predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n            else:\n                predictions = [_enforce_prediction_order(\n                    estimator.classes_[i_label], predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # since non-list predictions indicate single output\n                predictions = _enforce_prediction_order(\n                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n            else:\n                predictions = _enforce_prediction_order(\n                    estimator.classes_, predictions, n_classes, method)\n",
      "\n    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n        if isinstance(predictions, list):\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                predictions = [_enforce_prediction_order(\n                    estimator.estimators_[i_label].classes_, predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n            else:\n                predictions = [_enforce_prediction_order(\n                    estimator.classes_[i_label], predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # as all estimators should have same structure for single output\n                predictions = _enforce_prediction_order(\n                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n            else:\n                predictions = _enforce_prediction_order(\n                    estimator.classes_, predictions, n_classes, method)\n",
      "\n    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n        if isinstance(predictions, list):\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                predictions = [_enforce_prediction_order(\n                    estimator.estimators_[i_label].classes_, predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n            else:\n                predictions = [_enforce_prediction_order(\n                    estimator.classes_[i_label], predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # since non-list predictions imply single output\n                classes = estimator.estimators_[0].classes_\n            else:\n                classes = estimator.classes_\n            predictions = _enforce_prediction_order(\n                classes, predictions, n_classes, method)\n",
      "\n    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n        if isinstance(predictions, list):\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                predictions = [_enforce_prediction_order(\n                    estimator.estimators_[i_label].classes_, predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n            else:\n                predictions = [_enforce_prediction_order(\n                    estimator.classes_[i_label], predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # as all estimators should have same classes for single output case\n                classes = estimator.estimators_[0].classes_\n            else:\n                classes = estimator.classes_\n            predictions = _enforce_prediction_order(\n                classes, predictions, n_classes, method)\n",
      "\n    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n        if isinstance(predictions, list):\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                predictions = [_enforce_prediction_order(\n                    estimator.estimators_[i_label].classes_, predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n            else:\n                predictions = [_enforce_prediction_order(\n                    estimator.classes_[i_label], predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # as they should be consistent across outputs\n                predictions = _enforce_prediction_order(\n                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n            else:\n                predictions = _enforce_prediction_order(\n                    estimator.classes_, predictions, n_classes, method)\n",
      "\n    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n        if isinstance(predictions, list):\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                predictions = [_enforce_prediction_order(\n                    estimator.estimators_[i_label].classes_, predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n            else:\n                predictions = [_enforce_prediction_order(\n                    estimator.classes_[i_label], predictions[i_label],\n                    n_classes=len(set(y[:, i_label])), method=method)\n                    for i_label in range(len(predictions))]\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier case\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use the first estimator's classes\n                # since in the non-list case, we have a single prediction array\n                predictions = _enforce_prediction_order(\n                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n            else:\n                predictions = _enforce_prediction_order(\n                    estimator.classes_, predictions, n_classes, method)\n"
    ],
    "Location 2 (/root/hy/projects/scikit-learn/sklearn/model_selection/_validation.py lines 862-866)": [
      "\n        else:\n            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, we need to handle each output separately\n                # but this branch is for non-list predictions, so we assume binary classification\n                # for each output and use the first estimator's classes as reference\n                classes = estimator.estimators_[0].classes_\n            else:\n                classes = estimator.classes_\n            \n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            predictions = _enforce_prediction_order(\n                classes, predictions, n_classes, method)\n",
      "\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # All estimators should have the same classes for binary classification\n                estimator_classes = estimator.estimators_[0].classes_\n            else:\n                estimator_classes = estimator.classes_\n            predictions = _enforce_prediction_order(\n                estimator_classes, predictions, n_classes, method)\n",
      "\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # since all estimators should have the same classes for this case\n                classes = estimator.estimators_[0].classes_\n            else:\n                classes = estimator.classes_\n            predictions = _enforce_prediction_order(\n                classes, predictions, n_classes, method)\n",
      "\n        else:\n            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n            from ..multioutput import MultiOutputClassifier\n            if isinstance(estimator, MultiOutputClassifier):\n                # For MultiOutputClassifier, classes are stored in individual estimators\n                predictions = _enforce_prediction_order(\n                    [est.classes_ for est in estimator.estimators_], \n                    predictions, n_classes=y.shape[1], method=method)\n            else:\n                # A 2D y array should be a binary label indicator matrix\n                n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n                predictions = _enforce_prediction_order(\n                    estimator.classes_, predictions, n_classes, method)\n",
      "\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Check if estimator is MultiOutputClassifier\n            if hasattr(estimator, 'estimators_') and not hasattr(estimator, 'classes_'):\n                # For MultiOutputClassifier, use classes from first estimator\n                # assuming all estimators have same classes for binary classification\n                classes = estimator.estimators_[0].classes_\n            else:\n                classes = estimator.classes_\n            predictions = _enforce_prediction_order(\n                classes, predictions, n_classes, method)\n",
      "\n        else:\n            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, we need to handle each output separately\n                # but this branch handles non-list predictions, so we collect all classes\n                all_classes = []\n                for est in estimator.estimators_:\n                    all_classes.extend(est.classes_)\n                classes = np.unique(all_classes)\n            else:\n                classes = estimator.classes_\n            \n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            predictions = _enforce_prediction_order(\n                classes, predictions, n_classes, method)\n",
      "\n    else:\n        # A 2D y array should be a binary label indicator matrix\n        n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n        # Handle MultiOutputClassifier which doesn't have classes_ attribute\n        if hasattr(estimator, 'estimators_') and hasattr(estimator.estimators_[0], 'classes_'):\n            # For MultiOutputClassifier, use classes from first estimator\n            # (all estimators should have same classes for binary classification)\n            classes = estimator.estimators_[0].classes_\n        else:\n            classes = estimator.classes_\n        predictions = _enforce_prediction_order(\n            classes, predictions, n_classes, method)\n",
      "\n        else:\n            # A 2D y array should be a binary label indicator matrix\n            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n            if hasattr(estimator, 'estimators_'):\n                # For MultiOutputClassifier, use classes from the first estimator\n                # since all estimators should have the same classes for each output\n                estimator_classes = estimator.estimators_[0].classes_\n            else:\n                estimator_classes = estimator.classes_\n            predictions = _enforce_prediction_order(\n                estimator_classes, predictions, n_classes, method)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a212..135a9afdf 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -854,16 +854,18 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n     func = getattr(estimator, method)\n     predictions = func(X_test)\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n+\n         if isinstance(predictions, list):\n             predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n+                estimator.estimators_[i_label].classes_ if hasattr(estimator, 'estimators_') else estimator.classes_[i_label], predictions[i_label],\n                 n_classes=len(set(y[:, i_label])), method=method)\n                 for i_label in range(len(predictions))]\n+\n         else:\n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n             predictions = _enforce_prediction_order(\n-                estimator.classes_, predictions, n_classes, method)\n+                estimator.classes_ if not hasattr(estimator, 'estimators_') else estimator.estimators_[0].classes_, predictions, n_classes, method)\n     return predictions, test\n \n \n",
    "variant_0": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a212..4887a6a70 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -853,17 +853,50 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n         estimator.fit(X_train, y_train, **fit_params)\n     func = getattr(estimator, method)\n     predictions = func(X_test)\n+    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n+\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n         else:\n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # since this is the non-list case (single output)\n+                classes = estimator.estimators_[0].classes_\n+            else:\n+                classes = estimator.classes_\n             predictions = _enforce_prediction_order(\n-                estimator.classes_, predictions, n_classes, method)\n+                classes, predictions, n_classes, method)\n+\n+        else:\n+            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, we need to handle each output separately\n+                # but since this is the non-list case, predictions should be 2D\n+                # where each column corresponds to an output\n+                n_classes = y.shape[1] if y.ndim > 1 else len(set(y))\n+                # For MultiOutputClassifier in non-list case, we can't use _enforce_prediction_order\n+                # as it expects a single classes_ array, but we have multiple estimators\n+                # Just return predictions as-is since they should already be in correct format\n+                pass\n+            else:\n+                # A 2D y array should be a binary label indicator matrix\n+                n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+                predictions = _enforce_prediction_order(\n+                    estimator.classes_, predictions, n_classes, method)\n     return predictions, test\n \n \n",
    "variant_1": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a212..95aed533a 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -853,17 +853,48 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n         estimator.fit(X_train, y_train, **fit_params)\n     func = getattr(estimator, method)\n     predictions = func(X_test)\n+    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n+\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n         else:\n+            # A 2D y array should be a binary label indicator matrix\n+            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # as they should be consistent across all estimators\n+                predictions = _enforce_prediction_order(\n+                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n+            else:\n+                predictions = _enforce_prediction_order(\n+                    estimator.classes_, predictions, n_classes, method)\n+\n+        else:\n+            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, we need to handle each output separately\n+                # but this branch is for non-list predictions, so we assume binary classification\n+                # for each output and use the first estimator's classes as reference\n+                classes = estimator.estimators_[0].classes_\n+            else:\n+                classes = estimator.classes_\n+            \n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n             predictions = _enforce_prediction_order(\n-                estimator.classes_, predictions, n_classes, method)\n+                classes, predictions, n_classes, method)\n     return predictions, test\n \n \n",
    "variant_2": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a212..648ba0039 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -853,17 +853,46 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n         estimator.fit(X_train, y_train, **fit_params)\n     func = getattr(estimator, method)\n     predictions = func(X_test)\n+    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n+\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n         else:\n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # as all estimators should have same classes for single output case\n+                predictions = _enforce_prediction_order(\n+                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n+            else:\n+                predictions = _enforce_prediction_order(\n+                    estimator.classes_, predictions, n_classes, method)\n+\n+        else:\n+            # A 2D y array should be a binary label indicator matrix\n+            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # All estimators should have the same classes for binary classification\n+                estimator_classes = estimator.estimators_[0].classes_\n+            else:\n+                estimator_classes = estimator.classes_\n             predictions = _enforce_prediction_order(\n-                estimator.classes_, predictions, n_classes, method)\n+                estimator_classes, predictions, n_classes, method)\n     return predictions, test\n \n \n",
    "variant_3": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a212..1e11e69da 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -853,17 +853,46 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n         estimator.fit(X_train, y_train, **fit_params)\n     func = getattr(estimator, method)\n     predictions = func(X_test)\n+    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n+\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n         else:\n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # since non-list predictions indicate single output\n+                predictions = _enforce_prediction_order(\n+                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n+            else:\n+                predictions = _enforce_prediction_order(\n+                    estimator.classes_, predictions, n_classes, method)\n+\n+        else:\n+            # A 2D y array should be a binary label indicator matrix\n+            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # since all estimators should have the same classes for this case\n+                classes = estimator.estimators_[0].classes_\n+            else:\n+                classes = estimator.classes_\n             predictions = _enforce_prediction_order(\n-                estimator.classes_, predictions, n_classes, method)\n+                classes, predictions, n_classes, method)\n     return predictions, test\n \n \n",
    "variant_4": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a212..313d9dfab 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -853,17 +853,47 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n         estimator.fit(X_train, y_train, **fit_params)\n     func = getattr(estimator, method)\n     predictions = func(X_test)\n+    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n+\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n         else:\n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n-            predictions = _enforce_prediction_order(\n-                estimator.classes_, predictions, n_classes, method)\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # as all estimators should have same structure for single output\n+                predictions = _enforce_prediction_order(\n+                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n+            else:\n+                predictions = _enforce_prediction_order(\n+                    estimator.classes_, predictions, n_classes, method)\n+\n+        else:\n+            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n+            from ..multioutput import MultiOutputClassifier\n+            if isinstance(estimator, MultiOutputClassifier):\n+                # For MultiOutputClassifier, classes are stored in individual estimators\n+                predictions = _enforce_prediction_order(\n+                    [est.classes_ for est in estimator.estimators_], \n+                    predictions, n_classes=y.shape[1], method=method)\n+            else:\n+                # A 2D y array should be a binary label indicator matrix\n+                n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+                predictions = _enforce_prediction_order(\n+                    estimator.classes_, predictions, n_classes, method)\n     return predictions, test\n \n \n",
    "variant_5": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a212..4b17c6f8d 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -853,17 +853,46 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n         estimator.fit(X_train, y_train, **fit_params)\n     func = getattr(estimator, method)\n     predictions = func(X_test)\n+    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n+\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+        else:\n+            # A 2D y array should be a binary label indicator matrix\n+            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # since non-list predictions imply single output\n+                classes = estimator.estimators_[0].classes_\n+            else:\n+                classes = estimator.classes_\n+            predictions = _enforce_prediction_order(\n+                classes, predictions, n_classes, method)\n+\n         else:\n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Check if estimator is MultiOutputClassifier\n+            if hasattr(estimator, 'estimators_') and not hasattr(estimator, 'classes_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # assuming all estimators have same classes for binary classification\n+                classes = estimator.estimators_[0].classes_\n+            else:\n+                classes = estimator.classes_\n             predictions = _enforce_prediction_order(\n-                estimator.classes_, predictions, n_classes, method)\n+                classes, predictions, n_classes, method)\n     return predictions, test\n \n \n",
    "variant_6": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a212..2df387e0d 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -853,17 +853,50 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n         estimator.fit(X_train, y_train, **fit_params)\n     func = getattr(estimator, method)\n     predictions = func(X_test)\n+    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n+\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+        else:\n+            # A 2D y array should be a binary label indicator matrix\n+            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # as all estimators should have same classes for single output case\n+                classes = estimator.estimators_[0].classes_\n+            else:\n+                classes = estimator.classes_\n+            predictions = _enforce_prediction_order(\n+                classes, predictions, n_classes, method)\n+\n         else:\n+            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, we need to handle each output separately\n+                # but this branch handles non-list predictions, so we collect all classes\n+                all_classes = []\n+                for est in estimator.estimators_:\n+                    all_classes.extend(est.classes_)\n+                classes = np.unique(all_classes)\n+            else:\n+                classes = estimator.classes_\n+            \n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n             predictions = _enforce_prediction_order(\n-                estimator.classes_, predictions, n_classes, method)\n+                classes, predictions, n_classes, method)\n     return predictions, test\n \n \n",
    "variant_7": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a212..c752c00d5 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -853,17 +853,46 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n         estimator.fit(X_train, y_train, **fit_params)\n     func = getattr(estimator, method)\n     predictions = func(X_test)\n+    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n+\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n         else:\n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n-            predictions = _enforce_prediction_order(\n-                estimator.classes_, predictions, n_classes, method)\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from first estimator\n+                # as they should be consistent across outputs\n+                predictions = _enforce_prediction_order(\n+                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n+            else:\n+                predictions = _enforce_prediction_order(\n+                    estimator.classes_, predictions, n_classes, method)\n+\n+    else:\n+        # A 2D y array should be a binary label indicator matrix\n+        n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+        # Handle MultiOutputClassifier which doesn't have classes_ attribute\n+        if hasattr(estimator, 'estimators_') and hasattr(estimator.estimators_[0], 'classes_'):\n+            # For MultiOutputClassifier, use classes from first estimator\n+            # (all estimators should have same classes for binary classification)\n+            classes = estimator.estimators_[0].classes_\n+        else:\n+            classes = estimator.classes_\n+        predictions = _enforce_prediction_order(\n+            classes, predictions, n_classes, method)\n     return predictions, test\n \n \n",
    "variant_8": "diff --git a/sklearn/model_selection/_validation.py b/sklearn/model_selection/_validation.py\nindex 95669a212..a44fb303f 100644\n--- a/sklearn/model_selection/_validation.py\n+++ b/sklearn/model_selection/_validation.py\n@@ -853,17 +853,46 @@ def _fit_and_predict(estimator, X, y, train, test, verbose, fit_params,\n         estimator.fit(X_train, y_train, **fit_params)\n     func = getattr(estimator, method)\n     predictions = func(X_test)\n+    if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n+\n     if method in ['decision_function', 'predict_proba', 'predict_log_proba']:\n         if isinstance(predictions, list):\n-            predictions = [_enforce_prediction_order(\n-                estimator.classes_[i_label], predictions[i_label],\n-                n_classes=len(set(y[:, i_label])), method=method)\n-                for i_label in range(len(predictions))]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                predictions = [_enforce_prediction_order(\n+                    estimator.estimators_[i_label].classes_, predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n+            else:\n+                predictions = [_enforce_prediction_order(\n+                    estimator.classes_[i_label], predictions[i_label],\n+                    n_classes=len(set(y[:, i_label])), method=method)\n+                    for i_label in range(len(predictions))]\n         else:\n             # A 2D y array should be a binary label indicator matrix\n             n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Handle MultiOutputClassifier case\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use the first estimator's classes\n+                # since in the non-list case, we have a single prediction array\n+                predictions = _enforce_prediction_order(\n+                    estimator.estimators_[0].classes_, predictions, n_classes, method)\n+            else:\n+                predictions = _enforce_prediction_order(\n+                    estimator.classes_, predictions, n_classes, method)\n+\n+        else:\n+            # A 2D y array should be a binary label indicator matrix\n+            n_classes = len(set(y)) if y.ndim == 1 else y.shape[1]\n+            # Handle MultiOutputClassifier which doesn't have classes_ attribute\n+            if hasattr(estimator, 'estimators_'):\n+                # For MultiOutputClassifier, use classes from the first estimator\n+                # since all estimators should have the same classes for each output\n+                estimator_classes = estimator.estimators_[0].classes_\n+            else:\n+                estimator_classes = estimator.classes_\n             predictions = _enforce_prediction_order(\n-                estimator.classes_, predictions, n_classes, method)\n+                estimator_classes, predictions, n_classes, method)\n     return predictions, test\n \n \n"
  }
}