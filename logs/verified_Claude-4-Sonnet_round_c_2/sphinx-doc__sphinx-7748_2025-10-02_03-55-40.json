{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1070-1071)": "\n            # don't look any further - collect all signatures instead\n            if result is None:\n                result = []\n            result.append((args, retann))\n",
    "Location 2 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1047-1072)": "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        \n        # Process all lines to find multiple signatures\n        matched_lines = []\n        remaining_lines = []\n        \n        for j, line in enumerate(doclines):\n            match = py_ext_sig_re.match(line)\n            if match:\n                exmod, path, base, args, retann = match.groups()\n                # the base name must match ours\n                valid_names = [self.objpath[-1]]  # type: ignore\n                if isinstance(self, ClassDocumenter):\n                    valid_names.append('__init__')\n                    if hasattr(self.object, '__mro__'):\n                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n                if base in valid_names:\n                    signatures.append((args, retann))\n                    matched_lines.append(j)\n            else:\n                # Once we hit a non-signature line, treat rest as docstring content\n                if matched_lines:\n                    remaining_lines = doclines[j:]\n                    break\n        \n        # If we found signatures, update the docstring\n        if signatures:\n            # re-prepare docstring to ignore signature lines\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            if remaining_lines:\n                self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n                                                           tabsize=tab_width)\n            else:\n                # If no remaining lines after signatures, prepare empty docstring\n                self._new_docstrings[i] = []\n            break\n    \n    if signatures:\n        # Combine multiple signatures into a single args string\n        if len(signatures) == 1:\n            return signatures[0]\n        else:\n            # Format multiple signatures on separate lines\n            combined_args = '\\n'.join(sig[0] for sig in signatures if sig[0])\n            # Use the return annotation from the first signature\n            retann = signatures[0][1] if signatures[0][1] else ''\n            return combined_args, retann\n    \n    return None\n",
    "Location 3 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1040-1040)": "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n        \n        # the base name must match ours\n        valid_names = [self.objpath[-1]]  # type: ignore\n        if isinstance(self, ClassDocumenter):\n            valid_names.append('__init__')\n            if hasattr(self.object, '__mro__'):\n                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n        if base not in valid_names:\n            continue\n            \n        signatures.append((args, retann))\n        \n        # remove the processed signature line from docstring\n        del self._new_docstrings[i][0]\n        if not self._new_docstrings[i]:\n            del self._new_docstrings[i]\n    \n    if signatures:\n        # Combine multiple signatures with newlines\n        combined_args = '\\n'.join(sig[0] for sig in signatures)\n        # Use the return annotation from the first signature\n        retann = signatures[0][1] if signatures[0][1] else ''\n        return combined_args, retann\n    else:\n        return None, None\n",
    "Location 4 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1065-1069)": "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # Combine multiple signatures for overloaded methods\n                combined_args = result[0] + '\\n' + args\n                result = combined_args, retann\n            # continue looking for more signatures instead of breaking\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1070-1071)": [
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n\n    docstrings = self.get_doc(encoding)\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    \n    if not docstrings:\n        return None, None\n\n    # candidates of the object name\n    valid_names = [self.objpath[-1]]  # type: List[str]\n    if isinstance(self, ClassDocumenter):\n        valid_names.append('__init__')\n        if hasattr(self.object, '__mro__'):\n            valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n    elif isinstance(self, MethodDocumenter):\n        valid_names.extend(filter(None, [self.objpath[-1].rstrip('.'), \n                                        self.object.__name__]))\n    elif isinstance(self, FunctionDocumenter):\n        valid_names.append(self.object.__name__)\n\n    # look for the first signature line that matches one of the candidates\n    for i, doclines in enumerate(docstrings):\n        if not doclines:\n            continue\n        \n        lines_to_remove = 0\n        for j, line in enumerate(doclines):\n            match = py_ext_sig_re.match(line)\n            if not match:\n                break\n                \n            exmod, path, base, args, retann = match.groups()\n            # the base name must match ours\n            if base not in valid_names:\n                continue\n                \n            # Found a valid signature\n            signatures.append((args, retann))\n            lines_to_remove = j + 1\n            \n        if signatures and lines_to_remove > 0:\n            # re-prepare docstring to ignore signature lines\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[lines_to_remove:]),\n                                                        tabsize=tab_width)\n            break\n    \n    if not signatures:\n        return None, None\n        \n    # Combine multiple signatures into a single formatted string\n    if len(signatures) == 1:\n        return signatures[0]\n    else:\n        # Format multiple signatures on separate lines\n        combined_args = []\n        combined_retann = signatures[0][1]  # Use return annotation from first signature\n        for args, retann in signatures:\n            combined_args.append(args)\n        return '\\n'.join(combined_args), combined_retann\n",
      "\n            # don't look any further - collect all signatures instead\n            if result is None:\n                result = []\n            result.append((args, retann))\n            \n            # Continue processing to find additional overloaded signatures\n            # instead of breaking here\n",
      "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # Combine multiple signatures\n                combined_args = result[0] + '\\n' + args\n                result = combined_args, retann\n            # continue looking for more signatures\n",
      "\n        for i, line in enumerate(doclines):\n            if not line:\n                continue\n            # match first line of signature\n            match = py_ext_sig_re.match(line)\n            if not match:\n                continue\n            exmod, path, base, args, retann = match.groups()\n\n            # the base name must be the current class name\n            valid_names = [self.object.__name__]  # type: ignore\n            if isinstance(self, ClassDocumenter):\n                valid_names.append('__init__')\n                if hasattr(self.object, '__mro__'):\n                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n            if base not in valid_names:\n                continue\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # combine multiple signatures\n                combined_args = result[0] + '\\n' + args\n                result = combined_args, retann\n            # continue looking for more signatures\n",
      "\n            # don't look any further - collect all signatures instead\n            if result is None:\n                result = []\n            result.append((args, retann))\n            # Continue to look for more signatures instead of breaking\n",
      "\n        for i, line in enumerate(doclines):\n            if not line:\n                break\n            # match first line of docstring against signature RE\n            match = py_ext_sig_re.match(line)\n            if not match:\n                break\n            exmod, path, base, args, retann = match.groups()\n\n            # the base name must match ours\n            valid_names = [self.objpath[-1]]  # type: ignore\n            if isinstance(self, ClassDocumenter):\n                valid_names.append('__init__')\n                if hasattr(self.object, '__mro__'):\n                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n            if base not in valid_names:\n                continue\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[i+1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # combine multiple signatures\n                combined_args = result[0] + '\\n' + args\n                result = combined_args, retann\n",
      "\n            # don't look any further - collect all signatures instead\n            if result is None:\n                result = []\n            result.append((args, retann))\n",
      "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            result = args, retann\n            # continue looking for more signatures\n"
    ],
    "Location 2 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1047-1072)": [
      "\n    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n        if encoding is not None:\n            warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                          \"deprecated.\" % self.__class__.__name__,\n                          RemovedInSphinx40Warning, stacklevel=2)\n        docstrings = self.get_doc()\n        self._new_docstrings = docstrings[:]\n        signatures = []\n        matched_lines = set()\n        \n        for i, doclines in enumerate(docstrings):\n            # no lines in docstring, no match\n            if not doclines:\n                continue\n            \n            # Process each line in the docstring to find multiple signatures\n            lines_to_remove = []\n            for line_idx, line in enumerate(doclines):\n                # match line against signature RE\n                match = py_ext_sig_re.match(line)\n                if not match:\n                    continue\n                exmod, path, base, args, retann = match.groups()\n                # the base name must match ours\n                valid_names = [self.objpath[-1]]  # type: ignore\n                if isinstance(self, ClassDocumenter):\n                    valid_names.append('__init__')\n                    if hasattr(self.object, '__mro__'):\n                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n                if base not in valid_names:\n                    continue\n                # Found a valid signature\n                signatures.append((args, retann))\n                lines_to_remove.append(line_idx)\n            \n            # Remove matched signature lines and re-prepare docstring\n            if lines_to_remove:\n                remaining_lines = [line for idx, line in enumerate(doclines) \n                                 if idx not in lines_to_remove]\n                tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n                self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n                                                            tabsize=tab_width)\n                matched_lines.add(i)\n        \n        # Combine all found signatures\n        if signatures:\n            # Format multiple signatures with newlines\n            combined_args = '\\n'.join(sig[0] for sig in signatures if sig[0])\n            combined_retann = signatures[0][1] if signatures[0][1] else ''  # Use first return annotation\n            return combined_args, combined_retann\n        \n        return None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    lines_to_remove = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n        # the base name must match ours\n        valid_names = [self.objpath[-1]]  # type: ignore\n        if isinstance(self, ClassDocumenter):\n            valid_names.append('__init__')\n            if hasattr(self.object, '__mro__'):\n                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n        if base not in valid_names:\n            continue\n        # collect signature and mark line for removal\n        signatures.append((args, retann))\n        lines_to_remove.append((i, 0))  # docstring index, line index\n        \n        # check for additional overloaded signatures in subsequent lines\n        for j, line in enumerate(doclines[1:], 1):\n            match = py_ext_sig_re.match(line)\n            if not match:\n                break\n            exmod, path, base, args, retann = match.groups()\n            if base not in valid_names:\n                break\n            signatures.append((args, retann))\n            lines_to_remove.append((i, j))\n    \n    if signatures:\n        # re-prepare docstring to ignore signature lines and leading indentation\n        tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n        for i, doclines in enumerate(docstrings):\n            # remove signature lines from this docstring\n            lines_removed = [line_idx for doc_idx, line_idx in lines_to_remove if doc_idx == i]\n            if lines_removed:\n                # remove signature lines in reverse order to maintain indices\n                remaining_lines = doclines[:]\n                for line_idx in sorted(lines_removed, reverse=True):\n                    if line_idx < len(remaining_lines):\n                        remaining_lines.pop(line_idx)\n                self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n                                                            tabsize=tab_width)\n        \n        # combine all signatures\n        if len(signatures) == 1:\n            return signatures[0]\n        else:\n            # format multiple signatures\n            all_args = []\n            retann = signatures[0][1]  # use return annotation from first signature\n            for args, _ in signatures:\n                all_args.append(args)\n            combined_args = '\\n'.join(all_args)\n            return combined_args, retann\n    \n    return None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        \n        # Process all lines to find multiple signatures\n        processed_lines = []\n        signature_found = False\n        \n        for j, line in enumerate(doclines):\n            # match line against signature RE\n            match = py_ext_sig_re.match(line)\n            if match:\n                exmod, path, base, args, retann = match.groups()\n                # the base name must match ours\n                valid_names = [self.objpath[-1]]  # type: ignore\n                if isinstance(self, ClassDocumenter):\n                    valid_names.append('__init__')\n                    if hasattr(self.object, '__mro__'):\n                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n                if base in valid_names:\n                    signatures.append((args, retann))\n                    signature_found = True\n                    continue  # Skip signature lines from processed docstring\n            processed_lines.append(line)\n        \n        if signature_found:\n            # re-prepare docstring to ignore signature lines and leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(processed_lines),\n                                                        tabsize=tab_width)\n    \n    if signatures:\n        # Combine all signatures into a single args string\n        combined_args = []\n        retann = signatures[0][1]  # Use return annotation from first signature\n        for args, _ in signatures:\n            combined_args.append(args)\n        return '\\n'.join(combined_args), retann\n    \n    return None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        \n        # Find all signature lines at the beginning of the docstring\n        signature_lines = []\n        remaining_lines = []\n        found_non_signature = False\n        \n        for line_idx, line in enumerate(doclines):\n            if not found_non_signature:\n                match = py_ext_sig_re.match(line)\n                if match:\n                    exmod, path, base, args, retann = match.groups()\n                    # the base name must match ours\n                    valid_names = [self.objpath[-1]]  # type: ignore\n                    if isinstance(self, ClassDocumenter):\n                        valid_names.append('__init__')\n                        if hasattr(self.object, '__mro__'):\n                            valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n                    if base in valid_names:\n                        signatures.append((args, retann))\n                        signature_lines.append(line_idx)\n                    else:\n                        found_non_signature = True\n                        remaining_lines = doclines[line_idx:]\n                        break\n                else:\n                    found_non_signature = True\n                    remaining_lines = doclines[line_idx:]\n                    break\n            else:\n                break\n        \n        # If we found signatures, update the docstring to remove signature lines\n        if signatures:\n            # re-prepare docstring to ignore signature lines and leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n                                                        tabsize=tab_width)\n            break\n    \n    if signatures:\n        # Combine multiple signatures into a single formatted string\n        combined_args = []\n        combined_retann = signatures[0][1]  # Use return annotation from first signature\n        \n        for args, retann in signatures:\n            combined_args.append(args)\n            # If return annotations differ, use the first one\n            if not combined_retann and retann:\n                combined_retann = retann\n        \n        # Format multiple signatures on separate lines\n        if len(combined_args) > 1:\n            formatted_args = '\\n'.join(combined_args)\n        else:\n            formatted_args = combined_args[0]\n            \n        return formatted_args, combined_retann\n    \n    return None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        \n        # Process all lines to find multiple signatures\n        processed_lines = []\n        found_signatures = []\n        \n        for line_idx, line in enumerate(doclines):\n            # match each line of docstring against signature RE\n            match = py_ext_sig_re.match(line)\n            if match:\n                exmod, path, base, args, retann = match.groups()\n                # the base name must match ours\n                valid_names = [self.objpath[-1]]  # type: ignore\n                if isinstance(self, ClassDocumenter):\n                    valid_names.append('__init__')\n                    if hasattr(self.object, '__mro__'):\n                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n                if base in valid_names:\n                    found_signatures.append((args, retann))\n                    # Skip this line in the processed docstring\n                    continue\n            processed_lines.append(line)\n        \n        if found_signatures:\n            # re-prepare docstring to ignore signature lines and leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(processed_lines),\n                                                        tabsize=tab_width)\n            signatures.extend(found_signatures)\n    \n    if signatures:\n        # Combine multiple signatures into a single formatted string\n        combined_args = '\\n'.join(sig[0] for sig in signatures if sig[0])\n        combined_retann = signatures[0][1] if signatures[0][1] else ''\n        return combined_args, combined_retann\n    \n    return None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        \n        # Process all lines to find multiple signatures\n        matched_lines = 0\n        docstring_signatures = []\n        \n        for j, line in enumerate(doclines):\n            # match each line of docstring against signature RE\n            match = py_ext_sig_re.match(line)\n            if not match:\n                # If we haven't found any signatures yet, continue\n                if matched_lines == 0:\n                    continue\n                else:\n                    # Stop processing this docstring after consecutive signatures\n                    break\n            \n            exmod, path, base, args, retann = match.groups()\n            # the base name must match ours\n            valid_names = [self.objpath[-1]]  # type: ignore\n            if isinstance(self, ClassDocumenter):\n                valid_names.append('__init__')\n                if hasattr(self.object, '__mro__'):\n                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n            if base not in valid_names:\n                if matched_lines == 0:\n                    continue\n                else:\n                    break\n            \n            docstring_signatures.append((args, retann))\n            matched_lines += 1\n        \n        if docstring_signatures:\n            # re-prepare docstring to ignore signature lines\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            remaining_lines = doclines[matched_lines:] if matched_lines < len(doclines) else []\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n                                                        tabsize=tab_width)\n            signatures.extend(docstring_signatures)\n            # Process only the first docstring that contains signatures\n            break\n    \n    if signatures:\n        # Combine multiple signatures into a single formatted string\n        if len(signatures) == 1:\n            return signatures[0]\n        else:\n            # Format multiple signatures on separate lines\n            combined_args = '\\n'.join(sig[0] for sig in signatures)\n            # Use the return annotation from the first signature\n            return combined_args, signatures[0][1]\n    \n    return None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n        # the base name must match ours\n        valid_names = [self.objpath[-1]]  # type: ignore\n        if isinstance(self, ClassDocumenter):\n            valid_names.append('__init__')\n            if hasattr(self.object, '__mro__'):\n                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n        if base not in valid_names:\n            continue\n        # re-prepare docstring to ignore more leading indentation\n        tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n        self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                    tabsize=tab_width)\n        signatures.append((args, retann))\n        # continue to find additional signatures\n    \n    if signatures:\n        # Combine multiple signatures into a single string\n        combined_args = '\\n'.join(sig[0] for sig in signatures if sig[0])\n        combined_retann = signatures[0][1]  # Use return annotation from first signature\n        return combined_args, combined_retann\n    \n    return None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    matched_indices = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n        # the base name must match ours\n        valid_names = [self.objpath[-1]]  # type: ignore\n        if isinstance(self, ClassDocumenter):\n            valid_names.append('__init__')\n            if hasattr(self.object, '__mro__'):\n                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n        if base not in valid_names:\n            continue\n        # collect signature and mark docstring for processing\n        signatures.append((args, retann))\n        matched_indices.append(i)\n    \n    # process docstrings to remove signature lines\n    tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n    for i in matched_indices:\n        doclines = self._new_docstrings[i]\n        if doclines:\n            # re-prepare docstring to ignore signature line and leading indentation\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n    \n    if signatures:\n        # combine multiple signatures with newlines\n        combined_args = '\\n'.join(sig[0] for sig in signatures)\n        # use return annotation from first signature (they should be the same)\n        retann = signatures[0][1]\n        return combined_args, retann\n    \n    return None\n"
    ],
    "Location 3 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1040-1040)": [
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    lines_to_remove = []\n    \n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n\n        # the base name must match ours\n        valid_names = [self.objpath[-1]]  # type: ignore\n        if isinstance(self, ClassDocumenter):\n            valid_names.append('__init__')\n            if hasattr(self.object, '__mro__'):\n                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n        if base not in valid_names:\n            continue\n\n        # re-prepare docstring to ignore more leading indentation\n        tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n        self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines), tab_width)\n\n        signatures.append((args, retann))\n        lines_to_remove.append((i, 0))  # mark first line for removal\n\n    # Remove signature lines from docstrings\n    for i, line_idx in reversed(lines_to_remove):\n        if self._new_docstrings[i]:\n            del self._new_docstrings[i][line_idx]\n\n    if signatures:\n        # Combine multiple signatures into a single args string\n        if len(signatures) == 1:\n            args, retann = signatures[0]\n        else:\n            # For multiple signatures, format them as separate lines\n            combined_args = []\n            retann = signatures[0][1]  # Use return annotation from first signature\n            for args, _ in signatures:\n                combined_args.append(args)\n            args = '\\n'.join(combined_args)\n        \n        return args, retann\n    else:\n        return None, None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    \n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n        \n        # the base name must match ours\n        valid_names = [self.objpath[-1]]  # type: ignore\n        if isinstance(self, ClassDocumenter):\n            valid_names.append('__new__')\n            valid_names.append('__init__')\n        if base not in valid_names:\n            continue\n        \n        signatures.append((args, retann))\n        \n        # remove the processed signature line from docstring\n        new_doclines = doclines[1:]\n        self._new_docstrings[i] = new_doclines\n    \n    if signatures:\n        # combine multiple signatures into a single args string\n        combined_args = []\n        combined_retann = None\n        for args, retann in signatures:\n            combined_args.append(args)\n            if retann and not combined_retann:\n                combined_retann = retann\n        \n        # format multiple signatures on separate lines if more than one\n        if len(combined_args) > 1:\n            formatted_args = '\\n'.join(f'({args})' for args in combined_args)\n        else:\n            formatted_args = combined_args[0]\n            \n        return formatted_args, combined_retann or ''\n    \n    return None, None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    \n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        \n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        \n        exmod, path, base, args, retann = match.groups()\n        \n        # the base name must match ours\n        valid_names = [self.objpath[-1]]  # type: ignore\n        if isinstance(self, ClassDocumenter):\n            valid_names.append('__init__')\n            if hasattr(self.object, '__mro__'):\n                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n        if base not in valid_names:\n            continue\n            \n        signatures.append((args, retann))\n        \n        # remove the signature from the docstring\n        del self._new_docstrings[i][0]\n        if retann:\n            del self._new_docstrings[i][0]\n    \n    # combine all signatures into a single formatted string\n    if signatures:\n        combined_args = []\n        combined_retann = None\n        for args, retann in signatures:\n            combined_args.append(args)\n            if retann:\n                combined_retann = retann\n        \n        # format multiple signatures on separate lines\n        if len(combined_args) > 1:\n            formatted_args = '\\n'.join(f\"({args})\" for args in combined_args)\n        else:\n            formatted_args = combined_args[0] if combined_args else ''\n            \n        return formatted_args, combined_retann or ''\n    \n    return '', ''\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    lines_to_remove = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n        # the base name must match ours\n        valid_names = [self.objpath[-1]]  # type: ignore\n        if isinstance(self, ClassDocumenter):\n            valid_names.append('__init__')\n            if hasattr(self.object, '__mro__'):\n                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n        if base not in valid_names:\n            continue\n        signatures.append((args, retann))\n        lines_to_remove.append((i, 0))  # Track which lines to remove\n        \n        # Look for additional overloaded signatures on subsequent lines\n        for j in range(1, len(doclines)):\n            match = py_ext_sig_re.match(doclines[j])\n            if not match:\n                break\n            exmod, path, base, args, retann = match.groups()\n            if base not in valid_names:\n                break\n            signatures.append((args, retann))\n            lines_to_remove.append((i, j))\n    \n    if not signatures:\n        return None, None\n    \n    # Remove signature lines from docstrings\n    for doc_idx, line_idx in reversed(lines_to_remove):\n        del self._new_docstrings[doc_idx][line_idx]\n    \n    # Combine all signatures\n    if len(signatures) == 1:\n        args, retann = signatures[0]\n    else:\n        # Format multiple signatures on separate lines\n        formatted_sigs = []\n        for args, retann in signatures:\n            if retann:\n                formatted_sigs.append(f\"{args} -> {retann}\")\n            else:\n                formatted_sigs.append(args)\n        args = \"\\n\".join(formatted_sigs)\n        retann = \"\"\n    \n    return args, retann\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n        # the base name must match ours\n        valid_names = [self.objpath[-1]]  # type: ignore\n        if isinstance(self, ClassDocumenter):\n            valid_names.append('__init__')\n            if hasattr(self.object, '__mro__'):\n                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n        if base not in valid_names:\n            continue\n        signatures.append((args, retann))\n        # remove the processed signature line from docstring copy\n        self._new_docstrings[i] = doclines[1:]\n    \n    if signatures:\n        # Combine all signatures into a multi-line format\n        combined_args = '\\n'.join(sig[0] for sig in signatures)\n        # Use the return annotation from the first signature\n        retann = signatures[0][1]\n        return combined_args, retann\n    return None, None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n\n        # the base name must match ours\n        if not self.env.config.autodoc_docstring_signature:  # only act if enabled\n            continue\n        if base not in (self.objpath[-1], '__new__', '__init__'):\n            continue\n\n        signatures.append((args, retann))\n        # remove the first line from docstring\n        del doclines[0]\n\n    if not signatures:\n        return None, None\n\n    # combine all signatures\n    if len(signatures) == 1:\n        args, retann = signatures[0]\n    else:\n        # format multiple signatures\n        formatted_sigs = []\n        for args, retann in signatures:\n            if retann:\n                formatted_sigs.append(f\"{args} -> {retann}\")\n            else:\n                formatted_sigs.append(args)\n        args = '\\n'.join(formatted_sigs)\n        retann = None\n\n    return args, retann\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n\n        # the base name must match ours\n        if not self.env.config.autodoc_docstring_signature:  # only act if enabled\n            continue\n        if base not in self.objpath:  # modname::one.two.three\n            continue\n\n        signatures.append((args, retann))\n        # remove the processed signature line from docstring\n        del self._new_docstrings[i][0]\n        if not self._new_docstrings[i]:\n            del self._new_docstrings[i]\n\n    if signatures:\n        # combine all signatures into a single formatted string\n        combined_args = []\n        retann = signatures[0][1]  # use return annotation from first signature\n        for args, _ in signatures:\n            combined_args.append(args)\n        # join multiple signatures with newlines for display\n        result_args = '\\n'.join(combined_args) if len(signatures) > 1 else signatures[0][0]\n        return result_args, retann\n    else:\n        return None, None\n",
      "\ndef _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                      \"deprecated.\" % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstrings = self.get_doc()\n    self._new_docstrings = docstrings[:]\n    signatures = []\n    for i, doclines in enumerate(docstrings):\n        # no lines in docstring, no match\n        if not doclines:\n            continue\n        # match first line of docstring against signature RE\n        match = py_ext_sig_re.match(doclines[0])\n        if not match:\n            continue\n        exmod, path, base, args, retann = match.groups()\n        # the base name must match ours\n        if not self.env.config.autodoc_docstring_signature:  # only act if enabled\n            continue\n        if base not in self.objpath:  # modname not allowed\n            continue\n        signatures.append((args, retann))\n        # remove the processed signature line from this docstring\n        del self._new_docstrings[i][0]\n        if not self._new_docstrings[i]:\n            del self._new_docstrings[i]\n    \n    if signatures:\n        # Combine all signatures into a single args string\n        combined_args = []\n        retann = signatures[0][1] if signatures[0][1] else None  # Use return annotation from first signature\n        for args, _ in signatures:\n            if args:\n                combined_args.append(args.strip())\n        \n        if combined_args:\n            # Join multiple signatures with newlines for proper display\n            final_args = '\\n'.join(combined_args) if len(combined_args) > 1 else combined_args[0]\n            return final_args, retann or ''\n    \n    return None, None\n"
    ],
    "Location 4 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1065-1069)": [
      "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # Combine multiple signatures for overloaded methods\n                combined_args = result[0] + '\\n' + args\n                result = combined_args, retann\n            # continue looking for more signatures instead of breaking\n",
      "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # Combine multiple signatures for overloaded methods\n                combined_args = result[0] + '\\n' + args\n                result = combined_args, retann\n            # continue looking for more signatures (don't break)\n",
      "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # Combine multiple signatures for overloaded methods\n                combined_args = result[0] + '\\n' + args\n                result = combined_args, retann\n            # continue looking for more signatures instead of breaking\n",
      "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # Combine multiple signatures for overloaded methods\n                combined_args = result[0] + '\\n' + args\n                result = combined_args, retann\n            # continue looking for more signatures\n",
      "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # Combine multiple signatures for overloaded methods\n                existing_args, existing_retann = result\n                combined_args = existing_args + '\\n' + args\n                # Use the return annotation from the first signature\n                result = combined_args, existing_retann\n            # continue looking for more signatures\n",
      "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # Combine multiple signatures for overloaded methods\n                existing_args, existing_retann = result\n                combined_args = existing_args + '\\n' + args\n                result = combined_args, retann if retann else existing_retann\n",
      "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # Combine multiple signatures for overloaded methods\n                combined_args = result[0] + '\\n' + args\n                result = combined_args, retann\n            # continue looking for more signatures instead of breaking\n",
      "\n            # re-prepare docstring to ignore more leading indentation\n            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                        tabsize=tab_width)\n            if result is None:\n                result = args, retann\n            else:\n                # Combine multiple signatures for overloaded methods\n                combined_args = result[0] + '\\n' + args\n                result = combined_args, retann\n            # continue looking for more signatures\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..e4d836a57 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,6 +1037,7 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n+\n     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n@@ -1044,31 +1045,75 @@ class DocstringSignatureMixin:\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n+\n+        signatures = []\n+        signature_lines_to_remove = []\n         for i, doclines in enumerate(docstrings):\n             # no lines in docstring, no match\n             if not doclines:\n                 continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n-            if base not in valid_names:\n-                continue\n-            # re-prepare docstring to ignore more leading indentation\n-            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n-                                                        tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n+            \n+            # Check each line in the docstring for signatures\n+            lines_consumed = 0\n+            for line_idx, line in enumerate(doclines):\n+                match = py_ext_sig_re.match(line)\n+                if not match:\n+                    # If we haven't found any signatures yet, continue checking\n+                    if lines_consumed == 0:\n+                        continue\n+                    else:\n+                        # We've found signatures before, stop at first non-signature line\n+                        break\n+                \n+                exmod, path, base, args, retann = match.groups()\n+                # the base name must match ours\n+                valid_names = [self.objpath[-1]]  # type: ignore\n+                if isinstance(self, ClassDocumenter):\n+                    valid_names.append('__init__')\n+                    if hasattr(self.object, '__mro__'):\n+                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+                if base not in valid_names:\n+                    # If we haven't found any signatures yet, continue checking\n+                    if lines_consumed == 0:\n+                        continue\n+                    else:\n+                        # We've found signatures before, stop at first non-matching signature\n+                        break\n+                \n+                # Found a valid signature\n+                signatures.append((args, retann))\n+                lines_consumed += 1\n+            \n+            # If we found signatures, prepare the modified docstring\n+            if lines_consumed > 0:\n+                # re-prepare docstring to ignore more leading indentation\n+                tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+                self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[lines_consumed:]),\n+                                                            tabsize=tab_width)\n+                break  # Only process the first docstring that contains signatures\n+        \n+        # Combine all signatures into a single result\n+        if signatures:\n+            # Combine arguments from all signatures, separated by newlines for multiple overloads\n+            combined_args = []\n+            combined_retann = None\n+            \n+            for args, retann in signatures:\n+                if args:\n+                    combined_args.append(args)\n+                # Use the return annotation from the last signature (or first non-None one)\n+                if retann:\n+                    combined_retann = retann\n+            \n+            if len(combined_args) == 1:\n+                # Single signature - return as before\n+                result = combined_args[0], combined_retann\n+            else:\n+                # Multiple signatures - combine with newlines\n+                result = '\\n'.join(f'({args})' if args else '()' for args in combined_args), combined_retann\n+        else:\n+            result = None\n+            \n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..ac64a18d0 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,38 +1037,125 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+        \n+        # the base name must match ours\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__init__')\n+            if hasattr(self.object, '__mro__'):\n+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+        if base not in valid_names:\n+            continue\n+            \n+        signatures.append((args, retann))\n+        \n+        # remove the processed signature line from docstring\n+        del self._new_docstrings[i][0]\n+        if not self._new_docstrings[i]:\n+            del self._new_docstrings[i]\n+    \n+    if signatures:\n+        # Combine multiple signatures with newlines\n+        combined_args = '\\n'.join(sig[0] for sig in signatures)\n+        # Use the return annotation from the first signature\n+        retann = signatures[0][1] if signatures[0][1] else ''\n+        return combined_args, retann\n+    else:\n+        return None, None\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                           \"deprecated.\" % self.__class__.__name__,\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n-        for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n-            if not doclines:\n-                continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n-            if base not in valid_names:\n-                continue\n-            # re-prepare docstring to ignore more leading indentation\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        \n+        # Process all lines to find multiple signatures\n+        matched_lines = []\n+        remaining_lines = []\n+        \n+        for j, line in enumerate(doclines):\n+            match = py_ext_sig_re.match(line)\n+            if match:\n+                exmod, path, base, args, retann = match.groups()\n+                # the base name must match ours\n+                valid_names = [self.objpath[-1]]  # type: ignore\n+                if isinstance(self, ClassDocumenter):\n+                    valid_names.append('__init__')\n+                    if hasattr(self.object, '__mro__'):\n+                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+                if base in valid_names:\n+                    signatures.append((args, retann))\n+                    matched_lines.append(j)\n+            else:\n+                # Once we hit a non-signature line, treat rest as docstring content\n+                if matched_lines:\n+                    remaining_lines = doclines[j:]\n+                    break\n+        \n+        # If we found signatures, update the docstring\n+        if signatures:\n+            # re-prepare docstring to ignore signature lines\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n-                                                        tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n+            if remaining_lines:\n+                self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n+                                                           tabsize=tab_width)\n+            else:\n+                # If no remaining lines after signatures, prepare empty docstring\n+                self._new_docstrings[i] = []\n             break\n+    \n+    if signatures:\n+        # Combine multiple signatures into a single args string\n+        if len(signatures) == 1:\n+            return signatures[0]\n+        else:\n+            # Format multiple signatures on separate lines\n+            combined_args = '\\n'.join(sig[0] for sig in signatures if sig[0])\n+            # Use the return annotation from the first signature\n+            retann = signatures[0][1] if signatures[0][1] else ''\n+            return combined_args, retann\n+    \n+    return None\n+                # Combine multiple signatures for overloaded methods\n+                combined_args = result[0] + '\\n' + args\n+                result = combined_args, retann\n+            # continue looking for more signatures instead of breaking\n+\n+            # don't look any further - collect all signatures instead\n+            if result is None:\n+                result = []\n+            result.append((args, retann))\n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..f7c08b47e 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,6 +1037,70 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    lines_to_remove = []\n+    \n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+\n+        # the base name must match ours\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__init__')\n+            if hasattr(self.object, '__mro__'):\n+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+        if base not in valid_names:\n+            continue\n+\n+        # re-prepare docstring to ignore more leading indentation\n+        tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+        self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines), tab_width)\n+\n+        signatures.append((args, retann))\n+        lines_to_remove.append((i, 0))  # mark first line for removal\n+\n+    # Remove signature lines from docstrings\n+    for i, line_idx in reversed(lines_to_remove):\n+        if self._new_docstrings[i]:\n+            del self._new_docstrings[i][line_idx]\n+\n+    if signatures:\n+        # Combine multiple signatures into a single args string\n+        if len(signatures) == 1:\n+            args, retann = signatures[0]\n+        else:\n+            # For multiple signatures, format them as separate lines\n+            combined_args = []\n+            retann = signatures[0][1]  # Use return annotation from first signature\n+            for args, _ in signatures:\n+                combined_args.append(args)\n+            args = '\\n'.join(combined_args)\n+        \n+        return args, retann\n+    else:\n+        return None, None\n+        if encoding is not None:\n+            warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                          \"deprecated.\" % self.__class__.__name__,\n+                          RemovedInSphinx40Warning, stacklevel=2)\n+        docstrings = self.get_doc()\n+        self._new_docstrings = docstrings[:]\n+\n     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n@@ -1044,31 +1108,121 @@ class DocstringSignatureMixin:\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n+        signatures = []\n+        matched_lines = set()\n+        \n         for i, doclines in enumerate(docstrings):\n             # no lines in docstring, no match\n             if not doclines:\n                 continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n+            \n+            # Process each line in the docstring to find multiple signatures\n+            lines_to_remove = []\n+            for line_idx, line in enumerate(doclines):\n+                # match line against signature RE\n+                match = py_ext_sig_re.match(line)\n+                if not match:\n+                    continue\n+                exmod, path, base, args, retann = match.groups()\n+                # the base name must match ours\n+                valid_names = [self.objpath[-1]]  # type: ignore\n+                if isinstance(self, ClassDocumenter):\n+                    valid_names.append('__init__')\n+                    if hasattr(self.object, '__mro__'):\n+                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+                if base not in valid_names:\n+                    continue\n+                # Found a valid signature\n+                signatures.append((args, retann))\n+                lines_to_remove.append(line_idx)\n+            \n+            # Remove matched signature lines and re-prepare docstring\n+            if lines_to_remove:\n+                remaining_lines = [line for idx, line in enumerate(doclines) \n+                                 if idx not in lines_to_remove]\n+                tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+                self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n+                                                            tabsize=tab_width)\n+                matched_lines.add(i)\n+        \n+        # Combine all found signatures\n+        if signatures:\n+            # Format multiple signatures with newlines\n+            combined_args = '\\n'.join(sig[0] for sig in signatures if sig[0])\n+            combined_retann = signatures[0][1] if signatures[0][1] else ''  # Use first return annotation\n+            return combined_args, combined_retann\n+        \n+        return None\n+                # Combine multiple signatures for overloaded methods\n+                combined_args = result[0] + '\\n' + args\n+                result = combined_args, retann\n+            # continue looking for more signatures instead of breaking\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+\n+    docstrings = self.get_doc(encoding)\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    \n+    if not docstrings:\n+        return None, None\n+\n+    # candidates of the object name\n+    valid_names = [self.objpath[-1]]  # type: List[str]\n+    if isinstance(self, ClassDocumenter):\n+        valid_names.append('__init__')\n+        if hasattr(self.object, '__mro__'):\n+            valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+    elif isinstance(self, MethodDocumenter):\n+        valid_names.extend(filter(None, [self.objpath[-1].rstrip('.'), \n+                                        self.object.__name__]))\n+    elif isinstance(self, FunctionDocumenter):\n+        valid_names.append(self.object.__name__)\n+\n+    # look for the first signature line that matches one of the candidates\n+    for i, doclines in enumerate(docstrings):\n+        if not doclines:\n+            continue\n+        \n+        lines_to_remove = 0\n+        for j, line in enumerate(doclines):\n+            match = py_ext_sig_re.match(line)\n             if not match:\n-                continue\n+                break\n+                \n             exmod, path, base, args, retann = match.groups()\n             # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n             if base not in valid_names:\n                 continue\n-            # re-prepare docstring to ignore more leading indentation\n+                \n+            # Found a valid signature\n+            signatures.append((args, retann))\n+            lines_to_remove = j + 1\n+            \n+        if signatures and lines_to_remove > 0:\n+            # re-prepare docstring to ignore signature lines\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n+            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[lines_to_remove:]),\n                                                         tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n             break\n+    \n+    if not signatures:\n+        return None, None\n+        \n+    # Combine multiple signatures into a single formatted string\n+    if len(signatures) == 1:\n+        return signatures[0]\n+    else:\n+        # Format multiple signatures on separate lines\n+        combined_args = []\n+        combined_retann = signatures[0][1]  # Use return annotation from first signature\n+        for args, retann in signatures:\n+            combined_args.append(args)\n+        return '\\n'.join(combined_args), combined_retann\n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..835fb09f4 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,38 +1037,146 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    \n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+        \n+        # the base name must match ours\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__new__')\n+            valid_names.append('__init__')\n+        if base not in valid_names:\n+            continue\n+        \n+        signatures.append((args, retann))\n+        \n+        # remove the processed signature line from docstring\n+        new_doclines = doclines[1:]\n+        self._new_docstrings[i] = new_doclines\n+    \n+    if signatures:\n+        # combine multiple signatures into a single args string\n+        combined_args = []\n+        combined_retann = None\n+        for args, retann in signatures:\n+            combined_args.append(args)\n+            if retann and not combined_retann:\n+                combined_retann = retann\n+        \n+        # format multiple signatures on separate lines if more than one\n+        if len(combined_args) > 1:\n+            formatted_args = '\\n'.join(f'({args})' for args in combined_args)\n+        else:\n+            formatted_args = combined_args[0]\n+            \n+        return formatted_args, combined_retann or ''\n+    \n+    return None, None\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                           \"deprecated.\" % self.__class__.__name__,\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n-        for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n-            if not doclines:\n-                continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    lines_to_remove = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+        # the base name must match ours\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__init__')\n+            if hasattr(self.object, '__mro__'):\n+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+        if base not in valid_names:\n+            continue\n+        # collect signature and mark line for removal\n+        signatures.append((args, retann))\n+        lines_to_remove.append((i, 0))  # docstring index, line index\n+        \n+        # check for additional overloaded signatures in subsequent lines\n+        for j, line in enumerate(doclines[1:], 1):\n+            match = py_ext_sig_re.match(line)\n             if not match:\n-                continue\n+                break\n             exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n             if base not in valid_names:\n-                continue\n-            # re-prepare docstring to ignore more leading indentation\n-            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n-                                                        tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n+                break\n+            signatures.append((args, retann))\n+            lines_to_remove.append((i, j))\n+    \n+    if signatures:\n+        # re-prepare docstring to ignore signature lines and leading indentation\n+        tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+        for i, doclines in enumerate(docstrings):\n+            # remove signature lines from this docstring\n+            lines_removed = [line_idx for doc_idx, line_idx in lines_to_remove if doc_idx == i]\n+            if lines_removed:\n+                # remove signature lines in reverse order to maintain indices\n+                remaining_lines = doclines[:]\n+                for line_idx in sorted(lines_removed, reverse=True):\n+                    if line_idx < len(remaining_lines):\n+                        remaining_lines.pop(line_idx)\n+                self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n+                                                            tabsize=tab_width)\n+        \n+        # combine all signatures\n+        if len(signatures) == 1:\n+            return signatures[0]\n+        else:\n+            # format multiple signatures\n+            all_args = []\n+            retann = signatures[0][1]  # use return annotation from first signature\n+            for args, _ in signatures:\n+                all_args.append(args)\n+            combined_args = '\\n'.join(all_args)\n+            return combined_args, retann\n+    \n+    return None\n+                # Combine multiple signatures for overloaded methods\n+                combined_args = result[0] + '\\n' + args\n+                result = combined_args, retann\n+            # continue looking for more signatures (don't break)\n+\n+            # don't look any further - collect all signatures instead\n+            if result is None:\n+                result = []\n+            result.append((args, retann))\n+            \n+            # Continue processing to find additional overloaded signatures\n+            # instead of breaking here\n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..0f7eafc3d 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,38 +1037,134 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    \n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        \n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        \n+        exmod, path, base, args, retann = match.groups()\n+        \n+        # the base name must match ours\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__init__')\n+            if hasattr(self.object, '__mro__'):\n+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+        if base not in valid_names:\n+            continue\n+            \n+        signatures.append((args, retann))\n+        \n+        # remove the signature from the docstring\n+        del self._new_docstrings[i][0]\n+        if retann:\n+            del self._new_docstrings[i][0]\n+    \n+    # combine all signatures into a single formatted string\n+    if signatures:\n+        combined_args = []\n+        combined_retann = None\n+        for args, retann in signatures:\n+            combined_args.append(args)\n+            if retann:\n+                combined_retann = retann\n+        \n+        # format multiple signatures on separate lines\n+        if len(combined_args) > 1:\n+            formatted_args = '\\n'.join(f\"({args})\" for args in combined_args)\n+        else:\n+            formatted_args = combined_args[0] if combined_args else ''\n+            \n+        return formatted_args, combined_retann or ''\n+    \n+    return '', ''\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                           \"deprecated.\" % self.__class__.__name__,\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n-        for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n-            if not doclines:\n-                continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n-            if base not in valid_names:\n-                continue\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        \n+        # Process all lines to find multiple signatures\n+        processed_lines = []\n+        signature_found = False\n+        \n+        for j, line in enumerate(doclines):\n+            # match line against signature RE\n+            match = py_ext_sig_re.match(line)\n+            if match:\n+                exmod, path, base, args, retann = match.groups()\n+                # the base name must match ours\n+                valid_names = [self.objpath[-1]]  # type: ignore\n+                if isinstance(self, ClassDocumenter):\n+                    valid_names.append('__init__')\n+                    if hasattr(self.object, '__mro__'):\n+                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+                if base in valid_names:\n+                    signatures.append((args, retann))\n+                    signature_found = True\n+                    continue  # Skip signature lines from processed docstring\n+            processed_lines.append(line)\n+        \n+        if signature_found:\n+            # re-prepare docstring to ignore signature lines and leading indentation\n+            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+            self._new_docstrings[i] = prepare_docstring('\\n'.join(processed_lines),\n+                                                        tabsize=tab_width)\n+    \n+    if signatures:\n+        # Combine all signatures into a single args string\n+        combined_args = []\n+        retann = signatures[0][1]  # Use return annotation from first signature\n+        for args, _ in signatures:\n+            combined_args.append(args)\n+        return '\\n'.join(combined_args), retann\n+    \n+    return None\n+                # Combine multiple signatures for overloaded methods\n+                combined_args = result[0] + '\\n' + args\n+                result = combined_args, retann\n+            # continue looking for more signatures instead of breaking\n+\n             # re-prepare docstring to ignore more leading indentation\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n             self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                         tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n+            if result is None:\n+                result = args, retann\n+            else:\n+                # Combine multiple signatures\n+                combined_args = result[0] + '\\n' + args\n+                result = combined_args, retann\n+            # continue looking for more signatures\n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..e571261e0 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,25 +1037,163 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    lines_to_remove = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+        # the base name must match ours\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__init__')\n+            if hasattr(self.object, '__mro__'):\n+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+        if base not in valid_names:\n+            continue\n+        signatures.append((args, retann))\n+        lines_to_remove.append((i, 0))  # Track which lines to remove\n+        \n+        # Look for additional overloaded signatures on subsequent lines\n+        for j in range(1, len(doclines)):\n+            match = py_ext_sig_re.match(doclines[j])\n+            if not match:\n+                break\n+            exmod, path, base, args, retann = match.groups()\n+            if base not in valid_names:\n+                break\n+            signatures.append((args, retann))\n+            lines_to_remove.append((i, j))\n+    \n+    if not signatures:\n+        return None, None\n+    \n+    # Remove signature lines from docstrings\n+    for doc_idx, line_idx in reversed(lines_to_remove):\n+        del self._new_docstrings[doc_idx][line_idx]\n+    \n+    # Combine all signatures\n+    if len(signatures) == 1:\n+        args, retann = signatures[0]\n+    else:\n+        # Format multiple signatures on separate lines\n+        formatted_sigs = []\n+        for args, retann in signatures:\n+            if retann:\n+                formatted_sigs.append(f\"{args} -> {retann}\")\n+            else:\n+                formatted_sigs.append(args)\n+        args = \"\\n\".join(formatted_sigs)\n+        retann = \"\"\n+    \n+    return args, retann\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                           \"deprecated.\" % self.__class__.__name__,\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n-        for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n-            if not doclines:\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        \n+        # Find all signature lines at the beginning of the docstring\n+        signature_lines = []\n+        remaining_lines = []\n+        found_non_signature = False\n+        \n+        for line_idx, line in enumerate(doclines):\n+            if not found_non_signature:\n+                match = py_ext_sig_re.match(line)\n+                if match:\n+                    exmod, path, base, args, retann = match.groups()\n+                    # the base name must match ours\n+                    valid_names = [self.objpath[-1]]  # type: ignore\n+                    if isinstance(self, ClassDocumenter):\n+                        valid_names.append('__init__')\n+                        if hasattr(self.object, '__mro__'):\n+                            valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+                    if base in valid_names:\n+                        signatures.append((args, retann))\n+                        signature_lines.append(line_idx)\n+                    else:\n+                        found_non_signature = True\n+                        remaining_lines = doclines[line_idx:]\n+                        break\n+                else:\n+                    found_non_signature = True\n+                    remaining_lines = doclines[line_idx:]\n+                    break\n+            else:\n+                break\n+        \n+        # If we found signatures, update the docstring to remove signature lines\n+        if signatures:\n+            # re-prepare docstring to ignore signature lines and leading indentation\n+            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+            self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n+                                                        tabsize=tab_width)\n+            break\n+    \n+    if signatures:\n+        # Combine multiple signatures into a single formatted string\n+        combined_args = []\n+        combined_retann = signatures[0][1]  # Use return annotation from first signature\n+        \n+        for args, retann in signatures:\n+            combined_args.append(args)\n+            # If return annotations differ, use the first one\n+            if not combined_retann and retann:\n+                combined_retann = retann\n+        \n+        # Format multiple signatures on separate lines\n+        if len(combined_args) > 1:\n+            formatted_args = '\\n'.join(combined_args)\n+        else:\n+            formatted_args = combined_args[0]\n+            \n+        return formatted_args, combined_retann\n+    \n+    return None\n+                # Combine multiple signatures for overloaded methods\n+                combined_args = result[0] + '\\n' + args\n+                result = combined_args, retann\n+            # continue looking for more signatures\n+\n+        for i, line in enumerate(doclines):\n+            if not line:\n                 continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n+            # match first line of signature\n+            match = py_ext_sig_re.match(line)\n             if not match:\n                 continue\n             exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n+\n+            # the base name must be the current class name\n+            valid_names = [self.object.__name__]  # type: ignore\n             if isinstance(self, ClassDocumenter):\n                 valid_names.append('__init__')\n                 if hasattr(self.object, '__mro__'):\n@@ -1066,9 +1204,13 @@ class DocstringSignatureMixin:\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n             self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                         tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n+            if result is None:\n+                result = args, retann\n+            else:\n+                # combine multiple signatures\n+                combined_args = result[0] + '\\n' + args\n+                result = combined_args, retann\n+            # continue looking for more signatures\n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..4d0e6d68a 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,38 +1037,110 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+        # the base name must match ours\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__init__')\n+            if hasattr(self.object, '__mro__'):\n+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+        if base not in valid_names:\n+            continue\n+        signatures.append((args, retann))\n+        # remove the processed signature line from docstring copy\n+        self._new_docstrings[i] = doclines[1:]\n+    \n+    if signatures:\n+        # Combine all signatures into a multi-line format\n+        combined_args = '\\n'.join(sig[0] for sig in signatures)\n+        # Use the return annotation from the first signature\n+        retann = signatures[0][1]\n+        return combined_args, retann\n+    return None, None\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                           \"deprecated.\" % self.__class__.__name__,\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n-        for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n-            if not doclines:\n-                continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n-            if base not in valid_names:\n-                continue\n-            # re-prepare docstring to ignore more leading indentation\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        \n+        # Process all lines to find multiple signatures\n+        processed_lines = []\n+        found_signatures = []\n+        \n+        for line_idx, line in enumerate(doclines):\n+            # match each line of docstring against signature RE\n+            match = py_ext_sig_re.match(line)\n+            if match:\n+                exmod, path, base, args, retann = match.groups()\n+                # the base name must match ours\n+                valid_names = [self.objpath[-1]]  # type: ignore\n+                if isinstance(self, ClassDocumenter):\n+                    valid_names.append('__init__')\n+                    if hasattr(self.object, '__mro__'):\n+                        valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+                if base in valid_names:\n+                    found_signatures.append((args, retann))\n+                    # Skip this line in the processed docstring\n+                    continue\n+            processed_lines.append(line)\n+        \n+        if found_signatures:\n+            # re-prepare docstring to ignore signature lines and leading indentation\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n+            self._new_docstrings[i] = prepare_docstring('\\n'.join(processed_lines),\n                                                         tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n+            signatures.extend(found_signatures)\n+    \n+    if signatures:\n+        # Combine multiple signatures into a single formatted string\n+        combined_args = '\\n'.join(sig[0] for sig in signatures if sig[0])\n+        combined_retann = signatures[0][1] if signatures[0][1] else ''\n+        return combined_args, combined_retann\n+    \n+    return None\n+                # Combine multiple signatures for overloaded methods\n+                existing_args, existing_retann = result\n+                combined_args = existing_args + '\\n' + args\n+                # Use the return annotation from the first signature\n+                result = combined_args, existing_retann\n+            # continue looking for more signatures\n+\n+            # don't look any further - collect all signatures instead\n+            if result is None:\n+                result = []\n+            result.append((args, retann))\n+            # Continue to look for more signatures instead of breaking\n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..c496947c3 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,23 +1037,139 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+\n+        # the base name must match ours\n+        if not self.env.config.autodoc_docstring_signature:  # only act if enabled\n+            continue\n+        if base not in (self.objpath[-1], '__new__', '__init__'):\n+            continue\n+\n+        signatures.append((args, retann))\n+        # remove the first line from docstring\n+        del doclines[0]\n+\n+    if not signatures:\n+        return None, None\n+\n+    # combine all signatures\n+    if len(signatures) == 1:\n+        args, retann = signatures[0]\n+    else:\n+        # format multiple signatures\n+        formatted_sigs = []\n+        for args, retann in signatures:\n+            if retann:\n+                formatted_sigs.append(f\"{args} -> {retann}\")\n+            else:\n+                formatted_sigs.append(args)\n+        args = '\\n'.join(formatted_sigs)\n+        retann = None\n+\n+    return args, retann\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                           \"deprecated.\" % self.__class__.__name__,\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n-        for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n-            if not doclines:\n-                continue\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        \n+        # Process all lines to find multiple signatures\n+        matched_lines = 0\n+        docstring_signatures = []\n+        \n+        for j, line in enumerate(doclines):\n+            # match each line of docstring against signature RE\n+            match = py_ext_sig_re.match(line)\n+            if not match:\n+                # If we haven't found any signatures yet, continue\n+                if matched_lines == 0:\n+                    continue\n+                else:\n+                    # Stop processing this docstring after consecutive signatures\n+                    break\n+            \n+            exmod, path, base, args, retann = match.groups()\n+            # the base name must match ours\n+            valid_names = [self.objpath[-1]]  # type: ignore\n+            if isinstance(self, ClassDocumenter):\n+                valid_names.append('__init__')\n+                if hasattr(self.object, '__mro__'):\n+                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+            if base not in valid_names:\n+                if matched_lines == 0:\n+                    continue\n+                else:\n+                    break\n+            \n+            docstring_signatures.append((args, retann))\n+            matched_lines += 1\n+        \n+        if docstring_signatures:\n+            # re-prepare docstring to ignore signature lines\n+            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+            remaining_lines = doclines[matched_lines:] if matched_lines < len(doclines) else []\n+            self._new_docstrings[i] = prepare_docstring('\\n'.join(remaining_lines),\n+                                                        tabsize=tab_width)\n+            signatures.extend(docstring_signatures)\n+            # Process only the first docstring that contains signatures\n+            break\n+    \n+    if signatures:\n+        # Combine multiple signatures into a single formatted string\n+        if len(signatures) == 1:\n+            return signatures[0]\n+        else:\n+            # Format multiple signatures on separate lines\n+            combined_args = '\\n'.join(sig[0] for sig in signatures)\n+            # Use the return annotation from the first signature\n+            return combined_args, signatures[0][1]\n+    \n+    return None\n+                # Combine multiple signatures for overloaded methods\n+                existing_args, existing_retann = result\n+                combined_args = existing_args + '\\n' + args\n+                result = combined_args, retann if retann else existing_retann\n+\n+        for i, line in enumerate(doclines):\n+            if not line:\n+                break\n             # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n+            match = py_ext_sig_re.match(line)\n             if not match:\n-                continue\n+                break\n             exmod, path, base, args, retann = match.groups()\n+\n             # the base name must match ours\n             valid_names = [self.objpath[-1]]  # type: ignore\n             if isinstance(self, ClassDocumenter):\n@@ -1064,11 +1180,14 @@ class DocstringSignatureMixin:\n                 continue\n             # re-prepare docstring to ignore more leading indentation\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n+            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[i+1:]),\n                                                         tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n+            if result is None:\n+                result = args, retann\n+            else:\n+                # combine multiple signatures\n+                combined_args = result[0] + '\\n' + args\n+                result = combined_args, retann\n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..23a8e2656 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,38 +1037,103 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+\n+        # the base name must match ours\n+        if not self.env.config.autodoc_docstring_signature:  # only act if enabled\n+            continue\n+        if base not in self.objpath:  # modname::one.two.three\n+            continue\n+\n+        signatures.append((args, retann))\n+        # remove the processed signature line from docstring\n+        del self._new_docstrings[i][0]\n+        if not self._new_docstrings[i]:\n+            del self._new_docstrings[i]\n+\n+    if signatures:\n+        # combine all signatures into a single formatted string\n+        combined_args = []\n+        retann = signatures[0][1]  # use return annotation from first signature\n+        for args, _ in signatures:\n+            combined_args.append(args)\n+        # join multiple signatures with newlines for display\n+        result_args = '\\n'.join(combined_args) if len(signatures) > 1 else signatures[0][0]\n+        return result_args, retann\n+    else:\n+        return None, None\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                           \"deprecated.\" % self.__class__.__name__,\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n-        for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n-            if not doclines:\n-                continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n-            if base not in valid_names:\n-                continue\n-            # re-prepare docstring to ignore more leading indentation\n-            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n-                                                        tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+        # the base name must match ours\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__init__')\n+            if hasattr(self.object, '__mro__'):\n+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+        if base not in valid_names:\n+            continue\n+        # re-prepare docstring to ignore more leading indentation\n+        tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+        self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n+                                                    tabsize=tab_width)\n+        signatures.append((args, retann))\n+        # continue to find additional signatures\n+    \n+    if signatures:\n+        # Combine multiple signatures into a single string\n+        combined_args = '\\n'.join(sig[0] for sig in signatures if sig[0])\n+        combined_retann = signatures[0][1]  # Use return annotation from first signature\n+        return combined_args, combined_retann\n+    \n+    return None\n+                # Combine multiple signatures for overloaded methods\n+                combined_args = result[0] + '\\n' + args\n+                result = combined_args, retann\n+            # continue looking for more signatures instead of breaking\n+\n+            # don't look any further - collect all signatures instead\n+            if result is None:\n+                result = []\n+            result.append((args, retann))\n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..871048aeb 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,38 +1037,114 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+        # the base name must match ours\n+        if not self.env.config.autodoc_docstring_signature:  # only act if enabled\n+            continue\n+        if base not in self.objpath:  # modname not allowed\n+            continue\n+        signatures.append((args, retann))\n+        # remove the processed signature line from this docstring\n+        del self._new_docstrings[i][0]\n+        if not self._new_docstrings[i]:\n+            del self._new_docstrings[i]\n+    \n+    if signatures:\n+        # Combine all signatures into a single args string\n+        combined_args = []\n+        retann = signatures[0][1] if signatures[0][1] else None  # Use return annotation from first signature\n+        for args, _ in signatures:\n+            if args:\n+                combined_args.append(args.strip())\n+        \n+        if combined_args:\n+            # Join multiple signatures with newlines for proper display\n+            final_args = '\\n'.join(combined_args) if len(combined_args) > 1 else combined_args[0]\n+            return final_args, retann or ''\n+    \n+    return None, None\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                           \"deprecated.\" % self.__class__.__name__,\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n-        for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n-            if not doclines:\n-                continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n-            if base not in valid_names:\n-                continue\n+\n+def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                      \"deprecated.\" % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstrings = self.get_doc()\n+    self._new_docstrings = docstrings[:]\n+    signatures = []\n+    matched_indices = []\n+    for i, doclines in enumerate(docstrings):\n+        # no lines in docstring, no match\n+        if not doclines:\n+            continue\n+        # match first line of docstring against signature RE\n+        match = py_ext_sig_re.match(doclines[0])\n+        if not match:\n+            continue\n+        exmod, path, base, args, retann = match.groups()\n+        # the base name must match ours\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__init__')\n+            if hasattr(self.object, '__mro__'):\n+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+        if base not in valid_names:\n+            continue\n+        # collect signature and mark docstring for processing\n+        signatures.append((args, retann))\n+        matched_indices.append(i)\n+    \n+    # process docstrings to remove signature lines\n+    tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+    for i in matched_indices:\n+        doclines = self._new_docstrings[i]\n+        if doclines:\n+            # re-prepare docstring to ignore signature line and leading indentation\n+            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n+                                                        tabsize=tab_width)\n+    \n+    if signatures:\n+        # combine multiple signatures with newlines\n+        combined_args = '\\n'.join(sig[0] for sig in signatures)\n+        # use return annotation from first signature (they should be the same)\n+        retann = signatures[0][1]\n+        return combined_args, retann\n+    \n+    return None\n+                # Combine multiple signatures for overloaded methods\n+                combined_args = result[0] + '\\n' + args\n+                result = combined_args, retann\n+            # continue looking for more signatures\n+\n             # re-prepare docstring to ignore more leading indentation\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n             self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                         tabsize=tab_width)\n             result = args, retann\n-            # don't look any further\n-            break\n+            # continue looking for more signatures\n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n"
  }
}