{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/forms/models.py lines 1175-1181)": "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
    "Location 2 (/root/hy/projects/django/django/forms/models.py lines 1170-1171)": "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
    "Location 3 (/root/hy/projects/django/django/forms/models.py lines 1093-1093)": "\n        if instance is None:\n            self.instance = self.fk.remote_field.model()\n        else:\n            self.instance = instance\n        self.save_as_new = save_as_new\n        if queryset is None:\n            queryset = self.model._default_manager\n        if self.instance.pk is not None:\n            qs = queryset.filter(**{self.fk.name: self.instance})\n        else:\n            qs = queryset.none()\n        self.unique_fields = {self.fk.name}\n        super().__init__(\n            data, files, prefix=prefix, queryset=qs, **kwargs\n        )\n\n    def add_fields(self, form, index):\n        super().add_fields(form, index)\n        if self._pk_field == self.fk:\n            name = self._pk_field.name\n            kwargs = {\"pk_field\": True}\n        else:\n            # The foreign key field might not be on the form, so we poke at the\n            # Model field to get the label, since we need to apply the same\n            # logic as django.forms.forms.BaseForm.add_prefix to get the correct\n            # label.\n            name = self.fk.name\n            kwargs = {\n                \"label\": getattr(form.fields.get(name), \"label\", None)\n                or capfirst(self.fk.verbose_name)\n            }\n            if self.fk.remote_field.field.name != self.fk.remote_field.model._meta.pk.name:\n                kwargs[\"to_field\"] = self.fk.remote_field.field.name\n\n        form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n\n    def get_unique_error_message(self, unique_together):\n        unique_together = tuple(unique_together)\n        if len(unique_together) == 1:\n            return gettext(\"Please correct the duplicate data for %(field)s.\") % {\n                \"field\": unique_together[0],\n            }\n        else:\n            return gettext(\n                \"Please correct the duplicate data for %(field)s, \"\n                \"which must be unique.\"\n            ) % {\n                \"field\": get_text_list(unique_together, _(\"and\")),\n            }\n\n    def save_new_instance(self, form, commit=True):\n        kwargs = {self.fk.get_attname(): self.instance.pk}\n        new_obj = form.save(commit=False)\n        for k, v in kwargs.items():\n            setattr(new_obj, k, v)\n        if commit:\n            new_obj.save()\n        # form.save_m2m() can be called via the formset later on if commit=False\n        if commit and hasattr(form, \"save_m2m\"):\n            form.save_m2m()\n        return new_obj\n\n\ndef generic_inlineformset_factory(\n    model,\n    form=ModelForm,\n    formset=BaseGenericInlineFormSet,\n    ct_field=\"content_type\",\n    fk_field=\"object_id\",\n    fields=None,\n    exclude=None,\n    extra=3,\n    can_order=False,\n    can_delete=True,\n    max_num=None,\n    formfield_callback=None,\n    validate_max=False,\n    for_concrete_model=True,\n    min_num=None,\n    validate_min=False,\n    absolute_max=None,\n    can_delete_extra=True,\n):\n    \"\"\"\n    Return a ``GenericInlineFormSet`` for the given kwargs.\n\n    You must provide ``ct_field`` and ``fk_field`` if they are different from\n    the defaults ``content_type`` and ``object_id`` respectively.\n    \"\"\"\n    opts = model._meta\n    # if there is no field called `ct_field` let the exception propagate\n    ct_field = opts.get_field(ct_field)\n    if (\n        not isinstance(ct_field, models.ForeignKey)\n        or ct_field.remote_field.model != ContentType\n    ):\n        raise Exception(\"fk_name '%s' is not a ForeignKey to ContentType\" % ct_field)\n    fk_field = opts.get_field(fk_field)  # let the exception propagate\n    exclude = [*(exclude or []), ct_field.name, fk_field.name]\n    FormSet = modelformset_factory(\n        model,\n        form=form,\n        formfield_callback=formfield_callback,\n        formset=formset,\n        extra=extra,\n        can_delete=can_delete,\n        can_order=can_order,\n        fields=fields,\n        exclude=exclude,\n        max_num=max_num,\n        validate_max=validate_max,\n        min_num=min_num,\n        validate_min=validate_min,\n        absolute_max=absolute_max,\n        can_delete_extra=can_delete_extra,\n    )\n    FormSet.ct_field = ct_field\n    FormSet.ct_fk_field = fk_field\n    FormSet.for_concrete_model = for_concrete_model\n    return FormSet\n\n\nclass BaseGenericInlineFormSet(BaseModelFormSet):\n    \"\"\"\n    A formset for generic inline objects to a parent.\n    \"\"\"\n\n    def __init__(\n        self,\n        data=None,\n        files=None,\n        instance=None,\n        save_as_new=None,\n        prefix=None,\n        queryset=None,\n        **kwargs,\n    ):\n        opts = self.model._meta\n        self.instance = instance\n        self.rel_name = (\n            \"-%s-%s\"\n            % (\n                opts.app_label,\n                opts.model_name,\n            )\n        )[:-1]\n        if self.instance is None or self.instance.pk is None:\n            qs = self.model._default_manager.none()\n        else:\n            if queryset is None:\n                queryset = self.model._default_manager\n            qs = queryset.filter(\n                **{\n                    self.ct_field.name: ContentType.objects.get_for_model(\n                        self.instance, for_concrete_model=self.for_concrete_model\n                    ),\n                    self.ct_fk_field.name: self.instance.pk,\n                }\n            )\n        super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n\n    @classmethod\n    def get_default_prefix(cls):\n        opts = cls.model._meta\n        return (\n            opts.app_label + \"-\" + opts.model_name + cls.rel_name\n        ).lower()\n\n    def save_new(self, form, commit=True):\n        kwargs = {\n            self.ct_field.get_attname(): ContentType.objects.get_for_model(\n                self.instance, for_concrete_model=self.for_concrete_model\n            ).pk,\n            self.ct_fk_field.get_attname(): self.instance.pk,\n        }\n        new_obj = form.save(commit=False)\n        for k, v in kwargs.items():\n            setattr(new_obj, k, v)\n        if commit:\n            new_obj.save()\n        # form.save_m2m() can be called via the formset later on if commit=False\n        if commit and hasattr(form, \"save_m2m\"):\n            form.save_m2m()\n        return new_obj\n\n\nclass InlineForeignKeyField(Field):\n    \"\"\"\n    A basic integer field that deals with validating the given value to a\n    given parent instance in an inline.\n    \"\"\"\n\n    widget = HiddenInput\n    default_error_messages = {\n        \"invalid_choice\": _(\n            \"The inline value did not match the parent instance.\"\n        ),\n    }\n\n    def __init__(self, parent_instance, *args, pk_field=False, to_field=None, **kwargs):\n        self.parent_instance = parent_instance\n        self.pk_field = pk_field\n        self.to_field = to_field\n        if self.parent_instance is not None:\n            if to_field:\n                kwargs[\"initial\"] = getattr(self.parent_instance, to_field)\n            else:\n                kwargs[\"initial\"] = self.parent_instance.pk\n        kwargs[\"required\"] = False\n        super().__init__(*args, **kwargs)\n\n    def clean(self, value):\n        if self.pk_field:\n            return self.parent_instance.pk\n        # Check that the user didn't send us a GET parameter corresponding\n        # to a field that we don't want them to set.\n        elif self.to_field:\n            orig = getattr(self.parent_instance, self.to_field)\n        else:\n            orig = self.parent_instance.pk\n        if force_str(value) != force_str(orig):\n            raise ValidationError(\n                self.error_messages[\"invalid_choice\"],\n                code=\"invalid_choice\",\n            )\n        return orig\n\n    def has_changed(self, initial, data):\n        return False\n",
    "Location 4 (/root/hy/projects/django/django/forms/models.py lines 1176-1179)": "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
    "Location 5 (/root/hy/projects/django/django/forms/models.py lines 1180-1181)": "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/forms/models.py lines 1175-1181)": [
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n"
    ],
    "Location 2 (/root/hy/projects/django/django/forms/models.py lines 1170-1171)": [
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n"
    ],
    "Location 3 (/root/hy/projects/django/django/forms/models.py lines 1093-1093)": [
      "\n    def __init__(\n        self,\n        data=None,\n        files=None,\n        instance=None,\n        save_as_new=False,\n        prefix=None,\n        queryset=None,\n        **kwargs,\n    ):\n        if instance is None:\n            self.instance = self.fk.remote_field.model()\n        else:\n            self.instance = instance\n        self.save_as_new = save_as_new\n        if queryset is None:\n            queryset = self.model._default_manager\n        if self.instance.pk is not None:\n            qs = queryset.filter(**{self.fk.name: self.instance})\n        else:\n            qs = queryset.none()\n        self.unique_fields = {self.fk.name}\n",
      "\n        if instance is None:\n            self.instance = self.fk.remote_field.model()\n        else:\n            self.instance = instance\n        self.save_as_new = save_as_new\n        if queryset is None:\n            queryset = self.model._default_manager\n        if self.instance.pk is not None:\n            qs = queryset.filter(**{self.fk.name: self.instance})\n        else:\n            qs = queryset.none()\n        self.unique_fields = {self.fk.name}\n        super().__init__(\n            data, files, prefix=prefix, queryset=qs, **kwargs\n        )\n\n    def add_fields(self, form, index):\n        super().add_fields(form, index)\n        if self._pk_field == self.fk:\n            name = self._pk_field.name\n            kwargs = {\"pk_field\": True}\n        else:\n            # The foreign key field might not be on the form, so we poke at the\n            # Model field to get the label, since we need that for error messages.\n            name = self.fk.name\n            kwargs = {\n                \"label\": getattr(form.fields.get(name), \"label\", capfirst(self.fk.verbose_name))\n            }\n\n        # The InlineForeignKeyField assumes that the foreign key relation is\n        # based on the parent model's pk. If that's not the case, set to_field\n        # to correctly resolve the initial form value.\n        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n\n        form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n",
      "\n        if instance is None:\n            self.instance = self.fk.remote_field.model()\n",
      "\n        if instance is None:\n            self.instance = self.fk.remote_field.model()\n        else:\n            self.instance = instance\n        self.save_as_new = save_as_new\n        if queryset is None:\n            queryset = self.model._default_manager\n        if self.instance.pk is not None:\n            qs = queryset.filter(**{self.fk.name: self.instance})\n        else:\n            qs = queryset.none()\n        self.unique_fields = {self.fk.name}\n        super().__init__(\n            data, files, prefix=prefix, queryset=qs, **kwargs\n        )\n\n    def add_fields(self, form, index):\n        super().add_fields(form, index)\n        if self._pk_field == self.fk:\n            name = self._pk_field.name\n            kwargs = {\"pk_field\": True}\n        else:\n            # The foreign key field might not be on the form, so we pass the\n            # object instance instead, to check that the foreign key is held\n            # by the \"to\" field on the related object.\n            name = self.fk.name\n            kwargs = {\"to_field\": self.fk.target_field.name}\n\n        form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n\n    def get_unique_error_message(self, unique_check):\n        unique_check = [\n            field for field in unique_check if field != self.fk.name\n        ]\n        return super().get_unique_error_message(unique_check)\n\n\ndef _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\n    \"\"\"\n    Find and return the ForeignKey from model to parent if there is one\n    (return None if can_fail is True and no such field exists). If fk_name is\n    provided, assume it is the name of the ForeignKey field. Unless can_fail is\n    True, raise an exception if there isn't a ForeignKey from model to\n    parent_model.\n    \"\"\"\n    # avoid circular import\n    from django.db import models\n\n    opts = model._meta\n    if fk_name:\n        fks_to_parent = [f for f in opts.fields if f.name == fk_name]\n        if len(fks_to_parent) == 1:\n            fk = fks_to_parent[0]\n            if not isinstance(fk, models.ForeignKey):\n                raise ValueError(\n                    \"fk_name '%s' is not a ForeignKey to %s\"\n                    % (fk_name, parent_model._meta.label)\n                )\n        elif not fks_to_parent:\n            raise ValueError(\n                \"%s has no field named '%s'\" % (model._meta.label, fk_name)\n            )\n        else:\n            raise ValueError(\n                \"%s has more than one field named '%s'\" % (model._meta.label, fk_name)\n            )\n    else:\n        # Try to discover what the ForeignKey from model to parent_model is\n        fks_to_parent = [\n            f\n            for f in opts.fields\n            if isinstance(f, models.ForeignKey) and (\n                f.remote_field.model == parent_model or \n                f.remote_field.model == parent_model._meta.proxy_for_model\n            )\n        ]\n        if len(fks_to_parent) == 1:\n            fk = fks_to_parent[0]\n        elif not fks_to_parent:\n            if can_fail:\n                return\n            raise ValueError(\n                \"%s has no ForeignKey to %s\" % (model._meta.label, parent_model._meta.label)\n            )\n        else:\n            raise ValueError(\n                \"%s has more than one ForeignKey to %s\" % (\n                    model._meta.label,\n                    parent_model._meta.label,\n                )\n            )\n    return fk\n\n\n# InlineForeignKeyField ######################################################\n\n\nclass InlineForeignKeyField(Field):\n    \"\"\"\n    A basic integer field that deals with validating the given value to a\n    given parent instance in an inline.\n    \"\"\"\n\n    widget = HiddenInput\n    default_error_messages = {\n        \"invalid_choice\": _(\n            \"The inline value did not match the parent instance.\"\n        ),\n    }\n\n    def __init__(self, parent_instance, *args, to_field=None, **kwargs):\n        self.parent_instance = parent_instance\n        self.to_field = to_field\n        if self.parent_instance is not None:\n            if to_field:\n                kwargs[\"initial\"] = getattr(self.parent_instance, to_field)\n            else:\n                kwargs[\"initial\"] = self.parent_instance.pk\n        kwargs[\"required\"] = False\n        super().__init__(*args, **kwargs)\n\n    def clean(self, value):\n        if value in self.empty_values:\n            if self.to_field:\n                return getattr(self.parent_instance, self.to_field, None)\n            else:\n                return self.parent_instance.pk\n        return super().clean(value)\n\n    def validate(self, value):\n        if self.parent_instance is None:\n            return\n        super().validate(value)\n        if self.to_field:\n            orig = getattr(self.parent_instance, self.to_field)\n        else:\n            orig = self.parent_instance.pk\n        if value != orig:\n            raise ValidationError(\n                self.error_messages[\"invalid_choice\"], code=\"invalid_choice\"\n            )\n\n\nclass InlineForeignKeyHiddenInput(HiddenInput):\n    def _has_changed(self, initial, data):\n        return False\n\n\nclass BaseInlineFormSet(BaseFormSet):\n    \"\"\"\n    A formset for child objects related to a parent.\n    \"\"\"\n\n    def __init__(\n        self,\n        data=None,\n        files=None,\n        instance=None,\n        save_as_new=False,\n        prefix=None,\n        queryset=None,\n        **kwargs,\n    ):\n        if instance is None:\n            self.instance = self.fk.remote_field.model()\n        else:\n            self.instance = instance\n        self.save_as_new = save_as_new\n        if queryset is None:\n            queryset = self.model._default_manager\n        if self.instance.pk is not None:\n            qs = queryset.filter(**{self.fk.name: self.instance})\n        else:\n            qs = queryset.none()\n        self.unique_fields = {self.fk.name}\n        super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n\n    def initial_form_count(self):\n        if self.save_as_new:\n            return 0\n        return super().initial_form_count()\n\n    def _construct_form(self, i, **kwargs):\n        form = super()._construct_form(i, **kwargs)\n        if self.save_as_new:\n            mutable = getattr(form.data, '_mutable', None)\n            if mutable is not None:\n                form.data._mutable = True\n            # Remove the primary key from the form's data, we are only\n            # creating new instances\n            form.data[form.add_prefix(self._pk_field.name)] = None\n            # Remove the foreign key from the form's data\n            form.data[form.add_prefix(self.fk.name)] = None\n            if mutable is not None:\n                form.data._mutable = mutable\n\n        # Set the fk value here so that the form can do its validation.\n        fk_value = self.instance.pk\n        if self.fk.to_field:\n            fk_value = getattr(self.instance, self.fk.to_field)\n            # Don't clear fields that have non-auto defaults when instance is being added\n            if self.instance._state.adding and fk_value is None:\n                to_field = self.fk.target_field\n                if to_field.has_default() and not getattr(to_field, 'auto', False):\n                    # Let the field use its default value instead of clearing it\n                    pass\n                else:\n                    setattr(self.instance, to_field.attname, None)\n        form.fields[self.fk.name].initial = fk_value\n        return form\n\n    @classmethod\n    def get_default_prefix(cls):\n        return cls.fk.remote_field.get_accessor_name(model=cls.model).replace(\"+\", \"\")\n\n    def save_new(self, form, commit=True):\n        kwargs = {self.fk.get_attname(): self.instance.pk}\n        if self.fk.to_field:\n            kwargs = {self.fk.get_attname(): getattr(self.instance, self.fk.to_field)}\n        new_obj = form.save(commit=False)\n        for k, v in kwargs.items():\n            setattr(new_obj, k, v)\n        if commit:\n            new_obj.save()\n        return new_obj\n\n    def add_fields(self, form, index):\n        super().add_fields(form, index)\n        if self._pk_field == self.fk:\n            name = self._pk_field.name\n            kwargs = {\"pk_field\": True}\n        else:\n            # The foreign key field might not be on the form, so we pass the\n            # object instance instead, to check that the foreign key is held\n            # by the \"to\" field on the related object.\n            name = self.fk.name\n            kwargs = {\"to_field\": self.fk.target_field.name}\n\n        form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n\n    def get_unique_error_message(self, unique_check):\n        unique_check = [\n            field for field in unique_check if field != self.fk.name\n        ]\n        return super().get_unique_error_message(unique_check)\n\n\ndef _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\n    \"\"\"\n    Find and return the ForeignKey from model to parent if there is one\n    (return None if can_fail is True and no such field exists). If fk_name is\n    provided, assume it is the name of the ForeignKey field. Unless can_fail is\n    True, raise an exception if there isn't a ForeignKey from model to\n    parent_model.\n    \"\"\"\n    # avoid circular import\n    from django.db import models\n\n    opts = model._meta\n    if fk_name:\n        fks_to_parent = [f for f in opts.fields if f.name == fk_name]\n        if len(fks_to_parent) == 1:\n            fk = fks_to_parent[0]\n            if not isinstance(fk, models.ForeignKey):\n                raise ValueError(\n                    \"fk_name '%s' is not a ForeignKey to %s\"\n                    % (fk_name, parent_model._meta.label)\n                )\n        elif not fks_to_parent:\n            raise ValueError(\n                \"%s has no field named '%s'\" % (model._meta.label, fk_name)\n            )\n        else:\n            raise ValueError(\n                \"%s has more than one field named '%s'\" % (model._meta.label, fk_name)\n            )\n    else:\n        # Try to discover what the ForeignKey from model to parent_model is\n        fks_to_parent = [\n            f\n            for f in opts.fields\n            if isinstance(f, models.ForeignKey) and (\n                f.remote_field.model == parent_model or \n                f.remote_field.model == parent_model._meta.proxy_for_model\n            )\n        ]\n        if len(fks_to_parent) == 1:\n            fk = fks_to_parent[0]\n        elif not fks_to_parent:\n            if can_fail:\n                return\n            raise ValueError(\n                \"%s has no ForeignKey to %s\" % (model._meta.label, parent_model._meta.label)\n            )\n        else:\n            raise ValueError(\n                \"%s has more than one ForeignKey to %s\" % (\n                    model._meta.label,\n                    parent_model._meta.label,\n                )\n            )\n    return fk\n\n\n# InlineForeignKeyField ######################################################\n\n\nclass InlineForeignKeyField(Field):\n    \"\"\"\n    A basic integer field that deals with validating the given value to a\n    given parent instance in an inline.\n    \"\"\"\n\n    widget = HiddenInput\n    default_error_messages = {\n        \"invalid_choice\": _(\n            \"The inline value did not match the parent instance.\"\n        ),\n    }\n\n    def __init__(self, parent_instance, *args, to_field=None, **kwargs):\n        self.parent_instance = parent_instance\n        self.to_field = to_field\n        if self.parent_instance is not None:\n            if to_field:\n                kwargs[\"initial\"] = getattr(self.parent_instance, to_field)\n            else:\n                kwargs[\"initial\"] = self.parent_instance.pk\n        kwargs[\"required\"] = False\n        super().__init__(*args, **kwargs)\n\n    def clean(self, value):\n        if value in self.empty_values:\n            if self.to_field:\n                return getattr(self.parent_instance, self.to_field, None)\n            else:\n                return self.parent_instance.pk\n        return super().clean(value)\n\n    def validate(self, value):\n        if self.parent_instance is None:\n            return\n        super().validate(value)\n        if self.to_field:\n            orig = getattr(self.parent_instance, self.to_field)\n        else:\n            orig = self.parent_instance.pk\n        if value != orig:\n            raise ValidationError(\n                self.error_messages[\"invalid_choice\"], code=\"invalid_choice\"\n            )\n",
      "\n    def __init__(\n        self,\n        data=None,\n        files=None,\n        instance=None,\n        save_as_new=False,\n        prefix=None,\n        queryset=None,\n        **kwargs,\n    ):\n        if instance is None:\n            self.instance = self.fk.remote_field.model()\n        else:\n            self.instance = instance\n        self.save_as_new = save_as_new\n        if queryset is None:\n            queryset = self.model._default_manager\n        if self.instance.pk is not None:\n            qs = queryset.filter(**{self.fk.name: self.instance})\n        else:\n            qs = queryset.none()\n        self.unique_fields = {self.fk.name}\n",
      "\ndef __init__(\n    self,\n    data=None,\n    files=None,\n    instance=None,\n    save_as_new=False,\n    prefix=None,\n    queryset=None,\n    **kwargs,\n):\n    if instance is None:\n        self.instance = self.fk.remote_field.model()\n    else:\n        self.instance = instance\n    self.save_as_new = save_as_new\n    if queryset is None:\n        queryset = self.model._default_manager\n    if self.instance.pk is not None:\n        qs = queryset.filter(**{self.fk.name: self.instance})\n    else:\n        qs = queryset.none()\n    self.unique_fields = {self.fk.name}\n",
      "\n        if self.instance._state.adding:\n            self.instance = self.fk.remote_field.model()\n",
      "\ndef __init__(\n    self,\n    data=None,\n    files=None,\n    instance=None,\n    save_as_new=False,\n    prefix=None,\n    queryset=None,\n    **kwargs,\n):\n    if instance is None:\n        self.instance = self.fk.remote_field.model()\n    else:\n        self.instance = instance\n    self.save_as_new = save_as_new\n    if queryset is None:\n        queryset = self.model._default_manager\n    if self.instance.pk is not None:\n        qs = queryset.filter(**{self.fk.name: self.instance})\n    else:\n        qs = queryset.none()\n    self.unique_fields = {self.fk.name}\n"
    ],
    "Location 4 (/root/hy/projects/django/django/forms/models.py lines 1176-1179)": [
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # The InlineForeignKeyField assumes that the foreign key relation is\n        # based on the parent model's pk. If this isn't the case, set to_field\n        # to correctly resolve the initial form value.\n        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n"
    ],
    "Location 5 (/root/hy/projects/django/django/forms/models.py lines 1180-1181)": [
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n",
      "\n        # If we're adding a new object, ignore a parent's auto-generated key\n        # as it will be regenerated on the save request.\n        if self.instance._state.adding:\n            if kwargs.get(\"to_field\") is not None:\n                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n            else:\n                to_field = self.instance._meta.pk\n            if to_field.has_default() and getattr(to_field, 'auto', False):\n                setattr(self.instance, to_field.attname, None)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 3fa04b821f..b33d4c6ff3 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1090,6 +1090,7 @@ class BaseInlineFormSet(BaseModelFormSet):\n         **kwargs,\n     ):\n         if instance is None:\n+\n             self.instance = self.fk.remote_field.model()\n         else:\n             self.instance = instance\n@@ -1167,17 +1168,21 @@ class BaseInlineFormSet(BaseModelFormSet):\n         # The InlineForeignKeyField assumes that the foreign key relation is\n         # based on the parent model's pk. If this isn't the case, set to_field\n         # to correctly resolve the initial form value.\n+\n         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n             kwargs[\"to_field\"] = self.fk.remote_field.field_name\n \n         # If we're adding a new object, ignore a parent's auto-generated key\n         # as it will be regenerated on the save request.\n+\n         if self.instance._state.adding:\n             if kwargs.get(\"to_field\") is not None:\n                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n             else:\n                 to_field = self.instance._meta.pk\n-            if to_field.has_default():\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n                 setattr(self.instance, to_field.attname, None)\n \n         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n",
    "variant_0": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 3fa04b821f..5a3c41b6ad 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1089,6 +1089,8 @@ class BaseInlineFormSet(BaseModelFormSet):\n         queryset=None,\n         **kwargs,\n     ):\n+        if instance is None:\n+\n         if instance is None:\n             self.instance = self.fk.remote_field.model()\n         else:\n@@ -1101,6 +1103,233 @@ class BaseInlineFormSet(BaseModelFormSet):\n         else:\n             qs = queryset.none()\n         self.unique_fields = {self.fk.name}\n+        super().__init__(\n+            data, files, prefix=prefix, queryset=qs, **kwargs\n+        )\n+\n+    def add_fields(self, form, index):\n+        super().add_fields(form, index)\n+        if self._pk_field == self.fk:\n+            name = self._pk_field.name\n+            kwargs = {\"pk_field\": True}\n+        else:\n+            # The foreign key field might not be on the form, so we poke at the\n+            # Model field to get the label, since we need to apply the same\n+            # logic as django.forms.forms.BaseForm.add_prefix to get the correct\n+            # label.\n+            name = self.fk.name\n+            kwargs = {\n+                \"label\": getattr(form.fields.get(name), \"label\", None)\n+                or capfirst(self.fk.verbose_name)\n+            }\n+            if self.fk.remote_field.field.name != self.fk.remote_field.model._meta.pk.name:\n+                kwargs[\"to_field\"] = self.fk.remote_field.field.name\n+\n+        form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n+\n+    def get_unique_error_message(self, unique_together):\n+        unique_together = tuple(unique_together)\n+        if len(unique_together) == 1:\n+            return gettext(\"Please correct the duplicate data for %(field)s.\") % {\n+                \"field\": unique_together[0],\n+            }\n+        else:\n+            return gettext(\n+                \"Please correct the duplicate data for %(field)s, \"\n+                \"which must be unique.\"\n+            ) % {\n+                \"field\": get_text_list(unique_together, _(\"and\")),\n+            }\n+\n+    def save_new_instance(self, form, commit=True):\n+        kwargs = {self.fk.get_attname(): self.instance.pk}\n+        new_obj = form.save(commit=False)\n+        for k, v in kwargs.items():\n+            setattr(new_obj, k, v)\n+        if commit:\n+            new_obj.save()\n+        # form.save_m2m() can be called via the formset later on if commit=False\n+        if commit and hasattr(form, \"save_m2m\"):\n+            form.save_m2m()\n+        return new_obj\n+\n+\n+def generic_inlineformset_factory(\n+    model,\n+    form=ModelForm,\n+    formset=BaseGenericInlineFormSet,\n+    ct_field=\"content_type\",\n+    fk_field=\"object_id\",\n+    fields=None,\n+    exclude=None,\n+    extra=3,\n+    can_order=False,\n+    can_delete=True,\n+    max_num=None,\n+    formfield_callback=None,\n+    validate_max=False,\n+    for_concrete_model=True,\n+    min_num=None,\n+    validate_min=False,\n+    absolute_max=None,\n+    can_delete_extra=True,\n+):\n+    \"\"\"\n+    Return a ``GenericInlineFormSet`` for the given kwargs.\n+\n+    You must provide ``ct_field`` and ``fk_field`` if they are different from\n+    the defaults ``content_type`` and ``object_id`` respectively.\n+    \"\"\"\n+    opts = model._meta\n+    # if there is no field called `ct_field` let the exception propagate\n+    ct_field = opts.get_field(ct_field)\n+    if (\n+        not isinstance(ct_field, models.ForeignKey)\n+        or ct_field.remote_field.model != ContentType\n+    ):\n+        raise Exception(\"fk_name '%s' is not a ForeignKey to ContentType\" % ct_field)\n+    fk_field = opts.get_field(fk_field)  # let the exception propagate\n+    exclude = [*(exclude or []), ct_field.name, fk_field.name]\n+    FormSet = modelformset_factory(\n+        model,\n+        form=form,\n+        formfield_callback=formfield_callback,\n+        formset=formset,\n+        extra=extra,\n+        can_delete=can_delete,\n+        can_order=can_order,\n+        fields=fields,\n+        exclude=exclude,\n+        max_num=max_num,\n+        validate_max=validate_max,\n+        min_num=min_num,\n+        validate_min=validate_min,\n+        absolute_max=absolute_max,\n+        can_delete_extra=can_delete_extra,\n+    )\n+    FormSet.ct_field = ct_field\n+    FormSet.ct_fk_field = fk_field\n+    FormSet.for_concrete_model = for_concrete_model\n+    return FormSet\n+\n+\n+class BaseGenericInlineFormSet(BaseModelFormSet):\n+    \"\"\"\n+    A formset for generic inline objects to a parent.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        data=None,\n+        files=None,\n+        instance=None,\n+        save_as_new=None,\n+        prefix=None,\n+        queryset=None,\n+        **kwargs,\n+    ):\n+        opts = self.model._meta\n+        self.instance = instance\n+        self.rel_name = (\n+            \"-%s-%s\"\n+            % (\n+                opts.app_label,\n+                opts.model_name,\n+            )\n+        )[:-1]\n+        if self.instance is None or self.instance.pk is None:\n+            qs = self.model._default_manager.none()\n+        else:\n+            if queryset is None:\n+                queryset = self.model._default_manager\n+            qs = queryset.filter(\n+                **{\n+                    self.ct_field.name: ContentType.objects.get_for_model(\n+                        self.instance, for_concrete_model=self.for_concrete_model\n+                    ),\n+                    self.ct_fk_field.name: self.instance.pk,\n+                }\n+            )\n+        super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n+\n+    @classmethod\n+    def get_default_prefix(cls):\n+        opts = cls.model._meta\n+        return (\n+            opts.app_label + \"-\" + opts.model_name + cls.rel_name\n+        ).lower()\n+\n+    def save_new(self, form, commit=True):\n+        kwargs = {\n+            self.ct_field.get_attname(): ContentType.objects.get_for_model(\n+                self.instance, for_concrete_model=self.for_concrete_model\n+            ).pk,\n+            self.ct_fk_field.get_attname(): self.instance.pk,\n+        }\n+        new_obj = form.save(commit=False)\n+        for k, v in kwargs.items():\n+            setattr(new_obj, k, v)\n+        if commit:\n+            new_obj.save()\n+        # form.save_m2m() can be called via the formset later on if commit=False\n+        if commit and hasattr(form, \"save_m2m\"):\n+            form.save_m2m()\n+        return new_obj\n+\n+\n+class InlineForeignKeyField(Field):\n+    \"\"\"\n+    A basic integer field that deals with validating the given value to a\n+    given parent instance in an inline.\n+    \"\"\"\n+\n+    widget = HiddenInput\n+    default_error_messages = {\n+        \"invalid_choice\": _(\n+            \"The inline value did not match the parent instance.\"\n+        ),\n+    }\n+\n+    def __init__(self, parent_instance, *args, pk_field=False, to_field=None, **kwargs):\n+        self.parent_instance = parent_instance\n+        self.pk_field = pk_field\n+        self.to_field = to_field\n+        if self.parent_instance is not None:\n+            if to_field:\n+                kwargs[\"initial\"] = getattr(self.parent_instance, to_field)\n+            else:\n+                kwargs[\"initial\"] = self.parent_instance.pk\n+        kwargs[\"required\"] = False\n+        super().__init__(*args, **kwargs)\n+\n+    def clean(self, value):\n+        if self.pk_field:\n+            return self.parent_instance.pk\n+        # Check that the user didn't send us a GET parameter corresponding\n+        # to a field that we don't want them to set.\n+        elif self.to_field:\n+            orig = getattr(self.parent_instance, self.to_field)\n+        else:\n+            orig = self.parent_instance.pk\n+        if force_str(value) != force_str(orig):\n+            raise ValidationError(\n+                self.error_messages[\"invalid_choice\"],\n+                code=\"invalid_choice\",\n+            )\n+        return orig\n+\n+    def has_changed(self, initial, data):\n+        return False\n+        else:\n+            self.instance = instance\n+        self.save_as_new = save_as_new\n+        if queryset is None:\n+            queryset = self.model._default_manager\n+        if self.instance.pk is not None:\n+            qs = queryset.filter(**{self.fk.name: self.instance})\n+        else:\n+            qs = queryset.none()\n+        self.unique_fields = {self.fk.name}\n         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n \n         # Add the generated field to form._meta.fields if it's defined to make\n@@ -1167,8 +1396,6 @@ class BaseInlineFormSet(BaseModelFormSet):\n         # The InlineForeignKeyField assumes that the foreign key relation is\n         # based on the parent model's pk. If this isn't the case, set to_field\n         # to correctly resolve the initial form value.\n-        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n-            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n \n         # If we're adding a new object, ignore a parent's auto-generated key\n         # as it will be regenerated on the save request.\n@@ -1177,7 +1404,34 @@ class BaseInlineFormSet(BaseModelFormSet):\n                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n             else:\n                 to_field = self.instance._meta.pk\n-            if to_field.has_default():\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n                 setattr(self.instance, to_field.attname, None)\n \n         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n",
    "variant_1": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 3fa04b821f..5bc1b06f5e 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1079,6 +1079,18 @@ def modelformset_factory(\n class BaseInlineFormSet(BaseModelFormSet):\n     \"\"\"A formset for child objects related to a parent.\"\"\"\n \n+    def __init__(\n+        self,\n+        data=None,\n+        files=None,\n+        instance=None,\n+        save_as_new=False,\n+        prefix=None,\n+        queryset=None,\n+        **kwargs,\n+    ):\n+        if instance is None:\n+\n     def __init__(\n         self,\n         data=None,\n@@ -1101,6 +1113,16 @@ class BaseInlineFormSet(BaseModelFormSet):\n         else:\n             qs = queryset.none()\n         self.unique_fields = {self.fk.name}\n+        else:\n+            self.instance = instance\n+        self.save_as_new = save_as_new\n+        if queryset is None:\n+            queryset = self.model._default_manager\n+        if self.instance.pk is not None:\n+            qs = queryset.filter(**{self.fk.name: self.instance})\n+        else:\n+            qs = queryset.none()\n+        self.unique_fields = {self.fk.name}\n         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n \n         # Add the generated field to form._meta.fields if it's defined to make\n@@ -1167,8 +1189,6 @@ class BaseInlineFormSet(BaseModelFormSet):\n         # The InlineForeignKeyField assumes that the foreign key relation is\n         # based on the parent model's pk. If this isn't the case, set to_field\n         # to correctly resolve the initial form value.\n-        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n-            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n \n         # If we're adding a new object, ignore a parent's auto-generated key\n         # as it will be regenerated on the save request.\n@@ -1177,7 +1197,34 @@ class BaseInlineFormSet(BaseModelFormSet):\n                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n             else:\n                 to_field = self.instance._meta.pk\n-            if to_field.has_default():\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n                 setattr(self.instance, to_field.attname, None)\n \n         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n",
    "variant_2": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 3fa04b821f..9865c33286 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1089,6 +1089,8 @@ class BaseInlineFormSet(BaseModelFormSet):\n         queryset=None,\n         **kwargs,\n     ):\n+        if instance is None:\n+\n         if instance is None:\n             self.instance = self.fk.remote_field.model()\n         else:\n@@ -1101,6 +1103,50 @@ class BaseInlineFormSet(BaseModelFormSet):\n         else:\n             qs = queryset.none()\n         self.unique_fields = {self.fk.name}\n+        super().__init__(\n+            data, files, prefix=prefix, queryset=qs, **kwargs\n+        )\n+\n+    def add_fields(self, form, index):\n+        super().add_fields(form, index)\n+        if self._pk_field == self.fk:\n+            name = self._pk_field.name\n+            kwargs = {\"pk_field\": True}\n+        else:\n+            # The foreign key field might not be on the form, so we poke at the\n+            # Model field to get the label, since we need that for error messages.\n+            name = self.fk.name\n+            kwargs = {\n+                \"label\": getattr(form.fields.get(name), \"label\", capfirst(self.fk.verbose_name))\n+            }\n+\n+        # The InlineForeignKeyField assumes that the foreign key relation is\n+        # based on the parent model's pk. If that's not the case, set to_field\n+        # to correctly resolve the initial form value.\n+        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n+            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n+        else:\n+            self.instance = instance\n+        self.save_as_new = save_as_new\n+        if queryset is None:\n+            queryset = self.model._default_manager\n+        if self.instance.pk is not None:\n+            qs = queryset.filter(**{self.fk.name: self.instance})\n+        else:\n+            qs = queryset.none()\n+        self.unique_fields = {self.fk.name}\n         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n \n         # Add the generated field to form._meta.fields if it's defined to make\n@@ -1167,8 +1213,6 @@ class BaseInlineFormSet(BaseModelFormSet):\n         # The InlineForeignKeyField assumes that the foreign key relation is\n         # based on the parent model's pk. If this isn't the case, set to_field\n         # to correctly resolve the initial form value.\n-        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n-            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n \n         # If we're adding a new object, ignore a parent's auto-generated key\n         # as it will be regenerated on the save request.\n@@ -1177,7 +1221,34 @@ class BaseInlineFormSet(BaseModelFormSet):\n                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n             else:\n                 to_field = self.instance._meta.pk\n-            if to_field.has_default():\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n                 setattr(self.instance, to_field.attname, None)\n \n         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n",
    "variant_3": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 3fa04b821f..c7324cd58b 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1089,6 +1089,8 @@ class BaseInlineFormSet(BaseModelFormSet):\n         queryset=None,\n         **kwargs,\n     ):\n+        if instance is None:\n+\n         if instance is None:\n             self.instance = self.fk.remote_field.model()\n         else:\n@@ -1167,8 +1169,6 @@ class BaseInlineFormSet(BaseModelFormSet):\n         # The InlineForeignKeyField assumes that the foreign key relation is\n         # based on the parent model's pk. If this isn't the case, set to_field\n         # to correctly resolve the initial form value.\n-        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n-            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n \n         # If we're adding a new object, ignore a parent's auto-generated key\n         # as it will be regenerated on the save request.\n@@ -1177,7 +1177,34 @@ class BaseInlineFormSet(BaseModelFormSet):\n                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n             else:\n                 to_field = self.instance._meta.pk\n-            if to_field.has_default():\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n                 setattr(self.instance, to_field.attname, None)\n \n         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n",
    "variant_4": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 3fa04b821f..b257e56678 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1079,6 +1079,171 @@ def modelformset_factory(\n class BaseInlineFormSet(BaseModelFormSet):\n     \"\"\"A formset for child objects related to a parent.\"\"\"\n \n+    def __init__(\n+        self,\n+        data=None,\n+        files=None,\n+        instance=None,\n+        save_as_new=False,\n+        prefix=None,\n+        queryset=None,\n+        **kwargs,\n+    ):\n+        if instance is None:\n+\n+        if instance is None:\n+            self.instance = self.fk.remote_field.model()\n+        else:\n+            self.instance = instance\n+        self.save_as_new = save_as_new\n+        if queryset is None:\n+            queryset = self.model._default_manager\n+        if self.instance.pk is not None:\n+            qs = queryset.filter(**{self.fk.name: self.instance})\n+        else:\n+            qs = queryset.none()\n+        self.unique_fields = {self.fk.name}\n+        super().__init__(\n+            data, files, prefix=prefix, queryset=qs, **kwargs\n+        )\n+\n+    def add_fields(self, form, index):\n+        super().add_fields(form, index)\n+        if self._pk_field == self.fk:\n+            name = self._pk_field.name\n+            kwargs = {\"pk_field\": True}\n+        else:\n+            # The foreign key field might not be on the form, so we pass the\n+            # object instance instead, to check that the foreign key is held\n+            # by the \"to\" field on the related object.\n+            name = self.fk.name\n+            kwargs = {\"to_field\": self.fk.target_field.name}\n+\n+        form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n+\n+    def get_unique_error_message(self, unique_check):\n+        unique_check = [\n+            field for field in unique_check if field != self.fk.name\n+        ]\n+        return super().get_unique_error_message(unique_check)\n+\n+\n+def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\n+    \"\"\"\n+    Find and return the ForeignKey from model to parent if there is one\n+    (return None if can_fail is True and no such field exists). If fk_name is\n+    provided, assume it is the name of the ForeignKey field. Unless can_fail is\n+    True, raise an exception if there isn't a ForeignKey from model to\n+    parent_model.\n+    \"\"\"\n+    # avoid circular import\n+    from django.db import models\n+\n+    opts = model._meta\n+    if fk_name:\n+        fks_to_parent = [f for f in opts.fields if f.name == fk_name]\n+        if len(fks_to_parent) == 1:\n+            fk = fks_to_parent[0]\n+            if not isinstance(fk, models.ForeignKey):\n+                raise ValueError(\n+                    \"fk_name '%s' is not a ForeignKey to %s\"\n+                    % (fk_name, parent_model._meta.label)\n+                )\n+        elif not fks_to_parent:\n+            raise ValueError(\n+                \"%s has no field named '%s'\" % (model._meta.label, fk_name)\n+            )\n+        else:\n+            raise ValueError(\n+                \"%s has more than one field named '%s'\" % (model._meta.label, fk_name)\n+            )\n+    else:\n+        # Try to discover what the ForeignKey from model to parent_model is\n+        fks_to_parent = [\n+            f\n+            for f in opts.fields\n+            if isinstance(f, models.ForeignKey) and (\n+                f.remote_field.model == parent_model or \n+                f.remote_field.model == parent_model._meta.proxy_for_model\n+            )\n+        ]\n+        if len(fks_to_parent) == 1:\n+            fk = fks_to_parent[0]\n+        elif not fks_to_parent:\n+            if can_fail:\n+                return\n+            raise ValueError(\n+                \"%s has no ForeignKey to %s\" % (model._meta.label, parent_model._meta.label)\n+            )\n+        else:\n+            raise ValueError(\n+                \"%s has more than one ForeignKey to %s\" % (\n+                    model._meta.label,\n+                    parent_model._meta.label,\n+                )\n+            )\n+    return fk\n+\n+\n+# InlineForeignKeyField ######################################################\n+\n+\n+class InlineForeignKeyField(Field):\n+    \"\"\"\n+    A basic integer field that deals with validating the given value to a\n+    given parent instance in an inline.\n+    \"\"\"\n+\n+    widget = HiddenInput\n+    default_error_messages = {\n+        \"invalid_choice\": _(\n+            \"The inline value did not match the parent instance.\"\n+        ),\n+    }\n+\n+    def __init__(self, parent_instance, *args, to_field=None, **kwargs):\n+        self.parent_instance = parent_instance\n+        self.to_field = to_field\n+        if self.parent_instance is not None:\n+            if to_field:\n+                kwargs[\"initial\"] = getattr(self.parent_instance, to_field)\n+            else:\n+                kwargs[\"initial\"] = self.parent_instance.pk\n+        kwargs[\"required\"] = False\n+        super().__init__(*args, **kwargs)\n+\n+    def clean(self, value):\n+        if value in self.empty_values:\n+            if self.to_field:\n+                return getattr(self.parent_instance, self.to_field, None)\n+            else:\n+                return self.parent_instance.pk\n+        return super().clean(value)\n+\n+    def validate(self, value):\n+        if self.parent_instance is None:\n+            return\n+        super().validate(value)\n+        if self.to_field:\n+            orig = getattr(self.parent_instance, self.to_field)\n+        else:\n+            orig = self.parent_instance.pk\n+        if value != orig:\n+            raise ValidationError(\n+                self.error_messages[\"invalid_choice\"], code=\"invalid_choice\"\n+            )\n+\n+\n+class InlineForeignKeyHiddenInput(HiddenInput):\n+    def _has_changed(self, initial, data):\n+        return False\n+\n+\n+class BaseInlineFormSet(BaseFormSet):\n+    \"\"\"\n+    A formset for child objects related to a parent.\n+    \"\"\"\n+\n     def __init__(\n         self,\n         data=None,\n@@ -1103,6 +1268,192 @@ class BaseInlineFormSet(BaseModelFormSet):\n         self.unique_fields = {self.fk.name}\n         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n \n+    def initial_form_count(self):\n+        if self.save_as_new:\n+            return 0\n+        return super().initial_form_count()\n+\n+    def _construct_form(self, i, **kwargs):\n+        form = super()._construct_form(i, **kwargs)\n+        if self.save_as_new:\n+            mutable = getattr(form.data, '_mutable', None)\n+            if mutable is not None:\n+                form.data._mutable = True\n+            # Remove the primary key from the form's data, we are only\n+            # creating new instances\n+            form.data[form.add_prefix(self._pk_field.name)] = None\n+            # Remove the foreign key from the form's data\n+            form.data[form.add_prefix(self.fk.name)] = None\n+            if mutable is not None:\n+                form.data._mutable = mutable\n+\n+        # Set the fk value here so that the form can do its validation.\n+        fk_value = self.instance.pk\n+        if self.fk.to_field:\n+            fk_value = getattr(self.instance, self.fk.to_field)\n+            # Don't clear fields that have non-auto defaults when instance is being added\n+            if self.instance._state.adding and fk_value is None:\n+                to_field = self.fk.target_field\n+                if to_field.has_default() and not getattr(to_field, 'auto', False):\n+                    # Let the field use its default value instead of clearing it\n+                    pass\n+                else:\n+                    setattr(self.instance, to_field.attname, None)\n+        form.fields[self.fk.name].initial = fk_value\n+        return form\n+\n+    @classmethod\n+    def get_default_prefix(cls):\n+        return cls.fk.remote_field.get_accessor_name(model=cls.model).replace(\"+\", \"\")\n+\n+    def save_new(self, form, commit=True):\n+        kwargs = {self.fk.get_attname(): self.instance.pk}\n+        if self.fk.to_field:\n+            kwargs = {self.fk.get_attname(): getattr(self.instance, self.fk.to_field)}\n+        new_obj = form.save(commit=False)\n+        for k, v in kwargs.items():\n+            setattr(new_obj, k, v)\n+        if commit:\n+            new_obj.save()\n+        return new_obj\n+\n+    def add_fields(self, form, index):\n+        super().add_fields(form, index)\n+        if self._pk_field == self.fk:\n+            name = self._pk_field.name\n+            kwargs = {\"pk_field\": True}\n+        else:\n+            # The foreign key field might not be on the form, so we pass the\n+            # object instance instead, to check that the foreign key is held\n+            # by the \"to\" field on the related object.\n+            name = self.fk.name\n+            kwargs = {\"to_field\": self.fk.target_field.name}\n+\n+        form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n+\n+    def get_unique_error_message(self, unique_check):\n+        unique_check = [\n+            field for field in unique_check if field != self.fk.name\n+        ]\n+        return super().get_unique_error_message(unique_check)\n+\n+\n+def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\n+    \"\"\"\n+    Find and return the ForeignKey from model to parent if there is one\n+    (return None if can_fail is True and no such field exists). If fk_name is\n+    provided, assume it is the name of the ForeignKey field. Unless can_fail is\n+    True, raise an exception if there isn't a ForeignKey from model to\n+    parent_model.\n+    \"\"\"\n+    # avoid circular import\n+    from django.db import models\n+\n+    opts = model._meta\n+    if fk_name:\n+        fks_to_parent = [f for f in opts.fields if f.name == fk_name]\n+        if len(fks_to_parent) == 1:\n+            fk = fks_to_parent[0]\n+            if not isinstance(fk, models.ForeignKey):\n+                raise ValueError(\n+                    \"fk_name '%s' is not a ForeignKey to %s\"\n+                    % (fk_name, parent_model._meta.label)\n+                )\n+        elif not fks_to_parent:\n+            raise ValueError(\n+                \"%s has no field named '%s'\" % (model._meta.label, fk_name)\n+            )\n+        else:\n+            raise ValueError(\n+                \"%s has more than one field named '%s'\" % (model._meta.label, fk_name)\n+            )\n+    else:\n+        # Try to discover what the ForeignKey from model to parent_model is\n+        fks_to_parent = [\n+            f\n+            for f in opts.fields\n+            if isinstance(f, models.ForeignKey) and (\n+                f.remote_field.model == parent_model or \n+                f.remote_field.model == parent_model._meta.proxy_for_model\n+            )\n+        ]\n+        if len(fks_to_parent) == 1:\n+            fk = fks_to_parent[0]\n+        elif not fks_to_parent:\n+            if can_fail:\n+                return\n+            raise ValueError(\n+                \"%s has no ForeignKey to %s\" % (model._meta.label, parent_model._meta.label)\n+            )\n+        else:\n+            raise ValueError(\n+                \"%s has more than one ForeignKey to %s\" % (\n+                    model._meta.label,\n+                    parent_model._meta.label,\n+                )\n+            )\n+    return fk\n+\n+\n+# InlineForeignKeyField ######################################################\n+\n+\n+class InlineForeignKeyField(Field):\n+    \"\"\"\n+    A basic integer field that deals with validating the given value to a\n+    given parent instance in an inline.\n+    \"\"\"\n+\n+    widget = HiddenInput\n+    default_error_messages = {\n+        \"invalid_choice\": _(\n+            \"The inline value did not match the parent instance.\"\n+        ),\n+    }\n+\n+    def __init__(self, parent_instance, *args, to_field=None, **kwargs):\n+        self.parent_instance = parent_instance\n+        self.to_field = to_field\n+        if self.parent_instance is not None:\n+            if to_field:\n+                kwargs[\"initial\"] = getattr(self.parent_instance, to_field)\n+            else:\n+                kwargs[\"initial\"] = self.parent_instance.pk\n+        kwargs[\"required\"] = False\n+        super().__init__(*args, **kwargs)\n+\n+    def clean(self, value):\n+        if value in self.empty_values:\n+            if self.to_field:\n+                return getattr(self.parent_instance, self.to_field, None)\n+            else:\n+                return self.parent_instance.pk\n+        return super().clean(value)\n+\n+    def validate(self, value):\n+        if self.parent_instance is None:\n+            return\n+        super().validate(value)\n+        if self.to_field:\n+            orig = getattr(self.parent_instance, self.to_field)\n+        else:\n+            orig = self.parent_instance.pk\n+        if value != orig:\n+            raise ValidationError(\n+                self.error_messages[\"invalid_choice\"], code=\"invalid_choice\"\n+            )\n+        else:\n+            self.instance = instance\n+        self.save_as_new = save_as_new\n+        if queryset is None:\n+            queryset = self.model._default_manager\n+        if self.instance.pk is not None:\n+            qs = queryset.filter(**{self.fk.name: self.instance})\n+        else:\n+            qs = queryset.none()\n+        self.unique_fields = {self.fk.name}\n+        super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n+\n         # Add the generated field to form._meta.fields if it's defined to make\n         # sure validation isn't skipped on that field.\n         if self.form._meta.fields and self.fk.name not in self.form._meta.fields:\n@@ -1167,8 +1518,6 @@ class BaseInlineFormSet(BaseModelFormSet):\n         # The InlineForeignKeyField assumes that the foreign key relation is\n         # based on the parent model's pk. If this isn't the case, set to_field\n         # to correctly resolve the initial form value.\n-        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n-            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n \n         # If we're adding a new object, ignore a parent's auto-generated key\n         # as it will be regenerated on the save request.\n@@ -1177,7 +1526,34 @@ class BaseInlineFormSet(BaseModelFormSet):\n                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n             else:\n                 to_field = self.instance._meta.pk\n-            if to_field.has_default():\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n                 setattr(self.instance, to_field.attname, None)\n \n         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n",
    "variant_5": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 3fa04b821f..5bc1b06f5e 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1079,6 +1079,18 @@ def modelformset_factory(\n class BaseInlineFormSet(BaseModelFormSet):\n     \"\"\"A formset for child objects related to a parent.\"\"\"\n \n+    def __init__(\n+        self,\n+        data=None,\n+        files=None,\n+        instance=None,\n+        save_as_new=False,\n+        prefix=None,\n+        queryset=None,\n+        **kwargs,\n+    ):\n+        if instance is None:\n+\n     def __init__(\n         self,\n         data=None,\n@@ -1101,6 +1113,16 @@ class BaseInlineFormSet(BaseModelFormSet):\n         else:\n             qs = queryset.none()\n         self.unique_fields = {self.fk.name}\n+        else:\n+            self.instance = instance\n+        self.save_as_new = save_as_new\n+        if queryset is None:\n+            queryset = self.model._default_manager\n+        if self.instance.pk is not None:\n+            qs = queryset.filter(**{self.fk.name: self.instance})\n+        else:\n+            qs = queryset.none()\n+        self.unique_fields = {self.fk.name}\n         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n \n         # Add the generated field to form._meta.fields if it's defined to make\n@@ -1167,8 +1189,6 @@ class BaseInlineFormSet(BaseModelFormSet):\n         # The InlineForeignKeyField assumes that the foreign key relation is\n         # based on the parent model's pk. If this isn't the case, set to_field\n         # to correctly resolve the initial form value.\n-        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n-            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n \n         # If we're adding a new object, ignore a parent's auto-generated key\n         # as it will be regenerated on the save request.\n@@ -1177,7 +1197,34 @@ class BaseInlineFormSet(BaseModelFormSet):\n                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n             else:\n                 to_field = self.instance._meta.pk\n-            if to_field.has_default():\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n                 setattr(self.instance, to_field.attname, None)\n \n         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n",
    "variant_6": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 3fa04b821f..1a0dcf5ee0 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1090,7 +1090,29 @@ class BaseInlineFormSet(BaseModelFormSet):\n         **kwargs,\n     ):\n         if instance is None:\n-            self.instance = self.fk.remote_field.model()\n+\n+def __init__(\n+    self,\n+    data=None,\n+    files=None,\n+    instance=None,\n+    save_as_new=False,\n+    prefix=None,\n+    queryset=None,\n+    **kwargs,\n+):\n+    if instance is None:\n+        self.instance = self.fk.remote_field.model()\n+    else:\n+        self.instance = instance\n+    self.save_as_new = save_as_new\n+    if queryset is None:\n+        queryset = self.model._default_manager\n+    if self.instance.pk is not None:\n+        qs = queryset.filter(**{self.fk.name: self.instance})\n+    else:\n+        qs = queryset.none()\n+    self.unique_fields = {self.fk.name}\n         else:\n             self.instance = instance\n         self.save_as_new = save_as_new\n@@ -1167,8 +1189,6 @@ class BaseInlineFormSet(BaseModelFormSet):\n         # The InlineForeignKeyField assumes that the foreign key relation is\n         # based on the parent model's pk. If this isn't the case, set to_field\n         # to correctly resolve the initial form value.\n-        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n-            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n \n         # If we're adding a new object, ignore a parent's auto-generated key\n         # as it will be regenerated on the save request.\n@@ -1177,7 +1197,34 @@ class BaseInlineFormSet(BaseModelFormSet):\n                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n             else:\n                 to_field = self.instance._meta.pk\n-            if to_field.has_default():\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n                 setattr(self.instance, to_field.attname, None)\n \n         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n",
    "variant_7": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 3fa04b821f..057830f178 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1090,6 +1090,8 @@ class BaseInlineFormSet(BaseModelFormSet):\n         **kwargs,\n     ):\n         if instance is None:\n+\n+        if self.instance._state.adding:\n             self.instance = self.fk.remote_field.model()\n         else:\n             self.instance = instance\n@@ -1167,8 +1169,6 @@ class BaseInlineFormSet(BaseModelFormSet):\n         # The InlineForeignKeyField assumes that the foreign key relation is\n         # based on the parent model's pk. If this isn't the case, set to_field\n         # to correctly resolve the initial form value.\n-        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n-            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n \n         # If we're adding a new object, ignore a parent's auto-generated key\n         # as it will be regenerated on the save request.\n@@ -1177,7 +1177,34 @@ class BaseInlineFormSet(BaseModelFormSet):\n                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n             else:\n                 to_field = self.instance._meta.pk\n-            if to_field.has_default():\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n                 setattr(self.instance, to_field.attname, None)\n \n         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n",
    "variant_8": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 3fa04b821f..2a41657c14 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1090,7 +1090,29 @@ class BaseInlineFormSet(BaseModelFormSet):\n         **kwargs,\n     ):\n         if instance is None:\n-            self.instance = self.fk.remote_field.model()\n+\n+def __init__(\n+    self,\n+    data=None,\n+    files=None,\n+    instance=None,\n+    save_as_new=False,\n+    prefix=None,\n+    queryset=None,\n+    **kwargs,\n+):\n+    if instance is None:\n+        self.instance = self.fk.remote_field.model()\n+    else:\n+        self.instance = instance\n+    self.save_as_new = save_as_new\n+    if queryset is None:\n+        queryset = self.model._default_manager\n+    if self.instance.pk is not None:\n+        qs = queryset.filter(**{self.fk.name: self.instance})\n+    else:\n+        qs = queryset.none()\n+    self.unique_fields = {self.fk.name}\n         else:\n             self.instance = instance\n         self.save_as_new = save_as_new\n@@ -1167,8 +1189,6 @@ class BaseInlineFormSet(BaseModelFormSet):\n         # The InlineForeignKeyField assumes that the foreign key relation is\n         # based on the parent model's pk. If this isn't the case, set to_field\n         # to correctly resolve the initial form value.\n-        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n-            kwargs[\"to_field\"] = self.fk.remote_field.field_name\n \n         # If we're adding a new object, ignore a parent's auto-generated key\n         # as it will be regenerated on the save request.\n@@ -1177,7 +1197,40 @@ class BaseInlineFormSet(BaseModelFormSet):\n                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n             else:\n                 to_field = self.instance._meta.pk\n-            if to_field.has_default():\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n+                setattr(self.instance, to_field.attname, None)\n+\n+        # If we're adding a new object, ignore a parent's auto-generated key\n+        # as it will be regenerated on the save request.\n+        if self.instance._state.adding:\n+            if kwargs.get(\"to_field\") is not None:\n+                to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n+            else:\n+                to_field = self.instance._meta.pk\n+            if to_field.has_default() and getattr(to_field, 'auto', False):\n                 setattr(self.instance, to_field.attname, None)\n \n         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n"
  }
}