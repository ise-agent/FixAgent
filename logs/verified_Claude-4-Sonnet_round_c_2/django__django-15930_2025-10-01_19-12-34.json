{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/expressions.py lines 1387-1390)": "\n    def as_sql(\n        self, compiler, connection, template=None, case_joiner=None, **extra_context\n    ):\n        connection.ops.check_expression_support(self)\n        if not self.cases:\n            return compiler.compile(self.default)\n        template_params = {**self.extra, **extra_context}\n        case_parts = []\n        sql_params = []\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue  # Skip cases that truly represent empty results\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        return template % template_params, sql_params\n\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n",
    "Location 2 (/root/hy/projects/django/django/db/models/expressions.py lines 1394-1395)": "\n        if not case_parts:\n            # If all cases were skipped due to EmptyResultSet, return only the default\n            return default_sql, default_params\n",
    "Location 3 (/root/hy/projects/django/django/db/models/expressions.py lines 1396-1401)": "\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        sql = template % template_params\n",
    "Location 4 (/root/hy/projects/django/django/db/models/expressions.py lines 1301-1301)": "\n        condition_sql, condition_params = compiler.compile(self.condition)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/expressions.py lines 1387-1390)": [
      "\n    def as_sql(\n        self, compiler, connection, template=None, case_joiner=None, **extra_context\n    ):\n        connection.ops.check_expression_support(self)\n        if not self.cases:\n            return compiler.compile(self.default)\n        template_params = {**self.extra, **extra_context}\n        case_parts = []\n        sql_params = []\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue  # Skip cases that truly represent empty results\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        return template % template_params, sql_params\n\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n",
      "\n    def as_sql(\n        self, compiler, connection, template=None, case_joiner=None, **extra_context\n    ):\n        connection.ops.check_expression_support(self)\n        if not self.cases:\n            return compiler.compile(self.default)\n        template_params = {**self.extra, **extra_context}\n        case_parts = []\n        sql_params = []\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        sql = template % template_params\n        return sql, sql_params\n\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n",
      "\n    def as_sql(\n        self, compiler, connection, template=None, case_joiner=None, **extra_context\n    ):\n        connection.ops.check_expression_support(self)\n        if not self.cases:\n            return compiler.compile(self.default)\n        template_params = {**self.extra, **extra_context}\n        case_parts = []\n        sql_params = []\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        return template % template_params, sql_params\n\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n",
      "\n    def as_sql(\n        self, compiler, connection, template=None, case_joiner=None, **extra_context\n    ):\n        connection.ops.check_expression_support(self)\n        if not self.cases:\n            return compiler.compile(self.default)\n        template_params = {**self.extra, **extra_context}\n        case_parts = []\n        sql_params = []\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        return template % template_params, sql_params\n\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n",
      "\n    def as_sql(\n        self, compiler, connection, template=None, case_joiner=None, **extra_context\n    ):\n        connection.ops.check_expression_support(self)\n        if not self.cases:\n            return compiler.compile(self.default)\n        template_params = {**self.extra, **extra_context}\n        case_parts = []\n        sql_params = []\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        return template % template_params, sql_params\n\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n",
      "\n    def as_sql(\n        self, compiler, connection, template=None, case_joiner=None, **extra_context\n    ):\n        connection.ops.check_expression_support(self)\n        if not self.cases:\n            return compiler.compile(self.default)\n        template_params = {**self.extra, **extra_context}\n        case_parts = []\n        sql_params = []\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        return template % template_params, sql_params\n\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n",
      "\n    def as_sql(\n        self, compiler, connection, template=None, case_joiner=None, **extra_context\n    ):\n        connection.ops.check_expression_support(self)\n        if not self.cases:\n            return compiler.compile(self.default)\n        template_params = {**self.extra, **extra_context}\n        case_parts = []\n        sql_params = []\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        return template % template_params, sql_params\n\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n",
      "\n    def as_sql(\n        self, compiler, connection, template=None, case_joiner=None, **extra_context\n    ):\n        connection.ops.check_expression_support(self)\n        if not self.cases:\n            return compiler.compile(self.default)\n        template_params = {**self.extra, **extra_context}\n        case_parts = []\n        sql_params = []\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue  # Skip cases that truly represent empty results\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        return template % template_params, sql_params\n\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/expressions.py lines 1394-1395)": [
      "\n        if not case_parts:\n            # All cases were filtered out due to EmptyResultSet exceptions\n            # Return the default case SQL and parameters\n            return default_sql, default_params\n",
      "\n        if not case_parts:\n            # Check if we had cases that were skipped due to EmptyResultSet\n            # but might represent \"always true\" conditions (like ~Q(pk__in=[]))\n            has_always_true_cases = False\n            for case in self.cases:\n                try:\n                    compiler.compile(case)\n                except EmptyResultSet:\n                    # Check if this represents a negated empty condition\n                    if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                        has_always_true_cases = True\n                        break\n            \n            if has_always_true_cases:\n                # Re-process cases, handling always-true conditions properly\n                case_parts = []\n                sql_params = []\n                for case in self.cases:\n                    try:\n                        case_sql, case_params = compiler.compile(case)\n                        case_parts.append(case_sql)\n                        sql_params.extend(case_params)\n                    except EmptyResultSet:\n                        if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                            result_sql, result_params = compiler.compile(case.result)\n                            case_parts.append(f\"WHEN 1=1 THEN {result_sql}\")\n                            sql_params.extend(result_params)\n                \n                if case_parts:\n                    case_joiner = case_joiner or self.case_joiner\n                    template_params[\"cases\"] = case_joiner.join(case_parts)\n                    template_params[\"default\"] = default_sql\n                    sql_params.extend(default_params)\n                    template = template or template_params.get(\"template\", self.template)\n                    sql = template % template_params\n                    if self._output_field_or_none is not None:\n                        sql = connection.ops.unification_cast_sql(self.output_field) % sql\n                    return sql, sql_params\n            \n            return default_sql, default_params\n",
      "\n        if not case_parts:\n            # All cases resulted in EmptyResultSet - return just the default\n            return default_sql, default_params\n",
      "\n        if not case_parts:\n            # Check if all cases were skipped due to EmptyResultSet but represent always-true conditions\n            always_true_cases = []\n            for case in self.cases:\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    result_sql, result_params = compiler.compile(case.result)\n                    always_true_cases.append((result_sql, result_params))\n            \n            if always_true_cases:\n                # Return the first always-true case result directly\n                return always_true_cases[0]\n            \n            return default_sql, default_params\n",
      "\n        if not case_parts:\n            # If no case parts were generated, check if any cases represent \"always true\" conditions\n            # that were incorrectly skipped due to EmptyResultSet exceptions\n            for case in self.cases:\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for the \"always true\" case\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_parts.append(f\"WHEN 1=1 THEN {result_sql}\")\n                    sql_params.extend(result_params)\n                    break  # Use the first \"always true\" case found\n            \n            # If still no case parts after checking for \"always true\" conditions\n            if not case_parts:\n                return default_sql, default_params\n",
      "\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n",
      "\n        if not case_parts:\n            # Check if all cases were skipped due to EmptyResultSet exceptions\n            # In this case, return the default value as the complete result\n            return default_sql, default_params\n",
      "\n        if not case_parts:\n            # Check if all cases were skipped due to EmptyResultSet exceptions\n            # that might represent negated empty conditions (always true)\n            for case in self.cases:\n                if hasattr(case, 'condition') and self._represents_always_true_condition(case.condition):\n                    # Generate SQL for this always-true case\n                    result_sql, result_params = compiler.compile(case.result)\n                    return result_sql, result_params\n            return default_sql, default_params\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/expressions.py lines 1396-1401)": [
      "\ndef _represents_always_true(self, condition):\n    \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n    # Check for negated empty Q objects like ~Q(pk__in=[])\n    if hasattr(condition, 'negated') and condition.negated:\n        if hasattr(condition, 'children') and not condition.children:\n            return True\n        # Check for empty pk__in conditions\n        for child in getattr(condition, 'children', []):\n            if isinstance(child, tuple) and len(child) == 2:\n                lookup, value = child\n                if lookup.endswith('__in') and not value:\n                    return True\n    return False\n\ncase_joiner = case_joiner or self.case_joiner\ntemplate_params[\"cases\"] = case_joiner.join(case_parts)\ntemplate_params[\"default\"] = default_sql\nsql_params.extend(default_params)\ntemplate = template or template_params.get(\"template\", self.template)\nsql = template % template_params\n",
      "\ndef _represents_always_true(self, condition):\n    \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n    # Check for negated empty Q objects like ~Q(pk__in=[])\n    if hasattr(condition, 'negated') and condition.negated:\n        if hasattr(condition, 'children') and not condition.children:\n            return True\n        # Check for empty pk__in conditions\n        for child in getattr(condition, 'children', []):\n            if isinstance(child, tuple) and len(child) == 2:\n                lookup, value = child\n                if lookup.endswith('__in') and not value:\n                    return True\n    return False\n\ncase_joiner = case_joiner or self.case_joiner\ntemplate_params[\"cases\"] = case_joiner.join(case_parts)\ntemplate_params[\"default\"] = default_sql\nsql_params.extend(default_params)\ntemplate = template or template_params.get(\"template\", self.template)\nsql = template % template_params\n",
      "\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        sql = template % template_params\n",
      "\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n\n    def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):\n        connection.ops.check_expression_support(self)\n        if not self.cases:\n            try:\n                return compiler.compile(self.default)\n            except EmptyResultSet:\n                raise EmptyResultSet\n        case_parts = []\n        sql_params = []\n        template_params = {**self.extra, **extra_context}\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                    case_parts.append(case_sql)\n                    sql_params.extend(case_params)\n                continue\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        sql = template % template_params\n",
      "\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        sql = template % template_params\n",
      "\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        sql = template % template_params\n",
      "\n    def _represents_always_true(self, condition):\n        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n        # Check for negated empty Q objects like ~Q(pk__in=[])\n        if hasattr(condition, 'negated') and condition.negated:\n            if hasattr(condition, 'children') and not condition.children:\n                return True\n            # Check for empty pk__in conditions\n            for child in getattr(condition, 'children', []):\n                if isinstance(child, tuple) and len(child) == 2:\n                    lookup, value = child\n                    if lookup.endswith('__in') and not value:\n                        return True\n        return False\n\n    def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):\n        connection.ops.check_expression_support(self)\n        if self.cases:\n            try:\n                return self.cases[0].result.as_sql(compiler, connection, **extra_context)\n            except EmptyResultSet:\n                known_null_counts = len([\n                    case for case in self.cases\n                    if case.condition.is_summary\n                ])\n                if known_null_counts == len(self.cases):\n                    return self.default.as_sql(compiler, connection, **extra_context)\n                raise\n        case_parts = []\n        sql_params = []\n        template_params = {**self.extra, **extra_context}\n        for case in self.cases:\n            try:\n                case_sql, case_params = compiler.compile(case)\n            except EmptyResultSet:\n                # Check if this is a negated empty condition that should match all rows\n                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n                    # Generate SQL for \"always true\" condition\n                    result_sql, result_params = compiler.compile(case.result)\n                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n                    case_params = result_params\n                else:\n                    continue  # Skip cases that truly represent empty results\n            case_parts.append(case_sql)\n            sql_params.extend(case_params)\n        default_sql, default_params = compiler.compile(self.default)\n        if not case_parts:\n            return default_sql, default_params\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        sql = template % template_params\n",
      "\n        case_joiner = case_joiner or self.case_joiner\n        template_params[\"cases\"] = case_joiner.join(case_parts)\n        template_params[\"default\"] = default_sql\n        sql_params.extend(default_params)\n        template = template or template_params.get(\"template\", self.template)\n        sql = template % template_params\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/expressions.py lines 1301-1301)": [
      "\n        condition_sql, condition_params = compiler.compile(self.condition)\n",
      "\ncondition_sql, condition_params = self._compile_condition_with_empty_handling(\n    compiler, self.condition\n)\n",
      "\ncondition_sql, condition_params = compiler.compile(self.condition)\n",
      "\ncondition_sql, condition_params = compiler.compile(self.condition)\n",
      "\n        condition_sql, condition_params = compiler.compile(self.condition)\n",
      "\n        condition_sql, condition_params = compiler.compile(self.condition)\n",
      "\ncondition_sql, condition_params = compiler.compile(self.condition)\n",
      "\n        condition_sql, condition_params = compiler.compile(self.condition)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..b2704ebb10 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,6 +1298,7 @@ class When(Expression):\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n+\n         condition_sql, condition_params = compiler.compile(self.condition)\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n@@ -1384,15 +1385,25 @@ class Case(SQLiteNumericMixin, Expression):\n         case_parts = []\n         sql_params = []\n         for case in self.cases:\n+\n             try:\n                 case_sql, case_params = compiler.compile(case)\n             except EmptyResultSet:\n-                continue\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = \"WHEN 1=1 THEN %s\" % result_sql\n+                    case_params = result_params\n+                else:\n+                    continue\n             case_parts.append(case_sql)\n             sql_params.extend(case_params)\n         default_sql, default_params = compiler.compile(self.default)\n+\n         if not case_parts:\n             return default_sql, default_params\n+\n         case_joiner = case_joiner or self.case_joiner\n         template_params[\"cases\"] = case_joiner.join(case_parts)\n         template_params[\"default\"] = default_sql\n",
    "variant_0": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..7b4190ffcf 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,6 +1298,7 @@ class When(Expression):\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n+\n         condition_sql, condition_params = compiler.compile(self.condition)\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n@@ -1374,6 +1375,17 @@ class Case(SQLiteNumericMixin, Expression):\n         c.cases = c.cases[:]\n         return c\n \n+    def as_sql(\n+        self, compiler, connection, template=None, case_joiner=None, **extra_context\n+    ):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            return compiler.compile(self.default)\n+        template_params = {**self.extra, **extra_context}\n+        case_parts = []\n+        sql_params = []\n+        for case in self.cases:\n+\n     def as_sql(\n         self, compiler, connection, template=None, case_joiner=None, **extra_context\n     ):\n@@ -1387,7 +1399,14 @@ class Case(SQLiteNumericMixin, Expression):\n             try:\n                 case_sql, case_params = compiler.compile(case)\n             except EmptyResultSet:\n-                continue\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue  # Skip cases that truly represent empty results\n             case_parts.append(case_sql)\n             sql_params.extend(case_params)\n         default_sql, default_params = compiler.compile(self.default)\n@@ -1398,6 +1417,34 @@ class Case(SQLiteNumericMixin, Expression):\n         template_params[\"default\"] = default_sql\n         sql_params.extend(default_params)\n         template = template or template_params.get(\"template\", self.template)\n+        return template % template_params, sql_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+\n+        if not case_parts:\n+            # If all cases were skipped due to EmptyResultSet, return only the default\n+            return default_sql, default_params\n+\n+        case_joiner = case_joiner or self.case_joiner\n+        template_params[\"cases\"] = case_joiner.join(case_parts)\n+        template_params[\"default\"] = default_sql\n+        sql_params.extend(default_params)\n+        template = template or template_params.get(\"template\", self.template)\n         sql = template % template_params\n         if self._output_field_or_none is not None:\n             sql = connection.ops.unification_cast_sql(self.output_field) % sql\n",
    "variant_1": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..2a98f4b06f 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,6 +1298,7 @@ class When(Expression):\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n+\n         condition_sql, condition_params = compiler.compile(self.condition)\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n@@ -1374,6 +1375,17 @@ class Case(SQLiteNumericMixin, Expression):\n         c.cases = c.cases[:]\n         return c\n \n+    def as_sql(\n+        self, compiler, connection, template=None, case_joiner=None, **extra_context\n+    ):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            return compiler.compile(self.default)\n+        template_params = {**self.extra, **extra_context}\n+        case_parts = []\n+        sql_params = []\n+        for case in self.cases:\n+\n     def as_sql(\n         self, compiler, connection, template=None, case_joiner=None, **extra_context\n     ):\n@@ -1387,7 +1399,14 @@ class Case(SQLiteNumericMixin, Expression):\n             try:\n                 case_sql, case_params = compiler.compile(case)\n             except EmptyResultSet:\n-                continue\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue  # Skip cases that truly represent empty results\n             case_parts.append(case_sql)\n             sql_params.extend(case_params)\n         default_sql, default_params = compiler.compile(self.default)\n@@ -1398,7 +1417,50 @@ class Case(SQLiteNumericMixin, Expression):\n         template_params[\"default\"] = default_sql\n         sql_params.extend(default_params)\n         template = template or template_params.get(\"template\", self.template)\n-        sql = template % template_params\n+        return template % template_params, sql_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+\n+        if not case_parts:\n+            # All cases were filtered out due to EmptyResultSet exceptions\n+            # Return the default case SQL and parameters\n+            return default_sql, default_params\n+\n+def _represents_always_true(self, condition):\n+    \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+    # Check for negated empty Q objects like ~Q(pk__in=[])\n+    if hasattr(condition, 'negated') and condition.negated:\n+        if hasattr(condition, 'children') and not condition.children:\n+            return True\n+        # Check for empty pk__in conditions\n+        for child in getattr(condition, 'children', []):\n+            if isinstance(child, tuple) and len(child) == 2:\n+                lookup, value = child\n+                if lookup.endswith('__in') and not value:\n+                    return True\n+    return False\n+\n+case_joiner = case_joiner or self.case_joiner\n+template_params[\"cases\"] = case_joiner.join(case_parts)\n+template_params[\"default\"] = default_sql\n+sql_params.extend(default_params)\n+template = template or template_params.get(\"template\", self.template)\n+sql = template % template_params\n         if self._output_field_or_none is not None:\n             sql = connection.ops.unification_cast_sql(self.output_field) % sql\n         return sql, sql_params\n",
    "variant_2": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..29826afe71 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,7 +1298,10 @@ class When(Expression):\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n-        condition_sql, condition_params = compiler.compile(self.condition)\n+\n+condition_sql, condition_params = self._compile_condition_with_empty_handling(\n+    compiler, self.condition\n+)\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n@@ -1374,6 +1377,17 @@ class Case(SQLiteNumericMixin, Expression):\n         c.cases = c.cases[:]\n         return c\n \n+    def as_sql(\n+        self, compiler, connection, template=None, case_joiner=None, **extra_context\n+    ):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            return compiler.compile(self.default)\n+        template_params = {**self.extra, **extra_context}\n+        case_parts = []\n+        sql_params = []\n+        for case in self.cases:\n+\n     def as_sql(\n         self, compiler, connection, template=None, case_joiner=None, **extra_context\n     ):\n@@ -1387,7 +1401,14 @@ class Case(SQLiteNumericMixin, Expression):\n             try:\n                 case_sql, case_params = compiler.compile(case)\n             except EmptyResultSet:\n-                continue\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue\n             case_parts.append(case_sql)\n             sql_params.extend(case_params)\n         default_sql, default_params = compiler.compile(self.default)\n@@ -1399,6 +1420,86 @@ class Case(SQLiteNumericMixin, Expression):\n         sql_params.extend(default_params)\n         template = template or template_params.get(\"template\", self.template)\n         sql = template % template_params\n+        return sql, sql_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+\n+        if not case_parts:\n+            # Check if we had cases that were skipped due to EmptyResultSet\n+            # but might represent \"always true\" conditions (like ~Q(pk__in=[]))\n+            has_always_true_cases = False\n+            for case in self.cases:\n+                try:\n+                    compiler.compile(case)\n+                except EmptyResultSet:\n+                    # Check if this represents a negated empty condition\n+                    if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                        has_always_true_cases = True\n+                        break\n+            \n+            if has_always_true_cases:\n+                # Re-process cases, handling always-true conditions properly\n+                case_parts = []\n+                sql_params = []\n+                for case in self.cases:\n+                    try:\n+                        case_sql, case_params = compiler.compile(case)\n+                        case_parts.append(case_sql)\n+                        sql_params.extend(case_params)\n+                    except EmptyResultSet:\n+                        if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                            result_sql, result_params = compiler.compile(case.result)\n+                            case_parts.append(f\"WHEN 1=1 THEN {result_sql}\")\n+                            sql_params.extend(result_params)\n+                \n+                if case_parts:\n+                    case_joiner = case_joiner or self.case_joiner\n+                    template_params[\"cases\"] = case_joiner.join(case_parts)\n+                    template_params[\"default\"] = default_sql\n+                    sql_params.extend(default_params)\n+                    template = template or template_params.get(\"template\", self.template)\n+                    sql = template % template_params\n+                    if self._output_field_or_none is not None:\n+                        sql = connection.ops.unification_cast_sql(self.output_field) % sql\n+                    return sql, sql_params\n+            \n+            return default_sql, default_params\n+\n+def _represents_always_true(self, condition):\n+    \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+    # Check for negated empty Q objects like ~Q(pk__in=[])\n+    if hasattr(condition, 'negated') and condition.negated:\n+        if hasattr(condition, 'children') and not condition.children:\n+            return True\n+        # Check for empty pk__in conditions\n+        for child in getattr(condition, 'children', []):\n+            if isinstance(child, tuple) and len(child) == 2:\n+                lookup, value = child\n+                if lookup.endswith('__in') and not value:\n+                    return True\n+    return False\n+\n+case_joiner = case_joiner or self.case_joiner\n+template_params[\"cases\"] = case_joiner.join(case_parts)\n+template_params[\"default\"] = default_sql\n+sql_params.extend(default_params)\n+template = template or template_params.get(\"template\", self.template)\n+sql = template % template_params\n         if self._output_field_or_none is not None:\n             sql = connection.ops.unification_cast_sql(self.output_field) % sql\n         return sql, sql_params\n",
    "variant_3": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..46e91e121a 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,7 +1298,8 @@ class When(Expression):\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n-        condition_sql, condition_params = compiler.compile(self.condition)\n+\n+condition_sql, condition_params = compiler.compile(self.condition)\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n@@ -1374,6 +1375,17 @@ class Case(SQLiteNumericMixin, Expression):\n         c.cases = c.cases[:]\n         return c\n \n+    def as_sql(\n+        self, compiler, connection, template=None, case_joiner=None, **extra_context\n+    ):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            return compiler.compile(self.default)\n+        template_params = {**self.extra, **extra_context}\n+        case_parts = []\n+        sql_params = []\n+        for case in self.cases:\n+\n     def as_sql(\n         self, compiler, connection, template=None, case_joiner=None, **extra_context\n     ):\n@@ -1387,7 +1399,14 @@ class Case(SQLiteNumericMixin, Expression):\n             try:\n                 case_sql, case_params = compiler.compile(case)\n             except EmptyResultSet:\n-                continue\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue\n             case_parts.append(case_sql)\n             sql_params.extend(case_params)\n         default_sql, default_params = compiler.compile(self.default)\n@@ -1398,6 +1417,34 @@ class Case(SQLiteNumericMixin, Expression):\n         template_params[\"default\"] = default_sql\n         sql_params.extend(default_params)\n         template = template or template_params.get(\"template\", self.template)\n+        return template % template_params, sql_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+\n+        if not case_parts:\n+            # All cases resulted in EmptyResultSet - return just the default\n+            return default_sql, default_params\n+\n+        case_joiner = case_joiner or self.case_joiner\n+        template_params[\"cases\"] = case_joiner.join(case_parts)\n+        template_params[\"default\"] = default_sql\n+        sql_params.extend(default_params)\n+        template = template or template_params.get(\"template\", self.template)\n         sql = template % template_params\n         if self._output_field_or_none is not None:\n             sql = connection.ops.unification_cast_sql(self.output_field) % sql\n",
    "variant_4": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..66311a51df 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,7 +1298,8 @@ class When(Expression):\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n-        condition_sql, condition_params = compiler.compile(self.condition)\n+\n+condition_sql, condition_params = compiler.compile(self.condition)\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n@@ -1384,9 +1385,107 @@ class Case(SQLiteNumericMixin, Expression):\n         case_parts = []\n         sql_params = []\n         for case in self.cases:\n+\n+    def as_sql(\n+        self, compiler, connection, template=None, case_joiner=None, **extra_context\n+    ):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            return compiler.compile(self.default)\n+        template_params = {**self.extra, **extra_context}\n+        case_parts = []\n+        sql_params = []\n+        for case in self.cases:\n+            try:\n+                case_sql, case_params = compiler.compile(case)\n+            except EmptyResultSet:\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+        if not case_parts:\n+            return default_sql, default_params\n+        case_joiner = case_joiner or self.case_joiner\n+        template_params[\"cases\"] = case_joiner.join(case_parts)\n+        template_params[\"default\"] = default_sql\n+        sql_params.extend(default_params)\n+        template = template or template_params.get(\"template\", self.template)\n+        return template % template_params, sql_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+\n+        if not case_parts:\n+            # Check if all cases were skipped due to EmptyResultSet but represent always-true conditions\n+            always_true_cases = []\n+            for case in self.cases:\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    always_true_cases.append((result_sql, result_params))\n+            \n+            if always_true_cases:\n+                # Return the first always-true case result directly\n+                return always_true_cases[0]\n+            \n+            return default_sql, default_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n+\n+    def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            try:\n+                return compiler.compile(self.default)\n+            except EmptyResultSet:\n+                raise EmptyResultSet\n+        case_parts = []\n+        sql_params = []\n+        template_params = {**self.extra, **extra_context}\n+        for case in self.cases:\n             try:\n                 case_sql, case_params = compiler.compile(case)\n             except EmptyResultSet:\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                    case_parts.append(case_sql)\n+                    sql_params.extend(case_params)\n                 continue\n             case_parts.append(case_sql)\n             sql_params.extend(case_params)\n",
    "variant_5": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..b021e650bb 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,6 +1298,7 @@ class When(Expression):\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n+\n         condition_sql, condition_params = compiler.compile(self.condition)\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n@@ -1383,11 +1384,85 @@ class Case(SQLiteNumericMixin, Expression):\n         template_params = {**self.extra, **extra_context}\n         case_parts = []\n         sql_params = []\n+        for case in self.cases:\n+\n+    def as_sql(\n+        self, compiler, connection, template=None, case_joiner=None, **extra_context\n+    ):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            return compiler.compile(self.default)\n+        template_params = {**self.extra, **extra_context}\n+        case_parts = []\n+        sql_params = []\n+        for case in self.cases:\n+            try:\n+                case_sql, case_params = compiler.compile(case)\n+            except EmptyResultSet:\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+        if not case_parts:\n+            return default_sql, default_params\n+        case_joiner = case_joiner or self.case_joiner\n+        template_params[\"cases\"] = case_joiner.join(case_parts)\n+        template_params[\"default\"] = default_sql\n+        sql_params.extend(default_params)\n+        template = template or template_params.get(\"template\", self.template)\n+        return template % template_params, sql_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+\n+        if not case_parts:\n+            # If no case parts were generated, check if any cases represent \"always true\" conditions\n+            # that were incorrectly skipped due to EmptyResultSet exceptions\n+            for case in self.cases:\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for the \"always true\" case\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_parts.append(f\"WHEN 1=1 THEN {result_sql}\")\n+                    sql_params.extend(result_params)\n+                    break  # Use the first \"always true\" case found\n+            \n+            # If still no case parts after checking for \"always true\" conditions\n+            if not case_parts:\n+                return default_sql, default_params\n+\n         for case in self.cases:\n             try:\n                 case_sql, case_params = compiler.compile(case)\n             except EmptyResultSet:\n-                continue\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue\n             case_parts.append(case_sql)\n             sql_params.extend(case_params)\n         default_sql, default_params = compiler.compile(self.default)\n",
    "variant_6": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..5bf1b4caf2 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,6 +1298,7 @@ class When(Expression):\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n+\n         condition_sql, condition_params = compiler.compile(self.condition)\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n@@ -1374,6 +1375,17 @@ class Case(SQLiteNumericMixin, Expression):\n         c.cases = c.cases[:]\n         return c\n \n+    def as_sql(\n+        self, compiler, connection, template=None, case_joiner=None, **extra_context\n+    ):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            return compiler.compile(self.default)\n+        template_params = {**self.extra, **extra_context}\n+        case_parts = []\n+        sql_params = []\n+        for case in self.cases:\n+\n     def as_sql(\n         self, compiler, connection, template=None, case_joiner=None, **extra_context\n     ):\n@@ -1387,12 +1399,47 @@ class Case(SQLiteNumericMixin, Expression):\n             try:\n                 case_sql, case_params = compiler.compile(case)\n             except EmptyResultSet:\n-                continue\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+        if not case_parts:\n+            return default_sql, default_params\n+        case_joiner = case_joiner or self.case_joiner\n+        template_params[\"cases\"] = case_joiner.join(case_parts)\n+        template_params[\"default\"] = default_sql\n+        sql_params.extend(default_params)\n+        template = template or template_params.get(\"template\", self.template)\n+        return template % template_params, sql_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n             case_parts.append(case_sql)\n             sql_params.extend(case_params)\n         default_sql, default_params = compiler.compile(self.default)\n+\n+        default_sql, default_params = compiler.compile(self.default)\n         if not case_parts:\n             return default_sql, default_params\n+\n         case_joiner = case_joiner or self.case_joiner\n         template_params[\"cases\"] = case_joiner.join(case_parts)\n         template_params[\"default\"] = default_sql\n",
    "variant_7": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..860baa4360 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,7 +1298,8 @@ class When(Expression):\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n-        condition_sql, condition_params = compiler.compile(self.condition)\n+\n+condition_sql, condition_params = compiler.compile(self.condition)\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n@@ -1384,10 +1385,104 @@ class Case(SQLiteNumericMixin, Expression):\n         case_parts = []\n         sql_params = []\n         for case in self.cases:\n+\n+    def as_sql(\n+        self, compiler, connection, template=None, case_joiner=None, **extra_context\n+    ):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            return compiler.compile(self.default)\n+        template_params = {**self.extra, **extra_context}\n+        case_parts = []\n+        sql_params = []\n+        for case in self.cases:\n+            try:\n+                case_sql, case_params = compiler.compile(case)\n+            except EmptyResultSet:\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+        if not case_parts:\n+            return default_sql, default_params\n+        case_joiner = case_joiner or self.case_joiner\n+        template_params[\"cases\"] = case_joiner.join(case_parts)\n+        template_params[\"default\"] = default_sql\n+        sql_params.extend(default_params)\n+        template = template or template_params.get(\"template\", self.template)\n+        return template % template_params, sql_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+\n+        if not case_parts:\n+            # Check if all cases were skipped due to EmptyResultSet exceptions\n+            # In this case, return the default value as the complete result\n+            return default_sql, default_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n+\n+    def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):\n+        connection.ops.check_expression_support(self)\n+        if self.cases:\n+            try:\n+                return self.cases[0].result.as_sql(compiler, connection, **extra_context)\n+            except EmptyResultSet:\n+                known_null_counts = len([\n+                    case for case in self.cases\n+                    if case.condition.is_summary\n+                ])\n+                if known_null_counts == len(self.cases):\n+                    return self.default.as_sql(compiler, connection, **extra_context)\n+                raise\n+        case_parts = []\n+        sql_params = []\n+        template_params = {**self.extra, **extra_context}\n+        for case in self.cases:\n             try:\n                 case_sql, case_params = compiler.compile(case)\n             except EmptyResultSet:\n-                continue\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue  # Skip cases that truly represent empty results\n             case_parts.append(case_sql)\n             sql_params.extend(case_params)\n         default_sql, default_params = compiler.compile(self.default)\n",
    "variant_8": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..2c23d120c7 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1298,6 +1298,7 @@ class When(Expression):\n         connection.ops.check_expression_support(self)\n         template_params = extra_context\n         sql_params = []\n+\n         condition_sql, condition_params = compiler.compile(self.condition)\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n@@ -1374,6 +1375,17 @@ class Case(SQLiteNumericMixin, Expression):\n         c.cases = c.cases[:]\n         return c\n \n+    def as_sql(\n+        self, compiler, connection, template=None, case_joiner=None, **extra_context\n+    ):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            return compiler.compile(self.default)\n+        template_params = {**self.extra, **extra_context}\n+        case_parts = []\n+        sql_params = []\n+        for case in self.cases:\n+\n     def as_sql(\n         self, compiler, connection, template=None, case_joiner=None, **extra_context\n     ):\n@@ -1387,7 +1399,14 @@ class Case(SQLiteNumericMixin, Expression):\n             try:\n                 case_sql, case_params = compiler.compile(case)\n             except EmptyResultSet:\n-                continue\n+                # Check if this is a negated empty condition that should match all rows\n+                if hasattr(case, 'condition') and self._represents_always_true(case.condition):\n+                    # Generate SQL for \"always true\" condition\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    case_sql = f\"WHEN 1=1 THEN {result_sql}\"\n+                    case_params = result_params\n+                else:\n+                    continue  # Skip cases that truly represent empty results\n             case_parts.append(case_sql)\n             sql_params.extend(case_params)\n         default_sql, default_params = compiler.compile(self.default)\n@@ -1398,6 +1417,40 @@ class Case(SQLiteNumericMixin, Expression):\n         template_params[\"default\"] = default_sql\n         sql_params.extend(default_params)\n         template = template or template_params.get(\"template\", self.template)\n+        return template % template_params, sql_params\n+\n+    def _represents_always_true(self, condition):\n+        \"\"\"Check if an EmptyResultSet condition represents 'always true' logic.\"\"\"\n+        # Check for negated empty Q objects like ~Q(pk__in=[])\n+        if hasattr(condition, 'negated') and condition.negated:\n+            if hasattr(condition, 'children') and not condition.children:\n+                return True\n+            # Check for empty pk__in conditions\n+            for child in getattr(condition, 'children', []):\n+                if isinstance(child, tuple) and len(child) == 2:\n+                    lookup, value = child\n+                    if lookup.endswith('__in') and not value:\n+                        return True\n+        return False\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+\n+        if not case_parts:\n+            # Check if all cases were skipped due to EmptyResultSet exceptions\n+            # that might represent negated empty conditions (always true)\n+            for case in self.cases:\n+                if hasattr(case, 'condition') and self._represents_always_true_condition(case.condition):\n+                    # Generate SQL for this always-true case\n+                    result_sql, result_params = compiler.compile(case.result)\n+                    return result_sql, result_params\n+            return default_sql, default_params\n+\n+        case_joiner = case_joiner or self.case_joiner\n+        template_params[\"cases\"] = case_joiner.join(case_parts)\n+        template_params[\"default\"] = default_sql\n+        sql_params.extend(default_params)\n+        template = template or template_params.get(\"template\", self.template)\n         sql = template % template_params\n         if self._output_field_or_none is not None:\n             sql = connection.ops.unification_cast_sql(self.output_field) % sql\n"
  }
}