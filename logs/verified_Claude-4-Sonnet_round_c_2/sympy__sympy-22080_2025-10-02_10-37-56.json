{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/printing/precedence.py lines 50-52)": "\n    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n    \"Equality\": PRECEDENCE[\"Mul\"],\n    \"Unequality\": PRECEDENCE[\"Mul\"],\n    \"Mod\": PRECEDENCE[\"Mul\"],\n}\n",
    "Location 2 (/root/hy/projects/sympy/sympy/printing/pycode.py lines 235-237)": "\n    def _print_Mod(self, expr):\n        from .precedence import PRECEDENCE\n        PREC = PRECEDENCE[\"Mul\"]\n        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/printing/precedence.py lines 50-52)": [
      "\n    \"MatAdd\": PRECEDENCE[\"Add\"],\n    \"MatPow\": PRECEDENCE[\"Pow\"],\n    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n    \"TensAdd\": PRECEDENCE[\"Add\"],\n    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n    \"TensMul\": PRECEDENCE[\"Mul\"],\n    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n    \"Equality\": PRECEDENCE[\"Mul\"],\n    \"Unequality\": PRECEDENCE[\"Mul\"],\n    \"Mod\": PRECEDENCE[\"Mul\"],\n}\n",
      "\n    \"MatAdd\": PRECEDENCE[\"Add\"],\n    \"MatPow\": PRECEDENCE[\"Pow\"],\n    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n    \"TensAdd\": PRECEDENCE[\"Add\"],\n    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n    \"TensMul\": PRECEDENCE[\"Mul\"],\n    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n    \"Equality\": PRECEDENCE[\"Mul\"],\n    \"Unequality\": PRECEDENCE[\"Mul\"],\n    \"Mod\": PRECEDENCE[\"Mul\"],\n}\n",
      "\n    \"MatAdd\": PRECEDENCE[\"Add\"],\n    \"MatPow\": PRECEDENCE[\"Pow\"],\n    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n    \"TensAdd\": PRECEDENCE[\"Add\"],\n    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n    \"TensMul\": PRECEDENCE[\"Mul\"],\n    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n    \"Equality\": PRECEDENCE[\"Mul\"],\n    \"Unequality\": PRECEDENCE[\"Mul\"],\n    \"Mod\": PRECEDENCE[\"Mul\"],\n}\n",
      "\n    \"MatAdd\": PRECEDENCE[\"Add\"],\n    \"MatPow\": PRECEDENCE[\"Pow\"],\n    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n    \"TensAdd\": PRECEDENCE[\"Add\"],\n    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n    \"TensMul\": PRECEDENCE[\"Mul\"],\n    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n    \"Equality\": PRECEDENCE[\"Mul\"],\n    \"Unequality\": PRECEDENCE[\"Mul\"],\n    \"Mod\": PRECEDENCE[\"Mul\"],\n}\n",
      "\n    \"Equality\": PRECEDENCE[\"Mul\"],\n    \"Unequality\": PRECEDENCE[\"Mul\"],\n    \"Mod\": PRECEDENCE[\"Mul\"],\n}\n",
      "\n    \"MatAdd\": PRECEDENCE[\"Add\"],\n    \"MatPow\": PRECEDENCE[\"Pow\"],\n    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n    \"TensAdd\": PRECEDENCE[\"Add\"],\n    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n    \"TensMul\": PRECEDENCE[\"Mul\"],\n    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n    \"Equality\": PRECEDENCE[\"Mul\"],\n    \"Unequality\": PRECEDENCE[\"Mul\"],\n    \"Mod\": PRECEDENCE[\"Mul\"],\n}\n",
      "\n    \"MatAdd\": PRECEDENCE[\"Add\"],\n    \"MatPow\": PRECEDENCE[\"Pow\"],\n    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n    \"TensAdd\": PRECEDENCE[\"Add\"],\n    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n    \"TensMul\": PRECEDENCE[\"Mul\"],\n    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n    \"Equality\": PRECEDENCE[\"Mul\"],\n    \"Unequality\": PRECEDENCE[\"Mul\"],\n    \"Mod\": PRECEDENCE[\"Mul\"],\n}\n",
      "\n    \"MatAdd\": PRECEDENCE[\"Add\"],\n    \"MatPow\": PRECEDENCE[\"Pow\"],\n    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n    \"TensAdd\": PRECEDENCE[\"Add\"],\n    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n    \"TensMul\": PRECEDENCE[\"Mul\"],\n    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n    \"Equality\": PRECEDENCE[\"Mul\"],\n    \"Unequality\": PRECEDENCE[\"Mul\"],\n    \"Mod\": PRECEDENCE[\"Mul\"],\n}\n"
    ],
    "Location 2 (/root/hy/projects/sympy/sympy/printing/pycode.py lines 235-237)": [
      "\n    def _print_Mod(self, expr):\n        from .precedence import PRECEDENCE\n        PREC = PRECEDENCE[\"Mul\"]\n        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n",
      "\n    def _print_Mod(self, expr):\n        from .precedence import PRECEDENCE\n        PREC = PRECEDENCE[\"Mul\"]\n        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n",
      "\n    def _print_Mod(self, expr):\n        from .precedence import PRECEDENCE\n        PREC = PRECEDENCE[\"Mul\"]\n        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n",
      "\n    def _print_Mod(self, expr):\n        from .precedence import PRECEDENCE\n        PREC = PRECEDENCE[\"Mul\"]\n        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n",
      "\n    def _print_Mod(self, expr):\n        from .precedence import PRECEDENCE\n        PREC = PRECEDENCE[\"Mul\"]\n        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n",
      "\n    def _print_Mod(self, expr):\n        from .precedence import PRECEDENCE\n        PREC = PRECEDENCE[\"Mul\"]\n        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n",
      "\n    def _print_Mod(self, expr):\n        from .precedence import PRECEDENCE\n        PREC = PRECEDENCE[\"Mul\"]\n        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n",
      "\n    def _print_Mod(self, expr):\n        from .precedence import PRECEDENCE\n        PREC = PRECEDENCE[\"Mul\"]\n        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf..c36582da2e 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -47,7 +47,9 @@\n     \"HadamardPower\": PRECEDENCE[\"Pow\"],\n     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n     \"Equality\": PRECEDENCE[\"Mul\"],\n+\n     \"Unequality\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n }\n \n # Sometimes it's not enough to assign a fixed precedence value to a\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..6be643528f 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -232,8 +232,10 @@ def _print_NegativeInfinity(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n+\n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n+        from .precedence import PRECEDENCE\n+        PREC = PRECEDENCE[\"Mul\"]\n         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n \n     def _print_Piecewise(self, expr):\n",
    "variant_0": "diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf..b743f360ab 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -45,11 +45,14 @@\n     \"TensMul\": PRECEDENCE[\"Mul\"],\n     \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n     \"HadamardPower\": PRECEDENCE[\"Pow\"],\n+    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n+    \"Equality\": PRECEDENCE[\"Mul\"],\n+\n     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n     \"Equality\": PRECEDENCE[\"Mul\"],\n     \"Unequality\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n }\n-\n # Sometimes it's not enough to assign a fixed precedence value to a\n # class. Then a function can be inserted in this dictionary that takes\n # an instance of this class as argument and returns the appropriate\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..6be643528f 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -232,8 +232,10 @@ def _print_NegativeInfinity(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n+\n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n+        from .precedence import PRECEDENCE\n+        PREC = PRECEDENCE[\"Mul\"]\n         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n \n     def _print_Piecewise(self, expr):\n",
    "variant_1": "diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf..f8746f6128 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -37,6 +37,17 @@\n     \"Not\": PRECEDENCE[\"Not\"],\n     \"Function\" : PRECEDENCE[\"Func\"],\n     \"NegativeInfinity\": PRECEDENCE[\"Add\"],\n+    \"MatAdd\": PRECEDENCE[\"Add\"],\n+    \"MatPow\": PRECEDENCE[\"Pow\"],\n+    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n+    \"TensAdd\": PRECEDENCE[\"Add\"],\n+    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n+    \"TensMul\": PRECEDENCE[\"Mul\"],\n+    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n+    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n+    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n+    \"Equality\": PRECEDENCE[\"Mul\"],\n+\n     \"MatAdd\": PRECEDENCE[\"Add\"],\n     \"MatPow\": PRECEDENCE[\"Pow\"],\n     \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n@@ -48,8 +59,8 @@\n     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n     \"Equality\": PRECEDENCE[\"Mul\"],\n     \"Unequality\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n }\n-\n # Sometimes it's not enough to assign a fixed precedence value to a\n # class. Then a function can be inserted in this dictionary that takes\n # an instance of this class as argument and returns the appropriate\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..6be643528f 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -232,8 +232,10 @@ def _print_NegativeInfinity(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n+\n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n+        from .precedence import PRECEDENCE\n+        PREC = PRECEDENCE[\"Mul\"]\n         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n \n     def _print_Piecewise(self, expr):\n",
    "variant_2": "diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf..f8746f6128 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -37,6 +37,17 @@\n     \"Not\": PRECEDENCE[\"Not\"],\n     \"Function\" : PRECEDENCE[\"Func\"],\n     \"NegativeInfinity\": PRECEDENCE[\"Add\"],\n+    \"MatAdd\": PRECEDENCE[\"Add\"],\n+    \"MatPow\": PRECEDENCE[\"Pow\"],\n+    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n+    \"TensAdd\": PRECEDENCE[\"Add\"],\n+    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n+    \"TensMul\": PRECEDENCE[\"Mul\"],\n+    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n+    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n+    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n+    \"Equality\": PRECEDENCE[\"Mul\"],\n+\n     \"MatAdd\": PRECEDENCE[\"Add\"],\n     \"MatPow\": PRECEDENCE[\"Pow\"],\n     \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n@@ -48,8 +59,8 @@\n     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n     \"Equality\": PRECEDENCE[\"Mul\"],\n     \"Unequality\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n }\n-\n # Sometimes it's not enough to assign a fixed precedence value to a\n # class. Then a function can be inserted in this dictionary that takes\n # an instance of this class as argument and returns the appropriate\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..6be643528f 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -232,8 +232,10 @@ def _print_NegativeInfinity(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n+\n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n+        from .precedence import PRECEDENCE\n+        PREC = PRECEDENCE[\"Mul\"]\n         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n \n     def _print_Piecewise(self, expr):\n",
    "variant_3": "diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf..f8746f6128 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -37,6 +37,17 @@\n     \"Not\": PRECEDENCE[\"Not\"],\n     \"Function\" : PRECEDENCE[\"Func\"],\n     \"NegativeInfinity\": PRECEDENCE[\"Add\"],\n+    \"MatAdd\": PRECEDENCE[\"Add\"],\n+    \"MatPow\": PRECEDENCE[\"Pow\"],\n+    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n+    \"TensAdd\": PRECEDENCE[\"Add\"],\n+    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n+    \"TensMul\": PRECEDENCE[\"Mul\"],\n+    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n+    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n+    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n+    \"Equality\": PRECEDENCE[\"Mul\"],\n+\n     \"MatAdd\": PRECEDENCE[\"Add\"],\n     \"MatPow\": PRECEDENCE[\"Pow\"],\n     \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n@@ -48,8 +59,8 @@\n     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n     \"Equality\": PRECEDENCE[\"Mul\"],\n     \"Unequality\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n }\n-\n # Sometimes it's not enough to assign a fixed precedence value to a\n # class. Then a function can be inserted in this dictionary that takes\n # an instance of this class as argument and returns the appropriate\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..6be643528f 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -232,8 +232,10 @@ def _print_NegativeInfinity(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n+\n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n+        from .precedence import PRECEDENCE\n+        PREC = PRECEDENCE[\"Mul\"]\n         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n \n     def _print_Piecewise(self, expr):\n",
    "variant_4": "diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf..f8746f6128 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -37,6 +37,17 @@\n     \"Not\": PRECEDENCE[\"Not\"],\n     \"Function\" : PRECEDENCE[\"Func\"],\n     \"NegativeInfinity\": PRECEDENCE[\"Add\"],\n+    \"MatAdd\": PRECEDENCE[\"Add\"],\n+    \"MatPow\": PRECEDENCE[\"Pow\"],\n+    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n+    \"TensAdd\": PRECEDENCE[\"Add\"],\n+    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n+    \"TensMul\": PRECEDENCE[\"Mul\"],\n+    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n+    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n+    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n+    \"Equality\": PRECEDENCE[\"Mul\"],\n+\n     \"MatAdd\": PRECEDENCE[\"Add\"],\n     \"MatPow\": PRECEDENCE[\"Pow\"],\n     \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n@@ -48,8 +59,8 @@\n     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n     \"Equality\": PRECEDENCE[\"Mul\"],\n     \"Unequality\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n }\n-\n # Sometimes it's not enough to assign a fixed precedence value to a\n # class. Then a function can be inserted in this dictionary that takes\n # an instance of this class as argument and returns the appropriate\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..6be643528f 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -232,8 +232,10 @@ def _print_NegativeInfinity(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n+\n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n+        from .precedence import PRECEDENCE\n+        PREC = PRECEDENCE[\"Mul\"]\n         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n \n     def _print_Piecewise(self, expr):\n",
    "variant_5": "diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf..fef1dcfaf9 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -46,10 +46,12 @@\n     \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n     \"HadamardPower\": PRECEDENCE[\"Pow\"],\n     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n+    \"Equality\": PRECEDENCE[\"Mul\"],\n+\n     \"Equality\": PRECEDENCE[\"Mul\"],\n     \"Unequality\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n }\n-\n # Sometimes it's not enough to assign a fixed precedence value to a\n # class. Then a function can be inserted in this dictionary that takes\n # an instance of this class as argument and returns the appropriate\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..6be643528f 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -232,8 +232,10 @@ def _print_NegativeInfinity(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n+\n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n+        from .precedence import PRECEDENCE\n+        PREC = PRECEDENCE[\"Mul\"]\n         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n \n     def _print_Piecewise(self, expr):\n",
    "variant_6": "diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf..f8746f6128 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -37,6 +37,17 @@\n     \"Not\": PRECEDENCE[\"Not\"],\n     \"Function\" : PRECEDENCE[\"Func\"],\n     \"NegativeInfinity\": PRECEDENCE[\"Add\"],\n+    \"MatAdd\": PRECEDENCE[\"Add\"],\n+    \"MatPow\": PRECEDENCE[\"Pow\"],\n+    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n+    \"TensAdd\": PRECEDENCE[\"Add\"],\n+    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n+    \"TensMul\": PRECEDENCE[\"Mul\"],\n+    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n+    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n+    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n+    \"Equality\": PRECEDENCE[\"Mul\"],\n+\n     \"MatAdd\": PRECEDENCE[\"Add\"],\n     \"MatPow\": PRECEDENCE[\"Pow\"],\n     \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n@@ -48,8 +59,8 @@\n     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n     \"Equality\": PRECEDENCE[\"Mul\"],\n     \"Unequality\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n }\n-\n # Sometimes it's not enough to assign a fixed precedence value to a\n # class. Then a function can be inserted in this dictionary that takes\n # an instance of this class as argument and returns the appropriate\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..6be643528f 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -232,8 +232,10 @@ def _print_NegativeInfinity(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n+\n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n+        from .precedence import PRECEDENCE\n+        PREC = PRECEDENCE[\"Mul\"]\n         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n \n     def _print_Piecewise(self, expr):\n",
    "variant_7": "diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf..f8746f6128 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -37,6 +37,17 @@\n     \"Not\": PRECEDENCE[\"Not\"],\n     \"Function\" : PRECEDENCE[\"Func\"],\n     \"NegativeInfinity\": PRECEDENCE[\"Add\"],\n+    \"MatAdd\": PRECEDENCE[\"Add\"],\n+    \"MatPow\": PRECEDENCE[\"Pow\"],\n+    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n+    \"TensAdd\": PRECEDENCE[\"Add\"],\n+    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n+    \"TensMul\": PRECEDENCE[\"Mul\"],\n+    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n+    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n+    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n+    \"Equality\": PRECEDENCE[\"Mul\"],\n+\n     \"MatAdd\": PRECEDENCE[\"Add\"],\n     \"MatPow\": PRECEDENCE[\"Pow\"],\n     \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n@@ -48,8 +59,8 @@\n     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n     \"Equality\": PRECEDENCE[\"Mul\"],\n     \"Unequality\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n }\n-\n # Sometimes it's not enough to assign a fixed precedence value to a\n # class. Then a function can be inserted in this dictionary that takes\n # an instance of this class as argument and returns the appropriate\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..6be643528f 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -232,8 +232,10 @@ def _print_NegativeInfinity(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n+\n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n+        from .precedence import PRECEDENCE\n+        PREC = PRECEDENCE[\"Mul\"]\n         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n \n     def _print_Piecewise(self, expr):\n",
    "variant_8": "diff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf..f8746f6128 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -37,6 +37,17 @@\n     \"Not\": PRECEDENCE[\"Not\"],\n     \"Function\" : PRECEDENCE[\"Func\"],\n     \"NegativeInfinity\": PRECEDENCE[\"Add\"],\n+    \"MatAdd\": PRECEDENCE[\"Add\"],\n+    \"MatPow\": PRECEDENCE[\"Pow\"],\n+    \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n+    \"TensAdd\": PRECEDENCE[\"Add\"],\n+    # As soon as `TensMul` is a subclass of `Mul`, remove this:\n+    \"TensMul\": PRECEDENCE[\"Mul\"],\n+    \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n+    \"HadamardPower\": PRECEDENCE[\"Pow\"],\n+    \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n+    \"Equality\": PRECEDENCE[\"Mul\"],\n+\n     \"MatAdd\": PRECEDENCE[\"Add\"],\n     \"MatPow\": PRECEDENCE[\"Pow\"],\n     \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n@@ -48,8 +59,8 @@\n     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n     \"Equality\": PRECEDENCE[\"Mul\"],\n     \"Unequality\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n }\n-\n # Sometimes it's not enough to assign a fixed precedence value to a\n # class. Then a function can be inserted in this dictionary that takes\n # an instance of this class as argument and returns the appropriate\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..6be643528f 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -232,8 +232,10 @@ def _print_NegativeInfinity(self, expr):\n     def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n+\n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n+        from .precedence import PRECEDENCE\n+        PREC = PRECEDENCE[\"Mul\"]\n         return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n \n     def _print_Piecewise(self, expr):\n"
  }
}