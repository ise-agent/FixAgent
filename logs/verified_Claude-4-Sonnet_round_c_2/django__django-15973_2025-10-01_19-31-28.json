{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/backends/base/schema.py lines 452-454)": "\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                from django.apps import apps\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n",
    "Location 2 (/root/hy/projects/django/django/db/backends/base/schema.py lines 459-461)": "\nfrom django.apps import apps\n\ndef create_model(self, model):\n    \"\"\"\n    Create a table and any accompanying indexes or unique constraints for\n    the given `model`.\n    \"\"\"\n    # Create column SQL, add FK deferreds if needed\n    column_sqls = []\n    params = []\n    for field in model._meta.local_fields:\n        # SQL\n        definition, extra_params = self.column_sql(model, field)\n        if definition is None:\n            continue\n        # Check constraints can go on the column SQL here\n        db_params = field.db_parameters(connection=self.connection)\n        if db_params[\"check\"]:\n            definition += \" \" + self.sql_check_constraint % db_params\n        # Autoincrement SQL (for backends with inline variant)\n        col_type_suffix = field.db_type_suffix(connection=self.connection)\n        if col_type_suffix:\n            definition += \" %s\" % col_type_suffix\n        params.extend(extra_params)\n        # FK\n        if field.remote_field:\n            to_table = field.remote_field.model._meta.db_table\n            to_column = field.remote_field.model._meta.get_field(\n                field.remote_field.field_name\n            ).column\n            if self.sql_create_inline_fk:\n                definition += \" \" + self.sql_create_inline_fk % {\n                    \"to_table\": self.quote_name(to_table),\n                    \"to_column\": self.quote_name(to_column),\n                }\n            elif self.connection.features.supports_foreign_keys:\n                self.deferred_sql.append(\n                    self._create_fk_sql(model, field, \"_fk_%(to_table)s_%(to_column)s\")\n                )\n        # Add the SQL to our big list\n        column_sqls.append(\n            \"%s %s\"\n            % (\n                self.quote_name(field.column),\n                definition,\n            )\n        )\n        # Autoincrement SQL (for backends with post table definition\n        # variant)\n        if field.get_internal_type() in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n            autoinc_sql = self.connection.ops.autoinc_sql(\n                model._meta.db_table, field.column\n            )\n            if autoinc_sql:\n                self.deferred_sql.extend(autoinc_sql)\n\n    # Add any unique_together, index_together, or unique constraints.\n    sql = self.sql_create_table % {\n        \"table\": self.quote_name(model._meta.db_table),\n        \"definition\": \", \".join(column_sqls),\n    }\n    if model._meta.db_tablespace:\n        tablespace_sql = self.connection.ops.tablespace_sql(\n            model._meta.db_tablespace\n        )\n        if tablespace_sql:\n            sql += \" \" + tablespace_sql\n    # Prevent using [] as params, in the case a literal '%' is used in the\n    # definition\n    self.execute(sql, params or None)\n\n    # Add any field index and unique_together's (deferred as SQLite\n    # _remake_table needs it)\n    self.deferred_sql.extend(self._model_indexes_sql(model))\n\n    # Make M2M tables\n    for field in model._meta.local_many_to_many:\n        through_model = field.remote_field.through\n        if isinstance(through_model, str):\n            through_model = apps.get_model(through_model)\n        if through_model._meta.auto_created:\n            self.create_model(through_model)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/backends/base/schema.py lines 452-454)": [
      "\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                from django.apps import apps\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n",
      "\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                from django.apps import apps\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n",
      "\n        # Add any field index and index_together's (deferred as SQLite\n        # _remake_table needs it).\n        self.deferred_sql.extend(self._model_indexes_sql(model))\n\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                from django.apps import apps\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n",
      "\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                from django.apps import apps\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n",
      "\n        # Add any field index and index_together's (deferred as SQLite\n        # _remake_table needs it).\n        self.deferred_sql.extend(self._model_indexes_sql(model))\n\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                from django.apps import apps\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n",
      "\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n",
      "\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                from django.apps import apps\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n",
      "\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/backends/base/schema.py lines 459-461)": [
      "\nfrom django.apps import apps\n\n    def create_model(self, model):\n        \"\"\"\n        Create a table and any accompanying indexes or unique constraints for\n        the given `model`.\n        \"\"\"\n        # Create column SQL, add FK deferreds if needed\n        column_sqls = []\n        params = []\n        for field in model._meta.local_fields:\n            # SQL\n            definition, extra_params = self.column_sql(model, field)\n            if definition is None:\n                continue\n            # Check constraints can go on the column SQL here\n            db_params = field.db_parameters(connection=self.connection)\n            if db_params[\"check\"]:\n                definition += \" \" + self.sql_check_constraint % {\n                    \"check\": db_params[\"check\"],\n                }\n            # Autoincrement SQL (for backends with inline variant)\n            col_type_suffix = field.db_type_suffix(connection=self.connection)\n            if col_type_suffix:\n                definition += \" %s\" % col_type_suffix\n            params.extend(extra_params)\n            # FK\n            if field.remote_field:\n                to_table = field.remote_field.model._meta.db_table\n                to_column = field.remote_field.model._meta.get_field(\n                    field.remote_field.field_name\n                ).column\n                if self.sql_create_inline_fk:\n                    definition += \" \" + self.sql_create_inline_fk % {\n                        \"to_table\": self.quote_name(to_table),\n                        \"to_column\": self.quote_name(to_column),\n                    }\n                elif self.connection.features.supports_foreign_keys:\n                    self.deferred_sql.append(\n                        self._create_fk_sql(model, field, \"_fk_%(to_table)s_%(to_column)s\")\n                    )\n            # Add the SQL to our big list\n            column_sqls.append(\n                \"%s %s\"\n                % (\n                    self.quote_name(field.column),\n                    definition,\n                )\n            )\n            # Autoincrement SQL (for backends with post table definition\n            # variant)\n            if field.get_internal_type() in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n                autoinc_sql = self.connection.ops.autoinc_sql(\n                    model._meta.db_table, field.column\n                )\n                if autoinc_sql:\n                    self.deferred_sql.extend(autoinc_sql)\n\n        # Add any unique_together, index_together, or Meta.indexes\n        self.deferred_sql.extend(self._model_indexes_sql(model))\n\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n\n    def delete_model(self, model):\n        \"\"\"Delete a model from the database.\"\"\"\n        # Handle auto-created intermediary models\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.delete_model(through_model)\n",
      "\n    def delete_model(self, model):\n        \"\"\"Delete a model from the database.\"\"\"\n        # Handle auto-created intermediary models\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                from django.apps import apps\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.delete_model(through_model)\n",
      "\n    def create_model(self, model):\n        \"\"\"\n        Create a table and any accompanying indexes or unique constraints for\n        the given `model`.\n        \"\"\"\n        # Create column SQL, add FK deferreds if needed\n        column_sqls = []\n        params = []\n        for field in model._meta.local_fields:\n            # SQL\n            definition, extra_params = self.column_sql(model, field)\n            if definition is None:\n                continue\n            # Check constraints can go on the column SQL here\n            db_params = field.db_parameters(connection=self.connection)\n            if db_params[\"check\"]:\n                definition += \" \" + self.sql_check_constraint % {\n                    \"check\": db_params[\"check\"],\n                }\n            # Autoincrement SQL (for backends with inline variant)\n            col_type_suffix = field.db_type_suffix(connection=self.connection)\n            if col_type_suffix:\n                definition += \" %s\" % col_type_suffix\n            params.extend(extra_params)\n            # FK\n            if field.remote_field:\n                to_table = field.remote_field.model._meta.db_table\n                to_column = field.remote_field.model._meta.get_field(\n                    field.remote_field.field_name\n                ).column\n                if self.sql_create_inline_fk:\n                    definition += \" \" + self.sql_create_inline_fk % {\n                        \"to_table\": self.quote_name(to_table),\n                        \"to_column\": self.quote_name(to_column),\n                    }\n                elif self.connection.features.supports_foreign_keys:\n                    self.deferred_sql.append(\n                        self._create_fk_sql(model, field, \"_fk_%(to_table)s_%(to_column)s\")\n                    )\n            # Add the SQL to our big list\n            column_sqls.append(\n                \"%s %s\"\n                % (\n                    self.quote_name(field.column),\n                    definition,\n                )\n            )\n            # Autoincrement SQL (for backends with post table definition\n            # variant)\n            if field.get_internal_type() in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n                autoinc_sql = self.connection.ops.autoinc_sql(\n                    model._meta.db_table, field.column\n                )\n                if autoinc_sql:\n                    self.deferred_sql.extend(autoinc_sql)\n\n        # Add any unique_togethers (always deferred, as some fields might be\n        # created afterwards, like geometry fields with some backends)\n        for fields in model._meta.unique_together:\n            columns = [model._meta.get_field(field).column for field in fields]\n            self.deferred_sql.append(self._create_unique_sql(model, columns))\n        # Make the table\n        sql = self.sql_create_table % {\n            \"table\": self.quote_name(model._meta.db_table),\n            \"definition\": \", \".join(column_sqls),\n        }\n        if model._meta.db_tablespace:\n            tablespace_sql = self.connection.ops.tablespace_sql(\n                model._meta.db_tablespace\n            )\n            if tablespace_sql:\n                sql += \" \" + tablespace_sql\n        # Prevent using [] as params, in the case a literal '%' is used in the\n        # definition\n        self.execute(sql, params or None)\n\n        # Add any field index and index_together's (deferred as SQLite\n        # _remake_table needs it)\n        self.deferred_sql.extend(self._model_indexes_sql(model))\n\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n",
      "\nfrom django.apps import apps\n",
      "\n    def create_model(self, model):\n        \"\"\"\n        Create a table and any accompanying indexes or unique constraints for\n        the given `model`.\n        \"\"\"\n        # Create column SQL, add FK deferreds if needed\n        column_sqls = []\n        params = []\n        for field in model._meta.local_fields:\n            # SQL\n            definition, extra_params = self.column_sql(model, field)\n            if definition is None:\n                continue\n            # Check constraints can go on the column SQL here\n            db_params = field.db_parameters(connection=self.connection)\n            if db_params[\"check\"]:\n                definition += \" \" + self.sql_check_constraint % {\n                    \"check\": db_params[\"check\"],\n                }\n            # Autoincrement SQL (for backends with inline variant)\n            col_type_suffix = field.db_type_suffix(connection=self.connection)\n            if col_type_suffix:\n                definition += \" %s\" % col_type_suffix\n            params.extend(extra_params)\n            # FK\n            if field.remote_field:\n                to_table = field.remote_field.model._meta.db_table\n                to_column = field.remote_field.model._meta.get_field(\n                    field.remote_field.field_name\n                ).column\n                if self.sql_create_inline_fk:\n                    definition += \" \" + self.sql_create_inline_fk % {\n                        \"to_table\": self.quote_name(to_table),\n                        \"to_column\": self.quote_name(to_column),\n                    }\n                elif self.connection.features.supports_foreign_keys:\n                    self.deferred_sql.append(\n                        self._create_fk_sql(model, field, \"_fk_%(to_table)s_%(to_column)s\")\n                    )\n            # Add the SQL to our big list\n            column_sqls.append(\n                \"%s %s\"\n                % (\n                    self.quote_name(field.column),\n                    definition,\n                )\n            )\n            # Autoincrement SQL (for backends with post table definition\n            # variant)\n            if field.get_internal_type() in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n                autoinc_sql = self.connection.ops.autoinc_sql(\n                    model._meta.db_table, field.column\n                )\n                if autoinc_sql:\n                    self.deferred_sql.extend(autoinc_sql)\n\n        # Add any unique_togethers (always deferred, as some fields might not\n        # be present yet)\n        for fields in model._meta.unique_together:\n            columns = [model._meta.get_field(field).column for field in fields]\n            self.deferred_sql.append(self._create_unique_sql(model, columns))\n        # Make the table\n        sql = self.sql_create_table % {\n            \"table\": self.quote_name(model._meta.db_table),\n            \"definition\": \", \".join(column_sqls),\n        }\n        if model._meta.db_tablespace:\n            tablespace_sql = self.connection.ops.tablespace_sql(\n                model._meta.db_tablespace\n            )\n            if tablespace_sql:\n                sql += \" \" + tablespace_sql\n        self.execute(sql, params)\n\n        # Deferred SQL\n        self.deferred_sql.extend(self._model_indexes_sql(model))\n\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                from django.apps import apps\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n",
      "\n        # Handle auto-created intermediary models\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.delete_model(through_model)\n",
      "\nfrom django.apps import apps\n\n    def create_model(self, model):\n        \"\"\"\n        Create a table and any accompanying indexes or unique constraints for\n        the given `model`.\n        \"\"\"\n        # Create column SQL, add FK deferreds if needed\n        column_sqls = []\n        params = []\n        for field in model._meta.local_fields:\n            # SQL\n            definition, extra_params = self.column_sql(model, field)\n            if definition is None:\n                continue\n            # Check constraints can go on the column SQL here\n            db_params = field.db_parameters(connection=self.connection)\n            if db_params[\"check\"]:\n                definition += \" \" + self.sql_check_constraint % db_params\n            # Autoincrement SQL (for backends with inline variant)\n            col_type_suffix = field.db_type_suffix(connection=self.connection)\n            if col_type_suffix:\n                definition += \" %s\" % col_type_suffix\n            params.extend(extra_params)\n            # FK\n            if field.remote_field:\n                to_table = field.remote_field.model._meta.db_table\n                to_column = field.remote_field.model._meta.get_field(\n                    field.remote_field.field_name\n                ).column\n                if self.sql_create_inline_fk:\n                    definition += \" \" + self.sql_create_inline_fk % {\n                        \"to_table\": self.quote_name(to_table),\n                        \"to_column\": self.quote_name(to_column),\n                    }\n                elif self.connection.features.supports_foreign_keys:\n                    self.deferred_sql.append(\n                        self._create_fk_sql(model, field, \"_fk_%(to_table)s_%(to_column)s\")\n                    )\n            # Add the SQL to our big list\n            column_sqls.append(\n                \"%s %s\"\n                % (\n                    self.quote_name(field.column),\n                    definition,\n                )\n            )\n            # Autoincrement SQL (for backends with post table definition\n            # variant)\n            if field.get_internal_type() in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n                autoinc_sql = self.connection.ops.autoinc_sql(\n                    model._meta.db_table, field.column\n                )\n                if autoinc_sql:\n                    self.deferred_sql.extend(autoinc_sql)\n\n        # Add any unique_together, index_together, or unique constraints.\n        self.deferred_sql.extend(self._model_indexes_sql(model))\n\n        # Make M2M tables\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.create_model(through_model)\n\n    def delete_model(self, model):\n        \"\"\"Delete a model from the database.\"\"\"\n        # Handle auto-created intermediary models\n        for field in model._meta.local_many_to_many:\n            through_model = field.remote_field.through\n            if isinstance(through_model, str):\n                through_model = apps.get_model(through_model)\n            if through_model._meta.auto_created:\n                self.delete_model(through_model)\n",
      "\nimport logging\nimport operator\nfrom datetime import datetime\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.db.backends.ddl_references import (\nfrom django.db.backends.utils import names_digest, split_identifier\nfrom django.db.models import Deferrable, Index\nfrom django.db.models.sql import Query\nfrom django.db.transaction import TransactionManagementError, atomic\nfrom django.utils import timezone\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..145d7c25f5 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -448,17 +448,29 @@ class BaseDatabaseSchemaEditor:\n         # _remake_table needs it).\n         self.deferred_sql.extend(self._model_indexes_sql(model))\n \n+        # Make M2M tables\n+\n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n+        # Handle auto-created intermediary models\n+\n         # Handle auto-created intermediary models\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.delete_model(through_model)\n \n         # Delete the table\n         self.execute(\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..3d450d20df 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -448,17 +448,103 @@ class BaseDatabaseSchemaEditor:\n         # _remake_table needs it).\n         self.deferred_sql.extend(self._model_indexes_sql(model))\n \n+        # Make M2M tables\n+\n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n         # Handle auto-created intermediary models\n-        for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+\n+from django.apps import apps\n+\n+def create_model(self, model):\n+    \"\"\"\n+    Create a table and any accompanying indexes or unique constraints for\n+    the given `model`.\n+    \"\"\"\n+    # Create column SQL, add FK deferreds if needed\n+    column_sqls = []\n+    params = []\n+    for field in model._meta.local_fields:\n+        # SQL\n+        definition, extra_params = self.column_sql(model, field)\n+        if definition is None:\n+            continue\n+        # Check constraints can go on the column SQL here\n+        db_params = field.db_parameters(connection=self.connection)\n+        if db_params[\"check\"]:\n+            definition += \" \" + self.sql_check_constraint % db_params\n+        # Autoincrement SQL (for backends with inline variant)\n+        col_type_suffix = field.db_type_suffix(connection=self.connection)\n+        if col_type_suffix:\n+            definition += \" %s\" % col_type_suffix\n+        params.extend(extra_params)\n+        # FK\n+        if field.remote_field:\n+            to_table = field.remote_field.model._meta.db_table\n+            to_column = field.remote_field.model._meta.get_field(\n+                field.remote_field.field_name\n+            ).column\n+            if self.sql_create_inline_fk:\n+                definition += \" \" + self.sql_create_inline_fk % {\n+                    \"to_table\": self.quote_name(to_table),\n+                    \"to_column\": self.quote_name(to_column),\n+                }\n+            elif self.connection.features.supports_foreign_keys:\n+                self.deferred_sql.append(\n+                    self._create_fk_sql(model, field, \"_fk_%(to_table)s_%(to_column)s\")\n+                )\n+        # Add the SQL to our big list\n+        column_sqls.append(\n+            \"%s %s\"\n+            % (\n+                self.quote_name(field.column),\n+                definition,\n+            )\n+        )\n+        # Autoincrement SQL (for backends with post table definition\n+        # variant)\n+        if field.get_internal_type() in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n+            autoinc_sql = self.connection.ops.autoinc_sql(\n+                model._meta.db_table, field.column\n+            )\n+            if autoinc_sql:\n+                self.deferred_sql.extend(autoinc_sql)\n+\n+    # Add any unique_together, index_together, or unique constraints.\n+    sql = self.sql_create_table % {\n+        \"table\": self.quote_name(model._meta.db_table),\n+        \"definition\": \", \".join(column_sqls),\n+    }\n+    if model._meta.db_tablespace:\n+        tablespace_sql = self.connection.ops.tablespace_sql(\n+            model._meta.db_tablespace\n+        )\n+        if tablespace_sql:\n+            sql += \" \" + tablespace_sql\n+    # Prevent using [] as params, in the case a literal '%' is used in the\n+    # definition\n+    self.execute(sql, params or None)\n+\n+    # Add any field index and unique_together's (deferred as SQLite\n+    # _remake_table needs it)\n+    self.deferred_sql.extend(self._model_indexes_sql(model))\n+\n+    # Make M2M tables\n+    for field in model._meta.local_many_to_many:\n+        through_model = field.remote_field.through\n+        if isinstance(through_model, str):\n+            through_model = apps.get_model(through_model)\n+        if through_model._meta.auto_created:\n+            self.create_model(through_model)\n \n         # Delete the table\n         self.execute(\n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..ff5ab71992 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -448,17 +448,99 @@ class BaseDatabaseSchemaEditor:\n         # _remake_table needs it).\n         self.deferred_sql.extend(self._model_indexes_sql(model))\n \n+        # Make M2M tables\n+\n+        # Make M2M tables\n+        for field in model._meta.local_many_to_many:\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n+\n+    def delete_model(self, model):\n+        \"\"\"Delete a model from the database.\"\"\"\n+        # Handle auto-created intermediary models\n+\n+from django.apps import apps\n+\n+    def create_model(self, model):\n+        \"\"\"\n+        Create a table and any accompanying indexes or unique constraints for\n+        the given `model`.\n+        \"\"\"\n+        # Create column SQL, add FK deferreds if needed\n+        column_sqls = []\n+        params = []\n+        for field in model._meta.local_fields:\n+            # SQL\n+            definition, extra_params = self.column_sql(model, field)\n+            if definition is None:\n+                continue\n+            # Check constraints can go on the column SQL here\n+            db_params = field.db_parameters(connection=self.connection)\n+            if db_params[\"check\"]:\n+                definition += \" \" + self.sql_check_constraint % {\n+                    \"check\": db_params[\"check\"],\n+                }\n+            # Autoincrement SQL (for backends with inline variant)\n+            col_type_suffix = field.db_type_suffix(connection=self.connection)\n+            if col_type_suffix:\n+                definition += \" %s\" % col_type_suffix\n+            params.extend(extra_params)\n+            # FK\n+            if field.remote_field:\n+                to_table = field.remote_field.model._meta.db_table\n+                to_column = field.remote_field.model._meta.get_field(\n+                    field.remote_field.field_name\n+                ).column\n+                if self.sql_create_inline_fk:\n+                    definition += \" \" + self.sql_create_inline_fk % {\n+                        \"to_table\": self.quote_name(to_table),\n+                        \"to_column\": self.quote_name(to_column),\n+                    }\n+                elif self.connection.features.supports_foreign_keys:\n+                    self.deferred_sql.append(\n+                        self._create_fk_sql(model, field, \"_fk_%(to_table)s_%(to_column)s\")\n+                    )\n+            # Add the SQL to our big list\n+            column_sqls.append(\n+                \"%s %s\"\n+                % (\n+                    self.quote_name(field.column),\n+                    definition,\n+                )\n+            )\n+            # Autoincrement SQL (for backends with post table definition\n+            # variant)\n+            if field.get_internal_type() in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n+                autoinc_sql = self.connection.ops.autoinc_sql(\n+                    model._meta.db_table, field.column\n+                )\n+                if autoinc_sql:\n+                    self.deferred_sql.extend(autoinc_sql)\n+\n+        # Add any unique_together, index_together, or Meta.indexes\n+        self.deferred_sql.extend(self._model_indexes_sql(model))\n+\n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n         # Handle auto-created intermediary models\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.delete_model(through_model)\n \n         # Delete the table\n         self.execute(\n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..5a80d41cbc 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -448,17 +448,31 @@ class BaseDatabaseSchemaEditor:\n         # _remake_table needs it).\n         self.deferred_sql.extend(self._model_indexes_sql(model))\n \n+        # Make M2M tables\n+\n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n+\n+    def delete_model(self, model):\n+        \"\"\"Delete a model from the database.\"\"\"\n+        # Handle auto-created intermediary models\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n         # Handle auto-created intermediary models\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.delete_model(through_model)\n \n         # Delete the table\n         self.execute(\n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..2be4cbfa9b 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -448,17 +448,112 @@ class BaseDatabaseSchemaEditor:\n         # _remake_table needs it).\n         self.deferred_sql.extend(self._model_indexes_sql(model))\n \n+        # Make M2M tables\n+\n+        # Add any field index and index_together's (deferred as SQLite\n+        # _remake_table needs it).\n+        self.deferred_sql.extend(self._model_indexes_sql(model))\n+\n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n         # Handle auto-created intermediary models\n+\n+    def create_model(self, model):\n+        \"\"\"\n+        Create a table and any accompanying indexes or unique constraints for\n+        the given `model`.\n+        \"\"\"\n+        # Create column SQL, add FK deferreds if needed\n+        column_sqls = []\n+        params = []\n+        for field in model._meta.local_fields:\n+            # SQL\n+            definition, extra_params = self.column_sql(model, field)\n+            if definition is None:\n+                continue\n+            # Check constraints can go on the column SQL here\n+            db_params = field.db_parameters(connection=self.connection)\n+            if db_params[\"check\"]:\n+                definition += \" \" + self.sql_check_constraint % {\n+                    \"check\": db_params[\"check\"],\n+                }\n+            # Autoincrement SQL (for backends with inline variant)\n+            col_type_suffix = field.db_type_suffix(connection=self.connection)\n+            if col_type_suffix:\n+                definition += \" %s\" % col_type_suffix\n+            params.extend(extra_params)\n+            # FK\n+            if field.remote_field:\n+                to_table = field.remote_field.model._meta.db_table\n+                to_column = field.remote_field.model._meta.get_field(\n+                    field.remote_field.field_name\n+                ).column\n+                if self.sql_create_inline_fk:\n+                    definition += \" \" + self.sql_create_inline_fk % {\n+                        \"to_table\": self.quote_name(to_table),\n+                        \"to_column\": self.quote_name(to_column),\n+                    }\n+                elif self.connection.features.supports_foreign_keys:\n+                    self.deferred_sql.append(\n+                        self._create_fk_sql(model, field, \"_fk_%(to_table)s_%(to_column)s\")\n+                    )\n+            # Add the SQL to our big list\n+            column_sqls.append(\n+                \"%s %s\"\n+                % (\n+                    self.quote_name(field.column),\n+                    definition,\n+                )\n+            )\n+            # Autoincrement SQL (for backends with post table definition\n+            # variant)\n+            if field.get_internal_type() in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n+                autoinc_sql = self.connection.ops.autoinc_sql(\n+                    model._meta.db_table, field.column\n+                )\n+                if autoinc_sql:\n+                    self.deferred_sql.extend(autoinc_sql)\n+\n+        # Add any unique_togethers (always deferred, as some fields might be\n+        # created afterwards, like geometry fields with some backends)\n+        for fields in model._meta.unique_together:\n+            columns = [model._meta.get_field(field).column for field in fields]\n+            self.deferred_sql.append(self._create_unique_sql(model, columns))\n+        # Make the table\n+        sql = self.sql_create_table % {\n+            \"table\": self.quote_name(model._meta.db_table),\n+            \"definition\": \", \".join(column_sqls),\n+        }\n+        if model._meta.db_tablespace:\n+            tablespace_sql = self.connection.ops.tablespace_sql(\n+                model._meta.db_tablespace\n+            )\n+            if tablespace_sql:\n+                sql += \" \" + tablespace_sql\n+        # Prevent using [] as params, in the case a literal '%' is used in the\n+        # definition\n+        self.execute(sql, params or None)\n+\n+        # Add any field index and index_together's (deferred as SQLite\n+        # _remake_table needs it)\n+        self.deferred_sql.extend(self._model_indexes_sql(model))\n+\n+        # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n         # Delete the table\n         self.execute(\n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..4b49154c17 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -448,17 +448,22 @@ class BaseDatabaseSchemaEditor:\n         # _remake_table needs it).\n         self.deferred_sql.extend(self._model_indexes_sql(model))\n \n+        # Make M2M tables\n+\n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n         # Handle auto-created intermediary models\n-        for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+\n+from django.apps import apps\n \n         # Delete the table\n         self.execute(\n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..0e62faed81 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -448,17 +448,110 @@ class BaseDatabaseSchemaEditor:\n         # _remake_table needs it).\n         self.deferred_sql.extend(self._model_indexes_sql(model))\n \n+        # Make M2M tables\n+\n+        # Add any field index and index_together's (deferred as SQLite\n+        # _remake_table needs it).\n+        self.deferred_sql.extend(self._model_indexes_sql(model))\n+\n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n         # Handle auto-created intermediary models\n+\n+    def create_model(self, model):\n+        \"\"\"\n+        Create a table and any accompanying indexes or unique constraints for\n+        the given `model`.\n+        \"\"\"\n+        # Create column SQL, add FK deferreds if needed\n+        column_sqls = []\n+        params = []\n+        for field in model._meta.local_fields:\n+            # SQL\n+            definition, extra_params = self.column_sql(model, field)\n+            if definition is None:\n+                continue\n+            # Check constraints can go on the column SQL here\n+            db_params = field.db_parameters(connection=self.connection)\n+            if db_params[\"check\"]:\n+                definition += \" \" + self.sql_check_constraint % {\n+                    \"check\": db_params[\"check\"],\n+                }\n+            # Autoincrement SQL (for backends with inline variant)\n+            col_type_suffix = field.db_type_suffix(connection=self.connection)\n+            if col_type_suffix:\n+                definition += \" %s\" % col_type_suffix\n+            params.extend(extra_params)\n+            # FK\n+            if field.remote_field:\n+                to_table = field.remote_field.model._meta.db_table\n+                to_column = field.remote_field.model._meta.get_field(\n+                    field.remote_field.field_name\n+                ).column\n+                if self.sql_create_inline_fk:\n+                    definition += \" \" + self.sql_create_inline_fk % {\n+                        \"to_table\": self.quote_name(to_table),\n+                        \"to_column\": self.quote_name(to_column),\n+                    }\n+                elif self.connection.features.supports_foreign_keys:\n+                    self.deferred_sql.append(\n+                        self._create_fk_sql(model, field, \"_fk_%(to_table)s_%(to_column)s\")\n+                    )\n+            # Add the SQL to our big list\n+            column_sqls.append(\n+                \"%s %s\"\n+                % (\n+                    self.quote_name(field.column),\n+                    definition,\n+                )\n+            )\n+            # Autoincrement SQL (for backends with post table definition\n+            # variant)\n+            if field.get_internal_type() in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n+                autoinc_sql = self.connection.ops.autoinc_sql(\n+                    model._meta.db_table, field.column\n+                )\n+                if autoinc_sql:\n+                    self.deferred_sql.extend(autoinc_sql)\n+\n+        # Add any unique_togethers (always deferred, as some fields might not\n+        # be present yet)\n+        for fields in model._meta.unique_together:\n+            columns = [model._meta.get_field(field).column for field in fields]\n+            self.deferred_sql.append(self._create_unique_sql(model, columns))\n+        # Make the table\n+        sql = self.sql_create_table % {\n+            \"table\": self.quote_name(model._meta.db_table),\n+            \"definition\": \", \".join(column_sqls),\n+        }\n+        if model._meta.db_tablespace:\n+            tablespace_sql = self.connection.ops.tablespace_sql(\n+                model._meta.db_tablespace\n+            )\n+            if tablespace_sql:\n+                sql += \" \" + tablespace_sql\n+        self.execute(sql, params)\n+\n+        # Deferred SQL\n+        self.deferred_sql.extend(self._model_indexes_sql(model))\n+\n+        # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n         # Delete the table\n         self.execute(\n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..20de513ce2 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -448,17 +448,27 @@ class BaseDatabaseSchemaEditor:\n         # _remake_table needs it).\n         self.deferred_sql.extend(self._model_indexes_sql(model))\n \n+        # Make M2M tables\n+\n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n+        # Handle auto-created intermediary models\n+\n         # Handle auto-created intermediary models\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.delete_model(through_model)\n \n         # Delete the table\n         self.execute(\n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..afdd15060d 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -448,17 +448,97 @@ class BaseDatabaseSchemaEditor:\n         # _remake_table needs it).\n         self.deferred_sql.extend(self._model_indexes_sql(model))\n \n+        # Make M2M tables\n+\n+        # Make M2M tables\n+        for field in model._meta.local_many_to_many:\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                from django.apps import apps\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n+\n+    def delete_model(self, model):\n+        \"\"\"Delete a model from the database.\"\"\"\n+        # Handle auto-created intermediary models\n+\n+from django.apps import apps\n+\n+    def create_model(self, model):\n+        \"\"\"\n+        Create a table and any accompanying indexes or unique constraints for\n+        the given `model`.\n+        \"\"\"\n+        # Create column SQL, add FK deferreds if needed\n+        column_sqls = []\n+        params = []\n+        for field in model._meta.local_fields:\n+            # SQL\n+            definition, extra_params = self.column_sql(model, field)\n+            if definition is None:\n+                continue\n+            # Check constraints can go on the column SQL here\n+            db_params = field.db_parameters(connection=self.connection)\n+            if db_params[\"check\"]:\n+                definition += \" \" + self.sql_check_constraint % db_params\n+            # Autoincrement SQL (for backends with inline variant)\n+            col_type_suffix = field.db_type_suffix(connection=self.connection)\n+            if col_type_suffix:\n+                definition += \" %s\" % col_type_suffix\n+            params.extend(extra_params)\n+            # FK\n+            if field.remote_field:\n+                to_table = field.remote_field.model._meta.db_table\n+                to_column = field.remote_field.model._meta.get_field(\n+                    field.remote_field.field_name\n+                ).column\n+                if self.sql_create_inline_fk:\n+                    definition += \" \" + self.sql_create_inline_fk % {\n+                        \"to_table\": self.quote_name(to_table),\n+                        \"to_column\": self.quote_name(to_column),\n+                    }\n+                elif self.connection.features.supports_foreign_keys:\n+                    self.deferred_sql.append(\n+                        self._create_fk_sql(model, field, \"_fk_%(to_table)s_%(to_column)s\")\n+                    )\n+            # Add the SQL to our big list\n+            column_sqls.append(\n+                \"%s %s\"\n+                % (\n+                    self.quote_name(field.column),\n+                    definition,\n+                )\n+            )\n+            # Autoincrement SQL (for backends with post table definition\n+            # variant)\n+            if field.get_internal_type() in (\"AutoField\", \"BigAutoField\", \"SmallAutoField\"):\n+                autoinc_sql = self.connection.ops.autoinc_sql(\n+                    model._meta.db_table, field.column\n+                )\n+                if autoinc_sql:\n+                    self.deferred_sql.extend(autoinc_sql)\n+\n+        # Add any unique_together, index_together, or unique constraints.\n+        self.deferred_sql.extend(self._model_indexes_sql(model))\n+\n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n         # Handle auto-created intermediary models\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.delete_model(through_model)\n \n         # Delete the table\n         self.execute(\n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 09785e8586..31bf137854 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -448,17 +448,31 @@ class BaseDatabaseSchemaEditor:\n         # _remake_table needs it).\n         self.deferred_sql.extend(self._model_indexes_sql(model))\n \n+        # Make M2M tables\n+\n         # Make M2M tables\n         for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.create_model(field.remote_field.through)\n+            through_model = field.remote_field.through\n+            if isinstance(through_model, str):\n+                through_model = apps.get_model(through_model)\n+            if through_model._meta.auto_created:\n+                self.create_model(through_model)\n \n     def delete_model(self, model):\n         \"\"\"Delete a model from the database.\"\"\"\n         # Handle auto-created intermediary models\n-        for field in model._meta.local_many_to_many:\n-            if field.remote_field.through._meta.auto_created:\n-                self.delete_model(field.remote_field.through)\n+\n+import logging\n+import operator\n+from datetime import datetime\n+from django.apps import apps\n+from django.conf import settings\n+from django.db.backends.ddl_references import (\n+from django.db.backends.utils import names_digest, split_identifier\n+from django.db.models import Deferrable, Index\n+from django.db.models.sql import Query\n+from django.db.transaction import TransactionManagementError, atomic\n+from django.utils import timezone\n \n         # Delete the table\n         self.execute(\n"
  }
}