{
  "zero_patches": {
    "Location 1 (/root/hy/projects/xarray/xarray/core/dataarray.py lines 1961-1967)": "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # Handle coordinate conflicts by extracting only shared coordinates\n        # and data variables separately\n        coords_dict = {}\n        data_vars_dict = {}\n\n        if data_dict:\n            # Get the first variable to establish baseline coordinates\n            first_var = next(iter(data_dict.values()))\n            \n            # Find coordinates that are shared by all variables\n            shared_coords = set(first_var.coords.keys())\n            for var in data_dict.values():\n                shared_coords &= set(var.coords.keys())\n            \n            # Extract shared coordinates\n            for coord_name in shared_coords:\n                coords_dict[coord_name] = first_var.coords[coord_name]\n            \n            # Extract data variables without conflicting coordinates\n            for k, var in data_dict.items():\n                # Keep only the data, remove all coordinates to avoid conflicts\n                data_vars_dict[k] = var.variable\n\n        # unstacked dataset - create with explicit separation of coords and data_vars\n        return Dataset(data_vars_dict, coords_dict)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/xarray/xarray/core/dataarray.py lines 1961-1967)": [
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # Handle coordinate conflicts by extracting only shared coordinates\n        # and data variables separately\n        coords_dict = {}\n        data_vars_dict = {}\n\n        if data_dict:\n            # Get the first variable to establish baseline coordinates\n            first_var = next(iter(data_dict.values()))\n            \n            # Find coordinates that are shared by all variables\n            shared_coords = set(first_var.coords.keys())\n            for var in data_dict.values():\n                shared_coords &= set(var.coords.keys())\n            \n            # Extract shared coordinates\n            for coord_name in shared_coords:\n                coords_dict[coord_name] = first_var.coords[coord_name]\n            \n            # Extract data variables without conflicting coordinates\n            for k, var in data_dict.items():\n                # Keep only the data, remove all coordinates to avoid conflicts\n                data_vars_dict[k] = var.variable\n\n        # unstacked dataset - create with explicit separation of coords and data_vars\n        return Dataset(data_vars_dict, coords_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # Handle coordinate conflicts by extracting only shared coordinates\n        # and data variables separately\n        coords_dict = {}\n        data_vars_dict = {}\n\n        if data_dict:\n            # Get the first variable to establish baseline coordinates\n            first_var = next(iter(data_dict.values()))\n            \n            # Find coordinates that are shared by all variables\n            shared_coords = set(first_var.coords.keys())\n            for var in data_dict.values():\n                shared_coords &= set(var.coords.keys())\n            \n            # Extract shared coordinates\n            for coord_name in shared_coords:\n                coords_dict[coord_name] = first_var.coords[coord_name]\n            \n            # Extract data variables without conflicting coordinates\n            for k, var in data_dict.items():\n                # Keep only the data, remove all coordinates to avoid conflicts\n                data_vars_dict[k] = var.variable\n\n        # unstacked dataset - create with explicit separation of coords and data_vars\n        return Dataset(data_vars_dict, coords_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # Handle coordinate conflicts by extracting only shared coordinates\n        # and data variables separately\n        coords_dict = {}\n        data_vars_dict = {}\n\n        if data_dict:\n            # Get the first variable to establish baseline coordinates\n            first_var = next(iter(data_dict.values()))\n            \n            # Find coordinates that are shared by all variables\n            shared_coords = set(first_var.coords.keys())\n            for var in data_dict.values():\n                shared_coords &= set(var.coords.keys())\n            \n            # Extract shared coordinates\n            for coord_name in shared_coords:\n                coords_dict[coord_name] = first_var.coords[coord_name]\n            \n            # Extract data variables without conflicting coordinates\n            for k, var in data_dict.items():\n                # Keep only the data, remove all coordinates to avoid conflicts\n                data_vars_dict[k] = var.variable\n\n        # unstacked dataset - create with explicit separation of coords and data_vars\n        return Dataset(data_vars_dict, coords_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # Handle coordinate conflicts by extracting only shared coordinates\n        # and data variables separately\n        coords_dict = {}\n        data_vars_dict = {}\n\n        if data_dict:\n            # Get the first variable to establish baseline coordinates\n            first_var = next(iter(data_dict.values()))\n            \n            # Find coordinates that are shared by all variables\n            shared_coords = set(first_var.coords.keys())\n            for var in data_dict.values():\n                shared_coords &= set(var.coords.keys())\n            \n            # Extract shared coordinates\n            for coord_name in shared_coords:\n                coords_dict[coord_name] = first_var.coords[coord_name]\n            \n            # Extract data variables without conflicting coordinates\n            for k, var in data_dict.items():\n                # Keep only the data, remove all coordinates to avoid conflicts\n                data_vars_dict[k] = var.variable\n\n        # unstacked dataset - create with explicit separation of coords and data_vars\n        return Dataset(data_vars_dict, coords_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # Handle coordinate conflicts by extracting only shared coordinates\n        # and data variables separately\n        coords_dict = {}\n        data_vars_dict = {}\n\n        if data_dict:\n            # Get the first variable to establish baseline coordinates\n            first_var = next(iter(data_dict.values()))\n            \n            # Find coordinates that are shared by all variables\n            shared_coords = set(first_var.coords.keys())\n            for var in data_dict.values():\n                shared_coords &= set(var.coords.keys())\n            \n            # Extract shared coordinates\n            for coord_name in shared_coords:\n                coords_dict[coord_name] = first_var.coords[coord_name]\n            \n            # Extract data variables without conflicting coordinates\n            for k, var in data_dict.items():\n                # Keep only the data, remove all coordinates to avoid conflicts\n                data_vars_dict[k] = var.variable\n\n        # unstacked dataset - create with explicit separation of coords and data_vars\n        return Dataset(data_vars_dict, coords_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # Handle coordinate conflicts by extracting only shared coordinates\n        # and data variables separately\n        coords_dict = {}\n        data_vars_dict = {}\n\n        if data_dict:\n            # Get the first variable to establish baseline coordinates\n            first_var = next(iter(data_dict.values()))\n            \n            # Find coordinates that are shared by all variables\n            shared_coords = set(first_var.coords.keys())\n            for var in data_dict.values():\n                shared_coords &= set(var.coords.keys())\n            \n            # Extract shared coordinates\n            for coord_name in shared_coords:\n                coords_dict[coord_name] = first_var.coords[coord_name]\n            \n            # Extract data variables without conflicting coordinates\n            for k, var in data_dict.items():\n                # Keep only the data, remove all coordinates to avoid conflicts\n                data_vars_dict[k] = var.variable\n\n        # unstacked dataset - create with explicit separation of coords and data_vars\n        return Dataset(data_vars_dict, coords_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # Handle coordinate conflicts by extracting only shared coordinates\n        # and data variables separately\n        coords_dict = {}\n        data_vars_dict = {}\n\n        if data_dict:\n            # Get the first variable to establish baseline coordinates\n            first_var = next(iter(data_dict.values()))\n            \n            # Find coordinates that are shared by all variables\n            shared_coords = set(first_var.coords.keys())\n            for var in data_dict.values():\n                shared_coords &= set(var.coords.keys())\n            \n            # Extract shared coordinates\n            for coord_name in shared_coords:\n                coords_dict[coord_name] = first_var.coords[coord_name]\n            \n            # Extract data variables without conflicting coordinates\n            for k, var in data_dict.items():\n                # Keep only the data, remove all coordinates to avoid conflicts\n                data_vars_dict[k] = var.variable\n\n        # unstacked dataset - create with explicit separation of coords and data_vars\n        return Dataset(data_vars_dict, coords_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n\n        # Handle coordinate conflicts by extracting only shared coordinates\n        # and data variables separately\n        coords_dict = {}\n        data_vars_dict = {}\n\n        if data_dict:\n            # Get the first variable to establish baseline coordinates\n            first_var = next(iter(data_dict.values()))\n            \n            # Find coordinates that are shared by all variables\n            shared_coords = set(first_var.coords.keys())\n            for var in data_dict.values():\n                shared_coords &= set(var.coords.keys())\n            \n            # Extract shared coordinates\n            for coord_name in shared_coords:\n                coords_dict[coord_name] = first_var.coords[coord_name]\n            \n            # Extract data variables without conflicting coordinates\n            for k, var in data_dict.items():\n                # Keep only the data, remove all coordinates to avoid conflicts\n                data_vars_dict[k] = var.variable\n\n        # unstacked dataset - create with explicit separation of coords and data_vars\n        return Dataset(data_vars_dict, coords_dict)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..5671e584 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,37 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n \n-        # unstacked dataset\n-        return Dataset(data_dict)\n+        # Handle coordinate conflicts by extracting only shared coordinates\n+        # and data variables separately\n+        coords_dict = {}\n+        data_vars_dict = {}\n+\n+        if data_dict:\n+            # Get the first variable to establish baseline coordinates\n+            first_var = next(iter(data_dict.values()))\n+            \n+            # Find coordinates that are shared by all variables\n+            shared_coords = set(first_var.coords.keys())\n+            for var in data_dict.values():\n+                shared_coords &= set(var.coords.keys())\n+            \n+            # Extract shared coordinates\n+            for coord_name in shared_coords:\n+                coords_dict[coord_name] = first_var.coords[coord_name]\n+            \n+            # Extract data variables without conflicting coordinates\n+            for k, var in data_dict.items():\n+                # Keep only the data, remove all coordinates to avoid conflicts\n+                data_vars_dict[k] = var.variable\n+\n+        # unstacked dataset - create with explicit separation of coords and data_vars\n+        return Dataset(data_vars_dict, coords_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n",
    "variant_0": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..5671e584 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,37 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n \n-        # unstacked dataset\n-        return Dataset(data_dict)\n+        # Handle coordinate conflicts by extracting only shared coordinates\n+        # and data variables separately\n+        coords_dict = {}\n+        data_vars_dict = {}\n+\n+        if data_dict:\n+            # Get the first variable to establish baseline coordinates\n+            first_var = next(iter(data_dict.values()))\n+            \n+            # Find coordinates that are shared by all variables\n+            shared_coords = set(first_var.coords.keys())\n+            for var in data_dict.values():\n+                shared_coords &= set(var.coords.keys())\n+            \n+            # Extract shared coordinates\n+            for coord_name in shared_coords:\n+                coords_dict[coord_name] = first_var.coords[coord_name]\n+            \n+            # Extract data variables without conflicting coordinates\n+            for k, var in data_dict.items():\n+                # Keep only the data, remove all coordinates to avoid conflicts\n+                data_vars_dict[k] = var.variable\n+\n+        # unstacked dataset - create with explicit separation of coords and data_vars\n+        return Dataset(data_vars_dict, coords_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n",
    "variant_1": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..5671e584 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,37 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n \n-        # unstacked dataset\n-        return Dataset(data_dict)\n+        # Handle coordinate conflicts by extracting only shared coordinates\n+        # and data variables separately\n+        coords_dict = {}\n+        data_vars_dict = {}\n+\n+        if data_dict:\n+            # Get the first variable to establish baseline coordinates\n+            first_var = next(iter(data_dict.values()))\n+            \n+            # Find coordinates that are shared by all variables\n+            shared_coords = set(first_var.coords.keys())\n+            for var in data_dict.values():\n+                shared_coords &= set(var.coords.keys())\n+            \n+            # Extract shared coordinates\n+            for coord_name in shared_coords:\n+                coords_dict[coord_name] = first_var.coords[coord_name]\n+            \n+            # Extract data variables without conflicting coordinates\n+            for k, var in data_dict.items():\n+                # Keep only the data, remove all coordinates to avoid conflicts\n+                data_vars_dict[k] = var.variable\n+\n+        # unstacked dataset - create with explicit separation of coords and data_vars\n+        return Dataset(data_vars_dict, coords_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n",
    "variant_2": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..5671e584 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,37 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n \n-        # unstacked dataset\n-        return Dataset(data_dict)\n+        # Handle coordinate conflicts by extracting only shared coordinates\n+        # and data variables separately\n+        coords_dict = {}\n+        data_vars_dict = {}\n+\n+        if data_dict:\n+            # Get the first variable to establish baseline coordinates\n+            first_var = next(iter(data_dict.values()))\n+            \n+            # Find coordinates that are shared by all variables\n+            shared_coords = set(first_var.coords.keys())\n+            for var in data_dict.values():\n+                shared_coords &= set(var.coords.keys())\n+            \n+            # Extract shared coordinates\n+            for coord_name in shared_coords:\n+                coords_dict[coord_name] = first_var.coords[coord_name]\n+            \n+            # Extract data variables without conflicting coordinates\n+            for k, var in data_dict.items():\n+                # Keep only the data, remove all coordinates to avoid conflicts\n+                data_vars_dict[k] = var.variable\n+\n+        # unstacked dataset - create with explicit separation of coords and data_vars\n+        return Dataset(data_vars_dict, coords_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n",
    "variant_3": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..5671e584 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,37 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n \n-        # unstacked dataset\n-        return Dataset(data_dict)\n+        # Handle coordinate conflicts by extracting only shared coordinates\n+        # and data variables separately\n+        coords_dict = {}\n+        data_vars_dict = {}\n+\n+        if data_dict:\n+            # Get the first variable to establish baseline coordinates\n+            first_var = next(iter(data_dict.values()))\n+            \n+            # Find coordinates that are shared by all variables\n+            shared_coords = set(first_var.coords.keys())\n+            for var in data_dict.values():\n+                shared_coords &= set(var.coords.keys())\n+            \n+            # Extract shared coordinates\n+            for coord_name in shared_coords:\n+                coords_dict[coord_name] = first_var.coords[coord_name]\n+            \n+            # Extract data variables without conflicting coordinates\n+            for k, var in data_dict.items():\n+                # Keep only the data, remove all coordinates to avoid conflicts\n+                data_vars_dict[k] = var.variable\n+\n+        # unstacked dataset - create with explicit separation of coords and data_vars\n+        return Dataset(data_vars_dict, coords_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n",
    "variant_4": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..5671e584 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,37 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n \n-        # unstacked dataset\n-        return Dataset(data_dict)\n+        # Handle coordinate conflicts by extracting only shared coordinates\n+        # and data variables separately\n+        coords_dict = {}\n+        data_vars_dict = {}\n+\n+        if data_dict:\n+            # Get the first variable to establish baseline coordinates\n+            first_var = next(iter(data_dict.values()))\n+            \n+            # Find coordinates that are shared by all variables\n+            shared_coords = set(first_var.coords.keys())\n+            for var in data_dict.values():\n+                shared_coords &= set(var.coords.keys())\n+            \n+            # Extract shared coordinates\n+            for coord_name in shared_coords:\n+                coords_dict[coord_name] = first_var.coords[coord_name]\n+            \n+            # Extract data variables without conflicting coordinates\n+            for k, var in data_dict.items():\n+                # Keep only the data, remove all coordinates to avoid conflicts\n+                data_vars_dict[k] = var.variable\n+\n+        # unstacked dataset - create with explicit separation of coords and data_vars\n+        return Dataset(data_vars_dict, coords_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n",
    "variant_5": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..5671e584 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,37 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n \n-        # unstacked dataset\n-        return Dataset(data_dict)\n+        # Handle coordinate conflicts by extracting only shared coordinates\n+        # and data variables separately\n+        coords_dict = {}\n+        data_vars_dict = {}\n+\n+        if data_dict:\n+            # Get the first variable to establish baseline coordinates\n+            first_var = next(iter(data_dict.values()))\n+            \n+            # Find coordinates that are shared by all variables\n+            shared_coords = set(first_var.coords.keys())\n+            for var in data_dict.values():\n+                shared_coords &= set(var.coords.keys())\n+            \n+            # Extract shared coordinates\n+            for coord_name in shared_coords:\n+                coords_dict[coord_name] = first_var.coords[coord_name]\n+            \n+            # Extract data variables without conflicting coordinates\n+            for k, var in data_dict.items():\n+                # Keep only the data, remove all coordinates to avoid conflicts\n+                data_vars_dict[k] = var.variable\n+\n+        # unstacked dataset - create with explicit separation of coords and data_vars\n+        return Dataset(data_vars_dict, coords_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n",
    "variant_6": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..5671e584 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,37 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n \n-        # unstacked dataset\n-        return Dataset(data_dict)\n+        # Handle coordinate conflicts by extracting only shared coordinates\n+        # and data variables separately\n+        coords_dict = {}\n+        data_vars_dict = {}\n+\n+        if data_dict:\n+            # Get the first variable to establish baseline coordinates\n+            first_var = next(iter(data_dict.values()))\n+            \n+            # Find coordinates that are shared by all variables\n+            shared_coords = set(first_var.coords.keys())\n+            for var in data_dict.values():\n+                shared_coords &= set(var.coords.keys())\n+            \n+            # Extract shared coordinates\n+            for coord_name in shared_coords:\n+                coords_dict[coord_name] = first_var.coords[coord_name]\n+            \n+            # Extract data variables without conflicting coordinates\n+            for k, var in data_dict.items():\n+                # Keep only the data, remove all coordinates to avoid conflicts\n+                data_vars_dict[k] = var.variable\n+\n+        # unstacked dataset - create with explicit separation of coords and data_vars\n+        return Dataset(data_vars_dict, coords_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n",
    "variant_7": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..5671e584 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,37 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n \n-        # unstacked dataset\n-        return Dataset(data_dict)\n+        # Handle coordinate conflicts by extracting only shared coordinates\n+        # and data variables separately\n+        coords_dict = {}\n+        data_vars_dict = {}\n+\n+        if data_dict:\n+            # Get the first variable to establish baseline coordinates\n+            first_var = next(iter(data_dict.values()))\n+            \n+            # Find coordinates that are shared by all variables\n+            shared_coords = set(first_var.coords.keys())\n+            for var in data_dict.values():\n+                shared_coords &= set(var.coords.keys())\n+            \n+            # Extract shared coordinates\n+            for coord_name in shared_coords:\n+                coords_dict[coord_name] = first_var.coords[coord_name]\n+            \n+            # Extract data variables without conflicting coordinates\n+            for k, var in data_dict.items():\n+                # Keep only the data, remove all coordinates to avoid conflicts\n+                data_vars_dict[k] = var.variable\n+\n+        # unstacked dataset - create with explicit separation of coords and data_vars\n+        return Dataset(data_vars_dict, coords_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n",
    "variant_8": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..5671e584 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,37 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n             data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n \n-        # unstacked dataset\n-        return Dataset(data_dict)\n+        # Handle coordinate conflicts by extracting only shared coordinates\n+        # and data variables separately\n+        coords_dict = {}\n+        data_vars_dict = {}\n+\n+        if data_dict:\n+            # Get the first variable to establish baseline coordinates\n+            first_var = next(iter(data_dict.values()))\n+            \n+            # Find coordinates that are shared by all variables\n+            shared_coords = set(first_var.coords.keys())\n+            for var in data_dict.values():\n+                shared_coords &= set(var.coords.keys())\n+            \n+            # Extract shared coordinates\n+            for coord_name in shared_coords:\n+                coords_dict[coord_name] = first_var.coords[coord_name]\n+            \n+            # Extract data variables without conflicting coordinates\n+            for k, var in data_dict.items():\n+                # Keep only the data, remove all coordinates to avoid conflicts\n+                data_vars_dict[k] = var.variable\n+\n+        # unstacked dataset - create with explicit separation of coords and data_vars\n+        return Dataset(data_vars_dict, coords_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n"
  }
}