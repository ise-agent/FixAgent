{
  "zero_patches": {
    "Location 1 (/root/hy/projects/xarray/xarray/core/computation.py lines 1730-1730)": "\ndef where(cond, x, y, keep_attrs: bool = None):\n",
    "Location 2 (/root/hy/projects/xarray/xarray/core/computation.py lines 1811-1811)": "\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n",
    "Location 3 (/root/hy/projects/xarray/xarray/core/computation.py lines 1812-1820)": "\ndef where(cond, x, y, keep_attrs: bool = None):\n    \"\"\"Return elements from `x` or `y` depending on condition.\n\n    Performs xarray-like broadcasting across input arguments.\n\n    All dimension coordinates on `x` and `y`  must be aligned with each\n    other and with `cond`.\n\n    Parameters\n    ----------\n    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n        When True, return values from `x`, otherwise returns values from `y`.\n    x : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is True\n    y : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is False\n    keep_attrs : bool or None, optional\n        If True, the attributes (attrs) will be copied\n        from the first input to the new one.\n        If False, the new one will not have attributes.\n        If None uses the global default.\n\n    Returns\n    -------\n    Dataset, DataArray, Variable or array\n        In priority order: Dataset, DataArray, Variable, array.\n\n    Examples\n    --------\n\n    >>> import numpy as np\n    >>> import xarray as xr\n    >>> x = xr.DataArray(\n    ...     0.1 * np.arange(10),\n    ...     dims=[\"lat\"],\n    ...     coords={\"lat\": np.arange(10)},\n    ...     name=\"sst\",\n    ... )\n    >>> x\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> xr.where(x < 0.5, x, x * 100)\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> y = xr.DataArray(\n    ...     0.1 * np.arange(9).reshape(3, 3),\n    ...     dims=[\"x\", \"y\"],\n    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n    ...     name=\"sst\",\n    ... )\n    >>> y\n    <xarray.DataArray 'sst' (x: 3, y: 3)>\n    array([[0. , 0.1, 0.2],\n           [0.3, 0.4, 0.5],\n           [0.6, 0.7, 0.8]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> xr.where(y.x + y.y < 4, y, -1)\n    <xarray.DataArray (x: 3, y: 3)>\n    array([[ 0. ,  0.1,  0.2],\n           [ 0.3, -1. , -1. ],\n           [-1. , -1. , -1. ]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n    >>> xr.where(cond, x, 0)\n    <xarray.DataArray (x: 2, y: 2)>\n    array([[1, 2],\n           [0, 0]])\n    Dimensions without coordinates: x, y\n\n    See Also\n    --------\n    numpy.where : corresponding numpy function\n    Dataset.where, DataArray.where :\n        equivalent methods\n    \"\"\"\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    \n    return apply_ufunc(\n        duck_array_ops.where,\n        cond,\n        x,\n        y,\n        join=\"exact\",\n        dataset_join=\"exact\",\n        dask=\"allowed\",\n        keep_attrs=keep_attrs,\n    )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/xarray/xarray/core/computation.py lines 1730-1730)": [
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n    \"\"\"Return elements from `x` or `y` depending on `cond`.\n\n    Performs xarray-like broadcasting across input arguments.\n\n    All dimension coordinates on `x` and `y`  must be aligned with each\n    other and with `cond`.\n\n    Parameters\n    ----------\n    cond : scalar, array, Variable, DataArray or Dataset\n        Locations at which to preserve this object's values. dtype must be `bool`.\n        If a Dataset, it must have a single data variable.\n    x : scalar, array, Variable, DataArray or Dataset\n        values to use where `cond` is True\n    y : scalar, array, Variable, DataArray or Dataset\n        values to use where `cond` is False\n    keep_attrs : bool or None, optional\n        If True, the attributes (attrs) will be copied\n        from the first input to the new one.\n        If False, the new one will not copy attributes from the first input.\n        If None uses the global default.\n\n    Returns\n    -------\n    Dataset, DataArray, Variable, dask.array.Array or numpy.ndarray, optional\n        In priority order: Dataset, DataArray, Variable, dask.array.Array or\n        numpy.ndarray, whichever type appears as an input argument.\n\n    Examples\n    --------\n\n    >>> import xarray as xr\n    >>> import numpy as np\n    >>> x = xr.DataArray(\n    ...     0.1 * np.arange(10),\n    ...     dims=[\"lat\"],\n    ...     coords={\"lat\": np.arange(10)},\n    ...     name=\"sst\",\n    ... )\n    >>> x\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> xr.where(x < 0.5, x, x * 100)\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> y = xr.DataArray(\n    ...     0.1 * np.arange(9).reshape(3, 3),\n    ...     dims=[\"lat\", \"lon\"],\n    ...     coords={\"lat\": np.arange(3), \"lon\": 10 + np.arange(3)},\n    ...     name=\"sst\",\n    ... )\n    >>> y\n    <xarray.DataArray 'sst' (lat: 3, lon: 3)>\n    array([[0. , 0.1, 0.2],\n           [0.3, 0.4, 0.5],\n           [0.6, 0.7, 0.8]])\n    Coordinates:\n      * lat      (lat) int64 0 1 2\n      * lon      (lon) int64 10 11 12\n\n    >>> xr.where(y.lat < 1, y, -1)\n    <xarray.DataArray (lat: 3, lon: 3)>\n    array([[ 0. ,  0.1,  0.2],\n           [-1. , -1. , -1. ],\n           [-1. , -1. , -1. ]])\n    Coordinates:\n      * lat      (lat) int64 0 1 2\n      * lon      (lon) int64 10 11 12\n\n    See Also\n    --------\n    numpy.where : corresponding numpy function\n    Dataset.where, DataArray.where :\n        equivalent methods\n    \"\"\"\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    return apply_ufunc(\n        duck_array_ops.where,\n        cond,\n        x,\n        y,\n        join=\"exact\",\n        dataset_join=\"exact\",\n        dask=\"allowed\",\n        keep_attrs=keep_attrs,\n    )\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n"
    ],
    "Location 2 (/root/hy/projects/xarray/xarray/core/computation.py lines 1811-1811)": [
      "\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n",
      "\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n",
      "\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n",
      "\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n",
      "\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n",
      "\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n",
      "\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n",
      "\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n"
    ],
    "Location 3 (/root/hy/projects/xarray/xarray/core/computation.py lines 1812-1820)": [
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n    \"\"\"Return elements from `x` or `y` depending on condition.\n\n    Performs xarray-like broadcasting across input arguments.\n\n    All dimension coordinates on `x` and `y`  must be aligned with each\n    other and with `cond`.\n\n    Parameters\n    ----------\n    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n        When True, return values from `x`, otherwise returns values from `y`.\n    x : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is True\n    y : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is False\n    keep_attrs : bool or None, optional\n        If True, the attributes (attrs) will be copied\n        from the first input to the new object.\n\n    Returns\n    -------\n    Dataset, DataArray, Variable or array\n        In priority order: Dataset, DataArray, Variable or array, whichever\n        type is encountered as an input argument.\n\n    Examples\n    --------\n\n    >>> import xarray as xr\n    >>> import numpy as np\n    >>> x = xr.DataArray(\n    ...     0.1 * np.arange(10),\n    ...     dims=[\"lat\"],\n    ...     coords={\"lat\": np.arange(10)},\n    ...     name=\"sst\",\n    ... )\n    >>> x\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> xr.where(x < 0.5, x, x * 100)\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> y = xr.DataArray(\n    ...     0.1 * np.arange(9).reshape(3, 3),\n    ...     dims=[\"x\", \"y\"],\n    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n    ...     name=\"sst\",\n    ... )\n    >>> y\n    <xarray.DataArray 'sst' (x: 3, y: 3)>\n    array([[0. , 0.1, 0.2],\n           [0.3, 0.4, 0.5],\n           [0.6, 0.7, 0.8]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> xr.where(y.x + y.y < 4, y, -1)\n    <xarray.DataArray (x: 3, y: 3)>\n    array([[ 0. ,  0.1,  0.2],\n           [ 0.3, -1. , -1. ],\n           [-1. , -1. , -1. ]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n    >>> xr.where(cond, x, 0)\n    <xarray.DataArray (x: 2, y: 2)>\n    array([[1, 2],\n           [0, 0]])\n    Dimensions without coordinates: x, y\n\n    See Also\n    --------\n    numpy.where : corresponding numpy function\n    Dataset.where, DataArray.where :\n        equivalent methods\n    \"\"\"\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    \n    return apply_ufunc(\n        duck_array_ops.where,\n        cond,\n        x,\n        y,\n        join=\"exact\",\n        dataset_join=\"exact\",\n        dask=\"allowed\",\n        keep_attrs=keep_attrs,\n    )\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n    \"\"\"Return elements from `x` or `y` depending on condition.\n\n    Performs xarray-like broadcasting across input arguments.\n\n    All dimension coordinates on `x` and `y`  must be aligned with each\n    other and with `cond`.\n\n    Parameters\n    ----------\n    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n        When True, return values from `x`, otherwise returns values from `y`.\n    x : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is True\n    y : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is False\n    keep_attrs : bool or None, optional\n        If True, the attributes (attrs) will be copied\n        from the first input to the new one.\n        If False, the new one will not have attributes.\n        If None uses the global default.\n\n    Returns\n    -------\n    Dataset, DataArray, Variable or array\n        In priority order: Dataset, DataArray, Variable or array, whichever\n        type appears as an input argument.\n\n    Examples\n    --------\n\n    >>> import xarray as xr\n    >>> import numpy as np\n    >>> x = xr.DataArray(\n    ...     0.1 * np.arange(10),\n    ...     dims=[\"lat\"],\n    ...     coords={\"lat\": np.arange(10)},\n    ...     name=\"sst\",\n    ... )\n    >>> x\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> xr.where(x < 0.5, x, x * 100)\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> y = xr.DataArray(\n    ...     0.1 * np.arange(9).reshape(3, 3),\n    ...     dims=[\"x\", \"y\"],\n    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n    ...     name=\"sst\",\n    ... )\n    >>> y\n    <xarray.DataArray 'sst' (x: 3, y: 3)>\n    array([[0. , 0.1, 0.2],\n           [0.3, 0.4, 0.5],\n           [0.6, 0.7, 0.8]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> xr.where(y.y < 11, y, -1)\n    <xarray.DataArray (x: 3, y: 3)>\n    array([[ 0. , -1. , -1. ],\n           [ 0.3, -1. , -1. ],\n           [ 0.6, -1. , -1. ]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n    >>> xr.where(cond, x, 0)\n    <xarray.DataArray (x: 2, y: 2)>\n    array([[1, 2],\n           [0, 0]])\n    Dimensions without coordinates: x, y\n\n    See Also\n    --------\n    numpy.where : corresponding numpy function\n    Dataset.where, DataArray.where :\n        equivalent methods\n    \"\"\"\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    return apply_ufunc(\n        duck_array_ops.where,\n        cond,\n        x,\n        y,\n        join=\"exact\",\n        dataset_join=\"exact\",\n        dask=\"allowed\",\n        keep_attrs=keep_attrs,\n    )\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n    \"\"\"Return elements from `x` or `y` depending on condition.\n\n    Performs xarray-like broadcasting across input arguments.\n\n    All dimension coordinates on these objects must be aligned with each\n    other and with the condition.\n\n    Parameters\n    ----------\n    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n        When True, return values from `x`, otherwise returns values from `y`.\n    x : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is True\n    y : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is False\n    keep_attrs : bool or None, optional\n        If True, the attributes (attrs) will be copied\n        from the first input to the new one.\n        If False, the new one will not have attributes.\n        If None uses the global default.\n\n    Returns\n    -------\n    Dataset, DataArray or Variable\n        In priority order: Dataset, DataArray, Variable.\n        Objects of the same type as the first of `x` or `y`.\n\n    Examples\n    --------\n\n    >>> import xarray as xr\n    >>> import numpy as np\n    >>> x = xr.DataArray(\n    ...     0.1 * np.arange(10),\n    ...     dims=[\"lat\"],\n    ...     coords={\"lat\": np.arange(10)},\n    ...     name=\"sst\",\n    ... )\n    >>> x\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> xr.where(x < 0.5, x, x * 100)\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> y = xr.DataArray(\n    ...     0.1 * np.arange(9).reshape(3, 3),\n    ...     dims=[\"lat\", \"lon\"],\n    ...     coords={\"lat\": np.arange(3), \"lon\": 10 + np.arange(3)},\n    ...     name=\"sst\",\n    ... )\n    >>> y\n    <xarray.DataArray 'sst' (lat: 3, lon: 3)>\n    array([[0. , 0.1, 0.2],\n           [0.3, 0.4, 0.5],\n           [0.6, 0.7, 0.8]])\n    Coordinates:\n      * lat      (lat) int64 0 1 2\n      * lon      (lon) int64 10 11 12\n\n    >>> xr.where(y.lat < 1, y, -1)\n    <xarray.DataArray (lat: 3, lon: 3)>\n    array([[ 0. ,  0.1,  0.2],\n           [-1. , -1. , -1. ],\n           [-1. , -1. , -1. ]])\n    Coordinates:\n      * lat      (lat) int64 0 1 2\n      * lon      (lon) int64 10 11 12\n\n    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n    >>> xr.where(cond, x, 0)\n    <xarray.DataArray (x: 2, y: 2)>\n    array([[1, 2],\n           [0, 0]])\n    Dimensions without coordinates: x, y\n\n    See Also\n    --------\n    numpy.where : corresponding numpy function\n    Dataset.where, DataArray.where :\n        equivalent methods\n    \"\"\"\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    \n    return apply_ufunc(\n        duck_array_ops.where,\n        cond,\n        x,\n        y,\n        join=\"exact\",\n        dataset_join=\"exact\",\n        dask=\"allowed\",\n        keep_attrs=keep_attrs,\n    )\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n    \"\"\"Return elements from `x` or `y` depending on `cond`.\n\n    Performs xarray-like broadcasting across input arguments.\n\n    All dimension coordinates on `x` and `y`  must be aligned with each\n    other and with `cond`.\n\n    Parameters\n    ----------\n    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n        When True, return values from `x`, otherwise returns values from `y`.\n    x : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is True\n    y : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is False\n    keep_attrs : bool or None, optional\n        If True, the attributes (attrs) will be copied\n        from the first input to the new one.\n        If False, the new one will not have attributes.\n        If None uses the global default.\n\n    Returns\n    -------\n    Dataset, DataArray, Variable or array\n        In priority order: Dataset, DataArray, Variable or array, whichever\n        type is encountered as an input argument.\n\n    Examples\n    --------\n\n    >>> import xarray as xr\n    >>> import numpy as np\n    >>> x = xr.DataArray(\n    ...     0.1 * np.arange(10),\n    ...     dims=[\"lat\"],\n    ...     coords={\"lat\": np.arange(10)},\n    ...     name=\"sst\",\n    ... )\n    >>> x\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> xr.where(x < 0.5, x, x * 100)\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> y = xr.DataArray(\n    ...     0.1 * np.arange(9).reshape(3, 3),\n    ...     dims=[\"x\", \"y\"],\n    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n    ...     name=\"sst\",\n    ... )\n    >>> y\n    <xarray.DataArray 'sst' (x: 3, y: 3)>\n    array([[0. , 0.1, 0.2],\n           [0.3, 0.4, 0.5],\n           [0.6, 0.7, 0.8]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> xr.where(y.x < 1, y, -1)\n    <xarray.DataArray (x: 3, y: 3)>\n    array([[ 0. ,  0.1,  0.2],\n           [-1. , -1. , -1. ],\n           [-1. , -1. , -1. ]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n    >>> xr.where(cond, x, 0)\n    <xarray.DataArray (x: 2, y: 2)>\n    array([[1, 2],\n           [0, 0]])\n    Dimensions without coordinates: x, y\n\n    See Also\n    --------\n    numpy.where : corresponding numpy function\n    Dataset.where, DataArray.where :\n        equivalent methods\n    \"\"\"\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    return apply_ufunc(\n        duck_array_ops.where,\n        cond,\n        x,\n        y,\n        join=\"exact\",\n        dataset_join=\"exact\",\n        dask=\"allowed\",\n        keep_attrs=keep_attrs,\n    )\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n    \"\"\"Return elements from `x` or `y` depending on condition.\n\n    Performs xarray-like broadcasting across input arguments.\n\n    All dimension coordinates on `x` and `y`  must be aligned with each\n    other and with `cond`.\n\n    Parameters\n    ----------\n    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n        When True, return values from `x`, otherwise returns values from `y`.\n    x : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is True\n    y : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is False\n    keep_attrs : bool, optional\n        If True, the attributes (attrs) will be copied from the first input to the new one.\n        If False (default), the new one will not copy attributes from any of the inputs.\n\n    Returns\n    -------\n    Dataset, DataArray or Variable\n        In priority order: Dataset, DataArray, Variable.\n        Objects of the same type as the first of `x` or `y`.\n\n    Examples\n    --------\n\n    >>> import xarray as xr\n    >>> import numpy as np\n    >>> x = xr.DataArray(\n    ...     0.1 * np.arange(10),\n    ...     dims=[\"lat\"],\n    ...     coords={\"lat\": np.arange(10)},\n    ...     name=\"sst\",\n    ... )\n    >>> x\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> xr.where(x < 0.5, x, x * 100)\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> y = xr.DataArray(\n    ...     0.1 * np.arange(9).reshape(3, 3),\n    ...     dims=[\"x\", \"y\"],\n    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n    ...     name=\"sst\",\n    ... )\n    >>> y\n    <xarray.DataArray 'sst' (x: 3, y: 3)>\n    array([[0. , 0.1, 0.2],\n           [0.3, 0.4, 0.5],\n           [0.6, 0.7, 0.8]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> xr.where(y.x < 1, y, -1)\n    <xarray.DataArray (x: 3, y: 3)>\n    array([[ 0. ,  0.1,  0.2],\n           [-1. , -1. , -1. ],\n           [-1. , -1. , -1. ]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n    >>> xr.where(cond, x, 0)\n    <xarray.DataArray (x: 2, y: 2)>\n    array([[1, 2],\n           [0, 0]])\n    Dimensions without coordinates: x, y\n\n    See Also\n    --------\n    numpy.where : corresponding numpy function\n    Dataset.where, DataArray.where :\n        equivalent methods\n    \"\"\"\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    return apply_ufunc(\n        duck_array_ops.where,\n        cond,\n        x,\n        y,\n        join=\"exact\",\n        dataset_join=\"exact\",\n        dask=\"allowed\",\n        keep_attrs=keep_attrs,\n    )\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n    \"\"\"Return elements from `x` or `y` depending on condition.\n\n    Performs xarray-like broadcasting across input arguments.\n\n    All dimension coordinates on these objects must be aligned with each\n    other and with the condition.\n\n    Parameters\n    ----------\n    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n        When True, return values from `x`, otherwise returns values from `y`.\n    x : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is True\n    y : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is False\n    keep_attrs : bool, optional\n        If True, the attributes (attrs) will be copied from the first input to the new one.\n        If False (default), the new one will not copy attributes.\n\n    Returns\n    -------\n    Dataset, DataArray, Variable or array\n        In priority order: Dataset, DataArray, Variable, array, in that order.\n\n    Examples\n    --------\n\n    >>> import numpy as np\n    >>> import xarray as xr\n    >>> x = xr.DataArray(\n    ...     0.1 * np.arange(10),\n    ...     dims=[\"lat\"],\n    ...     coords={\"lat\": np.arange(10)},\n    ...     name=\"sst\",\n    ... )\n    >>> x\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> xr.where(x < 0.5, x, x * 100)\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> y = xr.DataArray(\n    ...     0.1 * np.arange(9).reshape(3, 3),\n    ...     dims=[\"x\", \"y\"],\n    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n    ...     name=\"sst\",\n    ... )\n    >>> y\n    <xarray.DataArray 'sst' (x: 3, y: 3)>\n    array([[0. , 0.1, 0.2],\n           [0.3, 0.4, 0.5],\n           [0.6, 0.7, 0.8]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> xr.where(y.x + y.y < 4, y, -1)\n    <xarray.DataArray (x: 3, y: 3)>\n    array([[ 0. ,  0.1,  0.2],\n           [ 0.3, -1. , -1. ],\n           [-1. , -1. , -1. ]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n    >>> xr.where(cond, x, 0)\n    <xarray.DataArray (x: 2, y: 2)>\n    array([[1, 2],\n           [0, 0]])\n    Dimensions without coordinates: x, y\n\n    See Also\n    --------\n    numpy.where : corresponding numpy function\n    Dataset.where, DataArray.where :\n        equivalent methods\n    \"\"\"\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    return apply_ufunc(\n        duck_array_ops.where,\n        cond,\n        x,\n        y,\n        join=\"exact\",\n        dataset_join=\"exact\",\n        dask=\"allowed\",\n        keep_attrs=keep_attrs,\n    )\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n    \"\"\"Return elements from `x` or `y` depending on condition.\n\n    Performs xarray-like broadcasting across input arguments.\n\n    All dimension coordinates on `x` and `y`  must be aligned with each\n    other and with `cond`.\n\n    Parameters\n    ----------\n    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n        When True, return values from `x`, otherwise returns values from `y`.\n    x : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is True\n    y : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is False\n    keep_attrs : bool, optional\n        If True, the attributes (attrs) will be copied from the first input to the new one.\n        If False, the new one will be returned without attributes.\n        If None uses the global default.\n\n    Returns\n    -------\n    Dataset, DataArray, Variable or array\n        In priority order: Dataset, DataArray, Variable or array, whichever\n        type is encountered as input.\n\n    Examples\n    --------\n\n    >>> import xarray as xr\n    >>> import numpy as np\n    >>> x = xr.DataArray(\n    ...     0.1 * np.arange(10),\n    ...     dims=[\"lat\"],\n    ...     coords={\"lat\": np.arange(10)},\n    ...     name=\"sst\",\n    ... )\n    >>> x\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> xr.where(x < 0.5, x, x * 100)\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> y = xr.DataArray(\n    ...     0.1 * np.arange(9).reshape(3, 3),\n    ...     dims=[\"x\", \"y\"],\n    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n    ...     name=\"var\",\n    ... )\n    >>> y\n    <xarray.DataArray 'var' (x: 3, y: 3)>\n    array([[0. , 0.1, 0.2],\n           [0.3, 0.4, 0.5],\n           [0.6, 0.7, 0.8]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> xr.where(y.x + y.y < 4, y, -1)\n    <xarray.DataArray (x: 3, y: 3)>\n    array([[ 0. ,  0.1,  0.2],\n           [ 0.3, -1. , -1. ],\n           [-1. , -1. , -1. ]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n    >>> xr.where(cond, x, 0)\n    <xarray.DataArray (x: 2, y: 2)>\n    array([[1, 2],\n           [0, 0]])\n    Dimensions without coordinates: x, y\n\n    See Also\n    --------\n    numpy.where : corresponding numpy function\n    Dataset.where, DataArray.where :\n        equivalent methods\n    \"\"\"\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    return apply_ufunc(\n        duck_array_ops.where,\n        cond,\n        x,\n        y,\n        join=\"exact\",\n        dataset_join=\"exact\",\n        dask=\"allowed\",\n        keep_attrs=keep_attrs,\n    )\n",
      "\ndef where(cond, x, y, keep_attrs: bool = None):\n    \"\"\"Return elements from `x` or `y` depending on condition.\n\n    Performs xarray-like broadcasting across input arguments.\n\n    All dimension coordinates on these objects must be aligned with each\n    other and with the condition.\n\n    Parameters\n    ----------\n    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n        When True, return values from `x`, otherwise returns values from `y`.\n    x : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is True\n    y : scalar, array, Variable, DataArray or Dataset\n        values to choose from where `cond` is False\n    keep_attrs : bool, optional\n        If True, the attributes (attrs) will be copied\n        from the first input to the new one. If False (default), the new\n        object will be returned without attributes.\n\n    Returns\n    -------\n    Dataset, DataArray or Variable\n        In priority order: Dataset, DataArray, Variable.\n        Objects of the same type as the first input.\n\n    Examples\n    --------\n\n    >>> import numpy as np\n    >>> import xarray as xr\n    >>> x = xr.DataArray(\n    ...     0.1 * np.arange(10),\n    ...     dims=[\"lat\"],\n    ...     coords={\"lat\": np.arange(10)},\n    ...     name=\"sst\",\n    ... )\n    >>> x\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> xr.where(x < 0.5, x, x * 100)\n    <xarray.DataArray 'sst' (lat: 10)>\n    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n    Coordinates:\n      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n\n    >>> y = xr.DataArray(\n    ...     0.1 * np.arange(9).reshape(3, 3),\n    ...     dims=[\"x\", \"y\"],\n    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n    ...     name=\"sst\",\n    ... )\n    >>> y\n    <xarray.DataArray 'sst' (x: 3, y: 3)>\n    array([[0. , 0.1, 0.2],\n           [0.3, 0.4, 0.5],\n           [0.6, 0.7, 0.8]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> xr.where(y.y < 11, y, -1)\n    <xarray.DataArray (x: 3, y: 3)>\n    array([[ 0. , -1. , -1. ],\n           [ 0.3, -1. , -1. ],\n           [ 0.6, -1. , -1. ]])\n    Coordinates:\n      * x        (x) int64 0 1 2\n      * y        (y) int64 10 11 12\n\n    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n    >>> xr.where(cond, x, 0)\n    <xarray.DataArray (x: 2, y: 2)>\n    array([[1, 2],\n           [0, 0]])\n    Dimensions without coordinates: x, y\n\n    See Also\n    --------\n    numpy.where : corresponding numpy function\n    Dataset.where, DataArray.where :\n        equivalent methods\n    \"\"\"\n    # alignment for three arguments is complicated, so don't support it yet\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    return apply_ufunc(\n        duck_array_ops.where,\n        cond,\n        x,\n        y,\n        join=\"exact\",\n        dataset_join=\"exact\",\n        dask=\"allowed\",\n        keep_attrs=keep_attrs,\n    )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..f770abfa 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,8 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1808,7 +1809,11 @@ def where(cond, x, y):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+\n     # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+\n     return apply_ufunc(\n         duck_array_ops.where,\n         cond,\n@@ -1817,6 +1822,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \n",
    "variant_0": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..755c3ca2 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,8 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1802,6 +1803,99 @@ def where(cond, x, y):\n            [0, 0]])\n     Dimensions without coordinates: x, y\n \n+    See Also\n+    --------\n+    numpy.where : corresponding numpy function\n+    Dataset.where, DataArray.where :\n+        equivalent methods\n+    \"\"\"\n+\n+    # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n+    \"\"\"Return elements from `x` or `y` depending on condition.\n+\n+    Performs xarray-like broadcasting across input arguments.\n+\n+    All dimension coordinates on `x` and `y`  must be aligned with each\n+    other and with `cond`.\n+\n+    Parameters\n+    ----------\n+    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n+        When True, return values from `x`, otherwise returns values from `y`.\n+    x : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is True\n+    y : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is False\n+    keep_attrs : bool or None, optional\n+        If True, the attributes (attrs) will be copied\n+        from the first input to the new one.\n+        If False, the new one will not have attributes.\n+        If None uses the global default.\n+\n+    Returns\n+    -------\n+    Dataset, DataArray, Variable or array\n+        In priority order: Dataset, DataArray, Variable, array.\n+\n+    Examples\n+    --------\n+\n+    >>> import numpy as np\n+    >>> import xarray as xr\n+    >>> x = xr.DataArray(\n+    ...     0.1 * np.arange(10),\n+    ...     dims=[\"lat\"],\n+    ...     coords={\"lat\": np.arange(10)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> x\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> xr.where(x < 0.5, x, x * 100)\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> y = xr.DataArray(\n+    ...     0.1 * np.arange(9).reshape(3, 3),\n+    ...     dims=[\"x\", \"y\"],\n+    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> y\n+    <xarray.DataArray 'sst' (x: 3, y: 3)>\n+    array([[0. , 0.1, 0.2],\n+           [0.3, 0.4, 0.5],\n+           [0.6, 0.7, 0.8]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> xr.where(y.x + y.y < 4, y, -1)\n+    <xarray.DataArray (x: 3, y: 3)>\n+    array([[ 0. ,  0.1,  0.2],\n+           [ 0.3, -1. , -1. ],\n+           [-1. , -1. , -1. ]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n+    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n+    >>> xr.where(cond, x, 0)\n+    <xarray.DataArray (x: 2, y: 2)>\n+    array([[1, 2],\n+           [0, 0]])\n+    Dimensions without coordinates: x, y\n+\n     See Also\n     --------\n     numpy.where : corresponding numpy function\n@@ -1809,6 +1903,9 @@ def where(cond, x, y):\n         equivalent methods\n     \"\"\"\n     # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+    \n     return apply_ufunc(\n         duck_array_ops.where,\n         cond,\n@@ -1817,6 +1914,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \n",
    "variant_1": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..3aebc822 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,8 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1808,7 +1809,102 @@ def where(cond, x, y):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+\n     # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n+    \"\"\"Return elements from `x` or `y` depending on condition.\n+\n+    Performs xarray-like broadcasting across input arguments.\n+\n+    All dimension coordinates on `x` and `y`  must be aligned with each\n+    other and with `cond`.\n+\n+    Parameters\n+    ----------\n+    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n+        When True, return values from `x`, otherwise returns values from `y`.\n+    x : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is True\n+    y : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is False\n+    keep_attrs : bool or None, optional\n+        If True, the attributes (attrs) will be copied\n+        from the first input to the new object.\n+\n+    Returns\n+    -------\n+    Dataset, DataArray, Variable or array\n+        In priority order: Dataset, DataArray, Variable or array, whichever\n+        type is encountered as an input argument.\n+\n+    Examples\n+    --------\n+\n+    >>> import xarray as xr\n+    >>> import numpy as np\n+    >>> x = xr.DataArray(\n+    ...     0.1 * np.arange(10),\n+    ...     dims=[\"lat\"],\n+    ...     coords={\"lat\": np.arange(10)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> x\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> xr.where(x < 0.5, x, x * 100)\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> y = xr.DataArray(\n+    ...     0.1 * np.arange(9).reshape(3, 3),\n+    ...     dims=[\"x\", \"y\"],\n+    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> y\n+    <xarray.DataArray 'sst' (x: 3, y: 3)>\n+    array([[0. , 0.1, 0.2],\n+           [0.3, 0.4, 0.5],\n+           [0.6, 0.7, 0.8]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> xr.where(y.x + y.y < 4, y, -1)\n+    <xarray.DataArray (x: 3, y: 3)>\n+    array([[ 0. ,  0.1,  0.2],\n+           [ 0.3, -1. , -1. ],\n+           [-1. , -1. , -1. ]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n+    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n+    >>> xr.where(cond, x, 0)\n+    <xarray.DataArray (x: 2, y: 2)>\n+    array([[1, 2],\n+           [0, 0]])\n+    Dimensions without coordinates: x, y\n+\n+    See Also\n+    --------\n+    numpy.where : corresponding numpy function\n+    Dataset.where, DataArray.where :\n+        equivalent methods\n+    \"\"\"\n+    # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+    \n     return apply_ufunc(\n         duck_array_ops.where,\n         cond,\n@@ -1817,6 +1913,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \n",
    "variant_2": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..29921b01 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,8 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1808,7 +1809,103 @@ def where(cond, x, y):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+\n     # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n+    \"\"\"Return elements from `x` or `y` depending on condition.\n+\n+    Performs xarray-like broadcasting across input arguments.\n+\n+    All dimension coordinates on `x` and `y`  must be aligned with each\n+    other and with `cond`.\n+\n+    Parameters\n+    ----------\n+    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n+        When True, return values from `x`, otherwise returns values from `y`.\n+    x : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is True\n+    y : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is False\n+    keep_attrs : bool or None, optional\n+        If True, the attributes (attrs) will be copied\n+        from the first input to the new one.\n+        If False, the new one will not have attributes.\n+        If None uses the global default.\n+\n+    Returns\n+    -------\n+    Dataset, DataArray, Variable or array\n+        In priority order: Dataset, DataArray, Variable or array, whichever\n+        type appears as an input argument.\n+\n+    Examples\n+    --------\n+\n+    >>> import xarray as xr\n+    >>> import numpy as np\n+    >>> x = xr.DataArray(\n+    ...     0.1 * np.arange(10),\n+    ...     dims=[\"lat\"],\n+    ...     coords={\"lat\": np.arange(10)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> x\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> xr.where(x < 0.5, x, x * 100)\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> y = xr.DataArray(\n+    ...     0.1 * np.arange(9).reshape(3, 3),\n+    ...     dims=[\"x\", \"y\"],\n+    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> y\n+    <xarray.DataArray 'sst' (x: 3, y: 3)>\n+    array([[0. , 0.1, 0.2],\n+           [0.3, 0.4, 0.5],\n+           [0.6, 0.7, 0.8]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> xr.where(y.y < 11, y, -1)\n+    <xarray.DataArray (x: 3, y: 3)>\n+    array([[ 0. , -1. , -1. ],\n+           [ 0.3, -1. , -1. ],\n+           [ 0.6, -1. , -1. ]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n+    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n+    >>> xr.where(cond, x, 0)\n+    <xarray.DataArray (x: 2, y: 2)>\n+    array([[1, 2],\n+           [0, 0]])\n+    Dimensions without coordinates: x, y\n+\n+    See Also\n+    --------\n+    numpy.where : corresponding numpy function\n+    Dataset.where, DataArray.where :\n+        equivalent methods\n+    \"\"\"\n+    # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n     return apply_ufunc(\n         duck_array_ops.where,\n         cond,\n@@ -1817,6 +1914,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \n",
    "variant_3": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..6a4685f6 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,8 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1808,7 +1809,104 @@ def where(cond, x, y):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+\n     # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n+    \"\"\"Return elements from `x` or `y` depending on condition.\n+\n+    Performs xarray-like broadcasting across input arguments.\n+\n+    All dimension coordinates on these objects must be aligned with each\n+    other and with the condition.\n+\n+    Parameters\n+    ----------\n+    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n+        When True, return values from `x`, otherwise returns values from `y`.\n+    x : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is True\n+    y : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is False\n+    keep_attrs : bool or None, optional\n+        If True, the attributes (attrs) will be copied\n+        from the first input to the new one.\n+        If False, the new one will not have attributes.\n+        If None uses the global default.\n+\n+    Returns\n+    -------\n+    Dataset, DataArray or Variable\n+        In priority order: Dataset, DataArray, Variable.\n+        Objects of the same type as the first of `x` or `y`.\n+\n+    Examples\n+    --------\n+\n+    >>> import xarray as xr\n+    >>> import numpy as np\n+    >>> x = xr.DataArray(\n+    ...     0.1 * np.arange(10),\n+    ...     dims=[\"lat\"],\n+    ...     coords={\"lat\": np.arange(10)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> x\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> xr.where(x < 0.5, x, x * 100)\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> y = xr.DataArray(\n+    ...     0.1 * np.arange(9).reshape(3, 3),\n+    ...     dims=[\"lat\", \"lon\"],\n+    ...     coords={\"lat\": np.arange(3), \"lon\": 10 + np.arange(3)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> y\n+    <xarray.DataArray 'sst' (lat: 3, lon: 3)>\n+    array([[0. , 0.1, 0.2],\n+           [0.3, 0.4, 0.5],\n+           [0.6, 0.7, 0.8]])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2\n+      * lon      (lon) int64 10 11 12\n+\n+    >>> xr.where(y.lat < 1, y, -1)\n+    <xarray.DataArray (lat: 3, lon: 3)>\n+    array([[ 0. ,  0.1,  0.2],\n+           [-1. , -1. , -1. ],\n+           [-1. , -1. , -1. ]])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2\n+      * lon      (lon) int64 10 11 12\n+\n+    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n+    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n+    >>> xr.where(cond, x, 0)\n+    <xarray.DataArray (x: 2, y: 2)>\n+    array([[1, 2],\n+           [0, 0]])\n+    Dimensions without coordinates: x, y\n+\n+    See Also\n+    --------\n+    numpy.where : corresponding numpy function\n+    Dataset.where, DataArray.where :\n+        equivalent methods\n+    \"\"\"\n+    # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+    \n     return apply_ufunc(\n         duck_array_ops.where,\n         cond,\n@@ -1817,6 +1915,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \n",
    "variant_4": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..544264c1 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,8 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1808,7 +1809,103 @@ def where(cond, x, y):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+\n     # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n+    \"\"\"Return elements from `x` or `y` depending on `cond`.\n+\n+    Performs xarray-like broadcasting across input arguments.\n+\n+    All dimension coordinates on `x` and `y`  must be aligned with each\n+    other and with `cond`.\n+\n+    Parameters\n+    ----------\n+    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n+        When True, return values from `x`, otherwise returns values from `y`.\n+    x : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is True\n+    y : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is False\n+    keep_attrs : bool or None, optional\n+        If True, the attributes (attrs) will be copied\n+        from the first input to the new one.\n+        If False, the new one will not have attributes.\n+        If None uses the global default.\n+\n+    Returns\n+    -------\n+    Dataset, DataArray, Variable or array\n+        In priority order: Dataset, DataArray, Variable or array, whichever\n+        type is encountered as an input argument.\n+\n+    Examples\n+    --------\n+\n+    >>> import xarray as xr\n+    >>> import numpy as np\n+    >>> x = xr.DataArray(\n+    ...     0.1 * np.arange(10),\n+    ...     dims=[\"lat\"],\n+    ...     coords={\"lat\": np.arange(10)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> x\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> xr.where(x < 0.5, x, x * 100)\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> y = xr.DataArray(\n+    ...     0.1 * np.arange(9).reshape(3, 3),\n+    ...     dims=[\"x\", \"y\"],\n+    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> y\n+    <xarray.DataArray 'sst' (x: 3, y: 3)>\n+    array([[0. , 0.1, 0.2],\n+           [0.3, 0.4, 0.5],\n+           [0.6, 0.7, 0.8]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> xr.where(y.x < 1, y, -1)\n+    <xarray.DataArray (x: 3, y: 3)>\n+    array([[ 0. ,  0.1,  0.2],\n+           [-1. , -1. , -1. ],\n+           [-1. , -1. , -1. ]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n+    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n+    >>> xr.where(cond, x, 0)\n+    <xarray.DataArray (x: 2, y: 2)>\n+    array([[1, 2],\n+           [0, 0]])\n+    Dimensions without coordinates: x, y\n+\n+    See Also\n+    --------\n+    numpy.where : corresponding numpy function\n+    Dataset.where, DataArray.where :\n+        equivalent methods\n+    \"\"\"\n+    # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n     return apply_ufunc(\n         duck_array_ops.where,\n         cond,\n@@ -1817,6 +1914,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \n",
    "variant_5": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..2f99f0b6 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,102 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n+    \"\"\"Return elements from `x` or `y` depending on `cond`.\n+\n+    Performs xarray-like broadcasting across input arguments.\n+\n+    All dimension coordinates on `x` and `y`  must be aligned with each\n+    other and with `cond`.\n+\n+    Parameters\n+    ----------\n+    cond : scalar, array, Variable, DataArray or Dataset\n+        Locations at which to preserve this object's values. dtype must be `bool`.\n+        If a Dataset, it must have a single data variable.\n+    x : scalar, array, Variable, DataArray or Dataset\n+        values to use where `cond` is True\n+    y : scalar, array, Variable, DataArray or Dataset\n+        values to use where `cond` is False\n+    keep_attrs : bool or None, optional\n+        If True, the attributes (attrs) will be copied\n+        from the first input to the new one.\n+        If False, the new one will not copy attributes from the first input.\n+        If None uses the global default.\n+\n+    Returns\n+    -------\n+    Dataset, DataArray, Variable, dask.array.Array or numpy.ndarray, optional\n+        In priority order: Dataset, DataArray, Variable, dask.array.Array or\n+        numpy.ndarray, whichever type appears as an input argument.\n+\n+    Examples\n+    --------\n+\n+    >>> import xarray as xr\n+    >>> import numpy as np\n+    >>> x = xr.DataArray(\n+    ...     0.1 * np.arange(10),\n+    ...     dims=[\"lat\"],\n+    ...     coords={\"lat\": np.arange(10)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> x\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> xr.where(x < 0.5, x, x * 100)\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> y = xr.DataArray(\n+    ...     0.1 * np.arange(9).reshape(3, 3),\n+    ...     dims=[\"lat\", \"lon\"],\n+    ...     coords={\"lat\": np.arange(3), \"lon\": 10 + np.arange(3)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> y\n+    <xarray.DataArray 'sst' (lat: 3, lon: 3)>\n+    array([[0. , 0.1, 0.2],\n+           [0.3, 0.4, 0.5],\n+           [0.6, 0.7, 0.8]])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2\n+      * lon      (lon) int64 10 11 12\n+\n+    >>> xr.where(y.lat < 1, y, -1)\n+    <xarray.DataArray (lat: 3, lon: 3)>\n+    array([[ 0. ,  0.1,  0.2],\n+           [-1. , -1. , -1. ],\n+           [-1. , -1. , -1. ]])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2\n+      * lon      (lon) int64 10 11 12\n+\n+    See Also\n+    --------\n+    numpy.where : corresponding numpy function\n+    Dataset.where, DataArray.where :\n+        equivalent methods\n+    \"\"\"\n+    # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+    return apply_ufunc(\n+        duck_array_ops.where,\n+        cond,\n+        x,\n+        y,\n+        join=\"exact\",\n+        dataset_join=\"exact\",\n+        dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n+    )\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1808,7 +1903,101 @@ def where(cond, x, y):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+\n     # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n+    \"\"\"Return elements from `x` or `y` depending on condition.\n+\n+    Performs xarray-like broadcasting across input arguments.\n+\n+    All dimension coordinates on `x` and `y`  must be aligned with each\n+    other and with `cond`.\n+\n+    Parameters\n+    ----------\n+    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n+        When True, return values from `x`, otherwise returns values from `y`.\n+    x : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is True\n+    y : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is False\n+    keep_attrs : bool, optional\n+        If True, the attributes (attrs) will be copied from the first input to the new one.\n+        If False (default), the new one will not copy attributes from any of the inputs.\n+\n+    Returns\n+    -------\n+    Dataset, DataArray or Variable\n+        In priority order: Dataset, DataArray, Variable.\n+        Objects of the same type as the first of `x` or `y`.\n+\n+    Examples\n+    --------\n+\n+    >>> import xarray as xr\n+    >>> import numpy as np\n+    >>> x = xr.DataArray(\n+    ...     0.1 * np.arange(10),\n+    ...     dims=[\"lat\"],\n+    ...     coords={\"lat\": np.arange(10)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> x\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> xr.where(x < 0.5, x, x * 100)\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> y = xr.DataArray(\n+    ...     0.1 * np.arange(9).reshape(3, 3),\n+    ...     dims=[\"x\", \"y\"],\n+    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> y\n+    <xarray.DataArray 'sst' (x: 3, y: 3)>\n+    array([[0. , 0.1, 0.2],\n+           [0.3, 0.4, 0.5],\n+           [0.6, 0.7, 0.8]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> xr.where(y.x < 1, y, -1)\n+    <xarray.DataArray (x: 3, y: 3)>\n+    array([[ 0. ,  0.1,  0.2],\n+           [-1. , -1. , -1. ],\n+           [-1. , -1. , -1. ]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n+    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n+    >>> xr.where(cond, x, 0)\n+    <xarray.DataArray (x: 2, y: 2)>\n+    array([[1, 2],\n+           [0, 0]])\n+    Dimensions without coordinates: x, y\n+\n+    See Also\n+    --------\n+    numpy.where : corresponding numpy function\n+    Dataset.where, DataArray.where :\n+        equivalent methods\n+    \"\"\"\n+    # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n     return apply_ufunc(\n         duck_array_ops.where,\n         cond,\n@@ -1817,6 +2006,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \n",
    "variant_6": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..043dba14 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,8 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1808,7 +1809,100 @@ def where(cond, x, y):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+\n     # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n+    \"\"\"Return elements from `x` or `y` depending on condition.\n+\n+    Performs xarray-like broadcasting across input arguments.\n+\n+    All dimension coordinates on these objects must be aligned with each\n+    other and with the condition.\n+\n+    Parameters\n+    ----------\n+    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n+        When True, return values from `x`, otherwise returns values from `y`.\n+    x : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is True\n+    y : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is False\n+    keep_attrs : bool, optional\n+        If True, the attributes (attrs) will be copied from the first input to the new one.\n+        If False (default), the new one will not copy attributes.\n+\n+    Returns\n+    -------\n+    Dataset, DataArray, Variable or array\n+        In priority order: Dataset, DataArray, Variable, array, in that order.\n+\n+    Examples\n+    --------\n+\n+    >>> import numpy as np\n+    >>> import xarray as xr\n+    >>> x = xr.DataArray(\n+    ...     0.1 * np.arange(10),\n+    ...     dims=[\"lat\"],\n+    ...     coords={\"lat\": np.arange(10)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> x\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> xr.where(x < 0.5, x, x * 100)\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> y = xr.DataArray(\n+    ...     0.1 * np.arange(9).reshape(3, 3),\n+    ...     dims=[\"x\", \"y\"],\n+    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> y\n+    <xarray.DataArray 'sst' (x: 3, y: 3)>\n+    array([[0. , 0.1, 0.2],\n+           [0.3, 0.4, 0.5],\n+           [0.6, 0.7, 0.8]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> xr.where(y.x + y.y < 4, y, -1)\n+    <xarray.DataArray (x: 3, y: 3)>\n+    array([[ 0. ,  0.1,  0.2],\n+           [ 0.3, -1. , -1. ],\n+           [-1. , -1. , -1. ]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n+    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n+    >>> xr.where(cond, x, 0)\n+    <xarray.DataArray (x: 2, y: 2)>\n+    array([[1, 2],\n+           [0, 0]])\n+    Dimensions without coordinates: x, y\n+\n+    See Also\n+    --------\n+    numpy.where : corresponding numpy function\n+    Dataset.where, DataArray.where :\n+        equivalent methods\n+    \"\"\"\n+    # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n     return apply_ufunc(\n         duck_array_ops.where,\n         cond,\n@@ -1817,6 +1911,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \n",
    "variant_7": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..c5128d16 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,8 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1808,7 +1809,102 @@ def where(cond, x, y):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+\n     # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n+    \"\"\"Return elements from `x` or `y` depending on condition.\n+\n+    Performs xarray-like broadcasting across input arguments.\n+\n+    All dimension coordinates on `x` and `y`  must be aligned with each\n+    other and with `cond`.\n+\n+    Parameters\n+    ----------\n+    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n+        When True, return values from `x`, otherwise returns values from `y`.\n+    x : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is True\n+    y : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is False\n+    keep_attrs : bool, optional\n+        If True, the attributes (attrs) will be copied from the first input to the new one.\n+        If False, the new one will be returned without attributes.\n+        If None uses the global default.\n+\n+    Returns\n+    -------\n+    Dataset, DataArray, Variable or array\n+        In priority order: Dataset, DataArray, Variable or array, whichever\n+        type is encountered as input.\n+\n+    Examples\n+    --------\n+\n+    >>> import xarray as xr\n+    >>> import numpy as np\n+    >>> x = xr.DataArray(\n+    ...     0.1 * np.arange(10),\n+    ...     dims=[\"lat\"],\n+    ...     coords={\"lat\": np.arange(10)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> x\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> xr.where(x < 0.5, x, x * 100)\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> y = xr.DataArray(\n+    ...     0.1 * np.arange(9).reshape(3, 3),\n+    ...     dims=[\"x\", \"y\"],\n+    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n+    ...     name=\"var\",\n+    ... )\n+    >>> y\n+    <xarray.DataArray 'var' (x: 3, y: 3)>\n+    array([[0. , 0.1, 0.2],\n+           [0.3, 0.4, 0.5],\n+           [0.6, 0.7, 0.8]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> xr.where(y.x + y.y < 4, y, -1)\n+    <xarray.DataArray (x: 3, y: 3)>\n+    array([[ 0. ,  0.1,  0.2],\n+           [ 0.3, -1. , -1. ],\n+           [-1. , -1. , -1. ]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n+    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n+    >>> xr.where(cond, x, 0)\n+    <xarray.DataArray (x: 2, y: 2)>\n+    array([[1, 2],\n+           [0, 0]])\n+    Dimensions without coordinates: x, y\n+\n+    See Also\n+    --------\n+    numpy.where : corresponding numpy function\n+    Dataset.where, DataArray.where :\n+        equivalent methods\n+    \"\"\"\n+    # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n     return apply_ufunc(\n         duck_array_ops.where,\n         cond,\n@@ -1817,6 +1913,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \n",
    "variant_8": "diff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..f4505ca3 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,8 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1808,7 +1809,102 @@ def where(cond, x, y):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+\n     # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n+\n+def where(cond, x, y, keep_attrs: bool = None):\n+    \"\"\"Return elements from `x` or `y` depending on condition.\n+\n+    Performs xarray-like broadcasting across input arguments.\n+\n+    All dimension coordinates on these objects must be aligned with each\n+    other and with the condition.\n+\n+    Parameters\n+    ----------\n+    cond : scalar, array, Variable, DataArray or Dataset with boolean dtype\n+        When True, return values from `x`, otherwise returns values from `y`.\n+    x : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is True\n+    y : scalar, array, Variable, DataArray or Dataset\n+        values to choose from where `cond` is False\n+    keep_attrs : bool, optional\n+        If True, the attributes (attrs) will be copied\n+        from the first input to the new one. If False (default), the new\n+        object will be returned without attributes.\n+\n+    Returns\n+    -------\n+    Dataset, DataArray or Variable\n+        In priority order: Dataset, DataArray, Variable.\n+        Objects of the same type as the first input.\n+\n+    Examples\n+    --------\n+\n+    >>> import numpy as np\n+    >>> import xarray as xr\n+    >>> x = xr.DataArray(\n+    ...     0.1 * np.arange(10),\n+    ...     dims=[\"lat\"],\n+    ...     coords={\"lat\": np.arange(10)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> x\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> xr.where(x < 0.5, x, x * 100)\n+    <xarray.DataArray 'sst' (lat: 10)>\n+    array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n+    Coordinates:\n+      * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n+\n+    >>> y = xr.DataArray(\n+    ...     0.1 * np.arange(9).reshape(3, 3),\n+    ...     dims=[\"x\", \"y\"],\n+    ...     coords={\"x\": np.arange(3), \"y\": 10 + np.arange(3)},\n+    ...     name=\"sst\",\n+    ... )\n+    >>> y\n+    <xarray.DataArray 'sst' (x: 3, y: 3)>\n+    array([[0. , 0.1, 0.2],\n+           [0.3, 0.4, 0.5],\n+           [0.6, 0.7, 0.8]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> xr.where(y.y < 11, y, -1)\n+    <xarray.DataArray (x: 3, y: 3)>\n+    array([[ 0. , -1. , -1. ],\n+           [ 0.3, -1. , -1. ],\n+           [ 0.6, -1. , -1. ]])\n+    Coordinates:\n+      * x        (x) int64 0 1 2\n+      * y        (y) int64 10 11 12\n+\n+    >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n+    >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n+    >>> xr.where(cond, x, 0)\n+    <xarray.DataArray (x: 2, y: 2)>\n+    array([[1, 2],\n+           [0, 0]])\n+    Dimensions without coordinates: x, y\n+\n+    See Also\n+    --------\n+    numpy.where : corresponding numpy function\n+    Dataset.where, DataArray.where :\n+        equivalent methods\n+    \"\"\"\n+    # alignment for three arguments is complicated, so don't support it yet\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=True)\n     return apply_ufunc(\n         duck_array_ops.where,\n         cond,\n@@ -1817,6 +1913,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \n"
  }
}