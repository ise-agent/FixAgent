{
  "zero_patches": {
    "Location 1 (/root/hy/projects/pytest/src/_pytest/mark/structures.py lines 358-363)": "\ndef get_unpacked_marks(obj: object) -> Iterable[Mark]:\n    \"\"\"Obtain the unpacked marks that are stored on an object.\n    \n    When the object is a class with multiple inheritance, this function\n    will collect pytestmark from all base classes in the MRO to ensure\n    markers from all parent classes are preserved.\n    \"\"\"\n    mark_list = []\n    \n    # Handle both class objects and instances\n    if hasattr(obj, '__mro__'):\n        # obj is a class\n        mro = obj.__mro__\n    elif hasattr(obj, '__class__'):\n        # obj is an instance, get MRO from its class\n        mro = obj.__class__.__mro__\n    else:\n        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n        mro = [type(obj)]\n    \n    # Collect pytestmark from all classes in MRO\n    for cls in mro:\n        if hasattr(cls, 'pytestmark'):\n            cls_marks = getattr(cls, 'pytestmark', [])\n            if not isinstance(cls_marks, list):\n                cls_marks = [cls_marks]\n            mark_list.extend(cls_marks)\n    \n    # If no marks found in MRO, fall back to direct attribute access\n    # This handles cases where pytestmark might be set on instances\n    if not mark_list:\n        direct_marks = getattr(obj, \"pytestmark\", [])\n        if not isinstance(direct_marks, list):\n            direct_marks = [direct_marks]\n        mark_list = direct_marks\n    \n    return normalize_mark_list(mark_list)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/pytest/src/_pytest/mark/structures.py lines 358-363)": [
      "\ndef get_unpacked_marks(obj: object) -> Iterable[Mark]:\n    \"\"\"Obtain the unpacked marks that are stored on an object.\n    \n    When the object is a class with multiple inheritance, this function\n    will collect pytestmark from all base classes in the MRO to ensure\n    markers from all parent classes are preserved.\n    \"\"\"\n    mark_list = []\n    \n    # Handle both class objects and instances\n    if hasattr(obj, '__mro__'):\n        # obj is a class\n        mro = obj.__mro__\n    elif hasattr(obj, '__class__'):\n        # obj is an instance, get MRO from its class\n        mro = obj.__class__.__mro__\n    else:\n        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n        mro = [type(obj)]\n    \n    # Collect pytestmark from all classes in MRO\n    for cls in mro:\n        if hasattr(cls, 'pytestmark'):\n            cls_marks = getattr(cls, 'pytestmark', [])\n            if not isinstance(cls_marks, list):\n                cls_marks = [cls_marks]\n            mark_list.extend(cls_marks)\n    \n    # If no marks found in MRO, fall back to direct attribute access\n    # This handles cases where pytestmark might be set on instances\n    if not mark_list:\n        direct_marks = getattr(obj, \"pytestmark\", [])\n        if not isinstance(direct_marks, list):\n            direct_marks = [direct_marks]\n        mark_list = direct_marks\n    \n    return normalize_mark_list(mark_list)\n",
      "\ndef get_unpacked_marks(obj: object) -> Iterable[Mark]:\n    \"\"\"Obtain the unpacked marks that are stored on an object.\n    \n    When the object is a class with multiple inheritance, this function\n    will collect pytestmark from all base classes in the MRO to ensure\n    markers from all parent classes are preserved.\n    \"\"\"\n    mark_list = []\n    \n    # Handle both class objects and instances\n    if hasattr(obj, '__mro__'):\n        # obj is a class\n        mro = obj.__mro__\n    elif hasattr(obj, '__class__'):\n        # obj is an instance, get MRO from its class\n        mro = obj.__class__.__mro__\n    else:\n        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n        mro = [type(obj)]\n    \n    # Collect pytestmark from all classes in MRO\n    for cls in mro:\n        if hasattr(cls, 'pytestmark'):\n            cls_marks = getattr(cls, 'pytestmark', [])\n            if not isinstance(cls_marks, list):\n                cls_marks = [cls_marks]\n            mark_list.extend(cls_marks)\n    \n    # If no marks found in MRO, fall back to direct attribute access\n    # This handles cases where pytestmark might be set on instances\n    if not mark_list:\n        direct_marks = getattr(obj, \"pytestmark\", [])\n        if not isinstance(direct_marks, list):\n            direct_marks = [direct_marks]\n        mark_list = direct_marks\n    \n    return normalize_mark_list(mark_list)\n",
      "\ndef get_unpacked_marks(obj: object) -> Iterable[Mark]:\n    \"\"\"Obtain the unpacked marks that are stored on an object.\n    \n    When the object is a class with multiple inheritance, this function\n    will collect pytestmark from all base classes in the MRO to ensure\n    markers from all parent classes are preserved.\n    \"\"\"\n    mark_list = []\n    \n    # Handle both class objects and instances\n    if hasattr(obj, '__mro__'):\n        # obj is a class\n        mro = obj.__mro__\n    elif hasattr(obj, '__class__'):\n        # obj is an instance, get MRO from its class\n        mro = obj.__class__.__mro__\n    else:\n        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n        mro = [type(obj)]\n    \n    # Collect pytestmark from all classes in MRO\n    for cls in mro:\n        if hasattr(cls, 'pytestmark'):\n            cls_marks = getattr(cls, 'pytestmark', [])\n            if not isinstance(cls_marks, list):\n                cls_marks = [cls_marks]\n            mark_list.extend(cls_marks)\n    \n    # If no marks found in MRO, fall back to direct attribute access\n    # This handles cases where pytestmark might be set on instances\n    if not mark_list:\n        direct_marks = getattr(obj, \"pytestmark\", [])\n        if not isinstance(direct_marks, list):\n            direct_marks = [direct_marks]\n        mark_list = direct_marks\n    \n    return normalize_mark_list(mark_list)\n",
      "\ndef get_unpacked_marks(obj: object) -> Iterable[Mark]:\n    \"\"\"Obtain the unpacked marks that are stored on an object.\n    \n    When the object is a class with multiple inheritance, this function\n    will collect pytestmark from all base classes in the MRO to ensure\n    markers from all parent classes are preserved.\n    \"\"\"\n    mark_list = []\n    \n    # Handle both class objects and instances\n    if hasattr(obj, '__mro__'):\n        # obj is a class\n        mro = obj.__mro__\n    elif hasattr(obj, '__class__'):\n        # obj is an instance, get MRO from its class\n        mro = obj.__class__.__mro__\n    else:\n        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n        mro = [type(obj)]\n    \n    # Collect pytestmark from all classes in MRO\n    for cls in mro:\n        if hasattr(cls, 'pytestmark'):\n            cls_marks = getattr(cls, 'pytestmark', [])\n            if not isinstance(cls_marks, list):\n                cls_marks = [cls_marks]\n            mark_list.extend(cls_marks)\n    \n    # If no marks found in MRO, fall back to direct attribute access\n    # This handles cases where pytestmark might be set on instances\n    if not mark_list:\n        direct_marks = getattr(obj, \"pytestmark\", [])\n        if not isinstance(direct_marks, list):\n            direct_marks = [direct_marks]\n        mark_list = direct_marks\n    \n    return normalize_mark_list(mark_list)\n",
      "\ndef get_unpacked_marks(obj: object) -> Iterable[Mark]:\n    \"\"\"Obtain the unpacked marks that are stored on an object.\n    \n    When the object is a class with multiple inheritance, this function\n    will collect pytestmark from all base classes in the MRO to ensure\n    markers from all parent classes are preserved.\n    \"\"\"\n    mark_list = []\n    \n    # Handle both class objects and instances\n    if hasattr(obj, '__mro__'):\n        # obj is a class\n        mro = obj.__mro__\n    elif hasattr(obj, '__class__'):\n        # obj is an instance, get MRO from its class\n        mro = obj.__class__.__mro__\n    else:\n        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n        mro = [type(obj)]\n    \n    # Collect pytestmark from all classes in MRO\n    for cls in mro:\n        if hasattr(cls, 'pytestmark'):\n            cls_marks = getattr(cls, 'pytestmark', [])\n            if not isinstance(cls_marks, list):\n                cls_marks = [cls_marks]\n            mark_list.extend(cls_marks)\n    \n    # If no marks found in MRO, fall back to direct attribute access\n    # This handles cases where pytestmark might be set on instances\n    if not mark_list:\n        direct_marks = getattr(obj, \"pytestmark\", [])\n        if not isinstance(direct_marks, list):\n            direct_marks = [direct_marks]\n        mark_list = direct_marks\n    \n    return normalize_mark_list(mark_list)\n",
      "\ndef get_unpacked_marks(obj: object) -> Iterable[Mark]:\n    \"\"\"Obtain the unpacked marks that are stored on an object.\n    \n    When the object is a class with multiple inheritance, this function\n    will collect pytestmark from all base classes in the MRO to ensure\n    markers from all parent classes are preserved.\n    \"\"\"\n    mark_list = []\n    \n    # Handle both class objects and instances\n    if hasattr(obj, '__mro__'):\n        # obj is a class\n        mro = obj.__mro__\n    elif hasattr(obj, '__class__'):\n        # obj is an instance, get MRO from its class\n        mro = obj.__class__.__mro__\n    else:\n        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n        mro = [type(obj)]\n    \n    # Collect pytestmark from all classes in MRO\n    for cls in mro:\n        if hasattr(cls, 'pytestmark'):\n            cls_marks = getattr(cls, 'pytestmark', [])\n            if not isinstance(cls_marks, list):\n                cls_marks = [cls_marks]\n            mark_list.extend(cls_marks)\n    \n    # If no marks found in MRO, fall back to direct attribute access\n    # This handles cases where pytestmark might be set on instances\n    if not mark_list:\n        direct_marks = getattr(obj, \"pytestmark\", [])\n        if not isinstance(direct_marks, list):\n            direct_marks = [direct_marks]\n        mark_list = direct_marks\n    \n    return normalize_mark_list(mark_list)\n",
      "\ndef get_unpacked_marks(obj: object) -> Iterable[Mark]:\n    \"\"\"Obtain the unpacked marks that are stored on an object.\n    \n    When the object is a class with multiple inheritance, this function\n    will collect pytestmark from all base classes in the MRO to ensure\n    markers from all parent classes are preserved.\n    \"\"\"\n    mark_list = []\n    \n    # Handle both class objects and instances\n    if hasattr(obj, '__mro__'):\n        # obj is a class\n        mro = obj.__mro__\n    elif hasattr(obj, '__class__'):\n        # obj is an instance, get MRO from its class\n        mro = obj.__class__.__mro__\n    else:\n        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n        mro = [type(obj)]\n    \n    # Collect pytestmark from all classes in MRO\n    for cls in mro:\n        if hasattr(cls, 'pytestmark'):\n            cls_marks = getattr(cls, 'pytestmark', [])\n            if not isinstance(cls_marks, list):\n                cls_marks = [cls_marks]\n            mark_list.extend(cls_marks)\n    \n    # If no marks found in MRO, fall back to direct attribute access\n    # This handles cases where pytestmark might be set on instances\n    if not mark_list:\n        direct_marks = getattr(obj, \"pytestmark\", [])\n        if not isinstance(direct_marks, list):\n            direct_marks = [direct_marks]\n        mark_list = direct_marks\n    \n    return normalize_mark_list(mark_list)\n",
      "\ndef get_unpacked_marks(obj: object) -> Iterable[Mark]:\n    \"\"\"Obtain the unpacked marks that are stored on an object.\n    \n    When the object is a class with multiple inheritance, this function\n    will collect pytestmark from all base classes in the MRO to ensure\n    markers from all parent classes are preserved.\n    \"\"\"\n    mark_list = []\n    \n    # Handle both class objects and instances\n    if hasattr(obj, '__mro__'):\n        # obj is a class\n        mro = obj.__mro__\n    elif hasattr(obj, '__class__'):\n        # obj is an instance, get MRO from its class\n        mro = obj.__class__.__mro__\n    else:\n        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n        mro = [type(obj)]\n    \n    # Collect pytestmark from all classes in MRO\n    for cls in mro:\n        if hasattr(cls, 'pytestmark'):\n            cls_marks = getattr(cls, 'pytestmark', [])\n            if not isinstance(cls_marks, list):\n                cls_marks = [cls_marks]\n            mark_list.extend(cls_marks)\n    \n    # If no marks found in MRO, fall back to direct attribute access\n    # This handles cases where pytestmark might be set on instances\n    if not mark_list:\n        direct_marks = getattr(obj, \"pytestmark\", [])\n        if not isinstance(direct_marks, list):\n            direct_marks = [direct_marks]\n        mark_list = direct_marks\n    \n    return normalize_mark_list(mark_list)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..db833a01b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,11 +355,43 @@ class MarkDecorator:\n         return self.with_args(*args, **kwargs)\n \n \n+\n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    When the object is a class with multiple inheritance, this function\n+    will collect pytestmark from all base classes in the MRO to ensure\n+    markers from all parent classes are preserved.\n+    \"\"\"\n+    mark_list = []\n+    \n+    # Handle both class objects and instances\n+    if hasattr(obj, '__mro__'):\n+        # obj is a class\n+        mro = obj.__mro__\n+    elif hasattr(obj, '__class__'):\n+        # obj is an instance, get MRO from its class\n+        mro = obj.__class__.__mro__\n+    else:\n+        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n+        mro = [type(obj)]\n+    \n+    # Collect pytestmark from all classes in MRO\n+    for cls in mro:\n+        if hasattr(cls, 'pytestmark'):\n+            cls_marks = getattr(cls, 'pytestmark', [])\n+            if not isinstance(cls_marks, list):\n+                cls_marks = [cls_marks]\n+            mark_list.extend(cls_marks)\n+    \n+    # If no marks found in MRO, fall back to direct attribute access\n+    # This handles cases where pytestmark might be set on instances\n+    if not mark_list:\n+        direct_marks = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(direct_marks, list):\n+            direct_marks = [direct_marks]\n+        mark_list = direct_marks\n+    \n     return normalize_mark_list(mark_list)\n \n \n",
    "variant_0": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..db833a01b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,11 +355,43 @@ class MarkDecorator:\n         return self.with_args(*args, **kwargs)\n \n \n+\n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    When the object is a class with multiple inheritance, this function\n+    will collect pytestmark from all base classes in the MRO to ensure\n+    markers from all parent classes are preserved.\n+    \"\"\"\n+    mark_list = []\n+    \n+    # Handle both class objects and instances\n+    if hasattr(obj, '__mro__'):\n+        # obj is a class\n+        mro = obj.__mro__\n+    elif hasattr(obj, '__class__'):\n+        # obj is an instance, get MRO from its class\n+        mro = obj.__class__.__mro__\n+    else:\n+        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n+        mro = [type(obj)]\n+    \n+    # Collect pytestmark from all classes in MRO\n+    for cls in mro:\n+        if hasattr(cls, 'pytestmark'):\n+            cls_marks = getattr(cls, 'pytestmark', [])\n+            if not isinstance(cls_marks, list):\n+                cls_marks = [cls_marks]\n+            mark_list.extend(cls_marks)\n+    \n+    # If no marks found in MRO, fall back to direct attribute access\n+    # This handles cases where pytestmark might be set on instances\n+    if not mark_list:\n+        direct_marks = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(direct_marks, list):\n+            direct_marks = [direct_marks]\n+        mark_list = direct_marks\n+    \n     return normalize_mark_list(mark_list)\n \n \n",
    "variant_1": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..db833a01b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,11 +355,43 @@ class MarkDecorator:\n         return self.with_args(*args, **kwargs)\n \n \n+\n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    When the object is a class with multiple inheritance, this function\n+    will collect pytestmark from all base classes in the MRO to ensure\n+    markers from all parent classes are preserved.\n+    \"\"\"\n+    mark_list = []\n+    \n+    # Handle both class objects and instances\n+    if hasattr(obj, '__mro__'):\n+        # obj is a class\n+        mro = obj.__mro__\n+    elif hasattr(obj, '__class__'):\n+        # obj is an instance, get MRO from its class\n+        mro = obj.__class__.__mro__\n+    else:\n+        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n+        mro = [type(obj)]\n+    \n+    # Collect pytestmark from all classes in MRO\n+    for cls in mro:\n+        if hasattr(cls, 'pytestmark'):\n+            cls_marks = getattr(cls, 'pytestmark', [])\n+            if not isinstance(cls_marks, list):\n+                cls_marks = [cls_marks]\n+            mark_list.extend(cls_marks)\n+    \n+    # If no marks found in MRO, fall back to direct attribute access\n+    # This handles cases where pytestmark might be set on instances\n+    if not mark_list:\n+        direct_marks = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(direct_marks, list):\n+            direct_marks = [direct_marks]\n+        mark_list = direct_marks\n+    \n     return normalize_mark_list(mark_list)\n \n \n",
    "variant_2": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..db833a01b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,11 +355,43 @@ class MarkDecorator:\n         return self.with_args(*args, **kwargs)\n \n \n+\n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    When the object is a class with multiple inheritance, this function\n+    will collect pytestmark from all base classes in the MRO to ensure\n+    markers from all parent classes are preserved.\n+    \"\"\"\n+    mark_list = []\n+    \n+    # Handle both class objects and instances\n+    if hasattr(obj, '__mro__'):\n+        # obj is a class\n+        mro = obj.__mro__\n+    elif hasattr(obj, '__class__'):\n+        # obj is an instance, get MRO from its class\n+        mro = obj.__class__.__mro__\n+    else:\n+        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n+        mro = [type(obj)]\n+    \n+    # Collect pytestmark from all classes in MRO\n+    for cls in mro:\n+        if hasattr(cls, 'pytestmark'):\n+            cls_marks = getattr(cls, 'pytestmark', [])\n+            if not isinstance(cls_marks, list):\n+                cls_marks = [cls_marks]\n+            mark_list.extend(cls_marks)\n+    \n+    # If no marks found in MRO, fall back to direct attribute access\n+    # This handles cases where pytestmark might be set on instances\n+    if not mark_list:\n+        direct_marks = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(direct_marks, list):\n+            direct_marks = [direct_marks]\n+        mark_list = direct_marks\n+    \n     return normalize_mark_list(mark_list)\n \n \n",
    "variant_3": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..db833a01b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,11 +355,43 @@ class MarkDecorator:\n         return self.with_args(*args, **kwargs)\n \n \n+\n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    When the object is a class with multiple inheritance, this function\n+    will collect pytestmark from all base classes in the MRO to ensure\n+    markers from all parent classes are preserved.\n+    \"\"\"\n+    mark_list = []\n+    \n+    # Handle both class objects and instances\n+    if hasattr(obj, '__mro__'):\n+        # obj is a class\n+        mro = obj.__mro__\n+    elif hasattr(obj, '__class__'):\n+        # obj is an instance, get MRO from its class\n+        mro = obj.__class__.__mro__\n+    else:\n+        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n+        mro = [type(obj)]\n+    \n+    # Collect pytestmark from all classes in MRO\n+    for cls in mro:\n+        if hasattr(cls, 'pytestmark'):\n+            cls_marks = getattr(cls, 'pytestmark', [])\n+            if not isinstance(cls_marks, list):\n+                cls_marks = [cls_marks]\n+            mark_list.extend(cls_marks)\n+    \n+    # If no marks found in MRO, fall back to direct attribute access\n+    # This handles cases where pytestmark might be set on instances\n+    if not mark_list:\n+        direct_marks = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(direct_marks, list):\n+            direct_marks = [direct_marks]\n+        mark_list = direct_marks\n+    \n     return normalize_mark_list(mark_list)\n \n \n",
    "variant_4": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..db833a01b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,11 +355,43 @@ class MarkDecorator:\n         return self.with_args(*args, **kwargs)\n \n \n+\n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    When the object is a class with multiple inheritance, this function\n+    will collect pytestmark from all base classes in the MRO to ensure\n+    markers from all parent classes are preserved.\n+    \"\"\"\n+    mark_list = []\n+    \n+    # Handle both class objects and instances\n+    if hasattr(obj, '__mro__'):\n+        # obj is a class\n+        mro = obj.__mro__\n+    elif hasattr(obj, '__class__'):\n+        # obj is an instance, get MRO from its class\n+        mro = obj.__class__.__mro__\n+    else:\n+        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n+        mro = [type(obj)]\n+    \n+    # Collect pytestmark from all classes in MRO\n+    for cls in mro:\n+        if hasattr(cls, 'pytestmark'):\n+            cls_marks = getattr(cls, 'pytestmark', [])\n+            if not isinstance(cls_marks, list):\n+                cls_marks = [cls_marks]\n+            mark_list.extend(cls_marks)\n+    \n+    # If no marks found in MRO, fall back to direct attribute access\n+    # This handles cases where pytestmark might be set on instances\n+    if not mark_list:\n+        direct_marks = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(direct_marks, list):\n+            direct_marks = [direct_marks]\n+        mark_list = direct_marks\n+    \n     return normalize_mark_list(mark_list)\n \n \n",
    "variant_5": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..db833a01b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,11 +355,43 @@ class MarkDecorator:\n         return self.with_args(*args, **kwargs)\n \n \n+\n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    When the object is a class with multiple inheritance, this function\n+    will collect pytestmark from all base classes in the MRO to ensure\n+    markers from all parent classes are preserved.\n+    \"\"\"\n+    mark_list = []\n+    \n+    # Handle both class objects and instances\n+    if hasattr(obj, '__mro__'):\n+        # obj is a class\n+        mro = obj.__mro__\n+    elif hasattr(obj, '__class__'):\n+        # obj is an instance, get MRO from its class\n+        mro = obj.__class__.__mro__\n+    else:\n+        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n+        mro = [type(obj)]\n+    \n+    # Collect pytestmark from all classes in MRO\n+    for cls in mro:\n+        if hasattr(cls, 'pytestmark'):\n+            cls_marks = getattr(cls, 'pytestmark', [])\n+            if not isinstance(cls_marks, list):\n+                cls_marks = [cls_marks]\n+            mark_list.extend(cls_marks)\n+    \n+    # If no marks found in MRO, fall back to direct attribute access\n+    # This handles cases where pytestmark might be set on instances\n+    if not mark_list:\n+        direct_marks = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(direct_marks, list):\n+            direct_marks = [direct_marks]\n+        mark_list = direct_marks\n+    \n     return normalize_mark_list(mark_list)\n \n \n",
    "variant_6": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..db833a01b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,11 +355,43 @@ class MarkDecorator:\n         return self.with_args(*args, **kwargs)\n \n \n+\n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    When the object is a class with multiple inheritance, this function\n+    will collect pytestmark from all base classes in the MRO to ensure\n+    markers from all parent classes are preserved.\n+    \"\"\"\n+    mark_list = []\n+    \n+    # Handle both class objects and instances\n+    if hasattr(obj, '__mro__'):\n+        # obj is a class\n+        mro = obj.__mro__\n+    elif hasattr(obj, '__class__'):\n+        # obj is an instance, get MRO from its class\n+        mro = obj.__class__.__mro__\n+    else:\n+        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n+        mro = [type(obj)]\n+    \n+    # Collect pytestmark from all classes in MRO\n+    for cls in mro:\n+        if hasattr(cls, 'pytestmark'):\n+            cls_marks = getattr(cls, 'pytestmark', [])\n+            if not isinstance(cls_marks, list):\n+                cls_marks = [cls_marks]\n+            mark_list.extend(cls_marks)\n+    \n+    # If no marks found in MRO, fall back to direct attribute access\n+    # This handles cases where pytestmark might be set on instances\n+    if not mark_list:\n+        direct_marks = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(direct_marks, list):\n+            direct_marks = [direct_marks]\n+        mark_list = direct_marks\n+    \n     return normalize_mark_list(mark_list)\n \n \n",
    "variant_7": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..db833a01b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,11 +355,43 @@ class MarkDecorator:\n         return self.with_args(*args, **kwargs)\n \n \n+\n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    When the object is a class with multiple inheritance, this function\n+    will collect pytestmark from all base classes in the MRO to ensure\n+    markers from all parent classes are preserved.\n+    \"\"\"\n+    mark_list = []\n+    \n+    # Handle both class objects and instances\n+    if hasattr(obj, '__mro__'):\n+        # obj is a class\n+        mro = obj.__mro__\n+    elif hasattr(obj, '__class__'):\n+        # obj is an instance, get MRO from its class\n+        mro = obj.__class__.__mro__\n+    else:\n+        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n+        mro = [type(obj)]\n+    \n+    # Collect pytestmark from all classes in MRO\n+    for cls in mro:\n+        if hasattr(cls, 'pytestmark'):\n+            cls_marks = getattr(cls, 'pytestmark', [])\n+            if not isinstance(cls_marks, list):\n+                cls_marks = [cls_marks]\n+            mark_list.extend(cls_marks)\n+    \n+    # If no marks found in MRO, fall back to direct attribute access\n+    # This handles cases where pytestmark might be set on instances\n+    if not mark_list:\n+        direct_marks = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(direct_marks, list):\n+            direct_marks = [direct_marks]\n+        mark_list = direct_marks\n+    \n     return normalize_mark_list(mark_list)\n \n \n",
    "variant_8": "diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..db833a01b 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,11 +355,43 @@ class MarkDecorator:\n         return self.with_args(*args, **kwargs)\n \n \n+\n def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    When the object is a class with multiple inheritance, this function\n+    will collect pytestmark from all base classes in the MRO to ensure\n+    markers from all parent classes are preserved.\n+    \"\"\"\n+    mark_list = []\n+    \n+    # Handle both class objects and instances\n+    if hasattr(obj, '__mro__'):\n+        # obj is a class\n+        mro = obj.__mro__\n+    elif hasattr(obj, '__class__'):\n+        # obj is an instance, get MRO from its class\n+        mro = obj.__class__.__mro__\n+    else:\n+        # Fallback for objects without MRO (shouldn't happen in normal pytest usage)\n+        mro = [type(obj)]\n+    \n+    # Collect pytestmark from all classes in MRO\n+    for cls in mro:\n+        if hasattr(cls, 'pytestmark'):\n+            cls_marks = getattr(cls, 'pytestmark', [])\n+            if not isinstance(cls_marks, list):\n+                cls_marks = [cls_marks]\n+            mark_list.extend(cls_marks)\n+    \n+    # If no marks found in MRO, fall back to direct attribute access\n+    # This handles cases where pytestmark might be set on instances\n+    if not mark_list:\n+        direct_marks = getattr(obj, \"pytestmark\", [])\n+        if not isinstance(direct_marks, list):\n+            direct_marks = [direct_marks]\n+        mark_list = direct_marks\n+    \n     return normalize_mark_list(mark_list)\n \n \n"
  }
}