{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/contrib/auth/__init__.py lines 200-207)": "\n        if hasattr(user, \"get_session_auth_hash\"):\n            session_hash = request.session.get(HASH_SESSION_KEY)\n            session_hash_verified = False\n            if session_hash:\n                # Try current key first, then fallback keys\n                from django.utils.crypto import salted_hmac\n                for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                    # Generate hash with this key for comparison\n                    key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                    expected_hash = salted_hmac(\n                        key_salt,\n                        user.password,\n                        secret=secret_key,\n                        algorithm=\"sha256\",\n                    ).hexdigest()\n                    if constant_time_compare(session_hash, expected_hash):\n                        session_hash_verified = True\n                        break\n            if not session_hash_verified:\n                request.session.flush()\n                user = None\n",
    "Location 2 (/root/hy/projects/django/django/contrib/auth/base_user.py lines 134-143)": "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    from django.utils.crypto import salted_hmac\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
    "Location 3 (/root/hy/projects/django/django/utils/crypto.py lines 18-44)": "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.utils.crypto import salted_hmac\n    from django.utils.crypto import constant_time_compare\n    from django.conf import settings\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/contrib/auth/__init__.py lines 200-207)": [
      "\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    from django.utils.crypto import salted_hmac\n                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n",
      "\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                from django.utils.crypto import salted_hmac\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n\n    return user or AnonymousUser()\n",
      "\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    from django.utils.crypto import salted_hmac\n                    for secret_key in [settings.SECRET_KEY] + getattr(settings, 'SECRET_KEY_FALLBACKS', []):\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n\n    return user or AnonymousUser()\n",
      "\nif hasattr(user, \"get_session_auth_hash\"):\n    session_hash = request.session.get(HASH_SESSION_KEY)\n    session_hash_verified = False\n    if session_hash:\n        # Try current key first, then fallback keys\n        from django.utils.crypto import salted_hmac\n        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n        for secret_key in [settings.SECRET_KEY] + getattr(settings, 'SECRET_KEY_FALLBACKS', []):\n            expected_hash = salted_hmac(\n                key_salt,\n                user.password,\n                secret=secret_key,\n                algorithm=\"sha256\",\n            ).hexdigest()\n            if constant_time_compare(session_hash, expected_hash):\n                session_hash_verified = True\n                break\n    if not session_hash_verified:\n        request.session.flush()\n        user = None\n",
      "\nif hasattr(user, \"get_session_auth_hash\"):\n    session_hash = request.session.get(HASH_SESSION_KEY)\n    session_hash_verified = False\n    if session_hash:\n        # Try current key first, then fallback keys\n        from django.utils.crypto import salted_hmac\n        for secret_key in [settings.SECRET_KEY] + getattr(settings, 'SECRET_KEY_FALLBACKS', []):\n            # Generate hash with this key for comparison\n            key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n            expected_hash = salted_hmac(\n                key_salt,\n                user.password,\n                secret=secret_key,\n                algorithm=\"sha256\",\n            ).hexdigest()\n            if constant_time_compare(session_hash, expected_hash):\n                session_hash_verified = True\n                break\n    if not session_hash_verified:\n        request.session.flush()\n        user = None\n",
      "\nif hasattr(user, \"get_session_auth_hash\"):\n    session_hash = request.session.get(HASH_SESSION_KEY)\n    session_hash_verified = False\n    if session_hash:\n        # Try current key first, then fallback keys\n        from django.utils.crypto import salted_hmac\n        for secret_key in [settings.SECRET_KEY] + getattr(settings, 'SECRET_KEY_FALLBACKS', []):\n            # Generate hash with this key for comparison\n            key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n            expected_hash = salted_hmac(\n                key_salt,\n                user.password,\n                secret=secret_key,\n                algorithm=\"sha256\",\n            ).hexdigest()\n            if constant_time_compare(session_hash, expected_hash):\n                session_hash_verified = True\n                break\n    if not session_hash_verified:\n        request.session.flush()\n        user = None\n",
      "\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    from django.utils.crypto import salted_hmac\n                    key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                    \n                    # Check current SECRET_KEY first\n                    expected_hash = salted_hmac(\n                        key_salt,\n                        user.password,\n                        secret=settings.SECRET_KEY,\n                        algorithm=\"sha256\",\n                    ).hexdigest()\n                    if constant_time_compare(session_hash, expected_hash):\n                        session_hash_verified = True\n                    else:\n                        # Try fallback keys\n                        for fallback_key in getattr(settings, 'SECRET_KEY_FALLBACKS', []):\n                            expected_hash = salted_hmac(\n                                key_salt,\n                                user.password,\n                                secret=fallback_key,\n                                algorithm=\"sha256\",\n                            ).hexdigest()\n                            if constant_time_compare(session_hash, expected_hash):\n                                session_hash_verified = True\n                                break\n                \n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n",
      "\nif hasattr(user, \"get_session_auth_hash\"):\n    session_hash = request.session.get(HASH_SESSION_KEY)\n    session_hash_verified = False\n    if session_hash:\n        # Try current key first, then fallback keys\n        from django.utils.crypto import salted_hmac\n        keys_to_try = [settings.SECRET_KEY]\n        if hasattr(settings, 'SECRET_KEY_FALLBACKS'):\n            keys_to_try.extend(settings.SECRET_KEY_FALLBACKS)\n        \n        for secret_key in keys_to_try:\n            # Generate hash with this key for comparison\n            key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n            expected_hash = salted_hmac(\n                key_salt,\n                user.password,\n                secret=secret_key,\n                algorithm=\"sha256\",\n            ).hexdigest()\n            if constant_time_compare(session_hash, expected_hash):\n                session_hash_verified = True\n                break\n    if not session_hash_verified:\n        request.session.flush()\n        user = None\n"
    ],
    "Location 2 (/root/hy/projects/django/django/contrib/auth/base_user.py lines 134-143)": [
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.conf import settings\n    from django.utils.crypto import salted_hmac\n    from django.utils.crypto import constant_time_compare\n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\n    def get_session_auth_hash(self):\n        \"\"\"\n        Return an HMAC of the password field.\n        \"\"\"\n        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n        return salted_hmac(\n            key_salt,\n            self.password,\n            algorithm=\"sha256\",\n        ).hexdigest()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    from django.utils.crypto import salted_hmac\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    from django.utils.crypto import salted_hmac\n                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\n    def get_session_auth_hash(self):\n        \"\"\"\n        Return an HMAC of the password field.\n        \"\"\"\n        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n        return salted_hmac(\n            key_salt,\n            self.password,\n            algorithm=\"sha256\",\n        ).hexdigest()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.conf import settings\n    from django.utils.crypto import salted_hmac, constant_time_compare\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.conf import settings\n    from django.utils.crypto import salted_hmac, constant_time_compare\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    from django.utils.crypto import salted_hmac\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n"
    ],
    "Location 3 (/root/hy/projects/django/django/utils/crypto.py lines 18-44)": [
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.utils.crypto import salted_hmac\n    from django.utils.crypto import constant_time_compare\n    from django.conf import settings\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.utils.crypto import salted_hmac\n    from django.utils.crypto import constant_time_compare\n    from django.conf import settings\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.utils.crypto import salted_hmac\n    from django.utils.crypto import constant_time_compare\n    from django.conf import settings\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.utils.crypto import salted_hmac\n    from django.utils.crypto import constant_time_compare\n    from django.conf import settings\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.utils.crypto import salted_hmac\n    from django.utils.crypto import constant_time_compare\n    from django.conf import settings\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.utils.crypto import salted_hmac\n    from django.utils.crypto import constant_time_compare\n    from django.conf import settings\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.utils.crypto import salted_hmac\n    from django.utils.crypto import constant_time_compare\n    from django.conf import settings\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n",
      "\ndef get_user(request):\n    \"\"\"\n    Return the user model instance associated with the given request session.\n    If no user is retrieved, return an instance of `AnonymousUser`.\n    \"\"\"\n    from django.contrib.auth.models import AnonymousUser\n    from django.utils.crypto import salted_hmac\n    from django.utils.crypto import constant_time_compare\n    from django.conf import settings\n    \n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \"get_session_auth_hash\"):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = False\n                if session_hash:\n                    # Try current key first, then fallback keys\n                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n                        # Generate hash with this key for comparison\n                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n                        expected_hash = salted_hmac(\n                            key_salt,\n                            user.password,\n                            secret=secret_key,\n                            algorithm=\"sha256\",\n                        ).hexdigest()\n                        if constant_time_compare(session_hash, expected_hash):\n                            session_hash_verified = True\n                            break\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..5cc0e52ca7 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -197,11 +197,25 @@ def get_user(request):\n             backend = load_backend(backend_path)\n             user = backend.get_user(user_id)\n             # Verify the session\n+\n             if hasattr(user, \"get_session_auth_hash\"):\n                 session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n-                )\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    from django.utils.crypto import salted_hmac\n+                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n                 if not session_hash_verified:\n                     request.session.flush()\n                     user = None\ndiff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 5ee30bf59c..0c658e125e 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -131,6 +131,7 @@ class AbstractBaseUser(models.Model):\n         \"\"\"\n         return is_password_usable(self.password)\n \n+\n     def get_session_auth_hash(self):\n         \"\"\"\n         Return an HMAC of the password field.\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..af50edd91e 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,6 +15,7 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n+\n def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n     \"\"\"\n     Return the HMAC of 'value', using a key generated from key_salt and a\n",
    "variant_0": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..8c38eb7d12 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -197,14 +197,28 @@ def get_user(request):\n             backend = load_backend(backend_path)\n             user = backend.get_user(user_id)\n             # Verify the session\n-            if hasattr(user, \"get_session_auth_hash\"):\n-                session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n-                )\n-                if not session_hash_verified:\n-                    request.session.flush()\n-                    user = None\n+\n+        if hasattr(user, \"get_session_auth_hash\"):\n+            session_hash = request.session.get(HASH_SESSION_KEY)\n+            session_hash_verified = False\n+            if session_hash:\n+                # Try current key first, then fallback keys\n+                from django.utils.crypto import salted_hmac\n+                for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                    # Generate hash with this key for comparison\n+                    key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                    expected_hash = salted_hmac(\n+                        key_salt,\n+                        user.password,\n+                        secret=secret_key,\n+                        algorithm=\"sha256\",\n+                    ).hexdigest()\n+                    if constant_time_compare(session_hash, expected_hash):\n+                        session_hash_verified = True\n+                        break\n+            if not session_hash_verified:\n+                request.session.flush()\n+                user = None\n \n     return user or AnonymousUser()\n \ndiff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 5ee30bf59c..122332833e 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -131,16 +131,46 @@ class AbstractBaseUser(models.Model):\n         \"\"\"\n         return is_password_usable(self.password)\n \n-    def get_session_auth_hash(self):\n-        \"\"\"\n-        Return an HMAC of the password field.\n-        \"\"\"\n-        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n-        return salted_hmac(\n-            key_salt,\n-            self.password,\n-            algorithm=\"sha256\",\n-        ).hexdigest()\n+\n+def get_user(request):\n+    \"\"\"\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    user = None\n+    try:\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    from django.utils.crypto import salted_hmac\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n     @classmethod\n     def get_email_field_name(cls):\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..4b6fafb975 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,33 +15,49 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n-def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n-    \"\"\"\n-    Return the HMAC of 'value', using a key generated from key_salt and a\n-    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n-    but any algorithm name supported by hashlib can be passed.\n \n-    A different key_salt should be passed in for every application of HMAC.\n+def get_user(request):\n     \"\"\"\n-    if secret is None:\n-        secret = settings.SECRET_KEY\n-\n-    key_salt = force_bytes(key_salt)\n-    secret = force_bytes(secret)\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.utils.crypto import salted_hmac\n+    from django.utils.crypto import constant_time_compare\n+    from django.conf import settings\n+    \n+    user = None\n     try:\n-        hasher = getattr(hashlib, algorithm)\n-    except AttributeError as e:\n-        raise InvalidAlgorithm(\n-            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n-        ) from e\n-    # We need to generate a derived key from our base key.  We can do this by\n-    # passing the key_salt and our base key through a pseudo-random function.\n-    key = hasher(key_salt + secret).digest()\n-    # If len(key_salt + secret) > block size of the hash algorithm, the above\n-    # line is redundant and could be replaced by key = key_salt + secret, since\n-    # the hmac module does the same thing for keys longer than the block size.\n-    # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n \n RANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n",
    "variant_1": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..de07f50806 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -187,6 +187,17 @@ def get_user(request):\n     from .models import AnonymousUser\n \n     user = None\n+    try:\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+\n     try:\n         user_id = _get_user_session_key(request)\n         backend_path = request.session[BACKEND_SESSION_KEY]\n@@ -199,9 +210,22 @@ def get_user(request):\n             # Verify the session\n             if hasattr(user, \"get_session_auth_hash\"):\n                 session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n-                )\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    from django.utils.crypto import salted_hmac\n+                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n                 if not session_hash_verified:\n                     request.session.flush()\n                     user = None\ndiff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 5ee30bf59c..044bf83106 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -131,16 +131,48 @@ class AbstractBaseUser(models.Model):\n         \"\"\"\n         return is_password_usable(self.password)\n \n-    def get_session_auth_hash(self):\n-        \"\"\"\n-        Return an HMAC of the password field.\n-        \"\"\"\n-        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n-        return salted_hmac(\n-            key_salt,\n-            self.password,\n-            algorithm=\"sha256\",\n-        ).hexdigest()\n+\n+def get_user(request):\n+    \"\"\"\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.conf import settings\n+    from django.utils.crypto import salted_hmac\n+    from django.utils.crypto import constant_time_compare\n+    user = None\n+    try:\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n     @classmethod\n     def get_email_field_name(cls):\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..4b6fafb975 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,33 +15,49 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n-def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n-    \"\"\"\n-    Return the HMAC of 'value', using a key generated from key_salt and a\n-    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n-    but any algorithm name supported by hashlib can be passed.\n \n-    A different key_salt should be passed in for every application of HMAC.\n+def get_user(request):\n     \"\"\"\n-    if secret is None:\n-        secret = settings.SECRET_KEY\n-\n-    key_salt = force_bytes(key_salt)\n-    secret = force_bytes(secret)\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.utils.crypto import salted_hmac\n+    from django.utils.crypto import constant_time_compare\n+    from django.conf import settings\n+    \n+    user = None\n     try:\n-        hasher = getattr(hashlib, algorithm)\n-    except AttributeError as e:\n-        raise InvalidAlgorithm(\n-            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n-        ) from e\n-    # We need to generate a derived key from our base key.  We can do this by\n-    # passing the key_salt and our base key through a pseudo-random function.\n-    key = hasher(key_salt + secret).digest()\n-    # If len(key_salt + secret) > block size of the hash algorithm, the above\n-    # line is redundant and could be replaced by key = key_salt + secret, since\n-    # the hmac module does the same thing for keys longer than the block size.\n-    # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n \n RANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n",
    "variant_2": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..4ab1f051df 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -187,6 +187,17 @@ def get_user(request):\n     from .models import AnonymousUser\n \n     user = None\n+    try:\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+\n     try:\n         user_id = _get_user_session_key(request)\n         backend_path = request.session[BACKEND_SESSION_KEY]\n@@ -198,16 +209,31 @@ def get_user(request):\n             user = backend.get_user(user_id)\n             # Verify the session\n             if hasattr(user, \"get_session_auth_hash\"):\n+                from django.utils.crypto import salted_hmac\n                 session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n-                )\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n                 if not session_hash_verified:\n                     request.session.flush()\n                     user = None\n \n     return user or AnonymousUser()\n \n+    return user or AnonymousUser()\n+\n \n def get_permission_codename(action, opts):\n     \"\"\"\ndiff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 5ee30bf59c..0c658e125e 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -131,6 +131,7 @@ class AbstractBaseUser(models.Model):\n         \"\"\"\n         return is_password_usable(self.password)\n \n+\n     def get_session_auth_hash(self):\n         \"\"\"\n         Return an HMAC of the password field.\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..4b6fafb975 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,33 +15,49 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n-def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n-    \"\"\"\n-    Return the HMAC of 'value', using a key generated from key_salt and a\n-    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n-    but any algorithm name supported by hashlib can be passed.\n \n-    A different key_salt should be passed in for every application of HMAC.\n+def get_user(request):\n     \"\"\"\n-    if secret is None:\n-        secret = settings.SECRET_KEY\n-\n-    key_salt = force_bytes(key_salt)\n-    secret = force_bytes(secret)\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.utils.crypto import salted_hmac\n+    from django.utils.crypto import constant_time_compare\n+    from django.conf import settings\n+    \n+    user = None\n     try:\n-        hasher = getattr(hashlib, algorithm)\n-    except AttributeError as e:\n-        raise InvalidAlgorithm(\n-            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n-        ) from e\n-    # We need to generate a derived key from our base key.  We can do this by\n-    # passing the key_salt and our base key through a pseudo-random function.\n-    key = hasher(key_salt + secret).digest()\n-    # If len(key_salt + secret) > block size of the hash algorithm, the above\n-    # line is redundant and could be replaced by key = key_salt + secret, since\n-    # the hmac module does the same thing for keys longer than the block size.\n-    # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n \n RANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n",
    "variant_3": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..bb6b689ff7 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -187,6 +187,17 @@ def get_user(request):\n     from .models import AnonymousUser\n \n     user = None\n+    try:\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+\n     try:\n         user_id = _get_user_session_key(request)\n         backend_path = request.session[BACKEND_SESSION_KEY]\n@@ -199,15 +210,30 @@ def get_user(request):\n             # Verify the session\n             if hasattr(user, \"get_session_auth_hash\"):\n                 session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n-                )\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    from django.utils.crypto import salted_hmac\n+                    for secret_key in [settings.SECRET_KEY] + getattr(settings, 'SECRET_KEY_FALLBACKS', []):\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n                 if not session_hash_verified:\n                     request.session.flush()\n                     user = None\n \n     return user or AnonymousUser()\n \n+    return user or AnonymousUser()\n+\n \n def get_permission_codename(action, opts):\n     \"\"\"\ndiff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 5ee30bf59c..122332833e 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -131,16 +131,46 @@ class AbstractBaseUser(models.Model):\n         \"\"\"\n         return is_password_usable(self.password)\n \n-    def get_session_auth_hash(self):\n-        \"\"\"\n-        Return an HMAC of the password field.\n-        \"\"\"\n-        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n-        return salted_hmac(\n-            key_salt,\n-            self.password,\n-            algorithm=\"sha256\",\n-        ).hexdigest()\n+\n+def get_user(request):\n+    \"\"\"\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    user = None\n+    try:\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    from django.utils.crypto import salted_hmac\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n     @classmethod\n     def get_email_field_name(cls):\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..4b6fafb975 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,33 +15,49 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n-def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n-    \"\"\"\n-    Return the HMAC of 'value', using a key generated from key_salt and a\n-    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n-    but any algorithm name supported by hashlib can be passed.\n \n-    A different key_salt should be passed in for every application of HMAC.\n+def get_user(request):\n     \"\"\"\n-    if secret is None:\n-        secret = settings.SECRET_KEY\n-\n-    key_salt = force_bytes(key_salt)\n-    secret = force_bytes(secret)\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.utils.crypto import salted_hmac\n+    from django.utils.crypto import constant_time_compare\n+    from django.conf import settings\n+    \n+    user = None\n     try:\n-        hasher = getattr(hashlib, algorithm)\n-    except AttributeError as e:\n-        raise InvalidAlgorithm(\n-            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n-        ) from e\n-    # We need to generate a derived key from our base key.  We can do this by\n-    # passing the key_salt and our base key through a pseudo-random function.\n-    key = hasher(key_salt + secret).digest()\n-    # If len(key_salt + secret) > block size of the hash algorithm, the above\n-    # line is redundant and could be replaced by key = key_salt + secret, since\n-    # the hmac module does the same thing for keys longer than the block size.\n-    # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n \n RANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n",
    "variant_4": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..adcb5a9d26 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -197,14 +197,27 @@ def get_user(request):\n             backend = load_backend(backend_path)\n             user = backend.get_user(user_id)\n             # Verify the session\n-            if hasattr(user, \"get_session_auth_hash\"):\n-                session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n-                )\n-                if not session_hash_verified:\n-                    request.session.flush()\n-                    user = None\n+\n+if hasattr(user, \"get_session_auth_hash\"):\n+    session_hash = request.session.get(HASH_SESSION_KEY)\n+    session_hash_verified = False\n+    if session_hash:\n+        # Try current key first, then fallback keys\n+        from django.utils.crypto import salted_hmac\n+        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+        for secret_key in [settings.SECRET_KEY] + getattr(settings, 'SECRET_KEY_FALLBACKS', []):\n+            expected_hash = salted_hmac(\n+                key_salt,\n+                user.password,\n+                secret=secret_key,\n+                algorithm=\"sha256\",\n+            ).hexdigest()\n+            if constant_time_compare(session_hash, expected_hash):\n+                session_hash_verified = True\n+                break\n+    if not session_hash_verified:\n+        request.session.flush()\n+        user = None\n \n     return user or AnonymousUser()\n \ndiff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 5ee30bf59c..de9a6de916 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -131,16 +131,46 @@ class AbstractBaseUser(models.Model):\n         \"\"\"\n         return is_password_usable(self.password)\n \n-    def get_session_auth_hash(self):\n-        \"\"\"\n-        Return an HMAC of the password field.\n-        \"\"\"\n-        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n-        return salted_hmac(\n-            key_salt,\n-            self.password,\n-            algorithm=\"sha256\",\n-        ).hexdigest()\n+\n+def get_user(request):\n+    \"\"\"\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    user = None\n+    try:\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    from django.utils.crypto import salted_hmac\n+                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n     @classmethod\n     def get_email_field_name(cls):\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..4b6fafb975 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,33 +15,49 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n-def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n-    \"\"\"\n-    Return the HMAC of 'value', using a key generated from key_salt and a\n-    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n-    but any algorithm name supported by hashlib can be passed.\n \n-    A different key_salt should be passed in for every application of HMAC.\n+def get_user(request):\n     \"\"\"\n-    if secret is None:\n-        secret = settings.SECRET_KEY\n-\n-    key_salt = force_bytes(key_salt)\n-    secret = force_bytes(secret)\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.utils.crypto import salted_hmac\n+    from django.utils.crypto import constant_time_compare\n+    from django.conf import settings\n+    \n+    user = None\n     try:\n-        hasher = getattr(hashlib, algorithm)\n-    except AttributeError as e:\n-        raise InvalidAlgorithm(\n-            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n-        ) from e\n-    # We need to generate a derived key from our base key.  We can do this by\n-    # passing the key_salt and our base key through a pseudo-random function.\n-    key = hasher(key_salt + secret).digest()\n-    # If len(key_salt + secret) > block size of the hash algorithm, the above\n-    # line is redundant and could be replaced by key = key_salt + secret, since\n-    # the hmac module does the same thing for keys longer than the block size.\n-    # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n \n RANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n",
    "variant_5": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..58870774cf 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -197,14 +197,28 @@ def get_user(request):\n             backend = load_backend(backend_path)\n             user = backend.get_user(user_id)\n             # Verify the session\n-            if hasattr(user, \"get_session_auth_hash\"):\n-                session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n-                )\n-                if not session_hash_verified:\n-                    request.session.flush()\n-                    user = None\n+\n+if hasattr(user, \"get_session_auth_hash\"):\n+    session_hash = request.session.get(HASH_SESSION_KEY)\n+    session_hash_verified = False\n+    if session_hash:\n+        # Try current key first, then fallback keys\n+        from django.utils.crypto import salted_hmac\n+        for secret_key in [settings.SECRET_KEY] + getattr(settings, 'SECRET_KEY_FALLBACKS', []):\n+            # Generate hash with this key for comparison\n+            key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+            expected_hash = salted_hmac(\n+                key_salt,\n+                user.password,\n+                secret=secret_key,\n+                algorithm=\"sha256\",\n+            ).hexdigest()\n+            if constant_time_compare(session_hash, expected_hash):\n+                session_hash_verified = True\n+                break\n+    if not session_hash_verified:\n+        request.session.flush()\n+        user = None\n \n     return user or AnonymousUser()\n \ndiff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 5ee30bf59c..0c658e125e 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -131,6 +131,7 @@ class AbstractBaseUser(models.Model):\n         \"\"\"\n         return is_password_usable(self.password)\n \n+\n     def get_session_auth_hash(self):\n         \"\"\"\n         Return an HMAC of the password field.\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..cf830a2429 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,33 +15,49 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n-def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n-    \"\"\"\n-    Return the HMAC of 'value', using a key generated from key_salt and a\n-    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n-    but any algorithm name supported by hashlib can be passed.\n \n-    A different key_salt should be passed in for every application of HMAC.\n+def get_user(request):\n     \"\"\"\n-    if secret is None:\n-        secret = settings.SECRET_KEY\n-\n-    key_salt = force_bytes(key_salt)\n-    secret = force_bytes(secret)\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.utils.crypto import salted_hmac\n+    from django.utils.crypto import constant_time_compare\n+    from django.conf import settings\n+    \n+    user = None\n     try:\n-        hasher = getattr(hashlib, algorithm)\n-    except AttributeError as e:\n-        raise InvalidAlgorithm(\n-            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n-        ) from e\n-    # We need to generate a derived key from our base key.  We can do this by\n-    # passing the key_salt and our base key through a pseudo-random function.\n-    key = hasher(key_salt + secret).digest()\n-    # If len(key_salt + secret) > block size of the hash algorithm, the above\n-    # line is redundant and could be replaced by key = key_salt + secret, since\n-    # the hmac module does the same thing for keys longer than the block size.\n-    # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *settings.SECRET_KEY_FALLBACKS]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n \n RANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n",
    "variant_6": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..58870774cf 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -197,14 +197,28 @@ def get_user(request):\n             backend = load_backend(backend_path)\n             user = backend.get_user(user_id)\n             # Verify the session\n-            if hasattr(user, \"get_session_auth_hash\"):\n-                session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n-                )\n-                if not session_hash_verified:\n-                    request.session.flush()\n-                    user = None\n+\n+if hasattr(user, \"get_session_auth_hash\"):\n+    session_hash = request.session.get(HASH_SESSION_KEY)\n+    session_hash_verified = False\n+    if session_hash:\n+        # Try current key first, then fallback keys\n+        from django.utils.crypto import salted_hmac\n+        for secret_key in [settings.SECRET_KEY] + getattr(settings, 'SECRET_KEY_FALLBACKS', []):\n+            # Generate hash with this key for comparison\n+            key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+            expected_hash = salted_hmac(\n+                key_salt,\n+                user.password,\n+                secret=secret_key,\n+                algorithm=\"sha256\",\n+            ).hexdigest()\n+            if constant_time_compare(session_hash, expected_hash):\n+                session_hash_verified = True\n+                break\n+    if not session_hash_verified:\n+        request.session.flush()\n+        user = None\n \n     return user or AnonymousUser()\n \ndiff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 5ee30bf59c..6c7a3afbb0 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -131,16 +131,48 @@ class AbstractBaseUser(models.Model):\n         \"\"\"\n         return is_password_usable(self.password)\n \n-    def get_session_auth_hash(self):\n-        \"\"\"\n-        Return an HMAC of the password field.\n-        \"\"\"\n-        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n-        return salted_hmac(\n-            key_salt,\n-            self.password,\n-            algorithm=\"sha256\",\n-        ).hexdigest()\n+\n+def get_user(request):\n+    \"\"\"\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.conf import settings\n+    from django.utils.crypto import salted_hmac, constant_time_compare\n+    \n+    user = None\n+    try:\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n     @classmethod\n     def get_email_field_name(cls):\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..4b6fafb975 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,33 +15,49 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n-def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n-    \"\"\"\n-    Return the HMAC of 'value', using a key generated from key_salt and a\n-    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n-    but any algorithm name supported by hashlib can be passed.\n \n-    A different key_salt should be passed in for every application of HMAC.\n+def get_user(request):\n     \"\"\"\n-    if secret is None:\n-        secret = settings.SECRET_KEY\n-\n-    key_salt = force_bytes(key_salt)\n-    secret = force_bytes(secret)\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.utils.crypto import salted_hmac\n+    from django.utils.crypto import constant_time_compare\n+    from django.conf import settings\n+    \n+    user = None\n     try:\n-        hasher = getattr(hashlib, algorithm)\n-    except AttributeError as e:\n-        raise InvalidAlgorithm(\n-            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n-        ) from e\n-    # We need to generate a derived key from our base key.  We can do this by\n-    # passing the key_salt and our base key through a pseudo-random function.\n-    key = hasher(key_salt + secret).digest()\n-    # If len(key_salt + secret) > block size of the hash algorithm, the above\n-    # line is redundant and could be replaced by key = key_salt + secret, since\n-    # the hmac module does the same thing for keys longer than the block size.\n-    # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n \n RANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n",
    "variant_7": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..c3ff9dea04 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -197,11 +197,37 @@ def get_user(request):\n             backend = load_backend(backend_path)\n             user = backend.get_user(user_id)\n             # Verify the session\n+\n             if hasattr(user, \"get_session_auth_hash\"):\n                 session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n-                )\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    from django.utils.crypto import salted_hmac\n+                    key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                    \n+                    # Check current SECRET_KEY first\n+                    expected_hash = salted_hmac(\n+                        key_salt,\n+                        user.password,\n+                        secret=settings.SECRET_KEY,\n+                        algorithm=\"sha256\",\n+                    ).hexdigest()\n+                    if constant_time_compare(session_hash, expected_hash):\n+                        session_hash_verified = True\n+                    else:\n+                        # Try fallback keys\n+                        for fallback_key in getattr(settings, 'SECRET_KEY_FALLBACKS', []):\n+                            expected_hash = salted_hmac(\n+                                key_salt,\n+                                user.password,\n+                                secret=fallback_key,\n+                                algorithm=\"sha256\",\n+                            ).hexdigest()\n+                            if constant_time_compare(session_hash, expected_hash):\n+                                session_hash_verified = True\n+                                break\n+                \n                 if not session_hash_verified:\n                     request.session.flush()\n                     user = None\ndiff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 5ee30bf59c..6c7a3afbb0 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -131,16 +131,48 @@ class AbstractBaseUser(models.Model):\n         \"\"\"\n         return is_password_usable(self.password)\n \n-    def get_session_auth_hash(self):\n-        \"\"\"\n-        Return an HMAC of the password field.\n-        \"\"\"\n-        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n-        return salted_hmac(\n-            key_salt,\n-            self.password,\n-            algorithm=\"sha256\",\n-        ).hexdigest()\n+\n+def get_user(request):\n+    \"\"\"\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.conf import settings\n+    from django.utils.crypto import salted_hmac, constant_time_compare\n+    \n+    user = None\n+    try:\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n     @classmethod\n     def get_email_field_name(cls):\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..4b6fafb975 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,33 +15,49 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n-def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n-    \"\"\"\n-    Return the HMAC of 'value', using a key generated from key_salt and a\n-    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n-    but any algorithm name supported by hashlib can be passed.\n \n-    A different key_salt should be passed in for every application of HMAC.\n+def get_user(request):\n     \"\"\"\n-    if secret is None:\n-        secret = settings.SECRET_KEY\n-\n-    key_salt = force_bytes(key_salt)\n-    secret = force_bytes(secret)\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.utils.crypto import salted_hmac\n+    from django.utils.crypto import constant_time_compare\n+    from django.conf import settings\n+    \n+    user = None\n     try:\n-        hasher = getattr(hashlib, algorithm)\n-    except AttributeError as e:\n-        raise InvalidAlgorithm(\n-            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n-        ) from e\n-    # We need to generate a derived key from our base key.  We can do this by\n-    # passing the key_salt and our base key through a pseudo-random function.\n-    key = hasher(key_salt + secret).digest()\n-    # If len(key_salt + secret) > block size of the hash algorithm, the above\n-    # line is redundant and could be replaced by key = key_salt + secret, since\n-    # the hmac module does the same thing for keys longer than the block size.\n-    # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n \n RANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n",
    "variant_8": "diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py\nindex 155330c596..17e668ac65 100644\n--- a/django/contrib/auth/__init__.py\n+++ b/django/contrib/auth/__init__.py\n@@ -197,14 +197,32 @@ def get_user(request):\n             backend = load_backend(backend_path)\n             user = backend.get_user(user_id)\n             # Verify the session\n-            if hasattr(user, \"get_session_auth_hash\"):\n-                session_hash = request.session.get(HASH_SESSION_KEY)\n-                session_hash_verified = session_hash and constant_time_compare(\n-                    session_hash, user.get_session_auth_hash()\n-                )\n-                if not session_hash_verified:\n-                    request.session.flush()\n-                    user = None\n+\n+if hasattr(user, \"get_session_auth_hash\"):\n+    session_hash = request.session.get(HASH_SESSION_KEY)\n+    session_hash_verified = False\n+    if session_hash:\n+        # Try current key first, then fallback keys\n+        from django.utils.crypto import salted_hmac\n+        keys_to_try = [settings.SECRET_KEY]\n+        if hasattr(settings, 'SECRET_KEY_FALLBACKS'):\n+            keys_to_try.extend(settings.SECRET_KEY_FALLBACKS)\n+        \n+        for secret_key in keys_to_try:\n+            # Generate hash with this key for comparison\n+            key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+            expected_hash = salted_hmac(\n+                key_salt,\n+                user.password,\n+                secret=secret_key,\n+                algorithm=\"sha256\",\n+            ).hexdigest()\n+            if constant_time_compare(session_hash, expected_hash):\n+                session_hash_verified = True\n+                break\n+    if not session_hash_verified:\n+        request.session.flush()\n+        user = None\n \n     return user or AnonymousUser()\n \ndiff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py\nindex 5ee30bf59c..122332833e 100644\n--- a/django/contrib/auth/base_user.py\n+++ b/django/contrib/auth/base_user.py\n@@ -131,16 +131,46 @@ class AbstractBaseUser(models.Model):\n         \"\"\"\n         return is_password_usable(self.password)\n \n-    def get_session_auth_hash(self):\n-        \"\"\"\n-        Return an HMAC of the password field.\n-        \"\"\"\n-        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n-        return salted_hmac(\n-            key_salt,\n-            self.password,\n-            algorithm=\"sha256\",\n-        ).hexdigest()\n+\n+def get_user(request):\n+    \"\"\"\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    user = None\n+    try:\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    from django.utils.crypto import salted_hmac\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n     @classmethod\n     def get_email_field_name(cls):\ndiff --git a/django/utils/crypto.py b/django/utils/crypto.py\nindex 1c0e7001c6..4b6fafb975 100644\n--- a/django/utils/crypto.py\n+++ b/django/utils/crypto.py\n@@ -15,33 +15,49 @@ class InvalidAlgorithm(ValueError):\n     pass\n \n \n-def salted_hmac(key_salt, value, secret=None, *, algorithm=\"sha1\"):\n-    \"\"\"\n-    Return the HMAC of 'value', using a key generated from key_salt and a\n-    secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,\n-    but any algorithm name supported by hashlib can be passed.\n \n-    A different key_salt should be passed in for every application of HMAC.\n+def get_user(request):\n     \"\"\"\n-    if secret is None:\n-        secret = settings.SECRET_KEY\n-\n-    key_salt = force_bytes(key_salt)\n-    secret = force_bytes(secret)\n+    Return the user model instance associated with the given request session.\n+    If no user is retrieved, return an instance of `AnonymousUser`.\n+    \"\"\"\n+    from django.contrib.auth.models import AnonymousUser\n+    from django.utils.crypto import salted_hmac\n+    from django.utils.crypto import constant_time_compare\n+    from django.conf import settings\n+    \n+    user = None\n     try:\n-        hasher = getattr(hashlib, algorithm)\n-    except AttributeError as e:\n-        raise InvalidAlgorithm(\n-            \"%r is not an algorithm accepted by the hashlib module.\" % algorithm\n-        ) from e\n-    # We need to generate a derived key from our base key.  We can do this by\n-    # passing the key_salt and our base key through a pseudo-random function.\n-    key = hasher(key_salt + secret).digest()\n-    # If len(key_salt + secret) > block size of the hash algorithm, the above\n-    # line is redundant and could be replaced by key = key_salt + secret, since\n-    # the hmac module does the same thing for keys longer than the block size.\n-    # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=force_bytes(value), digestmod=hasher)\n+        user_id = _get_user_session_key(request)\n+        backend_path = request.session[BACKEND_SESSION_KEY]\n+    except KeyError:\n+        pass\n+    else:\n+        if backend_path in settings.AUTHENTICATION_BACKENDS:\n+            backend = load_backend(backend_path)\n+            user = backend.get_user(user_id)\n+            # Verify the session\n+            if hasattr(user, \"get_session_auth_hash\"):\n+                session_hash = request.session.get(HASH_SESSION_KEY)\n+                session_hash_verified = False\n+                if session_hash:\n+                    # Try current key first, then fallback keys\n+                    for secret_key in [settings.SECRET_KEY, *getattr(settings, 'SECRET_KEY_FALLBACKS', [])]:\n+                        # Generate hash with this key for comparison\n+                        key_salt = \"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash\"\n+                        expected_hash = salted_hmac(\n+                            key_salt,\n+                            user.password,\n+                            secret=secret_key,\n+                            algorithm=\"sha256\",\n+                        ).hexdigest()\n+                        if constant_time_compare(session_hash, expected_hash):\n+                            session_hash_verified = True\n+                            break\n+                if not session_hash_verified:\n+                    request.session.flush()\n+                    user = None\n+    return user or AnonymousUser()\n \n \n RANDOM_STRING_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n"
  }
}