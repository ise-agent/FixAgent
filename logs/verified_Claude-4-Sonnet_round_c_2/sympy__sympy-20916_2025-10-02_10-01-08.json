{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/printing/pretty/pretty_symbology.py lines 540-548)": "\n    def pretty_list(l, mapping):\n        result = []\n        for s in l:\n            pretty = mapping.get(s)\n            if pretty is None:\n                try:  # match by separate characters\n                    pretty_chars = []\n                    for c in s:\n                        if c in mapping:\n                            pretty_chars.append(mapping[c])\n                        else:\n                            # For individual characters that can't be mapped, keep them as-is\n                            # but don't fail the entire subscript/superscript formatting\n                            pretty_chars.append(c)\n                    pretty = ''.join(pretty_chars)\n                except (TypeError, KeyError):\n                    # Only return None if we can't process the string at all\n                    return None\n            result.append(pretty)\n        return result\n",
    "Location 2 (/root/hy/projects/sympy/sympy/printing/pretty/pretty_symbology.py lines 557-559)": "\ndef pretty_list(l, mapping):\n    result = []\n    has_failures = False\n    for s in l:\n        try:\n            pretty = mapping[s]\n            result.append(pretty)\n        except KeyError:\n            # For individual character failures, try to handle gracefully\n            if len(s) == 1 and s.isdigit():\n                # Digits should still get subscript formatting even if base symbol fails\n                if mapping == sub:\n                    result.append(sub.get(s, s))\n                elif mapping == sup:\n                    result.append(sup.get(s, s))\n                else:\n                    result.append(s)\n                    has_failures = True\n            else:\n                result.append(s)\n                has_failures = True\n    \n    # Return partial results for mixed formatting instead of all-or-nothing\n    return result if not has_failures or any(r != s for r, s in zip(result, l)) else None\n",
    "Location 3 (/root/hy/projects/sympy/sympy/printing/pretty/pretty_symbology.py lines 550-554)": "\n    def pretty_list(l, mapping):\n        result = []\n        for s in l:\n            pretty = mapping.get(s)\n            if pretty is None:\n                try:  # match by separate characters\n                    pretty = ''.join([mapping[c] for c in s])\n                except (TypeError, KeyError):\n                    # Try partial mapping - map what we can, keep what we can't\n                    partial_result = []\n                    for c in s:\n                        mapped_char = mapping.get(c)\n                        if mapped_char is not None:\n                            partial_result.append(mapped_char)\n                        else:\n                            partial_result.append(c)\n                    pretty = ''.join(partial_result)\n            result.append(pretty)\n        return result\n\n    pretty_sups = pretty_list(sups, sup)\n    pretty_subs = pretty_list(subs, sub)\n",
    "Location 4 (/root/hy/projects/sympy/sympy/printing/pretty/pretty_symbology.py lines 185-186)": "\n# Build a more flexible subscript list that handles mixed cases\nfor gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n    sub[gl] = GSUB(gl)\n\n# Add support for standalone digit subscripts regardless of base symbol\n# This ensures digits can be subscripted even when attached to unsupported Greek letters\nfor d in [str(i) for i in range(10)]:\n    sub[d] = DSUB(d)\n",
    "Location 5 (/root/hy/projects/sympy/sympy/printing/pretty/pretty_symbology.py lines 542-546)": "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty = ''.join([mapping[c] for c in s])\n            except (TypeError, KeyError):\n                # Instead of returning None for the entire list,\n                # use the original string for this element\n                pretty = s\n        result.append(pretty)\n    return result\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/printing/pretty/pretty_symbology.py lines 540-548)": [
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty_chars = []\n                for c in s:\n                    if c in mapping:\n                        pretty_chars.append(mapping[c])\n                    else:\n                        # If character can't be mapped, use original character\n                        pretty_chars.append(c)\n                pretty = ''.join(pretty_chars)\n            except (TypeError, KeyError):\n                pretty = s  # Use original string as fallback\n        result.append(pretty)\n    return result\n",
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty_chars = []\n                for c in s:\n                    if c in mapping:\n                        pretty_chars.append(mapping[c])\n                    else:\n                        # Return None only if no characters can be mapped\n                        # This allows partial success for mixed cases\n                        if not any(char in mapping for char in s):\n                            return None\n                        pretty_chars.append(c)\n                pretty = ''.join(pretty_chars)\n            except (TypeError, KeyError):\n                return None\n        result.append(pretty)\n    return result\n",
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty = ''.join([mapping[c] for c in s])\n            except (TypeError, KeyError):\n                # Instead of returning None for the entire list,\n                # try to format individual characters and use fallback for unmappable ones\n                pretty_chars = []\n                for c in s:\n                    mapped_char = mapping.get(c)\n                    if mapped_char is not None:\n                        pretty_chars.append(mapped_char)\n                    else:\n                        pretty_chars.append(c)  # use original character as fallback\n                pretty = ''.join(pretty_chars)\n        result.append(pretty)\n    return result\n",
      "\n    def pretty_list(l, mapping):\n        result = []\n        for s in l:\n            pretty = mapping.get(s)\n            if pretty is None:\n                try:  # match by separate characters\n                    pretty = ''.join([mapping[c] for c in s])\n                except (TypeError, KeyError):\n                    # Instead of failing completely, try partial mapping\n                    partial_pretty = []\n                    for c in s:\n                        mapped_c = mapping.get(c)\n                        if mapped_c is not None:\n                            partial_pretty.append(mapped_c)\n                        else:\n                            partial_pretty.append(c)\n                    pretty = ''.join(partial_pretty)\n            result.append(pretty)\n        return result\n",
      "\n    def pretty_list(l, mapping):\n        result = []\n        for s in l:\n            pretty = mapping.get(s)\n            if pretty is None:\n                try:  # match by separate characters\n                    pretty_chars = []\n                    for c in s:\n                        if c in mapping:\n                            pretty_chars.append(mapping[c])\n                        else:\n                            # If character can't be mapped, keep original and mark as partial failure\n                            pretty_chars.append(c)\n                    pretty = ''.join(pretty_chars)\n                    # Only return None if no characters could be mapped at all\n                    if all(c not in mapping for c in s):\n                        return None\n                except (TypeError, KeyError):\n                    return None\n            result.append(pretty)\n        return result\n",
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty = ''.join([mapping[c] for c in s])\n            except (TypeError, KeyError):\n                # Instead of returning None for the entire list,\n                # try character-by-character with fallback\n                mixed_result = []\n                for c in s:\n                    mapped_char = mapping.get(c)\n                    if mapped_char is not None:\n                        mixed_result.append(mapped_char)\n                    else:\n                        mixed_result.append(c)  # fallback to original character\n                pretty = ''.join(mixed_result)\n        result.append(pretty)\n    return result\n",
      "\n    def pretty_list(l, mapping):\n        result = []\n        for s in l:\n            pretty = mapping.get(s)\n            if pretty is None:\n                try:  # match by separate characters\n                    pretty = ''.join([mapping[c] for c in s])\n                except (TypeError, KeyError):\n                    # Instead of returning None, try to map individual characters\n                    # and use fallback for unmappable ones\n                    pretty_chars = []\n                    for c in s:\n                        if c in mapping:\n                            pretty_chars.append(mapping[c])\n                        else:\n                            pretty_chars.append(c)\n                    pretty = ''.join(pretty_chars) if pretty_chars else s\n            result.append(pretty)\n        return result\n",
      "\n    def pretty_list(l, mapping):\n        result = []\n        for s in l:\n            pretty = mapping.get(s)\n            if pretty is None:\n                try:  # match by separate characters\n                    pretty = ''.join([mapping[c] for c in s])\n                except (TypeError, KeyError):\n                    # Instead of failing completely, try partial mapping\n                    partial_pretty = []\n                    for c in s:\n                        mapped_c = mapping.get(c)\n                        if mapped_c is not None:\n                            partial_pretty.append(mapped_c)\n                        else:\n                            partial_pretty.append(c)\n                    pretty = ''.join(partial_pretty)\n            result.append(pretty)\n        return result\n"
    ],
    "Location 2 (/root/hy/projects/sympy/sympy/printing/pretty/pretty_symbology.py lines 557-559)": [
      "\ndef pretty_list(lista, mapping):\n    result = []\n    for s in lista:\n        pretty = translate(s, mapping)\n        if pretty is None:\n            # Instead of failing completely, try character-by-character\n            char_results = []\n            for char in s:\n                char_pretty = translate(char, mapping)\n                if char_pretty is not None:\n                    char_results.append(char_pretty)\n                else:\n                    # For individual characters that can't be mapped, use original\n                    char_results.append(char)\n            if char_results:\n                result.append(''.join(char_results))\n            else:\n                return None\n        else:\n            result.append(pretty)\n    return result\n",
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            # For mixed cases, allow partial success - don't fail the entire list\n            # if some characters can't be mapped but others can\n            if len(s) == 1:\n                return None  # Single character that can't be mapped\n            # Try character-by-character for multi-character strings\n            char_results = []\n            all_failed = True\n            for char in s:\n                char_pretty = mapping.get(char)\n                if char_pretty is not None:\n                    char_results.append(char_pretty)\n                    all_failed = False\n                else:\n                    char_results.append(char)\n            if all_failed:\n                return None\n            result.append(''.join(char_results))\n        else:\n            result.append(pretty)\n    return result\n",
      "\n    # glue the results into one string\n    if pretty_subs is None:  # nice formatting of subs/subs did not work\n        # Try to format individual characters in subscripts, preserving unicode for digits\n        formatted_subs = []\n        for s in subs:\n            try:\n                # Try to format each character individually\n                formatted_chars = []\n                for char in s:\n                    if char in sub:\n                        formatted_chars.append(sub[char])\n                    else:\n                        formatted_chars.append(char)\n                formatted_subs.append(''.join(formatted_chars))\n            except (KeyError, TypeError):\n                # Fallback to original character if formatting fails\n                formatted_subs.append(translate(s, bold_name))\n        \n        if formatted_subs:\n            name += '_' + '_'.join(formatted_subs)\n",
      "\n    def pretty_list(elements, mapping):\n        result = []\n        for element in elements:\n            try:\n                pretty = mapping[element]\n                result.append(pretty)\n            except KeyError:\n                # For mixed subscripts, allow partial success\n                # If it's a digit that can be subscripted, use it\n                if element in '0123456789+-=()':\n                    digit_mapping = {'0': '₀', '1': '₁', '2': '₂', '3': '₃', '4': '₄',\n                                   '5': '₅', '6': '₆', '7': '₇', '8': '₈', '9': '₉',\n                                   '+': '₊', '-': '₋', '=': '₌', '(': '₍', ')': '₎'}\n                    if element in digit_mapping:\n                        result.append(digit_mapping[element])\n                        continue\n                # For non-subscriptable characters, use regular format\n                result.append(element)\n        return result if result else None\n\n    pretty_sups = pretty_list(sups, sup)\n    pretty_subs = pretty_list(subs, sub)\n\n    # glue the results into one string\n    if pretty_subs is None and pretty_sups is None:  # no formatting worked at all\n        if subs:\n            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n",
      "\n    # glue the results into one string\n    if pretty_subs is None:  # nice formatting of subs/subs did not work\n        # Try to format individual characters, preserving unicode for digits\n        formatted_subs = []\n        for s in subs:\n            try:\n                # Try to format each character individually\n                formatted_char = translate(s, sub)\n                formatted_subs.append(formatted_char)\n            except KeyError:\n                # If individual character fails, use regular formatting\n                formatted_subs.append(translate(s, bold_name))\n        \n        if subs:\n            name += '_' + '_'.join(formatted_subs)\n",
      "\ndef pretty_symbol(sym_name, bold_name=False, compat_greek_name=None):\n    \"\"\"return pretty representation of a symbol\"\"\"\n    # let's split up the symbol name into symbol + subscripts/superscripts\n    # e.g. 'x1' -> 'x', [] ['1']\n    # e.g. 'x_1^2' -> 'x', ['1'], ['2']\n    sym, sups, subs = split_super_sub(sym_name)\n\n    # translate symbol\n    sym = translate(sym, bold_name)\n\n    # translate sups/subs to pretty format\n    def pretty_list(l, mapping):\n        result = []\n        for s in l:\n            pretty = None\n            try:\n                pretty = mapping[int(s)]\n            except (KeyError, ValueError):\n                try:\n                    pretty = mapping[s]\n                except KeyError:\n                    # Character-by-character approach for mixed cases\n                    if len(s) == 1:\n                        # Single character that can't be mapped, return None for this character\n                        return None\n                    else:\n                        # Multi-character string, try to map each character\n                        char_results = []\n                        all_failed = True\n                        for char in s:\n                            try:\n                                char_pretty = mapping[int(char)]\n                                char_results.append(char_pretty)\n                                all_failed = False\n                            except (KeyError, ValueError):\n                                try:\n                                    char_pretty = mapping[char]\n                                    char_results.append(char_pretty)\n                                    all_failed = False\n                                except KeyError:\n                                    # This character can't be mapped, use original\n                                    char_results.append(char)\n                        \n                        if all_failed:\n                            return None\n                        else:\n                            pretty = ''.join(char_results)\n            \n            if pretty is not None:\n                result.append(pretty)\n            else:\n                result.append(s)\n        return result\n\n    pretty_sups = pretty_list(sups, sup)\n    pretty_subs = pretty_list(subs, sub)\n\n    # glue the results into one string\n    if pretty_subs is None and pretty_sups is None:  # nice formatting completely failed\n        if subs:\n            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n        if sups:\n            name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n        return name\n    else:\n        # Use pretty formatting where available, fallback where not\n        if pretty_sups is not None:\n            sups_result = ' '.join(pretty_sups)\n        else:\n            sups_result = '__'+'__'.join([translate(s, bold_name) for s in sups]) if sups else ''\n            \n        if pretty_subs is not None:\n            subs_result = ' '.join(pretty_subs)\n        else:\n            subs_result = '_'+'_'.join([translate(s, bold_name) for s in subs]) if subs else ''\n\n    return ''.join([name, sups_result, subs_result])\n",
      "\ndef pretty_list(s, t):\n    \"\"\"\n    Helper function for pretty_symbol that converts a list of symbols\n    to their pretty-printed forms. Returns None if any symbol cannot\n    be converted, otherwise returns a list of pretty symbols.\n    \"\"\"\n    result = []\n    for sym in s:\n        try:\n            pretty = t[sym]\n            result.append(pretty)\n        except KeyError:\n            # If this is a digit and we're doing subscripts, try to convert it\n            if t == sub and sym.isdigit():\n                try:\n                    digit_sub = sub[sym]\n                    result.append(digit_sub)\n                    continue\n                except KeyError:\n                    pass\n            # For any other failure, use the original symbol\n            result.append(sym)\n    return result\n",
      "\n    # glue the results into one string\n    if pretty_subs is None:  # nice formatting of subs/subs did not work\n        # Try to format individual characters in subscripts, preserving unicode for digits\n        formatted_subs = []\n        if subs:\n            for s in subs:\n                try:\n                    # Try to format each character individually\n                    formatted_chars = []\n                    for char in s:\n                        if char.isdigit() and char in sub:\n                            formatted_chars.append(sub[char])\n                        else:\n                            formatted_chars.append(translate(char, bold_name))\n                    formatted_subs.append(''.join(formatted_chars))\n                except:\n                    formatted_subs.append(translate(s, bold_name))\n            name += '_' + '_'.join(formatted_subs)\n"
    ],
    "Location 3 (/root/hy/projects/sympy/sympy/printing/pretty/pretty_symbology.py lines 550-554)": [
      "\n    pretty_sups = pretty_list(sups, sup)\n    if pretty_sups is not None:\n        pretty_subs = pretty_list(subs, sub)\n        if pretty_subs is None and subs:\n            # Try character-by-character mapping for subscripts\n            pretty_subs = []\n            for s in subs:\n                char_result = []\n                for c in s:\n                    mapped = sub.get(c)\n                    if mapped is not None:\n                        char_result.append(mapped)\n                    else:\n                        # If individual character can't be mapped, keep original\n                        char_result.append(c)\n                pretty_subs.append(''.join(char_result))\n    else:\n        pretty_subs = None\n",
      "\n    # Check if we can format superscripts nicely\n    pretty_sups = pretty_list(sups, sup)\n    \n    # For subscripts, try a more flexible approach\n    if pretty_sups is not None:\n        pretty_subs = pretty_list(subs, sub)\n        # If subscripts failed but we have digits that could be formatted,\n        # try formatting each subscript component separately\n        if pretty_subs is None and subs:\n            mixed_subs = []\n            for s in subs:\n                # Try to format this subscript component\n                component_result = pretty_list([s], sub)\n                if component_result is not None:\n                    mixed_subs.append(component_result[0])\n                else:\n                    # Check if it's just digits that we can format\n                    if s.isdigit():\n                        try:\n                            digit_formatted = ''.join([sub[c] for c in s])\n                            mixed_subs.append(digit_formatted)\n                        except KeyError:\n                            mixed_subs = None\n                            break\n                    else:\n                        mixed_subs = None\n                        break\n            pretty_subs = mixed_subs\n    else:\n        pretty_subs = None\n",
      "\n    pretty_sups = pretty_list(sups, sup)\n    if pretty_sups is not None:\n        pretty_subs = pretty_list(subs, sub)\n    else:\n        # Even if superscripts failed, still try subscripts\n        pretty_subs = pretty_list(subs, sub)\n",
      "\n    pretty_sups = pretty_list(sups, sup)\n    if pretty_sups is not None:\n        pretty_subs = pretty_list(subs, sub)\n        # If subs formatting partially failed, try character-by-character for digits\n        if pretty_subs is None and subs:\n            mixed_subs = []\n            for s in subs:\n                if s.isdigit() and s in sub:\n                    mixed_subs.append(sub[s])\n                else:\n                    mixed_subs = None\n                    break\n            pretty_subs = mixed_subs\n    else:\n        pretty_subs = None\n",
      "\n    pretty_sups = pretty_list(sups, sup)\n    if pretty_sups is not None:\n        pretty_subs = pretty_list(subs, sub)\n        # If pretty_subs failed but we have digits that could be subscripted,\n        # try to format them individually\n        if pretty_subs is None and subs:\n            mixed_subs = []\n            for s in subs:\n                # Try to format each character individually\n                pretty_chars = []\n                for c in s:\n                    if c in sub:\n                        pretty_chars.append(sub[c])\n                    else:\n                        # If any character can't be subscripted, use fallback for this entire substring\n                        pretty_chars = None\n                        break\n                if pretty_chars is not None:\n                    mixed_subs.append(''.join(pretty_chars))\n                else:\n                    # If we have any failures, fall back to None for consistency\n                    mixed_subs = None\n                    break\n            pretty_subs = mixed_subs\n    else:\n        pretty_subs = None\n",
      "\n    # Try to use pretty formatting for subscripts and superscripts\n    def pretty_list(l, mapping):\n        result = []\n        for s in l:\n            pretty = mapping.get(s)\n            if pretty is None:\n                try:  # match by separate characters\n                    pretty = ''.join([mapping[c] for c in s])\n                except (TypeError, KeyError):\n                    # Instead of returning None, use the original character\n                    # This allows partial formatting where some chars work\n                    pretty = s\n            result.append(pretty)\n        return result\n\n    pretty_sups = pretty_list(sups, sup)\n    pretty_subs = pretty_list(subs, sub)\n",
      "\n    # Convert characters to pretty representations, allowing partial success\n    def pretty_list_tolerant(l, mapping):\n        if not mapping:\n            return None\n        result = []\n        for s in l:\n            pretty = mapping.get(s)\n            if pretty is None:\n                try:  # match by separate characters\n                    pretty = ''.join([mapping[c] for c in s])\n                except (TypeError, KeyError):\n                    # Instead of returning None for the whole list,\n                    # use the original character when mapping fails\n                    pretty = s\n            result.append(pretty)\n        return result\n\n    pretty_sups = pretty_list_tolerant(sups, sup)\n    pretty_subs = pretty_list_tolerant(subs, sub)\n",
      "\n    pretty_sups = pretty_list(sups, sup)\n    if pretty_sups is not None:\n        pretty_subs = pretty_list(subs, sub)\n    else:\n        # Try to format subscripts even if superscripts failed\n        pretty_subs = pretty_list(subs, sub)\n"
    ],
    "Location 4 (/root/hy/projects/sympy/sympy/printing/pretty/pretty_symbology.py lines 185-186)": [
      "\nfor gl in ['alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi']:\n    sub[gl] = GSUB(gl)\n",
      "\nfor gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n    sub[gl] = GSUB(gl)\n\n# Note: omega cannot be added to subscripts due to Unicode limitations,\n# but this should not prevent digit subscripts from working with omega\n",
      "\nfor gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n    sub[gl] = GSUB(gl)\n",
      "\nfor gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n    sub[gl] = GSUB(gl)\n",
      "\n# Greek subscripts - only include letters that have Unicode subscript equivalents\nfor gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n    sub[gl] = GSUB(gl)\n# Note: 'omega' is intentionally excluded as it lacks a proper Unicode subscript\n# but this should not prevent digit subscripts from working with omega\n",
      "\n# Enhanced Greek subscript definitions - add more supported letters\nfor gl in ['beta', 'gamma', 'rho', 'phi', 'chi', 'alpha', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'pi', 'sigma', 'tau', 'upsilon', 'psi']:\n    # Only add if the subscript character exists in Unicode\n    try:\n        subscript_char = GSUB(gl)\n        if subscript_char and ord(subscript_char) > 127:  # Valid Unicode subscript\n            sub[gl] = subscript_char\n    except (KeyError, AttributeError):\n        # Skip Greek letters without valid subscript representations\n        pass\n",
      "\nfor gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n    sub[gl] = GSUB(gl)\n",
      "\nfor gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n    sub[gl] = GSUB(gl)\n\n# Note: omega and other Greek letters not in the above list will be handled\n# by mixed formatting logic in pretty_list to allow digit subscripts\n"
    ],
    "Location 5 (/root/hy/projects/sympy/sympy/printing/pretty/pretty_symbology.py lines 542-546)": [
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty = ''.join([mapping[c] for c in s])\n            except (TypeError, KeyError):\n                # Instead of failing completely, try character-by-character with fallback\n                pretty_chars = []\n                for c in s:\n                    mapped_char = mapping.get(c)\n                    if mapped_char is not None:\n                        pretty_chars.append(mapped_char)\n                    else:\n                        pretty_chars.append(c)  # fallback to original character\n                pretty = ''.join(pretty_chars)\n        result.append(pretty)\n    return result\n",
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty = ''.join([mapping[c] for c in s])\n            except (TypeError, KeyError):\n                # Instead of returning None, try partial mapping\n                partial_result = []\n                for c in s:\n                    mapped_char = mapping.get(c)\n                    if mapped_char is not None:\n                        partial_result.append(mapped_char)\n                    else:\n                        partial_result.append(c)\n                pretty = ''.join(partial_result)\n        result.append(pretty)\n    return result\n",
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty = ''.join([mapping[c] for c in s])\n            except (TypeError, KeyError):\n                # Instead of returning None for the entire list,\n                # use the original string for this element\n                pretty = s\n        result.append(pretty)\n    return result\n",
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty = ''.join([mapping[c] for c in s])\n            except (TypeError, KeyError):\n                # Instead of returning None, try partial mapping\n                # Map characters that can be mapped, keep others as-is\n                try:\n                    pretty_chars = []\n                    for c in s:\n                        mapped_c = mapping.get(c)\n                        if mapped_c is not None:\n                            pretty_chars.append(mapped_c)\n                        else:\n                            # For unmappable characters, keep original\n                            pretty_chars.append(c)\n                    pretty = ''.join(pretty_chars)\n                except (TypeError, AttributeError):\n                    # If all else fails, use original string\n                    pretty = s\n        result.append(pretty)\n    return result\n",
      "\n    def pretty_list(l, mapping):\n        result = []\n        for s in l:\n            pretty = mapping.get(s)\n            if pretty is None:\n                try:  # match by separate characters\n                    pretty = ''.join([mapping[c] for c in s])\n                except (TypeError, KeyError):\n                    # Instead of returning None for the entire list,\n                    # try to preserve partial unicode formatting\n                    partial_pretty = []\n                    for c in s:\n                        mapped_c = mapping.get(c)\n                        if mapped_c is not None:\n                            partial_pretty.append(mapped_c)\n                        else:\n                            partial_pretty.append(c)\n                    pretty = ''.join(partial_pretty)\n            result.append(pretty)\n        return result\n",
      "\n    def pretty_list(l, mapping):\n        result = []\n        for s in l:\n            pretty = mapping.get(s)\n            if pretty is None:\n                try:  # match by separate characters\n                    pretty = ''.join([mapping[c] for c in s])\n                except (TypeError, KeyError):\n                    # Instead of returning None for the entire list,\n                    # try character-by-character with fallback\n                    pretty_chars = []\n                    for c in s:\n                        mapped_char = mapping.get(c)\n                        if mapped_char is not None:\n                            pretty_chars.append(mapped_char)\n                        else:\n                            pretty_chars.append(c)  # fallback to original character\n                    pretty = ''.join(pretty_chars)\n            result.append(pretty)\n        return result\n",
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty = ''.join([mapping[c] for c in s])\n            except (TypeError, KeyError):\n                # Instead of returning None for the entire list,\n                # use the original string for this element\n                pretty = s\n        result.append(pretty)\n    return result\n",
      "\ndef pretty_list(l, mapping):\n    result = []\n    for s in l:\n        pretty = mapping.get(s)\n        if pretty is None:\n            try:  # match by separate characters\n                pretty = ''.join([mapping[c] for c in s])\n            except (TypeError, KeyError):\n                # Instead of failing completely, try character-by-character\n                # and use original characters for unmappable ones\n                try:\n                    pretty_chars = []\n                    for c in s:\n                        mapped_char = mapping.get(c, c)  # Use original char if not mappable\n                        pretty_chars.append(mapped_char)\n                    pretty = ''.join(pretty_chars)\n                except (TypeError, AttributeError):\n                    pretty = s  # Use original string as fallback\n        result.append(pretty)\n    return result\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..62b42d696b 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -182,6 +182,7 @@ def xstr(*args):\n for l in 'in':\n     sup[l] = LSUP(l)\n \n+\n for gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n     sub[gl] = GSUB(gl)\n \n@@ -537,23 +538,27 @@ def translate(s, bold_name) :\n     # not used at all.\n     def pretty_list(l, mapping):\n         result = []\n+\n         for s in l:\n             pretty = mapping.get(s)\n             if pretty is None:\n                 try:  # match by separate characters\n                     pretty = ''.join([mapping[c] for c in s])\n                 except (TypeError, KeyError):\n-                    return None\n+                    # Instead of returning None for entire list, use original character\n+                    pretty = s\n+            result.append(pretty)\n+        return result\n             result.append(pretty)\n         return result\n \n+\n     pretty_sups = pretty_list(sups, sup)\n-    if pretty_sups is not None:\n-        pretty_subs = pretty_list(subs, sub)\n-    else:\n-        pretty_subs = None\n+    # Always try to process subscripts regardless of superscript success\n+    pretty_subs = pretty_list(subs, sub)\n \n     # glue the results into one string\n+\n     if pretty_subs is None:  # nice formatting of sups/subs did not work\n         if subs:\n             name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n",
    "variant_0": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..17d08bb72b 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -182,9 +182,16 @@ def xstr(*args):\n for l in 'in':\n     sup[l] = LSUP(l)\n \n+\n+# Build a more flexible subscript list that handles mixed cases\n for gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n     sub[gl] = GSUB(gl)\n \n+# Add support for standalone digit subscripts regardless of base symbol\n+# This ensures digits can be subscripted even when attached to unsupported Greek letters\n+for d in [str(i) for i in range(10)]:\n+    sub[d] = DSUB(d)\n+\n for d in [str(i) for i in range(10)]:\n     sub[d] = DSUB(d)\n     sup[d] = DSUP(d)\n@@ -535,28 +542,89 @@ def translate(s, bold_name) :\n \n     # Let's prettify sups/subs. If it fails at one of them, pretty sups/subs are\n     # not used at all.\n+    def pretty_list(l, mapping):\n+        result = []\n+\n     def pretty_list(l, mapping):\n         result = []\n         for s in l:\n             pretty = mapping.get(s)\n             if pretty is None:\n                 try:  # match by separate characters\n-                    pretty = ''.join([mapping[c] for c in s])\n+                    pretty_chars = []\n+                    for c in s:\n+                        if c in mapping:\n+                            pretty_chars.append(mapping[c])\n+                        else:\n+                            # For individual characters that can't be mapped, keep them as-is\n+                            # but don't fail the entire subscript/superscript formatting\n+                            pretty_chars.append(c)\n+                    pretty = ''.join(pretty_chars)\n                 except (TypeError, KeyError):\n+                    # Only return None if we can't process the string at all\n                     return None\n             result.append(pretty)\n+        return result\n+                pretty = ''.join([mapping[c] for c in s])\n+            except (TypeError, KeyError):\n+                # Instead of returning None for the entire list,\n+                # use the original string for this element\n+                pretty = s\n+        result.append(pretty)\n+    return result\n+            result.append(pretty)\n+        return result\n+\n+\n+    def pretty_list(l, mapping):\n+        result = []\n+        for s in l:\n+            pretty = mapping.get(s)\n+            if pretty is None:\n+                try:  # match by separate characters\n+                    pretty = ''.join([mapping[c] for c in s])\n+                except (TypeError, KeyError):\n+                    # Try partial mapping - map what we can, keep what we can't\n+                    partial_result = []\n+                    for c in s:\n+                        mapped_char = mapping.get(c)\n+                        if mapped_char is not None:\n+                            partial_result.append(mapped_char)\n+                        else:\n+                            partial_result.append(c)\n+                    pretty = ''.join(partial_result)\n+            result.append(pretty)\n         return result\n \n     pretty_sups = pretty_list(sups, sup)\n-    if pretty_sups is not None:\n-        pretty_subs = pretty_list(subs, sub)\n-    else:\n-        pretty_subs = None\n+    pretty_subs = pretty_list(subs, sub)\n \n     # glue the results into one string\n-    if pretty_subs is None:  # nice formatting of sups/subs did not work\n-        if subs:\n-            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n+\n+def pretty_list(l, mapping):\n+    result = []\n+    has_failures = False\n+    for s in l:\n+        try:\n+            pretty = mapping[s]\n+            result.append(pretty)\n+        except KeyError:\n+            # For individual character failures, try to handle gracefully\n+            if len(s) == 1 and s.isdigit():\n+                # Digits should still get subscript formatting even if base symbol fails\n+                if mapping == sub:\n+                    result.append(sub.get(s, s))\n+                elif mapping == sup:\n+                    result.append(sup.get(s, s))\n+                else:\n+                    result.append(s)\n+                    has_failures = True\n+            else:\n+                result.append(s)\n+                has_failures = True\n+    \n+    # Return partial results for mixed formatting instead of all-or-nothing\n+    return result if not has_failures or any(r != s for r, s in zip(result, l)) else None\n         if sups:\n             name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n         return name\n",
    "variant_1": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..a1581d4af2 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -182,7 +182,8 @@ def xstr(*args):\n for l in 'in':\n     sup[l] = LSUP(l)\n \n-for gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n+\n+for gl in ['alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi']:\n     sub[gl] = GSUB(gl)\n \n for d in [str(i) for i in range(10)]:\n@@ -537,26 +538,84 @@ def translate(s, bold_name) :\n     # not used at all.\n     def pretty_list(l, mapping):\n         result = []\n-        for s in l:\n-            pretty = mapping.get(s)\n-            if pretty is None:\n-                try:  # match by separate characters\n-                    pretty = ''.join([mapping[c] for c in s])\n-                except (TypeError, KeyError):\n-                    return None\n+\n+def pretty_list(l, mapping):\n+    result = []\n+    for s in l:\n+        pretty = mapping.get(s)\n+        if pretty is None:\n+            try:  # match by separate characters\n+                pretty_chars = []\n+                for c in s:\n+                    if c in mapping:\n+                        pretty_chars.append(mapping[c])\n+                    else:\n+                        # If character can't be mapped, use original character\n+                        pretty_chars.append(c)\n+                pretty = ''.join(pretty_chars)\n+            except (TypeError, KeyError):\n+                pretty = s  # Use original string as fallback\n+        result.append(pretty)\n+    return result\n+                pretty = ''.join([mapping[c] for c in s])\n+            except (TypeError, KeyError):\n+                # Instead of failing completely, try character-by-character with fallback\n+                pretty_chars = []\n+                for c in s:\n+                    mapped_char = mapping.get(c)\n+                    if mapped_char is not None:\n+                        pretty_chars.append(mapped_char)\n+                    else:\n+                        pretty_chars.append(c)  # fallback to original character\n+                pretty = ''.join(pretty_chars)\n+        result.append(pretty)\n+    return result\n             result.append(pretty)\n         return result\n \n+\n     pretty_sups = pretty_list(sups, sup)\n     if pretty_sups is not None:\n         pretty_subs = pretty_list(subs, sub)\n+        if pretty_subs is None and subs:\n+            # Try character-by-character mapping for subscripts\n+            pretty_subs = []\n+            for s in subs:\n+                char_result = []\n+                for c in s:\n+                    mapped = sub.get(c)\n+                    if mapped is not None:\n+                        char_result.append(mapped)\n+                    else:\n+                        # If individual character can't be mapped, keep original\n+                        char_result.append(c)\n+                pretty_subs.append(''.join(char_result))\n     else:\n         pretty_subs = None\n \n     # glue the results into one string\n-    if pretty_subs is None:  # nice formatting of sups/subs did not work\n-        if subs:\n-            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n+\n+def pretty_list(lista, mapping):\n+    result = []\n+    for s in lista:\n+        pretty = translate(s, mapping)\n+        if pretty is None:\n+            # Instead of failing completely, try character-by-character\n+            char_results = []\n+            for char in s:\n+                char_pretty = translate(char, mapping)\n+                if char_pretty is not None:\n+                    char_results.append(char_pretty)\n+                else:\n+                    # For individual characters that can't be mapped, use original\n+                    char_results.append(char)\n+            if char_results:\n+                result.append(''.join(char_results))\n+            else:\n+                return None\n+        else:\n+            result.append(pretty)\n+    return result\n         if sups:\n             name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n         return name\n",
    "variant_2": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..07e68a7a0f 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -182,9 +182,13 @@ def xstr(*args):\n for l in 'in':\n     sup[l] = LSUP(l)\n \n+\n for gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n     sub[gl] = GSUB(gl)\n \n+# Note: omega cannot be added to subscripts due to Unicode limitations,\n+# but this should not prevent digit subscripts from working with omega\n+\n for d in [str(i) for i in range(10)]:\n     sub[d] = DSUB(d)\n     sup[d] = DSUP(d)\n@@ -537,26 +541,103 @@ def translate(s, bold_name) :\n     # not used at all.\n     def pretty_list(l, mapping):\n         result = []\n-        for s in l:\n-            pretty = mapping.get(s)\n-            if pretty is None:\n-                try:  # match by separate characters\n-                    pretty = ''.join([mapping[c] for c in s])\n-                except (TypeError, KeyError):\n-                    return None\n+\n+def pretty_list(l, mapping):\n+    result = []\n+    for s in l:\n+        pretty = mapping.get(s)\n+        if pretty is None:\n+            try:  # match by separate characters\n+                pretty_chars = []\n+                for c in s:\n+                    if c in mapping:\n+                        pretty_chars.append(mapping[c])\n+                    else:\n+                        # Return None only if no characters can be mapped\n+                        # This allows partial success for mixed cases\n+                        if not any(char in mapping for char in s):\n+                            return None\n+                        pretty_chars.append(c)\n+                pretty = ''.join(pretty_chars)\n+            except (TypeError, KeyError):\n+                return None\n+        result.append(pretty)\n+    return result\n+                pretty = ''.join([mapping[c] for c in s])\n+            except (TypeError, KeyError):\n+                # Instead of returning None, try partial mapping\n+                partial_result = []\n+                for c in s:\n+                    mapped_char = mapping.get(c)\n+                    if mapped_char is not None:\n+                        partial_result.append(mapped_char)\n+                    else:\n+                        partial_result.append(c)\n+                pretty = ''.join(partial_result)\n+        result.append(pretty)\n+    return result\n             result.append(pretty)\n         return result\n \n+\n+    # Check if we can format superscripts nicely\n     pretty_sups = pretty_list(sups, sup)\n+    \n+    # For subscripts, try a more flexible approach\n     if pretty_sups is not None:\n         pretty_subs = pretty_list(subs, sub)\n+        # If subscripts failed but we have digits that could be formatted,\n+        # try formatting each subscript component separately\n+        if pretty_subs is None and subs:\n+            mixed_subs = []\n+            for s in subs:\n+                # Try to format this subscript component\n+                component_result = pretty_list([s], sub)\n+                if component_result is not None:\n+                    mixed_subs.append(component_result[0])\n+                else:\n+                    # Check if it's just digits that we can format\n+                    if s.isdigit():\n+                        try:\n+                            digit_formatted = ''.join([sub[c] for c in s])\n+                            mixed_subs.append(digit_formatted)\n+                        except KeyError:\n+                            mixed_subs = None\n+                            break\n+                    else:\n+                        mixed_subs = None\n+                        break\n+            pretty_subs = mixed_subs\n     else:\n         pretty_subs = None\n \n     # glue the results into one string\n-    if pretty_subs is None:  # nice formatting of sups/subs did not work\n-        if subs:\n-            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n+\n+def pretty_list(l, mapping):\n+    result = []\n+    for s in l:\n+        pretty = mapping.get(s)\n+        if pretty is None:\n+            # For mixed cases, allow partial success - don't fail the entire list\n+            # if some characters can't be mapped but others can\n+            if len(s) == 1:\n+                return None  # Single character that can't be mapped\n+            # Try character-by-character for multi-character strings\n+            char_results = []\n+            all_failed = True\n+            for char in s:\n+                char_pretty = mapping.get(char)\n+                if char_pretty is not None:\n+                    char_results.append(char_pretty)\n+                    all_failed = False\n+                else:\n+                    char_results.append(char)\n+            if all_failed:\n+                return None\n+            result.append(''.join(char_results))\n+        else:\n+            result.append(pretty)\n+    return result\n         if sups:\n             name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n         return name\n",
    "variant_3": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..e4449b7844 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -182,6 +182,7 @@ def xstr(*args):\n for l in 'in':\n     sup[l] = LSUP(l)\n \n+\n for gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n     sub[gl] = GSUB(gl)\n \n@@ -537,26 +538,67 @@ def translate(s, bold_name) :\n     # not used at all.\n     def pretty_list(l, mapping):\n         result = []\n-        for s in l:\n-            pretty = mapping.get(s)\n-            if pretty is None:\n-                try:  # match by separate characters\n-                    pretty = ''.join([mapping[c] for c in s])\n-                except (TypeError, KeyError):\n-                    return None\n+\n+def pretty_list(l, mapping):\n+    result = []\n+    for s in l:\n+        pretty = mapping.get(s)\n+        if pretty is None:\n+            try:  # match by separate characters\n+                pretty = ''.join([mapping[c] for c in s])\n+            except (TypeError, KeyError):\n+                # Instead of returning None for the entire list,\n+                # try to format individual characters and use fallback for unmappable ones\n+                pretty_chars = []\n+                for c in s:\n+                    mapped_char = mapping.get(c)\n+                    if mapped_char is not None:\n+                        pretty_chars.append(mapped_char)\n+                    else:\n+                        pretty_chars.append(c)  # use original character as fallback\n+                pretty = ''.join(pretty_chars)\n+        result.append(pretty)\n+    return result\n+                pretty = ''.join([mapping[c] for c in s])\n+            except (TypeError, KeyError):\n+                # Instead of returning None for the entire list,\n+                # use the original string for this element\n+                pretty = s\n+        result.append(pretty)\n+    return result\n             result.append(pretty)\n         return result\n \n+\n     pretty_sups = pretty_list(sups, sup)\n     if pretty_sups is not None:\n         pretty_subs = pretty_list(subs, sub)\n     else:\n-        pretty_subs = None\n+        # Even if superscripts failed, still try subscripts\n+        pretty_subs = pretty_list(subs, sub)\n+\n+    # glue the results into one string\n \n     # glue the results into one string\n-    if pretty_subs is None:  # nice formatting of sups/subs did not work\n-        if subs:\n-            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n+    if pretty_subs is None:  # nice formatting of subs/subs did not work\n+        # Try to format individual characters in subscripts, preserving unicode for digits\n+        formatted_subs = []\n+        for s in subs:\n+            try:\n+                # Try to format each character individually\n+                formatted_chars = []\n+                for char in s:\n+                    if char in sub:\n+                        formatted_chars.append(sub[char])\n+                    else:\n+                        formatted_chars.append(char)\n+                formatted_subs.append(''.join(formatted_chars))\n+            except (KeyError, TypeError):\n+                # Fallback to original character if formatting fails\n+                formatted_subs.append(translate(s, bold_name))\n+        \n+        if formatted_subs:\n+            name += '_' + '_'.join(formatted_subs)\n         if sups:\n             name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n         return name\n",
    "variant_4": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..0349c84adb 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -182,6 +182,7 @@ def xstr(*args):\n for l in 'in':\n     sup[l] = LSUP(l)\n \n+\n for gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n     sub[gl] = GSUB(gl)\n \n@@ -535,6 +536,9 @@ def translate(s, bold_name) :\n \n     # Let's prettify sups/subs. If it fails at one of them, pretty sups/subs are\n     # not used at all.\n+    def pretty_list(l, mapping):\n+        result = []\n+\n     def pretty_list(l, mapping):\n         result = []\n         for s in l:\n@@ -543,18 +547,83 @@ def pretty_list(l, mapping):\n                 try:  # match by separate characters\n                     pretty = ''.join([mapping[c] for c in s])\n                 except (TypeError, KeyError):\n-                    return None\n+                    # Instead of failing completely, try partial mapping\n+                    partial_pretty = []\n+                    for c in s:\n+                        mapped_c = mapping.get(c)\n+                        if mapped_c is not None:\n+                            partial_pretty.append(mapped_c)\n+                        else:\n+                            partial_pretty.append(c)\n+                    pretty = ''.join(partial_pretty)\n             result.append(pretty)\n         return result\n+                pretty = ''.join([mapping[c] for c in s])\n+            except (TypeError, KeyError):\n+                # Instead of returning None, try partial mapping\n+                # Map characters that can be mapped, keep others as-is\n+                try:\n+                    pretty_chars = []\n+                    for c in s:\n+                        mapped_c = mapping.get(c)\n+                        if mapped_c is not None:\n+                            pretty_chars.append(mapped_c)\n+                        else:\n+                            # For unmappable characters, keep original\n+                            pretty_chars.append(c)\n+                    pretty = ''.join(pretty_chars)\n+                except (TypeError, AttributeError):\n+                    # If all else fails, use original string\n+                    pretty = s\n+        result.append(pretty)\n+    return result\n+            result.append(pretty)\n+        return result\n+\n \n     pretty_sups = pretty_list(sups, sup)\n     if pretty_sups is not None:\n         pretty_subs = pretty_list(subs, sub)\n+        # If subs formatting partially failed, try character-by-character for digits\n+        if pretty_subs is None and subs:\n+            mixed_subs = []\n+            for s in subs:\n+                if s.isdigit() and s in sub:\n+                    mixed_subs.append(sub[s])\n+                else:\n+                    mixed_subs = None\n+                    break\n+            pretty_subs = mixed_subs\n     else:\n         pretty_subs = None\n \n     # glue the results into one string\n-    if pretty_subs is None:  # nice formatting of sups/subs did not work\n+\n+    def pretty_list(elements, mapping):\n+        result = []\n+        for element in elements:\n+            try:\n+                pretty = mapping[element]\n+                result.append(pretty)\n+            except KeyError:\n+                # For mixed subscripts, allow partial success\n+                # If it's a digit that can be subscripted, use it\n+                if element in '0123456789+-=()':\n+                    digit_mapping = {'0': '₀', '1': '₁', '2': '₂', '3': '₃', '4': '₄',\n+                                   '5': '₅', '6': '₆', '7': '₇', '8': '₈', '9': '₉',\n+                                   '+': '₊', '-': '₋', '=': '₌', '(': '₍', ')': '₎'}\n+                    if element in digit_mapping:\n+                        result.append(digit_mapping[element])\n+                        continue\n+                # For non-subscriptable characters, use regular format\n+                result.append(element)\n+        return result if result else None\n+\n+    pretty_sups = pretty_list(sups, sup)\n+    pretty_subs = pretty_list(subs, sub)\n+\n+    # glue the results into one string\n+    if pretty_subs is None and pretty_sups is None:  # no formatting worked at all\n         if subs:\n             name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n         if sups:\n",
    "variant_5": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..b540d81c62 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -182,8 +182,12 @@ def xstr(*args):\n for l in 'in':\n     sup[l] = LSUP(l)\n \n+\n+# Greek subscripts - only include letters that have Unicode subscript equivalents\n for gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n     sub[gl] = GSUB(gl)\n+# Note: 'omega' is intentionally excluded as it lacks a proper Unicode subscript\n+# but this should not prevent digit subscripts from working with omega\n \n for d in [str(i) for i in range(10)]:\n     sub[d] = DSUB(d)\n@@ -535,28 +539,92 @@ def translate(s, bold_name) :\n \n     # Let's prettify sups/subs. If it fails at one of them, pretty sups/subs are\n     # not used at all.\n+    def pretty_list(l, mapping):\n+        result = []\n+\n     def pretty_list(l, mapping):\n         result = []\n         for s in l:\n             pretty = mapping.get(s)\n             if pretty is None:\n                 try:  # match by separate characters\n-                    pretty = ''.join([mapping[c] for c in s])\n+                    pretty_chars = []\n+                    for c in s:\n+                        if c in mapping:\n+                            pretty_chars.append(mapping[c])\n+                        else:\n+                            # If character can't be mapped, keep original and mark as partial failure\n+                            pretty_chars.append(c)\n+                    pretty = ''.join(pretty_chars)\n+                    # Only return None if no characters could be mapped at all\n+                    if all(c not in mapping for c in s):\n+                        return None\n                 except (TypeError, KeyError):\n                     return None\n             result.append(pretty)\n         return result\n+                    pretty = ''.join([mapping[c] for c in s])\n+                except (TypeError, KeyError):\n+                    # Instead of returning None for the entire list,\n+                    # try to preserve partial unicode formatting\n+                    partial_pretty = []\n+                    for c in s:\n+                        mapped_c = mapping.get(c)\n+                        if mapped_c is not None:\n+                            partial_pretty.append(mapped_c)\n+                        else:\n+                            partial_pretty.append(c)\n+                    pretty = ''.join(partial_pretty)\n+            result.append(pretty)\n+        return result\n+            result.append(pretty)\n+        return result\n+\n \n     pretty_sups = pretty_list(sups, sup)\n     if pretty_sups is not None:\n         pretty_subs = pretty_list(subs, sub)\n+        # If pretty_subs failed but we have digits that could be subscripted,\n+        # try to format them individually\n+        if pretty_subs is None and subs:\n+            mixed_subs = []\n+            for s in subs:\n+                # Try to format each character individually\n+                pretty_chars = []\n+                for c in s:\n+                    if c in sub:\n+                        pretty_chars.append(sub[c])\n+                    else:\n+                        # If any character can't be subscripted, use fallback for this entire substring\n+                        pretty_chars = None\n+                        break\n+                if pretty_chars is not None:\n+                    mixed_subs.append(''.join(pretty_chars))\n+                else:\n+                    # If we have any failures, fall back to None for consistency\n+                    mixed_subs = None\n+                    break\n+            pretty_subs = mixed_subs\n     else:\n         pretty_subs = None\n \n     # glue the results into one string\n-    if pretty_subs is None:  # nice formatting of sups/subs did not work\n+\n+    # glue the results into one string\n+    if pretty_subs is None:  # nice formatting of subs/subs did not work\n+        # Try to format individual characters, preserving unicode for digits\n+        formatted_subs = []\n+        for s in subs:\n+            try:\n+                # Try to format each character individually\n+                formatted_char = translate(s, sub)\n+                formatted_subs.append(formatted_char)\n+            except KeyError:\n+                # If individual character fails, use regular formatting\n+                formatted_subs.append(translate(s, bold_name))\n+        \n         if subs:\n-            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n+            name += '_' + '_'.join(formatted_subs)\n         if sups:\n             name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n         return name\n",
    "variant_6": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..7de6e4d3d4 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -182,8 +182,17 @@ def xstr(*args):\n for l in 'in':\n     sup[l] = LSUP(l)\n \n-for gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n-    sub[gl] = GSUB(gl)\n+\n+# Enhanced Greek subscript definitions - add more supported letters\n+for gl in ['beta', 'gamma', 'rho', 'phi', 'chi', 'alpha', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'pi', 'sigma', 'tau', 'upsilon', 'psi']:\n+    # Only add if the subscript character exists in Unicode\n+    try:\n+        subscript_char = GSUB(gl)\n+        if subscript_char and ord(subscript_char) > 127:  # Valid Unicode subscript\n+            sub[gl] = subscript_char\n+    except (KeyError, AttributeError):\n+        # Skip Greek letters without valid subscript representations\n+        pass\n \n for d in [str(i) for i in range(10)]:\n     sub[d] = DSUB(d)\n@@ -537,29 +546,145 @@ def translate(s, bold_name) :\n     # not used at all.\n     def pretty_list(l, mapping):\n         result = []\n+\n+def pretty_list(l, mapping):\n+    result = []\n+    for s in l:\n+        pretty = mapping.get(s)\n+        if pretty is None:\n+            try:  # match by separate characters\n+                pretty = ''.join([mapping[c] for c in s])\n+            except (TypeError, KeyError):\n+                # Instead of returning None for the entire list,\n+                # try character-by-character with fallback\n+                mixed_result = []\n+                for c in s:\n+                    mapped_char = mapping.get(c)\n+                    if mapped_char is not None:\n+                        mixed_result.append(mapped_char)\n+                    else:\n+                        mixed_result.append(c)  # fallback to original character\n+                pretty = ''.join(mixed_result)\n+        result.append(pretty)\n+    return result\n+                    pretty = ''.join([mapping[c] for c in s])\n+                except (TypeError, KeyError):\n+                    # Instead of returning None for the entire list,\n+                    # try character-by-character with fallback\n+                    pretty_chars = []\n+                    for c in s:\n+                        mapped_char = mapping.get(c)\n+                        if mapped_char is not None:\n+                            pretty_chars.append(mapped_char)\n+                        else:\n+                            pretty_chars.append(c)  # fallback to original character\n+                    pretty = ''.join(pretty_chars)\n+            result.append(pretty)\n+        return result\n+            result.append(pretty)\n+        return result\n+\n+\n+    # Try to use pretty formatting for subscripts and superscripts\n+    def pretty_list(l, mapping):\n+        result = []\n         for s in l:\n             pretty = mapping.get(s)\n             if pretty is None:\n                 try:  # match by separate characters\n                     pretty = ''.join([mapping[c] for c in s])\n                 except (TypeError, KeyError):\n-                    return None\n+                    # Instead of returning None, use the original character\n+                    # This allows partial formatting where some chars work\n+                    pretty = s\n             result.append(pretty)\n         return result\n \n     pretty_sups = pretty_list(sups, sup)\n-    if pretty_sups is not None:\n-        pretty_subs = pretty_list(subs, sub)\n-    else:\n-        pretty_subs = None\n+    pretty_subs = pretty_list(subs, sub)\n+\n+    # glue the results into one string\n+\n+def pretty_symbol(sym_name, bold_name=False, compat_greek_name=None):\n+    \"\"\"return pretty representation of a symbol\"\"\"\n+    # let's split up the symbol name into symbol + subscripts/superscripts\n+    # e.g. 'x1' -> 'x', [] ['1']\n+    # e.g. 'x_1^2' -> 'x', ['1'], ['2']\n+    sym, sups, subs = split_super_sub(sym_name)\n+\n+    # translate symbol\n+    sym = translate(sym, bold_name)\n+\n+    # translate sups/subs to pretty format\n+    def pretty_list(l, mapping):\n+        result = []\n+        for s in l:\n+            pretty = None\n+            try:\n+                pretty = mapping[int(s)]\n+            except (KeyError, ValueError):\n+                try:\n+                    pretty = mapping[s]\n+                except KeyError:\n+                    # Character-by-character approach for mixed cases\n+                    if len(s) == 1:\n+                        # Single character that can't be mapped, return None for this character\n+                        return None\n+                    else:\n+                        # Multi-character string, try to map each character\n+                        char_results = []\n+                        all_failed = True\n+                        for char in s:\n+                            try:\n+                                char_pretty = mapping[int(char)]\n+                                char_results.append(char_pretty)\n+                                all_failed = False\n+                            except (KeyError, ValueError):\n+                                try:\n+                                    char_pretty = mapping[char]\n+                                    char_results.append(char_pretty)\n+                                    all_failed = False\n+                                except KeyError:\n+                                    # This character can't be mapped, use original\n+                                    char_results.append(char)\n+                        \n+                        if all_failed:\n+                            return None\n+                        else:\n+                            pretty = ''.join(char_results)\n+            \n+            if pretty is not None:\n+                result.append(pretty)\n+            else:\n+                result.append(s)\n+        return result\n+\n+    pretty_sups = pretty_list(sups, sup)\n+    pretty_subs = pretty_list(subs, sub)\n \n     # glue the results into one string\n-    if pretty_subs is None:  # nice formatting of sups/subs did not work\n+    if pretty_subs is None and pretty_sups is None:  # nice formatting completely failed\n         if subs:\n             name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n         if sups:\n             name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n         return name\n+    else:\n+        # Use pretty formatting where available, fallback where not\n+        if pretty_sups is not None:\n+            sups_result = ' '.join(pretty_sups)\n+        else:\n+            sups_result = '__'+'__'.join([translate(s, bold_name) for s in sups]) if sups else ''\n+            \n+        if pretty_subs is not None:\n+            subs_result = ' '.join(pretty_subs)\n+        else:\n+            subs_result = '_'+'_'.join([translate(s, bold_name) for s in subs]) if subs else ''\n+\n+    return ''.join([name, sups_result, subs_result])\n+        if sups:\n+            name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n+        return name\n     else:\n         sups_result = ' '.join(pretty_sups)\n         subs_result = ' '.join(pretty_subs)\n",
    "variant_7": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..f30e5c5c8f 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -182,6 +182,7 @@ def xstr(*args):\n for l in 'in':\n     sup[l] = LSUP(l)\n \n+\n for gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n     sub[gl] = GSUB(gl)\n \n@@ -535,6 +536,9 @@ def translate(s, bold_name) :\n \n     # Let's prettify sups/subs. If it fails at one of them, pretty sups/subs are\n     # not used at all.\n+    def pretty_list(l, mapping):\n+        result = []\n+\n     def pretty_list(l, mapping):\n         result = []\n         for s in l:\n@@ -543,20 +547,73 @@ def pretty_list(l, mapping):\n                 try:  # match by separate characters\n                     pretty = ''.join([mapping[c] for c in s])\n                 except (TypeError, KeyError):\n-                    return None\n+                    # Instead of returning None, try to map individual characters\n+                    # and use fallback for unmappable ones\n+                    pretty_chars = []\n+                    for c in s:\n+                        if c in mapping:\n+                            pretty_chars.append(mapping[c])\n+                        else:\n+                            pretty_chars.append(c)\n+                    pretty = ''.join(pretty_chars) if pretty_chars else s\n+            result.append(pretty)\n+        return result\n+                pretty = ''.join([mapping[c] for c in s])\n+            except (TypeError, KeyError):\n+                # Instead of returning None for the entire list,\n+                # use the original string for this element\n+                pretty = s\n+        result.append(pretty)\n+    return result\n             result.append(pretty)\n         return result\n \n-    pretty_sups = pretty_list(sups, sup)\n-    if pretty_sups is not None:\n-        pretty_subs = pretty_list(subs, sub)\n-    else:\n-        pretty_subs = None\n+\n+    # Convert characters to pretty representations, allowing partial success\n+    def pretty_list_tolerant(l, mapping):\n+        if not mapping:\n+            return None\n+        result = []\n+        for s in l:\n+            pretty = mapping.get(s)\n+            if pretty is None:\n+                try:  # match by separate characters\n+                    pretty = ''.join([mapping[c] for c in s])\n+                except (TypeError, KeyError):\n+                    # Instead of returning None for the whole list,\n+                    # use the original character when mapping fails\n+                    pretty = s\n+            result.append(pretty)\n+        return result\n+\n+    pretty_sups = pretty_list_tolerant(sups, sup)\n+    pretty_subs = pretty_list_tolerant(subs, sub)\n \n     # glue the results into one string\n-    if pretty_subs is None:  # nice formatting of sups/subs did not work\n-        if subs:\n-            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n+\n+def pretty_list(s, t):\n+    \"\"\"\n+    Helper function for pretty_symbol that converts a list of symbols\n+    to their pretty-printed forms. Returns None if any symbol cannot\n+    be converted, otherwise returns a list of pretty symbols.\n+    \"\"\"\n+    result = []\n+    for sym in s:\n+        try:\n+            pretty = t[sym]\n+            result.append(pretty)\n+        except KeyError:\n+            # If this is a digit and we're doing subscripts, try to convert it\n+            if t == sub and sym.isdigit():\n+                try:\n+                    digit_sub = sub[sym]\n+                    result.append(digit_sub)\n+                    continue\n+                except KeyError:\n+                    pass\n+            # For any other failure, use the original symbol\n+            result.append(sym)\n+    return result\n         if sups:\n             name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n         return name\n",
    "variant_8": "diff --git a/sympy/printing/pretty/pretty_symbology.py b/sympy/printing/pretty/pretty_symbology.py\nindex 3f7c4a2dc7..56172c6804 100644\n--- a/sympy/printing/pretty/pretty_symbology.py\n+++ b/sympy/printing/pretty/pretty_symbology.py\n@@ -182,9 +182,13 @@ def xstr(*args):\n for l in 'in':\n     sup[l] = LSUP(l)\n \n+\n for gl in ['beta', 'gamma', 'rho', 'phi', 'chi']:\n     sub[gl] = GSUB(gl)\n \n+# Note: omega and other Greek letters not in the above list will be handled\n+# by mixed formatting logic in pretty_list to allow digit subscripts\n+\n for d in [str(i) for i in range(10)]:\n     sub[d] = DSUB(d)\n     sup[d] = DSUP(d)\n@@ -535,6 +539,9 @@ def translate(s, bold_name) :\n \n     # Let's prettify sups/subs. If it fails at one of them, pretty sups/subs are\n     # not used at all.\n+    def pretty_list(l, mapping):\n+        result = []\n+\n     def pretty_list(l, mapping):\n         result = []\n         for s in l:\n@@ -543,20 +550,62 @@ def pretty_list(l, mapping):\n                 try:  # match by separate characters\n                     pretty = ''.join([mapping[c] for c in s])\n                 except (TypeError, KeyError):\n-                    return None\n+                    # Instead of failing completely, try partial mapping\n+                    partial_pretty = []\n+                    for c in s:\n+                        mapped_c = mapping.get(c)\n+                        if mapped_c is not None:\n+                            partial_pretty.append(mapped_c)\n+                        else:\n+                            partial_pretty.append(c)\n+                    pretty = ''.join(partial_pretty)\n             result.append(pretty)\n         return result\n+                pretty = ''.join([mapping[c] for c in s])\n+            except (TypeError, KeyError):\n+                # Instead of failing completely, try character-by-character\n+                # and use original characters for unmappable ones\n+                try:\n+                    pretty_chars = []\n+                    for c in s:\n+                        mapped_char = mapping.get(c, c)  # Use original char if not mappable\n+                        pretty_chars.append(mapped_char)\n+                    pretty = ''.join(pretty_chars)\n+                except (TypeError, AttributeError):\n+                    pretty = s  # Use original string as fallback\n+        result.append(pretty)\n+    return result\n+            result.append(pretty)\n+        return result\n+\n \n     pretty_sups = pretty_list(sups, sup)\n     if pretty_sups is not None:\n         pretty_subs = pretty_list(subs, sub)\n     else:\n-        pretty_subs = None\n+        # Try to format subscripts even if superscripts failed\n+        pretty_subs = pretty_list(subs, sub)\n+\n+    # glue the results into one string\n \n     # glue the results into one string\n-    if pretty_subs is None:  # nice formatting of sups/subs did not work\n+    if pretty_subs is None:  # nice formatting of subs/subs did not work\n+        # Try to format individual characters in subscripts, preserving unicode for digits\n+        formatted_subs = []\n         if subs:\n-            name += '_'+'_'.join([translate(s, bold_name) for s in subs])\n+            for s in subs:\n+                try:\n+                    # Try to format each character individually\n+                    formatted_chars = []\n+                    for char in s:\n+                        if char.isdigit() and char in sub:\n+                            formatted_chars.append(sub[char])\n+                        else:\n+                            formatted_chars.append(translate(char, bold_name))\n+                    formatted_subs.append(''.join(formatted_chars))\n+                except:\n+                    formatted_subs.append(translate(s, bold_name))\n+            name += '_' + '_'.join(formatted_subs)\n         if sups:\n             name += '__'+'__'.join([translate(s, bold_name) for s in sups])\n         return name\n"
  }
}