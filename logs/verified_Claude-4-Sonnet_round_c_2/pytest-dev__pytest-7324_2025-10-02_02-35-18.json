{
  "zero_patches": {
    "Location 1 (/root/hy/projects/pytest/src/_pytest/mark/expression.py lines 162-165)": "\ndef not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n        if ident.value in (\"True\", \"False\", \"None\"):\n            # Convert string representation to actual Python constant value\n            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n            return ast.NameConstant(constant_map[ident.value])\n        # Regular identifiers remain as Name nodes\n        return ast.Name(ident.value, ast.Load())\n    s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/pytest/src/_pytest/mark/expression.py lines 162-165)": [
      "\ndef not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n        if ident.value in (\"True\", \"False\", \"None\"):\n            # Convert string representation to actual Python constant value\n            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n            return ast.NameConstant(constant_map[ident.value])\n        # Regular identifiers remain as Name nodes\n        return ast.Name(ident.value, ast.Load())\n    s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n",
      "\ndef not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n        if ident.value in (\"True\", \"False\", \"None\"):\n            # Convert string representation to actual Python constant value\n            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n            return ast.NameConstant(constant_map[ident.value])\n        # Regular identifiers remain as Name nodes\n        return ast.Name(ident.value, ast.Load())\n    s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n",
      "\ndef not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n        if ident.value in (\"True\", \"False\", \"None\"):\n            # Convert string representation to actual Python constant value\n            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n            return ast.NameConstant(constant_map[ident.value])\n        # Regular identifiers remain as Name nodes\n        return ast.Name(ident.value, ast.Load())\n    s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n",
      "\ndef not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n        if ident.value in (\"True\", \"False\", \"None\"):\n            # Convert string representation to actual Python constant value\n            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n            return ast.NameConstant(constant_map[ident.value])\n        # Regular identifiers remain as Name nodes\n        return ast.Name(ident.value, ast.Load())\n    s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n",
      "\ndef not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n        if ident.value in (\"True\", \"False\", \"None\"):\n            # Convert string representation to actual Python constant value\n            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n            return ast.NameConstant(constant_map[ident.value])\n        # Regular identifiers remain as Name nodes\n        return ast.Name(ident.value, ast.Load())\n    s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n",
      "\ndef not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n        if ident.value in (\"True\", \"False\", \"None\"):\n            # Convert string representation to actual Python constant value\n            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n            return ast.NameConstant(constant_map[ident.value])\n        # Regular identifiers remain as Name nodes\n        return ast.Name(ident.value, ast.Load())\n    s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n",
      "\ndef not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n        if ident.value in (\"True\", \"False\", \"None\"):\n            # Convert string representation to actual Python constant value\n            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n            return ast.NameConstant(constant_map[ident.value])\n        # Regular identifiers remain as Name nodes\n        return ast.Name(ident.value, ast.Load())\n    s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n",
      "\ndef not_expr(s: Scanner) -> ast.expr:\n    if s.accept(TokenType.NOT):\n        return ast.UnaryOp(ast.Not(), not_expr(s))\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n        if ident.value in (\"True\", \"False\", \"None\"):\n            # Convert string representation to actual Python constant value\n            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n            return ast.NameConstant(constant_map[ident.value])\n        # Regular identifiers remain as Name nodes\n        return ast.Name(ident.value, ast.Load())\n    s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..afc450b60 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -159,8 +159,15 @@ def not_expr(s: Scanner) -> ast.expr:\n         ret = expr(s)\n         s.accept(TokenType.RPAREN, reject=True)\n         return ret\n+\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n+        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            # Convert string representation to actual Python constant value\n+            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n+            return ast.NameConstant(constant_map[ident.value])\n+        # Regular identifiers remain as Name nodes\n         return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n",
    "variant_0": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..0ce94809d 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -152,6 +152,14 @@ def and_expr(s: Scanner) -> ast.expr:\n     return ret\n \n \n+def not_expr(s: Scanner) -> ast.expr:\n+    if s.accept(TokenType.NOT):\n+        return ast.UnaryOp(ast.Not(), not_expr(s))\n+    if s.accept(TokenType.LPAREN):\n+        ret = expr(s)\n+        s.accept(TokenType.RPAREN, reject=True)\n+        return ret\n+\n def not_expr(s: Scanner) -> ast.expr:\n     if s.accept(TokenType.NOT):\n         return ast.UnaryOp(ast.Not(), not_expr(s))\n@@ -161,6 +169,12 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n+        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            # Convert string representation to actual Python constant value\n+            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n+            return ast.NameConstant(constant_map[ident.value])\n+        # Regular identifiers remain as Name nodes\n         return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n",
    "variant_1": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..0ce94809d 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -152,6 +152,14 @@ def and_expr(s: Scanner) -> ast.expr:\n     return ret\n \n \n+def not_expr(s: Scanner) -> ast.expr:\n+    if s.accept(TokenType.NOT):\n+        return ast.UnaryOp(ast.Not(), not_expr(s))\n+    if s.accept(TokenType.LPAREN):\n+        ret = expr(s)\n+        s.accept(TokenType.RPAREN, reject=True)\n+        return ret\n+\n def not_expr(s: Scanner) -> ast.expr:\n     if s.accept(TokenType.NOT):\n         return ast.UnaryOp(ast.Not(), not_expr(s))\n@@ -161,6 +169,12 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n+        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            # Convert string representation to actual Python constant value\n+            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n+            return ast.NameConstant(constant_map[ident.value])\n+        # Regular identifiers remain as Name nodes\n         return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n",
    "variant_2": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..0ce94809d 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -152,6 +152,14 @@ def and_expr(s: Scanner) -> ast.expr:\n     return ret\n \n \n+def not_expr(s: Scanner) -> ast.expr:\n+    if s.accept(TokenType.NOT):\n+        return ast.UnaryOp(ast.Not(), not_expr(s))\n+    if s.accept(TokenType.LPAREN):\n+        ret = expr(s)\n+        s.accept(TokenType.RPAREN, reject=True)\n+        return ret\n+\n def not_expr(s: Scanner) -> ast.expr:\n     if s.accept(TokenType.NOT):\n         return ast.UnaryOp(ast.Not(), not_expr(s))\n@@ -161,6 +169,12 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n+        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            # Convert string representation to actual Python constant value\n+            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n+            return ast.NameConstant(constant_map[ident.value])\n+        # Regular identifiers remain as Name nodes\n         return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n",
    "variant_3": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..0ce94809d 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -152,6 +152,14 @@ def and_expr(s: Scanner) -> ast.expr:\n     return ret\n \n \n+def not_expr(s: Scanner) -> ast.expr:\n+    if s.accept(TokenType.NOT):\n+        return ast.UnaryOp(ast.Not(), not_expr(s))\n+    if s.accept(TokenType.LPAREN):\n+        ret = expr(s)\n+        s.accept(TokenType.RPAREN, reject=True)\n+        return ret\n+\n def not_expr(s: Scanner) -> ast.expr:\n     if s.accept(TokenType.NOT):\n         return ast.UnaryOp(ast.Not(), not_expr(s))\n@@ -161,6 +169,12 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n+        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            # Convert string representation to actual Python constant value\n+            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n+            return ast.NameConstant(constant_map[ident.value])\n+        # Regular identifiers remain as Name nodes\n         return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n",
    "variant_4": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..0ce94809d 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -152,6 +152,14 @@ def and_expr(s: Scanner) -> ast.expr:\n     return ret\n \n \n+def not_expr(s: Scanner) -> ast.expr:\n+    if s.accept(TokenType.NOT):\n+        return ast.UnaryOp(ast.Not(), not_expr(s))\n+    if s.accept(TokenType.LPAREN):\n+        ret = expr(s)\n+        s.accept(TokenType.RPAREN, reject=True)\n+        return ret\n+\n def not_expr(s: Scanner) -> ast.expr:\n     if s.accept(TokenType.NOT):\n         return ast.UnaryOp(ast.Not(), not_expr(s))\n@@ -161,6 +169,12 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n+        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            # Convert string representation to actual Python constant value\n+            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n+            return ast.NameConstant(constant_map[ident.value])\n+        # Regular identifiers remain as Name nodes\n         return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n",
    "variant_5": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..0ce94809d 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -152,6 +152,14 @@ def and_expr(s: Scanner) -> ast.expr:\n     return ret\n \n \n+def not_expr(s: Scanner) -> ast.expr:\n+    if s.accept(TokenType.NOT):\n+        return ast.UnaryOp(ast.Not(), not_expr(s))\n+    if s.accept(TokenType.LPAREN):\n+        ret = expr(s)\n+        s.accept(TokenType.RPAREN, reject=True)\n+        return ret\n+\n def not_expr(s: Scanner) -> ast.expr:\n     if s.accept(TokenType.NOT):\n         return ast.UnaryOp(ast.Not(), not_expr(s))\n@@ -161,6 +169,12 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n+        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            # Convert string representation to actual Python constant value\n+            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n+            return ast.NameConstant(constant_map[ident.value])\n+        # Regular identifiers remain as Name nodes\n         return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n",
    "variant_6": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..0ce94809d 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -152,6 +152,14 @@ def and_expr(s: Scanner) -> ast.expr:\n     return ret\n \n \n+def not_expr(s: Scanner) -> ast.expr:\n+    if s.accept(TokenType.NOT):\n+        return ast.UnaryOp(ast.Not(), not_expr(s))\n+    if s.accept(TokenType.LPAREN):\n+        ret = expr(s)\n+        s.accept(TokenType.RPAREN, reject=True)\n+        return ret\n+\n def not_expr(s: Scanner) -> ast.expr:\n     if s.accept(TokenType.NOT):\n         return ast.UnaryOp(ast.Not(), not_expr(s))\n@@ -161,6 +169,12 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n+        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            # Convert string representation to actual Python constant value\n+            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n+            return ast.NameConstant(constant_map[ident.value])\n+        # Regular identifiers remain as Name nodes\n         return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n",
    "variant_7": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..0ce94809d 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -152,6 +152,14 @@ def and_expr(s: Scanner) -> ast.expr:\n     return ret\n \n \n+def not_expr(s: Scanner) -> ast.expr:\n+    if s.accept(TokenType.NOT):\n+        return ast.UnaryOp(ast.Not(), not_expr(s))\n+    if s.accept(TokenType.LPAREN):\n+        ret = expr(s)\n+        s.accept(TokenType.RPAREN, reject=True)\n+        return ret\n+\n def not_expr(s: Scanner) -> ast.expr:\n     if s.accept(TokenType.NOT):\n         return ast.UnaryOp(ast.Not(), not_expr(s))\n@@ -161,6 +169,12 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n+        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            # Convert string representation to actual Python constant value\n+            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n+            return ast.NameConstant(constant_map[ident.value])\n+        # Regular identifiers remain as Name nodes\n         return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n",
    "variant_8": "diff --git a/src/_pytest/mark/expression.py b/src/_pytest/mark/expression.py\nindex 04c73411a..0ce94809d 100644\n--- a/src/_pytest/mark/expression.py\n+++ b/src/_pytest/mark/expression.py\n@@ -152,6 +152,14 @@ def and_expr(s: Scanner) -> ast.expr:\n     return ret\n \n \n+def not_expr(s: Scanner) -> ast.expr:\n+    if s.accept(TokenType.NOT):\n+        return ast.UnaryOp(ast.Not(), not_expr(s))\n+    if s.accept(TokenType.LPAREN):\n+        ret = expr(s)\n+        s.accept(TokenType.RPAREN, reject=True)\n+        return ret\n+\n def not_expr(s: Scanner) -> ast.expr:\n     if s.accept(TokenType.NOT):\n         return ast.UnaryOp(ast.Not(), not_expr(s))\n@@ -161,6 +169,12 @@ def not_expr(s: Scanner) -> ast.expr:\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n+        # Handle Python built-in constants that must be NameConstant nodes in Python 3.8+\n+        if ident.value in (\"True\", \"False\", \"None\"):\n+            # Convert string representation to actual Python constant value\n+            constant_map = {\"True\": True, \"False\": False, \"None\": None}\n+            return ast.NameConstant(constant_map[ident.value])\n+        # Regular identifiers remain as Name nodes\n         return ast.Name(ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n"
  }
}