{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 779-785)": "\n            else:\n                # Check if this member was made public via :meta public: metadata\n                # by seeing if the name suggests it should be private but isprivate is False\n                made_public_by_metadata = (membername.startswith('_') and \n                                         not membername.startswith('__') and \n                                         not isprivate)\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                elif made_public_by_metadata:\n                    # Keep members made public via :meta public: regardless of documentation\n                    keep = True\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n",
    "Location 2 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 769-778)": "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and isprivate:\n                if has_doc or self.options.undoc_members:\n                    if self.options.private_members is None:\n                        keep = False\n                    elif is_filtered_inherited_member(membername, obj):\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    keep = False\n            else:\n                # Check if member was made public via :meta public: metadata\n                # (underscore name but isprivate=False due to metadata)\n                is_metadata_public = membername.startswith('_') and not isprivate\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                elif is_metadata_public:\n                    # Keep members made public via metadata even without documentation\n                    keep = True\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n",
    "Location 3 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 759-767)": "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n",
    "Location 4 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 731-739)": "\n            metadata = extract_metadata(doc)\n            metadata_public = False\n            if 'private' in metadata:\n                # consider a member private if docstring has \"private\" metadata\n                isprivate = True\n            elif 'public' in metadata:\n                # consider a member public if docstring has \"public\" metadata\n                isprivate = False\n                metadata_public = True\n            else:\n                isprivate = membername.startswith('_')\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 779-785)": [
      "\n            else:\n                # Check if this was made public via :meta public: metadata\n                # (member name starts with underscore but isprivate is False)\n                is_metadata_public = membername.startswith('_') and not isprivate\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                elif is_metadata_public:\n                    # Keep members made public via :meta public: metadata\n                    keep = True\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                # Check if this is a member made public via :meta public: metadata\n                # (member name starts with underscore but isprivate was set to False)\n                is_metadata_public = (membername.startswith('_') and not membername.startswith('__') \n                                    and not isprivate)\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                elif is_metadata_public:\n                    # Keep members made public via :meta public: metadata regardless of documentation\n                    keep = True\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                # Check if member was made public via metadata (starts with underscore but isprivate=False)\n                made_public_by_metadata = membername.startswith('_') and not isprivate\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # but keep members made public via :meta public: metadata\n                    keep = has_doc or self.options.undoc_members or made_public_by_metadata\n",
      "\n            else:\n                # Check if member was made public via :meta public: metadata\n                # (i.e., name starts with underscore but isprivate was set to False)\n                made_public_by_metadata = (membername.startswith('_') and not isprivate)\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # but always keep members made public via :meta public: metadata\n                    keep = has_doc or self.options.undoc_members or made_public_by_metadata\n",
      "\n            else:\n                # Check if member was made public via :meta public: metadata\n                # (starts with underscore but isprivate was set to False by metadata)\n                is_metadata_public = (membername.startswith('_') and not isprivate)\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                elif is_metadata_public:\n                    # Keep members made public via :meta public: metadata\n                    keep = True\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                # Check if member was made public via :meta public: metadata\n                # (member name starts with underscore but isprivate is False)\n                is_metadata_public = (membername.startswith('_') and not membername.startswith('__') \n                                    and not isprivate)\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                elif is_metadata_public:\n                    # Keep members made public via :meta public: metadata\n                    keep = True\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                # Check if this member was made public via :meta public: metadata\n                # by checking if it starts with underscore but isprivate is False\n                is_metadata_public = membername.startswith('_') and not isprivate\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                elif is_metadata_public:\n                    # Keep members made public via :meta public: metadata regardless of documentation\n                    keep = True\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                # Check if this was made public via :meta public: metadata\n                # (member name starts with underscore but isprivate was set to False)\n                is_metadata_public = (membername.startswith('_') and not membername.startswith('__') \n                                    and not isprivate)\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # but keep members made public via :meta public: metadata\n                    keep = has_doc or self.options.undoc_members or is_metadata_public\n"
    ],
    "Location 2 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 769-778)": [
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and isprivate:\n                if has_doc or self.options.undoc_members:\n                    if self.options.private_members is None:\n                        keep = False\n                    elif is_filtered_inherited_member(membername, obj):\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    keep = False\n            else:\n                # Check if member was made public via :meta public: metadata\n                was_made_public_by_metadata = (membername.startswith('_') and \n                                             not membername.startswith('__') and \n                                             not isprivate)\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                elif was_made_public_by_metadata:\n                    # Keep members made public via :meta public: even without documentation\n                    keep = True\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and isprivate:\n                if has_doc or self.options.undoc_members:\n                    if self.options.private_members is None:\n                        keep = False\n                    elif is_filtered_inherited_member(membername, obj):\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    keep = False\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # Check if member was made public via :meta public: metadata\n                    # (member name starts with underscore but isprivate is False due to metadata)\n                    made_public_by_metadata = (membername.startswith('_') and not isprivate and \n                                               not membername.startswith('__'))\n                    # ignore undocumented members if :undoc-members: is not given,\n                    # but keep members made public via metadata\n                    keep = has_doc or self.options.undoc_members or made_public_by_metadata\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and isprivate:\n                if has_doc or self.options.undoc_members:\n                    if self.options.private_members is None:\n                        keep = False\n                    elif is_filtered_inherited_member(membername, obj):\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    keep = False\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # Check if member was made public via :meta public: metadata\n                    # (member name starts with underscore but isprivate is False due to metadata)\n                    made_public_by_metadata = (membername.startswith('_') and not isprivate and \n                                               not membername.startswith('__'))\n                    # ignore undocumented members if :undoc-members: is not given\n                    # but keep members made public via metadata\n                    keep = has_doc or self.options.undoc_members or made_public_by_metadata\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and isprivate:\n                if has_doc or self.options.undoc_members:\n                    if self.options.private_members is None:\n                        keep = False\n                    elif is_filtered_inherited_member(membername, obj):\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    keep = False\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # Check if member was made public via :meta public: metadata\n                    # (i.e., starts with underscore but isprivate was set to False)\n                    made_public_via_metadata = (membername.startswith('_') and \n                                               not isprivate and \n                                               not membername.startswith('__'))\n                    # ignore undocumented members if :undoc-members: is not given\n                    # but keep members made public via metadata\n                    keep = has_doc or self.options.undoc_members or made_public_via_metadata\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and isprivate:\n                if has_doc or self.options.undoc_members:\n                    if self.options.private_members is None:\n                        keep = False\n                    elif is_filtered_inherited_member(membername, obj):\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    keep = False\n            else:\n                # Check if member was made public via :meta public: metadata\n                made_public_via_metadata = (membername.startswith('_') and not isprivate)\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # but keep members made public via :meta public: metadata\n                    keep = has_doc or self.options.undoc_members or made_public_via_metadata\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and isprivate:\n                if has_doc or self.options.undoc_members:\n                    if self.options.private_members is None:\n                        keep = False\n                    elif is_filtered_inherited_member(membername, obj):\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    keep = False\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # Check if member was made public via :meta public: metadata\n                    # (member name starts with underscore but isprivate is False)\n                    made_public_via_metadata = (membername.startswith('_') and not isprivate)\n                    \n                    # ignore undocumented members if :undoc-members: is not given\n                    # but keep members made public via metadata\n                    keep = has_doc or self.options.undoc_members or made_public_via_metadata\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and isprivate:\n                if has_doc or self.options.undoc_members:\n                    if self.options.private_members is None:\n                        keep = False\n                    elif is_filtered_inherited_member(membername, obj):\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    keep = False\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # Check if member was made public via :meta public: metadata\n                    # (i.e., starts with underscore but isprivate is False due to metadata)\n                    is_metadata_public = (membername.startswith('_') and not isprivate and \n                                        not membername.startswith('__'))\n                    # ignore undocumented members if :undoc-members: is not given,\n                    # but keep members made public via metadata\n                    keep = has_doc or self.options.undoc_members or is_metadata_public\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and isprivate:\n                if has_doc or self.options.undoc_members:\n                    if self.options.private_members is None:\n                        keep = False\n                    elif is_filtered_inherited_member(membername, obj):\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    keep = False\n            else:\n                # Check if member was made public via :meta public: metadata\n                # This happens when membername starts with underscore but isprivate is False\n                made_public_via_metadata = (membername.startswith('_') and not isprivate and \n                                          not membername.startswith('__'))\n                \n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                elif made_public_via_metadata:\n                    # Keep members made public via :meta public: even without documentation\n                    keep = True\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n"
    ],
    "Location 3 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 759-767)": [
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes or those made public via metadata\n                    keep = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n"
    ],
    "Location 4 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 731-739)": [
      "\n            metadata = extract_metadata(doc)\n            metadata_public = False\n            if 'private' in metadata:\n                # consider a member private if docstring has \"private\" metadata\n                isprivate = True\n            elif 'public' in metadata:\n                # consider a member public if docstring has \"public\" metadata\n                isprivate = False\n                metadata_public = True\n            else:\n                isprivate = membername.startswith('_')\n",
      "\n            metadata = extract_metadata(doc)\n            metadata_made_public = False\n            if 'private' in metadata:\n                # consider a member private if docstring has \"private\" metadata\n                isprivate = True\n            elif 'public' in metadata:\n                # consider a member public if docstring has \"public\" metadata\n                isprivate = False\n                metadata_made_public = membername.startswith('_')\n            else:\n                isprivate = membername.startswith('_')\n",
      "\n            metadata = extract_metadata(doc)\n            metadata_made_public = False\n            if 'private' in metadata:\n                # consider a member private if docstring has \"private\" metadata\n                isprivate = True\n            elif 'public' in metadata:\n                # consider a member public if docstring has \"public\" metadata\n                isprivate = False\n                metadata_made_public = membername.startswith('_')\n            else:\n                isprivate = membername.startswith('_')\n",
      "\n            metadata = extract_metadata(doc)\n            metadata_public = False\n            if 'private' in metadata:\n                # consider a member private if docstring has \"private\" metadata\n                isprivate = True\n            elif 'public' in metadata:\n                # consider a member public if docstring has \"public\" metadata\n                isprivate = False\n                metadata_public = True\n            else:\n                isprivate = membername.startswith('_')\n\n            keep = False\n            if safe_getattr(member, '__sphinx_mock__', None) is not None:\n                # mocked module or object\n                pass\n            elif self.options.exclude_members and membername in self.options.exclude_members:\n                # remove members given by exclude-members\n                keep = False\n            elif want_all and special_member_re.match(membername):\n                # special __methods__\n                if self.options.special_members is ALL:\n                    keep = has_doc or self.options.undoc_members\n                elif self.options.special_members:\n                    keep = membername in self.options.special_members and \\\n                           (has_doc or self.options.undoc_members)\n                else:\n                    keep = False\n            elif want_all and isprivate:\n                if self.options.private_members is ALL:\n                    keep = has_doc or self.options.undoc_members\n                elif self.options.private_members:\n                    keep = membername in self.options.private_members and \\\n                           (has_doc or self.options.undoc_members)\n                else:\n                    keep = False\n            elif (self.options.members is ALL and\n                  membername.startswith('__') and membername.endswith('__')):\n                # ignore members whose name starts and ends with __ (except in __all__)\n                keep = False\n            elif (self.options.members is ALL and\n                  membername in attr_docs):\n                keep = True\n                has_doc = True\n            elif self.options.members is ALL:\n                if self.options.inherited_members:\n                    keep = False  # because it contains members not in self.object\n                else:\n                    keep = has_doc or self.options.undoc_members or metadata_public\n            elif membername in self.options.members:\n                keep = has_doc or self.options.undoc_members\n",
      "\n            metadata = extract_metadata(doc)\n            metadata_made_public = False\n            if 'private' in metadata:\n                # consider a member private if docstring has \"private\" metadata\n                isprivate = True\n            elif 'public' in metadata:\n                # consider a member public if docstring has \"public\" metadata\n                isprivate = False\n                metadata_made_public = membername.startswith('_')\n            else:\n                isprivate = membername.startswith('_')\n\n            keep = False\n            if safe_getattr(member, '__sphinx_mock__', None) is not None:\n                # mocked module or object\n                pass\n            elif self.options.exclude_members and membername in self.options.exclude_members:\n                # remove members given by exclude-members\n                keep = False\n            elif want_all and special_member_re.match(membername):\n                # special __methods__\n                if self.options.special_members is ALL:\n                    keep = has_doc or self.options.undoc_members\n                elif self.options.special_members:\n                    keep = membername in self.options.special_members and \\\n                           (has_doc or self.options.undoc_members)\n                else:\n                    keep = False\n            elif (not isinstance(member, Callable) and\n                  not inspect.isclass(member) and\n                  not inspect.ismodule(member) and\n                  not hasattr(member, \"__module__\")):\n                # record dependency\n                try:\n                    analyzer.find_attr_docs()\n                    if membername in attr_docs:\n                        keep = True\n                        has_doc = True\n                        doc = '\\n'.join(attr_docs[membername])\n                    elif metadata_made_public:\n                        # keep members made public via :meta public: metadata\n                        keep = True\n                except PycodeError:\n                    pass  # give up if analyzer fails to find the definition\n            elif want_all and isprivate:\n                if has_doc or self.options.undoc_members:\n                    keep = True\n            else:\n                if metadata_made_public:\n                    # keep members made public via :meta public: metadata\n                    keep = True\n                elif has_doc or self.options.undoc_members:\n                    keep = True\n",
      "\n            metadata = extract_metadata(doc)\n            metadata_made_public = False\n            if 'private' in metadata:\n                # consider a member private if docstring has \"private\" metadata\n                isprivate = True\n            elif 'public' in metadata:\n                # consider a member public if docstring has \"public\" metadata\n                isprivate = False\n                metadata_made_public = membername.startswith('_')\n            else:\n                isprivate = membername.startswith('_')\n",
      "\n            metadata = extract_metadata(doc)\n            metadata_made_public = False\n            if 'private' in metadata:\n                # consider a member private if docstring has \"private\" metadata\n                isprivate = True\n            elif 'public' in metadata:\n                # consider a member public if docstring has \"public\" metadata\n                isprivate = False\n                metadata_made_public = membername.startswith('_')\n            else:\n                isprivate = membername.startswith('_')\n",
      "\n            metadata = extract_metadata(doc)\n            metadata_made_public = False\n            if 'private' in metadata:\n                # consider a member private if docstring has \"private\" metadata\n                isprivate = True\n            elif 'public' in metadata:\n                # consider a member public if docstring has \"public\" metadata\n                isprivate = False\n                metadata_made_public = membername.startswith('_')\n            else:\n                isprivate = membername.startswith('_')\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 76265f5be..80821e04d 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -728,15 +728,15 @@ class Documenter:\n \n             has_doc = bool(doc)\n \n-            metadata = extract_metadata(doc)\n-            if 'private' in metadata:\n-                # consider a member private if docstring has \"private\" metadata\n-                isprivate = True\n-            elif 'public' in metadata:\n-                # consider a member public if docstring has \"public\" metadata\n-                isprivate = False\n+\n             else:\n-                isprivate = membername.startswith('_')\n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                else:\n+                    # ignore undocumented members if :undoc-members: is not given\n+                    # but keep members made public via :meta public: metadata\n+                    keep = has_doc or self.options.undoc_members or made_public_by_metadata\n \n             keep = False\n             if safe_getattr(member, '__sphinx_mock__', None) is not None:\n@@ -756,33 +756,43 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n-                if want_all and isprivate:\n+\n+            elif want_all and isprivate:\n+                if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n                         keep = False\n+                    elif is_filtered_inherited_member(membername, obj):\n+                        keep = False\n                     else:\n                         keep = membername in self.options.private_members\n                 else:\n-                    # keep documented attributes\n-                    keep = True\n+                    keep = False\n                 isattr = True\n-            elif want_all and isprivate:\n-                if has_doc or self.options.undoc_members:\n+\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n                     if self.options.private_members is None:\n                         keep = False\n-                    elif is_filtered_inherited_member(membername, obj):\n-                        keep = False\n                     else:\n                         keep = membername in self.options.private_members\n                 else:\n-                    keep = False\n+                    # keep documented attributes\n+                    keep = True\n+                isattr = True\n+\n+            metadata = extract_metadata(doc)\n+            if 'private' in metadata:\n+                # consider a member private if docstring has \"private\" metadata\n+                isprivate = True\n+            elif 'public' in metadata:\n+                # consider a member public if docstring has \"public\" metadata\n+                isprivate = False\n             else:\n-                if (self.options.members is ALL and\n-                        is_filtered_inherited_member(membername, obj)):\n-                    keep = False\n-                else:\n-                    # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                isprivate = membername.startswith('_')\n+            \n+            # Track if member was made public via :meta public: metadata\n+            made_public_by_metadata = (membername.startswith('_') and \n+                                     'public' in metadata)\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 76265f5be..19f8da4a1 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -728,13 +728,16 @@ class Documenter:\n \n             has_doc = bool(doc)\n \n+\n             metadata = extract_metadata(doc)\n+            metadata_public = False\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n                 isprivate = True\n             elif 'public' in metadata:\n                 # consider a member public if docstring has \"public\" metadata\n                 isprivate = False\n+                metadata_public = True\n             else:\n                 isprivate = membername.startswith('_')\n \n@@ -756,6 +759,18 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep documented attributes\n+                    keep = True\n+                isattr = True\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -777,9 +792,33 @@ class Documenter:\n                 else:\n                     keep = False\n             else:\n+                # Check if member was made public via :meta public: metadata\n+                # (underscore name but isprivate=False due to metadata)\n+                is_metadata_public = membername.startswith('_') and not isprivate\n+                \n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+                elif is_metadata_public:\n+                    # Keep members made public via metadata even without documentation\n+                    keep = True\n+                else:\n+                    # ignore undocumented members if :undoc-members: is not given\n+                    keep = has_doc or self.options.undoc_members\n+\n+            else:\n+                # Check if this member was made public via :meta public: metadata\n+                # by seeing if the name suggests it should be private but isprivate is False\n+                made_public_by_metadata = (membername.startswith('_') and \n+                                         not membername.startswith('__') and \n+                                         not isprivate)\n+                \n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                elif made_public_by_metadata:\n+                    # Keep members made public via :meta public: regardless of documentation\n+                    keep = True\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 76265f5be..c5d53c39f 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -728,13 +728,16 @@ class Documenter:\n \n             has_doc = bool(doc)\n \n+\n             metadata = extract_metadata(doc)\n+            metadata_public = False\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n                 isprivate = True\n             elif 'public' in metadata:\n                 # consider a member public if docstring has \"public\" metadata\n                 isprivate = False\n+                metadata_public = True\n             else:\n                 isprivate = membername.startswith('_')\n \n@@ -756,6 +759,18 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep documented attributes\n+                    keep = True\n+                isattr = True\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -777,9 +792,32 @@ class Documenter:\n                 else:\n                     keep = False\n             else:\n+                # Check if member was made public via :meta public: metadata\n+                was_made_public_by_metadata = (membername.startswith('_') and \n+                                             not membername.startswith('__') and \n+                                             not isprivate)\n+                \n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+                elif was_made_public_by_metadata:\n+                    # Keep members made public via :meta public: even without documentation\n+                    keep = True\n+                else:\n+                    # ignore undocumented members if :undoc-members: is not given\n+                    keep = has_doc or self.options.undoc_members\n+\n+            else:\n+                # Check if this was made public via :meta public: metadata\n+                # (member name starts with underscore but isprivate is False)\n+                is_metadata_public = membername.startswith('_') and not isprivate\n+                \n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                elif is_metadata_public:\n+                    # Keep members made public via :meta public: metadata\n+                    keep = True\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 76265f5be..943b6147b 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -728,13 +728,16 @@ class Documenter:\n \n             has_doc = bool(doc)\n \n+\n             metadata = extract_metadata(doc)\n+            metadata_made_public = False\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n                 isprivate = True\n             elif 'public' in metadata:\n                 # consider a member public if docstring has \"public\" metadata\n                 isprivate = False\n+                metadata_made_public = membername.startswith('_')\n             else:\n                 isprivate = membername.startswith('_')\n \n@@ -756,6 +759,18 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep documented attributes\n+                    keep = True\n+                isattr = True\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -780,6 +795,27 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+                else:\n+                    # Check if member was made public via :meta public: metadata\n+                    # (member name starts with underscore but isprivate is False due to metadata)\n+                    made_public_by_metadata = (membername.startswith('_') and not isprivate and \n+                                               not membername.startswith('__'))\n+                    # ignore undocumented members if :undoc-members: is not given,\n+                    # but keep members made public via metadata\n+                    keep = has_doc or self.options.undoc_members or made_public_by_metadata\n+\n+            else:\n+                # Check if this is a member made public via :meta public: metadata\n+                # (member name starts with underscore but isprivate was set to False)\n+                is_metadata_public = (membername.startswith('_') and not membername.startswith('__') \n+                                    and not isprivate)\n+                \n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                elif is_metadata_public:\n+                    # Keep members made public via :meta public: metadata regardless of documentation\n+                    keep = True\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 76265f5be..741db7ebe 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -728,13 +728,16 @@ class Documenter:\n \n             has_doc = bool(doc)\n \n+\n             metadata = extract_metadata(doc)\n+            metadata_made_public = False\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n                 isprivate = True\n             elif 'public' in metadata:\n                 # consider a member public if docstring has \"public\" metadata\n                 isprivate = False\n+                metadata_made_public = membername.startswith('_')\n             else:\n                 isprivate = membername.startswith('_')\n \n@@ -756,6 +759,18 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep documented attributes or those made public via metadata\n+                    keep = True\n+                isattr = True\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -777,12 +792,29 @@ class Documenter:\n                 else:\n                     keep = False\n             else:\n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                else:\n+                    # Check if member was made public via :meta public: metadata\n+                    # (member name starts with underscore but isprivate is False due to metadata)\n+                    made_public_by_metadata = (membername.startswith('_') and not isprivate and \n+                                               not membername.startswith('__'))\n+                    # ignore undocumented members if :undoc-members: is not given\n+                    # but keep members made public via metadata\n+                    keep = has_doc or self.options.undoc_members or made_public_by_metadata\n+\n+            else:\n+                # Check if member was made public via metadata (starts with underscore but isprivate=False)\n+                made_public_by_metadata = membername.startswith('_') and not isprivate\n+                \n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    # but keep members made public via :meta public: metadata\n+                    keep = has_doc or self.options.undoc_members or made_public_by_metadata\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 76265f5be..533ad2ed8 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -728,16 +728,59 @@ class Documenter:\n \n             has_doc = bool(doc)\n \n+\n             metadata = extract_metadata(doc)\n+            metadata_public = False\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n                 isprivate = True\n             elif 'public' in metadata:\n                 # consider a member public if docstring has \"public\" metadata\n                 isprivate = False\n+                metadata_public = True\n             else:\n                 isprivate = membername.startswith('_')\n \n+            keep = False\n+            if safe_getattr(member, '__sphinx_mock__', None) is not None:\n+                # mocked module or object\n+                pass\n+            elif self.options.exclude_members and membername in self.options.exclude_members:\n+                # remove members given by exclude-members\n+                keep = False\n+            elif want_all and special_member_re.match(membername):\n+                # special __methods__\n+                if self.options.special_members is ALL:\n+                    keep = has_doc or self.options.undoc_members\n+                elif self.options.special_members:\n+                    keep = membername in self.options.special_members and \\\n+                           (has_doc or self.options.undoc_members)\n+                else:\n+                    keep = False\n+            elif want_all and isprivate:\n+                if self.options.private_members is ALL:\n+                    keep = has_doc or self.options.undoc_members\n+                elif self.options.private_members:\n+                    keep = membername in self.options.private_members and \\\n+                           (has_doc or self.options.undoc_members)\n+                else:\n+                    keep = False\n+            elif (self.options.members is ALL and\n+                  membername.startswith('__') and membername.endswith('__')):\n+                # ignore members whose name starts and ends with __ (except in __all__)\n+                keep = False\n+            elif (self.options.members is ALL and\n+                  membername in attr_docs):\n+                keep = True\n+                has_doc = True\n+            elif self.options.members is ALL:\n+                if self.options.inherited_members:\n+                    keep = False  # because it contains members not in self.object\n+                else:\n+                    keep = has_doc or self.options.undoc_members or metadata_public\n+            elif membername in self.options.members:\n+                keep = has_doc or self.options.undoc_members\n+\n             keep = False\n             if safe_getattr(member, '__sphinx_mock__', None) is not None:\n                 # mocked module or object\n@@ -756,6 +799,18 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep documented attributes\n+                    keep = True\n+                isattr = True\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -781,8 +836,27 @@ class Documenter:\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n                 else:\n+                    # Check if member was made public via :meta public: metadata\n+                    # (i.e., starts with underscore but isprivate was set to False)\n+                    made_public_via_metadata = (membername.startswith('_') and \n+                                               not isprivate and \n+                                               not membername.startswith('__'))\n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    # but keep members made public via metadata\n+                    keep = has_doc or self.options.undoc_members or made_public_via_metadata\n+\n+            else:\n+                # Check if member was made public via :meta public: metadata\n+                # (i.e., name starts with underscore but isprivate was set to False)\n+                made_public_by_metadata = (membername.startswith('_') and not isprivate)\n+                \n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                else:\n+                    # ignore undocumented members if :undoc-members: is not given\n+                    # but always keep members made public via :meta public: metadata\n+                    keep = has_doc or self.options.undoc_members or made_public_by_metadata\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 76265f5be..323006e80 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -728,16 +728,61 @@ class Documenter:\n \n             has_doc = bool(doc)\n \n+\n             metadata = extract_metadata(doc)\n+            metadata_made_public = False\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n                 isprivate = True\n             elif 'public' in metadata:\n                 # consider a member public if docstring has \"public\" metadata\n                 isprivate = False\n+                metadata_made_public = membername.startswith('_')\n             else:\n                 isprivate = membername.startswith('_')\n \n+            keep = False\n+            if safe_getattr(member, '__sphinx_mock__', None) is not None:\n+                # mocked module or object\n+                pass\n+            elif self.options.exclude_members and membername in self.options.exclude_members:\n+                # remove members given by exclude-members\n+                keep = False\n+            elif want_all and special_member_re.match(membername):\n+                # special __methods__\n+                if self.options.special_members is ALL:\n+                    keep = has_doc or self.options.undoc_members\n+                elif self.options.special_members:\n+                    keep = membername in self.options.special_members and \\\n+                           (has_doc or self.options.undoc_members)\n+                else:\n+                    keep = False\n+            elif (not isinstance(member, Callable) and\n+                  not inspect.isclass(member) and\n+                  not inspect.ismodule(member) and\n+                  not hasattr(member, \"__module__\")):\n+                # record dependency\n+                try:\n+                    analyzer.find_attr_docs()\n+                    if membername in attr_docs:\n+                        keep = True\n+                        has_doc = True\n+                        doc = '\\n'.join(attr_docs[membername])\n+                    elif metadata_made_public:\n+                        # keep members made public via :meta public: metadata\n+                        keep = True\n+                except PycodeError:\n+                    pass  # give up if analyzer fails to find the definition\n+            elif want_all and isprivate:\n+                if has_doc or self.options.undoc_members:\n+                    keep = True\n+            else:\n+                if metadata_made_public:\n+                    # keep members made public via :meta public: metadata\n+                    keep = True\n+                elif has_doc or self.options.undoc_members:\n+                    keep = True\n+\n             keep = False\n             if safe_getattr(member, '__sphinx_mock__', None) is not None:\n                 # mocked module or object\n@@ -756,6 +801,18 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep documented attributes\n+                    keep = True\n+                isattr = True\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -777,9 +834,28 @@ class Documenter:\n                 else:\n                     keep = False\n             else:\n+                # Check if member was made public via :meta public: metadata\n+                made_public_via_metadata = (membername.startswith('_') and not isprivate)\n+                \n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                else:\n+                    # ignore undocumented members if :undoc-members: is not given\n+                    # but keep members made public via :meta public: metadata\n+                    keep = has_doc or self.options.undoc_members or made_public_via_metadata\n+\n+            else:\n+                # Check if member was made public via :meta public: metadata\n+                # (starts with underscore but isprivate was set to False by metadata)\n+                is_metadata_public = (membername.startswith('_') and not isprivate)\n+                \n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+                elif is_metadata_public:\n+                    # Keep members made public via :meta public: metadata\n+                    keep = True\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 76265f5be..47cdf9651 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -728,13 +728,16 @@ class Documenter:\n \n             has_doc = bool(doc)\n \n+\n             metadata = extract_metadata(doc)\n+            metadata_made_public = False\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n                 isprivate = True\n             elif 'public' in metadata:\n                 # consider a member public if docstring has \"public\" metadata\n                 isprivate = False\n+                metadata_made_public = membername.startswith('_')\n             else:\n                 isprivate = membername.startswith('_')\n \n@@ -756,6 +759,18 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep documented attributes\n+                    keep = True\n+                isattr = True\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -780,6 +795,27 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+                else:\n+                    # Check if member was made public via :meta public: metadata\n+                    # (member name starts with underscore but isprivate is False)\n+                    made_public_via_metadata = (membername.startswith('_') and not isprivate)\n+                    \n+                    # ignore undocumented members if :undoc-members: is not given\n+                    # but keep members made public via metadata\n+                    keep = has_doc or self.options.undoc_members or made_public_via_metadata\n+\n+            else:\n+                # Check if member was made public via :meta public: metadata\n+                # (member name starts with underscore but isprivate is False)\n+                is_metadata_public = (membername.startswith('_') and not membername.startswith('__') \n+                                    and not isprivate)\n+                \n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                elif is_metadata_public:\n+                    # Keep members made public via :meta public: metadata\n+                    keep = True\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 76265f5be..88647671e 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -728,13 +728,16 @@ class Documenter:\n \n             has_doc = bool(doc)\n \n+\n             metadata = extract_metadata(doc)\n+            metadata_made_public = False\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n                 isprivate = True\n             elif 'public' in metadata:\n                 # consider a member public if docstring has \"public\" metadata\n                 isprivate = False\n+                metadata_made_public = membername.startswith('_')\n             else:\n                 isprivate = membername.startswith('_')\n \n@@ -756,6 +759,18 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep documented attributes\n+                    keep = True\n+                isattr = True\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -780,6 +795,26 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+                else:\n+                    # Check if member was made public via :meta public: metadata\n+                    # (i.e., starts with underscore but isprivate is False due to metadata)\n+                    is_metadata_public = (membername.startswith('_') and not isprivate and \n+                                        not membername.startswith('__'))\n+                    # ignore undocumented members if :undoc-members: is not given,\n+                    # but keep members made public via metadata\n+                    keep = has_doc or self.options.undoc_members or is_metadata_public\n+\n+            else:\n+                # Check if this member was made public via :meta public: metadata\n+                # by checking if it starts with underscore but isprivate is False\n+                is_metadata_public = membername.startswith('_') and not isprivate\n+                \n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                elif is_metadata_public:\n+                    # Keep members made public via :meta public: metadata regardless of documentation\n+                    keep = True\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 76265f5be..26b04e95d 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -728,13 +728,16 @@ class Documenter:\n \n             has_doc = bool(doc)\n \n+\n             metadata = extract_metadata(doc)\n+            metadata_made_public = False\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n                 isprivate = True\n             elif 'public' in metadata:\n                 # consider a member public if docstring has \"public\" metadata\n                 isprivate = False\n+                metadata_made_public = membername.startswith('_')\n             else:\n                 isprivate = membername.startswith('_')\n \n@@ -756,6 +759,18 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n+            elif (namespace, membername) in attr_docs:\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep documented attributes\n+                    keep = True\n+                isattr = True\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -777,13 +792,35 @@ class Documenter:\n                 else:\n                     keep = False\n             else:\n+                # Check if member was made public via :meta public: metadata\n+                # This happens when membername starts with underscore but isprivate is False\n+                made_public_via_metadata = (membername.startswith('_') and not isprivate and \n+                                          not membername.startswith('__'))\n+                \n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+                elif made_public_via_metadata:\n+                    # Keep members made public via :meta public: even without documentation\n+                    keep = True\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n \n+            else:\n+                # Check if this was made public via :meta public: metadata\n+                # (member name starts with underscore but isprivate was set to False)\n+                is_metadata_public = (membername.startswith('_') and not membername.startswith('__') \n+                                    and not isprivate)\n+                \n+                if (self.options.members is ALL and\n+                        is_filtered_inherited_member(membername, obj)):\n+                    keep = False\n+                else:\n+                    # ignore undocumented members if :undoc-members: is not given\n+                    # but keep members made public via :meta public: metadata\n+                    keep = has_doc or self.options.undoc_members or is_metadata_public\n+\n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n                 keep = False\n"
  }
}