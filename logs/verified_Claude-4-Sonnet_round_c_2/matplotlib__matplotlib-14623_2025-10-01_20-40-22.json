{
  "zero_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/scale.py lines 420-429)": "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"\n        Limit the domain to positive values.\n        \"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300  # This value should rarely if ever\n                             # end up with a visible effect.\n\n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if vmin > 0 and vmax > 0 and vmin > vmax:\n            return (new_vmin, new_vmax)  # Keep original order (inverted)\n        else:\n            return (new_vmin, new_vmax)\n",
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 3629-3641)": "\n        if self.get_yscale() == 'log':\n            # Only validate that values are positive, don't enforce bottom < top\n            if bottom is not None and bottom <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive bottom ylim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                bottom = old_bottom\n            if top is not None and top <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive top ylim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                top = old_top\n",
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 3647-3650)": "\n        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n        # Preserve intentional order inversion for log scale when both values are positive\n        if self.get_yscale() == 'log' and bottom > 0 and top > 0:\n            # Let limit_range_for_scale handle order preservation\n            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n        else:\n            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n\n        self.viewLim.intervaly = (bottom, top)\n",
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 3580-3590)": "\n        get_ylim\n        set_ybound, get_ybound\n        invert_yaxis, yaxis_inverted\n\n        Notes\n        -----\n        The *bottom* value may be greater than the *top* value, in which\n        case the y-axis values will decrease from *bottom* to *top*.\n\n        Examples\n        --------\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/scale.py lines 420-429)": [
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"\n        Limit the domain to positive values.\n        \"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300  # This value should rarely if ever\n                             # end up with a visible effect.\n\n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if vmin > 0 and vmax > 0 and vmin > vmax:\n            return (new_vmin, new_vmax)  # Maintain inverted order\n        else:\n            return (new_vmin, new_vmax)\n",
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"\n        Limit the domain to positive values.\n        \"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300  # This value should rarely if ever\n                             # end up with a visible effect.\n\n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if vmin > 0 and vmax > 0 and vmin > vmax:\n            return (new_vmax, new_vmin)  # Maintain inverted order\n        else:\n            return (new_vmin, new_vmax)\n",
      "\ndef limit_range_for_scale(self, vmin, vmax, minpos):\n    \"\"\"\n    Limit the domain to positive values.\n    \"\"\"\n    if not np.isfinite(minpos):\n        minpos = 1e-300  # This value should rarely if ever\n                         # end up with a visible effect.\n\n    # Handle negative values by replacing with minpos\n    new_vmin = minpos if vmin <= 0 else vmin\n    new_vmax = minpos if vmax <= 0 else vmax\n    \n    # Preserve intentional inversion when both original values are positive\n    if vmin > 0 and vmax > 0 and vmin > vmax:\n        return (new_vmax, new_vmin)  # Maintain inverted order\n    else:\n        return (new_vmin, new_vmax)\n",
      "\ndef limit_range_for_scale(self, vmin, vmax, minpos):\n    \"\"\"\n    Limit the domain to positive values.\n    \"\"\"\n    if not np.isfinite(minpos):\n        minpos = 1e-300  # This value should rarely if ever\n                         # end up with a visible effect.\n\n    # Handle negative values by replacing with minpos\n    new_vmin = minpos if vmin <= 0 else vmin\n    new_vmax = minpos if vmax <= 0 else vmax\n    \n    # Preserve intentional inversion when both original values are positive\n    if vmin > 0 and vmax > 0 and vmin > vmax:\n        return (new_vmax, new_vmin)  # Maintain inverted order\n    else:\n        return (new_vmin, new_vmax)\n",
      "\ndef limit_range_for_scale(self, vmin, vmax, minpos):\n    \"\"\"\n    Limit the domain to positive values.\n    \"\"\"\n    if not np.isfinite(minpos):\n        minpos = 1e-300  # This value should rarely if ever\n                         # end up with a visible effect.\n\n    # Handle negative values by replacing with minpos\n    new_vmin = minpos if vmin <= 0 else vmin\n    new_vmax = minpos if vmax <= 0 else vmax\n    \n    # Preserve intentional inversion when both original values are positive\n    if vmin > 0 and vmax > 0 and vmin > vmax:\n        return (new_vmax, new_vmin)  # Maintain inverted order\n    else:\n        return (new_vmin, new_vmax)\n",
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"\n        Limit the domain to positive values.\n        \"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300  # This value should rarely if ever\n                             # end up with a visible effect.\n\n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if vmin > 0 and vmax > 0 and vmin > vmax:\n            return (new_vmin, new_vmax)  # Maintain original order (inverted)\n        else:\n            return (new_vmin, new_vmax)\n",
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"\n        Limit the domain to positive values.\n        \"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300  # This value should rarely if ever\n                             # end up with a visible effect.\n\n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if vmin > 0 and vmax > 0 and vmin > vmax:\n            return (new_vmax, new_vmin)  # Maintain inverted order\n        else:\n            return (new_vmin, new_vmax)\n",
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"\n        Limit the domain to positive values.\n        \"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300  # This value should rarely if ever\n                             # end up with a visible effect.\n\n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if vmin > 0 and vmax > 0 and vmin > vmax:\n            return (new_vmax, new_vmin)  # Maintain inverted order\n        else:\n            return (new_vmin, new_vmax)\n"
    ],
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 3629-3641)": [
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"Limit the domain to positive values.\"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300\n        \n        # Check if we have intentional inversion with both positive values\n        intentional_inversion = (vmin > 0 and vmax > 0 and vmin > vmax)\n        \n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if intentional_inversion:\n            return (new_vmin, new_vmax)  # Keep original order (inverted)\n        else:\n            return (new_vmin, new_vmax) if new_vmin <= new_vmax else (new_vmax, new_vmin)\n",
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"Limit the domain to positive values.\"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300\n        \n        # Check if original values were intentionally inverted (both positive)\n        intentionally_inverted = vmin > 0 and vmax > 0 and vmin > vmax\n        \n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if intentionally_inverted:\n            return (new_vmin, new_vmax)  # Keep original order (inverted)\n        else:\n            return (min(new_vmin, new_vmax), max(new_vmin, new_vmax))\n",
      "\n        if self.get_yscale() == 'log':\n            # Only validate that values are positive, don't enforce bottom < top\n            if bottom is not None and bottom <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive bottom ylim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                bottom = old_bottom\n            if top is not None and top <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive top ylim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                top = old_top\n",
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"Limit the domain to positive values.\"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300\n        \n        # Check if we have intentional inversion with both positive values\n        intentional_inversion = vmin > 0 and vmax > 0 and vmin > vmax\n        \n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if intentional_inversion:\n            return (new_vmin, new_vmax)  # Keep original order (inverted)\n        else:\n            return (new_vmin, new_vmax) if new_vmin <= new_vmax else (new_vmax, new_vmin)\n",
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"Limit the domain to positive values.\"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300\n        \n        # Check if user intentionally provided inverted order with positive values\n        intentional_inversion = vmin > 0 and vmax > 0 and vmin > vmax\n        \n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if intentional_inversion:\n            return (new_vmin, new_vmax)  # Maintain original order (inverted)\n        else:\n            return (new_vmin, new_vmax)\n",
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"Limit the domain to positive values.\"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300\n        \n        # Check if user intentionally inverted positive values\n        intentionally_inverted = vmin > 0 and vmax > 0 and vmin > vmax\n        \n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if intentionally_inverted:\n            return (new_vmin, new_vmax)  # Keep original order (inverted)\n        else:\n            return (new_vmin, new_vmax)\n",
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"Limit the domain to positive values.\"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300\n        \n        # Check if user intentionally inverted the order with positive values\n        intentionally_inverted = vmin > 0 and vmax > 0 and vmin > vmax\n        \n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if intentionally_inverted:\n            return (new_vmin, new_vmax)  # Keep original order (inverted)\n        else:\n            return (new_vmin, new_vmax)\n",
      "\n        if self.get_yscale() == 'log':\n            # Only validate that values are positive, don't enforce bottom < top\n            if bottom is not None and bottom <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive bottom ylim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                bottom = old_bottom\n            if top is not None and top <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive top ylim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                top = old_top\n"
    ],
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 3647-3650)": [
      "\n        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n        # Preserve intentional order inversion for log scale with positive values\n        if (self.get_yscale() == 'log' and \n            bottom is not None and top is not None and\n            bottom > 0 and top > 0 and bottom > top):\n            # User intentionally inverted limits - preserve this after limit_range_for_scale\n            temp_bottom, temp_top = self.yaxis.limit_range_for_scale(top, bottom)\n            bottom, top = temp_top, temp_bottom\n        else:\n            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n\n        self.viewLim.intervaly = (bottom, top)\n",
      "\n        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n        # Preserve intentional inversion for log scale when both values are positive\n        if (self.get_yscale() == 'log' and bottom is not None and top is not None \n            and bottom > 0 and top > 0 and bottom > top):\n            # Store the intentional inversion before limit_range_for_scale\n            inverted = True\n            temp_bottom, temp_top = self.yaxis.limit_range_for_scale(top, bottom)\n            bottom, top = temp_top, temp_bottom\n        else:\n            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n\n        self.viewLim.intervaly = (bottom, top)\n",
      "\n        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n        \n        # Check if we have intentional inversion before applying limit_range_for_scale\n        was_inverted = bottom > top\n        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n        \n        # If it was intentionally inverted and both values are positive, restore the inversion\n        if was_inverted and bottom > 0 and top > 0 and bottom < top:\n            bottom, top = top, bottom\n\n        self.viewLim.intervaly = (bottom, top)\n",
      "\n        # Make sure both are positive, otherwise set to minpos\n        if not np.isfinite(minpos):\n            minpos = 1e-300  # This should never take this path.\n        \n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if vmin > 0 and vmax > 0 and vmin > vmax:\n            return (new_vmax, new_vmin)  # Maintain inverted order\n        else:\n            return (new_vmin, new_vmax)\n",
      "\n        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n        # Preserve intentional order inversion for log scale when both values are positive\n        if (self.get_yscale() == 'log' and \n            bottom is not None and top is not None and\n            bottom > 0 and top > 0 and bottom > top):\n            # User intentionally set inverted limits - preserve this order\n            bottom, top = self.yaxis.limit_range_for_scale(top, bottom)\n            bottom, top = top, bottom  # Swap back to maintain user's intention\n        else:\n            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n\n        self.viewLim.intervaly = (bottom, top)\n",
      "\n        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n        \n        # For log scale, preserve intentional order inversion when both values are positive\n        if self.get_yscale() == 'log' and bottom > 0 and top > 0 and bottom > top:\n            # User intentionally wants inverted axis - preserve this order\n            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n        else:\n            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n\n        self.viewLim.intervaly = (bottom, top)\n",
      "\n        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n        # Preserve intentional order inversion for log scale with positive values\n        if self.get_yscale() == 'log' and bottom > 0 and top > 0:\n            # Let limit_range_for_scale handle order preservation\n            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n        else:\n            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n\n        self.viewLim.intervaly = (bottom, top)\n",
      "\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"Limit the domain to positive values.\"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300\n        \n        # Remember if user intentionally inverted the order with positive values\n        intentionally_inverted = vmin > 0 and vmax > 0 and vmin > vmax\n        \n        # Replace non-positive values with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values were positive\n        if intentionally_inverted:\n            return new_vmax, new_vmin\n        else:\n            return new_vmin, new_vmax\n"
    ],
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 3580-3590)": [
      "\n        get_ylim\n        set_ybound, get_ybound\n        invert_yaxis, yaxis_inverted\n\n        Notes\n        -----\n        The *bottom* value may be greater than the *top* value, in which\n        case the y-axis values will decrease from *bottom* to *top*.\n\n        Examples\n        --------\n",
      "\n        get_ylim\n        set_ybound, get_ybound\n        invert_yaxis, yaxis_inverted\n\n        Notes\n        -----\n        The *bottom* value may be greater than the *top* value, in which\n        case the y-axis values will decrease from *bottom* to *top*.\n\n        Examples\n        --------\n",
      "\n        def limit_range_for_scale(self, vmin, vmax, minpos):\n            \"\"\"Limit the domain to positive values.\"\"\"\n            if not np.isfinite(minpos):\n                minpos = 1e-300  # This should never take this branch.\n            \n            # Handle negative values by replacing with minpos\n            new_vmin = minpos if vmin <= 0 else vmin\n            new_vmax = minpos if vmax <= 0 else vmax\n            \n            # Preserve intentional inversion when both original values are positive\n            if vmin > 0 and vmax > 0 and vmin > vmax:\n                return new_vmin, new_vmax  # Maintain inverted order\n            else:\n                return new_vmin, new_vmax\n",
      "\n        get_ylim\n        set_ybound, get_ybound\n        invert_yaxis, yaxis_inverted\n\n        Notes\n        -----\n        The *bottom* value may be greater than the *top* value, in which\n        case the y-axis values will decrease from *bottom* to *top*.\n\n        Examples\n        --------\n",
      "\n        \"\"\"Limit the domain to positive values.\"\"\"\n        if not np.isfinite(minpos):\n            minpos = 1e-300\n        \n        # Handle negative values by replacing with minpos\n        new_vmin = minpos if vmin <= 0 else vmin\n        new_vmax = minpos if vmax <= 0 else vmax\n        \n        # Preserve intentional inversion when both original values are positive\n        if vmin > 0 and vmax > 0 and vmin > vmax:\n            return (new_vmax, new_vmin)  # Maintain inverted order\n        else:\n            return (new_vmin, new_vmax)\n",
      "\n        def limit_range_for_scale(self, vmin, vmax, minpos):\n            \"\"\"Limit the domain to positive values.\"\"\"\n            if not np.isfinite(minpos):\n                minpos = 1e-300\n            \n            # Handle negative values by replacing with minpos\n            new_vmin = minpos if vmin <= 0 else vmin\n            new_vmax = minpos if vmax <= 0 else vmax\n            \n            # Preserve intentional inversion when both original values are positive\n            if vmin > 0 and vmax > 0 and vmin > vmax:\n                return (new_vmax, new_vmin)  # Maintain inverted order\n            else:\n                return (new_vmin, new_vmax)\n",
      "\n        get_ylim\n        set_ybound, get_ybound\n        invert_yaxis, yaxis_inverted\n\n        Notes\n        -----\n        The *bottom* value may be greater than the *top* value, in which\n        case the y-axis values will decrease from *bottom* to *top*.\n\n        Examples\n        --------\n",
      "\n        get_ylim\n        set_ybound, get_ybound\n        invert_yaxis, yaxis_inverted\n\n        Notes\n        -----\n        The *bottom* value may be greater than the *top* value, in which\n        case the y-axis values will decrease from *bottom* to *top*.\n\n        Examples\n        --------\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6f57..beb49f9197 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3577,6 +3577,7 @@ class _AxesBase(martist.Artist):\n \n         See Also\n         --------\n+\n         get_ylim\n         set_ybound, get_ybound\n         invert_yaxis, yaxis_inverted\n@@ -3626,14 +3627,15 @@ class _AxesBase(martist.Artist):\n         if top is None:\n             top = old_top\n \n+\n         if self.get_yscale() == 'log':\n-            if bottom <= 0:\n+            if bottom is not None and bottom <= 0:\n                 cbook._warn_external(\n                     'Attempted to set non-positive bottom ylim on a '\n                     'log-scaled axis.\\n'\n                     'Invalid limit will be ignored.')\n                 bottom = old_bottom\n-            if top <= 0:\n+            if top is not None and top <= 0:\n                 cbook._warn_external(\n                     'Attempted to set non-positive top ylim on a '\n                     'log-scaled axis.\\n'\n@@ -3644,6 +3646,7 @@ class _AxesBase(martist.Artist):\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n \ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..d2d8241680 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -417,6 +417,7 @@ class LogScale(ScaleBase):\n         \"\"\"\n         return self._transform\n \n+\n     def limit_range_for_scale(self, vmin, vmax, minpos):\n         \"\"\"\n         Limit the domain to positive values.\n@@ -425,8 +426,15 @@ class LogScale(ScaleBase):\n             minpos = 1e-300  # This value should rarely if ever\n                              # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if vmin > 0 and vmax > 0 and vmin > vmax:\n+            return (new_vmin, new_vmax)  # Maintain inverted order\n+        else:\n+            return (new_vmin, new_vmax)\n \n \n class FuncScaleLog(LogScale):\n",
    "variant_0": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6f57..1c4b73eb2d 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3577,6 +3577,7 @@ class _AxesBase(martist.Artist):\n \n         See Also\n         --------\n+\n         get_ylim\n         set_ybound, get_ybound\n         invert_yaxis, yaxis_inverted\n@@ -3626,14 +3627,16 @@ class _AxesBase(martist.Artist):\n         if top is None:\n             top = old_top\n \n+\n         if self.get_yscale() == 'log':\n-            if bottom <= 0:\n+            # Only validate that values are positive, don't enforce bottom < top\n+            if bottom is not None and bottom <= 0:\n                 cbook._warn_external(\n                     'Attempted to set non-positive bottom ylim on a '\n                     'log-scaled axis.\\n'\n                     'Invalid limit will be ignored.')\n                 bottom = old_bottom\n-            if top <= 0:\n+            if top is not None and top <= 0:\n                 cbook._warn_external(\n                     'Attempted to set non-positive top ylim on a '\n                     'log-scaled axis.\\n'\n@@ -3644,8 +3647,14 @@ class _AxesBase(martist.Artist):\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n-        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        # Preserve intentional order inversion for log scale when both values are positive\n+        if self.get_yscale() == 'log' and bottom > 0 and top > 0:\n+            # Let limit_range_for_scale handle order preservation\n+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        else:\n+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..980b570559 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -417,6 +417,7 @@ class LogScale(ScaleBase):\n         \"\"\"\n         return self._transform\n \n+\n     def limit_range_for_scale(self, vmin, vmax, minpos):\n         \"\"\"\n         Limit the domain to positive values.\n@@ -425,8 +426,15 @@ class LogScale(ScaleBase):\n             minpos = 1e-300  # This value should rarely if ever\n                              # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if vmin > 0 and vmax > 0 and vmin > vmax:\n+            return (new_vmin, new_vmax)  # Keep original order (inverted)\n+        else:\n+            return (new_vmin, new_vmax)\n \n \n class FuncScaleLog(LogScale):\n",
    "variant_1": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6f57..2e75fd876e 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3577,6 +3577,7 @@ class _AxesBase(martist.Artist):\n \n         See Also\n         --------\n+\n         get_ylim\n         set_ybound, get_ybound\n         invert_yaxis, yaxis_inverted\n@@ -3626,26 +3627,40 @@ class _AxesBase(martist.Artist):\n         if top is None:\n             top = old_top\n \n-        if self.get_yscale() == 'log':\n-            if bottom <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive bottom ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                bottom = old_bottom\n-            if top <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive top ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                top = old_top\n+\n+    def limit_range_for_scale(self, vmin, vmax, minpos):\n+        \"\"\"Limit the domain to positive values.\"\"\"\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300\n+        \n+        # Check if we have intentional inversion with both positive values\n+        intentional_inversion = (vmin > 0 and vmax > 0 and vmin > vmax)\n+        \n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if intentional_inversion:\n+            return (new_vmin, new_vmax)  # Keep original order (inverted)\n+        else:\n+            return (new_vmin, new_vmax) if new_vmin <= new_vmax else (new_vmax, new_vmin)\n         if bottom == top:\n             cbook._warn_external(\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n-        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        # Preserve intentional order inversion for log scale with positive values\n+        if (self.get_yscale() == 'log' and \n+            bottom is not None and top is not None and\n+            bottom > 0 and top > 0 and bottom > top):\n+            # User intentionally inverted limits - preserve this after limit_range_for_scale\n+            temp_bottom, temp_top = self.yaxis.limit_range_for_scale(top, bottom)\n+            bottom, top = temp_top, temp_bottom\n+        else:\n+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..d2d8241680 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -417,6 +417,7 @@ class LogScale(ScaleBase):\n         \"\"\"\n         return self._transform\n \n+\n     def limit_range_for_scale(self, vmin, vmax, minpos):\n         \"\"\"\n         Limit the domain to positive values.\n@@ -425,8 +426,15 @@ class LogScale(ScaleBase):\n             minpos = 1e-300  # This value should rarely if ever\n                              # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if vmin > 0 and vmax > 0 and vmin > vmax:\n+            return (new_vmin, new_vmax)  # Maintain inverted order\n+        else:\n+            return (new_vmin, new_vmax)\n \n \n class FuncScaleLog(LogScale):\n",
    "variant_2": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6f57..7e364acc1c 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3577,6 +3577,7 @@ class _AxesBase(martist.Artist):\n \n         See Also\n         --------\n+\n         get_ylim\n         set_ybound, get_ybound\n         invert_yaxis, yaxis_inverted\n@@ -3626,26 +3627,40 @@ class _AxesBase(martist.Artist):\n         if top is None:\n             top = old_top\n \n-        if self.get_yscale() == 'log':\n-            if bottom <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive bottom ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                bottom = old_bottom\n-            if top <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive top ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                top = old_top\n+\n+    def limit_range_for_scale(self, vmin, vmax, minpos):\n+        \"\"\"Limit the domain to positive values.\"\"\"\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300\n+        \n+        # Check if original values were intentionally inverted (both positive)\n+        intentionally_inverted = vmin > 0 and vmax > 0 and vmin > vmax\n+        \n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if intentionally_inverted:\n+            return (new_vmin, new_vmax)  # Keep original order (inverted)\n+        else:\n+            return (min(new_vmin, new_vmax), max(new_vmin, new_vmax))\n         if bottom == top:\n             cbook._warn_external(\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n-        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        # Preserve intentional inversion for log scale when both values are positive\n+        if (self.get_yscale() == 'log' and bottom is not None and top is not None \n+            and bottom > 0 and top > 0 and bottom > top):\n+            # Store the intentional inversion before limit_range_for_scale\n+            inverted = True\n+            temp_bottom, temp_top = self.yaxis.limit_range_for_scale(top, bottom)\n+            bottom, top = temp_top, temp_bottom\n+        else:\n+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..1371e8eaa4 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -417,6 +417,7 @@ class LogScale(ScaleBase):\n         \"\"\"\n         return self._transform\n \n+\n     def limit_range_for_scale(self, vmin, vmax, minpos):\n         \"\"\"\n         Limit the domain to positive values.\n@@ -425,8 +426,15 @@ class LogScale(ScaleBase):\n             minpos = 1e-300  # This value should rarely if ever\n                              # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if vmin > 0 and vmax > 0 and vmin > vmax:\n+            return (new_vmax, new_vmin)  # Maintain inverted order\n+        else:\n+            return (new_vmin, new_vmax)\n \n \n class FuncScaleLog(LogScale):\n",
    "variant_3": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6f57..384a4e49dc 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3577,17 +3577,21 @@ class _AxesBase(martist.Artist):\n \n         See Also\n         --------\n-        get_ylim\n-        set_ybound, get_ybound\n-        invert_yaxis, yaxis_inverted\n-\n-        Notes\n-        -----\n-        The *bottom* value may be greater than the *top* value, in which\n-        case the y-axis values will decrease from *bottom* to *top*.\n \n-        Examples\n-        --------\n+        def limit_range_for_scale(self, vmin, vmax, minpos):\n+            \"\"\"Limit the domain to positive values.\"\"\"\n+            if not np.isfinite(minpos):\n+                minpos = 1e-300  # This should never take this branch.\n+            \n+            # Handle negative values by replacing with minpos\n+            new_vmin = minpos if vmin <= 0 else vmin\n+            new_vmax = minpos if vmax <= 0 else vmax\n+            \n+            # Preserve intentional inversion when both original values are positive\n+            if vmin > 0 and vmax > 0 and vmin > vmax:\n+                return new_vmin, new_vmax  # Maintain inverted order\n+            else:\n+                return new_vmin, new_vmax\n         >>> set_ylim(bottom, top)\n         >>> set_ylim((bottom, top))\n         >>> bottom, top = set_ylim(bottom, top)\n@@ -3626,14 +3630,16 @@ class _AxesBase(martist.Artist):\n         if top is None:\n             top = old_top\n \n+\n         if self.get_yscale() == 'log':\n-            if bottom <= 0:\n+            # Only validate that values are positive, don't enforce bottom < top\n+            if bottom is not None and bottom <= 0:\n                 cbook._warn_external(\n                     'Attempted to set non-positive bottom ylim on a '\n                     'log-scaled axis.\\n'\n                     'Invalid limit will be ignored.')\n                 bottom = old_bottom\n-            if top <= 0:\n+            if top is not None and top <= 0:\n                 cbook._warn_external(\n                     'Attempted to set non-positive top ylim on a '\n                     'log-scaled axis.\\n'\n@@ -3644,8 +3650,16 @@ class _AxesBase(martist.Artist):\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n+        \n+        # Check if we have intentional inversion before applying limit_range_for_scale\n+        was_inverted = bottom > top\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        \n+        # If it was intentionally inverted and both values are positive, restore the inversion\n+        if was_inverted and bottom > 0 and top > 0 and bottom < top:\n+            bottom, top = top, bottom\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..f75b25296d 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -417,16 +417,24 @@ class LogScale(ScaleBase):\n         \"\"\"\n         return self._transform\n \n-    def limit_range_for_scale(self, vmin, vmax, minpos):\n-        \"\"\"\n-        Limit the domain to positive values.\n-        \"\"\"\n-        if not np.isfinite(minpos):\n-            minpos = 1e-300  # This value should rarely if ever\n-                             # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+def limit_range_for_scale(self, vmin, vmax, minpos):\n+    \"\"\"\n+    Limit the domain to positive values.\n+    \"\"\"\n+    if not np.isfinite(minpos):\n+        minpos = 1e-300  # This value should rarely if ever\n+                         # end up with a visible effect.\n+\n+    # Handle negative values by replacing with minpos\n+    new_vmin = minpos if vmin <= 0 else vmin\n+    new_vmax = minpos if vmax <= 0 else vmax\n+    \n+    # Preserve intentional inversion when both original values are positive\n+    if vmin > 0 and vmax > 0 and vmin > vmax:\n+        return (new_vmax, new_vmin)  # Maintain inverted order\n+    else:\n+        return (new_vmin, new_vmax)\n \n \n class FuncScaleLog(LogScale):\n",
    "variant_4": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6f57..cd2999b246 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3577,6 +3577,7 @@ class _AxesBase(martist.Artist):\n \n         See Also\n         --------\n+\n         get_ylim\n         set_ybound, get_ybound\n         invert_yaxis, yaxis_inverted\n@@ -3626,28 +3627,43 @@ class _AxesBase(martist.Artist):\n         if top is None:\n             top = old_top\n \n-        if self.get_yscale() == 'log':\n-            if bottom <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive bottom ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                bottom = old_bottom\n-            if top <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive top ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                top = old_top\n+\n+    def limit_range_for_scale(self, vmin, vmax, minpos):\n+        \"\"\"Limit the domain to positive values.\"\"\"\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300\n+        \n+        # Check if we have intentional inversion with both positive values\n+        intentional_inversion = vmin > 0 and vmax > 0 and vmin > vmax\n+        \n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if intentional_inversion:\n+            return (new_vmin, new_vmax)  # Keep original order (inverted)\n+        else:\n+            return (new_vmin, new_vmax) if new_vmin <= new_vmax else (new_vmax, new_vmin)\n         if bottom == top:\n             cbook._warn_external(\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n-        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n-        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n \n-        self.viewLim.intervaly = (bottom, top)\n+        # Make sure both are positive, otherwise set to minpos\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300  # This should never take this path.\n+        \n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if vmin > 0 and vmax > 0 and vmin > vmax:\n+            return (new_vmax, new_vmin)  # Maintain inverted order\n+        else:\n+            return (new_vmin, new_vmax)\n         if auto is not None:\n             self._autoscaleYon = bool(auto)\n \ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..f75b25296d 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -417,16 +417,24 @@ class LogScale(ScaleBase):\n         \"\"\"\n         return self._transform\n \n-    def limit_range_for_scale(self, vmin, vmax, minpos):\n-        \"\"\"\n-        Limit the domain to positive values.\n-        \"\"\"\n-        if not np.isfinite(minpos):\n-            minpos = 1e-300  # This value should rarely if ever\n-                             # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+def limit_range_for_scale(self, vmin, vmax, minpos):\n+    \"\"\"\n+    Limit the domain to positive values.\n+    \"\"\"\n+    if not np.isfinite(minpos):\n+        minpos = 1e-300  # This value should rarely if ever\n+                         # end up with a visible effect.\n+\n+    # Handle negative values by replacing with minpos\n+    new_vmin = minpos if vmin <= 0 else vmin\n+    new_vmax = minpos if vmax <= 0 else vmax\n+    \n+    # Preserve intentional inversion when both original values are positive\n+    if vmin > 0 and vmax > 0 and vmin > vmax:\n+        return (new_vmax, new_vmin)  # Maintain inverted order\n+    else:\n+        return (new_vmin, new_vmax)\n \n \n class FuncScaleLog(LogScale):\n",
    "variant_5": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6f57..a7cd009361 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3577,17 +3577,20 @@ class _AxesBase(martist.Artist):\n \n         See Also\n         --------\n-        get_ylim\n-        set_ybound, get_ybound\n-        invert_yaxis, yaxis_inverted\n-\n-        Notes\n-        -----\n-        The *bottom* value may be greater than the *top* value, in which\n-        case the y-axis values will decrease from *bottom* to *top*.\n \n-        Examples\n-        --------\n+        \"\"\"Limit the domain to positive values.\"\"\"\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300\n+        \n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if vmin > 0 and vmax > 0 and vmin > vmax:\n+            return (new_vmax, new_vmin)  # Maintain inverted order\n+        else:\n+            return (new_vmin, new_vmax)\n         >>> set_ylim(bottom, top)\n         >>> set_ylim((bottom, top))\n         >>> bottom, top = set_ylim(bottom, top)\n@@ -3626,26 +3629,40 @@ class _AxesBase(martist.Artist):\n         if top is None:\n             top = old_top\n \n-        if self.get_yscale() == 'log':\n-            if bottom <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive bottom ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                bottom = old_bottom\n-            if top <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive top ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                top = old_top\n+\n+    def limit_range_for_scale(self, vmin, vmax, minpos):\n+        \"\"\"Limit the domain to positive values.\"\"\"\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300\n+        \n+        # Check if user intentionally provided inverted order with positive values\n+        intentional_inversion = vmin > 0 and vmax > 0 and vmin > vmax\n+        \n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if intentional_inversion:\n+            return (new_vmin, new_vmax)  # Maintain original order (inverted)\n+        else:\n+            return (new_vmin, new_vmax)\n         if bottom == top:\n             cbook._warn_external(\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n-        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        # Preserve intentional order inversion for log scale when both values are positive\n+        if (self.get_yscale() == 'log' and \n+            bottom is not None and top is not None and\n+            bottom > 0 and top > 0 and bottom > top):\n+            # User intentionally set inverted limits - preserve this order\n+            bottom, top = self.yaxis.limit_range_for_scale(top, bottom)\n+            bottom, top = top, bottom  # Swap back to maintain user's intention\n+        else:\n+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..f75b25296d 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -417,16 +417,24 @@ class LogScale(ScaleBase):\n         \"\"\"\n         return self._transform\n \n-    def limit_range_for_scale(self, vmin, vmax, minpos):\n-        \"\"\"\n-        Limit the domain to positive values.\n-        \"\"\"\n-        if not np.isfinite(minpos):\n-            minpos = 1e-300  # This value should rarely if ever\n-                             # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+def limit_range_for_scale(self, vmin, vmax, minpos):\n+    \"\"\"\n+    Limit the domain to positive values.\n+    \"\"\"\n+    if not np.isfinite(minpos):\n+        minpos = 1e-300  # This value should rarely if ever\n+                         # end up with a visible effect.\n+\n+    # Handle negative values by replacing with minpos\n+    new_vmin = minpos if vmin <= 0 else vmin\n+    new_vmax = minpos if vmax <= 0 else vmax\n+    \n+    # Preserve intentional inversion when both original values are positive\n+    if vmin > 0 and vmax > 0 and vmin > vmax:\n+        return (new_vmax, new_vmin)  # Maintain inverted order\n+    else:\n+        return (new_vmin, new_vmax)\n \n \n class FuncScaleLog(LogScale):\n",
    "variant_6": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6f57..6f97911ee3 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3577,17 +3577,21 @@ class _AxesBase(martist.Artist):\n \n         See Also\n         --------\n-        get_ylim\n-        set_ybound, get_ybound\n-        invert_yaxis, yaxis_inverted\n-\n-        Notes\n-        -----\n-        The *bottom* value may be greater than the *top* value, in which\n-        case the y-axis values will decrease from *bottom* to *top*.\n \n-        Examples\n-        --------\n+        def limit_range_for_scale(self, vmin, vmax, minpos):\n+            \"\"\"Limit the domain to positive values.\"\"\"\n+            if not np.isfinite(minpos):\n+                minpos = 1e-300\n+            \n+            # Handle negative values by replacing with minpos\n+            new_vmin = minpos if vmin <= 0 else vmin\n+            new_vmax = minpos if vmax <= 0 else vmax\n+            \n+            # Preserve intentional inversion when both original values are positive\n+            if vmin > 0 and vmax > 0 and vmin > vmax:\n+                return (new_vmax, new_vmin)  # Maintain inverted order\n+            else:\n+                return (new_vmin, new_vmax)\n         >>> set_ylim(bottom, top)\n         >>> set_ylim((bottom, top))\n         >>> bottom, top = set_ylim(bottom, top)\n@@ -3626,26 +3630,38 @@ class _AxesBase(martist.Artist):\n         if top is None:\n             top = old_top\n \n-        if self.get_yscale() == 'log':\n-            if bottom <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive bottom ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                bottom = old_bottom\n-            if top <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive top ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                top = old_top\n+\n+    def limit_range_for_scale(self, vmin, vmax, minpos):\n+        \"\"\"Limit the domain to positive values.\"\"\"\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300\n+        \n+        # Check if user intentionally inverted positive values\n+        intentionally_inverted = vmin > 0 and vmax > 0 and vmin > vmax\n+        \n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if intentionally_inverted:\n+            return (new_vmin, new_vmax)  # Keep original order (inverted)\n+        else:\n+            return (new_vmin, new_vmax)\n         if bottom == top:\n             cbook._warn_external(\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n-        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        \n+        # For log scale, preserve intentional order inversion when both values are positive\n+        if self.get_yscale() == 'log' and bottom > 0 and top > 0 and bottom > top:\n+            # User intentionally wants inverted axis - preserve this order\n+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        else:\n+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..9d4537cd5d 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -417,6 +417,7 @@ class LogScale(ScaleBase):\n         \"\"\"\n         return self._transform\n \n+\n     def limit_range_for_scale(self, vmin, vmax, minpos):\n         \"\"\"\n         Limit the domain to positive values.\n@@ -425,8 +426,15 @@ class LogScale(ScaleBase):\n             minpos = 1e-300  # This value should rarely if ever\n                              # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if vmin > 0 and vmax > 0 and vmin > vmax:\n+            return (new_vmin, new_vmax)  # Maintain original order (inverted)\n+        else:\n+            return (new_vmin, new_vmax)\n \n \n class FuncScaleLog(LogScale):\n",
    "variant_7": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6f57..b65afbba4f 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3577,6 +3577,7 @@ class _AxesBase(martist.Artist):\n \n         See Also\n         --------\n+\n         get_ylim\n         set_ybound, get_ybound\n         invert_yaxis, yaxis_inverted\n@@ -3626,26 +3627,37 @@ class _AxesBase(martist.Artist):\n         if top is None:\n             top = old_top\n \n-        if self.get_yscale() == 'log':\n-            if bottom <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive bottom ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                bottom = old_bottom\n-            if top <= 0:\n-                cbook._warn_external(\n-                    'Attempted to set non-positive top ylim on a '\n-                    'log-scaled axis.\\n'\n-                    'Invalid limit will be ignored.')\n-                top = old_top\n+\n+    def limit_range_for_scale(self, vmin, vmax, minpos):\n+        \"\"\"Limit the domain to positive values.\"\"\"\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300\n+        \n+        # Check if user intentionally inverted the order with positive values\n+        intentionally_inverted = vmin > 0 and vmax > 0 and vmin > vmax\n+        \n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if intentionally_inverted:\n+            return (new_vmin, new_vmax)  # Keep original order (inverted)\n+        else:\n+            return (new_vmin, new_vmax)\n         if bottom == top:\n             cbook._warn_external(\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n-        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        # Preserve intentional order inversion for log scale with positive values\n+        if self.get_yscale() == 'log' and bottom > 0 and top > 0:\n+            # Let limit_range_for_scale handle order preservation\n+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        else:\n+            bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..1371e8eaa4 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -417,6 +417,7 @@ class LogScale(ScaleBase):\n         \"\"\"\n         return self._transform\n \n+\n     def limit_range_for_scale(self, vmin, vmax, minpos):\n         \"\"\"\n         Limit the domain to positive values.\n@@ -425,8 +426,15 @@ class LogScale(ScaleBase):\n             minpos = 1e-300  # This value should rarely if ever\n                              # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if vmin > 0 and vmax > 0 and vmin > vmax:\n+            return (new_vmax, new_vmin)  # Maintain inverted order\n+        else:\n+            return (new_vmin, new_vmax)\n \n \n class FuncScaleLog(LogScale):\n",
    "variant_8": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex da2dea6f57..9297ec5a03 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3577,6 +3577,7 @@ class _AxesBase(martist.Artist):\n \n         See Also\n         --------\n+\n         get_ylim\n         set_ybound, get_ybound\n         invert_yaxis, yaxis_inverted\n@@ -3626,14 +3627,16 @@ class _AxesBase(martist.Artist):\n         if top is None:\n             top = old_top\n \n+\n         if self.get_yscale() == 'log':\n-            if bottom <= 0:\n+            # Only validate that values are positive, don't enforce bottom < top\n+            if bottom is not None and bottom <= 0:\n                 cbook._warn_external(\n                     'Attempted to set non-positive bottom ylim on a '\n                     'log-scaled axis.\\n'\n                     'Invalid limit will be ignored.')\n                 bottom = old_bottom\n-            if top <= 0:\n+            if top is not None and top <= 0:\n                 cbook._warn_external(\n                     'Attempted to set non-positive top ylim on a '\n                     'log-scaled axis.\\n'\n@@ -3644,10 +3647,24 @@ class _AxesBase(martist.Artist):\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n-        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n-        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n \n-        self.viewLim.intervaly = (bottom, top)\n+    def limit_range_for_scale(self, vmin, vmax, minpos):\n+        \"\"\"Limit the domain to positive values.\"\"\"\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300\n+        \n+        # Remember if user intentionally inverted the order with positive values\n+        intentionally_inverted = vmin > 0 and vmax > 0 and vmin > vmax\n+        \n+        # Replace non-positive values with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values were positive\n+        if intentionally_inverted:\n+            return new_vmax, new_vmin\n+        else:\n+            return new_vmin, new_vmax\n         if auto is not None:\n             self._autoscaleYon = bool(auto)\n \ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..1371e8eaa4 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -417,6 +417,7 @@ class LogScale(ScaleBase):\n         \"\"\"\n         return self._transform\n \n+\n     def limit_range_for_scale(self, vmin, vmax, minpos):\n         \"\"\"\n         Limit the domain to positive values.\n@@ -425,8 +426,15 @@ class LogScale(ScaleBase):\n             minpos = 1e-300  # This value should rarely if ever\n                              # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+        # Handle negative values by replacing with minpos\n+        new_vmin = minpos if vmin <= 0 else vmin\n+        new_vmax = minpos if vmax <= 0 else vmax\n+        \n+        # Preserve intentional inversion when both original values are positive\n+        if vmin > 0 and vmax > 0 and vmin > vmax:\n+            return (new_vmax, new_vmin)  # Maintain inverted order\n+        else:\n+            return (new_vmin, new_vmax)\n \n \n class FuncScaleLog(LogScale):\n"
  }
}