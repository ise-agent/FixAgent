{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/core/servers/basehttp.py lines 113-148)": "\nclass ServerHandler(simple_server.ServerHandler):\n    http_version = \"1.1\"\n\n    def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n        \"\"\"\n        Use a LimitedStream so that unread request data will be ignored at\n        the end of the request. WSGIRequest uses a LimitedStream but it\n        shouldn't discard the data since the upstream servers usually do this.\n        This fix applies only for testserver/runserver.\n        \"\"\"\n        try:\n            content_length = int(environ.get(\"CONTENT_LENGTH\"))\n        except (ValueError, TypeError):\n            content_length = 0\n        super().__init__(\n            LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n        )\n\n    def cleanup_headers(self):\n        super().cleanup_headers()\n        # HTTP/1.1 requires support for persistent connections. Send 'close' if\n        # the content length is unknown to prevent clients from reusing the\n        # connection.\n        if \"Content-Length\" not in self.headers:\n            self.headers[\"Connection\"] = \"close\"\n        # Persistent connections require threading server.\n        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n            self.headers[\"Connection\"] = \"close\"\n        # Mark the connection for closing if it's set as such above or if the\n        # application sent the header.\n        if self.headers.get(\"Connection\") == \"close\":\n            self.request_handler.close_connection = True\n\n    def write(self, data):\n        \"\"\"\n        'write()' callable as specified by PEP 3333.\n        \n        For HEAD requests, suppress the response body to comply with RFC 2616.\n        \"\"\"\n        # For HEAD requests, don't write the response body\n        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n            # Still need to track bytes for Content-Length header accuracy\n            if not self.headers_sent:\n                self.bytes_sent = len(data)\n                self.send_headers()\n            else:\n                self.bytes_sent += len(data)\n            # Don't write the actual data for HEAD requests\n            return\n        \n        # For all other request methods, use the parent implementation\n        super().write(data)\n\n    def close(self):\n        self.get_stdin().read()\n        super().close()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/core/servers/basehttp.py lines 113-148)": [
      "\nclass ServerHandler(simple_server.ServerHandler):\n    http_version = \"1.1\"\n\n    def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n        \"\"\"\n        Use a LimitedStream so that unread request data will be ignored at\n        the end of the request. WSGIRequest uses a LimitedStream but it\n        shouldn't discard the data since the upstream servers usually do this.\n        This fix applies only for testserver/runserver.\n        \"\"\"\n        try:\n            content_length = int(environ.get(\"CONTENT_LENGTH\"))\n        except (ValueError, TypeError):\n            content_length = 0\n        super().__init__(\n            LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n        )\n\n    def cleanup_headers(self):\n        super().cleanup_headers()\n        # HTTP/1.1 requires support for persistent connections. Send 'close' if\n        # the content length is unknown to prevent clients from reusing the\n        # connection.\n        if \"Content-Length\" not in self.headers:\n            self.headers[\"Connection\"] = \"close\"\n        # Persistent connections require threading server.\n        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n            self.headers[\"Connection\"] = \"close\"\n        # Mark the connection for closing if it's set as such above or if the\n        # application sent the header.\n        if self.headers.get(\"Connection\") == \"close\":\n            self.request_handler.close_connection = True\n\n    def write(self, data):\n        \"\"\"\n        'write()' callable as specified by PEP 3333.\n        \n        For HEAD requests, suppress the response body to comply with RFC 2616.\n        \"\"\"\n        # For HEAD requests, don't write the response body\n        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n            # Still need to track bytes for Content-Length header accuracy\n            if not self.headers_sent:\n                self.bytes_sent = len(data)\n                self.send_headers()\n            else:\n                self.bytes_sent += len(data)\n            # Don't write the actual data for HEAD requests\n            return\n        \n        # For all other request methods, use the parent implementation\n        super().write(data)\n\n    def close(self):\n        self.get_stdin().read()\n        super().close()\n",
      "\nclass ServerHandler(simple_server.ServerHandler):\n    http_version = \"1.1\"\n\n    def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n        \"\"\"\n        Use a LimitedStream so that unread request data will be ignored at\n        the end of the request. WSGIRequest uses a LimitedStream but it\n        shouldn't discard the data since the upstream servers usually do this.\n        This fix applies only for testserver/runserver.\n        \"\"\"\n        try:\n            content_length = int(environ.get(\"CONTENT_LENGTH\"))\n        except (ValueError, TypeError):\n            content_length = 0\n        super().__init__(\n            LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n        )\n\n    def cleanup_headers(self):\n        super().cleanup_headers()\n        # HTTP/1.1 requires support for persistent connections. Send 'close' if\n        # the content length is unknown to prevent clients from reusing the\n        # connection.\n        if \"Content-Length\" not in self.headers:\n            self.headers[\"Connection\"] = \"close\"\n        # Persistent connections require threading server.\n        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n            self.headers[\"Connection\"] = \"close\"\n        # Mark the connection for closing if it's set as such above or if the\n        # application sent the header.\n        if self.headers.get(\"Connection\") == \"close\":\n            self.request_handler.close_connection = True\n\n    def write(self, data):\n        \"\"\"\n        'write()' callable as specified by PEP 3333.\n        \n        For HEAD requests, suppress the response body to comply with RFC 2616.\n        \"\"\"\n        # For HEAD requests, don't write the response body\n        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n            # Still need to track bytes for Content-Length header accuracy\n            if not self.headers_sent:\n                self.bytes_sent = len(data)\n                self.send_headers()\n            else:\n                self.bytes_sent += len(data)\n            # Don't write the actual data for HEAD requests\n            return\n        \n        # For all other request methods, use the parent implementation\n        super().write(data)\n\n    def close(self):\n        self.get_stdin().read()\n        super().close()\n",
      "\nclass ServerHandler(simple_server.ServerHandler):\n    http_version = \"1.1\"\n\n    def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n        \"\"\"\n        Use a LimitedStream so that unread request data will be ignored at\n        the end of the request. WSGIRequest uses a LimitedStream but it\n        shouldn't discard the data since the upstream servers usually do this.\n        This fix applies only for testserver/runserver.\n        \"\"\"\n        try:\n            content_length = int(environ.get(\"CONTENT_LENGTH\"))\n        except (ValueError, TypeError):\n            content_length = 0\n        super().__init__(\n            LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n        )\n\n    def cleanup_headers(self):\n        super().cleanup_headers()\n        # HTTP/1.1 requires support for persistent connections. Send 'close' if\n        # the content length is unknown to prevent clients from reusing the\n        # connection.\n        if \"Content-Length\" not in self.headers:\n            self.headers[\"Connection\"] = \"close\"\n        # Persistent connections require threading server.\n        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n            self.headers[\"Connection\"] = \"close\"\n        # Mark the connection for closing if it's set as such above or if the\n        # application sent the header.\n        if self.headers.get(\"Connection\") == \"close\":\n            self.request_handler.close_connection = True\n\n    def write(self, data):\n        \"\"\"\n        'write()' callable as specified by PEP 3333.\n        \n        For HEAD requests, suppress the response body to comply with RFC 2616.\n        \"\"\"\n        # For HEAD requests, don't write the response body\n        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n            # Still need to track bytes for Content-Length header accuracy\n            if not self.headers_sent:\n                self.bytes_sent = len(data)\n                self.send_headers()\n            else:\n                self.bytes_sent += len(data)\n            # Don't write the actual data for HEAD requests\n            return\n        \n        # For all other request methods, use the parent implementation\n        super().write(data)\n\n    def close(self):\n        self.get_stdin().read()\n        super().close()\n",
      "\nclass ServerHandler(simple_server.ServerHandler):\n    http_version = \"1.1\"\n\n    def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n        \"\"\"\n        Use a LimitedStream so that unread request data will be ignored at\n        the end of the request. WSGIRequest uses a LimitedStream but it\n        shouldn't discard the data since the upstream servers usually do this.\n        This fix applies only for testserver/runserver.\n        \"\"\"\n        try:\n            content_length = int(environ.get(\"CONTENT_LENGTH\"))\n        except (ValueError, TypeError):\n            content_length = 0\n        super().__init__(\n            LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n        )\n\n    def cleanup_headers(self):\n        super().cleanup_headers()\n        # HTTP/1.1 requires support for persistent connections. Send 'close' if\n        # the content length is unknown to prevent clients from reusing the\n        # connection.\n        if \"Content-Length\" not in self.headers:\n            self.headers[\"Connection\"] = \"close\"\n        # Persistent connections require threading server.\n        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n            self.headers[\"Connection\"] = \"close\"\n        # Mark the connection for closing if it's set as such above or if the\n        # application sent the header.\n        if self.headers.get(\"Connection\") == \"close\":\n            self.request_handler.close_connection = True\n\n    def write(self, data):\n        \"\"\"\n        'write()' callable as specified by PEP 3333.\n        \n        For HEAD requests, suppress the response body to comply with RFC 2616.\n        \"\"\"\n        # For HEAD requests, don't write the response body\n        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n            # Still need to track bytes for Content-Length header accuracy\n            if not self.headers_sent:\n                self.bytes_sent = len(data)\n                self.send_headers()\n            else:\n                self.bytes_sent += len(data)\n            # Don't write the actual data for HEAD requests\n            return\n        \n        # For all other request methods, use the parent implementation\n        super().write(data)\n\n    def close(self):\n        self.get_stdin().read()\n        super().close()\n",
      "\nclass ServerHandler(simple_server.ServerHandler):\n    http_version = \"1.1\"\n\n    def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n        \"\"\"\n        Use a LimitedStream so that unread request data will be ignored at\n        the end of the request. WSGIRequest uses a LimitedStream but it\n        shouldn't discard the data since the upstream servers usually do this.\n        This fix applies only for testserver/runserver.\n        \"\"\"\n        try:\n            content_length = int(environ.get(\"CONTENT_LENGTH\"))\n        except (ValueError, TypeError):\n            content_length = 0\n        super().__init__(\n            LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n        )\n\n    def cleanup_headers(self):\n        super().cleanup_headers()\n        # HTTP/1.1 requires support for persistent connections. Send 'close' if\n        # the content length is unknown to prevent clients from reusing the\n        # connection.\n        if \"Content-Length\" not in self.headers:\n            self.headers[\"Connection\"] = \"close\"\n        # Persistent connections require threading server.\n        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n            self.headers[\"Connection\"] = \"close\"\n        # Mark the connection for closing if it's set as such above or if the\n        # application sent the header.\n        if self.headers.get(\"Connection\") == \"close\":\n            self.request_handler.close_connection = True\n\n    def write(self, data):\n        \"\"\"\n        'write()' callable as specified by PEP 3333.\n        \n        For HEAD requests, suppress the response body to comply with RFC 2616.\n        \"\"\"\n        # For HEAD requests, don't write the response body\n        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n            # Still need to track bytes for Content-Length header accuracy\n            if not self.headers_sent:\n                self.bytes_sent = len(data)\n                self.send_headers()\n            else:\n                self.bytes_sent += len(data)\n            # Don't write the actual data for HEAD requests\n            return\n        \n        # For all other request methods, use the parent implementation\n        super().write(data)\n\n    def close(self):\n        self.get_stdin().read()\n        super().close()\n",
      "\nclass ServerHandler(simple_server.ServerHandler):\n    http_version = \"1.1\"\n\n    def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n        \"\"\"\n        Use a LimitedStream so that unread request data will be ignored at\n        the end of the request. WSGIRequest uses a LimitedStream but it\n        shouldn't discard the data since the upstream servers usually do this.\n        This fix applies only for testserver/runserver.\n        \"\"\"\n        try:\n            content_length = int(environ.get(\"CONTENT_LENGTH\"))\n        except (ValueError, TypeError):\n            content_length = 0\n        super().__init__(\n            LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n        )\n\n    def cleanup_headers(self):\n        super().cleanup_headers()\n        # HTTP/1.1 requires support for persistent connections. Send 'close' if\n        # the content length is unknown to prevent clients from reusing the\n        # connection.\n        if \"Content-Length\" not in self.headers:\n            self.headers[\"Connection\"] = \"close\"\n        # Persistent connections require threading server.\n        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n            self.headers[\"Connection\"] = \"close\"\n        # Mark the connection for closing if it's set as such above or if the\n        # application sent the header.\n        if self.headers.get(\"Connection\") == \"close\":\n            self.request_handler.close_connection = True\n\n    def write(self, data):\n        \"\"\"\n        'write()' callable as specified by PEP 3333.\n        \n        For HEAD requests, suppress the response body to comply with RFC 2616.\n        \"\"\"\n        # For HEAD requests, don't write the response body\n        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n            # Still need to track bytes for Content-Length header accuracy\n            if not self.headers_sent:\n                self.bytes_sent = len(data)\n                self.send_headers()\n            else:\n                self.bytes_sent += len(data)\n            # Don't write the actual data for HEAD requests\n            return\n        \n        # For all other request methods, use the parent implementation\n        super().write(data)\n\n    def close(self):\n        self.get_stdin().read()\n        super().close()\n",
      "\nclass ServerHandler(simple_server.ServerHandler):\n    http_version = \"1.1\"\n\n    def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n        \"\"\"\n        Use a LimitedStream so that unread request data will be ignored at\n        the end of the request. WSGIRequest uses a LimitedStream but it\n        shouldn't discard the data since the upstream servers usually do this.\n        This fix applies only for testserver/runserver.\n        \"\"\"\n        try:\n            content_length = int(environ.get(\"CONTENT_LENGTH\"))\n        except (ValueError, TypeError):\n            content_length = 0\n        super().__init__(\n            LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n        )\n\n    def cleanup_headers(self):\n        super().cleanup_headers()\n        # HTTP/1.1 requires support for persistent connections. Send 'close' if\n        # the content length is unknown to prevent clients from reusing the\n        # connection.\n        if \"Content-Length\" not in self.headers:\n            self.headers[\"Connection\"] = \"close\"\n        # Persistent connections require threading server.\n        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n            self.headers[\"Connection\"] = \"close\"\n        # Mark the connection for closing if it's set as such above or if the\n        # application sent the header.\n        if self.headers.get(\"Connection\") == \"close\":\n            self.request_handler.close_connection = True\n\n    def write(self, data):\n        \"\"\"\n        'write()' callable as specified by PEP 3333.\n        \n        For HEAD requests, suppress the response body to comply with RFC 2616.\n        \"\"\"\n        # For HEAD requests, don't write the response body\n        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n            # Still need to track bytes for Content-Length header accuracy\n            if not self.headers_sent:\n                self.bytes_sent = len(data)\n                self.send_headers()\n            else:\n                self.bytes_sent += len(data)\n            # Don't write the actual data for HEAD requests\n            return\n        \n        # For all other request methods, use the parent implementation\n        super().write(data)\n\n    def close(self):\n        self.get_stdin().read()\n        super().close()\n",
      "\nclass ServerHandler(simple_server.ServerHandler):\n    http_version = \"1.1\"\n\n    def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n        \"\"\"\n        Use a LimitedStream so that unread request data will be ignored at\n        the end of the request. WSGIRequest uses a LimitedStream but it\n        shouldn't discard the data since the upstream servers usually do this.\n        This fix applies only for testserver/runserver.\n        \"\"\"\n        try:\n            content_length = int(environ.get(\"CONTENT_LENGTH\"))\n        except (ValueError, TypeError):\n            content_length = 0\n        super().__init__(\n            LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n        )\n\n    def cleanup_headers(self):\n        super().cleanup_headers()\n        # HTTP/1.1 requires support for persistent connections. Send 'close' if\n        # the content length is unknown to prevent clients from reusing the\n        # connection.\n        if \"Content-Length\" not in self.headers:\n            self.headers[\"Connection\"] = \"close\"\n        # Persistent connections require threading server.\n        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n            self.headers[\"Connection\"] = \"close\"\n        # Mark the connection for closing if it's set as such above or if the\n        # application sent the header.\n        if self.headers.get(\"Connection\") == \"close\":\n            self.request_handler.close_connection = True\n\n    def write(self, data):\n        \"\"\"\n        'write()' callable as specified by PEP 3333.\n        \n        For HEAD requests, suppress the response body to comply with RFC 2616.\n        \"\"\"\n        # For HEAD requests, don't write the response body\n        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n            # Still need to track bytes for Content-Length header accuracy\n            if not self.headers_sent:\n                self.bytes_sent = len(data)\n                self.send_headers()\n            else:\n                self.bytes_sent += len(data)\n            # Don't write the actual data for HEAD requests\n            return\n        \n        # For all other request methods, use the parent implementation\n        super().write(data)\n\n    def close(self):\n        self.get_stdin().read()\n        super().close()\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..5e307bfd3d 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -110,6 +110,7 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n         super().close_request(request)\n \n \n+\n class ServerHandler(simple_server.ServerHandler):\n     http_version = \"1.1\"\n \n@@ -147,6 +148,26 @@ class ServerHandler(simple_server.ServerHandler):\n         self.get_stdin().read()\n         super().close()\n \n+    def write(self, data):\n+        \"\"\"\n+        'write()' callable as specified by PEP 3333.\n+        \n+        For HEAD requests, suppress the response body to comply with RFC 2616.\n+        \"\"\"\n+        # For HEAD requests, don't write the response body\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # Still need to track bytes for Content-Length header accuracy\n+            if not self.headers_sent:\n+                self.bytes_sent = len(data)\n+                self.send_headers()\n+            else:\n+                self.bytes_sent += len(data)\n+            # Don't write the actual data for HEAD requests\n+            return\n+        \n+        # For all other request methods, use the parent implementation\n+        super().write(data)\n+\n \n class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n     protocol_version = \"HTTP/1.1\"\n",
    "variant_0": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..8240109fb7 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -110,6 +110,7 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n         super().close_request(request)\n \n \n+\n class ServerHandler(simple_server.ServerHandler):\n     http_version = \"1.1\"\n \n@@ -143,6 +144,26 @@ class ServerHandler(simple_server.ServerHandler):\n         if self.headers.get(\"Connection\") == \"close\":\n             self.request_handler.close_connection = True\n \n+    def write(self, data):\n+        \"\"\"\n+        'write()' callable as specified by PEP 3333.\n+        \n+        For HEAD requests, suppress the response body to comply with RFC 2616.\n+        \"\"\"\n+        # For HEAD requests, don't write the response body\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # Still need to track bytes for Content-Length header accuracy\n+            if not self.headers_sent:\n+                self.bytes_sent = len(data)\n+                self.send_headers()\n+            else:\n+                self.bytes_sent += len(data)\n+            # Don't write the actual data for HEAD requests\n+            return\n+        \n+        # For all other request methods, use the parent implementation\n+        super().write(data)\n+\n     def close(self):\n         self.get_stdin().read()\n         super().close()\n",
    "variant_1": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..8240109fb7 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -110,6 +110,7 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n         super().close_request(request)\n \n \n+\n class ServerHandler(simple_server.ServerHandler):\n     http_version = \"1.1\"\n \n@@ -143,6 +144,26 @@ class ServerHandler(simple_server.ServerHandler):\n         if self.headers.get(\"Connection\") == \"close\":\n             self.request_handler.close_connection = True\n \n+    def write(self, data):\n+        \"\"\"\n+        'write()' callable as specified by PEP 3333.\n+        \n+        For HEAD requests, suppress the response body to comply with RFC 2616.\n+        \"\"\"\n+        # For HEAD requests, don't write the response body\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # Still need to track bytes for Content-Length header accuracy\n+            if not self.headers_sent:\n+                self.bytes_sent = len(data)\n+                self.send_headers()\n+            else:\n+                self.bytes_sent += len(data)\n+            # Don't write the actual data for HEAD requests\n+            return\n+        \n+        # For all other request methods, use the parent implementation\n+        super().write(data)\n+\n     def close(self):\n         self.get_stdin().read()\n         super().close()\n",
    "variant_2": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..8240109fb7 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -110,6 +110,7 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n         super().close_request(request)\n \n \n+\n class ServerHandler(simple_server.ServerHandler):\n     http_version = \"1.1\"\n \n@@ -143,6 +144,26 @@ class ServerHandler(simple_server.ServerHandler):\n         if self.headers.get(\"Connection\") == \"close\":\n             self.request_handler.close_connection = True\n \n+    def write(self, data):\n+        \"\"\"\n+        'write()' callable as specified by PEP 3333.\n+        \n+        For HEAD requests, suppress the response body to comply with RFC 2616.\n+        \"\"\"\n+        # For HEAD requests, don't write the response body\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # Still need to track bytes for Content-Length header accuracy\n+            if not self.headers_sent:\n+                self.bytes_sent = len(data)\n+                self.send_headers()\n+            else:\n+                self.bytes_sent += len(data)\n+            # Don't write the actual data for HEAD requests\n+            return\n+        \n+        # For all other request methods, use the parent implementation\n+        super().write(data)\n+\n     def close(self):\n         self.get_stdin().read()\n         super().close()\n",
    "variant_3": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..8240109fb7 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -110,6 +110,7 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n         super().close_request(request)\n \n \n+\n class ServerHandler(simple_server.ServerHandler):\n     http_version = \"1.1\"\n \n@@ -143,6 +144,26 @@ class ServerHandler(simple_server.ServerHandler):\n         if self.headers.get(\"Connection\") == \"close\":\n             self.request_handler.close_connection = True\n \n+    def write(self, data):\n+        \"\"\"\n+        'write()' callable as specified by PEP 3333.\n+        \n+        For HEAD requests, suppress the response body to comply with RFC 2616.\n+        \"\"\"\n+        # For HEAD requests, don't write the response body\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # Still need to track bytes for Content-Length header accuracy\n+            if not self.headers_sent:\n+                self.bytes_sent = len(data)\n+                self.send_headers()\n+            else:\n+                self.bytes_sent += len(data)\n+            # Don't write the actual data for HEAD requests\n+            return\n+        \n+        # For all other request methods, use the parent implementation\n+        super().write(data)\n+\n     def close(self):\n         self.get_stdin().read()\n         super().close()\n",
    "variant_4": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..8240109fb7 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -110,6 +110,7 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n         super().close_request(request)\n \n \n+\n class ServerHandler(simple_server.ServerHandler):\n     http_version = \"1.1\"\n \n@@ -143,6 +144,26 @@ class ServerHandler(simple_server.ServerHandler):\n         if self.headers.get(\"Connection\") == \"close\":\n             self.request_handler.close_connection = True\n \n+    def write(self, data):\n+        \"\"\"\n+        'write()' callable as specified by PEP 3333.\n+        \n+        For HEAD requests, suppress the response body to comply with RFC 2616.\n+        \"\"\"\n+        # For HEAD requests, don't write the response body\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # Still need to track bytes for Content-Length header accuracy\n+            if not self.headers_sent:\n+                self.bytes_sent = len(data)\n+                self.send_headers()\n+            else:\n+                self.bytes_sent += len(data)\n+            # Don't write the actual data for HEAD requests\n+            return\n+        \n+        # For all other request methods, use the parent implementation\n+        super().write(data)\n+\n     def close(self):\n         self.get_stdin().read()\n         super().close()\n",
    "variant_5": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..8240109fb7 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -110,6 +110,7 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n         super().close_request(request)\n \n \n+\n class ServerHandler(simple_server.ServerHandler):\n     http_version = \"1.1\"\n \n@@ -143,6 +144,26 @@ class ServerHandler(simple_server.ServerHandler):\n         if self.headers.get(\"Connection\") == \"close\":\n             self.request_handler.close_connection = True\n \n+    def write(self, data):\n+        \"\"\"\n+        'write()' callable as specified by PEP 3333.\n+        \n+        For HEAD requests, suppress the response body to comply with RFC 2616.\n+        \"\"\"\n+        # For HEAD requests, don't write the response body\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # Still need to track bytes for Content-Length header accuracy\n+            if not self.headers_sent:\n+                self.bytes_sent = len(data)\n+                self.send_headers()\n+            else:\n+                self.bytes_sent += len(data)\n+            # Don't write the actual data for HEAD requests\n+            return\n+        \n+        # For all other request methods, use the parent implementation\n+        super().write(data)\n+\n     def close(self):\n         self.get_stdin().read()\n         super().close()\n",
    "variant_6": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..8240109fb7 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -110,6 +110,7 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n         super().close_request(request)\n \n \n+\n class ServerHandler(simple_server.ServerHandler):\n     http_version = \"1.1\"\n \n@@ -143,6 +144,26 @@ class ServerHandler(simple_server.ServerHandler):\n         if self.headers.get(\"Connection\") == \"close\":\n             self.request_handler.close_connection = True\n \n+    def write(self, data):\n+        \"\"\"\n+        'write()' callable as specified by PEP 3333.\n+        \n+        For HEAD requests, suppress the response body to comply with RFC 2616.\n+        \"\"\"\n+        # For HEAD requests, don't write the response body\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # Still need to track bytes for Content-Length header accuracy\n+            if not self.headers_sent:\n+                self.bytes_sent = len(data)\n+                self.send_headers()\n+            else:\n+                self.bytes_sent += len(data)\n+            # Don't write the actual data for HEAD requests\n+            return\n+        \n+        # For all other request methods, use the parent implementation\n+        super().write(data)\n+\n     def close(self):\n         self.get_stdin().read()\n         super().close()\n",
    "variant_7": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..8240109fb7 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -110,6 +110,7 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n         super().close_request(request)\n \n \n+\n class ServerHandler(simple_server.ServerHandler):\n     http_version = \"1.1\"\n \n@@ -143,6 +144,26 @@ class ServerHandler(simple_server.ServerHandler):\n         if self.headers.get(\"Connection\") == \"close\":\n             self.request_handler.close_connection = True\n \n+    def write(self, data):\n+        \"\"\"\n+        'write()' callable as specified by PEP 3333.\n+        \n+        For HEAD requests, suppress the response body to comply with RFC 2616.\n+        \"\"\"\n+        # For HEAD requests, don't write the response body\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # Still need to track bytes for Content-Length header accuracy\n+            if not self.headers_sent:\n+                self.bytes_sent = len(data)\n+                self.send_headers()\n+            else:\n+                self.bytes_sent += len(data)\n+            # Don't write the actual data for HEAD requests\n+            return\n+        \n+        # For all other request methods, use the parent implementation\n+        super().write(data)\n+\n     def close(self):\n         self.get_stdin().read()\n         super().close()\n",
    "variant_8": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..8240109fb7 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -110,6 +110,7 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n         super().close_request(request)\n \n \n+\n class ServerHandler(simple_server.ServerHandler):\n     http_version = \"1.1\"\n \n@@ -143,6 +144,26 @@ class ServerHandler(simple_server.ServerHandler):\n         if self.headers.get(\"Connection\") == \"close\":\n             self.request_handler.close_connection = True\n \n+    def write(self, data):\n+        \"\"\"\n+        'write()' callable as specified by PEP 3333.\n+        \n+        For HEAD requests, suppress the response body to comply with RFC 2616.\n+        \"\"\"\n+        # For HEAD requests, don't write the response body\n+        if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+            # Still need to track bytes for Content-Length header accuracy\n+            if not self.headers_sent:\n+                self.bytes_sent = len(data)\n+                self.send_headers()\n+            else:\n+                self.bytes_sent += len(data)\n+            # Don't write the actual data for HEAD requests\n+            return\n+        \n+        # For all other request methods, use the parent implementation\n+        super().write(data)\n+\n     def close(self):\n         self.get_stdin().read()\n         super().close()\n"
  }
}