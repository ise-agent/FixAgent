{
  "zero_patches": {
    "Location 1 (/root/hy/projects/requests/requests/_internal_utils.py lines 14-27)": "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
    "Location 2 (/root/hy/projects/requests/requests/auth.py lines 65-67)": "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
    "Location 3 (/root/hy/projects/requests/requests/_internal_utils.py lines 21-25)": "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
    "Location 4 (/root/hy/projects/requests/requests/auth.py lines 59-63)": "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
    "Location 5 (/root/hy/projects/requests/requests/_internal_utils.py lines 1-5)": "\n# -*- coding: utf-8 -*-\n\n\"\"\"\nrequests._internal_utils\n~~~~~~~~~~~~~~\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/requests/requests/_internal_utils.py lines 14-27)": [
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n"
    ],
    "Location 2 (/root/hy/projects/requests/requests/auth.py lines 65-67)": [
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n"
    ],
    "Location 3 (/root/hy/projects/requests/requests/_internal_utils.py lines 21-25)": [
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes Latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes latin1 unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n"
    ],
    "Location 4 (/root/hy/projects/requests/requests/auth.py lines 59-63)": [
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n"
    ],
    "Location 5 (/root/hy/projects/requests/requests/_internal_utils.py lines 1-5)": [
      "\n# -*- coding: utf-8 -*-\n\n\"\"\"\nrequests._internal_utils\n~~~~~~~~~~~~~~\n",
      "\n# -*- coding: utf-8 -*-\n\n\"\"\"\nrequests._internal_utils\n~~~~~~~~~~~~~~\n",
      "\n# -*- coding: utf-8 -*-\n\n\"\"\"\nrequests._internal_utils\n~~~~~~~~~~~~~~\n\nProvides utility functions that are consumed internally by Requests\nwhich depend on extremely few external helpers (such as compat)\n\"\"\"\n\nfrom .compat import is_py2, builtin_str, str\n\n\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n\n\ndef unicode_is_ascii(u_string):\n    \"\"\"Determine if unicode string only contains ASCII characters.\n\n    :param str u_string: unicode string to check. Must be unicode\n        and not a byte string.\n    :returns: True if the string only contains ASCII characters.\n    :rtype: bool\n    \"\"\"\n    assert isinstance(u_string, str)\n    try:\n        u_string.encode('ascii')\n        return True\n    except UnicodeEncodeError:\n        return False\n",
      "\n# -*- coding: utf-8 -*-\n\n\"\"\"\nrequests._internal_utils\n~~~~~~~~~~~~~~\n",
      "\n# -*- coding: utf-8 -*-\n\n\"\"\"\nrequests._internal_utils\n~~~~~~~~~~~~~~\n",
      "\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\n# -*- coding: utf-8 -*-\n\n\"\"\"\nrequests._internal_utils\n~~~~~~~~~~~~~~\n\nProvides utility functions that are consumed internally by Requests\nwhich depend on extremely few external helpers (such as compat)\n\"\"\"\n\nfrom .compat import is_py2, builtin_str, str\n\n\ndef to_native_string(string, encoding='latin1'):\n    \"\"\"Given a string object, regardless of type, returns a representation of\n    that string in the native string type, encoding and decoding where\n    necessary. This assumes ASCII unless told otherwise.\n    \"\"\"\n    if isinstance(string, builtin_str):\n        out = string\n    else:\n        if is_py2:\n            out = string.encode(encoding)\n        else:\n            try:\n                out = string.decode(encoding)\n            except UnicodeDecodeError:\n                # Fallback to latin1 for base64 and other binary data\n                out = string.decode('latin1')\n\n    return out\n",
      "\n# -*- coding: utf-8 -*-\n\n\"\"\"\nrequests._internal_utils\n~~~~~~~~~~~~~~\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/requests/_internal_utils.py b/requests/_internal_utils.py\nindex 759d9a56..67bd1052 100644\n--- a/requests/_internal_utils.py\n+++ b/requests/_internal_utils.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n \n \"\"\"\n@@ -11,10 +12,11 @@ which depend on extremely few external helpers (such as compat)\n from .compat import is_py2, builtin_str, str\n \n \n-def to_native_string(string, encoding='ascii'):\n+\n+def to_native_string(string, encoding='latin1'):\n     \"\"\"Given a string object, regardless of type, returns a representation of\n     that string in the native string type, encoding and decoding where\n-    necessary. This assumes ASCII unless told otherwise.\n+    necessary. This assumes latin1 unless told otherwise.\n     \"\"\"\n     if isinstance(string, builtin_str):\n         out = string\n@@ -24,6 +26,11 @@ def to_native_string(string, encoding='ascii'):\n         else:\n             out = string.decode(encoding)\n \n+    return out\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n     return out\n \n \ndiff --git a/requests/auth.py b/requests/auth.py\nindex eeface39..026f3cd8 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -56,14 +56,17 @@ def _basic_auth_str(username, password):\n         password = str(password)\n     # -- End Removal --\n \n+\n     if isinstance(username, str):\n         username = username.encode('latin1')\n \n     if isinstance(password, str):\n         password = password.encode('latin1')\n \n+\n     authstr = 'Basic ' + to_native_string(\n-        b64encode(b':'.join((username, password))).strip()\n+        b64encode(b':'.join((username, password))).strip(),\n+        encoding='latin1'\n     )\n \n     return authstr\n",
    "variant_0": "diff --git a/requests/_internal_utils.py b/requests/_internal_utils.py\nindex 759d9a56..1cc5bad4 100644\n--- a/requests/_internal_utils.py\n+++ b/requests/_internal_utils.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n \n \"\"\"\n@@ -11,10 +12,11 @@ which depend on extremely few external helpers (such as compat)\n from .compat import is_py2, builtin_str, str\n \n \n-def to_native_string(string, encoding='ascii'):\n+\n+def to_native_string(string, encoding='latin1'):\n     \"\"\"Given a string object, regardless of type, returns a representation of\n     that string in the native string type, encoding and decoding where\n-    necessary. This assumes ASCII unless told otherwise.\n+    necessary. This assumes latin1 unless told otherwise.\n     \"\"\"\n     if isinstance(string, builtin_str):\n         out = string\n@@ -22,7 +24,25 @@ def to_native_string(string, encoding='ascii'):\n         if is_py2:\n             out = string.encode(encoding)\n         else:\n-            out = string.decode(encoding)\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n \n     return out\n \ndiff --git a/requests/auth.py b/requests/auth.py\nindex eeface39..f77cf7d6 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -56,15 +56,45 @@ def _basic_auth_str(username, password):\n         password = str(password)\n     # -- End Removal --\n \n-    if isinstance(username, str):\n-        username = username.encode('latin1')\n \n-    if isinstance(password, str):\n-        password = password.encode('latin1')\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n \n-    authstr = 'Basic ' + to_native_string(\n-        b64encode(b':'.join((username, password))).strip()\n-    )\n+    return out\n \n     return authstr\n \n",
    "variant_1": "diff --git a/requests/_internal_utils.py b/requests/_internal_utils.py\nindex 759d9a56..1cc5bad4 100644\n--- a/requests/_internal_utils.py\n+++ b/requests/_internal_utils.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n \n \"\"\"\n@@ -11,10 +12,11 @@ which depend on extremely few external helpers (such as compat)\n from .compat import is_py2, builtin_str, str\n \n \n-def to_native_string(string, encoding='ascii'):\n+\n+def to_native_string(string, encoding='latin1'):\n     \"\"\"Given a string object, regardless of type, returns a representation of\n     that string in the native string type, encoding and decoding where\n-    necessary. This assumes ASCII unless told otherwise.\n+    necessary. This assumes latin1 unless told otherwise.\n     \"\"\"\n     if isinstance(string, builtin_str):\n         out = string\n@@ -22,7 +24,25 @@ def to_native_string(string, encoding='ascii'):\n         if is_py2:\n             out = string.encode(encoding)\n         else:\n-            out = string.decode(encoding)\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n \n     return out\n \ndiff --git a/requests/auth.py b/requests/auth.py\nindex eeface39..f77cf7d6 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -56,15 +56,45 @@ def _basic_auth_str(username, password):\n         password = str(password)\n     # -- End Removal --\n \n-    if isinstance(username, str):\n-        username = username.encode('latin1')\n \n-    if isinstance(password, str):\n-        password = password.encode('latin1')\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n \n-    authstr = 'Basic ' + to_native_string(\n-        b64encode(b':'.join((username, password))).strip()\n-    )\n+    return out\n \n     return authstr\n \n",
    "variant_2": "diff --git a/requests/_internal_utils.py b/requests/_internal_utils.py\nindex 759d9a56..1cc5bad4 100644\n--- a/requests/_internal_utils.py\n+++ b/requests/_internal_utils.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n \n \"\"\"\n@@ -11,10 +12,11 @@ which depend on extremely few external helpers (such as compat)\n from .compat import is_py2, builtin_str, str\n \n \n-def to_native_string(string, encoding='ascii'):\n+\n+def to_native_string(string, encoding='latin1'):\n     \"\"\"Given a string object, regardless of type, returns a representation of\n     that string in the native string type, encoding and decoding where\n-    necessary. This assumes ASCII unless told otherwise.\n+    necessary. This assumes latin1 unless told otherwise.\n     \"\"\"\n     if isinstance(string, builtin_str):\n         out = string\n@@ -22,7 +24,25 @@ def to_native_string(string, encoding='ascii'):\n         if is_py2:\n             out = string.encode(encoding)\n         else:\n-            out = string.decode(encoding)\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n \n     return out\n \ndiff --git a/requests/auth.py b/requests/auth.py\nindex eeface39..f77cf7d6 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -56,15 +56,45 @@ def _basic_auth_str(username, password):\n         password = str(password)\n     # -- End Removal --\n \n-    if isinstance(username, str):\n-        username = username.encode('latin1')\n \n-    if isinstance(password, str):\n-        password = password.encode('latin1')\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n \n-    authstr = 'Basic ' + to_native_string(\n-        b64encode(b':'.join((username, password))).strip()\n-    )\n+    return out\n \n     return authstr\n \n",
    "variant_3": "diff --git a/requests/_internal_utils.py b/requests/_internal_utils.py\nindex 759d9a56..94ae0c69 100644\n--- a/requests/_internal_utils.py\n+++ b/requests/_internal_utils.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n \n \"\"\"\n@@ -11,7 +12,7 @@ which depend on extremely few external helpers (such as compat)\n from .compat import is_py2, builtin_str, str\n \n \n-def to_native_string(string, encoding='ascii'):\n+def to_native_string(string, encoding='latin1'):\n     \"\"\"Given a string object, regardless of type, returns a representation of\n     that string in the native string type, encoding and decoding where\n     necessary. This assumes ASCII unless told otherwise.\n@@ -22,7 +23,68 @@ def to_native_string(string, encoding='ascii'):\n         if is_py2:\n             out = string.encode(encoding)\n         else:\n-            out = string.decode(encoding)\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+\n+def unicode_is_ascii(u_string):\n+    \"\"\"Determine if unicode string only contains ASCII characters.\n+\n+    :param str u_string: unicode string to check. Must be unicode\n+        and not a byte string.\n+    :returns: True if the string only contains ASCII characters.\n+    :rtype: bool\n+    \"\"\"\n+    assert isinstance(u_string, str)\n+    try:\n+        u_string.encode('ascii')\n+        return True\n+    except UnicodeEncodeError:\n+        return False\n+\n+Provides utility functions that are consumed internally by Requests\n+which depend on extremely few external helpers (such as compat)\n+\"\"\"\n+\n+from .compat import is_py2, builtin_str, str\n+\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n \n     return out\n \ndiff --git a/requests/auth.py b/requests/auth.py\nindex eeface39..f77cf7d6 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -56,15 +56,45 @@ def _basic_auth_str(username, password):\n         password = str(password)\n     # -- End Removal --\n \n-    if isinstance(username, str):\n-        username = username.encode('latin1')\n \n-    if isinstance(password, str):\n-        password = password.encode('latin1')\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n \n-    authstr = 'Basic ' + to_native_string(\n-        b64encode(b':'.join((username, password))).strip()\n-    )\n+    return out\n \n     return authstr\n \n",
    "variant_4": "diff --git a/requests/_internal_utils.py b/requests/_internal_utils.py\nindex 759d9a56..1cc5bad4 100644\n--- a/requests/_internal_utils.py\n+++ b/requests/_internal_utils.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n \n \"\"\"\n@@ -11,10 +12,11 @@ which depend on extremely few external helpers (such as compat)\n from .compat import is_py2, builtin_str, str\n \n \n-def to_native_string(string, encoding='ascii'):\n+\n+def to_native_string(string, encoding='latin1'):\n     \"\"\"Given a string object, regardless of type, returns a representation of\n     that string in the native string type, encoding and decoding where\n-    necessary. This assumes ASCII unless told otherwise.\n+    necessary. This assumes latin1 unless told otherwise.\n     \"\"\"\n     if isinstance(string, builtin_str):\n         out = string\n@@ -22,7 +24,25 @@ def to_native_string(string, encoding='ascii'):\n         if is_py2:\n             out = string.encode(encoding)\n         else:\n-            out = string.decode(encoding)\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n \n     return out\n \ndiff --git a/requests/auth.py b/requests/auth.py\nindex eeface39..f77cf7d6 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -56,15 +56,45 @@ def _basic_auth_str(username, password):\n         password = str(password)\n     # -- End Removal --\n \n-    if isinstance(username, str):\n-        username = username.encode('latin1')\n \n-    if isinstance(password, str):\n-        password = password.encode('latin1')\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n \n-    authstr = 'Basic ' + to_native_string(\n-        b64encode(b':'.join((username, password))).strip()\n-    )\n+    return out\n \n     return authstr\n \n",
    "variant_5": "diff --git a/requests/_internal_utils.py b/requests/_internal_utils.py\nindex 759d9a56..1cc5bad4 100644\n--- a/requests/_internal_utils.py\n+++ b/requests/_internal_utils.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n \n \"\"\"\n@@ -11,10 +12,11 @@ which depend on extremely few external helpers (such as compat)\n from .compat import is_py2, builtin_str, str\n \n \n-def to_native_string(string, encoding='ascii'):\n+\n+def to_native_string(string, encoding='latin1'):\n     \"\"\"Given a string object, regardless of type, returns a representation of\n     that string in the native string type, encoding and decoding where\n-    necessary. This assumes ASCII unless told otherwise.\n+    necessary. This assumes latin1 unless told otherwise.\n     \"\"\"\n     if isinstance(string, builtin_str):\n         out = string\n@@ -22,7 +24,25 @@ def to_native_string(string, encoding='ascii'):\n         if is_py2:\n             out = string.encode(encoding)\n         else:\n-            out = string.decode(encoding)\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n \n     return out\n \ndiff --git a/requests/auth.py b/requests/auth.py\nindex eeface39..f77cf7d6 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -56,15 +56,45 @@ def _basic_auth_str(username, password):\n         password = str(password)\n     # -- End Removal --\n \n-    if isinstance(username, str):\n-        username = username.encode('latin1')\n \n-    if isinstance(password, str):\n-        password = password.encode('latin1')\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n \n-    authstr = 'Basic ' + to_native_string(\n-        b64encode(b':'.join((username, password))).strip()\n-    )\n+    return out\n \n     return authstr\n \n",
    "variant_6": "diff --git a/requests/_internal_utils.py b/requests/_internal_utils.py\nindex 759d9a56..75a202bc 100644\n--- a/requests/_internal_utils.py\n+++ b/requests/_internal_utils.py\n@@ -1,8 +1,22 @@\n-# -*- coding: utf-8 -*-\n \n-\"\"\"\n-requests._internal_utils\n-~~~~~~~~~~~~~~\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n \n Provides utility functions that are consumed internally by Requests\n which depend on extremely few external helpers (such as compat)\n@@ -11,10 +25,11 @@ which depend on extremely few external helpers (such as compat)\n from .compat import is_py2, builtin_str, str\n \n \n-def to_native_string(string, encoding='ascii'):\n+\n+def to_native_string(string, encoding='latin1'):\n     \"\"\"Given a string object, regardless of type, returns a representation of\n     that string in the native string type, encoding and decoding where\n-    necessary. This assumes ASCII unless told otherwise.\n+    necessary. This assumes latin1 unless told otherwise.\n     \"\"\"\n     if isinstance(string, builtin_str):\n         out = string\n@@ -22,7 +37,25 @@ def to_native_string(string, encoding='ascii'):\n         if is_py2:\n             out = string.encode(encoding)\n         else:\n-            out = string.decode(encoding)\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n \n     return out\n \ndiff --git a/requests/auth.py b/requests/auth.py\nindex eeface39..f77cf7d6 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -56,15 +56,45 @@ def _basic_auth_str(username, password):\n         password = str(password)\n     # -- End Removal --\n \n-    if isinstance(username, str):\n-        username = username.encode('latin1')\n \n-    if isinstance(password, str):\n-        password = password.encode('latin1')\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n \n-    authstr = 'Basic ' + to_native_string(\n-        b64encode(b':'.join((username, password))).strip()\n-    )\n+    return out\n \n     return authstr\n \n",
    "variant_7": "diff --git a/requests/_internal_utils.py b/requests/_internal_utils.py\nindex 759d9a56..c5e20fe3 100644\n--- a/requests/_internal_utils.py\n+++ b/requests/_internal_utils.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n \n \"\"\"\n@@ -11,7 +12,7 @@ which depend on extremely few external helpers (such as compat)\n from .compat import is_py2, builtin_str, str\n \n \n-def to_native_string(string, encoding='ascii'):\n+def to_native_string(string, encoding='latin1'):\n     \"\"\"Given a string object, regardless of type, returns a representation of\n     that string in the native string type, encoding and decoding where\n     necessary. This assumes ASCII unless told otherwise.\n@@ -22,7 +23,52 @@ def to_native_string(string, encoding='ascii'):\n         if is_py2:\n             out = string.encode(encoding)\n         else:\n-            out = string.decode(encoding)\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+Provides utility functions that are consumed internally by Requests\n+which depend on extremely few external helpers (such as compat)\n+\"\"\"\n+\n+from .compat import is_py2, builtin_str, str\n+\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes latin1 unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n \n     return out\n \ndiff --git a/requests/auth.py b/requests/auth.py\nindex eeface39..f77cf7d6 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -56,15 +56,45 @@ def _basic_auth_str(username, password):\n         password = str(password)\n     # -- End Removal --\n \n-    if isinstance(username, str):\n-        username = username.encode('latin1')\n \n-    if isinstance(password, str):\n-        password = password.encode('latin1')\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n \n-    authstr = 'Basic ' + to_native_string(\n-        b64encode(b':'.join((username, password))).strip()\n-    )\n+    return out\n \n     return authstr\n \n",
    "variant_8": "diff --git a/requests/_internal_utils.py b/requests/_internal_utils.py\nindex 759d9a56..cb36b2f5 100644\n--- a/requests/_internal_utils.py\n+++ b/requests/_internal_utils.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n \n \"\"\"\n@@ -11,7 +12,8 @@ which depend on extremely few external helpers (such as compat)\n from .compat import is_py2, builtin_str, str\n \n \n-def to_native_string(string, encoding='ascii'):\n+\n+def to_native_string(string, encoding='latin1'):\n     \"\"\"Given a string object, regardless of type, returns a representation of\n     that string in the native string type, encoding and decoding where\n     necessary. This assumes ASCII unless told otherwise.\n@@ -22,7 +24,25 @@ def to_native_string(string, encoding='ascii'):\n         if is_py2:\n             out = string.encode(encoding)\n         else:\n-            out = string.decode(encoding)\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n \n     return out\n \ndiff --git a/requests/auth.py b/requests/auth.py\nindex eeface39..f77cf7d6 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -56,15 +56,45 @@ def _basic_auth_str(username, password):\n         password = str(password)\n     # -- End Removal --\n \n-    if isinstance(username, str):\n-        username = username.encode('latin1')\n \n-    if isinstance(password, str):\n-        password = password.encode('latin1')\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n+\n+    return out\n+\n+\n+def to_native_string(string, encoding='latin1'):\n+    \"\"\"Given a string object, regardless of type, returns a representation of\n+    that string in the native string type, encoding and decoding where\n+    necessary. This assumes ASCII unless told otherwise.\n+    \"\"\"\n+    if isinstance(string, builtin_str):\n+        out = string\n+    else:\n+        if is_py2:\n+            out = string.encode(encoding)\n+        else:\n+            try:\n+                out = string.decode(encoding)\n+            except UnicodeDecodeError:\n+                # Fallback to latin1 for base64 and other binary data\n+                out = string.decode('latin1')\n \n-    authstr = 'Basic ' + to_native_string(\n-        b64encode(b':'.join((username, password))).strip()\n-    )\n+    return out\n \n     return authstr\n \n"
  }
}