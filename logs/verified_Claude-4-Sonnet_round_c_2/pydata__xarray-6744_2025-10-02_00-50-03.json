{
  "zero_patches": {
    "Location 1 (/root/hy/projects/xarray/xarray/core/rolling.py lines 270-282)": "\n    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n        if self.ndim > 1:\n            raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n        stops = np.arange(1, len(self.window_labels) + 1)\n        starts = stops - int(self.window[0])\n        \n        # Apply centering shift if center=True\n        if self.center[0]:\n            shift = -(self.window[0] // 2)\n            starts = starts + shift\n            stops = stops + shift\n        \n        # Handle boundary conditions\n        starts = np.maximum(starts, 0)\n        stops = np.minimum(stops, len(self.window_labels))\n        \n        for (label, start, stop) in zip(self.window_labels, starts, stops):\n            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n\n            counts = window.count(dim=self.dim[0])\n            window = window.where(counts >= self.min_periods)\n\n            yield (label, window)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/xarray/xarray/core/rolling.py lines 270-282)": [
      "\ndef __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n    if self.ndim > 1:\n        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n    \n    stops = np.arange(1, len(self.window_labels) + 1)\n    starts = stops - int(self.window[0])\n    \n    # Apply centering shift if center=True\n    if self.center[0]:\n        shift = -(self.window[0] // 2)\n        starts = starts + shift\n        stops = stops + shift\n    \n    # Handle boundary conditions\n    starts = np.maximum(starts, 0)\n    stops = np.minimum(stops, len(self.window_labels))\n    \n    for (label, start, stop) in zip(self.window_labels, starts, stops):\n        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n\n        counts = window.count(dim=self.dim[0])\n        window = window.where(counts >= self.min_periods)\n\n        yield (label, window)\n",
      "\ndef __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n    if self.ndim > 1:\n        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n    \n    stops = np.arange(1, len(self.window_labels) + 1)\n    starts = stops - int(self.window[0])\n    \n    # Apply centering shift if center=True\n    if self.center[0]:\n        shift = -(self.window[0] // 2)\n        starts = starts + shift\n        stops = stops + shift\n    \n    # Handle boundary conditions\n    starts = np.maximum(starts, 0)\n    stops = np.minimum(stops, len(self.window_labels))\n    \n    for (label, start, stop) in zip(self.window_labels, starts, stops):\n        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n\n        counts = window.count(dim=self.dim[0])\n        window = window.where(counts >= self.min_periods)\n\n        yield (label, window)\n",
      "\ndef __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n    if self.ndim > 1:\n        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n    \n    stops = np.arange(1, len(self.window_labels) + 1)\n    starts = stops - int(self.window[0])\n    \n    # Apply centering shift if center=True\n    if self.center[0]:\n        shift = -(self.window[0] // 2)\n        starts = starts + shift\n        stops = stops + shift\n    \n    # Handle boundary conditions\n    starts = np.maximum(starts, 0)\n    stops = np.minimum(stops, len(self.window_labels))\n    \n    for (label, start, stop) in zip(self.window_labels, starts, stops):\n        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n\n        counts = window.count(dim=self.dim[0])\n        window = window.where(counts >= self.min_periods)\n\n        yield (label, window)\n",
      "\ndef __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n    if self.ndim > 1:\n        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n    \n    stops = np.arange(1, len(self.window_labels) + 1)\n    starts = stops - int(self.window[0])\n    \n    # Apply centering shift if center=True\n    if self.center[0]:\n        shift = -(self.window[0] // 2)\n        starts = starts + shift\n        stops = stops + shift\n    \n    # Handle boundary conditions\n    starts = np.maximum(starts, 0)\n    stops = np.minimum(stops, len(self.window_labels))\n    \n    for (label, start, stop) in zip(self.window_labels, starts, stops):\n        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n\n        counts = window.count(dim=self.dim[0])\n        window = window.where(counts >= self.min_periods)\n\n        yield (label, window)\n",
      "\ndef __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n    if self.ndim > 1:\n        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n    \n    stops = np.arange(1, len(self.window_labels) + 1)\n    starts = stops - int(self.window[0])\n    \n    # Apply centering shift if center=True\n    if self.center[0]:\n        shift = -(self.window[0] // 2)\n        starts = starts + shift\n        stops = stops + shift\n    \n    # Handle boundary conditions\n    starts = np.maximum(starts, 0)\n    stops = np.minimum(stops, len(self.window_labels))\n    \n    for (label, start, stop) in zip(self.window_labels, starts, stops):\n        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n\n        counts = window.count(dim=self.dim[0])\n        window = window.where(counts >= self.min_periods)\n\n        yield (label, window)\n",
      "\n    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n        if self.ndim > 1:\n            raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n        \n        stops = np.arange(1, len(self.window_labels) + 1)\n        starts = stops - int(self.window[0])\n        \n        # Apply centering shift if center=True\n        if self.center[0]:\n            shift = -(self.window[0] // 2)\n            starts = starts + shift\n            stops = stops + shift\n        \n        # Handle boundary conditions\n        starts = np.maximum(starts, 0)\n        stops = np.minimum(stops, len(self.window_labels))\n        \n        for (label, start, stop) in zip(self.window_labels, starts, stops):\n            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n\n            counts = window.count(dim=self.dim[0])\n            window = window.where(counts >= self.min_periods)\n\n            yield (label, window)\n",
      "\ndef __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n    if self.ndim > 1:\n        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n    \n    stops = np.arange(1, len(self.window_labels) + 1)\n    starts = stops - int(self.window[0])\n    \n    # Apply centering shift if center=True\n    if self.center[0]:\n        shift = -(self.window[0] // 2)\n        starts = starts + shift\n        stops = stops + shift\n    \n    # Handle boundary conditions\n    starts = np.maximum(starts, 0)\n    stops = np.minimum(stops, len(self.window_labels))\n    \n    for (label, start, stop) in zip(self.window_labels, starts, stops):\n        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n\n        counts = window.count(dim=self.dim[0])\n        window = window.where(counts >= self.min_periods)\n\n        yield (label, window)\n",
      "\ndef __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n    if self.ndim > 1:\n        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n    \n    stops = np.arange(1, len(self.window_labels) + 1)\n    starts = stops - int(self.window[0])\n    \n    # Apply centering shift if center=True\n    if self.center[0]:\n        shift = -(self.window[0] // 2)\n        starts = starts + shift\n        stops = stops + shift\n    \n    # Handle boundary conditions\n    starts = np.maximum(starts, 0)\n    stops = np.minimum(stops, len(self.window_labels))\n    \n    for (label, start, stop) in zip(self.window_labels, starts, stops):\n        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n\n        counts = window.count(dim=self.dim[0])\n        window = window.where(counts >= self.min_periods)\n\n        yield (label, window)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..a86b0275 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,12 +267,23 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n+\n     def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n         if self.ndim > 1:\n             raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n         stops = np.arange(1, len(self.window_labels) + 1)\n         starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n+        \n+        # Apply centering shift if center=True\n+        if self.center[0]:\n+            shift = -(self.window[0] // 2)\n+            starts = starts + shift\n+            stops = stops + shift\n+        \n+        # Handle boundary conditions\n+        starts = np.maximum(starts, 0)\n+        stops = np.minimum(stops, len(self.window_labels))\n+        \n         for (label, start, stop) in zip(self.window_labels, starts, stops):\n             window = self.obj.isel({self.dim[0]: slice(start, stop)})\n \n",
    "variant_0": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..a86b0275 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,12 +267,23 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n+\n     def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n         if self.ndim > 1:\n             raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n         stops = np.arange(1, len(self.window_labels) + 1)\n         starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n+        \n+        # Apply centering shift if center=True\n+        if self.center[0]:\n+            shift = -(self.window[0] // 2)\n+            starts = starts + shift\n+            stops = stops + shift\n+        \n+        # Handle boundary conditions\n+        starts = np.maximum(starts, 0)\n+        stops = np.minimum(stops, len(self.window_labels))\n+        \n         for (label, start, stop) in zip(self.window_labels, starts, stops):\n             window = self.obj.isel({self.dim[0]: slice(start, stop)})\n \n",
    "variant_1": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..0292981f 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,19 +267,31 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n-    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n-        if self.ndim > 1:\n-            raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n-        for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n-\n-            counts = window.count(dim=self.dim[0])\n-            window = window.where(counts >= self.min_periods)\n-\n-            yield (label, window)\n+\n+def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+    if self.ndim > 1:\n+        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n+    \n+    stops = np.arange(1, len(self.window_labels) + 1)\n+    starts = stops - int(self.window[0])\n+    \n+    # Apply centering shift if center=True\n+    if self.center[0]:\n+        shift = -(self.window[0] // 2)\n+        starts = starts + shift\n+        stops = stops + shift\n+    \n+    # Handle boundary conditions\n+    starts = np.maximum(starts, 0)\n+    stops = np.minimum(stops, len(self.window_labels))\n+    \n+    for (label, start, stop) in zip(self.window_labels, starts, stops):\n+        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+\n+        counts = window.count(dim=self.dim[0])\n+        window = window.where(counts >= self.min_periods)\n+\n+        yield (label, window)\n \n     def construct(\n         self,\n",
    "variant_2": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..0292981f 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,19 +267,31 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n-    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n-        if self.ndim > 1:\n-            raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n-        for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n-\n-            counts = window.count(dim=self.dim[0])\n-            window = window.where(counts >= self.min_periods)\n-\n-            yield (label, window)\n+\n+def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+    if self.ndim > 1:\n+        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n+    \n+    stops = np.arange(1, len(self.window_labels) + 1)\n+    starts = stops - int(self.window[0])\n+    \n+    # Apply centering shift if center=True\n+    if self.center[0]:\n+        shift = -(self.window[0] // 2)\n+        starts = starts + shift\n+        stops = stops + shift\n+    \n+    # Handle boundary conditions\n+    starts = np.maximum(starts, 0)\n+    stops = np.minimum(stops, len(self.window_labels))\n+    \n+    for (label, start, stop) in zip(self.window_labels, starts, stops):\n+        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+\n+        counts = window.count(dim=self.dim[0])\n+        window = window.where(counts >= self.min_periods)\n+\n+        yield (label, window)\n \n     def construct(\n         self,\n",
    "variant_3": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..0292981f 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,19 +267,31 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n-    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n-        if self.ndim > 1:\n-            raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n-        for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n-\n-            counts = window.count(dim=self.dim[0])\n-            window = window.where(counts >= self.min_periods)\n-\n-            yield (label, window)\n+\n+def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+    if self.ndim > 1:\n+        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n+    \n+    stops = np.arange(1, len(self.window_labels) + 1)\n+    starts = stops - int(self.window[0])\n+    \n+    # Apply centering shift if center=True\n+    if self.center[0]:\n+        shift = -(self.window[0] // 2)\n+        starts = starts + shift\n+        stops = stops + shift\n+    \n+    # Handle boundary conditions\n+    starts = np.maximum(starts, 0)\n+    stops = np.minimum(stops, len(self.window_labels))\n+    \n+    for (label, start, stop) in zip(self.window_labels, starts, stops):\n+        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+\n+        counts = window.count(dim=self.dim[0])\n+        window = window.where(counts >= self.min_periods)\n+\n+        yield (label, window)\n \n     def construct(\n         self,\n",
    "variant_4": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..0292981f 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,19 +267,31 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n-    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n-        if self.ndim > 1:\n-            raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n-        for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n-\n-            counts = window.count(dim=self.dim[0])\n-            window = window.where(counts >= self.min_periods)\n-\n-            yield (label, window)\n+\n+def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+    if self.ndim > 1:\n+        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n+    \n+    stops = np.arange(1, len(self.window_labels) + 1)\n+    starts = stops - int(self.window[0])\n+    \n+    # Apply centering shift if center=True\n+    if self.center[0]:\n+        shift = -(self.window[0] // 2)\n+        starts = starts + shift\n+        stops = stops + shift\n+    \n+    # Handle boundary conditions\n+    starts = np.maximum(starts, 0)\n+    stops = np.minimum(stops, len(self.window_labels))\n+    \n+    for (label, start, stop) in zip(self.window_labels, starts, stops):\n+        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+\n+        counts = window.count(dim=self.dim[0])\n+        window = window.where(counts >= self.min_periods)\n+\n+        yield (label, window)\n \n     def construct(\n         self,\n",
    "variant_5": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..0292981f 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,19 +267,31 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n-    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n-        if self.ndim > 1:\n-            raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n-        for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n-\n-            counts = window.count(dim=self.dim[0])\n-            window = window.where(counts >= self.min_periods)\n-\n-            yield (label, window)\n+\n+def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+    if self.ndim > 1:\n+        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n+    \n+    stops = np.arange(1, len(self.window_labels) + 1)\n+    starts = stops - int(self.window[0])\n+    \n+    # Apply centering shift if center=True\n+    if self.center[0]:\n+        shift = -(self.window[0] // 2)\n+        starts = starts + shift\n+        stops = stops + shift\n+    \n+    # Handle boundary conditions\n+    starts = np.maximum(starts, 0)\n+    stops = np.minimum(stops, len(self.window_labels))\n+    \n+    for (label, start, stop) in zip(self.window_labels, starts, stops):\n+        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+\n+        counts = window.count(dim=self.dim[0])\n+        window = window.where(counts >= self.min_periods)\n+\n+        yield (label, window)\n \n     def construct(\n         self,\n",
    "variant_6": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..f361ba45 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,12 +267,24 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n+\n     def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n         if self.ndim > 1:\n             raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n+        \n         stops = np.arange(1, len(self.window_labels) + 1)\n         starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n+        \n+        # Apply centering shift if center=True\n+        if self.center[0]:\n+            shift = -(self.window[0] // 2)\n+            starts = starts + shift\n+            stops = stops + shift\n+        \n+        # Handle boundary conditions\n+        starts = np.maximum(starts, 0)\n+        stops = np.minimum(stops, len(self.window_labels))\n+        \n         for (label, start, stop) in zip(self.window_labels, starts, stops):\n             window = self.obj.isel({self.dim[0]: slice(start, stop)})\n \n",
    "variant_7": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..0292981f 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,19 +267,31 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n-    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n-        if self.ndim > 1:\n-            raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n-        for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n-\n-            counts = window.count(dim=self.dim[0])\n-            window = window.where(counts >= self.min_periods)\n-\n-            yield (label, window)\n+\n+def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+    if self.ndim > 1:\n+        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n+    \n+    stops = np.arange(1, len(self.window_labels) + 1)\n+    starts = stops - int(self.window[0])\n+    \n+    # Apply centering shift if center=True\n+    if self.center[0]:\n+        shift = -(self.window[0] // 2)\n+        starts = starts + shift\n+        stops = stops + shift\n+    \n+    # Handle boundary conditions\n+    starts = np.maximum(starts, 0)\n+    stops = np.minimum(stops, len(self.window_labels))\n+    \n+    for (label, start, stop) in zip(self.window_labels, starts, stops):\n+        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+\n+        counts = window.count(dim=self.dim[0])\n+        window = window.where(counts >= self.min_periods)\n+\n+        yield (label, window)\n \n     def construct(\n         self,\n",
    "variant_8": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..0292981f 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,19 +267,31 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n-    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n-        if self.ndim > 1:\n-            raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n-        for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n-\n-            counts = window.count(dim=self.dim[0])\n-            window = window.where(counts >= self.min_periods)\n-\n-            yield (label, window)\n+\n+def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+    if self.ndim > 1:\n+        raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n+    \n+    stops = np.arange(1, len(self.window_labels) + 1)\n+    starts = stops - int(self.window[0])\n+    \n+    # Apply centering shift if center=True\n+    if self.center[0]:\n+        shift = -(self.window[0] // 2)\n+        starts = starts + shift\n+        stops = stops + shift\n+    \n+    # Handle boundary conditions\n+    starts = np.maximum(starts, 0)\n+    stops = np.minimum(stops, len(self.window_labels))\n+    \n+    for (label, start, stop) in zip(self.window_labels, starts, stops):\n+        window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+\n+        counts = window.count(dim=self.dim[0])\n+        window = window.where(counts >= self.min_periods)\n+\n+        yield (label, window)\n \n     def construct(\n         self,\n"
  }
}