{
  "zero_patches": {
    "Location 1 (/root/hy/projects/pytest/src/_pytest/unittest.py lines 123-128)": "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
    "Location 2 (/root/hy/projects/pytest/src/_pytest/unittest.py lines 223-225)": "\n    def teardown(self):\n        if self._explicit_tearDown is not None:\n            # Only call explicit tearDown if the test was not skipped\n            if not self._store.get(skipped_by_mark_key, False):\n                self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None\n",
    "Location 3 (/root/hy/projects/pytest/src/_pytest/unittest.py lines 177-182)": "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/pytest/src/_pytest/unittest.py lines 123-128)": [
      "\n    def teardown(self):\n        if self._explicit_tearDown is not None:\n            # Only call explicit tearDown if the test was not skipped\n            if not self._store.get(skipped_by_mark_key, False):\n                self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None\n",
      "\n    def teardown(self):\n        if self._explicit_tearDown is not None:\n            # Only call explicit tearDown if the test was not skipped\n            if not self._store.get(skipped_by_mark_key, False):\n                self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\n    def teardown(self):\n        if self._explicit_tearDown is not None:\n            # Only call explicit tearDown if the test was not skipped\n            if not self._store.get(skipped_by_mark_key, False):\n                self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n"
    ],
    "Location 2 (/root/hy/projects/pytest/src/_pytest/unittest.py lines 223-225)": [
      "\n    def teardown(self):\n        if self._explicit_tearDown is not None:\n            # Only call explicit tearDown if the test was not skipped\n            if not self._store.get(skipped_by_mark_key, False):\n                self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None\n",
      "\n    def teardown(self):\n        if self._explicit_tearDown is not None:\n            # Only call explicit tearDown if the test was not skipped\n            if not self._store.get(skipped_by_mark_key, False):\n                self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\n    def teardown(self):\n        if self._explicit_tearDown is not None:\n            # Only call explicit tearDown if the test was not skipped\n            if not self._store.get(skipped_by_mark_key, False):\n                self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\n    def teardown(self):\n        if self._explicit_tearDown is not None:\n            # Only call explicit tearDown if the test was not skipped\n            if not self._store.get(skipped_by_mark_key, False):\n                self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n"
    ],
    "Location 3 (/root/hy/projects/pytest/src/_pytest/unittest.py lines 177-182)": [
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\n    def teardown(self):\n        if self._explicit_tearDown is not None:\n            # Only call explicit tearDown if the test was not skipped\n            if not self._store.get(skipped_by_mark_key, False):\n                self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n",
      "\ndef teardown(self):\n    if self._explicit_tearDown is not None:\n        # Only call explicit tearDown if the test was not skipped\n        if not self._store.get(skipped_by_mark_key, False):\n            self._explicit_tearDown()\n        self._explicit_tearDown = None\n    self._testcase = None\n    self._obj = None\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 773f545af..789337a31 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -120,9 +120,12 @@ class TestCaseFunction(Function):\n         if hasattr(self, \"_request\"):\n             self._request._fillfixtures()\n \n+\n     def teardown(self):\n         if self._explicit_tearDown is not None:\n-            self._explicit_tearDown()\n+            # Only call explicit tearDown if the test was not skipped\n+            if not self._store.get(skipped_by_mark_key, False):\n+                self._explicit_tearDown()\n             self._explicit_tearDown = None\n         self._testcase = None\n         self._obj = None\n@@ -174,6 +177,7 @@ class TestCaseFunction(Function):\n     def addFailure(self, testcase, rawexcinfo):\n         self._addexcinfo(rawexcinfo)\n \n+\n     def addSkip(self, testcase, reason):\n         try:\n             skip(reason)\n@@ -220,6 +224,7 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n+\n             if self.config.getoption(\"usepdb\"):\n                 self._explicit_tearDown = self._testcase.tearDown\n                 setattr(self._testcase, \"tearDown\", lambda *args: None)\n",
    "variant_0": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 773f545af..9dcfe01cc 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -120,12 +120,15 @@ class TestCaseFunction(Function):\n         if hasattr(self, \"_request\"):\n             self._request._fillfixtures()\n \n-    def teardown(self):\n-        if self._explicit_tearDown is not None:\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n             self._explicit_tearDown()\n-            self._explicit_tearDown = None\n-        self._testcase = None\n-        self._obj = None\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def startTest(self, testcase):\n         pass\n@@ -174,12 +177,15 @@ class TestCaseFunction(Function):\n     def addFailure(self, testcase, rawexcinfo):\n         self._addexcinfo(rawexcinfo)\n \n-    def addSkip(self, testcase, reason):\n-        try:\n-            skip(reason)\n-        except skip.Exception:\n-            self._store[skipped_by_mark_key] = True\n-            self._addexcinfo(sys.exc_info())\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def addExpectedFailure(self, testcase, rawexcinfo, reason=\"\"):\n         try:\n@@ -220,9 +226,15 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n-            if self.config.getoption(\"usepdb\"):\n-                self._explicit_tearDown = self._testcase.tearDown\n-                setattr(self._testcase, \"tearDown\", lambda *args: None)\n+\n+    def teardown(self):\n+        if self._explicit_tearDown is not None:\n+            # Only call explicit tearDown if the test was not skipped\n+            if not self._store.get(skipped_by_mark_key, False):\n+                self._explicit_tearDown()\n+            self._explicit_tearDown = None\n+        self._testcase = None\n+        self._obj = None\n \n             # we need to update the actual bound method with self.obj, because\n             # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n",
    "variant_1": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 773f545af..cc31b34c1 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -120,9 +120,12 @@ class TestCaseFunction(Function):\n         if hasattr(self, \"_request\"):\n             self._request._fillfixtures()\n \n+\n     def teardown(self):\n         if self._explicit_tearDown is not None:\n-            self._explicit_tearDown()\n+            # Only call explicit tearDown if the test was not skipped\n+            if not self._store.get(skipped_by_mark_key, False):\n+                self._explicit_tearDown()\n             self._explicit_tearDown = None\n         self._testcase = None\n         self._obj = None\n@@ -174,12 +177,15 @@ class TestCaseFunction(Function):\n     def addFailure(self, testcase, rawexcinfo):\n         self._addexcinfo(rawexcinfo)\n \n-    def addSkip(self, testcase, reason):\n-        try:\n-            skip(reason)\n-        except skip.Exception:\n-            self._store[skipped_by_mark_key] = True\n-            self._addexcinfo(sys.exc_info())\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def addExpectedFailure(self, testcase, rawexcinfo, reason=\"\"):\n         try:\n@@ -220,9 +226,15 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n-            if self.config.getoption(\"usepdb\"):\n-                self._explicit_tearDown = self._testcase.tearDown\n-                setattr(self._testcase, \"tearDown\", lambda *args: None)\n+\n+    def teardown(self):\n+        if self._explicit_tearDown is not None:\n+            # Only call explicit tearDown if the test was not skipped\n+            if not self._store.get(skipped_by_mark_key, False):\n+                self._explicit_tearDown()\n+            self._explicit_tearDown = None\n+        self._testcase = None\n+        self._obj = None\n \n             # we need to update the actual bound method with self.obj, because\n             # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n",
    "variant_2": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 773f545af..266d0d0bc 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -120,9 +120,12 @@ class TestCaseFunction(Function):\n         if hasattr(self, \"_request\"):\n             self._request._fillfixtures()\n \n+\n     def teardown(self):\n         if self._explicit_tearDown is not None:\n-            self._explicit_tearDown()\n+            # Only call explicit tearDown if the test was not skipped\n+            if not self._store.get(skipped_by_mark_key, False):\n+                self._explicit_tearDown()\n             self._explicit_tearDown = None\n         self._testcase = None\n         self._obj = None\n@@ -174,12 +177,15 @@ class TestCaseFunction(Function):\n     def addFailure(self, testcase, rawexcinfo):\n         self._addexcinfo(rawexcinfo)\n \n-    def addSkip(self, testcase, reason):\n-        try:\n-            skip(reason)\n-        except skip.Exception:\n-            self._store[skipped_by_mark_key] = True\n-            self._addexcinfo(sys.exc_info())\n+\n+    def teardown(self):\n+        if self._explicit_tearDown is not None:\n+            # Only call explicit tearDown if the test was not skipped\n+            if not self._store.get(skipped_by_mark_key, False):\n+                self._explicit_tearDown()\n+            self._explicit_tearDown = None\n+        self._testcase = None\n+        self._obj = None\n \n     def addExpectedFailure(self, testcase, rawexcinfo, reason=\"\"):\n         try:\n@@ -220,9 +226,15 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n-            if self.config.getoption(\"usepdb\"):\n-                self._explicit_tearDown = self._testcase.tearDown\n-                setattr(self._testcase, \"tearDown\", lambda *args: None)\n+\n+    def teardown(self):\n+        if self._explicit_tearDown is not None:\n+            # Only call explicit tearDown if the test was not skipped\n+            if not self._store.get(skipped_by_mark_key, False):\n+                self._explicit_tearDown()\n+            self._explicit_tearDown = None\n+        self._testcase = None\n+        self._obj = None\n \n             # we need to update the actual bound method with self.obj, because\n             # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n",
    "variant_3": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 773f545af..8f64aff9e 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -120,12 +120,15 @@ class TestCaseFunction(Function):\n         if hasattr(self, \"_request\"):\n             self._request._fillfixtures()\n \n-    def teardown(self):\n-        if self._explicit_tearDown is not None:\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n             self._explicit_tearDown()\n-            self._explicit_tearDown = None\n-        self._testcase = None\n-        self._obj = None\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def startTest(self, testcase):\n         pass\n@@ -174,12 +177,15 @@ class TestCaseFunction(Function):\n     def addFailure(self, testcase, rawexcinfo):\n         self._addexcinfo(rawexcinfo)\n \n-    def addSkip(self, testcase, reason):\n-        try:\n-            skip(reason)\n-        except skip.Exception:\n-            self._store[skipped_by_mark_key] = True\n-            self._addexcinfo(sys.exc_info())\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def addExpectedFailure(self, testcase, rawexcinfo, reason=\"\"):\n         try:\n@@ -220,9 +226,15 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n-            if self.config.getoption(\"usepdb\"):\n-                self._explicit_tearDown = self._testcase.tearDown\n-                setattr(self._testcase, \"tearDown\", lambda *args: None)\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n             # we need to update the actual bound method with self.obj, because\n             # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n",
    "variant_4": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 773f545af..8f64aff9e 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -120,12 +120,15 @@ class TestCaseFunction(Function):\n         if hasattr(self, \"_request\"):\n             self._request._fillfixtures()\n \n-    def teardown(self):\n-        if self._explicit_tearDown is not None:\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n             self._explicit_tearDown()\n-            self._explicit_tearDown = None\n-        self._testcase = None\n-        self._obj = None\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def startTest(self, testcase):\n         pass\n@@ -174,12 +177,15 @@ class TestCaseFunction(Function):\n     def addFailure(self, testcase, rawexcinfo):\n         self._addexcinfo(rawexcinfo)\n \n-    def addSkip(self, testcase, reason):\n-        try:\n-            skip(reason)\n-        except skip.Exception:\n-            self._store[skipped_by_mark_key] = True\n-            self._addexcinfo(sys.exc_info())\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def addExpectedFailure(self, testcase, rawexcinfo, reason=\"\"):\n         try:\n@@ -220,9 +226,15 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n-            if self.config.getoption(\"usepdb\"):\n-                self._explicit_tearDown = self._testcase.tearDown\n-                setattr(self._testcase, \"tearDown\", lambda *args: None)\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n             # we need to update the actual bound method with self.obj, because\n             # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n",
    "variant_5": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 773f545af..cc31b34c1 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -120,9 +120,12 @@ class TestCaseFunction(Function):\n         if hasattr(self, \"_request\"):\n             self._request._fillfixtures()\n \n+\n     def teardown(self):\n         if self._explicit_tearDown is not None:\n-            self._explicit_tearDown()\n+            # Only call explicit tearDown if the test was not skipped\n+            if not self._store.get(skipped_by_mark_key, False):\n+                self._explicit_tearDown()\n             self._explicit_tearDown = None\n         self._testcase = None\n         self._obj = None\n@@ -174,12 +177,15 @@ class TestCaseFunction(Function):\n     def addFailure(self, testcase, rawexcinfo):\n         self._addexcinfo(rawexcinfo)\n \n-    def addSkip(self, testcase, reason):\n-        try:\n-            skip(reason)\n-        except skip.Exception:\n-            self._store[skipped_by_mark_key] = True\n-            self._addexcinfo(sys.exc_info())\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def addExpectedFailure(self, testcase, rawexcinfo, reason=\"\"):\n         try:\n@@ -220,9 +226,15 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n-            if self.config.getoption(\"usepdb\"):\n-                self._explicit_tearDown = self._testcase.tearDown\n-                setattr(self._testcase, \"tearDown\", lambda *args: None)\n+\n+    def teardown(self):\n+        if self._explicit_tearDown is not None:\n+            # Only call explicit tearDown if the test was not skipped\n+            if not self._store.get(skipped_by_mark_key, False):\n+                self._explicit_tearDown()\n+            self._explicit_tearDown = None\n+        self._testcase = None\n+        self._obj = None\n \n             # we need to update the actual bound method with self.obj, because\n             # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n",
    "variant_6": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 773f545af..8f64aff9e 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -120,12 +120,15 @@ class TestCaseFunction(Function):\n         if hasattr(self, \"_request\"):\n             self._request._fillfixtures()\n \n-    def teardown(self):\n-        if self._explicit_tearDown is not None:\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n             self._explicit_tearDown()\n-            self._explicit_tearDown = None\n-        self._testcase = None\n-        self._obj = None\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def startTest(self, testcase):\n         pass\n@@ -174,12 +177,15 @@ class TestCaseFunction(Function):\n     def addFailure(self, testcase, rawexcinfo):\n         self._addexcinfo(rawexcinfo)\n \n-    def addSkip(self, testcase, reason):\n-        try:\n-            skip(reason)\n-        except skip.Exception:\n-            self._store[skipped_by_mark_key] = True\n-            self._addexcinfo(sys.exc_info())\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def addExpectedFailure(self, testcase, rawexcinfo, reason=\"\"):\n         try:\n@@ -220,9 +226,15 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n-            if self.config.getoption(\"usepdb\"):\n-                self._explicit_tearDown = self._testcase.tearDown\n-                setattr(self._testcase, \"tearDown\", lambda *args: None)\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n             # we need to update the actual bound method with self.obj, because\n             # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n",
    "variant_7": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 773f545af..9dcfe01cc 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -120,12 +120,15 @@ class TestCaseFunction(Function):\n         if hasattr(self, \"_request\"):\n             self._request._fillfixtures()\n \n-    def teardown(self):\n-        if self._explicit_tearDown is not None:\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n             self._explicit_tearDown()\n-            self._explicit_tearDown = None\n-        self._testcase = None\n-        self._obj = None\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def startTest(self, testcase):\n         pass\n@@ -174,12 +177,15 @@ class TestCaseFunction(Function):\n     def addFailure(self, testcase, rawexcinfo):\n         self._addexcinfo(rawexcinfo)\n \n-    def addSkip(self, testcase, reason):\n-        try:\n-            skip(reason)\n-        except skip.Exception:\n-            self._store[skipped_by_mark_key] = True\n-            self._addexcinfo(sys.exc_info())\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def addExpectedFailure(self, testcase, rawexcinfo, reason=\"\"):\n         try:\n@@ -220,9 +226,15 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n-            if self.config.getoption(\"usepdb\"):\n-                self._explicit_tearDown = self._testcase.tearDown\n-                setattr(self._testcase, \"tearDown\", lambda *args: None)\n+\n+    def teardown(self):\n+        if self._explicit_tearDown is not None:\n+            # Only call explicit tearDown if the test was not skipped\n+            if not self._store.get(skipped_by_mark_key, False):\n+                self._explicit_tearDown()\n+            self._explicit_tearDown = None\n+        self._testcase = None\n+        self._obj = None\n \n             # we need to update the actual bound method with self.obj, because\n             # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n",
    "variant_8": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex 773f545af..8f64aff9e 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -120,12 +120,15 @@ class TestCaseFunction(Function):\n         if hasattr(self, \"_request\"):\n             self._request._fillfixtures()\n \n-    def teardown(self):\n-        if self._explicit_tearDown is not None:\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n             self._explicit_tearDown()\n-            self._explicit_tearDown = None\n-        self._testcase = None\n-        self._obj = None\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def startTest(self, testcase):\n         pass\n@@ -174,12 +177,15 @@ class TestCaseFunction(Function):\n     def addFailure(self, testcase, rawexcinfo):\n         self._addexcinfo(rawexcinfo)\n \n-    def addSkip(self, testcase, reason):\n-        try:\n-            skip(reason)\n-        except skip.Exception:\n-            self._store[skipped_by_mark_key] = True\n-            self._addexcinfo(sys.exc_info())\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n     def addExpectedFailure(self, testcase, rawexcinfo, reason=\"\"):\n         try:\n@@ -220,9 +226,15 @@ class TestCaseFunction(Function):\n             # arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed\n-            if self.config.getoption(\"usepdb\"):\n-                self._explicit_tearDown = self._testcase.tearDown\n-                setattr(self._testcase, \"tearDown\", lambda *args: None)\n+\n+def teardown(self):\n+    if self._explicit_tearDown is not None:\n+        # Only call explicit tearDown if the test was not skipped\n+        if not self._store.get(skipped_by_mark_key, False):\n+            self._explicit_tearDown()\n+        self._explicit_tearDown = None\n+    self._testcase = None\n+    self._obj = None\n \n             # we need to update the actual bound method with self.obj, because\n             # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n"
  }
}