{
  "zero_patches": {
    "Location 1 (/root/hy/projects/xarray/xarray/core/variable.py lines 812-812)": "\n            if isinstance(data, indexing.MemoryCachedArray):\n                # don't share caching between copies\n                data = indexing.MemoryCachedArray(data.array)\n\n            if deep:\n                if isinstance(data, dask_array_type):\n                    data = data.copy()\n                elif not isinstance(data, PandasIndexAdapter):\n                    # pandas.Index is immutable\n                    data = np.array(data, dtype=data.dtype)\n",
    "Location 2 (/root/hy/projects/xarray/xarray/core/variable.py lines 183-183)": "\n    # validate whether the data is valid data types\n    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n",
    "Location 3 (/root/hy/projects/xarray/xarray/core/variable.py lines 807-813)": "\n        if deep:\n            if isinstance(data, dask_array_type):\n                data = data.copy()\n            elif not isinstance(data, PandasIndexAdapter):\n                # pandas.Index is immutable\n                data = np.array(data, dtype=data.dtype)\n",
    "Location 4 (/root/hy/projects/xarray/xarray/core/variable.py lines 1950-1954)": "\n        if data is None:\n            if deep:\n                # self._data should be a `PandasIndexAdapter` instance at this\n                # point, which doesn't have a copy method, so make a deep copy\n                # of the underlying `pandas.MultiIndex` and create a new\n                # `PandasIndexAdapter` instance with it.\n                data = PandasIndexAdapter(self._data.array.copy(deep=True))\n            else:\n                data = self._data\n        else:\n            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n",
    "Location 5 (/root/hy/projects/xarray/xarray/core/dataset.py lines 936-937)": "\n        if data is None:\n            variables = OrderedDict((k, v.copy(deep=deep))\n                                    for k, v in self._variables.items())\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/xarray/xarray/core/variable.py lines 812-812)": [
      "\n            if isinstance(data, indexing.MemoryCachedArray):\n                # don't share caching between copies\n                data = indexing.MemoryCachedArray(data.array)\n\n            if deep:\n                if isinstance(data, dask_array_type):\n                    data = data.copy()\n                elif not isinstance(data, PandasIndexAdapter):\n                    # pandas.Index is immutable\n                    data = np.array(data, dtype=data.dtype)\n        else:\n            data = as_compatible_data(data)\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n\n        # note:\n        # dims is already an immutable tuple\n        # attributes and encoding will be copied when the new Array is created\n        return type(self)(self.dims, data, self._attrs, self._encoding,\n",
      "\n            if isinstance(data, indexing.MemoryCachedArray):\n                # don't share caching between copies\n                data = indexing.MemoryCachedArray(data.array)\n\n            if deep:\n                if isinstance(data, dask_array_type):\n                    data = data.copy()\n                elif not isinstance(data, PandasIndexAdapter):\n                    # pandas.Index is immutable\n                    data = np.array(data, dtype=data.dtype)\n",
      "\n            if isinstance(data, indexing.MemoryCachedArray):\n                # don't share caching between copies\n                data = indexing.MemoryCachedArray(data.array)\n\n            if deep:\n                if isinstance(data, dask_array_type):\n                    data = data.copy()\n                elif not isinstance(data, PandasIndexAdapter):\n                    # pandas.Index is immutable\n                    data = np.array(data, dtype=data.dtype)\n",
      "\n            if isinstance(data, indexing.MemoryCachedArray):\n                # don't share caching between copies\n                data = indexing.MemoryCachedArray(data.array)\n\n            if deep:\n                if isinstance(data, dask_array_type):\n                    data = data.copy()\n                elif not isinstance(data, PandasIndexAdapter):\n                    # pandas.Index is immutable\n                    data = np.array(data, dtype=data.dtype)\n",
      "\n            if isinstance(data, indexing.MemoryCachedArray):\n                # don't share caching between copies\n                data = indexing.MemoryCachedArray(data.array)\n\n            if deep:\n                if isinstance(data, dask_array_type):\n                    data = data.copy()\n                elif not isinstance(data, PandasIndexAdapter):\n                    # pandas.Index is immutable\n                    data = np.array(data, dtype=data.dtype)\n",
      "\n            if isinstance(data, indexing.MemoryCachedArray):\n                # don't share caching between copies\n                data = indexing.MemoryCachedArray(data.array)\n\n            if deep:\n                if isinstance(data, dask_array_type):\n                    data = data.copy()\n                elif not isinstance(data, PandasIndexAdapter):\n                    # pandas.Index is immutable\n                    data = np.array(data, dtype=data.dtype)\n",
      "\n            if isinstance(data, indexing.MemoryCachedArray):\n                # don't share caching between copies\n                data = indexing.MemoryCachedArray(data.array)\n\n            if deep:\n                if isinstance(data, dask_array_type):\n                    data = data.copy()\n                elif not isinstance(data, PandasIndexAdapter):\n                    # pandas.Index is immutable\n                    data = np.array(data, dtype=data.dtype)\n",
      "\n            if isinstance(data, indexing.MemoryCachedArray):\n                # don't share caching between copies\n                data = indexing.MemoryCachedArray(data.array)\n\n            if deep:\n                if isinstance(data, dask_array_type):\n                    data = data.copy()\n                elif not isinstance(data, PandasIndexAdapter):\n                    # pandas.Index is immutable\n                    data = np.array(data, dtype=data.dtype)\n        else:\n            data = as_compatible_data(data)\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n\n        # note:\n        # dims is already an immutable tuple\n        # attributes and encoding will be copied when the new Array is created\n        return type(self)(self.dims, data, self._attrs, self._encoding,\n"
    ],
    "Location 2 (/root/hy/projects/xarray/xarray/core/variable.py lines 183-183)": [
      "\n    # validate whether the data is valid data types\n    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n",
      "\n    # validate whether the data is valid data types\n    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n",
      "\n    # validate whether the data is valid data types\n    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n",
      "\n    # validate whether the data is valid data types\n    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n",
      "\n    # validate whether the data is valid data types\n    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n",
      "\n    # validate whether the data is valid data types\n    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n",
      "\n    # validate whether the data is valid data types\n    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n",
      "\n    # validate whether the data is valid data types\n    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n"
    ],
    "Location 3 (/root/hy/projects/xarray/xarray/core/variable.py lines 807-813)": [
      "\n        if deep:\n            if isinstance(data, dask_array_type):\n                data = data.copy()\n            elif not isinstance(data, PandasIndexAdapter):\n                # pandas.Index is immutable\n                data = np.array(data, dtype=data.dtype)\n",
      "\n        if deep:\n            if isinstance(data, dask_array_type):\n                data = data.copy()\n            elif not isinstance(data, PandasIndexAdapter):\n                # pandas.Index is immutable\n                data = np.array(data, dtype=data.dtype)\n",
      "\n        if deep:\n            if isinstance(data, dask_array_type):\n                data = data.copy()\n            elif not isinstance(data, PandasIndexAdapter):\n                # pandas.Index is immutable\n                data = np.array(data, dtype=data.dtype)\n",
      "\n        if deep:\n            if isinstance(data, dask_array_type):\n                data = data.copy()\n            elif not isinstance(data, PandasIndexAdapter):\n                # pandas.Index is immutable\n                data = np.array(data, dtype=data.dtype)\n",
      "\n        if data is None:\n            data = self._data\n\n            if isinstance(data, indexing.MemoryCachedArray):\n                # don't share caching between copies\n                data = indexing.MemoryCachedArray(data.array)\n\n            if deep:\n                if isinstance(data, dask_array_type):\n                    data = data.copy()\n                elif not isinstance(data, PandasIndexAdapter):\n                    # pandas.Index is immutable\n                    data = np.array(data, dtype=data.dtype)\n        else:\n",
      "\n        if deep:\n            if isinstance(data, dask_array_type):\n                data = data.copy()\n            elif not isinstance(data, PandasIndexAdapter):\n                # pandas.Index is immutable\n                data = np.array(data, dtype=data.dtype)\n",
      "\n        if deep:\n            if isinstance(data, dask_array_type):\n                data = data.copy()\n            elif not isinstance(data, PandasIndexAdapter):\n                # pandas.Index is immutable\n                data = np.array(data, dtype=data.dtype)\n",
      "\n        if deep:\n            if isinstance(data, dask_array_type):\n                data = data.copy()\n            elif not isinstance(data, PandasIndexAdapter):\n                # pandas.Index is immutable\n                data = np.array(data, dtype=data.dtype)\n"
    ],
    "Location 4 (/root/hy/projects/xarray/xarray/core/variable.py lines 1950-1954)": [
      "\n        if data is None:\n            if deep:\n                # self._data should be a `PandasIndexAdapter` instance at this\n                # point, which doesn't have a copy method, so make a deep copy\n                # of the underlying `pandas.MultiIndex` and create a new\n                # `PandasIndexAdapter` instance with it.\n                data = PandasIndexAdapter(self._data.array.copy(deep=True))\n            else:\n                data = self._data\n        else:\n            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n",
      "\n        if data is None:\n            if deep:\n                # self._data should be a `PandasIndexAdapter` instance at this\n                # point, which doesn't have a copy method, so make a deep copy\n                # of the underlying `pandas.MultiIndex` and create a new\n                # `PandasIndexAdapter` instance with it.\n                data = PandasIndexAdapter(self._data.array.copy(deep=True))\n            else:\n                data = self._data\n        else:\n            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n",
      "\n        if data is None:\n            if deep:\n                # self._data should be a `PandasIndexAdapter` instance at this\n                # point, which doesn't have a copy method, so make a deep copy\n                # of the underlying `pandas.MultiIndex` and create a new\n                # `PandasIndexAdapter` instance with it.\n                data = PandasIndexAdapter(self._data.array.copy(deep=True))\n            else:\n                data = self._data\n        else:\n            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n",
      "\n        if data is None:\n            if deep:\n                # self._data should be a `PandasIndexAdapter` instance at this\n                # point, which doesn't have a copy method, so make a deep copy\n                # of the underlying `pandas.MultiIndex` and create a new\n                # `PandasIndexAdapter` instance with it.\n                data = PandasIndexAdapter(self._data.array.copy(deep=True))\n            else:\n                data = self._data\n        else:\n            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n",
      "\n        if data is None:\n            if deep:\n                # self._data should be a `PandasIndexAdapter` instance at this\n                # point, which doesn't have a copy method, so make a deep copy\n                # of the underlying `pandas.MultiIndex` and create a new\n                # `PandasIndexAdapter` instance with it.\n                data = PandasIndexAdapter(self._data.array.copy(deep=True))\n            else:\n                data = self._data\n        else:\n            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n",
      "\n        if data is None:\n            if deep:\n                # self._data should be a `PandasIndexAdapter` instance at this\n                # point, which doesn't have a copy method, so make a deep copy\n                # of the underlying `pandas.MultiIndex` and create a new\n                # `PandasIndexAdapter` instance with it.\n                data = PandasIndexAdapter(self._data.array.copy(deep=True))\n            else:\n                data = self._data\n        else:\n            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n",
      "\n        if data is None:\n            if deep:\n                # self._data should be a `PandasIndexAdapter` instance at this\n                # point, which doesn't have a copy method, so make a deep copy\n                # of the underlying `pandas.MultiIndex` and create a new\n                # `PandasIndexAdapter` instance with it.\n                data = PandasIndexAdapter(self._data.array.copy(deep=True))\n            else:\n                data = self._data\n        else:\n            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n",
      "\n        if data is None:\n            if deep:\n                # self._data should be a `PandasIndexAdapter` instance at this\n                # point, which doesn't have a copy method, so make a deep copy\n                # of the underlying `pandas.MultiIndex` and create a new\n                # `PandasIndexAdapter` instance with it.\n                data = PandasIndexAdapter(self._data.array.copy(deep=True))\n            else:\n                data = self._data\n        else:\n            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n            if self.shape != data.shape:\n                raise ValueError(\"Data shape {} must match shape of object {}\"\n                                 .format(data.shape, self.shape))\n"
    ],
    "Location 5 (/root/hy/projects/xarray/xarray/core/dataset.py lines 936-937)": [
      "\n        if data is None:\n            variables = OrderedDict((k, v.copy(deep=deep))\n                                    for k, v in self._variables.items())\n",
      "\n        if data is None:\n            variables = OrderedDict((k, v.copy(deep=deep))\n                                    for k, v in self._variables.items())\n",
      "\n        if data is None:\n            variables = OrderedDict((k, v.copy(deep=deep))\n                                    for k, v in self._variables.items())\n",
      "\n        if data is None:\n            variables = OrderedDict((k, v.copy(deep=deep))\n                                    for k, v in self._variables.items())\n",
      "\n        if data is None:\n            variables = OrderedDict((k, v.copy(deep=deep))\n                                    for k, v in self._variables.items())\n",
      "\n        if data is None:\n            variables = OrderedDict((k, v.copy(deep=deep))\n                                    for k, v in self._variables.items())\n",
      "\n        if data is None:\n            variables = OrderedDict((k, v.copy(deep=deep))\n                                    for k, v in self._variables.items())\n",
      "\n        if data is None:\n            variables = OrderedDict((k, v.copy(deep=deep))\n                                    for k, v in self._variables.items())\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..c16d83b5 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -933,6 +933,7 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n         if data is None:\n+\n             variables = OrderedDict((k, v.copy(deep=deep))\n                                     for k, v in self._variables.items())\n         elif not utils.is_dict_like(data):\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5..c0ae697e 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -180,7 +180,8 @@ def as_compatible_data(data, fastpath=False):\n             data = np.asarray(data)\n \n     # validate whether the data is valid data types\n-    data = np.asarray(data)\n+\n+    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n \n     if isinstance(data, np.ndarray):\n         if data.dtype.kind == 'O':\n@@ -804,12 +805,14 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                 # don't share caching between copies\n                 data = indexing.MemoryCachedArray(data.array)\n \n+\n             if deep:\n                 if isinstance(data, dask_array_type):\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n                     # pandas.Index is immutable\n-                    data = np.array(data)\n+                    data = np.array(data, dtype=data.dtype)\n+        else:\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n@@ -1947,6 +1950,7 @@ class IndexVariable(Variable):\n                 # point, which doesn't have a copy method, so make a deep copy\n                 # of the underlying `pandas.MultiIndex` and create a new\n                 # `PandasIndexAdapter` instance with it.\n+\n                 data = PandasIndexAdapter(self._data.array.copy(deep=True))\n             else:\n                 data = self._data\n",
    "variant_0": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..96dbfb2a 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -932,6 +932,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         --------\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n+        if data is None:\n+\n         if data is None:\n             variables = OrderedDict((k, v.copy(deep=deep))\n                                     for k, v in self._variables.items())\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5..7c4df3c0 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -180,7 +180,9 @@ def as_compatible_data(data, fastpath=False):\n             data = np.asarray(data)\n \n     # validate whether the data is valid data types\n-    data = np.asarray(data)\n+\n+    # validate whether the data is valid data types\n+    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n \n     if isinstance(data, np.ndarray):\n         if data.dtype.kind == 'O':\n@@ -804,12 +806,22 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                 # don't share caching between copies\n                 data = indexing.MemoryCachedArray(data.array)\n \n+\n+        if deep:\n+            if isinstance(data, dask_array_type):\n+                data = data.copy()\n+            elif not isinstance(data, PandasIndexAdapter):\n+                # pandas.Index is immutable\n+                data = np.array(data, dtype=data.dtype)\n+                # don't share caching between copies\n+                data = indexing.MemoryCachedArray(data.array)\n+\n             if deep:\n                 if isinstance(data, dask_array_type):\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n                     # pandas.Index is immutable\n-                    data = np.array(data)\n+                    data = np.array(data, dtype=data.dtype)\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n@@ -1941,6 +1953,13 @@ class IndexVariable(Variable):\n             New object with dimensions, attributes, encodings, and optionally\n             data copied from original.\n         \"\"\"\n+        if data is None:\n+            if deep:\n+                # self._data should be a `PandasIndexAdapter` instance at this\n+                # point, which doesn't have a copy method, so make a deep copy\n+                # of the underlying `pandas.MultiIndex` and create a new\n+                # `PandasIndexAdapter` instance with it.\n+\n         if data is None:\n             if deep:\n                 # self._data should be a `PandasIndexAdapter` instance at this\n@@ -1951,7 +1970,10 @@ class IndexVariable(Variable):\n             else:\n                 data = self._data\n         else:\n-            data = as_compatible_data(data)\n+            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n             if self.shape != data.shape:\n                 raise ValueError(\"Data shape {} must match shape of object {}\"\n                                  .format(data.shape, self.shape))\n",
    "variant_1": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..96dbfb2a 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -932,6 +932,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         --------\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n+        if data is None:\n+\n         if data is None:\n             variables = OrderedDict((k, v.copy(deep=deep))\n                                     for k, v in self._variables.items())\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5..1e04cb88 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -180,7 +180,9 @@ def as_compatible_data(data, fastpath=False):\n             data = np.asarray(data)\n \n     # validate whether the data is valid data types\n-    data = np.asarray(data)\n+\n+    # validate whether the data is valid data types\n+    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n \n     if isinstance(data, np.ndarray):\n         if data.dtype.kind == 'O':\n@@ -804,12 +806,32 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                 # don't share caching between copies\n                 data = indexing.MemoryCachedArray(data.array)\n \n+\n+        if deep:\n+            if isinstance(data, dask_array_type):\n+                data = data.copy()\n+            elif not isinstance(data, PandasIndexAdapter):\n+                # pandas.Index is immutable\n+                data = np.array(data, dtype=data.dtype)\n+                # don't share caching between copies\n+                data = indexing.MemoryCachedArray(data.array)\n+\n             if deep:\n                 if isinstance(data, dask_array_type):\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n                     # pandas.Index is immutable\n-                    data = np.array(data)\n+                    data = np.array(data, dtype=data.dtype)\n+        else:\n+            data = as_compatible_data(data)\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n+\n+        # note:\n+        # dims is already an immutable tuple\n+        # attributes and encoding will be copied when the new Array is created\n+        return type(self)(self.dims, data, self._attrs, self._encoding,\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n@@ -1941,6 +1963,13 @@ class IndexVariable(Variable):\n             New object with dimensions, attributes, encodings, and optionally\n             data copied from original.\n         \"\"\"\n+        if data is None:\n+            if deep:\n+                # self._data should be a `PandasIndexAdapter` instance at this\n+                # point, which doesn't have a copy method, so make a deep copy\n+                # of the underlying `pandas.MultiIndex` and create a new\n+                # `PandasIndexAdapter` instance with it.\n+\n         if data is None:\n             if deep:\n                 # self._data should be a `PandasIndexAdapter` instance at this\n@@ -1951,7 +1980,10 @@ class IndexVariable(Variable):\n             else:\n                 data = self._data\n         else:\n-            data = as_compatible_data(data)\n+            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n             if self.shape != data.shape:\n                 raise ValueError(\"Data shape {} must match shape of object {}\"\n                                  .format(data.shape, self.shape))\n",
    "variant_2": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..96dbfb2a 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -932,6 +932,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         --------\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n+        if data is None:\n+\n         if data is None:\n             variables = OrderedDict((k, v.copy(deep=deep))\n                                     for k, v in self._variables.items())\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5..7c4df3c0 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -180,7 +180,9 @@ def as_compatible_data(data, fastpath=False):\n             data = np.asarray(data)\n \n     # validate whether the data is valid data types\n-    data = np.asarray(data)\n+\n+    # validate whether the data is valid data types\n+    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n \n     if isinstance(data, np.ndarray):\n         if data.dtype.kind == 'O':\n@@ -804,12 +806,22 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                 # don't share caching between copies\n                 data = indexing.MemoryCachedArray(data.array)\n \n+\n+        if deep:\n+            if isinstance(data, dask_array_type):\n+                data = data.copy()\n+            elif not isinstance(data, PandasIndexAdapter):\n+                # pandas.Index is immutable\n+                data = np.array(data, dtype=data.dtype)\n+                # don't share caching between copies\n+                data = indexing.MemoryCachedArray(data.array)\n+\n             if deep:\n                 if isinstance(data, dask_array_type):\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n                     # pandas.Index is immutable\n-                    data = np.array(data)\n+                    data = np.array(data, dtype=data.dtype)\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n@@ -1941,6 +1953,13 @@ class IndexVariable(Variable):\n             New object with dimensions, attributes, encodings, and optionally\n             data copied from original.\n         \"\"\"\n+        if data is None:\n+            if deep:\n+                # self._data should be a `PandasIndexAdapter` instance at this\n+                # point, which doesn't have a copy method, so make a deep copy\n+                # of the underlying `pandas.MultiIndex` and create a new\n+                # `PandasIndexAdapter` instance with it.\n+\n         if data is None:\n             if deep:\n                 # self._data should be a `PandasIndexAdapter` instance at this\n@@ -1951,7 +1970,10 @@ class IndexVariable(Variable):\n             else:\n                 data = self._data\n         else:\n-            data = as_compatible_data(data)\n+            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n             if self.shape != data.shape:\n                 raise ValueError(\"Data shape {} must match shape of object {}\"\n                                  .format(data.shape, self.shape))\n",
    "variant_3": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..96dbfb2a 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -932,6 +932,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         --------\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n+        if data is None:\n+\n         if data is None:\n             variables = OrderedDict((k, v.copy(deep=deep))\n                                     for k, v in self._variables.items())\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5..7c4df3c0 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -180,7 +180,9 @@ def as_compatible_data(data, fastpath=False):\n             data = np.asarray(data)\n \n     # validate whether the data is valid data types\n-    data = np.asarray(data)\n+\n+    # validate whether the data is valid data types\n+    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n \n     if isinstance(data, np.ndarray):\n         if data.dtype.kind == 'O':\n@@ -804,12 +806,22 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                 # don't share caching between copies\n                 data = indexing.MemoryCachedArray(data.array)\n \n+\n+        if deep:\n+            if isinstance(data, dask_array_type):\n+                data = data.copy()\n+            elif not isinstance(data, PandasIndexAdapter):\n+                # pandas.Index is immutable\n+                data = np.array(data, dtype=data.dtype)\n+                # don't share caching between copies\n+                data = indexing.MemoryCachedArray(data.array)\n+\n             if deep:\n                 if isinstance(data, dask_array_type):\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n                     # pandas.Index is immutable\n-                    data = np.array(data)\n+                    data = np.array(data, dtype=data.dtype)\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n@@ -1941,6 +1953,13 @@ class IndexVariable(Variable):\n             New object with dimensions, attributes, encodings, and optionally\n             data copied from original.\n         \"\"\"\n+        if data is None:\n+            if deep:\n+                # self._data should be a `PandasIndexAdapter` instance at this\n+                # point, which doesn't have a copy method, so make a deep copy\n+                # of the underlying `pandas.MultiIndex` and create a new\n+                # `PandasIndexAdapter` instance with it.\n+\n         if data is None:\n             if deep:\n                 # self._data should be a `PandasIndexAdapter` instance at this\n@@ -1951,7 +1970,10 @@ class IndexVariable(Variable):\n             else:\n                 data = self._data\n         else:\n-            data = as_compatible_data(data)\n+            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n             if self.shape != data.shape:\n                 raise ValueError(\"Data shape {} must match shape of object {}\"\n                                  .format(data.shape, self.shape))\n",
    "variant_4": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..96dbfb2a 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -932,6 +932,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         --------\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n+        if data is None:\n+\n         if data is None:\n             variables = OrderedDict((k, v.copy(deep=deep))\n                                     for k, v in self._variables.items())\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5..7c4df3c0 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -180,7 +180,9 @@ def as_compatible_data(data, fastpath=False):\n             data = np.asarray(data)\n \n     # validate whether the data is valid data types\n-    data = np.asarray(data)\n+\n+    # validate whether the data is valid data types\n+    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n \n     if isinstance(data, np.ndarray):\n         if data.dtype.kind == 'O':\n@@ -804,12 +806,22 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                 # don't share caching between copies\n                 data = indexing.MemoryCachedArray(data.array)\n \n+\n+        if deep:\n+            if isinstance(data, dask_array_type):\n+                data = data.copy()\n+            elif not isinstance(data, PandasIndexAdapter):\n+                # pandas.Index is immutable\n+                data = np.array(data, dtype=data.dtype)\n+                # don't share caching between copies\n+                data = indexing.MemoryCachedArray(data.array)\n+\n             if deep:\n                 if isinstance(data, dask_array_type):\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n                     # pandas.Index is immutable\n-                    data = np.array(data)\n+                    data = np.array(data, dtype=data.dtype)\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n@@ -1941,6 +1953,13 @@ class IndexVariable(Variable):\n             New object with dimensions, attributes, encodings, and optionally\n             data copied from original.\n         \"\"\"\n+        if data is None:\n+            if deep:\n+                # self._data should be a `PandasIndexAdapter` instance at this\n+                # point, which doesn't have a copy method, so make a deep copy\n+                # of the underlying `pandas.MultiIndex` and create a new\n+                # `PandasIndexAdapter` instance with it.\n+\n         if data is None:\n             if deep:\n                 # self._data should be a `PandasIndexAdapter` instance at this\n@@ -1951,7 +1970,10 @@ class IndexVariable(Variable):\n             else:\n                 data = self._data\n         else:\n-            data = as_compatible_data(data)\n+            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n             if self.shape != data.shape:\n                 raise ValueError(\"Data shape {} must match shape of object {}\"\n                                  .format(data.shape, self.shape))\n",
    "variant_5": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..96dbfb2a 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -932,6 +932,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         --------\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n+        if data is None:\n+\n         if data is None:\n             variables = OrderedDict((k, v.copy(deep=deep))\n                                     for k, v in self._variables.items())\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5..03bf4e91 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -180,7 +180,9 @@ def as_compatible_data(data, fastpath=False):\n             data = np.asarray(data)\n \n     # validate whether the data is valid data types\n-    data = np.asarray(data)\n+\n+    # validate whether the data is valid data types\n+    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n \n     if isinstance(data, np.ndarray):\n         if data.dtype.kind == 'O':\n@@ -797,6 +799,14 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n         --------\n         pandas.DataFrame.copy\n         \"\"\"\n+        if data is None:\n+            data = self._data\n+\n+            if isinstance(data, indexing.MemoryCachedArray):\n+                # don't share caching between copies\n+                data = indexing.MemoryCachedArray(data.array)\n+\n+\n         if data is None:\n             data = self._data\n \n@@ -809,7 +819,17 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n                     # pandas.Index is immutable\n-                    data = np.array(data)\n+                    data = np.array(data, dtype=data.dtype)\n+        else:\n+                # don't share caching between copies\n+                data = indexing.MemoryCachedArray(data.array)\n+\n+            if deep:\n+                if isinstance(data, dask_array_type):\n+                    data = data.copy()\n+                elif not isinstance(data, PandasIndexAdapter):\n+                    # pandas.Index is immutable\n+                    data = np.array(data, dtype=data.dtype)\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n@@ -1941,6 +1961,13 @@ class IndexVariable(Variable):\n             New object with dimensions, attributes, encodings, and optionally\n             data copied from original.\n         \"\"\"\n+        if data is None:\n+            if deep:\n+                # self._data should be a `PandasIndexAdapter` instance at this\n+                # point, which doesn't have a copy method, so make a deep copy\n+                # of the underlying `pandas.MultiIndex` and create a new\n+                # `PandasIndexAdapter` instance with it.\n+\n         if data is None:\n             if deep:\n                 # self._data should be a `PandasIndexAdapter` instance at this\n@@ -1951,7 +1978,10 @@ class IndexVariable(Variable):\n             else:\n                 data = self._data\n         else:\n-            data = as_compatible_data(data)\n+            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n             if self.shape != data.shape:\n                 raise ValueError(\"Data shape {} must match shape of object {}\"\n                                  .format(data.shape, self.shape))\n",
    "variant_6": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..96dbfb2a 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -932,6 +932,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         --------\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n+        if data is None:\n+\n         if data is None:\n             variables = OrderedDict((k, v.copy(deep=deep))\n                                     for k, v in self._variables.items())\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5..7c4df3c0 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -180,7 +180,9 @@ def as_compatible_data(data, fastpath=False):\n             data = np.asarray(data)\n \n     # validate whether the data is valid data types\n-    data = np.asarray(data)\n+\n+    # validate whether the data is valid data types\n+    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n \n     if isinstance(data, np.ndarray):\n         if data.dtype.kind == 'O':\n@@ -804,12 +806,22 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                 # don't share caching between copies\n                 data = indexing.MemoryCachedArray(data.array)\n \n+\n+        if deep:\n+            if isinstance(data, dask_array_type):\n+                data = data.copy()\n+            elif not isinstance(data, PandasIndexAdapter):\n+                # pandas.Index is immutable\n+                data = np.array(data, dtype=data.dtype)\n+                # don't share caching between copies\n+                data = indexing.MemoryCachedArray(data.array)\n+\n             if deep:\n                 if isinstance(data, dask_array_type):\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n                     # pandas.Index is immutable\n-                    data = np.array(data)\n+                    data = np.array(data, dtype=data.dtype)\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n@@ -1941,6 +1953,13 @@ class IndexVariable(Variable):\n             New object with dimensions, attributes, encodings, and optionally\n             data copied from original.\n         \"\"\"\n+        if data is None:\n+            if deep:\n+                # self._data should be a `PandasIndexAdapter` instance at this\n+                # point, which doesn't have a copy method, so make a deep copy\n+                # of the underlying `pandas.MultiIndex` and create a new\n+                # `PandasIndexAdapter` instance with it.\n+\n         if data is None:\n             if deep:\n                 # self._data should be a `PandasIndexAdapter` instance at this\n@@ -1951,7 +1970,10 @@ class IndexVariable(Variable):\n             else:\n                 data = self._data\n         else:\n-            data = as_compatible_data(data)\n+            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n             if self.shape != data.shape:\n                 raise ValueError(\"Data shape {} must match shape of object {}\"\n                                  .format(data.shape, self.shape))\n",
    "variant_7": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..96dbfb2a 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -932,6 +932,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         --------\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n+        if data is None:\n+\n         if data is None:\n             variables = OrderedDict((k, v.copy(deep=deep))\n                                     for k, v in self._variables.items())\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5..7c4df3c0 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -180,7 +180,9 @@ def as_compatible_data(data, fastpath=False):\n             data = np.asarray(data)\n \n     # validate whether the data is valid data types\n-    data = np.asarray(data)\n+\n+    # validate whether the data is valid data types\n+    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n \n     if isinstance(data, np.ndarray):\n         if data.dtype.kind == 'O':\n@@ -804,12 +806,22 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                 # don't share caching between copies\n                 data = indexing.MemoryCachedArray(data.array)\n \n+\n+        if deep:\n+            if isinstance(data, dask_array_type):\n+                data = data.copy()\n+            elif not isinstance(data, PandasIndexAdapter):\n+                # pandas.Index is immutable\n+                data = np.array(data, dtype=data.dtype)\n+                # don't share caching between copies\n+                data = indexing.MemoryCachedArray(data.array)\n+\n             if deep:\n                 if isinstance(data, dask_array_type):\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n                     # pandas.Index is immutable\n-                    data = np.array(data)\n+                    data = np.array(data, dtype=data.dtype)\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n@@ -1941,6 +1953,13 @@ class IndexVariable(Variable):\n             New object with dimensions, attributes, encodings, and optionally\n             data copied from original.\n         \"\"\"\n+        if data is None:\n+            if deep:\n+                # self._data should be a `PandasIndexAdapter` instance at this\n+                # point, which doesn't have a copy method, so make a deep copy\n+                # of the underlying `pandas.MultiIndex` and create a new\n+                # `PandasIndexAdapter` instance with it.\n+\n         if data is None:\n             if deep:\n                 # self._data should be a `PandasIndexAdapter` instance at this\n@@ -1951,7 +1970,10 @@ class IndexVariable(Variable):\n             else:\n                 data = self._data\n         else:\n-            data = as_compatible_data(data)\n+            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n             if self.shape != data.shape:\n                 raise ValueError(\"Data shape {} must match shape of object {}\"\n                                  .format(data.shape, self.shape))\n",
    "variant_8": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..96dbfb2a 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -932,6 +932,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         --------\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n+        if data is None:\n+\n         if data is None:\n             variables = OrderedDict((k, v.copy(deep=deep))\n                                     for k, v in self._variables.items())\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5..1e04cb88 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -180,7 +180,9 @@ def as_compatible_data(data, fastpath=False):\n             data = np.asarray(data)\n \n     # validate whether the data is valid data types\n-    data = np.asarray(data)\n+\n+    # validate whether the data is valid data types\n+    data = np.asarray(data, dtype=getattr(data, 'dtype', None))\n \n     if isinstance(data, np.ndarray):\n         if data.dtype.kind == 'O':\n@@ -804,12 +806,32 @@ class Variable(common.AbstractArray, arithmetic.SupportsArithmetic,\n                 # don't share caching between copies\n                 data = indexing.MemoryCachedArray(data.array)\n \n+\n+        if deep:\n+            if isinstance(data, dask_array_type):\n+                data = data.copy()\n+            elif not isinstance(data, PandasIndexAdapter):\n+                # pandas.Index is immutable\n+                data = np.array(data, dtype=data.dtype)\n+                # don't share caching between copies\n+                data = indexing.MemoryCachedArray(data.array)\n+\n             if deep:\n                 if isinstance(data, dask_array_type):\n                     data = data.copy()\n                 elif not isinstance(data, PandasIndexAdapter):\n                     # pandas.Index is immutable\n-                    data = np.array(data)\n+                    data = np.array(data, dtype=data.dtype)\n+        else:\n+            data = as_compatible_data(data)\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n+\n+        # note:\n+        # dims is already an immutable tuple\n+        # attributes and encoding will be copied when the new Array is created\n+        return type(self)(self.dims, data, self._attrs, self._encoding,\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\n@@ -1941,6 +1963,13 @@ class IndexVariable(Variable):\n             New object with dimensions, attributes, encodings, and optionally\n             data copied from original.\n         \"\"\"\n+        if data is None:\n+            if deep:\n+                # self._data should be a `PandasIndexAdapter` instance at this\n+                # point, which doesn't have a copy method, so make a deep copy\n+                # of the underlying `pandas.MultiIndex` and create a new\n+                # `PandasIndexAdapter` instance with it.\n+\n         if data is None:\n             if deep:\n                 # self._data should be a `PandasIndexAdapter` instance at this\n@@ -1951,7 +1980,10 @@ class IndexVariable(Variable):\n             else:\n                 data = self._data\n         else:\n-            data = as_compatible_data(data)\n+            data = as_compatible_data(data, dtype=getattr(data, 'dtype', None))\n+            if self.shape != data.shape:\n+                raise ValueError(\"Data shape {} must match shape of object {}\"\n+                                 .format(data.shape, self.shape))\n             if self.shape != data.shape:\n                 raise ValueError(\"Data shape {} must match shape of object {}\"\n                                  .format(data.shape, self.shape))\n"
  }
}