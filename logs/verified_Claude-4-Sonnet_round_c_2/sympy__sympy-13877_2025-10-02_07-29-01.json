{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/matrices/matrices.py lines 383-430)": "\n    def det(self, method=\"bareiss\"):\n        \"\"\"Computes the determinant of a matrix.  If the matrix\n        is at most 3x3, a hard-coded formula is used.\n        Otherwise, the determinant using the method `method`.\n\n\n        Possible values for \"method\":\n          bareis\n          berkowitz\n          lu\n        \"\"\"\n\n        # sanitize `method`\n        method = method.lower()\n        if method == \"bareis\":\n            method = \"bareiss\"\n        if method == \"det_lu\":\n            method = \"lu\"\n        if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n            raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n\n        # if methods were made internal and all determinant calculations\n        # passed through here, then these lines could be factored out of\n        # the method routines\n        if self.rows != self.cols:\n            raise NonSquareMatrixError()\n\n        n = self.rows\n        if n == 0:\n            return S.One\n        elif n == 1:\n            return self[0,0]\n        elif n == 2:\n            return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n        elif n == 3:\n            return  (self[0, 0] * self[1, 1] * self[2, 2]\n                   + self[0, 1] * self[1, 2] * self[2, 0]\n                   + self[0, 2] * self[1, 0] * self[2, 1]\n                   - self[0, 2] * self[1, 1] * self[2, 0]\n                   - self[0, 0] * self[1, 2] * self[2, 1]\n                   - self[0, 1] * self[1, 0] * self[2, 2])\n\n        # Use intelligent algorithm selection for default \"bareiss\"\n        if method == \"bareiss\" and self.is_symbolic():\n            method = \"berkowitz\"\n\n        if method == \"bareiss\":\n            return self._eval_det_bareiss()\n        elif method == \"berkowitz\":\n            return self._eval_det_berkowitz()\n        elif method == \"lu\":\n            return self._eval_det_lu()\n",
    "Location 2 (/root/hy/projects/sympy/sympy/matrices/matrices.py lines 208-212)": "\n            def entry(i, j):\n                ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n                if not ret.is_Atom and not ret.has(Symbol):\n                    cancel(ret)\n                return ret\n",
    "Location 3 (/root/hy/projects/sympy/sympy/matrices/matrices.py lines 216-216)": "\n        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n",
    "Location 4 (/root/hy/projects/sympy/sympy/core/exprtools.py lines 1179-1179)": "\n            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].has(S.NaN)):\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/matrices/matrices.py lines 383-430)": [
      "\n    def det(self, method=\"auto\"):\n        \"\"\"Computes the determinant of a matrix.  If the matrix\n        is at most 3x3, a hard-coded formula is used.\n        Otherwise, the determinant using the method `method`.\n\n\n        Possible values for \"method\":\n          auto (default) - automatically selects best method based on matrix content\n          bareiss - for integer/rational matrices (default for non-symbolic)\n          berkowitz - for symbolic matrices (default for symbolic)\n          lu\n        \"\"\"\n\n        # sanitize `method`\n        method = method.lower()\n        if method == \"bareis\":\n            method = \"bareiss\"\n        if method == \"det_lu\":\n            method = \"lu\"\n        \n        # Auto-select method based on matrix content\n        if method == \"auto\":\n            if self.is_symbolic():\n                method = \"berkowitz\"\n            else:\n                method = \"bareiss\"\n        \n        if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n            raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n\n        # if methods were made internal and all determinant calculations\n        # passed through here, then these lines could be factored out of\n        # the method routines\n        if self.rows != self.cols:\n            raise NonSquareMatrixError()\n\n        n = self.rows\n        if n == 0:\n            return S.One\n        elif n == 1:\n            return self[0,0]\n        elif n == 2:\n            return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n        elif n == 3:\n            return  (self[0, 0] * self[1, 1] * self[2, 2]\n                   + self[0, 1] * self[1, 2] * self[2, 0]\n                   + self[0, 2] * self[1, 0] * self[2, 1]\n                   - self[0, 2] * self[1, 1] * self[2, 0]\n                   - self[0, 0] * self[1, 2] * self[2, 1]\n                   - self[0, 1] * self[1, 0] * self[2, 2])\n\n        if method == \"bareiss\":\n            return self._eval_det_bareiss()\n        elif method == \"berkowitz\":\n            return self._eval_det_berkowitz()\n        elif method == \"lu\":\n            return self._eval_det_lu()\n",
      "\n    def det(self, method=\"bareiss\"):\n        \"\"\"Computes the determinant of a matrix.  If the matrix\n        is at most 3x3, a hard-coded formula is used.\n        Otherwise, the determinant using the method `method`.\n\n\n        Possible values for \"method\":\n          bareis\n          berkowitz\n          lu\n        \"\"\"\n\n        # sanitize `method`\n        method = method.lower()\n        if method == \"bareis\":\n            method = \"bareiss\"\n        if method == \"det_lu\":\n            method = \"lu\"\n        if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n            raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n\n        # if methods were made internal and all determinant calculations\n        # passed through here, then these lines could be factored out of\n        # the method routines\n        if self.rows != self.cols:\n            raise NonSquareMatrixError()\n\n        n = self.rows\n        if n == 0:\n            return S.One\n        elif n == 1:\n            return self[0,0]\n        elif n == 2:\n            return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n        elif n == 3:\n            return  (self[0, 0] * self[1, 1] * self[2, 2]\n                   + self[0, 1] * self[1, 2] * self[2, 0]\n                   + self[0, 2] * self[1, 0] * self[2, 1]\n                   - self[0, 2] * self[1, 1] * self[2, 0]\n                   - self[0, 0] * self[1, 2] * self[2, 1]\n                   - self[0, 1] * self[1, 0] * self[2, 2])\n\n        # Use intelligent method selection for default \"bareiss\"\n        if method == \"bareiss\" and self.is_symbolic():\n            method = \"berkowitz\"\n\n        if method == \"bareiss\":\n            return self._eval_det_bareiss()\n        elif method == \"berkowitz\":\n            return self._eval_det_berkowitz()\n        elif method == \"lu\":\n            return self._eval_det_lu()\n",
      "\n    def det(self, method=\"auto\"):\n        \"\"\"Computes the determinant of a matrix.  If the matrix\n        is at most 3x3, a hard-coded formula is used.\n        Otherwise, the determinant using the method `method`.\n\n\n        Possible values for \"method\":\n          auto (default) - automatically selects appropriate method\n          bareis\n          berkowitz\n          lu\n        \"\"\"\n\n        # sanitize `method`\n        method = method.lower()\n        if method == \"bareis\":\n            method = \"bareiss\"\n        if method == \"det_lu\":\n            method = \"lu\"\n        \n        # Auto-select method based on matrix content\n        if method == \"auto\":\n            if self.is_symbolic():\n                method = \"berkowitz\"  # Better for symbolic matrices\n            else:\n                method = \"bareiss\"    # Efficient for numeric matrices\n        \n        if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n            raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n\n        # if methods were made internal and all determinant calculations\n        # passed through here, then these lines could be factored out of\n        # the method routines\n        if self.rows != self.cols:\n            raise NonSquareMatrixError()\n\n        n = self.rows\n        if n == 0:\n            return S.One\n        elif n == 1:\n            return self[0,0]\n        elif n == 2:\n            return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n        elif n == 3:\n            return  (self[0, 0] * self[1, 1] * self[2, 2]\n                   + self[0, 1] * self[1, 2] * self[2, 0]\n                   + self[0, 2] * self[1, 0] * self[2, 1]\n                   - self[0, 2] * self[1, 1] * self[2, 0]\n                   - self[0, 0] * self[1, 2] * self[2, 1]\n                   - self[0, 1] * self[1, 0] * self[2, 2])\n\n        if method == \"bareiss\":\n            return self._eval_det_bareiss()\n        elif method == \"berkowitz\":\n            return self._eval_det_berkowitz()\n        elif method == \"lu\":\n            return self._eval_det_lu()\n",
      "\n    def det(self, method=\"bareiss\"):\n        \"\"\"Computes the determinant of a matrix.  If the matrix\n        is at most 3x3, a hard-coded formula is used.\n        Otherwise, the determinant using the method `method`.\n\n\n        Possible values for \"method\":\n          bareis\n          berkowitz\n          lu\n        \"\"\"\n\n        # sanitize `method`\n        method = method.lower()\n        if method == \"bareis\":\n            method = \"bareiss\"\n        if method == \"det_lu\":\n            method = \"lu\"\n        if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n            raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n\n        # if methods were made internal and all determinant calculations\n        # passed through here, then these lines could be factored out of\n        # the method routines\n        if self.rows != self.cols:\n            raise NonSquareMatrixError()\n\n        n = self.rows\n        if n == 0:\n            return S.One\n        elif n == 1:\n            return self[0,0]\n        elif n == 2:\n            return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n        elif n == 3:\n            return  (self[0, 0] * self[1, 1] * self[2, 2]\n                   + self[0, 1] * self[1, 2] * self[2, 0]\n                   + self[0, 2] * self[1, 0] * self[2, 1]\n                   - self[0, 2] * self[1, 1] * self[2, 0]\n                   - self[0, 0] * self[1, 2] * self[2, 1]\n                   - self[0, 1] * self[1, 0] * self[2, 2])\n\n        # Use berkowitz for symbolic matrices, bareiss for numeric matrices\n        if method == \"bareiss\":\n            if self.is_symbolic():\n                method = \"berkowitz\"\n\n        if method == \"bareiss\":\n            return self._eval_det_bareiss()\n        elif method == \"berkowitz\":\n            return self._eval_det_berkowitz()\n        elif method == \"lu\":\n            return self._eval_det_lu()\n",
      "\ndef det(self, method=\"auto\"):\n    \"\"\"Computes the determinant of a matrix.  If the matrix\n    is at most 3x3, a hard-coded formula is used.\n    Otherwise, the determinant using the method `method`.\n\n\n    Possible values for \"method\":\n      bareiss\n      berkowitz\n      lu\n      auto (default) - automatically selects best method\n    \"\"\"\n\n    # sanitize `method`\n    method = method.lower()\n    if method == \"bareis\":\n        method = \"bareiss\"\n    if method == \"det_lu\":\n        method = \"lu\"\n    \n    # Auto-select method based on matrix content\n    if method == \"auto\":\n        if self.is_symbolic():\n            method = \"berkowitz\"\n        else:\n            method = \"bareiss\"\n    \n    if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n        raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n\n    # if methods were made internal and all determinant calculations\n    # passed through here, then these lines could be factored out of\n    # the method routines\n    if self.rows != self.cols:\n        raise NonSquareMatrixError()\n\n    n = self.rows\n    if n == 0:\n        return S.One\n    elif n == 1:\n        return self[0,0]\n    elif n == 2:\n        return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n    elif n == 3:\n        return  (self[0, 0] * self[1, 1] * self[2, 2]\n               + self[0, 1] * self[1, 2] * self[2, 0]\n               + self[0, 2] * self[1, 0] * self[2, 1]\n               - self[0, 2] * self[1, 1] * self[2, 0]\n               - self[0, 0] * self[1, 2] * self[2, 1]\n               - self[0, 1] * self[1, 0] * self[2, 2])\n\n    if method == \"bareiss\":\n        return self._eval_det_bareiss()\n    elif method == \"berkowitz\":\n        return self._eval_det_berkowitz()\n    elif method == \"lu\":\n        return self._eval_det_lu()\n",
      "\n    def det(self, method=\"bareiss\"):\n        \"\"\"Computes the determinant of a matrix.  If the matrix\n        is at most 3x3, a hard-coded formula is used.\n        Otherwise, the determinant using the method `method`.\n\n\n        Possible values for \"method\":\n          bareis\n          berkowitz\n          lu\n        \"\"\"\n\n        # sanitize `method`\n        method = method.lower()\n        if method == \"bareis\":\n            method = \"bareiss\"\n        if method == \"det_lu\":\n            method = \"lu\"\n        if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n            raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n\n        # if methods were made internal and all determinant calculations\n        # passed through here, then these lines could be factored out of\n        # the method routines\n        if self.rows != self.cols:\n            raise NonSquareMatrixError()\n\n        n = self.rows\n        if n == 0:\n            return S.One\n        elif n == 1:\n            return self[0,0]\n        elif n == 2:\n            return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n        elif n == 3:\n            return  (self[0, 0] * self[1, 1] * self[2, 2]\n                   + self[0, 1] * self[1, 2] * self[2, 0]\n                   + self[0, 2] * self[1, 0] * self[2, 1]\n                   - self[0, 2] * self[1, 1] * self[2, 0]\n                   - self[0, 0] * self[1, 2] * self[2, 1]\n                   - self[0, 1] * self[1, 0] * self[2, 2])\n\n        # Use berkowitz for symbolic matrices as bareiss can cause issues\n        if method == \"bareiss\" and self.is_symbolic():\n            method = \"berkowitz\"\n\n        if method == \"bareiss\":\n            return self._eval_det_bareiss()\n        elif method == \"berkowitz\":\n            return self._eval_det_berkowitz()\n        elif method == \"lu\":\n            return self._eval_det_lu()\n",
      "\n    def det(self, method=\"auto\"):\n        \"\"\"Computes the determinant of a matrix.  If the matrix\n        is at most 3x3, a hard-coded formula is used.\n        Otherwise, the determinant using the method `method`.\n\n\n        Possible values for \"method\":\n          auto (default) - automatically choose based on matrix type\n          bareiss - for integer/rational matrices\n          berkowitz - for symbolic matrices\n          lu\n        \"\"\"\n\n        # sanitize `method`\n        method = method.lower()\n        if method == \"bareis\":\n            method = \"bareiss\"\n        if method == \"det_lu\":\n            method = \"lu\"\n        \n        # Auto-select method based on matrix content\n        if method == \"auto\":\n            if self.is_symbolic():\n                method = \"berkowitz\"\n            else:\n                method = \"bareiss\"\n        \n        if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n            raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n\n        # if methods were made internal and all determinant calculations\n        # passed through here, then these lines could be factored out of\n        # the method routines\n        if self.rows != self.cols:\n            raise NonSquareMatrixError()\n\n        n = self.rows\n        if n == 0:\n            return S.One\n        elif n == 1:\n            return self[0,0]\n        elif n == 2:\n            return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n        elif n == 3:\n            return  (self[0, 0] * self[1, 1] * self[2, 2]\n                   + self[0, 1] * self[1, 2] * self[2, 0]\n                   + self[0, 2] * self[1, 0] * self[2, 1]\n                   - self[0, 2] * self[1, 1] * self[2, 0]\n                   - self[0, 0] * self[1, 2] * self[2, 1]\n                   - self[0, 1] * self[1, 0] * self[2, 2])\n\n        if method == \"bareiss\":\n            return self._eval_det_bareiss()\n        elif method == \"berkowitz\":\n            return self._eval_det_berkowitz()\n        elif method == \"lu\":\n            return self._eval_det_lu()\n",
      "\n    def det(self, method=\"bareiss\"):\n        \"\"\"Computes the determinant of a matrix.  If the matrix\n        is at most 3x3, a hard-coded formula is used.\n        Otherwise, the determinant using the method `method`.\n\n\n        Possible values for \"method\":\n          bareis\n          berkowitz\n          lu\n        \"\"\"\n\n        # sanitize `method`\n        method = method.lower()\n        if method == \"bareis\":\n            method = \"bareiss\"\n        if method == \"det_lu\":\n            method = \"lu\"\n        if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n            raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n\n        # if methods were made internal and all determinant calculations\n        # passed through here, then these lines could be factored out of\n        # the method routines\n        if self.rows != self.cols:\n            raise NonSquareMatrixError()\n\n        n = self.rows\n        if n == 0:\n            return S.One\n        elif n == 1:\n            return self[0,0]\n        elif n == 2:\n            return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n        elif n == 3:\n            return  (self[0, 0] * self[1, 1] * self[2, 2]\n                   + self[0, 1] * self[1, 2] * self[2, 0]\n                   + self[0, 2] * self[1, 0] * self[2, 1]\n                   - self[0, 2] * self[1, 1] * self[2, 0]\n                   - self[0, 0] * self[1, 2] * self[2, 1]\n                   - self[0, 1] * self[1, 0] * self[2, 2])\n\n        # Choose appropriate method based on matrix content\n        if method == \"bareiss\":\n            # Bareiss is designed for integer matrices; use berkowitz for symbolic matrices\n            if self.is_symbolic():\n                method = \"berkowitz\"\n\n        if method == \"bareiss\":\n            return self._eval_det_bareiss()\n        elif method == \"berkowitz\":\n            return self._eval_det_berkowitz()\n        elif method == \"lu\":\n            return self._eval_det_lu()\n"
    ],
    "Location 2 (/root/hy/projects/sympy/sympy/matrices/matrices.py lines 208-212)": [
      "\n        def entry(i, j):\n            ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n            if not ret.is_Atom and not ret.has(Symbol):\n                cancel(ret)\n            return ret\n",
      "\n            def entry(i, j):\n                ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n                if not ret.is_Atom and not ret.has(Symbol):\n                    cancel(ret)\n                return ret\n",
      "\n            def entry(i, j):\n                ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n                if not ret.is_Atom and not ret.has(Symbol):\n                    cancel(ret)\n                return ret\n",
      "\n            def entry(i, j):\n                ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n                if not ret.is_Atom and not ret.has(Symbol):\n                    cancel(ret)\n                return ret\n",
      "\n            def entry(i, j):\n                ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n                if not ret.is_Atom and not ret.has(Symbol):\n                    cancel(ret)\n                return ret\n",
      "\n            def entry(i, j):\n                ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n                if not ret.is_Atom and not ret.has(Symbol):\n                    cancel(ret)\n                return ret\n",
      "\n            def entry(i, j):\n                ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n                if not ret.is_Atom and not ret.has(Symbol):\n                    cancel(ret)\n                return ret\n",
      "\n            def entry(i, j):\n                ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n                if not ret.is_Atom and not ret.has(Symbol):\n                    cancel(ret)\n                return ret\n"
    ],
    "Location 3 (/root/hy/projects/sympy/sympy/matrices/matrices.py lines 216-216)": [
      "\n        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n",
      "\n        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n",
      "\n        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n",
      "\n        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n",
      "\n        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n",
      "\n        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n",
      "\n        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n",
      "\n        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n"
    ],
    "Location 4 (/root/hy/projects/sympy/sympy/core/exprtools.py lines 1179-1179)": [
      "\n            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n",
      "\n            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n",
      "\n            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n",
      "\n            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_NaN):\n",
      "\n            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n",
      "\n            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n",
      "\n            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n",
      "\n            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\nindex 4e0de9ec18..0f4f7cd280 100644\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -1176,7 +1176,14 @@ def do(expr):\n         if p.is_Add:\n             list_args = [do(a) for a in Add.make_args(p)]\n             # get a common negative (if there) which gcd_terms does not remove\n-            if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+\n+            try:\n+                if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+                    cont = -cont\n+                    list_args = [-a for a in list_args]\n+            except TypeError:\n+                # Handle \"Invalid NaN comparison\" for symbolic expressions\n+                pass\n                 cont = -cont\n                 list_args = [-a for a in list_args]\n             # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\ndiff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 97cde62e26..06818708e8 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -205,15 +205,20 @@ def bareiss(mat, cumm=1):\n             cols = list(range(mat.cols))\n             tmp_mat = mat.extract(rows, cols)\n \n+\n             def entry(i, j):\n                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n+                if not ret.is_Atom and not ret.has(Symbol):\n                     cancel(ret)\n                 return ret\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+\n+        if self.is_symbolic():\n+            return bareiss(self)\n+        else:\n+            return cancel(bareiss(self))\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n@@ -380,6 +385,7 @@ def cofactor_matrix(self, method=\"berkowitz\"):\n         return self._new(self.rows, self.cols,\n                          lambda i, j: self.cofactor(i, j, method))\n \n+\n     def det(self, method=\"bareiss\"):\n         \"\"\"Computes the determinant of a matrix.  If the matrix\n         is at most 3x3, a hard-coded formula is used.\n@@ -422,8 +428,14 @@ def det(self, method=\"bareiss\"):\n                    - self[0, 0] * self[1, 2] * self[2, 1]\n                    - self[0, 1] * self[1, 0] * self[2, 2])\n \n+        # Use intelligent algorithm selection for default case\n         if method == \"bareiss\":\n-            return self._eval_det_bareiss()\n+            # Bareiss algorithm is designed for integer matrices\n+            # Use berkowitz for symbolic matrices to avoid NaN comparison errors\n+            if self.is_symbolic():\n+                return self._eval_det_berkowitz()\n+            else:\n+                return self._eval_det_bareiss()\n         elif method == \"berkowitz\":\n             return self._eval_det_berkowitz()\n         elif method == \"lu\":\n",
    "variant_0": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\nindex 4e0de9ec18..9bab1ae284 100644\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -1176,7 +1176,8 @@ def do(expr):\n         if p.is_Add:\n             list_args = [do(a) for a in Add.make_args(p)]\n             # get a common negative (if there) which gcd_terms does not remove\n-            if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+\n+            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].has(S.NaN)):\n                 cont = -cont\n                 list_args = [-a for a in list_args]\n             # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\ndiff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 97cde62e26..3bd13040aa 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -205,15 +205,17 @@ def bareiss(mat, cumm=1):\n             cols = list(range(mat.cols))\n             tmp_mat = mat.extract(rows, cols)\n \n+\n             def entry(i, j):\n                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n+                if not ret.is_Atom and not ret.has(Symbol):\n                     cancel(ret)\n                 return ret\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+\n+        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n@@ -380,6 +382,7 @@ def cofactor_matrix(self, method=\"berkowitz\"):\n         return self._new(self.rows, self.cols,\n                          lambda i, j: self.cofactor(i, j, method))\n \n+\n     def det(self, method=\"bareiss\"):\n         \"\"\"Computes the determinant of a matrix.  If the matrix\n         is at most 3x3, a hard-coded formula is used.\n@@ -422,6 +425,10 @@ def det(self, method=\"bareiss\"):\n                    - self[0, 0] * self[1, 2] * self[2, 1]\n                    - self[0, 1] * self[1, 0] * self[2, 2])\n \n+        # Use intelligent algorithm selection for default \"bareiss\"\n+        if method == \"bareiss\" and self.is_symbolic():\n+            method = \"berkowitz\"\n+\n         if method == \"bareiss\":\n             return self._eval_det_bareiss()\n         elif method == \"berkowitz\":\n",
    "variant_1": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\nindex 4e0de9ec18..feef6a9f39 100644\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -1176,7 +1176,8 @@ def do(expr):\n         if p.is_Add:\n             list_args = [do(a) for a in Add.make_args(p)]\n             # get a common negative (if there) which gcd_terms does not remove\n-            if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+\n+            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n                 cont = -cont\n                 list_args = [-a for a in list_args]\n             # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\ndiff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 97cde62e26..c177a500a3 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -205,15 +205,17 @@ def bareiss(mat, cumm=1):\n             cols = list(range(mat.cols))\n             tmp_mat = mat.extract(rows, cols)\n \n-            def entry(i, j):\n-                ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n-                    cancel(ret)\n-                return ret\n+\n+        def entry(i, j):\n+            ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n+            if not ret.is_Atom and not ret.has(Symbol):\n+                cancel(ret)\n+            return ret\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+\n+        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n@@ -380,15 +382,17 @@ def cofactor_matrix(self, method=\"berkowitz\"):\n         return self._new(self.rows, self.cols,\n                          lambda i, j: self.cofactor(i, j, method))\n \n-    def det(self, method=\"bareiss\"):\n+\n+    def det(self, method=\"auto\"):\n         \"\"\"Computes the determinant of a matrix.  If the matrix\n         is at most 3x3, a hard-coded formula is used.\n         Otherwise, the determinant using the method `method`.\n \n \n         Possible values for \"method\":\n-          bareis\n-          berkowitz\n+          auto (default) - automatically selects best method based on matrix content\n+          bareiss - for integer/rational matrices (default for non-symbolic)\n+          berkowitz - for symbolic matrices (default for symbolic)\n           lu\n         \"\"\"\n \n@@ -398,6 +402,14 @@ def det(self, method=\"bareiss\"):\n             method = \"bareiss\"\n         if method == \"det_lu\":\n             method = \"lu\"\n+        \n+        # Auto-select method based on matrix content\n+        if method == \"auto\":\n+            if self.is_symbolic():\n+                method = \"berkowitz\"\n+            else:\n+                method = \"bareiss\"\n+        \n         if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n             raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n \n",
    "variant_2": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\nindex 4e0de9ec18..feef6a9f39 100644\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -1176,7 +1176,8 @@ def do(expr):\n         if p.is_Add:\n             list_args = [do(a) for a in Add.make_args(p)]\n             # get a common negative (if there) which gcd_terms does not remove\n-            if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+\n+            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n                 cont = -cont\n                 list_args = [-a for a in list_args]\n             # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\ndiff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 97cde62e26..acf2c2359b 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -205,15 +205,17 @@ def bareiss(mat, cumm=1):\n             cols = list(range(mat.cols))\n             tmp_mat = mat.extract(rows, cols)\n \n+\n             def entry(i, j):\n                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n+                if not ret.is_Atom and not ret.has(Symbol):\n                     cancel(ret)\n                 return ret\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+\n+        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n@@ -380,6 +382,7 @@ def cofactor_matrix(self, method=\"berkowitz\"):\n         return self._new(self.rows, self.cols,\n                          lambda i, j: self.cofactor(i, j, method))\n \n+\n     def det(self, method=\"bareiss\"):\n         \"\"\"Computes the determinant of a matrix.  If the matrix\n         is at most 3x3, a hard-coded formula is used.\n@@ -422,6 +425,10 @@ def det(self, method=\"bareiss\"):\n                    - self[0, 0] * self[1, 2] * self[2, 1]\n                    - self[0, 1] * self[1, 0] * self[2, 2])\n \n+        # Use intelligent method selection for default \"bareiss\"\n+        if method == \"bareiss\" and self.is_symbolic():\n+            method = \"berkowitz\"\n+\n         if method == \"bareiss\":\n             return self._eval_det_bareiss()\n         elif method == \"berkowitz\":\n",
    "variant_3": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\nindex 4e0de9ec18..feef6a9f39 100644\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -1176,7 +1176,8 @@ def do(expr):\n         if p.is_Add:\n             list_args = [do(a) for a in Add.make_args(p)]\n             # get a common negative (if there) which gcd_terms does not remove\n-            if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+\n+            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n                 cont = -cont\n                 list_args = [-a for a in list_args]\n             # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\ndiff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 97cde62e26..296fb9497e 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -205,15 +205,17 @@ def bareiss(mat, cumm=1):\n             cols = list(range(mat.cols))\n             tmp_mat = mat.extract(rows, cols)\n \n+\n             def entry(i, j):\n                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n+                if not ret.is_Atom and not ret.has(Symbol):\n                     cancel(ret)\n                 return ret\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+\n+        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n@@ -380,13 +382,15 @@ def cofactor_matrix(self, method=\"berkowitz\"):\n         return self._new(self.rows, self.cols,\n                          lambda i, j: self.cofactor(i, j, method))\n \n-    def det(self, method=\"bareiss\"):\n+\n+    def det(self, method=\"auto\"):\n         \"\"\"Computes the determinant of a matrix.  If the matrix\n         is at most 3x3, a hard-coded formula is used.\n         Otherwise, the determinant using the method `method`.\n \n \n         Possible values for \"method\":\n+          auto (default) - automatically selects appropriate method\n           bareis\n           berkowitz\n           lu\n@@ -398,6 +402,14 @@ def det(self, method=\"bareiss\"):\n             method = \"bareiss\"\n         if method == \"det_lu\":\n             method = \"lu\"\n+        \n+        # Auto-select method based on matrix content\n+        if method == \"auto\":\n+            if self.is_symbolic():\n+                method = \"berkowitz\"  # Better for symbolic matrices\n+            else:\n+                method = \"bareiss\"    # Efficient for numeric matrices\n+        \n         if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n             raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n \n",
    "variant_4": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\nindex 4e0de9ec18..1d0e782846 100644\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -1176,7 +1176,8 @@ def do(expr):\n         if p.is_Add:\n             list_args = [do(a) for a in Add.make_args(p)]\n             # get a common negative (if there) which gcd_terms does not remove\n-            if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+\n+            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_NaN):\n                 cont = -cont\n                 list_args = [-a for a in list_args]\n             # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\ndiff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 97cde62e26..03047f4b3b 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -205,15 +205,17 @@ def bareiss(mat, cumm=1):\n             cols = list(range(mat.cols))\n             tmp_mat = mat.extract(rows, cols)\n \n+\n             def entry(i, j):\n                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n+                if not ret.is_Atom and not ret.has(Symbol):\n                     cancel(ret)\n                 return ret\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+\n+        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n@@ -380,6 +382,7 @@ def cofactor_matrix(self, method=\"berkowitz\"):\n         return self._new(self.rows, self.cols,\n                          lambda i, j: self.cofactor(i, j, method))\n \n+\n     def det(self, method=\"bareiss\"):\n         \"\"\"Computes the determinant of a matrix.  If the matrix\n         is at most 3x3, a hard-coded formula is used.\n@@ -422,6 +425,11 @@ def det(self, method=\"bareiss\"):\n                    - self[0, 0] * self[1, 2] * self[2, 1]\n                    - self[0, 1] * self[1, 0] * self[2, 2])\n \n+        # Use berkowitz for symbolic matrices, bareiss for numeric matrices\n+        if method == \"bareiss\":\n+            if self.is_symbolic():\n+                method = \"berkowitz\"\n+\n         if method == \"bareiss\":\n             return self._eval_det_bareiss()\n         elif method == \"berkowitz\":\n",
    "variant_5": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\nindex 4e0de9ec18..feef6a9f39 100644\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -1176,7 +1176,8 @@ def do(expr):\n         if p.is_Add:\n             list_args = [do(a) for a in Add.make_args(p)]\n             # get a common negative (if there) which gcd_terms does not remove\n-            if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+\n+            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n                 cont = -cont\n                 list_args = [-a for a in list_args]\n             # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\ndiff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 97cde62e26..21ad4f2dad 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -205,15 +205,17 @@ def bareiss(mat, cumm=1):\n             cols = list(range(mat.cols))\n             tmp_mat = mat.extract(rows, cols)\n \n+\n             def entry(i, j):\n                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n+                if not ret.is_Atom and not ret.has(Symbol):\n                     cancel(ret)\n                 return ret\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+\n+        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n@@ -380,54 +382,64 @@ def cofactor_matrix(self, method=\"berkowitz\"):\n         return self._new(self.rows, self.cols,\n                          lambda i, j: self.cofactor(i, j, method))\n \n-    def det(self, method=\"bareiss\"):\n-        \"\"\"Computes the determinant of a matrix.  If the matrix\n-        is at most 3x3, a hard-coded formula is used.\n-        Otherwise, the determinant using the method `method`.\n \n+def det(self, method=\"auto\"):\n+    \"\"\"Computes the determinant of a matrix.  If the matrix\n+    is at most 3x3, a hard-coded formula is used.\n+    Otherwise, the determinant using the method `method`.\n \n-        Possible values for \"method\":\n-          bareis\n-          berkowitz\n-          lu\n-        \"\"\"\n \n-        # sanitize `method`\n-        method = method.lower()\n-        if method == \"bareis\":\n-            method = \"bareiss\"\n-        if method == \"det_lu\":\n-            method = \"lu\"\n-        if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n-            raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n-\n-        # if methods were made internal and all determinant calculations\n-        # passed through here, then these lines could be factored out of\n-        # the method routines\n-        if self.rows != self.cols:\n-            raise NonSquareMatrixError()\n+    Possible values for \"method\":\n+      bareiss\n+      berkowitz\n+      lu\n+      auto (default) - automatically selects best method\n+    \"\"\"\n \n-        n = self.rows\n-        if n == 0:\n-            return S.One\n-        elif n == 1:\n-            return self[0,0]\n-        elif n == 2:\n-            return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n-        elif n == 3:\n-            return  (self[0, 0] * self[1, 1] * self[2, 2]\n-                   + self[0, 1] * self[1, 2] * self[2, 0]\n-                   + self[0, 2] * self[1, 0] * self[2, 1]\n-                   - self[0, 2] * self[1, 1] * self[2, 0]\n-                   - self[0, 0] * self[1, 2] * self[2, 1]\n-                   - self[0, 1] * self[1, 0] * self[2, 2])\n-\n-        if method == \"bareiss\":\n-            return self._eval_det_bareiss()\n-        elif method == \"berkowitz\":\n-            return self._eval_det_berkowitz()\n-        elif method == \"lu\":\n-            return self._eval_det_lu()\n+    # sanitize `method`\n+    method = method.lower()\n+    if method == \"bareis\":\n+        method = \"bareiss\"\n+    if method == \"det_lu\":\n+        method = \"lu\"\n+    \n+    # Auto-select method based on matrix content\n+    if method == \"auto\":\n+        if self.is_symbolic():\n+            method = \"berkowitz\"\n+        else:\n+            method = \"bareiss\"\n+    \n+    if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n+        raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n+\n+    # if methods were made internal and all determinant calculations\n+    # passed through here, then these lines could be factored out of\n+    # the method routines\n+    if self.rows != self.cols:\n+        raise NonSquareMatrixError()\n+\n+    n = self.rows\n+    if n == 0:\n+        return S.One\n+    elif n == 1:\n+        return self[0,0]\n+    elif n == 2:\n+        return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n+    elif n == 3:\n+        return  (self[0, 0] * self[1, 1] * self[2, 2]\n+               + self[0, 1] * self[1, 2] * self[2, 0]\n+               + self[0, 2] * self[1, 0] * self[2, 1]\n+               - self[0, 2] * self[1, 1] * self[2, 0]\n+               - self[0, 0] * self[1, 2] * self[2, 1]\n+               - self[0, 1] * self[1, 0] * self[2, 2])\n+\n+    if method == \"bareiss\":\n+        return self._eval_det_bareiss()\n+    elif method == \"berkowitz\":\n+        return self._eval_det_berkowitz()\n+    elif method == \"lu\":\n+        return self._eval_det_lu()\n \n     def minor(self, i, j, method=\"berkowitz\"):\n         \"\"\"Return the (i,j) minor of `self`.  That is,\n",
    "variant_6": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\nindex 4e0de9ec18..feef6a9f39 100644\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -1176,7 +1176,8 @@ def do(expr):\n         if p.is_Add:\n             list_args = [do(a) for a in Add.make_args(p)]\n             # get a common negative (if there) which gcd_terms does not remove\n-            if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+\n+            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n                 cont = -cont\n                 list_args = [-a for a in list_args]\n             # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\ndiff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 97cde62e26..4b99914a3f 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -205,15 +205,17 @@ def bareiss(mat, cumm=1):\n             cols = list(range(mat.cols))\n             tmp_mat = mat.extract(rows, cols)\n \n+\n             def entry(i, j):\n                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n+                if not ret.is_Atom and not ret.has(Symbol):\n                     cancel(ret)\n                 return ret\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+\n+        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n@@ -380,6 +382,7 @@ def cofactor_matrix(self, method=\"berkowitz\"):\n         return self._new(self.rows, self.cols,\n                          lambda i, j: self.cofactor(i, j, method))\n \n+\n     def det(self, method=\"bareiss\"):\n         \"\"\"Computes the determinant of a matrix.  If the matrix\n         is at most 3x3, a hard-coded formula is used.\n@@ -422,6 +425,10 @@ def det(self, method=\"bareiss\"):\n                    - self[0, 0] * self[1, 2] * self[2, 1]\n                    - self[0, 1] * self[1, 0] * self[2, 2])\n \n+        # Use berkowitz for symbolic matrices as bareiss can cause issues\n+        if method == \"bareiss\" and self.is_symbolic():\n+            method = \"berkowitz\"\n+\n         if method == \"bareiss\":\n             return self._eval_det_bareiss()\n         elif method == \"berkowitz\":\n",
    "variant_7": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\nindex 4e0de9ec18..feef6a9f39 100644\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -1176,7 +1176,8 @@ def do(expr):\n         if p.is_Add:\n             list_args = [do(a) for a in Add.make_args(p)]\n             # get a common negative (if there) which gcd_terms does not remove\n-            if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+\n+            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n                 cont = -cont\n                 list_args = [-a for a in list_args]\n             # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\ndiff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 97cde62e26..9ee4768095 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -205,15 +205,17 @@ def bareiss(mat, cumm=1):\n             cols = list(range(mat.cols))\n             tmp_mat = mat.extract(rows, cols)\n \n+\n             def entry(i, j):\n                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n+                if not ret.is_Atom and not ret.has(Symbol):\n                     cancel(ret)\n                 return ret\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+\n+        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n@@ -380,15 +382,17 @@ def cofactor_matrix(self, method=\"berkowitz\"):\n         return self._new(self.rows, self.cols,\n                          lambda i, j: self.cofactor(i, j, method))\n \n-    def det(self, method=\"bareiss\"):\n+\n+    def det(self, method=\"auto\"):\n         \"\"\"Computes the determinant of a matrix.  If the matrix\n         is at most 3x3, a hard-coded formula is used.\n         Otherwise, the determinant using the method `method`.\n \n \n         Possible values for \"method\":\n-          bareis\n-          berkowitz\n+          auto (default) - automatically choose based on matrix type\n+          bareiss - for integer/rational matrices\n+          berkowitz - for symbolic matrices\n           lu\n         \"\"\"\n \n@@ -398,6 +402,14 @@ def det(self, method=\"bareiss\"):\n             method = \"bareiss\"\n         if method == \"det_lu\":\n             method = \"lu\"\n+        \n+        # Auto-select method based on matrix content\n+        if method == \"auto\":\n+            if self.is_symbolic():\n+                method = \"berkowitz\"\n+            else:\n+                method = \"bareiss\"\n+        \n         if method not in (\"bareiss\", \"berkowitz\", \"lu\"):\n             raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n \n",
    "variant_8": "diff --git a/sympy/core/exprtools.py b/sympy/core/exprtools.py\nindex 4e0de9ec18..feef6a9f39 100644\n--- a/sympy/core/exprtools.py\n+++ b/sympy/core/exprtools.py\n@@ -1176,7 +1176,8 @@ def do(expr):\n         if p.is_Add:\n             list_args = [do(a) for a in Add.make_args(p)]\n             # get a common negative (if there) which gcd_terms does not remove\n-            if all(a.as_coeff_Mul()[0] < 0 for a in list_args):\n+\n+            if all(a.as_coeff_Mul()[0] < 0 for a in list_args if not a.as_coeff_Mul()[0].is_nan):\n                 cont = -cont\n                 list_args = [-a for a in list_args]\n             # watch out for exp(-(x+2)) which gcd_terms will change to exp(-x-2)\ndiff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py\nindex 97cde62e26..11e2eb6bf6 100644\n--- a/sympy/matrices/matrices.py\n+++ b/sympy/matrices/matrices.py\n@@ -205,15 +205,17 @@ def bareiss(mat, cumm=1):\n             cols = list(range(mat.cols))\n             tmp_mat = mat.extract(rows, cols)\n \n+\n             def entry(i, j):\n                 ret = (pivot_val*tmp_mat[i, j + 1] - mat[pivot_pos, j + 1]*tmp_mat[i, 0]) / cumm\n-                if not ret.is_Atom:\n+                if not ret.is_Atom and not ret.has(Symbol):\n                     cancel(ret)\n                 return ret\n \n             return sign*bareiss(self._new(mat.rows - 1, mat.cols - 1, entry), pivot_val)\n \n-        return cancel(bareiss(self))\n+\n+        return cancel(bareiss(self)) if not self.is_symbolic() else bareiss(self)\n \n     def _eval_det_berkowitz(self):\n         \"\"\" Use the Berkowitz algorithm to compute the determinant.\"\"\"\n@@ -380,6 +382,7 @@ def cofactor_matrix(self, method=\"berkowitz\"):\n         return self._new(self.rows, self.cols,\n                          lambda i, j: self.cofactor(i, j, method))\n \n+\n     def det(self, method=\"bareiss\"):\n         \"\"\"Computes the determinant of a matrix.  If the matrix\n         is at most 3x3, a hard-coded formula is used.\n@@ -422,6 +425,12 @@ def det(self, method=\"bareiss\"):\n                    - self[0, 0] * self[1, 2] * self[2, 1]\n                    - self[0, 1] * self[1, 0] * self[2, 2])\n \n+        # Choose appropriate method based on matrix content\n+        if method == \"bareiss\":\n+            # Bareiss is designed for integer matrices; use berkowitz for symbolic matrices\n+            if self.is_symbolic():\n+                method = \"berkowitz\"\n+\n         if method == \"bareiss\":\n             return self._eval_det_bareiss()\n         elif method == \"berkowitz\":\n"
  }
}