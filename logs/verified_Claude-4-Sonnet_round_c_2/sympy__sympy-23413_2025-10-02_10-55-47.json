{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/polys/matrices/normalforms.py lines 248-248)": "\n    return DomainMatrix.from_rep(A)[m-rows:, k:]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/polys/matrices/normalforms.py lines 248-248)": [
      "\n    return DomainMatrix.from_rep(A)[m-rows:, k:]\n",
      "\n    return DomainMatrix.from_rep(A)[m-rows:, k:]\n",
      "\ndef _hermite_normal_form(A):\n    r\"\"\"\n    Perform the Hermite Normal Form reduction algorithm on\n    :py:class:`~.DomainMatrix` *A*.\n\n    Explanation\n    ===========\n\n    If *A* is an $m \\times n$ matrix of integers, then its Hermite Normal\n    Form (HNF) is an $m \\times n$ matrix $H$ such that,\n\n    1. $H$ is upper triangular (i.e. $H[i, j] = 0$ for $i > j$).\n    2. $H[i, j] > 0$ for all $i, j$ such that $H[i, j] \\neq 0$.\n    3. If $H[i, j] \\neq 0$, then $H[i, k] < H[i, j]$ for all $k > j$.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.domains import ZZ\n    >>> A = DomainMatrix([[12, 6, 4], [3, 9, 6], [2, 16, 14]], ZZ)\n    >>> H = A.hermite_normal_form()\n    >>> H\n    DomainMatrix([[10, 0, 2], [0, 15, 3], [0, 0, 2]], ZZ)\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n       (See Algorithm 2.4.5.)\n\n    \"\"\"\n    # We work on a copy of the input matrix.\n    A = A.copy().rep\n\n    m, n = A.rows, A.cols\n\n    # The algorithm processes min(m, n) rows, starting from the bottom.\n    rows = min(m, n)\n    k = n - 1\n\n    for i in range(m - 1, m - rows - 1, -1):\n        # Starting from the rightmost column, look for a nonzero entry in row i.\n        j = n - 1\n        while j >= 0 and A[i][j] == 0:\n            j -= 1\n        # If row i is entirely zero, then move on to the next row.\n        if j == -1:\n            continue\n\n        # Otherwise, we want to clear out column j by doing column operations.\n        # First, move column j to the right place (namely, position k).\n        swap_columns(A, j, k)\n        j = k\n\n        # Next, we want to clear out all entries above A[i][j].\n        # But first, we should make A[i][j] > 0.\n        if A[i][j] < 0:\n            multiply_column(A, j, -1)\n\n        for ii in range(i):\n            if A[ii][j] != 0:\n                # We use the division algorithm to make A[ii][j] a remainder w.r.t. A[i][j].\n                q = A[ii][j] // A[i][j]\n                add_columns(A, ii, j, 1, -q, 0, 1)\n\n        # Now use A[i][j] as a pivot to clear entries to the left in row i.\n        b = A[i][j]\n        # But first, let's move to the next position.\n        k -= 1\n        # If the pivot entry is nonzero, then we want to reduce all entries to its\n        # right in the sense of the division algorithm, i.e. make them all remainders\n        # w.r.t. the pivot as divisor.\n        else:\n            for j in range(k + 1, n):\n                q = A[i][j] // b\n                add_columns(A, j, k, 1, -q, 0, 1)\n    # Finally, the HNF consists of those columns of A in which we succeeded in making\n    # a nonzero pivot.\n    return DomainMatrix.from_rep(A)[m-rows:, k+1:]\n",
      "\n    return DomainMatrix.from_rep(A)[m-rows:, k:]\n",
      "\n    return DomainMatrix.from_rep(A)[m-rows:, k:]\n",
      "\ndef _hermite_normal_form(A):\n    r\"\"\"\n    Perform the Hermite Normal Form reduction algorithm on\n    :py:class:`~.DomainMatrix` *A*.\n\n    Explanation\n    ===========\n\n    If *A* is an $m \\times n$ matrix of rank $k$, then the HNF of *A*\n    is the unique $m \\times k$ matrix $H$ such that (1) the columns of $H$\n    span the same $\\mathbb{Z}$-module as those of $A$, (2) $H$ is in column\n    echelon form, and (3) the entries of $H$ are the \"canonical\" ones for\n    this form, meaning that each entry lying to the right of a pivot is a\n    non-negative remainder when divided by that pivot.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.normalforms import _hermite_normal_form\n    >>> A = DomainMatrix([[12, 6, 4], [3, 9, 6], [2, 16, 14]], ZZ)\n    >>> H = _hermite_normal_form(A)\n    >>> print(H)\n    DomainMatrix([[1, 0, 2], [0, 3, 0], [0, 0, 2]], ZZ)\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n       (See Algorithms 2.4.5 and 2.4.8.)\n\n    \"\"\"\n    # We work on a copy of the input matrix.\n    A = A.copy().to_field().to_dense().rep\n    m, n = len(A), len(A[0])\n    \n    def add_columns(M, j, k, a, b, c, d):\n        r\"\"\"\n        Apply the 2x2 matrix transformation [[a, b], [c, d]] to columns j and k\n        of matrix M.\n        \"\"\"\n        for i in range(len(M)):\n            e = M[i][j]\n            M[i][j] = a * e + b * M[i][k]\n            M[i][k] = c * e + d * M[i][k]\n\n    # We work our way upwards through the rows.\n    rows = min(m, n)\n    k = n\n    for i0 in range(rows):\n        i = m - 1 - i0\n        # Move leftward through the columns, looking for a pivot.\n        k -= 1\n        while k >= 0 and A[i][k] == 0:\n            k -= 1\n        # If we can't find a pivot, then we move on to the next row.\n        if k < 0:\n            k += 1\n        # If the pivot entry is nonzero, then we want to reduce all entries to its\n        # right in the sense of the division algorithm, i.e. make them all remainders\n        # w.r.t. the pivot as divisor.\n        else:\n            for j in range(k + 1, n):\n                q = A[i][j] // b\n                add_columns(A, j, k, 1, -q, 0, 1)\n    # Finally, the HNF consists of those columns of A in which we succeeded in making\n    # a nonzero pivot.\n    return DomainMatrix.from_rep(A)[m-rows:, k:]\n",
      "\n    return DomainMatrix.from_rep(A)[m-rows:, k:]\n",
      "\n    return DomainMatrix.from_rep(A)[m-rows:, k:]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..26dc3832ef 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,8 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+\n+    return DomainMatrix.from_rep(A)[m-rows:, k:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\n",
    "variant_0": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..26dc3832ef 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,8 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+\n+    return DomainMatrix.from_rep(A)[m-rows:, k:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\n",
    "variant_1": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..26dc3832ef 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,8 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+\n+    return DomainMatrix.from_rep(A)[m-rows:, k:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\n",
    "variant_2": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..26dc3832ef 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,8 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+\n+    return DomainMatrix.from_rep(A)[m-rows:, k:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\n",
    "variant_3": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..251111240e 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,87 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+\n+def _hermite_normal_form(A):\n+    r\"\"\"\n+    Perform the Hermite Normal Form reduction algorithm on\n+    :py:class:`~.DomainMatrix` *A*.\n+\n+    Explanation\n+    ===========\n+\n+    If *A* is an $m \\times n$ matrix of integers, then its Hermite Normal\n+    Form (HNF) is an $m \\times n$ matrix $H$ such that,\n+\n+    1. $H$ is upper triangular (i.e. $H[i, j] = 0$ for $i > j$).\n+    2. $H[i, j] > 0$ for all $i, j$ such that $H[i, j] \\neq 0$.\n+    3. If $H[i, j] \\neq 0$, then $H[i, k] < H[i, j]$ for all $k > j$.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy.polys.matrices import DomainMatrix\n+    >>> from sympy.polys.domains import ZZ\n+    >>> A = DomainMatrix([[12, 6, 4], [3, 9, 6], [2, 16, 14]], ZZ)\n+    >>> H = A.hermite_normal_form()\n+    >>> H\n+    DomainMatrix([[10, 0, 2], [0, 15, 3], [0, 0, 2]], ZZ)\n+\n+    References\n+    ==========\n+\n+    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n+       (See Algorithm 2.4.5.)\n+\n+    \"\"\"\n+    # We work on a copy of the input matrix.\n+    A = A.copy().rep\n+\n+    m, n = A.rows, A.cols\n+\n+    # The algorithm processes min(m, n) rows, starting from the bottom.\n+    rows = min(m, n)\n+    k = n - 1\n+\n+    for i in range(m - 1, m - rows - 1, -1):\n+        # Starting from the rightmost column, look for a nonzero entry in row i.\n+        j = n - 1\n+        while j >= 0 and A[i][j] == 0:\n+            j -= 1\n+        # If row i is entirely zero, then move on to the next row.\n+        if j == -1:\n+            continue\n+\n+        # Otherwise, we want to clear out column j by doing column operations.\n+        # First, move column j to the right place (namely, position k).\n+        swap_columns(A, j, k)\n+        j = k\n+\n+        # Next, we want to clear out all entries above A[i][j].\n+        # But first, we should make A[i][j] > 0.\n+        if A[i][j] < 0:\n+            multiply_column(A, j, -1)\n+\n+        for ii in range(i):\n+            if A[ii][j] != 0:\n+                # We use the division algorithm to make A[ii][j] a remainder w.r.t. A[i][j].\n+                q = A[ii][j] // A[i][j]\n+                add_columns(A, ii, j, 1, -q, 0, 1)\n+\n+        # Now use A[i][j] as a pivot to clear entries to the left in row i.\n+        b = A[i][j]\n+        # But first, let's move to the next position.\n+        k -= 1\n+        # If the pivot entry is nonzero, then we want to reduce all entries to its\n+        # right in the sense of the division algorithm, i.e. make them all remainders\n+        # w.r.t. the pivot as divisor.\n+        else:\n+            for j in range(k + 1, n):\n+                q = A[i][j] // b\n+                add_columns(A, j, k, 1, -q, 0, 1)\n+    # Finally, the HNF consists of those columns of A in which we succeeded in making\n+    # a nonzero pivot.\n+    return DomainMatrix.from_rep(A)[m-rows:, k+1:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\n",
    "variant_4": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..26dc3832ef 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,8 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+\n+    return DomainMatrix.from_rep(A)[m-rows:, k:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\n",
    "variant_5": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..26dc3832ef 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,8 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+\n+    return DomainMatrix.from_rep(A)[m-rows:, k:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\n",
    "variant_6": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..8951a564ff 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,76 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+\n+def _hermite_normal_form(A):\n+    r\"\"\"\n+    Perform the Hermite Normal Form reduction algorithm on\n+    :py:class:`~.DomainMatrix` *A*.\n+\n+    Explanation\n+    ===========\n+\n+    If *A* is an $m \\times n$ matrix of rank $k$, then the HNF of *A*\n+    is the unique $m \\times k$ matrix $H$ such that (1) the columns of $H$\n+    span the same $\\mathbb{Z}$-module as those of $A$, (2) $H$ is in column\n+    echelon form, and (3) the entries of $H$ are the \"canonical\" ones for\n+    this form, meaning that each entry lying to the right of a pivot is a\n+    non-negative remainder when divided by that pivot.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import ZZ\n+    >>> from sympy.polys.matrices import DomainMatrix\n+    >>> from sympy.polys.matrices.normalforms import _hermite_normal_form\n+    >>> A = DomainMatrix([[12, 6, 4], [3, 9, 6], [2, 16, 14]], ZZ)\n+    >>> H = _hermite_normal_form(A)\n+    >>> print(H)\n+    DomainMatrix([[1, 0, 2], [0, 3, 0], [0, 0, 2]], ZZ)\n+\n+    References\n+    ==========\n+\n+    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n+       (See Algorithms 2.4.5 and 2.4.8.)\n+\n+    \"\"\"\n+    # We work on a copy of the input matrix.\n+    A = A.copy().to_field().to_dense().rep\n+    m, n = len(A), len(A[0])\n+    \n+    def add_columns(M, j, k, a, b, c, d):\n+        r\"\"\"\n+        Apply the 2x2 matrix transformation [[a, b], [c, d]] to columns j and k\n+        of matrix M.\n+        \"\"\"\n+        for i in range(len(M)):\n+            e = M[i][j]\n+            M[i][j] = a * e + b * M[i][k]\n+            M[i][k] = c * e + d * M[i][k]\n+\n+    # We work our way upwards through the rows.\n+    rows = min(m, n)\n+    k = n\n+    for i0 in range(rows):\n+        i = m - 1 - i0\n+        # Move leftward through the columns, looking for a pivot.\n+        k -= 1\n+        while k >= 0 and A[i][k] == 0:\n+            k -= 1\n+        # If we can't find a pivot, then we move on to the next row.\n+        if k < 0:\n+            k += 1\n+        # If the pivot entry is nonzero, then we want to reduce all entries to its\n+        # right in the sense of the division algorithm, i.e. make them all remainders\n+        # w.r.t. the pivot as divisor.\n+        else:\n+            for j in range(k + 1, n):\n+                q = A[i][j] // b\n+                add_columns(A, j, k, 1, -q, 0, 1)\n+    # Finally, the HNF consists of those columns of A in which we succeeded in making\n+    # a nonzero pivot.\n+    return DomainMatrix.from_rep(A)[m-rows:, k:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\n",
    "variant_7": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..26dc3832ef 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,8 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+\n+    return DomainMatrix.from_rep(A)[m-rows:, k:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\n",
    "variant_8": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..26dc3832ef 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,8 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+\n+    return DomainMatrix.from_rep(A)[m-rows:, k:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\n"
  }
}