{
  "zero_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/__init__.py lines 673-677)": "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Only auto-switch if we're in an interactive context or explicitly requested\n                # This prevents get_backend() from having destructive side effects\n                import sys\n                if hasattr(sys, 'ps1') or sys.flags.interactive:\n                    from matplotlib import pyplot as plt\n                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/__init__.py lines 1170-1178)": "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/pyplot.py lines 225-225)": "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, since\n    switching backends would require destroying the event loop. In that case,\n    a RuntimeError is raised.\n\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    \n    # Only close figures when explicitly switching to a different backend\n    # Auto-detection should not destroy existing figures\n    if newbackend is not rcsetup._auto_backend_sentinel:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n",
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/pyplot.py lines 940-941)": "\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n",
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/__init__.py lines 681-684)": "\ndef _get_backend_or_none(self):\n    \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n    backend = dict.__getitem__(self, \"backend\")\n    return None if backend is rcsetup._auto_backend_sentinel else backend\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/__init__.py lines 673-677)": [
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Only auto-switch if we're in an interactive context or explicitly requested\n                # This prevents get_backend() from having destructive side effects\n                import sys\n                if hasattr(sys, 'ps1') or sys.flags.interactive:\n                    from matplotlib import pyplot as plt\n                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Only auto-switch if we're in an interactive context or explicitly requested\n                # This prevents get_backend() from having destructive side effects\n                import sys\n                if hasattr(sys, 'ps1') or sys.flags.interactive:\n                    from matplotlib import pyplot as plt\n                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n    \n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Only auto-switch if we're in an interactive context or explicitly requested\n                # This prevents get_backend() from having destructive side effects\n                import sys\n                if hasattr(sys, 'ps1') or sys.flags.interactive:\n                    from matplotlib import pyplot as plt\n                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Only auto-switch if we're in an interactive context or explicitly requested\n                # This prevents get_backend() from having destructive side effects\n                import sys\n                if hasattr(sys, 'ps1') or sys.flags.interactive:\n                    from matplotlib import pyplot as plt\n                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Only auto-switch if we're in an interactive context or explicitly requested\n                # This prevents get_backend() from having destructive side effects\n                import sys\n                if hasattr(sys, 'ps1') or sys.flags.interactive:\n                    from matplotlib import pyplot as plt\n                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Only auto-switch if we're in an interactive context or explicitly requested\n                # This prevents get_backend() from having destructive side effects\n                import sys\n                if hasattr(sys, 'ps1') or sys.flags.interactive:\n                    from matplotlib import pyplot as plt\n                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\n    elif key == \"backend\" and self is globals().get(\"rcParams\"):\n        val = dict.__getitem__(self, key)\n        if val is rcsetup._auto_backend_sentinel:\n            # Only auto-switch if we're in an interactive context or explicitly requested\n            # This prevents get_backend() from having destructive side effects\n            import sys\n            if hasattr(sys, 'ps1') or sys.flags.interactive:\n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n"
    ],
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/__init__.py lines 1170-1178)": [
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n"
    ],
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/pyplot.py lines 225-225)": [
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend is case-insensitive; e.g., 'GTKAgg' and 'gtkagg' are\n    equivalent.\n\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    \n    # Only close figures when explicitly switching to a different backend\n    # Auto-detection should not destroy existing figures\n    if newbackend is not rcsetup._auto_backend_sentinel:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI mainloop is running, since that\n    would require tearing down the old GUI and starting up the new one. In\n    that case, RuntimeError is raised.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    \n    # Only close figures when explicitly switching to a different backend\n    # Auto-detection should not destroy existing figures\n    if newbackend is not rcsetup._auto_backend_sentinel:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI window has already been created,\n    as is the case within IPython kernel with certain magic commands (%pylab,\n    %matplotlib). In such cases, a RuntimeError is raised.\n\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    # Only close figures when explicitly switching to a different backend\n    # Auto-detection should not destroy existing figures\n    if newbackend is not rcsetup._auto_backend_sentinel:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n    \n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n    \n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, since\n    most GUI toolkits require being initialized before being used.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    \n    # Only close figures when explicitly switching to a different backend\n    # Auto-detection should not destroy existing figures\n    if newbackend is not rcsetup._auto_backend_sentinel:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, since\n    most GUI toolkits require the event loop to start earlier.  In that case,\n    we raise an ImportError.\n\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    \n    # Only close figures when explicitly switching to a different backend\n    # Auto-detection should not destroy existing figures\n    if newbackend is not rcsetup._auto_backend_sentinel:\n        close(\"all\")\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n    \n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use the safe method to avoid triggering backend switching\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only trigger backend resolution if we actually need it\n        # This preserves the auto-detection behavior when explicitly needed\n        return rcParams['backend']\n    return backend\n"
    ],
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/pyplot.py lines 940-941)": [
      "\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n",
      "\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n",
      "\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n",
      "\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n",
      "\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n",
      "\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n",
      "\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n",
      "\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n"
    ],
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/__init__.py lines 681-684)": [
      "\ndef _get_backend_or_none(self):\n    \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n    backend = dict.__getitem__(self, \"backend\")\n    return None if backend is rcsetup._auto_backend_sentinel else backend\n",
      "\ndef _get_backend_or_none(self):\n    \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n    backend = dict.__getitem__(self, \"backend\")\n    return None if backend is rcsetup._auto_backend_sentinel else backend\n",
      "\n    def _get_backend_or_none(self):\n        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n        backend = dict.__getitem__(self, \"backend\")\n        return None if backend is rcsetup._auto_backend_sentinel else backend\n",
      "\n    def _get_backend_or_none(self):\n        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n        backend = dict.__getitem__(self, \"backend\")\n        return None if backend is rcsetup._auto_backend_sentinel else backend\n",
      "\n    def _get_backend_or_none(self):\n        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n        backend = dict.__getitem__(self, \"backend\")\n        return None if backend is rcsetup._auto_backend_sentinel else backend\n",
      "\n    def _get_backend_or_none(self):\n        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n        backend = dict.__getitem__(self, \"backend\")\n        return None if backend is rcsetup._auto_backend_sentinel else backend\n",
      "\n    def _get_backend_or_none(self):\n        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n        backend = dict.__getitem__(self, \"backend\")\n        return None if backend is rcsetup._auto_backend_sentinel else backend\n",
      "\n    def _get_backend_or_none(self):\n        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n        backend = dict.__getitem__(self, \"backend\")\n        return None if backend is rcsetup._auto_backend_sentinel else backend\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..d92cd52ccb 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -670,14 +670,19 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                # Only auto-switch if we're in an interactive context or explicitly requested\n+                # This prevents get_backend() from having destructive side effects\n+                if hasattr(sys, 'ps1') or sys.flags.interactive:\n+                    from matplotlib import pyplot as plt\n+                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1167,6 +1172,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1181,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..6461f41d0e 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,11 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+    if newbackend is not rcsetup._auto_backend_sentinel:\n+        # Only close figures when explicitly switching to a different backend\n+        # Auto-detection should not destroy existing figures\n+        close(\"all\")\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -937,6 +941,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n",
    "variant_0": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..e94b478b3d 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -670,18 +670,24 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                # Only auto-switch if we're in an interactive context or explicitly requested\n+                # This prevents get_backend() from having destructive side effects\n+                import sys\n+                if hasattr(sys, 'ps1') or sys.flags.interactive:\n+                    from matplotlib import pyplot as plt\n+                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\n \n-    def _get_backend_or_none(self):\n-        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n-        backend = dict.__getitem__(self, \"backend\")\n-        return None if backend is rcsetup._auto_backend_sentinel else backend\n+\n+def _get_backend_or_none(self):\n+    \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n+    backend = dict.__getitem__(self, \"backend\")\n+    return None if backend is rcsetup._auto_backend_sentinel else backend\n \n     def __repr__(self):\n         class_name = self.__class__.__name__\n@@ -1167,6 +1173,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1182,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..f5478d760f 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,40 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, since\n+    switching backends would require destroying the event loop. In that case,\n+    a RuntimeError is raised.\n+\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.backends\n+    \n+    # Only close figures when explicitly switching to a different backend\n+    # Auto-detection should not destroy existing figures\n+    if newbackend is not rcsetup._auto_backend_sentinel:\n+        close(\"all\")\n+\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -937,6 +970,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n",
    "variant_1": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..e94b478b3d 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -670,18 +670,24 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                # Only auto-switch if we're in an interactive context or explicitly requested\n+                # This prevents get_backend() from having destructive side effects\n+                import sys\n+                if hasattr(sys, 'ps1') or sys.flags.interactive:\n+                    from matplotlib import pyplot as plt\n+                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\n \n-    def _get_backend_or_none(self):\n-        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n-        backend = dict.__getitem__(self, \"backend\")\n-        return None if backend is rcsetup._auto_backend_sentinel else backend\n+\n+def _get_backend_or_none(self):\n+    \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n+    backend = dict.__getitem__(self, \"backend\")\n+    return None if backend is rcsetup._auto_backend_sentinel else backend\n \n     def __repr__(self):\n         class_name = self.__class__.__name__\n@@ -1167,6 +1173,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1182,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..e4815e20b0 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,39 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend is case-insensitive; e.g., 'GTKAgg' and 'gtkagg' are\n+    equivalent.\n+\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.backends\n+    \n+    # Only close figures when explicitly switching to a different backend\n+    # Auto-detection should not destroy existing figures\n+    if newbackend is not rcsetup._auto_backend_sentinel:\n+        close(\"all\")\n+\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -937,6 +969,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n",
    "variant_2": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..e94b478b3d 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -670,18 +670,24 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                # Only auto-switch if we're in an interactive context or explicitly requested\n+                # This prevents get_backend() from having destructive side effects\n+                import sys\n+                if hasattr(sys, 'ps1') or sys.flags.interactive:\n+                    from matplotlib import pyplot as plt\n+                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\n \n-    def _get_backend_or_none(self):\n-        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n-        backend = dict.__getitem__(self, \"backend\")\n-        return None if backend is rcsetup._auto_backend_sentinel else backend\n+\n+def _get_backend_or_none(self):\n+    \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n+    backend = dict.__getitem__(self, \"backend\")\n+    return None if backend is rcsetup._auto_backend_sentinel else backend\n \n     def __repr__(self):\n         class_name = self.__class__.__name__\n@@ -1167,6 +1173,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1182,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..661ed041ae 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,38 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI mainloop is running, since that\n+    would require tearing down the old GUI and starting up the new one. In\n+    that case, RuntimeError is raised.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.backends\n+    \n+    # Only close figures when explicitly switching to a different backend\n+    # Auto-detection should not destroy existing figures\n+    if newbackend is not rcsetup._auto_backend_sentinel:\n+        close(\"all\")\n+\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -937,6 +968,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n",
    "variant_3": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..c570febd60 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -670,14 +670,26 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n-        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n-            val = dict.__getitem__(self, key)\n-            if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+    \n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1167,6 +1179,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1188,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..a00943ef10 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,39 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI window has already been created,\n+    as is the case within IPython kernel with certain magic commands (%pylab,\n+    %matplotlib). In such cases, a RuntimeError is raised.\n+\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.backends\n+    # Only close figures when explicitly switching to a different backend\n+    # Auto-detection should not destroy existing figures\n+    if newbackend is not rcsetup._auto_backend_sentinel:\n+        close(\"all\")\n+\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -937,6 +969,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n",
    "variant_4": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..9ddb9ca263 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -670,14 +670,20 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                # Only auto-switch if we're in an interactive context or explicitly requested\n+                # This prevents get_backend() from having destructive side effects\n+                import sys\n+                if hasattr(sys, 'ps1') or sys.flags.interactive:\n+                    from matplotlib import pyplot as plt\n+                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1167,6 +1173,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1182,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..5d9449331f 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,22 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+    \n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -937,6 +952,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n",
    "variant_5": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..9ddb9ca263 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -670,14 +670,20 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                # Only auto-switch if we're in an interactive context or explicitly requested\n+                # This prevents get_backend() from having destructive side effects\n+                import sys\n+                if hasattr(sys, 'ps1') or sys.flags.interactive:\n+                    from matplotlib import pyplot as plt\n+                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1167,6 +1173,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1182,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..5d9449331f 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,22 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+    \n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -937,6 +952,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n",
    "variant_6": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..9ddb9ca263 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -670,14 +670,20 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                # Only auto-switch if we're in an interactive context or explicitly requested\n+                # This prevents get_backend() from having destructive side effects\n+                import sys\n+                if hasattr(sys, 'ps1') or sys.flags.interactive:\n+                    from matplotlib import pyplot as plt\n+                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1167,6 +1173,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1182,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..97c2a000c3 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,38 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, since\n+    most GUI toolkits require being initialized before being used.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.backends\n+    \n+    # Only close figures when explicitly switching to a different backend\n+    # Auto-detection should not destroy existing figures\n+    if newbackend is not rcsetup._auto_backend_sentinel:\n+        close(\"all\")\n+\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -937,6 +968,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n",
    "variant_7": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..9ddb9ca263 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -670,14 +670,20 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                # Only auto-switch if we're in an interactive context or explicitly requested\n+                # This prevents get_backend() from having destructive side effects\n+                import sys\n+                if hasattr(sys, 'ps1') or sys.flags.interactive:\n+                    from matplotlib import pyplot as plt\n+                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1167,6 +1173,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1182,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..80ebe38f08 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,30 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, since\n+    most GUI toolkits require the event loop to start earlier.  In that case,\n+    we raise an ImportError.\n+\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.backends\n+    \n+    # Only close figures when explicitly switching to a different backend\n+    # Auto-detection should not destroy existing figures\n+    if newbackend is not rcsetup._auto_backend_sentinel:\n+        close(\"all\")\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -937,6 +960,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n",
    "variant_8": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..f1f3edf74b 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -670,14 +670,20 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n-        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n-            val = dict.__getitem__(self, key)\n-            if val is rcsetup._auto_backend_sentinel:\n+\n+    elif key == \"backend\" and self is globals().get(\"rcParams\"):\n+        val = dict.__getitem__(self, key)\n+        if val is rcsetup._auto_backend_sentinel:\n+            # Only auto-switch if we're in an interactive context or explicitly requested\n+            # This prevents get_backend() from having destructive side effects\n+            import sys\n+            if hasattr(sys, 'ps1') or sys.flags.interactive:\n                 from matplotlib import pyplot as plt\n                 plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1167,6 +1173,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1182,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..5d9449331f 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,22 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+    \n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use the safe method to avoid triggering backend switching\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only trigger backend resolution if we actually need it\n+        # This preserves the auto-detection behavior when explicitly needed\n+        return rcParams['backend']\n+    return backend\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -937,6 +952,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n"
  }
}