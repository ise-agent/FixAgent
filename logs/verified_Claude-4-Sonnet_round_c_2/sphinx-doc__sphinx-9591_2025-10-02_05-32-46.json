{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 2726-2738)": "\n        if func and self.config.autodoc_typehints != 'none':\n            try:\n                signature = inspect.signature(func,\n                                              type_aliases=self.config.autodoc_type_aliases)\n                if signature.return_annotation is not Parameter.empty:\n                    # Record the type annotation for cross-reference processing\n                    annotations = self.env.temp_data.setdefault('annotations', {})\n                    annotations[self.fullname] = {\n                        'return': signature.return_annotation\n                    }\n                    # Let merge_typehints handle the cross-reference generation\n                    objrepr = stringify_typehint(signature.return_annotation)\n                    self.add_line('   :type: ' + objrepr, sourcename)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                return None\n",
    "Location 2 (/root/hy/projects/sphinx/sphinx/ext/autodoc/typehints.py lines 23-37)": "\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n    \"\"\"Record type hints to env object.\"\"\"\n    try:\n        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n            # Handle both regular callables and property objects\n            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n            annotations = app.env.temp_data.setdefault('annotations', {})\n            annotation = annotations.setdefault(name, OrderedDict())\n            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n            for param in sig.parameters.values():\n                if param.annotation is not param.empty:\n                    annotation[param.name] = typing.stringify(param.annotation)\n            if sig.return_annotation is not sig.empty:\n                annotation['return'] = typing.stringify(sig.return_annotation)\n    except (TypeError, ValueError):\n        pass\n",
    "Location 3 (/root/hy/projects/sphinx/sphinx/ext/autodoc/typehints.py lines 40-67)": "\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    if domain != 'py':\n        return\n    if app.config.autodoc_typehints not in ('both', 'description'):\n        return\n\n    try:\n        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n        if signature['module']:\n            fullname = '.'.join([signature['module'], signature['fullname']])\n        else:\n            fullname = signature['fullname']\n    except (KeyError, IndexError):\n        # signature node does not have valid context info for the target object\n        return\n\n    annotations = app.env.temp_data.get('annotations', {})\n    if annotations.get(fullname, {}):\n        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n        if field_lists == []:\n            field_list = insert_field_list(contentnode)\n            field_lists.append(field_list)\n\n        for field_list in field_lists:\n            if app.config.autodoc_typehints_description_target == \"all\":\n                modify_field_list(field_list, annotations[fullname])\n            else:\n                augment_descriptions_with_types(field_list, annotations[fullname])\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 2726-2738)": [
      "\n        if func and self.config.autodoc_typehints != 'none':\n            try:\n                signature = inspect.signature(func,\n                                              type_aliases=self.config.autodoc_type_aliases)\n                if signature.return_annotation is not Parameter.empty:\n                    # Store the type annotation for later processing by merge_typehints\n                    annotations = self.env.temp_data.setdefault('annotations', {})\n                    annotations[self.fullname] = {'return': signature.return_annotation}\n                    \n                    # Emit autodoc-process-signature event to enable cross-reference processing\n                    self.env.app.emit('autodoc-process-signature',\n                                    self.objtype, self.fullname, func, self.options, \n                                    None, signature.return_annotation)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                return None\n",
      "\n        if func and self.config.autodoc_typehints != 'none':\n            try:\n                signature = inspect.signature(func,\n                                              type_aliases=self.config.autodoc_type_aliases)\n                if signature.return_annotation is not Parameter.empty:\n                    # Use the event system to enable cross-reference generation for property types\n                    retann = stringify_typehint(signature.return_annotation)\n                    # Record the type annotation for later processing by merge_typehints\n                    annotations = self.env.temp_data.setdefault('annotations', {})\n                    annotations[self.fullname] = {'return': signature.return_annotation}\n                    # Add the type line - cross-references will be processed later\n                    self.add_line('   :type: ' + retann, sourcename)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                return None\n",
      "\n        if func and self.config.autodoc_typehints != 'none':\n            try:\n                signature = inspect.signature(func,\n                                              type_aliases=self.config.autodoc_type_aliases)\n                if signature.return_annotation is not Parameter.empty:\n                    # Use the event system to enable cross-reference generation for property types\n                    # Store the annotation for later processing by merge_typehints\n                    annotations = self.env.temp_data.setdefault('annotations', {})\n                    annotations[self.fullname] = {\n                        'return': signature.return_annotation\n                    }\n                    \n                    # Emit the event to allow other handlers to process the signature\n                    retann = stringify_typehint(signature.return_annotation)\n                    self.env.app.emit('autodoc-process-signature', \n                                      self.objtype, self.fullname, func, self.options, '', retann)\n                    \n                    # Add the type line - merge_typehints will later enhance it with cross-references\n                    objrepr = stringify_typehint(signature.return_annotation)\n                    self.add_line('   :type: ' + objrepr, sourcename)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                return None\n",
      "\n        if func and self.config.autodoc_typehints != 'none':\n            try:\n                signature = inspect.signature(func,\n                                              type_aliases=self.config.autodoc_type_aliases)\n                if signature.return_annotation is not Parameter.empty:\n                    # Use the same event-driven approach as other documenters for cross-references\n                    retann = stringify_typehint(signature.return_annotation)\n                    # Store the annotation for later processing by merge_typehints\n                    annotations = self.env.temp_data.setdefault('annotations', {})\n                    annotations[self.fullname] = {'return': signature.return_annotation}\n                    \n                    # Fire the event to allow processing of the signature\n                    self.env.app.emit('autodoc-process-signature', \n                                      self.objtype, self.fullname, func, self.options, '', retann)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                return None\n",
      "\n        if func and self.config.autodoc_typehints != 'none':\n            try:\n                signature = inspect.signature(func,\n                                              type_aliases=self.config.autodoc_type_aliases)\n                if signature.return_annotation is not Parameter.empty:\n                    # Record the type annotation for cross-reference processing\n                    annotations = self.env.temp_data.setdefault('annotations', {})\n                    annotations[self.fullname] = signature.return_annotation\n                    \n                    # Fire autodoc-process-signature event to enable cross-reference processing\n                    retann = stringify_typehint(signature.return_annotation)\n                    self.env.app.emit('autodoc-process-signature', \n                                      self.objtype, self.fullname, func, self.options, '', retann)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                return None\n",
      "\n        if func and self.config.autodoc_typehints != 'none':\n            try:\n                signature = inspect.signature(func,\n                                              type_aliases=self.config.autodoc_type_aliases)\n                if signature.return_annotation is not Parameter.empty:\n                    # Store the type annotation for later processing by merge_typehints\n                    annotations = self.env.temp_data.setdefault('annotations', {})\n                    annotations[self.fullname] = {'return': signature.return_annotation}\n                    \n                    # Emit autodoc-process-signature event to enable cross-reference processing\n                    retann = stringify_typehint(signature.return_annotation)\n                    self.env.app.emit('autodoc-process-signature',\n                                      self.objtype, self.fullname, func, self.options, '', retann)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                return None\n",
      "\n        if func and self.config.autodoc_typehints != 'none':\n            try:\n                signature = inspect.signature(func,\n                                              type_aliases=self.config.autodoc_type_aliases)\n                if signature.return_annotation is not Parameter.empty:\n                    # Use the same event-driven approach as other documenters for cross-references\n                    retann = stringify_typehint(signature.return_annotation)\n                    # Record the type annotation for later processing by merge_typehints\n                    annotations = self.env.temp_data.setdefault('annotations', {})\n                    annotations[self.fullname] = {'return': signature.return_annotation}\n                    # Fire the event to allow for cross-reference processing\n                    self.env.app.emit('autodoc-process-signature', \n                                      self.objtype, self.fullname, func, self.options, '', retann)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                return None\n",
      "\n        if func and self.config.autodoc_typehints != 'none':\n            try:\n                signature = inspect.signature(func,\n                                              type_aliases=self.config.autodoc_type_aliases)\n                if signature.return_annotation is not Parameter.empty:\n                    # Store the type annotation for cross-reference processing\n                    annotations = self.env.temp_data.setdefault('annotations', {})\n                    annotations[self.fullname] = {'return': signature.return_annotation}\n                    \n                    # Let the event system handle cross-reference generation\n                    objrepr = stringify_typehint(signature.return_annotation)\n                    self.add_line('   :type: ' + objrepr, sourcename)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                return None\n"
    ],
    "Location 2 (/root/hy/projects/sphinx/sphinx/ext/autodoc/typehints.py lines 23-37)": [
      "\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n    \"\"\"Record type hints to env object.\"\"\"\n    try:\n        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n            # Handle both regular callables and property objects\n            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n            annotations = app.env.temp_data.setdefault('annotations', {})\n            annotation = annotations.setdefault(name, OrderedDict())\n            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n            for param in sig.parameters.values():\n                if param.annotation is not param.empty:\n                    annotation[param.name] = typing.stringify(param.annotation)\n            if sig.return_annotation is not sig.empty:\n                annotation['return'] = typing.stringify(sig.return_annotation)\n    except (TypeError, ValueError):\n        pass\n",
      "\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n    \"\"\"Record type hints to env object.\"\"\"\n    try:\n        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n            # Handle both regular callables and property objects\n            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n            annotations = app.env.temp_data.setdefault('annotations', {})\n            annotation = annotations.setdefault(name, OrderedDict())\n            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n            for param in sig.parameters.values():\n                if param.annotation is not param.empty:\n                    annotation[param.name] = typing.stringify(param.annotation)\n            if sig.return_annotation is not sig.empty:\n                annotation['return'] = typing.stringify(sig.return_annotation)\n    except (TypeError, ValueError):\n        pass\n",
      "\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n    \"\"\"Record type hints to env object.\"\"\"\n    try:\n        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n            # Handle both regular callables and property objects\n            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n            annotations = app.env.temp_data.setdefault('annotations', {})\n            annotation = annotations.setdefault(name, OrderedDict())\n            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n            for param in sig.parameters.values():\n                if param.annotation is not param.empty:\n                    annotation[param.name] = typing.stringify(param.annotation)\n            if sig.return_annotation is not sig.empty:\n                annotation['return'] = typing.stringify(sig.return_annotation)\n    except (TypeError, ValueError):\n        pass\n",
      "\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n    \"\"\"Record type hints to env object.\"\"\"\n    try:\n        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n            # Handle both regular callables and property objects\n            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n            annotations = app.env.temp_data.setdefault('annotations', {})\n            annotation = annotations.setdefault(name, OrderedDict())\n            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n            for param in sig.parameters.values():\n                if param.annotation is not param.empty:\n                    annotation[param.name] = typing.stringify(param.annotation)\n            if sig.return_annotation is not sig.empty:\n                annotation['return'] = typing.stringify(sig.return_annotation)\n    except (TypeError, ValueError):\n        pass\n",
      "\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n    \"\"\"Record type hints to env object.\"\"\"\n    try:\n        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n            # Handle both regular callables and property objects\n            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n            annotations = app.env.temp_data.setdefault('annotations', {})\n            annotation = annotations.setdefault(name, OrderedDict())\n            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n            for param in sig.parameters.values():\n                if param.annotation is not param.empty:\n                    annotation[param.name] = typing.stringify(param.annotation)\n            if sig.return_annotation is not sig.empty:\n                annotation['return'] = typing.stringify(sig.return_annotation)\n    except (TypeError, ValueError):\n        pass\n",
      "\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n    \"\"\"Record type hints to env object.\"\"\"\n    try:\n        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n            # Handle both regular callables and property objects\n            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n            annotations = app.env.temp_data.setdefault('annotations', {})\n            annotation = annotations.setdefault(name, OrderedDict())\n            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n            for param in sig.parameters.values():\n                if param.annotation is not param.empty:\n                    annotation[param.name] = typing.stringify(param.annotation)\n            if sig.return_annotation is not sig.empty:\n                annotation['return'] = typing.stringify(sig.return_annotation)\n    except (TypeError, ValueError):\n        pass\n",
      "\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n    \"\"\"Record type hints to env object.\"\"\"\n    try:\n        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n            # Handle both regular callables and property objects\n            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n            annotations = app.env.temp_data.setdefault('annotations', {})\n            annotation = annotations.setdefault(name, OrderedDict())\n            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n            for param in sig.parameters.values():\n                if param.annotation is not param.empty:\n                    annotation[param.name] = typing.stringify(param.annotation)\n            if sig.return_annotation is not sig.empty:\n                annotation['return'] = typing.stringify(sig.return_annotation)\n    except (TypeError, ValueError):\n        pass\n",
      "\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n    \"\"\"Record type hints to env object.\"\"\"\n    try:\n        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n            # Handle both regular callables and property objects\n            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n            annotations = app.env.temp_data.setdefault('annotations', {})\n            annotation = annotations.setdefault(name, OrderedDict())\n            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n            for param in sig.parameters.values():\n                if param.annotation is not param.empty:\n                    annotation[param.name] = typing.stringify(param.annotation)\n            if sig.return_annotation is not sig.empty:\n                annotation['return'] = typing.stringify(sig.return_annotation)\n    except (TypeError, ValueError):\n        pass\n"
    ],
    "Location 3 (/root/hy/projects/sphinx/sphinx/ext/autodoc/typehints.py lines 40-67)": [
      "\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    if domain != 'py':\n        return\n    if app.config.autodoc_typehints not in ('both', 'description'):\n        return\n\n    try:\n        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n        if signature['module']:\n            fullname = '.'.join([signature['module'], signature['fullname']])\n        else:\n            fullname = signature['fullname']\n    except (KeyError, IndexError):\n        # signature node does not have valid context info for the target object\n        return\n\n    annotations = app.env.temp_data.get('annotations', {})\n    if annotations.get(fullname, {}):\n        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n        if field_lists == []:\n            field_list = insert_field_list(contentnode)\n            field_lists.append(field_list)\n\n        for field_list in field_lists:\n            if app.config.autodoc_typehints_description_target == \"all\":\n                modify_field_list(field_list, annotations[fullname])\n            else:\n                augment_descriptions_with_types(field_list, annotations[fullname])\n",
      "\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    if domain != 'py':\n        return\n    if app.config.autodoc_typehints not in ('both', 'description'):\n        return\n\n    try:\n        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n        if signature['module']:\n            fullname = '.'.join([signature['module'], signature['fullname']])\n        else:\n            fullname = signature['fullname']\n    except KeyError:\n        # signature node does not have valid context info for the target object\n        return\n\n    annotations = app.env.temp_data.get('annotations', {})\n    if annotations.get(fullname, {}):\n        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n        if field_lists == []:\n            field_list = insert_field_list(contentnode)\n            field_lists.append(field_list)\n\n        for field_list in field_lists:\n            if app.config.autodoc_typehints_description_target == \"all\":\n                modify_field_list(field_list, annotations[fullname])\n            else:\n                augment_descriptions_with_types(field_list, annotations[fullname])\n",
      "\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    if domain != 'py':\n        return\n    if app.config.autodoc_typehints not in ('both', 'description'):\n        return\n\n    try:\n        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n        if signature['module']:\n            fullname = '.'.join([signature['module'], signature['fullname']])\n        else:\n            fullname = signature['fullname']\n    except (KeyError, IndexError):\n        # signature node does not have valid context info for the target object\n        return\n\n    annotations = app.env.temp_data.get('annotations', {})\n    if annotations.get(fullname, {}):\n        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n        if field_lists == []:\n            field_list = insert_field_list(contentnode)\n            field_lists.append(field_list)\n\n        for field_list in field_lists:\n            if app.config.autodoc_typehints_description_target == \"all\":\n                modify_field_list(field_list, annotations[fullname])\n            else:\n                augment_descriptions_with_types(field_list, annotations[fullname])\n",
      "\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    if domain != 'py':\n        return\n    if app.config.autodoc_typehints not in ('both', 'description'):\n        return\n\n    try:\n        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n        if signature['module']:\n            fullname = '.'.join([signature['module'], signature['fullname']])\n        else:\n            fullname = signature['fullname']\n    except (KeyError, IndexError):\n        # signature node does not have valid context info for the target object\n        return\n\n    annotations = app.env.temp_data.get('annotations', {})\n    if annotations.get(fullname, {}):\n        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n        if field_lists == []:\n            field_list = insert_field_list(contentnode)\n            field_lists.append(field_list)\n\n        for field_list in field_lists:\n            if app.config.autodoc_typehints_description_target == \"all\":\n                modify_field_list(field_list, annotations[fullname])\n            else:\n                augment_descriptions_with_types(field_list, annotations[fullname])\n",
      "\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    if domain != 'py':\n        return\n    if app.config.autodoc_typehints not in ('both', 'description'):\n        return\n\n    try:\n        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n        if signature['module']:\n            fullname = '.'.join([signature['module'], signature['fullname']])\n        else:\n            fullname = signature['fullname']\n    except (KeyError, IndexError):\n        # signature node does not have valid context info for the target object\n        return\n\n    annotations = app.env.temp_data.get('annotations', {})\n    if annotations.get(fullname, {}):\n        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n        if field_lists == []:\n            field_list = insert_field_list(contentnode)\n            field_lists.append(field_list)\n\n        for field_list in field_lists:\n            if app.config.autodoc_typehints_description_target == \"all\":\n                modify_field_list(field_list, annotations[fullname])\n            else:\n                augment_descriptions_with_types(field_list, annotations[fullname])\n",
      "\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    if domain != 'py':\n        return\n    if app.config.autodoc_typehints not in ('both', 'description'):\n        return\n\n    try:\n        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n        if signature['module']:\n            fullname = '.'.join([signature['module'], signature['fullname']])\n        else:\n            fullname = signature['fullname']\n    except (KeyError, IndexError):\n        # signature node does not have valid context info for the target object\n        return\n\n    annotations = app.env.temp_data.get('annotations', {})\n    if annotations.get(fullname, {}):\n        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n        if field_lists == []:\n            field_list = insert_field_list(contentnode)\n            field_lists.append(field_list)\n\n        for field_list in field_lists:\n            if app.config.autodoc_typehints_description_target == \"all\":\n                modify_field_list(field_list, annotations[fullname])\n            else:\n                augment_descriptions_with_types(field_list, annotations[fullname])\n",
      "\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    if domain != 'py':\n        return\n    if app.config.autodoc_typehints not in ('both', 'description'):\n        return\n\n    try:\n        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n        if signature['module']:\n            fullname = '.'.join([signature['module'], signature['fullname']])\n        else:\n            fullname = signature['fullname']\n    except (KeyError, IndexError):\n        # signature node does not have valid context info for the target object\n        return\n\n    annotations = app.env.temp_data.get('annotations', {})\n    if annotations.get(fullname, {}):\n        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n        if field_lists == []:\n            field_list = insert_field_list(contentnode)\n            field_lists.append(field_list)\n\n        for field_list in field_lists:\n            if app.config.autodoc_typehints_description_target == \"all\":\n                modify_field_list(field_list, annotations[fullname])\n            else:\n                augment_descriptions_with_types(field_list, annotations[fullname])\n",
      "\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    if domain != 'py':\n        return\n    if app.config.autodoc_typehints not in ('both', 'description'):\n        return\n\n    try:\n        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n        if signature['module']:\n            fullname = '.'.join([signature['module'], signature['fullname']])\n        else:\n            fullname = signature['fullname']\n    except KeyError:\n        # signature node does not have valid context info for the target object\n        return\n\n    annotations = app.env.temp_data.get('annotations', {})\n    if annotations.get(fullname, {}):\n        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n        if field_lists == []:\n            field_list = insert_field_list(contentnode)\n            field_lists.append(field_list)\n\n        for field_list in field_lists:\n            if app.config.autodoc_typehints_description_target == \"all\":\n                modify_field_list(field_list, annotations[fullname])\n            else:\n                augment_descriptions_with_types(field_list, annotations[fullname])\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976cd..1299a1271 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2723,13 +2723,17 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         else:\n             func = None\n \n+\n         if func and self.config.autodoc_typehints != 'none':\n             try:\n                 signature = inspect.signature(func,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n-                    objrepr = stringify_typehint(signature.return_annotation)\n-                    self.add_line('   :type: ' + objrepr, sourcename)\n+                    # Fire autodoc-process-signature event to enable cross-reference processing\n+                    retann = stringify_typehint(signature.return_annotation)\n+                    self.env.events.emit_firstresult('autodoc-process-signature',\n+                                                     self.objtype, self.fullname,\n+                                                     func, self.options, '', retann)\n             except TypeError as exc:\n                 logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                                self.fullname, exc)\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..6e4ff4afd 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -20,14 +20,17 @@ from sphinx.application import Sphinx\n from sphinx.util import inspect, typing\n \n \n+\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n     try:\n-        if callable(obj):\n+        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n+            # Handle both regular callables and property objects\n+            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n+            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -37,6 +40,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         pass\n \n \n+\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n     if domain != 'py':\n         return\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976cd..04a14f44c 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2723,11 +2723,18 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         else:\n             func = None\n \n+\n         if func and self.config.autodoc_typehints != 'none':\n             try:\n                 signature = inspect.signature(func,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n+                    # Record the type annotation for cross-reference processing\n+                    annotations = self.env.temp_data.setdefault('annotations', {})\n+                    annotations[self.fullname] = {\n+                        'return': signature.return_annotation\n+                    }\n+                    # Let merge_typehints handle the cross-reference generation\n                     objrepr = stringify_typehint(signature.return_annotation)\n                     self.add_line('   :type: ' + objrepr, sourcename)\n             except TypeError as exc:\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..8251ee1ab 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -20,14 +20,17 @@ from sphinx.application import Sphinx\n from sphinx.util import inspect, typing\n \n \n+\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n     try:\n-        if callable(obj):\n+        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n+            # Handle both regular callables and property objects\n+            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n+            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -37,6 +40,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         pass\n \n \n+\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n     if domain != 'py':\n         return\n@@ -49,7 +53,7 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n             fullname = '.'.join([signature['module'], signature['fullname']])\n         else:\n             fullname = signature['fullname']\n-    except KeyError:\n+    except (KeyError, IndexError):\n         # signature node does not have valid context info for the target object\n         return\n \n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976cd..102aebe82 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2723,13 +2723,20 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         else:\n             func = None\n \n+\n         if func and self.config.autodoc_typehints != 'none':\n             try:\n                 signature = inspect.signature(func,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n-                    objrepr = stringify_typehint(signature.return_annotation)\n-                    self.add_line('   :type: ' + objrepr, sourcename)\n+                    # Store the type annotation for later processing by merge_typehints\n+                    annotations = self.env.temp_data.setdefault('annotations', {})\n+                    annotations[self.fullname] = {'return': signature.return_annotation}\n+                    \n+                    # Emit autodoc-process-signature event to enable cross-reference processing\n+                    self.env.app.emit('autodoc-process-signature',\n+                                    self.objtype, self.fullname, func, self.options, \n+                                    None, signature.return_annotation)\n             except TypeError as exc:\n                 logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                                self.fullname, exc)\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..8251ee1ab 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -20,14 +20,17 @@ from sphinx.application import Sphinx\n from sphinx.util import inspect, typing\n \n \n+\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n     try:\n-        if callable(obj):\n+        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n+            # Handle both regular callables and property objects\n+            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n+            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -37,6 +40,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         pass\n \n \n+\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n     if domain != 'py':\n         return\n@@ -49,7 +53,7 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n             fullname = '.'.join([signature['module'], signature['fullname']])\n         else:\n             fullname = signature['fullname']\n-    except KeyError:\n+    except (KeyError, IndexError):\n         # signature node does not have valid context info for the target object\n         return\n \n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976cd..efd678d9b 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2723,13 +2723,19 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         else:\n             func = None\n \n+\n         if func and self.config.autodoc_typehints != 'none':\n             try:\n                 signature = inspect.signature(func,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n-                    objrepr = stringify_typehint(signature.return_annotation)\n-                    self.add_line('   :type: ' + objrepr, sourcename)\n+                    # Use the event system to enable cross-reference generation for property types\n+                    retann = stringify_typehint(signature.return_annotation)\n+                    # Record the type annotation for later processing by merge_typehints\n+                    annotations = self.env.temp_data.setdefault('annotations', {})\n+                    annotations[self.fullname] = {'return': signature.return_annotation}\n+                    # Add the type line - cross-references will be processed later\n+                    self.add_line('   :type: ' + retann, sourcename)\n             except TypeError as exc:\n                 logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                                self.fullname, exc)\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..6e4ff4afd 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -20,14 +20,17 @@ from sphinx.application import Sphinx\n from sphinx.util import inspect, typing\n \n \n+\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n     try:\n-        if callable(obj):\n+        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n+            # Handle both regular callables and property objects\n+            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n+            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -37,6 +40,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         pass\n \n \n+\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n     if domain != 'py':\n         return\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976cd..bcf71c981 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2723,11 +2723,25 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         else:\n             func = None\n \n+\n         if func and self.config.autodoc_typehints != 'none':\n             try:\n                 signature = inspect.signature(func,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n+                    # Use the event system to enable cross-reference generation for property types\n+                    # Store the annotation for later processing by merge_typehints\n+                    annotations = self.env.temp_data.setdefault('annotations', {})\n+                    annotations[self.fullname] = {\n+                        'return': signature.return_annotation\n+                    }\n+                    \n+                    # Emit the event to allow other handlers to process the signature\n+                    retann = stringify_typehint(signature.return_annotation)\n+                    self.env.app.emit('autodoc-process-signature', \n+                                      self.objtype, self.fullname, func, self.options, '', retann)\n+                    \n+                    # Add the type line - merge_typehints will later enhance it with cross-references\n                     objrepr = stringify_typehint(signature.return_annotation)\n                     self.add_line('   :type: ' + objrepr, sourcename)\n             except TypeError as exc:\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..8251ee1ab 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -20,14 +20,17 @@ from sphinx.application import Sphinx\n from sphinx.util import inspect, typing\n \n \n+\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n     try:\n-        if callable(obj):\n+        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n+            # Handle both regular callables and property objects\n+            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n+            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -37,6 +40,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         pass\n \n \n+\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n     if domain != 'py':\n         return\n@@ -49,7 +53,7 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n             fullname = '.'.join([signature['module'], signature['fullname']])\n         else:\n             fullname = signature['fullname']\n-    except KeyError:\n+    except (KeyError, IndexError):\n         # signature node does not have valid context info for the target object\n         return\n \n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976cd..b4e8ae89d 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2723,13 +2723,21 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         else:\n             func = None\n \n+\n         if func and self.config.autodoc_typehints != 'none':\n             try:\n                 signature = inspect.signature(func,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n-                    objrepr = stringify_typehint(signature.return_annotation)\n-                    self.add_line('   :type: ' + objrepr, sourcename)\n+                    # Use the same event-driven approach as other documenters for cross-references\n+                    retann = stringify_typehint(signature.return_annotation)\n+                    # Store the annotation for later processing by merge_typehints\n+                    annotations = self.env.temp_data.setdefault('annotations', {})\n+                    annotations[self.fullname] = {'return': signature.return_annotation}\n+                    \n+                    # Fire the event to allow processing of the signature\n+                    self.env.app.emit('autodoc-process-signature', \n+                                      self.objtype, self.fullname, func, self.options, '', retann)\n             except TypeError as exc:\n                 logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                                self.fullname, exc)\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..8251ee1ab 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -20,14 +20,17 @@ from sphinx.application import Sphinx\n from sphinx.util import inspect, typing\n \n \n+\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n     try:\n-        if callable(obj):\n+        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n+            # Handle both regular callables and property objects\n+            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n+            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -37,6 +40,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         pass\n \n \n+\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n     if domain != 'py':\n         return\n@@ -49,7 +53,7 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n             fullname = '.'.join([signature['module'], signature['fullname']])\n         else:\n             fullname = signature['fullname']\n-    except KeyError:\n+    except (KeyError, IndexError):\n         # signature node does not have valid context info for the target object\n         return\n \n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976cd..197fa3f1c 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2723,13 +2723,20 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         else:\n             func = None\n \n+\n         if func and self.config.autodoc_typehints != 'none':\n             try:\n                 signature = inspect.signature(func,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n-                    objrepr = stringify_typehint(signature.return_annotation)\n-                    self.add_line('   :type: ' + objrepr, sourcename)\n+                    # Record the type annotation for cross-reference processing\n+                    annotations = self.env.temp_data.setdefault('annotations', {})\n+                    annotations[self.fullname] = signature.return_annotation\n+                    \n+                    # Fire autodoc-process-signature event to enable cross-reference processing\n+                    retann = stringify_typehint(signature.return_annotation)\n+                    self.env.app.emit('autodoc-process-signature', \n+                                      self.objtype, self.fullname, func, self.options, '', retann)\n             except TypeError as exc:\n                 logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                                self.fullname, exc)\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..8251ee1ab 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -20,14 +20,17 @@ from sphinx.application import Sphinx\n from sphinx.util import inspect, typing\n \n \n+\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n     try:\n-        if callable(obj):\n+        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n+            # Handle both regular callables and property objects\n+            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n+            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -37,6 +40,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         pass\n \n \n+\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n     if domain != 'py':\n         return\n@@ -49,7 +53,7 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n             fullname = '.'.join([signature['module'], signature['fullname']])\n         else:\n             fullname = signature['fullname']\n-    except KeyError:\n+    except (KeyError, IndexError):\n         # signature node does not have valid context info for the target object\n         return\n \n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976cd..bc674bb7e 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2723,13 +2723,20 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         else:\n             func = None\n \n+\n         if func and self.config.autodoc_typehints != 'none':\n             try:\n                 signature = inspect.signature(func,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n-                    objrepr = stringify_typehint(signature.return_annotation)\n-                    self.add_line('   :type: ' + objrepr, sourcename)\n+                    # Store the type annotation for later processing by merge_typehints\n+                    annotations = self.env.temp_data.setdefault('annotations', {})\n+                    annotations[self.fullname] = {'return': signature.return_annotation}\n+                    \n+                    # Emit autodoc-process-signature event to enable cross-reference processing\n+                    retann = stringify_typehint(signature.return_annotation)\n+                    self.env.app.emit('autodoc-process-signature',\n+                                      self.objtype, self.fullname, func, self.options, '', retann)\n             except TypeError as exc:\n                 logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                                self.fullname, exc)\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..8251ee1ab 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -20,14 +20,17 @@ from sphinx.application import Sphinx\n from sphinx.util import inspect, typing\n \n \n+\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n     try:\n-        if callable(obj):\n+        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n+            # Handle both regular callables and property objects\n+            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n+            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -37,6 +40,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         pass\n \n \n+\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n     if domain != 'py':\n         return\n@@ -49,7 +53,7 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n             fullname = '.'.join([signature['module'], signature['fullname']])\n         else:\n             fullname = signature['fullname']\n-    except KeyError:\n+    except (KeyError, IndexError):\n         # signature node does not have valid context info for the target object\n         return\n \n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976cd..3bc7c57e6 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2723,13 +2723,20 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         else:\n             func = None\n \n+\n         if func and self.config.autodoc_typehints != 'none':\n             try:\n                 signature = inspect.signature(func,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n-                    objrepr = stringify_typehint(signature.return_annotation)\n-                    self.add_line('   :type: ' + objrepr, sourcename)\n+                    # Use the same event-driven approach as other documenters for cross-references\n+                    retann = stringify_typehint(signature.return_annotation)\n+                    # Record the type annotation for later processing by merge_typehints\n+                    annotations = self.env.temp_data.setdefault('annotations', {})\n+                    annotations[self.fullname] = {'return': signature.return_annotation}\n+                    # Fire the event to allow for cross-reference processing\n+                    self.env.app.emit('autodoc-process-signature', \n+                                      self.objtype, self.fullname, func, self.options, '', retann)\n             except TypeError as exc:\n                 logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                                self.fullname, exc)\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..8251ee1ab 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -20,14 +20,17 @@ from sphinx.application import Sphinx\n from sphinx.util import inspect, typing\n \n \n+\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n     try:\n-        if callable(obj):\n+        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n+            # Handle both regular callables and property objects\n+            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n+            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -37,6 +40,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         pass\n \n \n+\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n     if domain != 'py':\n         return\n@@ -49,7 +53,7 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n             fullname = '.'.join([signature['module'], signature['fullname']])\n         else:\n             fullname = signature['fullname']\n-    except KeyError:\n+    except (KeyError, IndexError):\n         # signature node does not have valid context info for the target object\n         return\n \n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 938f976cd..8f92ea9ad 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -2723,11 +2723,17 @@ class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  #\n         else:\n             func = None\n \n+\n         if func and self.config.autodoc_typehints != 'none':\n             try:\n                 signature = inspect.signature(func,\n                                               type_aliases=self.config.autodoc_type_aliases)\n                 if signature.return_annotation is not Parameter.empty:\n+                    # Store the type annotation for cross-reference processing\n+                    annotations = self.env.temp_data.setdefault('annotations', {})\n+                    annotations[self.fullname] = {'return': signature.return_annotation}\n+                    \n+                    # Let the event system handle cross-reference generation\n                     objrepr = stringify_typehint(signature.return_annotation)\n                     self.add_line('   :type: ' + objrepr, sourcename)\n             except TypeError as exc:\ndiff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..6e4ff4afd 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -20,14 +20,17 @@ from sphinx.application import Sphinx\n from sphinx.util import inspect, typing\n \n \n+\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                      options: Dict, args: str, retann: str) -> None:\n     \"\"\"Record type hints to env object.\"\"\"\n     try:\n-        if callable(obj):\n+        if callable(obj) or (hasattr(obj, 'fget') and callable(obj.fget)):\n+            # Handle both regular callables and property objects\n+            target_obj = obj.fget if hasattr(obj, 'fget') else obj\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n+            sig = inspect.signature(target_obj, type_aliases=app.config.autodoc_type_aliases)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -37,6 +40,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         pass\n \n \n+\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n     if domain != 'py':\n         return\n"
  }
}