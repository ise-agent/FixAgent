{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/polys/factortools.py lines 1154-1155)": "\n    if len(factors) == 1:\n        # Check if this is truly irreducible or if we need to try direct factorization\n        # over the extension field for multivariate polynomials\n        if u == 0:  # univariate case\n            factors = [f]\n        else:  # multivariate case - try direct factorization\n            try:\n                # Attempt direct factorization over the extension field\n                direct_factors = dmp_factor_list_include(f, u, K)\n                if len(direct_factors) > 1:\n                    factors = [factor for factor, _ in direct_factors]\n                else:\n                    factors = [f]\n            except:\n                factors = [f]\n",
    "Location 2 (/root/hy/projects/sympy/sympy/polys/factortools.py lines 1149-1152)": "\n    if len(factors) == 1:\n        # Try direct factorization over the extension field when base field fails\n        try:\n            # Attempt multivariate factorization directly over the extension\n            direct_factors = []\n            temp_f = f\n            \n            # Try factoring each variable separately\n            for i in range(u + 1):\n                # Get polynomial in terms of variable i\n                var_poly = dmp_ground_content(temp_f, u, K)[1] if i == 0 else temp_f\n                \n                # Try univariate factorization for this variable level\n                if dmp_degree_in(var_poly, i, u) > 0:\n                    # Convert to univariate in variable i and factor\n                    uni_factors = []\n                    try:\n                        # Extract factors that are linear in variable i\n                        for deg in range(1, dmp_degree_in(var_poly, i, u) + 1):\n                            test_factor = dmp_extract_ground(var_poly, u, K, deg, i)\n                            if test_factor and not dmp_zero_p(test_factor, u):\n                                quotient, remainder = dmp_div(temp_f, test_factor, u, K)\n                                if dmp_zero_p(remainder, u):\n                                    direct_factors.append(test_factor)\n                                    temp_f = quotient\n                                    break\n                    except:\n                        pass\n            \n            if direct_factors and not dmp_one_p(temp_f, u, K):\n                direct_factors.append(temp_f)\n                factors = direct_factors\n            else:\n                factors = [f]\n        except:\n            factors = [f]\n",
    "Location 3 (/root/hy/projects/sympy/sympy/polys/polytools.py lines 5925-5927)": "\n            func = getattr(poly, method + '_list')\n\n            _coeff, _factors = func()\n            \n            # Validate that factorization is complete by checking if product equals original\n            if method in ('factor', 'sqf') and _factors:\n                from sympy.polys.polyclasses import DMP\n                if hasattr(poly, 'rep') and isinstance(poly.rep, DMP):\n                    # For multivariate polynomials, verify completeness\n                    product_check = _coeff\n                    for factor, exp in _factors:\n                        product_check *= factor**exp\n                    \n                    # If factorization is incomplete, try alternative approach\n                    if product_check != poly.as_expr() and hasattr(poly, 'domain') and hasattr(poly.domain, 'ext'):\n                        # For extension fields, attempt direct factorization\n                        try:\n                            from sympy.polys.factortools import dmp_ext_factor\n                            alt_coeff, alt_factors = dmp_ext_factor(poly.rep, poly.domain)\n                            if alt_factors and len(alt_factors) > len(_factors):\n                                _coeff, _factors = alt_coeff, alt_factors\n                        except:\n                            pass  # Fall back to original result\n",
    "Location 4 (/root/hy/projects/sympy/sympy/polys/factortools.py lines 1268-1269)": "\n    elif K0.is_Algebraic:\n        coeff, factors = dmp_ext_factor(f, u, K0)\n        # Validate that factorization is complete for multivariate polynomials\n        if u > 0 and len(factors) == 1 and factors[0][1] == 1:\n            # If we got only one factor, verify it's actually irreducible\n            # by checking if the product equals the original\n            reconstructed = dmp_mul(dmp_ground_LC(factors[0][0], u, K0), factors[0][0], u, K0)\n            if not dmp_zero_p(dmp_sub(f, reconstructed, u, K0), u):\n                # Try alternative factorization approach for multivariate case\n                try:\n                    # Attempt factorization by treating as univariate in each variable\n                    alt_coeff, alt_factors = _dmp_multivar_ext_factor(f, u, K0)\n                    if len(alt_factors) > 1:\n                        coeff, factors = alt_coeff, alt_factors\n                except:\n                    pass\n",
    "Location 5 (/root/hy/projects/sympy/sympy/polys/factortools.py lines 1165-1165)": "\n    # Validate that factors actually divide the polynomial completely\n    if factors:\n        product = dmp_one(u, K)\n        for factor in factors:\n            product = dmp_mul(product, factor, u, K)\n        \n        # If the product doesn't match F (up to leading coefficient), we have incomplete factorization\n        if not dmp_zero_p(dmp_sub(F, dmp_mul(product, lc, u, K), u, K), u):\n            # Fall back to direct factorization attempt\n            try:\n                direct_factors = []\n                remaining = F\n                # Try to extract more factors by direct division attempts\n                for base_factor, _ in dmp_factor_list_include(F, u, K.dom)[1]:\n                    converted = dmp_convert(base_factor, u, K.dom, K)\n                    if not dmp_zero_p(dmp_rem(remaining, converted, u, K), u):\n                        continue\n                    direct_factors.append(converted)\n                    remaining = dmp_quo(remaining, converted, u, K)\n                \n                if direct_factors and not dmp_one_p(remaining, u, K):\n                    direct_factors.append(remaining)\n                    factors = direct_factors\n            except:\n                pass\n    \n    return lc, dmp_trial_division(F, factors, u, K)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/polys/factortools.py lines 1154-1155)": [
      "\n    if len(factors) == 1:\n        # When factorization over base field yields only one factor,\n        # try direct factorization over the extension field\n        try:\n            ext_factors = dmp_factor_list_include(f, u, K)\n            if len(ext_factors) > 1:\n                factors = [factor for factor, _ in ext_factors]\n            else:\n                factors = [f]\n        except:\n            factors = [f]\n",
      "\n    if len(factors) == 1:\n        # If factorization over the base field yields only one factor,\n        # try direct factorization over the extension field for multivariate cases\n        if u > 0:  # multivariate case\n            try:\n                direct_factors = dmp_factor_list_include(f, u, K)\n                if len(direct_factors) > 1:\n                    factors = [factor for factor, _ in direct_factors]\n                else:\n                    factors = [f]\n            except:\n                factors = [f]\n        else:\n            factors = [f]\n",
      "\n    if len(factors) == 1:\n        # If factorization over the base domain yields only one factor,\n        # try direct factorization over the extension field for multivariate case\n        if u > 0:  # multivariate case\n            try:\n                # Attempt direct factorization of the original polynomial\n                direct_factors = dmp_factor_list_include(F, u, K)\n                if len(direct_factors) > 1:\n                    factors = [factor for factor, _ in direct_factors]\n                else:\n                    factors = [f]\n            except:\n                factors = [f]\n        else:\n            factors = [f]\n",
      "\n    if len(factors) == 1:\n        # Check if we have a trivial factorization over the base field\n        # but the polynomial might factor over the extension field\n        if u > 0:  # multivariate case\n            # Try direct factorization over the extension field\n            try:\n                direct_factors = dmp_factor_list_include(f, u, K)\n                if len(direct_factors) > 1:\n                    factors = [factor for factor, _ in direct_factors]\n                else:\n                    factors = [f]\n            except:\n                factors = [f]\n        else:\n            factors = [f]\n",
      "\n    if len(factors) == 1:\n        # If factorization over base field yields only one factor,\n        # try direct factorization over the extension field\n        try:\n            ext_factors = dmp_factor_list(f, u, K)\n            if len(ext_factors[1]) > 1:\n                # Found multiple factors over extension field\n                factors = [factor for factor, _ in ext_factors[1]]\n            else:\n                factors = [f]\n        except:\n            factors = [f]\n",
      "\n    if len(factors) == 1:\n        # When base field factorization yields only one factor, it might still\n        # be reducible over the extension field. Try direct factorization.\n        direct_factors = dmp_factor_list_include(f, u, K)\n        if len(direct_factors) > 1:\n            factors = [factor for factor, _ in direct_factors]\n        else:\n            factors = [f]\n",
      "\n    if len(factors) == 1:\n        # If factorization over K.dom yields only one factor, try direct factorization\n        # over the extension field for multivariate polynomials\n        if u > 0:  # multivariate case\n            try:\n                # Attempt direct factorization of the original polynomial\n                direct_factors = dmp_factor_list_include(f, u, K)\n                if len(direct_factors) > 1:\n                    factors = [factor for factor, _ in direct_factors]\n                else:\n                    factors = [f]\n            except:\n                factors = [f]\n        else:\n            factors = [f]\n",
      "\n    if len(factors) == 1:\n        # Check if the polynomial might factor over the extension field\n        # even if it doesn't factor over the base field\n        try:\n            # Try direct factorization over the extension field\n            alt_factors = dmp_factor_list(f, u, K)\n            if len(alt_factors[1]) > 1:\n                # Found additional factors over the extension field\n                factors = [factor for factor, _ in alt_factors[1]]\n            else:\n                factors = [f]\n        except (NotImplementedError, DomainError):\n            # Fall back to original behavior if extension field factorization fails\n            factors = [f]\n"
    ],
    "Location 2 (/root/hy/projects/sympy/sympy/polys/factortools.py lines 1149-1152)": [
      "\n    f, F = dmp_sqf_part(f, u, K), f\n    s, g, r = dmp_sqf_norm(f, u, K)\n\n    factors = dmp_factor_list_include(r, u, K.dom)\n",
      "\n    factors = dmp_factor_list_include(r, u, K.dom)\n\n    if len(factors) == 1:\n        # Try direct factorization over the extension field instead of assuming irreducibility\n        try:\n            # Attempt factorization using the original polynomial over the extension field\n            direct_factors = dmp_factor_list_include(F, u, K)\n            if len(direct_factors) > 1:\n                factors = direct_factors\n            else:\n                factors = [f]\n        except:\n            factors = [f]\n",
      "\n    if len(factors) == 1:\n        # If no factors found in the norm, try direct multivariate factorization\n        # over the extension field\n        from sympy.polys.factortools import dmp_factor_list\n        try:\n            direct_factors = dmp_factor_list(f, u, K)\n            if len(direct_factors[1]) > 1:\n                # Direct factorization succeeded, use those factors\n                factors = [factor for factor, _ in direct_factors[1]]\n            else:\n                # No factorization possible, polynomial is irreducible\n                factors = [f]\n        except:\n            # Fallback to treating as irreducible\n            factors = [f]\n    else:\n        H = dmp_raise([K.one, s*K.unit], u, 0, K)\n\n        for i, (factor, _) in enumerate(factors):\n            h = dmp_convert(factor, u, K.dom, K)\n            h, _, g = dmp_inner_gcd(h, g, u, K)\n            h = dmp_compose(h, H, u, K)\n",
      "\n    if len(factors) == 1:\n        # When base field factorization yields only one factor, try direct factorization\n        # over the extension field for multivariate polynomials\n        try:\n            # Attempt direct factorization over the extension field\n            alt_factors = dmp_factor_list_include(f, u, K)\n            if len(alt_factors) > 1:\n                factors = [factor for factor, _ in alt_factors]\n            else:\n                factors = [f]\n        except:\n            factors = [f]\n    else:\n        H = dmp_raise([K.one, s*K.unit], u, 0, K)\n\n        for i, (factor, _) in enumerate(factors):\n            h = dmp_convert(factor, u, K.dom, K)\n            h, _, g = dmp_inner_gcd(h, g, u, K)\n            h = dmp_compose(h, H, u, K)\n",
      "\n    if len(factors) == 1:\n        # When base field factorization returns only one factor, try direct factorization\n        # over the extension field before concluding the polynomial is irreducible\n        try:\n            # Attempt direct multivariate factorization over the extension field\n            direct_factors = []\n            temp_f = f\n            \n            # Try to find linear factors by substitution and factorization\n            # This handles cases where the norm-based approach misses factors\n            from sympy.polys.polytools import factor as poly_factor\n            from sympy.polys.domains import QQ\n            \n            # Convert to a form suitable for direct factorization attempts\n            if hasattr(K, 'ext') and K.ext is not None:\n                # For algebraic extensions, try factoring each variable separately\n                # and look for common factors\n                found_factors = False\n                remaining = temp_f\n                \n                # Check if we can factor out simpler polynomials\n                for var_idx in range(u + 1):\n                    # Try partial factorization by treating other variables as parameters\n                    partial_result = dmp_factor_list_include(remaining, u, K)\n                    if len(partial_result) > 1:\n                        direct_factors.extend([factor for factor, mult in partial_result])\n                        found_factors = True\n                        break\n                \n                if found_factors:\n                    factors = direct_factors\n                else:\n                    factors = [f]\n            else:\n                factors = [f]\n        except:\n            # Fall back to original behavior if direct factorization fails\n            factors = [f]\n",
      "\n    f, F = dmp_sqf_part(f, u, K), f\n    s, g, r = dmp_sqf_norm(f, u, K)\n\n    factors = dmp_factor_list_include(r, u, K.dom)\n",
      "\n    if len(factors) == 1:\n        # The polynomial may still be reducible over the extension field\n        # even if it appears irreducible over the base field\n        # Try direct factorization over the extension field\n        try:\n            # Attempt to factor directly over the extension field\n            ext_factors = dmp_factor_list_include(f, u, K)\n            if len(ext_factors) > 1:\n                factors = [factor for factor, _ in ext_factors]\n            else:\n                factors = [f]\n        except:\n            factors = [f]\n",
      "\n    if len(factors) == 1:\n        # Try direct factorization over the extension field when base field factorization fails\n        try:\n            # Attempt multivariate factorization directly over the extension field\n            direct_factors = []\n            temp_f = f\n            \n            # Try factoring each variable separately\n            for i in range(u + 1):\n                if dmp_degree_in(temp_f, i, u) > 0:\n                    # Check if we can factor out linear terms in variable i\n                    var_factors = []\n                    for j in range(dmp_degree_in(temp_f, i, u) + 1):\n                        # Try to find linear factors by substitution\n                        test_poly = dmp_eval_in(temp_f, K.zero, i, u)\n                        if not test_poly or dmp_zero_p(test_poly, u-1):\n                            # Found a factor, extract it\n                            linear_factor = dmp_from_dict({(0,) * i + (1,) + (0,) * (u-i): K.one}, u, K)\n                            if i < u:\n                                linear_factor = dmp_add_term(linear_factor, K.zero, (0,) * (u+1), u, K)\n                            var_factors.append(linear_factor)\n                    \n                    if var_factors:\n                        direct_factors.extend(var_factors)\n                        for factor in var_factors:\n                            temp_f, _ = dmp_div(temp_f, factor, u, K)\n            \n            if direct_factors:\n                if not dmp_one_p(temp_f, u, K):\n                    direct_factors.append(temp_f)\n                factors = direct_factors\n            else:\n                factors = [f]\n        except:\n            factors = [f]\n    else:\n"
    ],
    "Location 3 (/root/hy/projects/sympy/sympy/polys/polytools.py lines 5925-5927)": [
      "\n            func = getattr(poly, method + '_list')\n\n            _coeff, _factors = func()\n            \n            # Validate that the factorization is complete\n            if method in ('factor', 'sqf') and _factors:\n                from sympy import expand\n                reconstructed = _coeff * reduce(mul, [base**exp for base, exp in _factors], S.One)\n                if not expand(reconstructed - poly.as_expr()).is_zero:\n                    # If factorization is incomplete, fall back to original expression\n                    factors.append((base, exp))\n                    continue\n",
      "\n            func = getattr(poly, method + '_list')\n            \n            _coeff, _factors = func()\n            \n            # Validate that the factorization is complete\n            if method in ['factor', 'sqf_factor']:\n                from sympy.core.mul import Mul\n                product = _coeff\n                for factor, exp in _factors:\n                    product *= factor**exp\n                \n                # If factorization is incomplete, try alternative methods\n                if not poly.equals(product):\n                    # For extension fields, try direct factorization\n                    if hasattr(poly.domain, 'ext') and poly.domain.ext:\n                        try:\n                            alt_func = getattr(poly, 'factor_list')\n                            _coeff, _factors = alt_func()\n                        except (AttributeError, PolificationFailed):\n                            pass\n",
      "\n            func = getattr(poly, method + '_list')\n\n            _coeff, _factors = func()\n            \n            # Validate that factorization is complete by checking the product\n            if _factors and method in ('factor', 'sqf'):\n                from sympy.polys.polytools import expand\n                product = _coeff\n                for factor, exp in _factors:\n                    product *= factor**exp\n                \n                # If factorization is incomplete, try alternative methods\n                if not poly.equals(product):\n                    # For extension fields, try direct factorization\n                    if hasattr(poly.rep, 'dom') and hasattr(poly.rep.dom, 'ext'):\n                        try:\n                            alt_func = getattr(poly, 'factor_list')\n                            _coeff, _factors = alt_func()\n                        except (AttributeError, PolynomialError):\n                            pass\n",
      "\n            func = getattr(poly, method + '_list')\n\n            _coeff, _factors = func()\n            \n            # Validate that the factorization is complete\n            if method in ['factor', 'sqf_factor'] and len(_factors) > 0:\n                # Check if the product of factors equals the original polynomial\n                from sympy.core.mul import Mul\n                reconstructed = _coeff * Mul(*[base**exp for base, exp in _factors])\n                if not poly.as_expr().equals(reconstructed):\n                    # If factorization is incomplete, fall back to original expression\n                    factors.append((base, exp))\n                    continue\n",
      "\n            func = getattr(poly, method + '_list')\n\n            _coeff, _factors = func()\n            \n            # Validate that factorization is complete by checking if product equals original\n            if method in ('factor', 'sqf') and _factors:\n                from sympy.polys.polyfuncs import symmetrize\n                product = _coeff\n                for factor, exp in _factors:\n                    product *= factor**exp\n                \n                # If factorization is incomplete, try alternative methods\n                if not poly.equals(product):\n                    # For extension fields, try direct factorization\n                    if hasattr(poly.domain, 'ext') and poly.domain.ext:\n                        try:\n                            alt_func = getattr(poly, 'factor_list')\n                            _coeff, _factors = alt_func()\n                        except (AttributeError, PolificationFailed):\n                            pass\n",
      "\n            func = getattr(poly, method + '_list')\n\n            _coeff, _factors = func()\n            \n            # Validate that factorization is complete by checking if product equals original\n            if method in ('factor', 'sqf') and _factors:\n                from sympy.polys.polyclasses import DMP\n                if hasattr(poly, 'rep') and isinstance(poly.rep, DMP):\n                    # For multivariate polynomials, verify completeness\n                    product_check = _coeff\n                    for factor, exp in _factors:\n                        if hasattr(factor, '__pow__'):\n                            product_check *= factor ** exp\n                        else:\n                            # Handle case where factor might be a coefficient\n                            product_check *= factor\n                    \n                    # If factorization is incomplete, try alternative approach\n                    if product_check != poly.as_expr():\n                        # Attempt direct factorization over extension field if available\n                        if hasattr(poly, 'get_domain') and hasattr(poly.get_domain(), 'ext'):\n                            try:\n                                from sympy.polys.factortools import dmp_ext_factor\n                                alt_factors = dmp_ext_factor(poly.rep, poly.get_domain())\n                                if alt_factors and len(alt_factors[1]) > len(_factors):\n                                    _coeff, _factors = alt_factors\n                            except:\n                                pass  # Fall back to original result\n",
      "\n            func = getattr(poly, method + '_list')\n\n            _coeff, _factors = func()\n            \n            # Validate factorization completeness for extension fields\n            if hasattr(opt, 'extension') and opt.extension:\n                from sympy.polys.polyclasses import DMP\n                # Check if the product of factors equals original polynomial\n                if _factors:\n                    product = poly.one\n                    for factor, exp in _factors:\n                        product *= DMP.from_list(factor, poly.domain, poly.ring)**exp\n                    if _coeff != S.One:\n                        product *= _coeff\n                    \n                    # If factorization is incomplete, try alternative methods\n                    if not poly.eq(product):\n                        try:\n                            # Attempt direct factorization over extension field\n                            alt_coeff, alt_factors = poly.factor_list()\n                            if alt_factors and len(alt_factors) > len(_factors):\n                                _coeff, _factors = alt_coeff, alt_factors\n                        except:\n                            pass\n",
      "\n            func = getattr(poly, method + '_list')\n\n            _coeff, _factors = func()\n            \n            # Validate that the factorization is complete\n            if method in ('factor', 'sqf') and _factors:\n                # Check if the product of factors equals the original polynomial\n                from sympy.core.mul import Mul\n                factor_product = Mul(*[base**exp for base, exp in _factors]) * _coeff\n                if not poly.as_expr().equals(factor_product):\n                    # If factorization is incomplete, fall back to original expression\n                    factors.append((base, exp))\n                    continue\n"
    ],
    "Location 4 (/root/hy/projects/sympy/sympy/polys/factortools.py lines 1268-1269)": [
      "\n    elif K0.is_Algebraic:\n        coeff, factors = dmp_ext_factor(f, u, K0)\n        # Verify completeness of factorization for multivariate polynomials\n        if u > 0 and len(factors) > 0:\n            # Check if product of factors equals original polynomial\n            product = dmp_mul(dmp_ground_LC(f, u, K0), u, K0)\n            for factor, exp in factors:\n                for _ in range(exp):\n                    product = dmp_mul(product, factor, u, K0)\n            if not dmp_zero_p(dmp_sub(f, product, u, K0), u):\n                # Fallback: try direct factorization if extension field method is incomplete\n                try:\n                    alt_coeff, alt_factors = dmp_factor_list_include(f, u, K0.dom)\n                    if len(alt_factors) > len(factors):\n                        coeff, factors = alt_coeff, alt_factors\n                except:\n                    pass\n",
      "\n    elif K0.is_Algebraic:\n        coeff, factors = dmp_ext_factor(f, u, K0)\n        # Validate that factorization is complete for multivariate polynomials\n        if len(factors) == 1 and u > 0:\n            # Try alternative factorization approach for multivariate case\n            from sympy.polys.factortools import dmp_factor_list_include\n            try:\n                # Attempt factorization by treating as polynomial over base field\n                base_factors = dmp_factor_list_include(f, u, K0.dom)\n                if len(base_factors[1]) > 1:\n                    # Convert base field factors to extension field\n                    ext_factors = []\n                    for base_factor in base_factors[1]:\n                        ext_factor = dmp_convert(base_factor[0], u, K0.dom, K0)\n                        ext_factors.append((ext_factor, base_factor[1]))\n                    if ext_factors:\n                        coeff, factors = base_factors[0], ext_factors\n            except (DomainError, NotImplementedError):\n                pass\n",
      "\n    elif K0.is_Algebraic:\n        # For algebraic extensions, we need to ensure complete factorization\n        # especially for multivariate polynomials\n        coeff, factors = dmp_ext_factor(f, u, K0)\n        \n        # Validate that the factorization is complete by checking if the product\n        # of factors equals the original polynomial\n        if factors:\n            product = dmp_one(u, K0)\n            for factor, mult in factors:\n                for _ in range(mult):\n                    product = dmp_mul(product, factor, u, K0)\n            product = dmp_mul_ground(product, coeff, u, K0)\n            \n            # If the product doesn't match, the factorization may be incomplete\n            # This can happen with multivariate polynomials over extension fields\n            if not dmp_zero_p(dmp_sub(f, product, u, K0), u):\n                # Fallback: try alternative factorization approaches\n                # or return the original polynomial as irreducible\n                coeff, factors = K0.one, [(f, 1)]\n",
      "\n    elif K0.is_Algebraic:\n        coeff, factors = dmp_ext_factor(f, u, K0)\n        # Verify completeness of factorization for multivariate polynomials\n        if len(factors) == 1 and u > 0:\n            # Check if the single factor is actually the original polynomial\n            # indicating incomplete factorization\n            factor_poly = factors[0][0]\n            if dmp_cmp(factor_poly, f, u, K0) == 0:\n                # Try alternative factorization approach for multivariate case\n                try:\n                    # Attempt factorization by treating as univariate in each variable\n                    alt_factors = []\n                    for i in range(u + 1):\n                        # Convert to univariate in variable i\n                        f_uni = dmp_to_dict(f, u, K0)\n                        if f_uni:\n                            # Try factoring as univariate and see if we get more factors\n                            temp_factors = []\n                            for var_power, coeff_poly in f_uni.items():\n                                if any(var_power):  # Non-constant term\n                                    try:\n                                        var_factors = dmp_ext_factor(coeff_poly, u-1, K0) if u > 1 else dup_ext_factor(coeff_poly, K0)\n                                        temp_factors.extend(var_factors[1])\n                                    except:\n                                        continue\n                            if len(temp_factors) > 1:\n                                alt_factors = temp_factors\n                                break\n                    if alt_factors:\n                        factors = alt_factors\n                except:\n                    pass  # Fall back to original result\n",
      "\n    elif K0.is_Algebraic:\n        coeff, factors = dmp_ext_factor(f, u, K0)\n        # Verify that factorization is complete for multivariate polynomials\n        if u > 0 and len(factors) == 1 and factors[0][1] == 1:\n            # If only one factor found, check if it's actually irreducible\n            test_poly = factors[0][0]\n            if not dmp_zero_p(dmp_sub(f, test_poly, u, K0), u):\n                # Factor doesn't match original, try alternative approach\n                from sympy.polys.polytools import Poly\n                from sympy import symbols\n                try:\n                    # Convert to Poly and attempt factorization with extension handling\n                    vars_list = [symbols(f'x_{i}') for i in range(u + 1)]\n                    poly_obj = Poly.from_list(f, *vars_list, domain=K0)\n                    alt_factors = poly_obj.factor_list()\n                    if len(alt_factors[1]) > 1:\n                        # Convert back to dense representation\n                        coeff = alt_factors[0]\n                        factors = [(factor.rep.rep, mult) for factor, mult in alt_factors[1]]\n                except:\n                    pass  # Fall back to original result if conversion fails\n",
      "\n    elif K0.is_Algebraic:\n        coeff, factors = dmp_ext_factor(f, u, K0)\n        # Verify that the factorization is complete by checking the product\n        if factors:\n            product = dmp_one(u, K0)\n            for factor, exp in factors:\n                for _ in range(exp):\n                    product = dmp_mul(product, factor, u, K0)\n            product = dmp_mul(product, coeff, u, K0)\n            if not dmp_zero_p(dmp_sub(product, f, u, K0), u):\n                # Factorization incomplete, try alternative approach\n                # Fall back to ground field factorization and lift\n                if hasattr(K0, 'dom') and K0.dom != K0:\n                    try:\n                        f_ground = dmp_convert(f, u, K0, K0.dom)\n                        coeff_alt, factors_alt = dmp_factor_list(f_ground, u, K0.dom)\n                        # Convert factors back to extension field\n                        factors_converted = []\n                        for factor, exp in factors_alt:\n                            factor_ext = dmp_convert(factor, u, K0.dom, K0)\n                            factors_converted.append((factor_ext, exp))\n                        coeff = dmp_convert(coeff_alt, u, K0.dom, K0)\n                        factors = factors_converted\n                    except:\n                        pass  # Keep original result if conversion fails\n",
      "\n    elif K0.is_Algebraic:\n        coeff, factors = dmp_ext_factor(f, u, K0)\n        # Validate that extension field factorization is complete\n        if len(factors) == 1 and factors[0][1] == 1:\n            # If only one factor found, verify it's truly irreducible\n            # by checking if the product equals the original\n            reconstructed = dmp_mul(dmp_pow(factors[0][0], factors[0][1], u, K0), \n                                  dmp_ground(coeff, u, K0), u, K0)\n            if not dmp_zero_p(dmp_sub(f, reconstructed, u, K0), u):\n                # Factorization incomplete, attempt alternative approach\n                coeff, factors = dmp_factor_list(f, u, K0.dom), []\n",
      "\n    elif K0.is_Algebraic:\n        coeff, factors = dmp_ext_factor(f, u, K0)\n        # Validate that the factorization is complete for multivariate polynomials\n        if len(factors) == 1 and u > 0:\n            # Try alternative factorization approach for multivariate case\n            try:\n                # Attempt factorization by converting to univariate in each variable\n                alt_factors = []\n                for i in range(u + 1):\n                    # Try factoring as univariate in variable i\n                    f_uni = dmp_convert_to_univariate(f, u, i, K0)\n                    if f_uni is not None:\n                        uni_factors = dup_factor_list(f_uni, K0)[1]\n                        if len(uni_factors) > 1:\n                            # Convert back to multivariate factors\n                            for factor_poly, mult in uni_factors:\n                                mv_factor = dmp_convert_from_univariate(factor_poly, u, i, K0)\n                                alt_factors.append((mv_factor, mult))\n                            break\n                \n                if len(alt_factors) > 1:\n                    factors = alt_factors\n                    # Recompute coefficient to maintain polynomial equality\n                    factor_product = dmp_one(u, K0)\n                    for factor_poly, mult in factors:\n                        for _ in range(mult):\n                            factor_product = dmp_mul(factor_product, factor_poly, u, K0)\n                    coeff = dmp_quo(f, factor_product, u, K0) if not dmp_zero_p(factor_product, u) else coeff\n            except:\n                # Fall back to original result if alternative approach fails\n                pass\n"
    ],
    "Location 5 (/root/hy/projects/sympy/sympy/polys/factortools.py lines 1165-1165)": [
      "\n    return lc, dmp_trial_division(F, factors, u, K)\n",
      "\n    if len(factors) == 1:\n        # Don't assume the polynomial is irreducible - it might factor over the extension field\n        # even if it doesn't factor over the base field. Try direct factorization.\n        try:\n            # Attempt to factor directly over the extension field\n            ext_factors = dmp_factor_list(f, u, K)\n            if len(ext_factors[1]) > 1:\n                # Found additional factors over the extension field\n                factors = ext_factors[1]\n            else:\n                factors = [f]\n        except:\n            factors = [f]\n    else:\n        H = dmp_raise([K.one, s*K.unit], u, 0, K)\n\n        for i, (factor, _) in enumerate(factors):\n            h = dmp_convert(factor, u, K.dom, K)\n            h, _, g = dmp_inner_gcd(h, g, u, K)\n            h = dmp_compose(h, H, u, K)\n            factors[i] = h\n\n    return lc, dmp_trial_division(F, factors, u, K)\n",
      "\n    if len(factors) == 1:\n        # Don't assume irreducibility - attempt direct factorization over extension field\n        # Try to factor the polynomial directly in the extension field\n        try:\n            # Convert back to the extension field and attempt factorization\n            f_ext = dmp_convert(f, u, K.dom, K)\n            # Try factorization with different approaches for multivariate case\n            if u > 0:  # multivariate case\n                # Use content-primitive decomposition and recursive factorization\n                content, primitive = dmp_ground_content(f_ext, u, K)\n                if not dmp_zero_p(dmp_sub(primitive, f_ext, u, K), u, K):\n                    # If there's non-trivial content, factor both parts\n                    prim_factors = dmp_factor_list_include(primitive, u, K)\n                    if len(prim_factors[1]) > 1:\n                        factors = [(dmp_convert(factor, u, K, K.dom), mult) \n                                 for factor, mult in prim_factors[1]]\n                    else:\n                        factors = [f]\n                else:\n                    factors = [f]\n            else:\n                factors = [f]\n        except (NotImplementedError, DomainError):\n            factors = [f]\n",
      "\n    return lc, _validate_and_complete_factorization(F, dmp_trial_division(F, factors, u, K), u, K)\n\n\ndef _validate_and_complete_factorization(original, result, u, K):\n    \"\"\"Validate factorization completeness and attempt recovery if incomplete.\"\"\"\n    lc, factors = result\n    \n    # Check if factorization is complete by multiplying factors\n    if factors:\n        product = factors[0][0]\n        for factor, mult in factors[1:]:\n            for _ in range(mult):\n                product = dmp_mul(product, factor, u, K)\n        for factor, mult in factors[:1]:\n            for _ in range(mult - 1):\n                product = dmp_mul(product, factor, u, K)\n        \n        # Scale by leading coefficient\n        expected = dmp_mul_ground(original, lc, u, K) if lc != K.one else original\n        \n        if not dmp_zero_p(dmp_sub(product, expected, u, K), u):\n            # Factorization incomplete, attempt direct factorization\n            try:\n                direct_result = dmp_factor_list(original, u, K)\n                if len(direct_result[1]) > len(factors):\n                    return direct_result\n            except:\n                pass\n    \n    return lc, factors\n",
      "\n    return lc, _validate_and_complete_factorization(F, dmp_trial_division(F, factors, u, K), u, K)\n\ndef _validate_and_complete_factorization(original, result, u, K):\n    \"\"\"Validate factorization completeness and attempt completion if needed.\"\"\"\n    lc, factors = result\n    \n    # Check if product of factors equals original (accounting for leading coefficient)\n    if factors:\n        product = dmp_mul(dmp_ground(lc, u, K), factors[0][0], u, K)\n        for factor, exp in factors[1:]:\n            for _ in range(exp):\n                product = dmp_mul(product, factor, u, K)\n        \n        if dmp_cmp(product, original, u, K) == 0:\n            return result\n    \n    # If validation fails and we have extension field, try alternative methods\n    if hasattr(K, 'ext') and K.ext:\n        # For extension fields, attempt direct factorization if trial division incomplete\n        try:\n            alt_factors = []\n            remaining = dmp_quo(original, dmp_ground(lc, u, K), u, K) if lc != K.one else original\n            \n            for factor, exp in factors:\n                for _ in range(exp):\n                    remaining = dmp_quo(remaining, factor, u, K)\n            \n            # If there's remaining unfactored part, try to factor it\n            if not dmp_one_p(remaining, u, K):\n                additional = dmp_factor_list(remaining, u, K)[1]\n                factors.extend(additional)\n        except:\n            pass\n    \n    return lc, factors\n",
      "\n    if len(factors) == 1:\n        # Don't assume irreducibility - try direct factorization over extension field\n        # First attempt factorization using the extension field directly\n        try:\n            ext_factors = dmp_factor_list_include(f, u, K)\n            if len(ext_factors) > 1:\n                factors = ext_factors\n            else:\n                factors = [f]\n        except:\n            factors = [f]\n    else:\n",
      "\n    if len(factors) == 1:\n        # Don't assume irreducibility - try direct factorization over extension field\n        # when base field factorization yields only one factor\n        try:\n            # Attempt factorization directly over the extension field K\n            direct_factors = dmp_factor_list_include(f, u, K)\n            if len(direct_factors) > 1:\n                # Direct factorization found multiple factors\n                factors = direct_factors\n            else:\n                # If still only one factor, then it's truly irreducible\n                factors = [f]\n        except (NotImplementedError, DomainError):\n            # Fall back to original behavior if direct factorization fails\n            factors = [f]\n    else:\n",
      "\n    # Validate factorization completeness before returning\n    if len(factors) == 1:\n        # Try direct factorization over the extension field\n        try:\n            # Attempt multivariate factorization by treating as univariate in each variable\n            from sympy.polys.polytools import factor_list\n            from sympy.polys.domains import QQ\n            \n            # Convert to a form suitable for direct factorization\n            result_factors = []\n            temp_poly = dmp_convert(f, u, K, QQ)\n            \n            # Try factoring directly if possible\n            direct_factors = dmp_trial_division(F, [f], u, K)\n            if len(direct_factors) > 1 or direct_factors[0][1] > 1:\n                return lc, direct_factors\n            \n            # If still only one factor, return the original factorization attempt\n            factors = [f]\n        except:\n            factors = [f]\n    \n    return lc, dmp_trial_division(F, factors, u, K)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..05cb5cad77 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1146,13 +1146,58 @@ def dmp_ext_factor(f, u, K):\n     if all(d <= 0 for d in dmp_degree_list(f, u)):\n         return lc, []\n \n+\n     f, F = dmp_sqf_part(f, u, K), f\n     s, g, r = dmp_sqf_norm(f, u, K)\n \n     factors = dmp_factor_list_include(r, u, K.dom)\n+    \n+    # For extension fields, if base domain factorization is insufficient,\n+    # try alternative approaches\n+    if len(factors) <= 1 and hasattr(K, 'dom') and K.dom != K:\n+        try:\n+            # Try factorization over a simpler base field\n+            from sympy.polys.domains import QQ\n+            if K.dom != QQ:\n+                alt_factors = dmp_factor_list_include(r, u, QQ)\n+                if len(alt_factors) > len(factors):\n+                    factors = alt_factors\n+        except:\n+            pass\n+\n \n     if len(factors) == 1:\n-        factors = [f]\n+        # Try direct factorization over the extension field when base domain\n+        # factorization appears to show irreducibility\n+        try:\n+            # Attempt to factor directly over the extension field\n+            from sympy.polys.polytools import Poly\n+            from sympy.polys.domains import QQ\n+            \n+            # Convert to symbolic form and try factorization\n+            poly_f = Poly.from_list(f, domain=K)\n+            if poly_f.is_multivariate:\n+                # For multivariate polynomials, try factorization over base field first\n+                base_factors = []\n+                try:\n+                    base_poly = Poly.from_list(f, domain=K.dom if hasattr(K, 'dom') else QQ)\n+                    base_coeff, base_factor_list = base_poly.factor_list()\n+                    if len(base_factor_list) > 1:\n+                        # Convert base field factors back to extension field\n+                        for factor, mult in base_factor_list:\n+                            factor_dmp = factor.rep.rep\n+                            base_factors.append(dmp_convert(factor_dmp, u, K.dom if hasattr(K, 'dom') else QQ, K))\n+                        if base_factors:\n+                            factors = base_factors\n+                except:\n+                    pass\n+            \n+            # If no factors found, keep original behavior\n+            if len(factors) == 1:\n+                factors = [f]\n+        except:\n+            # Fallback to original behavior if anything fails\n+            factors = [f]\n     else:\n         H = dmp_raise([K.one, s*K.unit], u, 0, K)\n \n@@ -1162,6 +1207,39 @@ def dmp_ext_factor(f, u, K):\n             h = dmp_compose(h, H, u, K)\n             factors[i] = h\n \n+\n+    # Validate factors before trial division\n+    if factors:\n+        try:\n+            # Check if factors multiply back to original polynomial\n+            from sympy.polys.densetools import dmp_mul\n+            product = dmp_ground(lc, u, K)\n+            for factor in factors:\n+                product = dmp_mul(product, factor, u, K)\n+            \n+            # If product doesn't match F, there might be missing factors\n+            if not dmp_equal_p(product, F, u, K):\n+                # Try to find missing factors by polynomial division\n+                quotient = F\n+                verified_factors = []\n+                for factor in factors:\n+                    try:\n+                        q, r = dmp_div(quotient, factor, u, K)\n+                        if dmp_zero_p(r, u):\n+                            verified_factors.append(factor)\n+                            quotient = q\n+                    except:\n+                        verified_factors.append(factor)\n+                \n+                # Add any remaining quotient as a factor if it's not constant\n+                if not dmp_ground_p(quotient, None, u) and not dmp_one_p(quotient, u, K):\n+                    verified_factors.append(quotient)\n+                \n+                if verified_factors:\n+                    factors = verified_factors\n+        except:\n+            pass\n+    \n     return lc, dmp_trial_division(F, factors, u, K)\n \n \n@@ -1265,8 +1343,31 @@ def dmp_factor_list(f, u, K0):\n \n     if K0.is_FiniteField:  # pragma: no cover\n         coeff, factors = dmp_gf_factor(f, u, K0)\n+\n     elif K0.is_Algebraic:\n         coeff, factors = dmp_ext_factor(f, u, K0)\n+        \n+        # Validate that extension field factorization is complete\n+        if factors:\n+            try:\n+                # Check if we have a complete factorization\n+                from sympy.polys.densetools import dmp_mul\n+                product = dmp_ground(coeff, u, K0)\n+                for factor, mult in factors:\n+                    for _ in range(mult):\n+                        product = dmp_mul(product, factor, u, K0)\n+                \n+                # If factorization seems incomplete, try base field approach\n+                if dmp_degree_in(product, 0, u) != dmp_degree_in(f, 0, u) or \\\n+                   (u > 0 and dmp_degree_in(product, 1, u) != dmp_degree_in(f, 1, u)):\n+                    # Try factorization over base domain\n+                    base_coeff, base_factors = dmp_factor_list(f, u, K0.dom)\n+                    if len(base_factors) > len(factors):\n+                        # Convert base factors to extension field\n+                        factors = [(dmp_convert(bf, u, K0.dom, K0), bm) for bf, bm in base_factors]\n+                        coeff = K0.convert(base_coeff, K0.dom)\n+            except:\n+                pass\n     else:\n         if not K0.is_Exact:\n             K0_inexact, K0 = K0, K0.get_exact()\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 68b69d1a24..fd4a7cefd0 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5922,9 +5922,33 @@ def _symbolic_factor_list(expr, opt, method):\n         except PolificationFailed as exc:\n             factors.append((exc.expr, exp))\n         else:\n+\n             func = getattr(poly, method + '_list')\n \n             _coeff, _factors = func()\n+            \n+            # Validate factorization completeness for extension fields\n+            if hasattr(poly, 'domain') and hasattr(poly.domain, 'is_Algebraic') and poly.domain.is_Algebraic:\n+                # Check if factorization is complete by verifying the product\n+                if _factors:\n+                    try:\n+                        from sympy.polys.polytools import Poly\n+                        product = _coeff\n+                        for factor, mult in _factors:\n+                            product *= factor**mult\n+                        \n+                        # If product doesn't match original, try alternative factorization\n+                        if not poly.equals(product):\n+                            # Try factorization over base field and convert\n+                            base_domain = poly.domain.dom if hasattr(poly.domain, 'dom') else poly.domain\n+                            base_poly = poly.set_domain(base_domain)\n+                            base_coeff, base_factors = base_poly.factor_list()\n+                            if len(base_factors) > len(_factors):\n+                                # Convert back to extension field\n+                                _coeff = base_coeff\n+                                _factors = [(f.set_domain(poly.domain), m) for f, m in base_factors]\n+                    except:\n+                        pass\n             if _coeff is not S.One:\n                 if exp.is_Integer:\n                     coeff *= _coeff**exp\n",
    "variant_0": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..66b2fc98e7 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1146,13 +1146,60 @@ def dmp_ext_factor(f, u, K):\n     if all(d <= 0 for d in dmp_degree_list(f, u)):\n         return lc, []\n \n-    f, F = dmp_sqf_part(f, u, K), f\n-    s, g, r = dmp_sqf_norm(f, u, K)\n \n-    factors = dmp_factor_list_include(r, u, K.dom)\n+    if len(factors) == 1:\n+        # Try direct factorization over the extension field when base field fails\n+        try:\n+            # Attempt multivariate factorization directly over the extension\n+            direct_factors = []\n+            temp_f = f\n+            \n+            # Try factoring each variable separately\n+            for i in range(u + 1):\n+                # Get polynomial in terms of variable i\n+                var_poly = dmp_ground_content(temp_f, u, K)[1] if i == 0 else temp_f\n+                \n+                # Try univariate factorization for this variable level\n+                if dmp_degree_in(var_poly, i, u) > 0:\n+                    # Convert to univariate in variable i and factor\n+                    uni_factors = []\n+                    try:\n+                        # Extract factors that are linear in variable i\n+                        for deg in range(1, dmp_degree_in(var_poly, i, u) + 1):\n+                            test_factor = dmp_extract_ground(var_poly, u, K, deg, i)\n+                            if test_factor and not dmp_zero_p(test_factor, u):\n+                                quotient, remainder = dmp_div(temp_f, test_factor, u, K)\n+                                if dmp_zero_p(remainder, u):\n+                                    direct_factors.append(test_factor)\n+                                    temp_f = quotient\n+                                    break\n+                    except:\n+                        pass\n+            \n+            if direct_factors and not dmp_one_p(temp_f, u, K):\n+                direct_factors.append(temp_f)\n+                factors = direct_factors\n+            else:\n+                factors = [f]\n+        except:\n+            factors = [f]\n+\n \n     if len(factors) == 1:\n-        factors = [f]\n+        # Check if this is truly irreducible or if we need to try direct factorization\n+        # over the extension field for multivariate polynomials\n+        if u == 0:  # univariate case\n+            factors = [f]\n+        else:  # multivariate case - try direct factorization\n+            try:\n+                # Attempt direct factorization over the extension field\n+                direct_factors = dmp_factor_list_include(f, u, K)\n+                if len(direct_factors) > 1:\n+                    factors = [factor for factor, _ in direct_factors]\n+                else:\n+                    factors = [f]\n+            except:\n+                factors = [f]\n     else:\n         H = dmp_raise([K.one, s*K.unit], u, 0, K)\n \n@@ -1162,6 +1209,33 @@ def dmp_ext_factor(f, u, K):\n             h = dmp_compose(h, H, u, K)\n             factors[i] = h\n \n+\n+    # Validate that factors actually divide the polynomial completely\n+    if factors:\n+        product = dmp_one(u, K)\n+        for factor in factors:\n+            product = dmp_mul(product, factor, u, K)\n+        \n+        # If the product doesn't match F (up to leading coefficient), we have incomplete factorization\n+        if not dmp_zero_p(dmp_sub(F, dmp_mul(product, lc, u, K), u, K), u):\n+            # Fall back to direct factorization attempt\n+            try:\n+                direct_factors = []\n+                remaining = F\n+                # Try to extract more factors by direct division attempts\n+                for base_factor, _ in dmp_factor_list_include(F, u, K.dom)[1]:\n+                    converted = dmp_convert(base_factor, u, K.dom, K)\n+                    if not dmp_zero_p(dmp_rem(remaining, converted, u, K), u):\n+                        continue\n+                    direct_factors.append(converted)\n+                    remaining = dmp_quo(remaining, converted, u, K)\n+                \n+                if direct_factors and not dmp_one_p(remaining, u, K):\n+                    direct_factors.append(remaining)\n+                    factors = direct_factors\n+            except:\n+                pass\n+    \n     return lc, dmp_trial_division(F, factors, u, K)\n \n \n@@ -1265,8 +1339,23 @@ def dmp_factor_list(f, u, K0):\n \n     if K0.is_FiniteField:  # pragma: no cover\n         coeff, factors = dmp_gf_factor(f, u, K0)\n+\n     elif K0.is_Algebraic:\n         coeff, factors = dmp_ext_factor(f, u, K0)\n+        # Validate that factorization is complete for multivariate polynomials\n+        if u > 0 and len(factors) == 1 and factors[0][1] == 1:\n+            # If we got only one factor, verify it's actually irreducible\n+            # by checking if the product equals the original\n+            reconstructed = dmp_mul(dmp_ground_LC(factors[0][0], u, K0), factors[0][0], u, K0)\n+            if not dmp_zero_p(dmp_sub(f, reconstructed, u, K0), u):\n+                # Try alternative factorization approach for multivariate case\n+                try:\n+                    # Attempt factorization by treating as univariate in each variable\n+                    alt_coeff, alt_factors = _dmp_multivar_ext_factor(f, u, K0)\n+                    if len(alt_factors) > 1:\n+                        coeff, factors = alt_coeff, alt_factors\n+                except:\n+                    pass\n     else:\n         if not K0.is_Exact:\n             K0_inexact, K0 = K0, K0.get_exact()\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 68b69d1a24..16247f2f5b 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5922,9 +5922,30 @@ def _symbolic_factor_list(expr, opt, method):\n         except PolificationFailed as exc:\n             factors.append((exc.expr, exp))\n         else:\n+\n             func = getattr(poly, method + '_list')\n \n             _coeff, _factors = func()\n+            \n+            # Validate that factorization is complete by checking if product equals original\n+            if method in ('factor', 'sqf') and _factors:\n+                from sympy.polys.polyclasses import DMP\n+                if hasattr(poly, 'rep') and isinstance(poly.rep, DMP):\n+                    # For multivariate polynomials, verify completeness\n+                    product_check = _coeff\n+                    for factor, exp in _factors:\n+                        product_check *= factor**exp\n+                    \n+                    # If factorization is incomplete, try alternative approach\n+                    if product_check != poly.as_expr() and hasattr(poly, 'domain') and hasattr(poly.domain, 'ext'):\n+                        # For extension fields, attempt direct factorization\n+                        try:\n+                            from sympy.polys.factortools import dmp_ext_factor\n+                            alt_coeff, alt_factors = dmp_ext_factor(poly.rep, poly.domain)\n+                            if alt_factors and len(alt_factors) > len(_factors):\n+                                _coeff, _factors = alt_coeff, alt_factors\n+                        except:\n+                            pass  # Fall back to original result\n             if _coeff is not S.One:\n                 if exp.is_Integer:\n                     coeff *= _coeff**exp\n",
    "variant_1": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..c72b0ada0d 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1146,13 +1146,24 @@ def dmp_ext_factor(f, u, K):\n     if all(d <= 0 for d in dmp_degree_list(f, u)):\n         return lc, []\n \n+\n     f, F = dmp_sqf_part(f, u, K), f\n     s, g, r = dmp_sqf_norm(f, u, K)\n \n     factors = dmp_factor_list_include(r, u, K.dom)\n \n+\n     if len(factors) == 1:\n-        factors = [f]\n+        # When factorization over base field yields only one factor,\n+        # try direct factorization over the extension field\n+        try:\n+            ext_factors = dmp_factor_list_include(f, u, K)\n+            if len(ext_factors) > 1:\n+                factors = [factor for factor, _ in ext_factors]\n+            else:\n+                factors = [f]\n+        except:\n+            factors = [f]\n     else:\n         H = dmp_raise([K.one, s*K.unit], u, 0, K)\n \n@@ -1162,6 +1173,7 @@ def dmp_ext_factor(f, u, K):\n             h = dmp_compose(h, H, u, K)\n             factors[i] = h\n \n+\n     return lc, dmp_trial_division(F, factors, u, K)\n \n \n@@ -1265,8 +1277,24 @@ def dmp_factor_list(f, u, K0):\n \n     if K0.is_FiniteField:  # pragma: no cover\n         coeff, factors = dmp_gf_factor(f, u, K0)\n+\n     elif K0.is_Algebraic:\n         coeff, factors = dmp_ext_factor(f, u, K0)\n+        # Verify completeness of factorization for multivariate polynomials\n+        if u > 0 and len(factors) > 0:\n+            # Check if product of factors equals original polynomial\n+            product = dmp_mul(dmp_ground_LC(f, u, K0), u, K0)\n+            for factor, exp in factors:\n+                for _ in range(exp):\n+                    product = dmp_mul(product, factor, u, K0)\n+            if not dmp_zero_p(dmp_sub(f, product, u, K0), u):\n+                # Fallback: try direct factorization if extension field method is incomplete\n+                try:\n+                    alt_coeff, alt_factors = dmp_factor_list_include(f, u, K0.dom)\n+                    if len(alt_factors) > len(factors):\n+                        coeff, factors = alt_coeff, alt_factors\n+                except:\n+                    pass\n     else:\n         if not K0.is_Exact:\n             K0_inexact, K0 = K0, K0.get_exact()\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 68b69d1a24..a1bfeb243b 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5922,9 +5922,19 @@ def _symbolic_factor_list(expr, opt, method):\n         except PolificationFailed as exc:\n             factors.append((exc.expr, exp))\n         else:\n+\n             func = getattr(poly, method + '_list')\n \n             _coeff, _factors = func()\n+            \n+            # Validate that the factorization is complete\n+            if method in ('factor', 'sqf') and _factors:\n+                from sympy import expand\n+                reconstructed = _coeff * reduce(mul, [base**exp for base, exp in _factors], S.One)\n+                if not expand(reconstructed - poly.as_expr()).is_zero:\n+                    # If factorization is incomplete, fall back to original expression\n+                    factors.append((base, exp))\n+                    continue\n             if _coeff is not S.One:\n                 if exp.is_Integer:\n                     coeff *= _coeff**exp\n",
    "variant_2": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..3581e2c111 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1146,13 +1146,59 @@ def dmp_ext_factor(f, u, K):\n     if all(d <= 0 for d in dmp_degree_list(f, u)):\n         return lc, []\n \n-    f, F = dmp_sqf_part(f, u, K), f\n-    s, g, r = dmp_sqf_norm(f, u, K)\n \n     factors = dmp_factor_list_include(r, u, K.dom)\n \n     if len(factors) == 1:\n-        factors = [f]\n+        # Try direct factorization over the extension field instead of assuming irreducibility\n+        try:\n+            # Attempt factorization using the original polynomial over the extension field\n+            direct_factors = dmp_factor_list_include(F, u, K)\n+            if len(direct_factors) > 1:\n+                factors = direct_factors\n+            else:\n+                factors = [f]\n+        except:\n+            factors = [f]\n+\n+\n+    if len(factors) == 1:\n+        # If factorization over the base field yields only one factor,\n+        # try direct factorization over the extension field for multivariate cases\n+        if u > 0:  # multivariate case\n+            try:\n+                direct_factors = dmp_factor_list_include(f, u, K)\n+                if len(direct_factors) > 1:\n+                    factors = [factor for factor, _ in direct_factors]\n+                else:\n+                    factors = [f]\n+            except:\n+                factors = [f]\n+        else:\n+            factors = [f]\n+    else:\n+        H = dmp_raise([K.one, s*K.unit], u, 0, K)\n+\n+        for i, (factor, _) in enumerate(factors):\n+            h = dmp_convert(factor, u, K.dom, K)\n+            h, _, g = dmp_inner_gcd(h, g, u, K)\n+            h = dmp_compose(h, H, u, K)\n+            factors[i] = h\n+\n+\n+    if len(factors) == 1:\n+        # Don't assume the polynomial is irreducible - it might factor over the extension field\n+        # even if it doesn't factor over the base field. Try direct factorization.\n+        try:\n+            # Attempt to factor directly over the extension field\n+            ext_factors = dmp_factor_list(f, u, K)\n+            if len(ext_factors[1]) > 1:\n+                # Found additional factors over the extension field\n+                factors = ext_factors[1]\n+            else:\n+                factors = [f]\n+        except:\n+            factors = [f]\n     else:\n         H = dmp_raise([K.one, s*K.unit], u, 0, K)\n \n@@ -1265,8 +1311,26 @@ def dmp_factor_list(f, u, K0):\n \n     if K0.is_FiniteField:  # pragma: no cover\n         coeff, factors = dmp_gf_factor(f, u, K0)\n+\n     elif K0.is_Algebraic:\n         coeff, factors = dmp_ext_factor(f, u, K0)\n+        # Validate that factorization is complete for multivariate polynomials\n+        if len(factors) == 1 and u > 0:\n+            # Try alternative factorization approach for multivariate case\n+            from sympy.polys.factortools import dmp_factor_list_include\n+            try:\n+                # Attempt factorization by treating as polynomial over base field\n+                base_factors = dmp_factor_list_include(f, u, K0.dom)\n+                if len(base_factors[1]) > 1:\n+                    # Convert base field factors to extension field\n+                    ext_factors = []\n+                    for base_factor in base_factors[1]:\n+                        ext_factor = dmp_convert(base_factor[0], u, K0.dom, K0)\n+                        ext_factors.append((ext_factor, base_factor[1]))\n+                    if ext_factors:\n+                        coeff, factors = base_factors[0], ext_factors\n+            except (DomainError, NotImplementedError):\n+                pass\n     else:\n         if not K0.is_Exact:\n             K0_inexact, K0 = K0, K0.get_exact()\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 68b69d1a24..a76b3c80ef 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5922,9 +5922,27 @@ def _symbolic_factor_list(expr, opt, method):\n         except PolificationFailed as exc:\n             factors.append((exc.expr, exp))\n         else:\n-            func = getattr(poly, method + '_list')\n \n+            func = getattr(poly, method + '_list')\n+            \n             _coeff, _factors = func()\n+            \n+            # Validate that the factorization is complete\n+            if method in ['factor', 'sqf_factor']:\n+                from sympy.core.mul import Mul\n+                product = _coeff\n+                for factor, exp in _factors:\n+                    product *= factor**exp\n+                \n+                # If factorization is incomplete, try alternative methods\n+                if not poly.equals(product):\n+                    # For extension fields, try direct factorization\n+                    if hasattr(poly.domain, 'ext') and poly.domain.ext:\n+                        try:\n+                            alt_func = getattr(poly, 'factor_list')\n+                            _coeff, _factors = alt_func()\n+                        except (AttributeError, PolificationFailed):\n+                            pass\n             if _coeff is not S.One:\n                 if exp.is_Integer:\n                     coeff *= _coeff**exp\n",
    "variant_3": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..82127057de 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1146,13 +1146,46 @@ def dmp_ext_factor(f, u, K):\n     if all(d <= 0 for d in dmp_degree_list(f, u)):\n         return lc, []\n \n-    f, F = dmp_sqf_part(f, u, K), f\n-    s, g, r = dmp_sqf_norm(f, u, K)\n \n-    factors = dmp_factor_list_include(r, u, K.dom)\n+    if len(factors) == 1:\n+        # If no factors found in the norm, try direct multivariate factorization\n+        # over the extension field\n+        from sympy.polys.factortools import dmp_factor_list\n+        try:\n+            direct_factors = dmp_factor_list(f, u, K)\n+            if len(direct_factors[1]) > 1:\n+                # Direct factorization succeeded, use those factors\n+                factors = [factor for factor, _ in direct_factors[1]]\n+            else:\n+                # No factorization possible, polynomial is irreducible\n+                factors = [f]\n+        except:\n+            # Fallback to treating as irreducible\n+            factors = [f]\n+    else:\n+        H = dmp_raise([K.one, s*K.unit], u, 0, K)\n+\n+        for i, (factor, _) in enumerate(factors):\n+            h = dmp_convert(factor, u, K.dom, K)\n+            h, _, g = dmp_inner_gcd(h, g, u, K)\n+            h = dmp_compose(h, H, u, K)\n+\n \n     if len(factors) == 1:\n-        factors = [f]\n+        # If factorization over the base domain yields only one factor,\n+        # try direct factorization over the extension field for multivariate case\n+        if u > 0:  # multivariate case\n+            try:\n+                # Attempt direct factorization of the original polynomial\n+                direct_factors = dmp_factor_list_include(F, u, K)\n+                if len(direct_factors) > 1:\n+                    factors = [factor for factor, _ in direct_factors]\n+                else:\n+                    factors = [f]\n+            except:\n+                factors = [f]\n+        else:\n+            factors = [f]\n     else:\n         H = dmp_raise([K.one, s*K.unit], u, 0, K)\n \n@@ -1162,7 +1195,31 @@ def dmp_ext_factor(f, u, K):\n             h = dmp_compose(h, H, u, K)\n             factors[i] = h\n \n-    return lc, dmp_trial_division(F, factors, u, K)\n+\n+    if len(factors) == 1:\n+        # Don't assume irreducibility - attempt direct factorization over extension field\n+        # Try to factor the polynomial directly in the extension field\n+        try:\n+            # Convert back to the extension field and attempt factorization\n+            f_ext = dmp_convert(f, u, K.dom, K)\n+            # Try factorization with different approaches for multivariate case\n+            if u > 0:  # multivariate case\n+                # Use content-primitive decomposition and recursive factorization\n+                content, primitive = dmp_ground_content(f_ext, u, K)\n+                if not dmp_zero_p(dmp_sub(primitive, f_ext, u, K), u, K):\n+                    # If there's non-trivial content, factor both parts\n+                    prim_factors = dmp_factor_list_include(primitive, u, K)\n+                    if len(prim_factors[1]) > 1:\n+                        factors = [(dmp_convert(factor, u, K, K.dom), mult) \n+                                 for factor, mult in prim_factors[1]]\n+                    else:\n+                        factors = [f]\n+                else:\n+                    factors = [f]\n+            else:\n+                factors = [f]\n+        except (NotImplementedError, DomainError):\n+            factors = [f]\n \n \n def dup_gf_factor(f, K):\n@@ -1265,8 +1322,27 @@ def dmp_factor_list(f, u, K0):\n \n     if K0.is_FiniteField:  # pragma: no cover\n         coeff, factors = dmp_gf_factor(f, u, K0)\n+\n     elif K0.is_Algebraic:\n+        # For algebraic extensions, we need to ensure complete factorization\n+        # especially for multivariate polynomials\n         coeff, factors = dmp_ext_factor(f, u, K0)\n+        \n+        # Validate that the factorization is complete by checking if the product\n+        # of factors equals the original polynomial\n+        if factors:\n+            product = dmp_one(u, K0)\n+            for factor, mult in factors:\n+                for _ in range(mult):\n+                    product = dmp_mul(product, factor, u, K0)\n+            product = dmp_mul_ground(product, coeff, u, K0)\n+            \n+            # If the product doesn't match, the factorization may be incomplete\n+            # This can happen with multivariate polynomials over extension fields\n+            if not dmp_zero_p(dmp_sub(f, product, u, K0), u):\n+                # Fallback: try alternative factorization approaches\n+                # or return the original polynomial as irreducible\n+                coeff, factors = K0.one, [(f, 1)]\n     else:\n         if not K0.is_Exact:\n             K0_inexact, K0 = K0, K0.get_exact()\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 68b69d1a24..08f2e2c91a 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5922,9 +5922,27 @@ def _symbolic_factor_list(expr, opt, method):\n         except PolificationFailed as exc:\n             factors.append((exc.expr, exp))\n         else:\n+\n             func = getattr(poly, method + '_list')\n \n             _coeff, _factors = func()\n+            \n+            # Validate that factorization is complete by checking the product\n+            if _factors and method in ('factor', 'sqf'):\n+                from sympy.polys.polytools import expand\n+                product = _coeff\n+                for factor, exp in _factors:\n+                    product *= factor**exp\n+                \n+                # If factorization is incomplete, try alternative methods\n+                if not poly.equals(product):\n+                    # For extension fields, try direct factorization\n+                    if hasattr(poly.rep, 'dom') and hasattr(poly.rep.dom, 'ext'):\n+                        try:\n+                            alt_func = getattr(poly, 'factor_list')\n+                            _coeff, _factors = alt_func()\n+                        except (AttributeError, PolynomialError):\n+                            pass\n             if _coeff is not S.One:\n                 if exp.is_Integer:\n                     coeff *= _coeff**exp\n",
    "variant_4": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..bcaddc9928 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1146,13 +1146,43 @@ def dmp_ext_factor(f, u, K):\n     if all(d <= 0 for d in dmp_degree_list(f, u)):\n         return lc, []\n \n-    f, F = dmp_sqf_part(f, u, K), f\n-    s, g, r = dmp_sqf_norm(f, u, K)\n \n-    factors = dmp_factor_list_include(r, u, K.dom)\n+    if len(factors) == 1:\n+        # When base field factorization yields only one factor, try direct factorization\n+        # over the extension field for multivariate polynomials\n+        try:\n+            # Attempt direct factorization over the extension field\n+            alt_factors = dmp_factor_list_include(f, u, K)\n+            if len(alt_factors) > 1:\n+                factors = [factor for factor, _ in alt_factors]\n+            else:\n+                factors = [f]\n+        except:\n+            factors = [f]\n+    else:\n+        H = dmp_raise([K.one, s*K.unit], u, 0, K)\n+\n+        for i, (factor, _) in enumerate(factors):\n+            h = dmp_convert(factor, u, K.dom, K)\n+            h, _, g = dmp_inner_gcd(h, g, u, K)\n+            h = dmp_compose(h, H, u, K)\n+\n \n     if len(factors) == 1:\n-        factors = [f]\n+        # Check if we have a trivial factorization over the base field\n+        # but the polynomial might factor over the extension field\n+        if u > 0:  # multivariate case\n+            # Try direct factorization over the extension field\n+            try:\n+                direct_factors = dmp_factor_list_include(f, u, K)\n+                if len(direct_factors) > 1:\n+                    factors = [factor for factor, _ in direct_factors]\n+                else:\n+                    factors = [f]\n+            except:\n+                factors = [f]\n+        else:\n+            factors = [f]\n     else:\n         H = dmp_raise([K.one, s*K.unit], u, 0, K)\n \n@@ -1162,7 +1192,37 @@ def dmp_ext_factor(f, u, K):\n             h = dmp_compose(h, H, u, K)\n             factors[i] = h\n \n-    return lc, dmp_trial_division(F, factors, u, K)\n+\n+    return lc, _validate_and_complete_factorization(F, dmp_trial_division(F, factors, u, K), u, K)\n+\n+\n+def _validate_and_complete_factorization(original, result, u, K):\n+    \"\"\"Validate factorization completeness and attempt recovery if incomplete.\"\"\"\n+    lc, factors = result\n+    \n+    # Check if factorization is complete by multiplying factors\n+    if factors:\n+        product = factors[0][0]\n+        for factor, mult in factors[1:]:\n+            for _ in range(mult):\n+                product = dmp_mul(product, factor, u, K)\n+        for factor, mult in factors[:1]:\n+            for _ in range(mult - 1):\n+                product = dmp_mul(product, factor, u, K)\n+        \n+        # Scale by leading coefficient\n+        expected = dmp_mul_ground(original, lc, u, K) if lc != K.one else original\n+        \n+        if not dmp_zero_p(dmp_sub(product, expected, u, K), u):\n+            # Factorization incomplete, attempt direct factorization\n+            try:\n+                direct_result = dmp_factor_list(original, u, K)\n+                if len(direct_result[1]) > len(factors):\n+                    return direct_result\n+            except:\n+                pass\n+    \n+    return lc, factors\n \n \n def dup_gf_factor(f, K):\n@@ -1265,8 +1325,39 @@ def dmp_factor_list(f, u, K0):\n \n     if K0.is_FiniteField:  # pragma: no cover\n         coeff, factors = dmp_gf_factor(f, u, K0)\n+\n     elif K0.is_Algebraic:\n         coeff, factors = dmp_ext_factor(f, u, K0)\n+        # Verify completeness of factorization for multivariate polynomials\n+        if len(factors) == 1 and u > 0:\n+            # Check if the single factor is actually the original polynomial\n+            # indicating incomplete factorization\n+            factor_poly = factors[0][0]\n+            if dmp_cmp(factor_poly, f, u, K0) == 0:\n+                # Try alternative factorization approach for multivariate case\n+                try:\n+                    # Attempt factorization by treating as univariate in each variable\n+                    alt_factors = []\n+                    for i in range(u + 1):\n+                        # Convert to univariate in variable i\n+                        f_uni = dmp_to_dict(f, u, K0)\n+                        if f_uni:\n+                            # Try factoring as univariate and see if we get more factors\n+                            temp_factors = []\n+                            for var_power, coeff_poly in f_uni.items():\n+                                if any(var_power):  # Non-constant term\n+                                    try:\n+                                        var_factors = dmp_ext_factor(coeff_poly, u-1, K0) if u > 1 else dup_ext_factor(coeff_poly, K0)\n+                                        temp_factors.extend(var_factors[1])\n+                                    except:\n+                                        continue\n+                            if len(temp_factors) > 1:\n+                                alt_factors = temp_factors\n+                                break\n+                    if alt_factors:\n+                        factors = alt_factors\n+                except:\n+                    pass  # Fall back to original result\n     else:\n         if not K0.is_Exact:\n             K0_inexact, K0 = K0, K0.get_exact()\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 68b69d1a24..97ad62f3bb 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5922,9 +5922,20 @@ def _symbolic_factor_list(expr, opt, method):\n         except PolificationFailed as exc:\n             factors.append((exc.expr, exp))\n         else:\n+\n             func = getattr(poly, method + '_list')\n \n             _coeff, _factors = func()\n+            \n+            # Validate that the factorization is complete\n+            if method in ['factor', 'sqf_factor'] and len(_factors) > 0:\n+                # Check if the product of factors equals the original polynomial\n+                from sympy.core.mul import Mul\n+                reconstructed = _coeff * Mul(*[base**exp for base, exp in _factors])\n+                if not poly.as_expr().equals(reconstructed):\n+                    # If factorization is incomplete, fall back to original expression\n+                    factors.append((base, exp))\n+                    continue\n             if _coeff is not S.One:\n                 if exp.is_Integer:\n                     coeff *= _coeff**exp\n",
    "variant_5": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..15324d7413 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1146,13 +1146,59 @@ def dmp_ext_factor(f, u, K):\n     if all(d <= 0 for d in dmp_degree_list(f, u)):\n         return lc, []\n \n-    f, F = dmp_sqf_part(f, u, K), f\n-    s, g, r = dmp_sqf_norm(f, u, K)\n \n-    factors = dmp_factor_list_include(r, u, K.dom)\n+    if len(factors) == 1:\n+        # When base field factorization returns only one factor, try direct factorization\n+        # over the extension field before concluding the polynomial is irreducible\n+        try:\n+            # Attempt direct multivariate factorization over the extension field\n+            direct_factors = []\n+            temp_f = f\n+            \n+            # Try to find linear factors by substitution and factorization\n+            # This handles cases where the norm-based approach misses factors\n+            from sympy.polys.polytools import factor as poly_factor\n+            from sympy.polys.domains import QQ\n+            \n+            # Convert to a form suitable for direct factorization attempts\n+            if hasattr(K, 'ext') and K.ext is not None:\n+                # For algebraic extensions, try factoring each variable separately\n+                # and look for common factors\n+                found_factors = False\n+                remaining = temp_f\n+                \n+                # Check if we can factor out simpler polynomials\n+                for var_idx in range(u + 1):\n+                    # Try partial factorization by treating other variables as parameters\n+                    partial_result = dmp_factor_list_include(remaining, u, K)\n+                    if len(partial_result) > 1:\n+                        direct_factors.extend([factor for factor, mult in partial_result])\n+                        found_factors = True\n+                        break\n+                \n+                if found_factors:\n+                    factors = direct_factors\n+                else:\n+                    factors = [f]\n+            else:\n+                factors = [f]\n+        except:\n+            # Fall back to original behavior if direct factorization fails\n+            factors = [f]\n+\n \n     if len(factors) == 1:\n-        factors = [f]\n+        # If factorization over base field yields only one factor,\n+        # try direct factorization over the extension field\n+        try:\n+            ext_factors = dmp_factor_list(f, u, K)\n+            if len(ext_factors[1]) > 1:\n+                # Found multiple factors over extension field\n+                factors = [factor for factor, _ in ext_factors[1]]\n+            else:\n+                factors = [f]\n+        except:\n+            factors = [f]\n     else:\n         H = dmp_raise([K.one, s*K.unit], u, 0, K)\n \n@@ -1162,7 +1208,42 @@ def dmp_ext_factor(f, u, K):\n             h = dmp_compose(h, H, u, K)\n             factors[i] = h\n \n-    return lc, dmp_trial_division(F, factors, u, K)\n+\n+    return lc, _validate_and_complete_factorization(F, dmp_trial_division(F, factors, u, K), u, K)\n+\n+def _validate_and_complete_factorization(original, result, u, K):\n+    \"\"\"Validate factorization completeness and attempt completion if needed.\"\"\"\n+    lc, factors = result\n+    \n+    # Check if product of factors equals original (accounting for leading coefficient)\n+    if factors:\n+        product = dmp_mul(dmp_ground(lc, u, K), factors[0][0], u, K)\n+        for factor, exp in factors[1:]:\n+            for _ in range(exp):\n+                product = dmp_mul(product, factor, u, K)\n+        \n+        if dmp_cmp(product, original, u, K) == 0:\n+            return result\n+    \n+    # If validation fails and we have extension field, try alternative methods\n+    if hasattr(K, 'ext') and K.ext:\n+        # For extension fields, attempt direct factorization if trial division incomplete\n+        try:\n+            alt_factors = []\n+            remaining = dmp_quo(original, dmp_ground(lc, u, K), u, K) if lc != K.one else original\n+            \n+            for factor, exp in factors:\n+                for _ in range(exp):\n+                    remaining = dmp_quo(remaining, factor, u, K)\n+            \n+            # If there's remaining unfactored part, try to factor it\n+            if not dmp_one_p(remaining, u, K):\n+                additional = dmp_factor_list(remaining, u, K)[1]\n+                factors.extend(additional)\n+        except:\n+            pass\n+    \n+    return lc, factors\n \n \n def dup_gf_factor(f, K):\n@@ -1265,8 +1346,28 @@ def dmp_factor_list(f, u, K0):\n \n     if K0.is_FiniteField:  # pragma: no cover\n         coeff, factors = dmp_gf_factor(f, u, K0)\n+\n     elif K0.is_Algebraic:\n         coeff, factors = dmp_ext_factor(f, u, K0)\n+        # Verify that factorization is complete for multivariate polynomials\n+        if u > 0 and len(factors) == 1 and factors[0][1] == 1:\n+            # If only one factor found, check if it's actually irreducible\n+            test_poly = factors[0][0]\n+            if not dmp_zero_p(dmp_sub(f, test_poly, u, K0), u):\n+                # Factor doesn't match original, try alternative approach\n+                from sympy.polys.polytools import Poly\n+                from sympy import symbols\n+                try:\n+                    # Convert to Poly and attempt factorization with extension handling\n+                    vars_list = [symbols(f'x_{i}') for i in range(u + 1)]\n+                    poly_obj = Poly.from_list(f, *vars_list, domain=K0)\n+                    alt_factors = poly_obj.factor_list()\n+                    if len(alt_factors[1]) > 1:\n+                        # Convert back to dense representation\n+                        coeff = alt_factors[0]\n+                        factors = [(factor.rep.rep, mult) for factor, mult in alt_factors[1]]\n+                except:\n+                    pass  # Fall back to original result if conversion fails\n     else:\n         if not K0.is_Exact:\n             K0_inexact, K0 = K0, K0.get_exact()\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 68b69d1a24..a1f3ea5728 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5922,9 +5922,27 @@ def _symbolic_factor_list(expr, opt, method):\n         except PolificationFailed as exc:\n             factors.append((exc.expr, exp))\n         else:\n+\n             func = getattr(poly, method + '_list')\n \n             _coeff, _factors = func()\n+            \n+            # Validate that factorization is complete by checking if product equals original\n+            if method in ('factor', 'sqf') and _factors:\n+                from sympy.polys.polyfuncs import symmetrize\n+                product = _coeff\n+                for factor, exp in _factors:\n+                    product *= factor**exp\n+                \n+                # If factorization is incomplete, try alternative methods\n+                if not poly.equals(product):\n+                    # For extension fields, try direct factorization\n+                    if hasattr(poly.domain, 'ext') and poly.domain.ext:\n+                        try:\n+                            alt_func = getattr(poly, 'factor_list')\n+                            _coeff, _factors = alt_func()\n+                        except (AttributeError, PolificationFailed):\n+                            pass\n             if _coeff is not S.One:\n                 if exp.is_Integer:\n                     coeff *= _coeff**exp\n",
    "variant_6": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..296f03a567 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1146,13 +1146,21 @@ def dmp_ext_factor(f, u, K):\n     if all(d <= 0 for d in dmp_degree_list(f, u)):\n         return lc, []\n \n+\n     f, F = dmp_sqf_part(f, u, K), f\n     s, g, r = dmp_sqf_norm(f, u, K)\n \n     factors = dmp_factor_list_include(r, u, K.dom)\n \n+\n     if len(factors) == 1:\n-        factors = [f]\n+        # When base field factorization yields only one factor, it might still\n+        # be reducible over the extension field. Try direct factorization.\n+        direct_factors = dmp_factor_list_include(f, u, K)\n+        if len(direct_factors) > 1:\n+            factors = [factor for factor, _ in direct_factors]\n+        else:\n+            factors = [f]\n     else:\n         H = dmp_raise([K.one, s*K.unit], u, 0, K)\n \n@@ -1162,7 +1170,19 @@ def dmp_ext_factor(f, u, K):\n             h = dmp_compose(h, H, u, K)\n             factors[i] = h\n \n-    return lc, dmp_trial_division(F, factors, u, K)\n+\n+    if len(factors) == 1:\n+        # Don't assume irreducibility - try direct factorization over extension field\n+        # First attempt factorization using the extension field directly\n+        try:\n+            ext_factors = dmp_factor_list_include(f, u, K)\n+            if len(ext_factors) > 1:\n+                factors = ext_factors\n+            else:\n+                factors = [f]\n+        except:\n+            factors = [f]\n+    else:\n \n \n def dup_gf_factor(f, K):\n@@ -1265,8 +1285,32 @@ def dmp_factor_list(f, u, K0):\n \n     if K0.is_FiniteField:  # pragma: no cover\n         coeff, factors = dmp_gf_factor(f, u, K0)\n+\n     elif K0.is_Algebraic:\n         coeff, factors = dmp_ext_factor(f, u, K0)\n+        # Verify that the factorization is complete by checking the product\n+        if factors:\n+            product = dmp_one(u, K0)\n+            for factor, exp in factors:\n+                for _ in range(exp):\n+                    product = dmp_mul(product, factor, u, K0)\n+            product = dmp_mul(product, coeff, u, K0)\n+            if not dmp_zero_p(dmp_sub(product, f, u, K0), u):\n+                # Factorization incomplete, try alternative approach\n+                # Fall back to ground field factorization and lift\n+                if hasattr(K0, 'dom') and K0.dom != K0:\n+                    try:\n+                        f_ground = dmp_convert(f, u, K0, K0.dom)\n+                        coeff_alt, factors_alt = dmp_factor_list(f_ground, u, K0.dom)\n+                        # Convert factors back to extension field\n+                        factors_converted = []\n+                        for factor, exp in factors_alt:\n+                            factor_ext = dmp_convert(factor, u, K0.dom, K0)\n+                            factors_converted.append((factor_ext, exp))\n+                        coeff = dmp_convert(coeff_alt, u, K0.dom, K0)\n+                        factors = factors_converted\n+                    except:\n+                        pass  # Keep original result if conversion fails\n     else:\n         if not K0.is_Exact:\n             K0_inexact, K0 = K0, K0.get_exact()\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 68b69d1a24..aeafed11dc 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5922,9 +5922,35 @@ def _symbolic_factor_list(expr, opt, method):\n         except PolificationFailed as exc:\n             factors.append((exc.expr, exp))\n         else:\n+\n             func = getattr(poly, method + '_list')\n \n             _coeff, _factors = func()\n+            \n+            # Validate that factorization is complete by checking if product equals original\n+            if method in ('factor', 'sqf') and _factors:\n+                from sympy.polys.polyclasses import DMP\n+                if hasattr(poly, 'rep') and isinstance(poly.rep, DMP):\n+                    # For multivariate polynomials, verify completeness\n+                    product_check = _coeff\n+                    for factor, exp in _factors:\n+                        if hasattr(factor, '__pow__'):\n+                            product_check *= factor ** exp\n+                        else:\n+                            # Handle case where factor might be a coefficient\n+                            product_check *= factor\n+                    \n+                    # If factorization is incomplete, try alternative approach\n+                    if product_check != poly.as_expr():\n+                        # Attempt direct factorization over extension field if available\n+                        if hasattr(poly, 'get_domain') and hasattr(poly.get_domain(), 'ext'):\n+                            try:\n+                                from sympy.polys.factortools import dmp_ext_factor\n+                                alt_factors = dmp_ext_factor(poly.rep, poly.get_domain())\n+                                if alt_factors and len(alt_factors[1]) > len(_factors):\n+                                    _coeff, _factors = alt_factors\n+                            except:\n+                                pass  # Fall back to original result\n             if _coeff is not S.One:\n                 if exp.is_Integer:\n                     coeff *= _coeff**exp\n",
    "variant_7": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..aa87cbc134 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1146,13 +1146,37 @@ def dmp_ext_factor(f, u, K):\n     if all(d <= 0 for d in dmp_degree_list(f, u)):\n         return lc, []\n \n-    f, F = dmp_sqf_part(f, u, K), f\n-    s, g, r = dmp_sqf_norm(f, u, K)\n \n-    factors = dmp_factor_list_include(r, u, K.dom)\n+    if len(factors) == 1:\n+        # The polynomial may still be reducible over the extension field\n+        # even if it appears irreducible over the base field\n+        # Try direct factorization over the extension field\n+        try:\n+            # Attempt to factor directly over the extension field\n+            ext_factors = dmp_factor_list_include(f, u, K)\n+            if len(ext_factors) > 1:\n+                factors = [factor for factor, _ in ext_factors]\n+            else:\n+                factors = [f]\n+        except:\n+            factors = [f]\n+\n \n     if len(factors) == 1:\n-        factors = [f]\n+        # If factorization over K.dom yields only one factor, try direct factorization\n+        # over the extension field for multivariate polynomials\n+        if u > 0:  # multivariate case\n+            try:\n+                # Attempt direct factorization of the original polynomial\n+                direct_factors = dmp_factor_list_include(f, u, K)\n+                if len(direct_factors) > 1:\n+                    factors = [factor for factor, _ in direct_factors]\n+                else:\n+                    factors = [f]\n+            except:\n+                factors = [f]\n+        else:\n+            factors = [f]\n     else:\n         H = dmp_raise([K.one, s*K.unit], u, 0, K)\n \n@@ -1162,7 +1186,23 @@ def dmp_ext_factor(f, u, K):\n             h = dmp_compose(h, H, u, K)\n             factors[i] = h\n \n-    return lc, dmp_trial_division(F, factors, u, K)\n+\n+    if len(factors) == 1:\n+        # Don't assume irreducibility - try direct factorization over extension field\n+        # when base field factorization yields only one factor\n+        try:\n+            # Attempt factorization directly over the extension field K\n+            direct_factors = dmp_factor_list_include(f, u, K)\n+            if len(direct_factors) > 1:\n+                # Direct factorization found multiple factors\n+                factors = direct_factors\n+            else:\n+                # If still only one factor, then it's truly irreducible\n+                factors = [f]\n+        except (NotImplementedError, DomainError):\n+            # Fall back to original behavior if direct factorization fails\n+            factors = [f]\n+    else:\n \n \n def dup_gf_factor(f, K):\n@@ -1265,8 +1305,18 @@ def dmp_factor_list(f, u, K0):\n \n     if K0.is_FiniteField:  # pragma: no cover\n         coeff, factors = dmp_gf_factor(f, u, K0)\n+\n     elif K0.is_Algebraic:\n         coeff, factors = dmp_ext_factor(f, u, K0)\n+        # Validate that extension field factorization is complete\n+        if len(factors) == 1 and factors[0][1] == 1:\n+            # If only one factor found, verify it's truly irreducible\n+            # by checking if the product equals the original\n+            reconstructed = dmp_mul(dmp_pow(factors[0][0], factors[0][1], u, K0), \n+                                  dmp_ground(coeff, u, K0), u, K0)\n+            if not dmp_zero_p(dmp_sub(f, reconstructed, u, K0), u):\n+                # Factorization incomplete, attempt alternative approach\n+                coeff, factors = dmp_factor_list(f, u, K0.dom), []\n     else:\n         if not K0.is_Exact:\n             K0_inexact, K0 = K0, K0.get_exact()\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 68b69d1a24..121a81e051 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5922,9 +5922,31 @@ def _symbolic_factor_list(expr, opt, method):\n         except PolificationFailed as exc:\n             factors.append((exc.expr, exp))\n         else:\n+\n             func = getattr(poly, method + '_list')\n \n             _coeff, _factors = func()\n+            \n+            # Validate factorization completeness for extension fields\n+            if hasattr(opt, 'extension') and opt.extension:\n+                from sympy.polys.polyclasses import DMP\n+                # Check if the product of factors equals original polynomial\n+                if _factors:\n+                    product = poly.one\n+                    for factor, exp in _factors:\n+                        product *= DMP.from_list(factor, poly.domain, poly.ring)**exp\n+                    if _coeff != S.One:\n+                        product *= _coeff\n+                    \n+                    # If factorization is incomplete, try alternative methods\n+                    if not poly.eq(product):\n+                        try:\n+                            # Attempt direct factorization over extension field\n+                            alt_coeff, alt_factors = poly.factor_list()\n+                            if alt_factors and len(alt_factors) > len(_factors):\n+                                _coeff, _factors = alt_coeff, alt_factors\n+                        except:\n+                            pass\n             if _coeff is not S.One:\n                 if exp.is_Integer:\n                     coeff *= _coeff**exp\n",
    "variant_8": "diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py\nindex c6a5f9f063..5dbf3afebd 100644\n--- a/sympy/polys/factortools.py\n+++ b/sympy/polys/factortools.py\n@@ -1146,13 +1146,59 @@ def dmp_ext_factor(f, u, K):\n     if all(d <= 0 for d in dmp_degree_list(f, u)):\n         return lc, []\n \n-    f, F = dmp_sqf_part(f, u, K), f\n-    s, g, r = dmp_sqf_norm(f, u, K)\n \n-    factors = dmp_factor_list_include(r, u, K.dom)\n+    if len(factors) == 1:\n+        # Try direct factorization over the extension field when base field factorization fails\n+        try:\n+            # Attempt multivariate factorization directly over the extension field\n+            direct_factors = []\n+            temp_f = f\n+            \n+            # Try factoring each variable separately\n+            for i in range(u + 1):\n+                if dmp_degree_in(temp_f, i, u) > 0:\n+                    # Check if we can factor out linear terms in variable i\n+                    var_factors = []\n+                    for j in range(dmp_degree_in(temp_f, i, u) + 1):\n+                        # Try to find linear factors by substitution\n+                        test_poly = dmp_eval_in(temp_f, K.zero, i, u)\n+                        if not test_poly or dmp_zero_p(test_poly, u-1):\n+                            # Found a factor, extract it\n+                            linear_factor = dmp_from_dict({(0,) * i + (1,) + (0,) * (u-i): K.one}, u, K)\n+                            if i < u:\n+                                linear_factor = dmp_add_term(linear_factor, K.zero, (0,) * (u+1), u, K)\n+                            var_factors.append(linear_factor)\n+                    \n+                    if var_factors:\n+                        direct_factors.extend(var_factors)\n+                        for factor in var_factors:\n+                            temp_f, _ = dmp_div(temp_f, factor, u, K)\n+            \n+            if direct_factors:\n+                if not dmp_one_p(temp_f, u, K):\n+                    direct_factors.append(temp_f)\n+                factors = direct_factors\n+            else:\n+                factors = [f]\n+        except:\n+            factors = [f]\n+    else:\n+\n \n     if len(factors) == 1:\n-        factors = [f]\n+        # Check if the polynomial might factor over the extension field\n+        # even if it doesn't factor over the base field\n+        try:\n+            # Try direct factorization over the extension field\n+            alt_factors = dmp_factor_list(f, u, K)\n+            if len(alt_factors[1]) > 1:\n+                # Found additional factors over the extension field\n+                factors = [factor for factor, _ in alt_factors[1]]\n+            else:\n+                factors = [f]\n+        except (NotImplementedError, DomainError):\n+            # Fall back to original behavior if extension field factorization fails\n+            factors = [f]\n     else:\n         H = dmp_raise([K.one, s*K.unit], u, 0, K)\n \n@@ -1162,6 +1208,29 @@ def dmp_ext_factor(f, u, K):\n             h = dmp_compose(h, H, u, K)\n             factors[i] = h\n \n+\n+    # Validate factorization completeness before returning\n+    if len(factors) == 1:\n+        # Try direct factorization over the extension field\n+        try:\n+            # Attempt multivariate factorization by treating as univariate in each variable\n+            from sympy.polys.polytools import factor_list\n+            from sympy.polys.domains import QQ\n+            \n+            # Convert to a form suitable for direct factorization\n+            result_factors = []\n+            temp_poly = dmp_convert(f, u, K, QQ)\n+            \n+            # Try factoring directly if possible\n+            direct_factors = dmp_trial_division(F, [f], u, K)\n+            if len(direct_factors) > 1 or direct_factors[0][1] > 1:\n+                return lc, direct_factors\n+            \n+            # If still only one factor, return the original factorization attempt\n+            factors = [f]\n+        except:\n+            factors = [f]\n+    \n     return lc, dmp_trial_division(F, factors, u, K)\n \n \n@@ -1265,8 +1334,38 @@ def dmp_factor_list(f, u, K0):\n \n     if K0.is_FiniteField:  # pragma: no cover\n         coeff, factors = dmp_gf_factor(f, u, K0)\n+\n     elif K0.is_Algebraic:\n         coeff, factors = dmp_ext_factor(f, u, K0)\n+        # Validate that the factorization is complete for multivariate polynomials\n+        if len(factors) == 1 and u > 0:\n+            # Try alternative factorization approach for multivariate case\n+            try:\n+                # Attempt factorization by converting to univariate in each variable\n+                alt_factors = []\n+                for i in range(u + 1):\n+                    # Try factoring as univariate in variable i\n+                    f_uni = dmp_convert_to_univariate(f, u, i, K0)\n+                    if f_uni is not None:\n+                        uni_factors = dup_factor_list(f_uni, K0)[1]\n+                        if len(uni_factors) > 1:\n+                            # Convert back to multivariate factors\n+                            for factor_poly, mult in uni_factors:\n+                                mv_factor = dmp_convert_from_univariate(factor_poly, u, i, K0)\n+                                alt_factors.append((mv_factor, mult))\n+                            break\n+                \n+                if len(alt_factors) > 1:\n+                    factors = alt_factors\n+                    # Recompute coefficient to maintain polynomial equality\n+                    factor_product = dmp_one(u, K0)\n+                    for factor_poly, mult in factors:\n+                        for _ in range(mult):\n+                            factor_product = dmp_mul(factor_product, factor_poly, u, K0)\n+                    coeff = dmp_quo(f, factor_product, u, K0) if not dmp_zero_p(factor_product, u) else coeff\n+            except:\n+                # Fall back to original result if alternative approach fails\n+                pass\n     else:\n         if not K0.is_Exact:\n             K0_inexact, K0 = K0, K0.get_exact()\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex 68b69d1a24..d03924395c 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -5922,9 +5922,20 @@ def _symbolic_factor_list(expr, opt, method):\n         except PolificationFailed as exc:\n             factors.append((exc.expr, exp))\n         else:\n+\n             func = getattr(poly, method + '_list')\n \n             _coeff, _factors = func()\n+            \n+            # Validate that the factorization is complete\n+            if method in ('factor', 'sqf') and _factors:\n+                # Check if the product of factors equals the original polynomial\n+                from sympy.core.mul import Mul\n+                factor_product = Mul(*[base**exp for base, exp in _factors]) * _coeff\n+                if not poly.as_expr().equals(factor_product):\n+                    # If factorization is incomplete, fall back to original expression\n+                    factors.append((base, exp))\n+                    continue\n             if _coeff is not S.One:\n                 if exp.is_Integer:\n                     coeff *= _coeff**exp\n"
  }
}