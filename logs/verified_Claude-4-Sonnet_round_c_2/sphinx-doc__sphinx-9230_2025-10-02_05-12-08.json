{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/ext/autodoc/typehints.py lines 88-99)": "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    i = 0\n    \n    while i < len(field_name):\n        char = field_name[i]\n        \n        if char == '(':\n            paren_depth += 1\n            current_part += char\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n        elif char == ' ' and paren_depth == 0:\n            # Only split on spaces when not inside parentheses\n            if current_part.strip():\n                parts.append(current_part.strip())\n                current_part = \"\"\n            # Skip consecutive spaces\n            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n                i += 1\n        else:\n            current_part += char\n        \n        i += 1\n    \n    if current_part.strip():\n        parts.append(current_part.strip())\n    \n    return parts\n\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
    "Location 2 (/root/hy/projects/sphinx/sphinx/ext/autodoc/typehints.py lines 139-148)": "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    i = 0\n    \n    while i < len(field_name):\n        char = field_name[i]\n        \n        if char == '(':\n            paren_depth += 1\n            current_part += char\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n        elif char == ' ' and paren_depth == 0:\n            # Only split on spaces when not inside parentheses\n            if current_part:\n                parts.append(current_part)\n                current_part = \"\"\n            # Skip consecutive spaces\n            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n                i += 1\n        else:\n            current_part += char\n        \n        i += 1\n    \n    if current_part:\n        parts.append(current_part)\n    \n    return parts\n\n\ndef augment_descriptions_with_types(\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/ext/autodoc/typehints.py lines 88-99)": [
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    i = 0\n    \n    while i < len(field_name):\n        char = field_name[i]\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n        elif char == ' ' and paren_depth == 0:\n            if current_part:\n                parts.append(current_part)\n                current_part = \"\"\n            # Skip multiple spaces\n            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n                i += 1\n        else:\n            current_part += char\n        i += 1\n    \n    if current_part:\n        parts.append(current_part)\n    \n    return parts\n\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    \n    i = 0\n    while i < len(field_name):\n        char = field_name[i]\n        \n        if char == '(':\n            paren_depth += 1\n            current_part += char\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n        elif char == ' ' and paren_depth == 0:\n            # Only split on spaces when not inside parentheses\n            if current_part.strip():\n                parts.append(current_part.strip())\n                current_part = \"\"\n            # Skip consecutive spaces\n            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n                i += 1\n        else:\n            current_part += char\n        \n        i += 1\n    \n    if current_part.strip():\n        parts.append(current_part.strip())\n    \n    return parts\n\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    in_word = False\n    \n    for char in field_name:\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n            in_word = True\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n            in_word = True\n        elif char == ' ':\n            if paren_depth == 0:\n                if in_word:\n                    parts.append(current_part)\n                    current_part = \"\"\n                    in_word = False\n            else:\n                current_part += char\n                in_word = True\n        else:\n            current_part += char\n            in_word = True\n    \n    if in_word:\n        parts.append(current_part)\n    \n    return parts\n\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\ndef parse_param_field(field_name: str) -> List[str]:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    i = 0\n    \n    while i < len(field_name):\n        char = field_name[i]\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n        elif char == ' ' and paren_depth == 0:\n            # Skip multiple spaces\n            while i < len(field_name) and field_name[i] == ' ':\n                i += 1\n            i -= 1  # Adjust for the increment at the end of the loop\n            if current_part:\n                parts.append(current_part)\n                current_part = \"\"\n        else:\n            current_part += char\n        i += 1\n    \n    if current_part:\n        parts.append(current_part)\n    \n    return parts\n\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    i = 0\n    \n    while i < len(field_name):\n        char = field_name[i]\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n        elif char == ' ' and paren_depth == 0:\n            # Skip multiple spaces\n            while i < len(field_name) and field_name[i] == ' ':\n                i += 1\n            if current_part:\n                parts.append(current_part)\n                current_part = \"\"\n            i -= 1  # Adjust for the increment at the end of the loop\n        else:\n            current_part += char\n        i += 1\n    \n    if current_part:\n        parts.append(current_part)\n    \n    return parts\n\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current = \"\"\n    paren_depth = 0\n    i = 0\n    \n    while i < len(field_name):\n        char = field_name[i]\n        if char == '(':\n            paren_depth += 1\n            current += char\n        elif char == ')':\n            paren_depth -= 1\n            current += char\n        elif char == ' ' and paren_depth == 0:\n            # Skip multiple spaces\n            while i < len(field_name) and field_name[i] == ' ':\n                i += 1\n            i -= 1  # Adjust for the increment at end of loop\n            if current:\n                parts.append(current)\n                current = \"\"\n        else:\n            current += char\n        i += 1\n    \n    if current:\n        parts.append(current)\n    \n    return parts\n\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\ndef parse_param_field(field_name: str) -> list[str]:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    i = 0\n    \n    while i < len(field_name):\n        char = field_name[i]\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n        elif char == ' ' and paren_depth == 0:\n            # Skip multiple spaces\n            if current_part.strip():\n                parts.append(current_part.strip())\n                current_part = \"\"\n            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n                i += 1\n        else:\n            current_part += char\n        i += 1\n    \n    if current_part.strip():\n        parts.append(current_part.strip())\n    \n    return parts\n\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\ndef parse_param_field(field_name: str) -> list[str]:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    i = 0\n    \n    while i < len(field_name):\n        char = field_name[i]\n        \n        if char == ' ' and paren_depth == 0:\n            # Only split on spaces when not inside parentheses\n            if current_part:\n                parts.append(current_part)\n                current_part = \"\"\n            # Skip multiple consecutive spaces\n            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n                i += 1\n        else:\n            if char == '(':\n                paren_depth += 1\n            elif char == ')':\n                paren_depth -= 1\n            current_part += char\n        \n        i += 1\n    \n    if current_part:\n        parts.append(current_part)\n    \n    return parts\n\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n"
    ],
    "Location 2 (/root/hy/projects/sphinx/sphinx/ext/autodoc/typehints.py lines 139-148)": [
      "\ndef augment_descriptions_with_types(\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        \n        # Parse field name respecting parentheses boundaries\n        parts = []\n        current_part = \"\"\n        paren_depth = 0\n        in_whitespace = False\n        \n        for char in field_name:\n            if char == '(':\n                paren_depth += 1\n                current_part += char\n                in_whitespace = False\n            elif char == ')':\n                paren_depth -= 1\n                current_part += char\n                in_whitespace = False\n            elif char == ' ':\n                if paren_depth == 0:\n                    if not in_whitespace and current_part:\n                        parts.append(current_part)\n                        current_part = \"\"\n                    in_whitespace = True\n                else:\n                    current_part += char\n                    in_whitespace = False\n            else:\n                current_part += char\n                in_whitespace = False\n        \n        if current_part:\n            parts.append(current_part)\n        \n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            has_type.add(name)\n        elif parts[0] == 'return':\n            has_description.add('return')\n        elif parts[0] == 'rtype':\n            has_type.add('return')\n\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    \n    i = 0\n    while i < len(field_name):\n        char = field_name[i]\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n        elif char == ' ' and paren_depth == 0:\n            if current_part:\n                parts.append(current_part)\n                current_part = \"\"\n            # Skip multiple spaces\n            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n                i += 1\n        else:\n            current_part += char\n        i += 1\n    \n    if current_part:\n        parts.append(current_part)\n    \n    return parts\n\ndef augment_descriptions_with_types(\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    in_whitespace = False\n    \n    for char in field_name:\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n            in_whitespace = False\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n            in_whitespace = False\n        elif char == ' ':\n            if paren_depth == 0:\n                if not in_whitespace and current_part:\n                    parts.append(current_part)\n                    current_part = \"\"\n                in_whitespace = True\n            else:\n                current_part += char\n                in_whitespace = False\n        else:\n            current_part += char\n            in_whitespace = False\n    \n    if current_part:\n        parts.append(current_part)\n    \n    return parts\n\n\ndef augment_descriptions_with_types(\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    in_word = False\n    \n    for char in field_name:\n        if char == ' ' and paren_depth == 0 and in_word:\n            if current_part:\n                parts.append(current_part)\n                current_part = \"\"\n                in_word = False\n        elif char != ' ' or paren_depth > 0:\n            if char == '(':\n                paren_depth += 1\n            elif char == ')':\n                paren_depth -= 1\n            current_part += char\n            in_word = True\n    \n    if current_part:\n        parts.append(current_part)\n    \n    return parts\n\ndef augment_descriptions_with_types(\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    in_whitespace = False\n    \n    for char in field_name:\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n            in_whitespace = False\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n            in_whitespace = False\n        elif char == ' ':\n            if paren_depth == 0:\n                if not in_whitespace and current_part:\n                    parts.append(current_part)\n                    current_part = \"\"\n                in_whitespace = True\n            else:\n                current_part += char\n                in_whitespace = False\n        else:\n            current_part += char\n            in_whitespace = False\n    \n    if current_part:\n        parts.append(current_part)\n    \n    return parts\n\n\ndef augment_descriptions_with_types(\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    i = 0\n    \n    while i < len(field_name):\n        char = field_name[i]\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n        elif char == ' ' and paren_depth == 0:\n            # Only split on spaces when not inside parentheses\n            if current_part.strip():\n                parts.append(current_part.strip())\n                current_part = \"\"\n            # Skip multiple spaces\n            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n                i += 1\n        else:\n            current_part += char\n        i += 1\n    \n    if current_part.strip():\n        parts.append(current_part.strip())\n    \n    return parts\n\ndef augment_descriptions_with_types(\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    in_space = False\n    \n    for char in field_name:\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n            in_space = False\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n            in_space = False\n        elif char == ' ':\n            if paren_depth == 0:\n                if not in_space and current_part:\n                    parts.append(current_part)\n                    current_part = \"\"\n                in_space = True\n            else:\n                current_part += char\n                in_space = False\n        else:\n            current_part += char\n            in_space = False\n    \n    if current_part:\n        parts.append(current_part)\n    \n    return parts\n\n\ndef augment_descriptions_with_types(\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n",
      "\ndef parse_param_field(field_name: str) -> list:\n    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n    parts = []\n    current_part = \"\"\n    paren_depth = 0\n    i = 0\n    \n    while i < len(field_name):\n        char = field_name[i]\n        if char == '(':\n            paren_depth += 1\n            current_part += char\n        elif char == ')':\n            paren_depth -= 1\n            current_part += char\n        elif char == ' ' and paren_depth == 0:\n            # Only split on spaces outside parentheses\n            if current_part.strip():\n                parts.append(current_part.strip())\n                current_part = \"\"\n            # Skip consecutive spaces\n            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n                i += 1\n        else:\n            current_part += char\n        i += 1\n    \n    if current_part.strip():\n        parts.append(current_part.strip())\n    \n    return parts\n\ndef augment_descriptions_with_types(\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = parse_param_field(field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..951f697fb 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -85,7 +85,47 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n     fields = cast(Iterable[nodes.field], node)\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def _parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\n+    \n+    For input 'param dict(str, str) opc_meta', returns:\n+    ['param', 'dict(str, str)', 'opc_meta']\n+    \"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        \n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            # Only split on spaces when not inside parentheses\n+            if current_part.strip():\n+                parts.append(current_part.strip())\n+                current_part = \"\"\n+            # Skip consecutive spaces\n+            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n+                i += 1\n+        else:\n+            current_part += char\n+        \n+        i += 1\n+    \n+    # Add the last part if it exists\n+    if current_part.strip():\n+        parts.append(current_part.strip())\n+    \n+    return parts\n+\n+        parts = _parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -136,7 +176,8 @@ def augment_descriptions_with_types(\n     has_type = set()  # type: Set[str]\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+        parts = _parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..e9eff838a 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -85,7 +85,48 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n     fields = cast(Iterable[nodes.field], node)\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        \n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            # Only split on spaces when not inside parentheses\n+            if current_part.strip():\n+                parts.append(current_part.strip())\n+                current_part = \"\"\n+            # Skip consecutive spaces\n+            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n+                i += 1\n+        else:\n+            current_part += char\n+        \n+        i += 1\n+    \n+    if current_part.strip():\n+        parts.append(current_part.strip())\n+    \n+    return parts\n+\n+\n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -136,7 +177,52 @@ def augment_descriptions_with_types(\n     has_type = set()  # type: Set[str]\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        \n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            # Only split on spaces when not inside parentheses\n+            if current_part:\n+                parts.append(current_part)\n+                current_part = \"\"\n+            # Skip consecutive spaces\n+            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n+                i += 1\n+        else:\n+            current_part += char\n+        \n+        i += 1\n+    \n+    if current_part:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+\n+def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..587c1206d 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -85,7 +85,45 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n     fields = cast(Iterable[nodes.field], node)\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            if current_part:\n+                parts.append(current_part)\n+                current_part = \"\"\n+            # Skip multiple spaces\n+            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n+                i += 1\n+        else:\n+            current_part += char\n+        i += 1\n+    \n+    if current_part:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+\n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -136,7 +174,48 @@ def augment_descriptions_with_types(\n     has_type = set()  # type: Set[str]\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        \n+        # Parse field name respecting parentheses boundaries\n+        parts = []\n+        current_part = \"\"\n+        paren_depth = 0\n+        in_whitespace = False\n+        \n+        for char in field_name:\n+            if char == '(':\n+                paren_depth += 1\n+                current_part += char\n+                in_whitespace = False\n+            elif char == ')':\n+                paren_depth -= 1\n+                current_part += char\n+                in_whitespace = False\n+            elif char == ' ':\n+                if paren_depth == 0:\n+                    if not in_whitespace and current_part:\n+                        parts.append(current_part)\n+                        current_part = \"\"\n+                    in_whitespace = True\n+                else:\n+                    current_part += char\n+                    in_whitespace = False\n+            else:\n+                current_part += char\n+                in_whitespace = False\n+        \n+        if current_part:\n+            parts.append(current_part)\n+        \n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -154,6 +233,16 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+    # Add 'type' for parameters with a description but no declared type.\n+    for name in annotations:\n+        elif parts[0] == 'type':\n+            name = ' '.join(parts[1:])\n+            has_type.add(name)\n+        elif parts[0] == 'return':\n+            has_description.add('return')\n+        elif parts[0] == 'rtype':\n+            has_type.add('return')\n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name == 'return':\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..099ab8c22 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -85,7 +85,48 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n     fields = cast(Iterable[nodes.field], node)\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    \n+    i = 0\n+    while i < len(field_name):\n+        char = field_name[i]\n+        \n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            # Only split on spaces when not inside parentheses\n+            if current_part.strip():\n+                parts.append(current_part.strip())\n+                current_part = \"\"\n+            # Skip consecutive spaces\n+            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n+                i += 1\n+        else:\n+            current_part += char\n+        \n+        i += 1\n+    \n+    if current_part.strip():\n+        parts.append(current_part.strip())\n+    \n+    return parts\n+\n+\n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -136,7 +177,48 @@ def augment_descriptions_with_types(\n     has_type = set()  # type: Set[str]\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    \n+    i = 0\n+    while i < len(field_name):\n+        char = field_name[i]\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            if current_part:\n+                parts.append(current_part)\n+                current_part = \"\"\n+            # Skip multiple spaces\n+            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n+                i += 1\n+        else:\n+            current_part += char\n+        i += 1\n+    \n+    if current_part:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..0184d875d 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -85,7 +85,48 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n     fields = cast(Iterable[nodes.field], node)\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    in_word = False\n+    \n+    for char in field_name:\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+            in_word = True\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+            in_word = True\n+        elif char == ' ':\n+            if paren_depth == 0:\n+                if in_word:\n+                    parts.append(current_part)\n+                    current_part = \"\"\n+                    in_word = False\n+            else:\n+                current_part += char\n+                in_word = True\n+        else:\n+            current_part += char\n+            in_word = True\n+    \n+    if in_word:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+\n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -136,7 +177,52 @@ def augment_descriptions_with_types(\n     has_type = set()  # type: Set[str]\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    in_whitespace = False\n+    \n+    for char in field_name:\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+            in_whitespace = False\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+            in_whitespace = False\n+        elif char == ' ':\n+            if paren_depth == 0:\n+                if not in_whitespace and current_part:\n+                    parts.append(current_part)\n+                    current_part = \"\"\n+                in_whitespace = True\n+            else:\n+                current_part += char\n+                in_whitespace = False\n+        else:\n+            current_part += char\n+            in_whitespace = False\n+    \n+    if current_part:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+\n+def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..bdf147a07 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -85,7 +85,46 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n     fields = cast(Iterable[nodes.field], node)\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> List[str]:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            # Skip multiple spaces\n+            while i < len(field_name) and field_name[i] == ' ':\n+                i += 1\n+            i -= 1  # Adjust for the increment at the end of the loop\n+            if current_part:\n+                parts.append(current_part)\n+                current_part = \"\"\n+        else:\n+            current_part += char\n+        i += 1\n+    \n+    if current_part:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+\n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -136,7 +175,43 @@ def augment_descriptions_with_types(\n     has_type = set()  # type: Set[str]\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    in_word = False\n+    \n+    for char in field_name:\n+        if char == ' ' and paren_depth == 0 and in_word:\n+            if current_part:\n+                parts.append(current_part)\n+                current_part = \"\"\n+                in_word = False\n+        elif char != ' ' or paren_depth > 0:\n+            if char == '(':\n+                paren_depth += 1\n+            elif char == ')':\n+                paren_depth -= 1\n+            current_part += char\n+            in_word = True\n+    \n+    if current_part:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..d4e23b334 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -85,7 +85,46 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n     fields = cast(Iterable[nodes.field], node)\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            # Skip multiple spaces\n+            while i < len(field_name) and field_name[i] == ' ':\n+                i += 1\n+            if current_part:\n+                parts.append(current_part)\n+                current_part = \"\"\n+            i -= 1  # Adjust for the increment at the end of the loop\n+        else:\n+            current_part += char\n+        i += 1\n+    \n+    if current_part:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+\n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -136,7 +175,52 @@ def augment_descriptions_with_types(\n     has_type = set()  # type: Set[str]\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    in_whitespace = False\n+    \n+    for char in field_name:\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+            in_whitespace = False\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+            in_whitespace = False\n+        elif char == ' ':\n+            if paren_depth == 0:\n+                if not in_whitespace and current_part:\n+                    parts.append(current_part)\n+                    current_part = \"\"\n+                in_whitespace = True\n+            else:\n+                current_part += char\n+                in_whitespace = False\n+        else:\n+            current_part += char\n+            in_whitespace = False\n+    \n+    if current_part:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+\n+def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..ab7be6850 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -85,7 +85,46 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n     fields = cast(Iterable[nodes.field], node)\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        if char == '(':\n+            paren_depth += 1\n+            current += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current += char\n+        elif char == ' ' and paren_depth == 0:\n+            # Skip multiple spaces\n+            while i < len(field_name) and field_name[i] == ' ':\n+                i += 1\n+            i -= 1  # Adjust for the increment at end of loop\n+            if current:\n+                parts.append(current)\n+                current = \"\"\n+        else:\n+            current += char\n+        i += 1\n+    \n+    if current:\n+        parts.append(current)\n+    \n+    return parts\n+\n+\n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -136,7 +175,49 @@ def augment_descriptions_with_types(\n     has_type = set()  # type: Set[str]\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            # Only split on spaces when not inside parentheses\n+            if current_part.strip():\n+                parts.append(current_part.strip())\n+                current_part = \"\"\n+            # Skip multiple spaces\n+            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n+                i += 1\n+        else:\n+            current_part += char\n+        i += 1\n+    \n+    if current_part.strip():\n+        parts.append(current_part.strip())\n+    \n+    return parts\n+\n+def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..3ca584fa1 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -85,7 +85,45 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n     fields = cast(Iterable[nodes.field], node)\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list[str]:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            # Skip multiple spaces\n+            if current_part.strip():\n+                parts.append(current_part.strip())\n+                current_part = \"\"\n+            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n+                i += 1\n+        else:\n+            current_part += char\n+        i += 1\n+    \n+    if current_part.strip():\n+        parts.append(current_part.strip())\n+    \n+    return parts\n+\n+\n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -136,7 +174,52 @@ def augment_descriptions_with_types(\n     has_type = set()  # type: Set[str]\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    in_space = False\n+    \n+    for char in field_name:\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+            in_space = False\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+            in_space = False\n+        elif char == ' ':\n+            if paren_depth == 0:\n+                if not in_space and current_part:\n+                    parts.append(current_part)\n+                    current_part = \"\"\n+                in_space = True\n+            else:\n+                current_part += char\n+                in_space = False\n+        else:\n+            current_part += char\n+            in_space = False\n+    \n+    if current_part:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+\n+def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex af4b47bb0..0a1c2f4c7 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -85,7 +85,46 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> No\n     fields = cast(Iterable[nodes.field], node)\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list[str]:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        \n+        if char == ' ' and paren_depth == 0:\n+            # Only split on spaces when not inside parentheses\n+            if current_part:\n+                parts.append(current_part)\n+                current_part = \"\"\n+            # Skip multiple consecutive spaces\n+            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n+                i += 1\n+        else:\n+            if char == '(':\n+                paren_depth += 1\n+            elif char == ')':\n+                paren_depth -= 1\n+            current_part += char\n+        \n+        i += 1\n+    \n+    if current_part:\n+        parts.append(current_part)\n+    \n+    return parts\n+\n+\n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -136,7 +175,49 @@ def augment_descriptions_with_types(\n     has_type = set()  # type: Set[str]\n     for field in fields:\n         field_name = field[0].astext()\n-        parts = re.split(' +', field_name)\n+\n+def parse_param_field(field_name: str) -> list:\n+    \"\"\"Parse parameter field name respecting parentheses boundaries.\"\"\"\n+    parts = []\n+    current_part = \"\"\n+    paren_depth = 0\n+    i = 0\n+    \n+    while i < len(field_name):\n+        char = field_name[i]\n+        if char == '(':\n+            paren_depth += 1\n+            current_part += char\n+        elif char == ')':\n+            paren_depth -= 1\n+            current_part += char\n+        elif char == ' ' and paren_depth == 0:\n+            # Only split on spaces outside parentheses\n+            if current_part.strip():\n+                parts.append(current_part.strip())\n+                current_part = \"\"\n+            # Skip consecutive spaces\n+            while i + 1 < len(field_name) and field_name[i + 1] == ' ':\n+                i += 1\n+        else:\n+            current_part += char\n+        i += 1\n+    \n+    if current_part.strip():\n+        parts.append(current_part.strip())\n+    \n+    return parts\n+\n+def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = parse_param_field(field_name)\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n"
  }
}