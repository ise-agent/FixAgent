{
  "zero_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1195-1196)": "\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n\n        # Store tick label visibility states before clearing\n        x_tick_params = {\n            'labelbottom': self.xaxis._major_tick_kw.get('labelbottom', True),\n            'labeltop': self.xaxis._major_tick_kw.get('labeltop', True)\n        }\n        y_tick_params = {\n            'labelleft': self.yaxis._major_tick_kw.get('labelleft', True),\n            'labelright': self.yaxis._major_tick_kw.get('labelright', True)\n        }\n\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Restore x-axis tick label visibility for shared axes\n            self.tick_params(axis='x', **x_tick_params)\n        else:\n",
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1204-1219)": "\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Ensure proper tick label visibility for shared x-axis\n            shared_axes = self._shared_axes['x'].get_siblings(self)\n            if len(shared_axes) > 1:\n                # Find the bottommost axes in the shared group\n                bottommost = min(shared_axes, key=lambda ax: ax.get_position().y0)\n                for ax in shared_axes:\n                    if ax is bottommost:\n                        ax.tick_params(labelbottom=True, labeltop=False)\n                    else:\n                        ax.tick_params(labelbottom=False, labeltop=False)\n        else:\n            self.xaxis._set_scale('linear')\n            try:\n                self.set_xlim(0, 1)\n            except TypeError:\n                pass\n        if self._sharey is not None:\n            self.sharey(self._sharey)\n            # Ensure proper tick label visibility for shared y-axis\n            shared_axes = self._shared_axes['y'].get_siblings(self)\n            if len(shared_axes) > 1:\n                # Find the leftmost axes in the shared group\n                leftmost = min(shared_axes, key=lambda ax: ax.get_position().x0)\n                for ax in shared_axes:\n                    if ax is leftmost:\n                        ax.tick_params(labelleft=True, labelright=False)\n                    else:\n                        ax.tick_params(labelleft=False, labelright=False)\n        else:\n            self.yaxis._set_scale('linear')\n            try:\n                self.set_ylim(0, 1)\n            except TypeError:\n                pass\n",
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1144-1161)": "\n    def sharex(self, other):\n        \"\"\"\n        Share the x-axis with *other*.\n\n        This is equivalent to passing ``sharex=other`` when constructing the\n        axes, and cannot be used if the x-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharex is not None and other is not self._sharex:\n            raise ValueError(\"x-axis is already shared\")\n        self._shared_axes[\"x\"].join(self, other)\n        self._sharex = other\n        self.xaxis.major = other.xaxis.major  # Ticker instances holding\n        self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n        x0, x1 = other.get_xlim()\n        self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n        self.xaxis._scale = other.xaxis._scale\n        \n        # Ensure proper tick label visibility for shared x-axis\n        # Get all axes sharing the x-axis\n        shared_x_axes = self._shared_axes[\"x\"].get_siblings(self)\n        if len(shared_x_axes) > 1:\n            # For shared x-axis, typically only bottom-most axes should show labels\n            for ax in shared_x_axes:\n                # Check if this is the bottom-most axis by comparing positions\n                is_bottom = True\n                ax_bbox = ax.get_position()\n                for other_ax in shared_x_axes:\n                    if other_ax != ax:\n                        other_bbox = other_ax.get_position()\n                        if other_bbox.y0 < ax_bbox.y0:\n                            is_bottom = False\n                            break\n                \n                # Set tick label visibility based on position\n                ax.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n",
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1163-1180)": "\n    def sharey(self, other):\n        \"\"\"\n        Share the y-axis with *other*.\n\n        This is equivalent to passing ``sharey=other`` when constructing the\n        axes, and cannot be used if the y-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharey is not None and other is not self._sharey:\n            raise ValueError(\"y-axis is already shared\")\n        self._shared_axes[\"y\"].join(self, other)\n        self._sharey = other\n        self.yaxis.major = other.yaxis.major  # Ticker instances holding\n        self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n        y0, y1 = other.get_ylim()\n        self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n        self.yaxis._scale = other.yaxis._scale\n        \n        # Configure tick label visibility for shared y-axis\n        # Find all axes that share this y-axis to determine proper label visibility\n        shared_y_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n        if len(shared_y_axes) > 1:\n            # For shared y-axes, typically only leftmost should show left labels\n            # and only rightmost should show right labels\n            leftmost_axes = []\n            rightmost_axes = []\n            \n            # Group by subplot position if available, otherwise use axes position\n            positions = {}\n            for ax in shared_y_axes:\n                if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n                    spec = ax.get_subplotspec()\n                    col = spec.colspan.start if hasattr(spec, 'colspan') else 0\n                    positions[ax] = col\n                else:\n                    # Fallback to axes position\n                    bbox = ax.get_position()\n                    positions[ax] = bbox.x0\n            \n            if positions:\n                min_pos = min(positions.values())\n                max_pos = max(positions.values())\n                \n                for ax in shared_y_axes:\n                    pos = positions[ax]\n                    is_leftmost = (pos == min_pos)\n                    is_rightmost = (pos == max_pos)\n                    \n                    ax.tick_params(axis='y', labelleft=is_leftmost, labelright=False)\n                    # Only show right labels if this is the rightmost and there are multiple columns\n                    if is_rightmost and max_pos > min_pos:\n                        # Check if right labels should be shown based on spine visibility\n                        if hasattr(ax.spines, 'right') and ax.spines['right'].get_visible():\n                            ax.tick_params(axis='y', labelright=True)\n",
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1305-1310)": "\n        if self._sharex is not None:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared x-axis\n            shared_x_axes = self._shared_axes[\"x\"].get_siblings(self)\n            if shared_x_axes:\n                # Only show bottom labels on the bottom row of shared axes\n                is_bottom_row = all(self.get_position().y0 <= other.get_position().y0 \n                                  for other in shared_x_axes if other != self)\n                self.tick_params(axis='x', labelbottom=is_bottom_row, labeltop=False)\n        if self._sharey is not None:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared y-axis\n            shared_y_axes = self._shared_axes[\"y\"].get_siblings(self)\n            if shared_y_axes:\n                # Only show left labels on the leftmost column of shared axes\n                is_left_column = all(self.get_position().x0 <= other.get_position().x0 \n                                   for other in shared_y_axes if other != self)\n                self.tick_params(axis='y', labelleft=is_left_column, labelright=False)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1195-1196)": [
      "\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n\n        # Preserve tick label visibility states for shared axes\n        xaxis_tick_params = {}\n        yaxis_tick_params = {}\n        if hasattr(self.xaxis, 'get_tick_params'):\n            # Store current tick label visibility states\n            xaxis_tick_params = {\n                'labelbottom': any(tick.label1.get_visible() for tick in self.xaxis.get_major_ticks()),\n                'labeltop': any(tick.label2.get_visible() for tick in self.xaxis.get_major_ticks()),\n            }\n        if hasattr(self.yaxis, 'get_tick_params'):\n            yaxis_tick_params = {\n                'labelleft': any(tick.label1.get_visible() for tick in self.yaxis.get_major_ticks()),\n                'labelright': any(tick.label2.get_visible() for tick in self.yaxis.get_major_ticks()),\n            }\n\n        self.xaxis.clear()\n        self.yaxis.clear()\n",
      "\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n\n        # Preserve tick label visibility for shared axes\n        x_tick_params = {}\n        y_tick_params = {}\n        if hasattr(self.xaxis, '_major_tick_kw'):\n            x_tick_params = self.xaxis._major_tick_kw.copy()\n        if hasattr(self.yaxis, '_major_tick_kw'):\n            y_tick_params = self.yaxis._major_tick_kw.copy()\n        \n        # Store current tick label visibility states\n        labelbottom = any(tick.label1.get_visible() for tick in self.xaxis.get_major_ticks())\n        labeltop = any(tick.label2.get_visible() for tick in self.xaxis.get_major_ticks())\n        labelleft = any(tick.label1.get_visible() for tick in self.yaxis.get_major_ticks())\n        labelright = any(tick.label2.get_visible() for tick in self.yaxis.get_major_ticks())\n\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Restore tick label visibility for shared x-axis\n            self.tick_params(axis='x', labelbottom=labelbottom, labeltop=labeltop)\n        else:\n",
      "\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n\n        # Preserve tick label visibility states for shared axes\n        x_tick_params = {}\n        y_tick_params = {}\n        if hasattr(self.xaxis, '_major_tick_kw'):\n            x_tick_params = self.xaxis._major_tick_kw.copy()\n        if hasattr(self.yaxis, '_major_tick_kw'):\n            y_tick_params = self.yaxis._major_tick_kw.copy()\n        \n        # Store current tick label visibility\n        x_labelbottom = any(tick.label1.get_visible() for tick in self.xaxis.get_major_ticks())\n        x_labeltop = any(tick.label2.get_visible() for tick in self.xaxis.get_major_ticks())\n        y_labelleft = any(tick.label1.get_visible() for tick in self.yaxis.get_major_ticks())\n        y_labelright = any(tick.label2.get_visible() for tick in self.yaxis.get_major_ticks())\n\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Restore x-axis tick label visibility for shared axes\n            self.tick_params(axis='x', labelbottom=x_labelbottom, labeltop=x_labeltop)\n        else:\n",
      "\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n        \n        # Preserve tick label visibility states for shared axes\n        x_tick_params = {}\n        y_tick_params = {}\n        if hasattr(self.xaxis, '_major_tick_kw'):\n            x_tick_params = self.xaxis._major_tick_kw.copy()\n        if hasattr(self.yaxis, '_major_tick_kw'):\n            y_tick_params = self.yaxis._major_tick_kw.copy()\n        \n        # Store current tick label visibility\n        x_labelbottom = self.xaxis._major_tick_kw.get('labelbottom', True)\n        x_labeltop = self.xaxis._major_tick_kw.get('labeltop', False)\n        y_labelleft = self.yaxis._major_tick_kw.get('labelleft', True)\n        y_labelright = self.yaxis._major_tick_kw.get('labelright', False)\n\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Restore x-axis tick label visibility for shared axes\n            self.tick_params(axis='x', labelbottom=x_labelbottom, labeltop=x_labeltop)\n        else:\n",
      "\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n        \n        # Preserve tick label visibility states for shared axes\n        x_tick_params = {}\n        y_tick_params = {}\n        if hasattr(self.xaxis, '_major_tick_kw'):\n            x_tick_params = self.xaxis._major_tick_kw.copy()\n        if hasattr(self.yaxis, '_major_tick_kw'):\n            y_tick_params = self.yaxis._major_tick_kw.copy()\n            \n        # Store current tick label visibility\n        x_labelbottom = any(tick.label1.get_visible() for tick in self.xaxis.get_major_ticks())\n        x_labeltop = any(tick.label2.get_visible() for tick in self.xaxis.get_major_ticks())\n        y_labelleft = any(tick.label1.get_visible() for tick in self.yaxis.get_major_ticks())\n        y_labelright = any(tick.label2.get_visible() for tick in self.yaxis.get_major_ticks())\n\n        self.xaxis.clear()\n        self.yaxis.clear()\n",
      "\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n\n        # Preserve tick label visibility for shared axes\n        x_tick_params = {}\n        y_tick_params = {}\n        if hasattr(self.xaxis, '_major_tick_kw'):\n            x_tick_params = self.xaxis._major_tick_kw.copy()\n        if hasattr(self.yaxis, '_major_tick_kw'):\n            y_tick_params = self.yaxis._major_tick_kw.copy()\n            \n        # Store current tick label visibility states\n        labelbottom = any(tick.label1.get_visible() for tick in self.xaxis.get_major_ticks())\n        labeltop = any(tick.label2.get_visible() for tick in self.xaxis.get_major_ticks())\n        labelleft = any(tick.label1.get_visible() for tick in self.yaxis.get_major_ticks())\n        labelright = any(tick.label2.get_visible() for tick in self.yaxis.get_major_ticks())\n\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Restore tick label visibility for shared x-axis\n            self.tick_params(axis='x', labelbottom=labelbottom, labeltop=labeltop)\n        else:\n",
      "\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n\n        # Preserve tick label visibility states for shared axes\n        xaxis_tick_params = {}\n        yaxis_tick_params = {}\n        if hasattr(self.xaxis, '_major_tick_kw'):\n            for key in ['labeltop', 'labelbottom']:\n                if key in self.xaxis._major_tick_kw:\n                    xaxis_tick_params[key] = self.xaxis._major_tick_kw[key]\n        if hasattr(self.yaxis, '_major_tick_kw'):\n            for key in ['labelleft', 'labelright']:\n                if key in self.yaxis._major_tick_kw:\n                    yaxis_tick_params[key] = self.yaxis._major_tick_kw[key]\n\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Restore x-axis tick label visibility for shared axes\n            if xaxis_tick_params:\n                self.tick_params(axis='x', **xaxis_tick_params)\n        else:\n",
      "\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n\n        # Store tick label visibility states before clearing for shared axes\n        xaxis_tick_params = {}\n        yaxis_tick_params = {}\n        if hasattr(self.xaxis, '_major_tick_kw'):\n            for key in ['labelbottom', 'labeltop']:\n                if key in self.xaxis._major_tick_kw:\n                    xaxis_tick_params[key] = self.xaxis._major_tick_kw[key]\n        if hasattr(self.yaxis, '_major_tick_kw'):\n            for key in ['labelleft', 'labelright']:\n                if key in self.yaxis._major_tick_kw:\n                    yaxis_tick_params[key] = self.yaxis._major_tick_kw[key]\n\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n        else:\n            # Restore x-axis tick label visibility if no sharing\n            if xaxis_tick_params:\n                self.tick_params(axis='x', **xaxis_tick_params)\n\n        if self._sharey is not None:\n            self.sharey(self._sharey)\n        else:\n            # Restore y-axis tick label visibility if no sharing\n            if yaxis_tick_params:\n                self.tick_params(axis='y', **yaxis_tick_params)\n"
    ],
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1204-1219)": [
      "\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Ensure proper tick label visibility for shared x-axis\n            self._update_shared_x_labels()\n        else:\n            self.xaxis._set_scale('linear')\n            try:\n                self.set_xlim(0, 1)\n            except TypeError:\n                pass\n        if self._sharey is not None:\n            self.sharey(self._sharey)\n            # Ensure proper tick label visibility for shared y-axis\n            self._update_shared_y_labels()\n        else:\n            self.yaxis._set_scale('linear')\n            try:\n                self.set_ylim(0, 1)\n            except TypeError:\n                pass\n",
      "\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n        else:\n            self.xaxis._set_scale('linear')\n            try:\n                self.set_xlim(0, 1)\n            except TypeError:\n                pass\n        if self._sharey is not None:\n            self.sharey(self._sharey)\n        else:\n            self.yaxis._set_scale('linear')\n            try:\n                self.set_ylim(0, 1)\n            except TypeError:\n                pass\n",
      "\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Ensure proper tick label visibility for shared x-axis\n            shared_axes = self._sharex.get_siblings(self)\n            if len(shared_axes) > 1:\n                # Find the bottom-most axes in the shared group\n                bottom_axes = min(shared_axes, key=lambda ax: ax.get_position().y0)\n                for ax in shared_axes:\n                    if ax is bottom_axes:\n                        ax.tick_params(axis='x', labelbottom=True, labeltop=False)\n                    else:\n                        ax.tick_params(axis='x', labelbottom=False, labeltop=False)\n        else:\n            self.xaxis._set_scale('linear')\n            try:\n                self.set_xlim(0, 1)\n            except TypeError:\n                pass\n        if self._sharey is not None:\n            self.sharey(self._sharey)\n            # Ensure proper tick label visibility for shared y-axis\n            shared_axes = self._sharey.get_siblings(self)\n            if len(shared_axes) > 1:\n                # Find the left-most axes in the shared group\n                left_axes = min(shared_axes, key=lambda ax: ax.get_position().x0)\n                for ax in shared_axes:\n                    if ax is left_axes:\n                        ax.tick_params(axis='y', labelleft=True, labelright=False)\n                    else:\n                        ax.tick_params(axis='y', labelleft=False, labelright=False)\n        else:\n            self.yaxis._set_scale('linear')\n            try:\n                self.set_ylim(0, 1)\n            except TypeError:\n                pass\n",
      "\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Ensure proper tick label visibility for shared x-axis\n            if hasattr(self._sharex, '_shared_axes'):\n                shared_group = self._sharex._shared_axes['x']\n                if self in shared_group:\n                    # Find position in shared group to determine label visibility\n                    axes_list = list(shared_group)\n                    if len(axes_list) > 1:\n                        # Only show labels on bottom-most axes\n                        bottom_axes = max(axes_list, key=lambda ax: ax.get_position().y0 if ax.get_position() else 0)\n                        if self != bottom_axes:\n                            self.tick_params(axis='x', labelbottom=False, labeltop=False)\n        else:\n            self.xaxis._set_scale('linear')\n            try:\n                self.set_xlim(0, 1)\n            except TypeError:\n                pass\n        if self._sharey is not None:\n            self.sharey(self._sharey)\n            # Ensure proper tick label visibility for shared y-axis\n            if hasattr(self._sharey, '_shared_axes'):\n                shared_group = self._sharey._shared_axes['y']\n                if self in shared_group:\n                    # Find position in shared group to determine label visibility\n                    axes_list = list(shared_group)\n                    if len(axes_list) > 1:\n                        # Only show labels on left-most axes\n                        left_axes = min(axes_list, key=lambda ax: ax.get_position().x0 if ax.get_position() else 0)\n                        if self != left_axes:\n                            self.tick_params(axis='y', labelleft=False, labelright=False)\n        else:\n            self.yaxis._set_scale('linear')\n            try:\n                self.set_ylim(0, 1)\n            except TypeError:\n                pass\n",
      "\n    def cla(self):\n        \"\"\"Clear the axes.\"\"\"\n        # Stash the current visibility and sharing state\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n        \n        # Store tick label visibility states for shared axes\n        tick_label_state = {}\n        if self._sharex is not None or self._sharey is not None:\n            tick_label_state = {\n                'labelbottom': self.xaxis._major_tick_kw.get('labelbottom', True),\n                'labeltop': self.xaxis._major_tick_kw.get('labeltop', False),\n                'labelleft': self.yaxis._major_tick_kw.get('labelleft', True),\n                'labelright': self.yaxis._major_tick_kw.get('labelright', False),\n            }\n\n        # We are clearing the axes of data, but preserving the axes\n        # instances, and some of their state.\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n        else:\n            self.xaxis._set_scale('linear')\n            try:\n                self.set_xlim(0, 1)\n            except TypeError:\n                pass\n        if self._sharey is not None:\n            self.sharey(self._sharey)\n        else:\n            self.yaxis._set_scale('linear')\n            try:\n                self.set_ylim(0, 1)\n            except TypeError:\n                pass\n\n        # update the minor locator for x and y axis based on rcParams\n        if mpl.rcParams['xtick.minor.visible']:\n            self.xaxis.set_minor_locator(mticker.AutoMinorLocator())\n        if mpl.rcParams['ytick.minor.visible']:\n            self.yaxis.set_minor_locator(mticker.AutoMinorLocator())\n\n        if self._sharex is None:\n            self._autoscaleXon = True\n        if self._sharey is None:\n            self._autoscaleYon = True\n\n        self._update_transScale()\n\n        # Restore visibility\n        self.xaxis.set_visible(xaxis_visible)\n        self.yaxis.set_visible(yaxis_visible)\n        \n        # Restore tick label visibility for shared axes\n        if tick_label_state:\n            self.tick_params(\n                labelbottom=tick_label_state['labelbottom'],\n                labeltop=tick_label_state['labeltop'],\n                labelleft=tick_label_state['labelleft'],\n                labelright=tick_label_state['labelright']\n            )\n\n        self.stale = True\n",
      "\n    def cla(self):\n        \"\"\"Clear the Axes.\"\"\"\n        # Stash the current view lim as an optimization for the resize\n        # observer.\n        self._stale_viewlim_x = False\n        self._stale_viewlim_y = False\n\n        # Store tick label visibility for shared axes before clearing\n        xaxis_labelbottom = self.xaxis._major_tick_kw.get('labelbottom', True)\n        xaxis_labeltop = self.xaxis._major_tick_kw.get('labeltop', False)\n        yaxis_labelleft = self.yaxis._major_tick_kw.get('labelleft', True)\n        yaxis_labelright = self.yaxis._major_tick_kw.get('labelright', False)\n\n        # Clear all the children except for the background patch.\n        for child in self.get_children():\n            if child is not self.patch:\n                child.remove()\n\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Restore tick label visibility for shared x-axis\n            self.tick_params(axis='x', labelbottom=xaxis_labelbottom, labeltop=xaxis_labeltop)\n        else:\n            self.xaxis._set_scale('linear')\n            try:\n                self.set_xlim(0, 1)\n            except TypeError:\n                pass\n        if self._sharey is not None:\n            self.sharey(self._sharey)\n            # Restore tick label visibility for shared y-axis\n            self.tick_params(axis='y', labelleft=yaxis_labelleft, labelright=yaxis_labelright)\n        else:\n            self.yaxis._set_scale('linear')\n            try:\n                self.set_ylim(0, 1)\n            except TypeError:\n                pass\n",
      "\n        self.xaxis.clear()\n        self.yaxis.clear()\n\n        for name, spine in self.spines.items():\n            spine.clear()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            self.sharex(self._sharex)\n            # Ensure proper tick label visibility for shared x-axis\n            if hasattr(self, '_shared_x_axes') and self._sharex in self._shared_x_axes:\n                shared_axes = self._shared_x_axes[self._sharex]\n                for ax in shared_axes:\n                    if ax != self._sharex:  # Don't modify the master axis\n                        ax.tick_params(labelbottom=False, labeltop=False)\n        else:\n            self.xaxis._set_scale('linear')\n            try:\n                self.set_xlim(0, 1)\n            except TypeError:\n                pass\n        if self._sharey is not None:\n            self.sharey(self._sharey)\n            # Ensure proper tick label visibility for shared y-axis\n            if hasattr(self, '_shared_y_axes') and self._sharey in self._shared_y_axes:\n                shared_axes = self._shared_y_axes[self._sharey]\n                for ax in shared_axes:\n                    if ax != self._sharey:  # Don't modify the master axis\n                        ax.tick_params(labelleft=False, labelright=False)\n        else:\n            self.yaxis._set_scale('linear')\n            try:\n                self.set_ylim(0, 1)\n            except TypeError:\n                pass\n",
      "\ndef cla(self):\n    \"\"\"Clear the axes.\"\"\"\n    # Stash the current visibility state so that layout engines have the\n    # information they need to make decisions.\n    self.stale = True\n\n    # Store sharing and tick visibility state before clearing\n    sharex_state = self._sharex\n    sharey_state = self._sharey\n    \n    # Store tick label visibility states for shared axes\n    tick_label_state = {}\n    if sharex_state is not None:\n        tick_label_state['labelbottom'] = self.xaxis._major_tick_kw.get('label1On', True)\n        tick_label_state['labeltop'] = self.xaxis._major_tick_kw.get('label2On', False)\n    if sharey_state is not None:\n        tick_label_state['labelleft'] = self.yaxis._major_tick_kw.get('label1On', True)\n        tick_label_state['labelright'] = self.yaxis._major_tick_kw.get('label2On', False)\n\n    self._axes_locator = None\n    self.relim()\n    self.set_axis_off()  # clear the axis\n    self._set_lim_and_transforms()\n\n    self.xaxis.clear()\n    self.yaxis.clear()\n\n    for name, spine in self.spines.items():\n        spine.clear()\n\n    self.ignore_existing_data_limits = True\n    self.callbacks = cbook.CallbackRegistry()\n\n    if self._sharex is not None:\n        self.sharex(self._sharex)\n        # Restore tick label visibility for shared x-axis\n        if 'labelbottom' in tick_label_state:\n            self.tick_params(axis='x', labelbottom=tick_label_state['labelbottom'])\n        if 'labeltop' in tick_label_state:\n            self.tick_params(axis='x', labeltop=tick_label_state['labeltop'])\n    else:\n        self.xaxis._set_scale('linear')\n        try:\n            self.set_xlim(0, 1)\n        except TypeError:\n            pass\n    if self._sharey is not None:\n        self.sharey(self._sharey)\n        # Restore tick label visibility for shared y-axis\n        if 'labelleft' in tick_label_state:\n            self.tick_params(axis='y', labelleft=tick_label_state['labelleft'])\n        if 'labelright' in tick_label_state:\n            self.tick_params(axis='y', labelright=tick_label_state['labelright'])\n    else:\n        self.yaxis._set_scale('linear')\n        try:\n            self.set_ylim(0, 1)\n        except TypeError:\n            pass\n"
    ],
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1144-1161)": [
      "\n    def sharex(self, other):\n        \"\"\"\n        Share the x-axis with *other*.\n\n        This is equivalent to passing ``sharex=other`` when constructing the\n        axes, and cannot be used if the x-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharex is not None and other is not self._sharex:\n            raise ValueError(\"x-axis is already shared\")\n        self._shared_axes[\"x\"].join(self, other)\n        self._sharex = other\n        self.xaxis.major = other.xaxis.major  # Ticker instances holding\n        self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n        x0, x1 = other.get_xlim()\n        self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n        self.xaxis._scale = other.xaxis._scale\n        \n        # Ensure proper tick label visibility for shared x-axes\n        shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n        if len(shared_axes) > 1:\n            # Find which axes should show x-axis labels (typically bottom row)\n            for ax in shared_axes:\n                if hasattr(ax, '_position') and ax._position is not None:\n                    row, col = ax._position\n                    is_bottom = True\n                    for other_ax in shared_axes:\n                        if (hasattr(other_ax, '_position') and other_ax._position is not None and\n                            other_ax._position[1] == col and other_ax._position[0] > row):\n                            is_bottom = False\n                            break\n                    ax.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n",
      "\n    def sharex(self, other):\n        \"\"\"\n        Share the x-axis with *other*.\n\n        This is equivalent to passing ``sharex=other`` when constructing the\n        axes, and cannot be used if the x-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharex is not None and other is not self._sharex:\n            raise ValueError(\"x-axis is already shared\")\n        self._shared_axes[\"x\"].join(self, other)\n        self._sharex = other\n        self.xaxis.major = other.xaxis.major  # Ticker instances holding\n        self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n        x0, x1 = other.get_xlim()\n        self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n        self.xaxis._scale = other.xaxis._scale\n        \n        # Ensure proper tick label visibility for shared axes\n        # Only show labels on appropriate edges based on sharing group\n        shared_group = self._shared_axes[\"x\"].get_siblings(self)\n        if len(shared_group) > 1:\n            # For shared x-axes, typically only bottom axes show labels\n            # This is a heuristic - in practice, subplot creation handles this properly\n            # but we need to maintain it after clearing\n            pass  # Let the existing tick visibility logic handle this\n",
      "\n    def sharex(self, other):\n        \"\"\"\n        Share the x-axis with *other*.\n\n        This is equivalent to passing ``sharex=other`` when constructing the\n        axes, and cannot be used if the x-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharex is not None and other is not self._sharex:\n            raise ValueError(\"x-axis is already shared\")\n        self._shared_axes[\"x\"].join(self, other)\n        self._sharex = other\n        self.xaxis.major = other.xaxis.major  # Ticker instances holding\n        self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n        x0, x1 = other.get_xlim()\n        self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n        self.xaxis._scale = other.xaxis._scale\n        \n        # Ensure proper tick label visibility for shared axes\n        # Get all axes sharing the x-axis\n        shared_x_axes = self._shared_axes[\"x\"].get_siblings(self)\n        \n        # For shared x-axes, typically only bottom row should show labels\n        for ax in shared_x_axes:\n            # Check if this axes is at the bottom of its subplot arrangement\n            # by checking if there are any shared axes below it\n            is_bottom = True\n            for other_ax in shared_x_axes:\n                if (other_ax is not ax and \n                    hasattr(other_ax, 'get_position') and \n                    hasattr(ax, 'get_position')):\n                    other_pos = other_ax.get_position()\n                    ax_pos = ax.get_position()\n                    # If another axes is below this one, this is not bottom\n                    if other_pos.y0 < ax_pos.y0:\n                        is_bottom = False\n                        break\n            \n            # Set tick label visibility based on position\n            ax.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n",
      "\n    def sharex(self, other):\n        \"\"\"\n        Share the x-axis with *other*.\n\n        This is equivalent to passing ``sharex=other`` when constructing the\n        axes, and cannot be used if the x-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharex is not None and other is not self._sharex:\n            raise ValueError(\"x-axis is already shared\")\n        self._shared_axes[\"x\"].join(self, other)\n        self._sharex = other\n        self.xaxis.major = other.xaxis.major  # Ticker instances holding\n        self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n        x0, x1 = other.get_xlim()\n        self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n        self.xaxis._scale = other.xaxis._scale\n        \n        # Ensure proper tick label visibility for shared x-axis\n        # Only the bottom-most axes in a shared group should show x-axis labels\n        shared_axes = list(self._shared_axes[\"x\"])\n        for ax in shared_axes:\n            # Check if this axes is at the bottom of its subplot arrangement\n            # by comparing with other shared axes\n            is_bottom = True\n            for other_ax in shared_axes:\n                if (other_ax != ax and \n                    hasattr(other_ax, 'get_position') and \n                    hasattr(ax, 'get_position')):\n                    other_pos = other_ax.get_position()\n                    ax_pos = ax.get_position()\n                    # If there's another axes below this one, it's not the bottom\n                    if (abs(other_pos.x0 - ax_pos.x0) < 1e-6 and \n                        other_pos.y0 < ax_pos.y0):\n                        is_bottom = False\n                        break\n            \n            # Set tick label visibility based on position\n            ax.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n",
      "\n    def sharex(self, other):\n        \"\"\"\n        Share the x-axis with *other*.\n\n        This is equivalent to passing ``sharex=other`` when constructing the\n        axes, and cannot be used if the x-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharex is not None and other is not self._sharex:\n            raise ValueError(\"x-axis is already shared\")\n        self._shared_axes[\"x\"].join(self, other)\n        self._sharex = other\n        self.xaxis.major = other.xaxis.major  # Ticker instances holding\n        self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n        x0, x1 = other.get_xlim()\n        self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n        self.xaxis._scale = other.xaxis._scale\n        \n        # Ensure proper tick label visibility for shared axes\n        # Only the bottom-most axes in a shared group should show x labels\n        shared_axes = list(self._shared_axes[\"x\"].get_siblings(self))\n        if len(shared_axes) > 1:\n            # Find which axes should show labels (typically the bottom ones)\n            axes_with_positions = []\n            for ax in shared_axes:\n                if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n                    spec = ax.get_subplotspec()\n                    axes_with_positions.append((ax, spec.rowspan.stop - 1))\n            \n            if axes_with_positions:\n                max_row = max(pos[1] for pos in axes_with_positions)\n                for ax, row in axes_with_positions:\n                    if row == max_row:\n                        ax.tick_params(axis='x', labelbottom=True, labeltop=False)\n                    else:\n                        ax.tick_params(axis='x', labelbottom=False, labeltop=False)\n",
      "\n    def sharex(self, other):\n        \"\"\"\n        Share the x-axis with *other*.\n\n        This is equivalent to passing ``sharex=other`` when constructing the\n        axes, and cannot be used if the x-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharex is not None and other is not self._sharex:\n            raise ValueError(\"x-axis is already shared\")\n        self._shared_axes[\"x\"].join(self, other)\n        self._sharex = other\n        self.xaxis.major = other.xaxis.major  # Ticker instances holding\n        self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n        x0, x1 = other.get_xlim()\n        self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n        self.xaxis._scale = other.xaxis._scale\n        \n        # Configure tick label visibility for shared x-axis\n        shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n        if len(shared_axes) > 1:\n            # For shared x-axes, only bottom-most axes should show bottom labels\n            # and only top-most axes should show top labels\n            positions = [ax.get_position() for ax in shared_axes]\n            bottom_y = min(pos.y0 for pos in positions)\n            top_y = max(pos.y1 for pos in positions)\n            \n            for ax in shared_axes:\n                pos = ax.get_position()\n                show_bottom = abs(pos.y0 - bottom_y) < 1e-6\n                show_top = abs(pos.y1 - top_y) < 1e-6\n                ax.tick_params(axis='x', which='both', \n                              labelbottom=show_bottom, labeltop=show_top)\n",
      "\n    def sharex(self, other):\n        \"\"\"\n        Share the x-axis with *other*.\n\n        This is equivalent to passing ``sharex=other`` when constructing the\n        axes, and cannot be used if the x-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharex is not None and other is not self._sharex:\n            raise ValueError(\"x-axis is already shared\")\n        self._shared_axes[\"x\"].join(self, other)\n        self._sharex = other\n        self.xaxis.major = other.xaxis.major  # Ticker instances holding\n        self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n        x0, x1 = other.get_xlim()\n        self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n        self.xaxis._scale = other.xaxis._scale\n        # Ensure proper tick label visibility for shared axes\n        # Get all axes sharing the same x-axis\n        shared_x_axes = self._shared_axes[\"x\"].get_siblings(self)\n        if len(shared_x_axes) > 1:\n            # Find the bottom-most axes in the shared group\n            bottom_axes = []\n            for ax in shared_x_axes:\n                if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n                    # For subplot axes, check if this is the bottom row\n                    subplotspec = ax.get_subplotspec()\n                    if hasattr(subplotspec, 'rowspan'):\n                        row_end = subplotspec.rowspan.stop - 1\n                        # Check if this is the last row by comparing with other axes\n                        is_bottom = True\n                        for other_ax in shared_x_axes:\n                            if (hasattr(other_ax, 'get_subplotspec') and \n                                other_ax.get_subplotspec() is not None):\n                                other_spec = other_ax.get_subplotspec()\n                                if hasattr(other_spec, 'rowspan'):\n                                    other_row_end = other_spec.rowspan.stop - 1\n                                    if other_row_end > row_end:\n                                        is_bottom = False\n                                        break\n                        if is_bottom:\n                            bottom_axes.append(ax)\n                else:\n                    # For non-subplot axes, assume they should show labels\n                    bottom_axes.append(ax)\n            \n            # Set tick label visibility\n            for ax in shared_x_axes:\n                if ax in bottom_axes:\n                    ax.tick_params(axis='x', labelbottom=True, labeltop=False)\n                else:\n                    ax.tick_params(axis='x', labelbottom=False, labeltop=False)\n",
      "\n    def sharex(self, other):\n        \"\"\"\n        Share the x-axis with *other*.\n\n        This is equivalent to passing ``sharex=other`` when constructing the\n        axes, and cannot be used if the x-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharex is not None and other is not self._sharex:\n            raise ValueError(\"x-axis is already shared\")\n        self._shared_axes[\"x\"].join(self, other)\n        self._sharex = other\n        self.xaxis.major = other.xaxis.major  # Ticker instances holding\n        self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n        x0, x1 = other.get_xlim()\n        self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n        self.xaxis._scale = other.xaxis._scale\n        \n        # Configure tick label visibility for shared x-axis\n        # Get all axes sharing the same x-axis\n        shared_x_axes = list(self._shared_axes[\"x\"].get_siblings(self))\n        if len(shared_x_axes) > 1:\n            # Find the bottom-most axes in the shared group\n            bottom_axes = []\n            max_row = max(ax.get_position().y0 for ax in shared_x_axes if hasattr(ax, 'get_position'))\n            for ax in shared_x_axes:\n                if hasattr(ax, 'get_position') and ax.get_position().y0 == max_row:\n                    bottom_axes.append(ax)\n            \n            # Only bottom axes should show x-axis labels\n            for ax in shared_x_axes:\n                if ax in bottom_axes:\n                    ax.tick_params(axis='x', labelbottom=True, labeltop=False)\n                else:\n                    ax.tick_params(axis='x', labelbottom=False, labeltop=False)\n"
    ],
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1163-1180)": [
      "\n    def sharey(self, other):\n        \"\"\"\n        Share the y-axis with *other*.\n\n        This is equivalent to passing ``sharey=other`` when constructing the\n        axes, and cannot be used if the y-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharey is not None and other is not self._sharey:\n            raise ValueError(\"y-axis is already shared\")\n        self._shared_axes[\"y\"].join(self, other)\n        self._sharey = other\n        self.yaxis.major = other.yaxis.major  # Ticker instances holding\n        self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n        y0, y1 = other.get_ylim()\n        self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n        self.yaxis._scale = other.yaxis._scale\n        \n        # Configure tick label visibility for shared y-axis\n        # Only the leftmost axes in a shared group should show left labels\n        # Only the rightmost axes in a shared group should show right labels\n        shared_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n        if len(shared_axes) > 1:\n            # For shared y-axis, typically only leftmost shows left labels\n            # and rightmost shows right labels\n            for ax in shared_axes:\n                # Default to hiding labels, specific positioning logic\n                # will be handled by subplot arrangements\n                ax.tick_params(axis='y', which='both', \n                             labelleft=True, labelright=False)\n",
      "\n    def sharey(self, other):\n        \"\"\"\n        Share the y-axis with *other*.\n\n        This is equivalent to passing ``sharey=other`` when constructing the\n        axes, and cannot be used if the y-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharey is not None and other is not self._sharey:\n            raise ValueError(\"y-axis is already shared\")\n        self._shared_axes[\"y\"].join(self, other)\n        self._sharey = other\n        self.yaxis.major = other.yaxis.major  # Ticker instances holding\n        self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n        y0, y1 = other.get_ylim()\n        self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n        self.yaxis._scale = other.yaxis._scale\n        \n        # Configure tick label visibility for shared y-axis\n        # Only the leftmost axes in a shared group should show left labels\n        # Only the rightmost axes in a shared group should show right labels\n        shared_y_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n        for ax in shared_y_axes:\n            # Default: hide all y-axis labels\n            ax.tick_params(axis='y', labelleft=False, labelright=False)\n        \n        # Find leftmost and rightmost axes to show appropriate labels\n        if shared_y_axes:\n            # Sort by x-position to find leftmost/rightmost\n            sorted_axes = sorted(shared_y_axes, key=lambda ax: ax.get_position().x0)\n            leftmost = sorted_axes[0]\n            rightmost = sorted_axes[-1]\n            \n            # Show left labels on leftmost axes\n            leftmost.tick_params(axis='y', labelleft=True)\n            # Show right labels on rightmost axes if it's different from leftmost\n            if rightmost != leftmost:\n                rightmost.tick_params(axis='y', labelright=False)  # Keep right labels hidden\n",
      "\n    def sharey(self, other):\n        \"\"\"\n        Share the y-axis with *other*.\n\n        This is equivalent to passing ``sharey=other`` when constructing the\n        axes, and cannot be used if the y-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharey is not None and other is not self._sharey:\n            raise ValueError(\"y-axis is already shared\")\n        self._shared_axes[\"y\"].join(self, other)\n        self._sharey = other\n        self.yaxis.major = other.yaxis.major  # Ticker instances holding\n        self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n        y0, y1 = other.get_ylim()\n        self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n        self.yaxis._scale = other.yaxis._scale\n        \n        # Configure tick label visibility for shared y-axis\n        # Find all axes in the shared group to determine proper label visibility\n        shared_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n        \n        # For shared y-axis, typically only leftmost axes show left labels\n        # and rightmost axes show right labels\n        leftmost_axes = []\n        rightmost_axes = []\n        \n        for ax in shared_axes:\n            if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n                # For subplot axes, use column position\n                ss = ax.get_subplotspec()\n                if hasattr(ss, 'colspan') and hasattr(ss, 'rowspan'):\n                    col_start = ss.colspan.start\n                    col_stop = ss.colspan.stop\n                    if not leftmost_axes or col_start <= min(a.get_subplotspec().colspan.start for a in leftmost_axes):\n                        if not leftmost_axes or col_start < min(a.get_subplotspec().colspan.start for a in leftmost_axes):\n                            leftmost_axes = [ax]\n                        else:\n                            leftmost_axes.append(ax)\n                    if not rightmost_axes or col_stop >= max(a.get_subplotspec().colspan.stop for a in rightmost_axes):\n                        if not rightmost_axes or col_stop > max(a.get_subplotspec().colspan.stop for a in rightmost_axes):\n                            rightmost_axes = [ax]\n                        else:\n                            rightmost_axes.append(ax)\n        \n        # If we can't determine positions, fall back to simpler logic\n        if not leftmost_axes:\n            leftmost_axes = [shared_axes[0]]  # Default to first axis\n        if not rightmost_axes:\n            rightmost_axes = [shared_axes[-1]]  # Default to last axis\n            \n        # Set tick label visibility\n        for ax in shared_axes:\n            labelleft = ax in leftmost_axes\n            labelright = ax in rightmost_axes and len(rightmost_axes) > 0\n            ax.tick_params(axis='y', labelleft=labelleft, labelright=labelright)\n",
      "\n    def sharey(self, other):\n        \"\"\"\n        Share the y-axis with *other*.\n\n        This is equivalent to passing ``sharey=other`` when constructing the\n        axes, and cannot be used if the y-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharey is not None and other is not self._sharey:\n            raise ValueError(\"y-axis is already shared\")\n        self._shared_axes[\"y\"].join(self, other)\n        self._sharey = other\n        self.yaxis.major = other.yaxis.major  # Ticker instances holding\n        self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n        y0, y1 = other.get_ylim()\n        self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n        self.yaxis._scale = other.yaxis._scale\n        \n        # Configure tick label visibility for shared y-axis\n        # Get all axes that share this y-axis\n        shared_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n        if len(shared_axes) > 1:\n            # For shared y-axis, typically only leftmost axes show left labels\n            # and only rightmost axes show right labels\n            for ax in shared_axes:\n                # Get position info if available (for subplots)\n                if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n                    subplotspec = ax.get_subplotspec()\n                    # Show left labels only for leftmost column\n                    show_left = subplotspec.colspan.start == 0\n                    # Show right labels only for rightmost column  \n                    show_right = subplotspec.colspan.stop == subplotspec.get_gridspec().ncols\n                    ax.tick_params(axis='y', labelleft=show_left, labelright=show_right)\n",
      "\n    def sharey(self, other):\n        \"\"\"\n        Share the y-axis with *other*.\n\n        This is equivalent to passing ``sharey=other`` when constructing the\n        axes, and cannot be used if the y-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharey is not None and other is not self._sharey:\n            raise ValueError(\"y-axis is already shared\")\n        self._shared_axes[\"y\"].join(self, other)\n        self._sharey = other\n        self.yaxis.major = other.yaxis.major  # Ticker instances holding\n        self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n        y0, y1 = other.get_ylim()\n        self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n        self.yaxis._scale = other.yaxis._scale\n        \n        # Update tick parameters to handle shared axis visibility properly\n        # For shared y-axis, we need to manage left/right tick label visibility\n        shared_axes = list(self._shared_axes[\"y\"])\n        for ax in shared_axes:\n            # Determine position in shared group to set appropriate visibility\n            ax_bbox = ax.get_position()\n            leftmost = True\n            rightmost = True\n            for other_ax in shared_axes:\n                if other_ax is not ax:\n                    other_bbox = other_ax.get_position()\n                    if other_bbox.x0 < ax_bbox.x0:\n                        leftmost = False\n                    if other_bbox.x1 > ax_bbox.x1:\n                        rightmost = False\n            \n            # Set tick label visibility based on position\n            ax.tick_params(axis='y', labelleft=leftmost, labelright=False)\n",
      "\ndef sharey(self, other):\n    \"\"\"\n    Share the y-axis with *other*.\n\n    This is equivalent to passing ``sharey=other`` when constructing the\n    axes, and cannot be used if the y-axis is already being shared with\n    another axes.\n    \"\"\"\n    _api.check_isinstance(_AxesBase, other=other)\n    if self._sharey is not None and other is not self._sharey:\n        raise ValueError(\"y-axis is already shared\")\n    self._shared_axes[\"y\"].join(self, other)\n    self._sharey = other\n    self.yaxis.major = other.yaxis.major  # Ticker instances holding\n    self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n    y0, y1 = other.get_ylim()\n    self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n    self.yaxis._scale = other.yaxis._scale\n    \n    # Ensure proper tick label visibility for shared y-axis\n    # Get all axes sharing the y-axis\n    shared_axes = self._shared_axes[\"y\"].get_siblings(self)\n    if len(shared_axes) > 1:\n        # For shared y-axes, typically only leftmost axes should show left labels\n        # and only rightmost axes should show right labels\n        for ax in shared_axes:\n            # Default to hiding both left and right labels\n            ax.tick_params(axis='y', labelleft=False, labelright=False)\n        \n        # Find leftmost and rightmost axes based on their position\n        leftmost_axes = []\n        rightmost_axes = []\n        \n        for ax in shared_axes:\n            is_leftmost = True\n            is_rightmost = True\n            \n            for other_ax in shared_axes:\n                if other_ax != ax:\n                    # Check if there's an axes to the left\n                    if (hasattr(ax, 'get_position') and hasattr(other_ax, 'get_position') and\n                        other_ax.get_position().x0 < ax.get_position().x0):\n                        is_leftmost = False\n                    # Check if there's an axes to the right  \n                    if (hasattr(ax, 'get_position') and hasattr(other_ax, 'get_position') and\n                        other_ax.get_position().x1 > ax.get_position().x1):\n                        is_rightmost = False\n            \n            if is_leftmost:\n                leftmost_axes.append(ax)\n            if is_rightmost:\n                rightmost_axes.append(ax)\n        \n        # Enable left labels for leftmost axes\n        for ax in leftmost_axes:\n            ax.tick_params(axis='y', labelleft=True)\n            \n        # Enable right labels for rightmost axes if they have right spine visible\n        for ax in rightmost_axes:\n            if ax.spines['right'].get_visible():\n                ax.tick_params(axis='y', labelright=True)\n",
      "\n    def sharey(self, other):\n        \"\"\"\n        Share the y-axis with *other*.\n\n        This is equivalent to passing ``sharey=other`` when constructing the\n        axes, and cannot be used if the y-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharey is not None and other is not self._sharey:\n            raise ValueError(\"y-axis is already shared\")\n        self._shared_axes[\"y\"].join(self, other)\n        self._sharey = other\n        self.yaxis.major = other.yaxis.major  # Ticker instances holding\n        self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n        y0, y1 = other.get_ylim()\n        self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n        self.yaxis._scale = other.yaxis._scale\n        \n        # Ensure proper tick label visibility for shared axes\n        # Check if this axes should show y-axis labels based on its position\n        # in the shared group - typically only the leftmost column should show labels\n        shared_axes = list(self._shared_axes[\"y\"])\n        if len(shared_axes) > 1:\n            # Find the leftmost axes in the shared group\n            leftmost_axes = min(shared_axes, \n                              key=lambda ax: ax.get_position().x0 if hasattr(ax.get_position(), 'x0') else 0)\n            \n            # Only the leftmost axes should show left labels\n            if self is leftmost_axes:\n                self.tick_params(labelleft=True, labelright=False)\n            else:\n                self.tick_params(labelleft=False, labelright=False)\n",
      "\n    def sharey(self, other):\n        \"\"\"\n        Share the y-axis with *other*.\n\n        This is equivalent to passing ``sharey=other`` when constructing the\n        axes, and cannot be used if the y-axis is already being shared with\n        another axes.\n        \"\"\"\n        _api.check_isinstance(_AxesBase, other=other)\n        if self._sharey is not None and other is not self._sharey:\n            raise ValueError(\"y-axis is already shared\")\n        self._shared_axes[\"y\"].join(self, other)\n        self._sharey = other\n        self.yaxis.major = other.yaxis.major  # Ticker instances holding\n        self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n        y0, y1 = other.get_ylim()\n        self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n        self.yaxis._scale = other.yaxis._scale\n        \n        # Configure tick label visibility for shared y-axis\n        # Find all axes that share this y-axis\n        shared_y_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n        \n        # Determine which axes should show y-axis labels (leftmost column)\n        if len(shared_y_axes) > 1:\n            # Get positions of all shared axes\n            positions = []\n            for ax in shared_y_axes:\n                if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n                    spec = ax.get_subplotspec()\n                    positions.append((ax, spec.colspan.start))\n                else:\n                    # Fallback: use axes position\n                    bbox = ax.get_position()\n                    positions.append((ax, bbox.x0))\n            \n            if positions:\n                # Sort by x position to find leftmost\n                positions.sort(key=lambda x: x[1])\n                leftmost_x = positions[0][1]\n                \n                for ax, x_pos in positions:\n                    # Only leftmost axes should show left labels\n                    show_left = abs(x_pos - leftmost_x) < 1e-10\n                    ax.tick_params(axis='y', labelleft=show_left, labelright=False)\n"
    ],
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1305-1310)": [
      "\n        if self._sharex is not None:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared x-axis\n            shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n            if len(shared_axes) > 1:\n                # Determine if this is the bottom-most axes in the shared group\n                is_bottom = all(self.get_position().y0 <= other.get_position().y0 \n                              for other in shared_axes if other != self)\n                self.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n        if self._sharey is not None:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared y-axis\n            shared_axes = self._shared_axes[\"y\"].get_siblings(self)\n            if len(shared_axes) > 1:\n                # Determine if this is the left-most axes in the shared group\n                is_left = all(self.get_position().x0 <= other.get_position().x0 \n                            for other in shared_axes if other != self)\n                self.tick_params(axis='y', labelleft=is_left, labelright=False)\n",
      "\n        if self._sharex is not None:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore tick label visibility for shared x-axis\n            if hasattr(self, '_saved_tick_params'):\n                self.tick_params(axis='x', **self._saved_tick_params.get('x', {}))\n        if self._sharey is not None:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore tick label visibility for shared y-axis\n            if hasattr(self, '_saved_tick_params'):\n                self.tick_params(axis='y', **self._saved_tick_params.get('y', {}))\n",
      "\n        if self._sharex is not None:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared x-axis\n            if hasattr(self, '_saved_tick_params'):\n                self.tick_params(axis='x', **self._saved_tick_params.get('x', {}))\n        if self._sharey is not None:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared y-axis\n            if hasattr(self, '_saved_tick_params'):\n                self.tick_params(axis='y', **self._saved_tick_params.get('y', {}))\n",
      "\n        if self._sharex is not None:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared x-axis\n            shared_group = self._shared_axes[\"x\"].get_siblings(self)\n            if len(shared_group) > 1:\n                # Determine if this axis should show x tick labels\n                # Only bottom-most axes in shared group should show bottom labels\n                should_show_bottom = True\n                should_show_top = True\n                for other_ax in shared_group:\n                    if other_ax is not self:\n                        # Simple heuristic: if another axis is below this one, hide bottom labels\n                        if hasattr(other_ax, 'get_position') and hasattr(self, 'get_position'):\n                            other_pos = other_ax.get_position()\n                            self_pos = self.get_position()\n                            if other_pos.y0 < self_pos.y0:\n                                should_show_bottom = False\n                            if other_pos.y0 > self_pos.y0:\n                                should_show_top = False\n                self.tick_params(axis='x', labelbottom=should_show_bottom, labeltop=should_show_top)\n        if self._sharey is not None:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared y-axis\n            shared_group = self._shared_axes[\"y\"].get_siblings(self)\n            if len(shared_group) > 1:\n                # Determine if this axis should show y tick labels\n                # Only left-most axes in shared group should show left labels\n                should_show_left = True\n                should_show_right = True\n                for other_ax in shared_group:\n                    if other_ax is not self:\n                        # Simple heuristic: if another axis is to the left, hide left labels\n                        if hasattr(other_ax, 'get_position') and hasattr(self, 'get_position'):\n                            other_pos = other_ax.get_position()\n                            self_pos = self.get_position()\n                            if other_pos.x0 < self_pos.x0:\n                                should_show_left = False\n                            if other_pos.x0 > self_pos.x0:\n                                should_show_right = False\n                self.tick_params(axis='y', labelleft=should_show_left, labelright=should_show_right)\n",
      "\n        if self._sharex is not None:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore tick label visibility for shared x-axis\n            self._sharex._adjust_autoscale_locked()\n            self._sharex._shared_axes[\"x\"]._update_ticks()\n        if self._sharey is not None:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore tick label visibility for shared y-axis\n            self._sharey._adjust_autoscale_locked()\n            self._sharey._shared_axes[\"y\"]._update_ticks()\n",
      "\n        if self._sharex is not None:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared x-axes\n            shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n            if len(shared_axes) > 1:\n                # Determine if this is a bottom axis that should show labels\n                is_bottom = all(ax.get_position().y0 >= self.get_position().y0 \n                              for ax in shared_axes if ax is not self)\n                self.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n        if self._sharey is not None:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared y-axes\n            shared_axes = self._shared_axes[\"y\"].get_siblings(self)\n            if len(shared_axes) > 1:\n                # Determine if this is a left axis that should show labels\n                is_left = all(ax.get_position().x0 >= self.get_position().x0 \n                            for ax in shared_axes if ax is not self)\n                self.tick_params(axis='y', labelleft=is_left, labelright=False)\n",
      "\n        if self._sharex is not None:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared x-axis\n            shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n            if len(shared_axes) > 1:\n                # For shared x-axis, typically only bottom axes show labels\n                is_bottom = all(other.get_position().y0 >= self.get_position().y0 \n                              for other in shared_axes if other != self)\n                self.tick_params(labelbottom=is_bottom, labeltop=False)\n        if self._sharey is not None:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared y-axis\n            shared_axes = self._shared_axes[\"y\"].get_siblings(self)\n            if len(shared_axes) > 1:\n                # For shared y-axis, typically only left axes show labels\n                is_left = all(other.get_position().x0 >= self.get_position().x0 \n                            for other in shared_axes if other != self)\n                self.tick_params(labelleft=is_left, labelright=False)\n",
      "\n        if self._sharex is not None:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared x-axis\n            shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n            if len(shared_axes) > 1:\n                # For shared x-axis, only bottom-most axes should show bottom labels\n                # and only top-most axes should show top labels\n                positions = [ax.get_position() for ax in shared_axes]\n                bottom_y = min(pos.y0 for pos in positions)\n                top_y = max(pos.y0 + pos.height for pos in positions)\n                \n                current_pos = self.get_position()\n                is_bottom = abs(current_pos.y0 - bottom_y) < 1e-10\n                is_top = abs(current_pos.y0 + current_pos.height - top_y) < 1e-10\n                \n                self.tick_params(axis='x', labelbottom=is_bottom, labeltop=is_top)\n        if self._sharey is not None:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n            # Restore proper tick label visibility for shared y-axis\n            shared_axes = self._shared_axes[\"y\"].get_siblings(self)\n            if len(shared_axes) > 1:\n                # For shared y-axis, only left-most axes should show left labels\n                # and only right-most axes should show right labels\n                positions = [ax.get_position() for ax in shared_axes]\n                left_x = min(pos.x0 for pos in positions)\n                right_x = max(pos.x0 + pos.width for pos in positions)\n                \n                current_pos = self.get_position()\n                is_left = abs(current_pos.x0 - left_x) < 1e-10\n                is_right = abs(current_pos.x0 + current_pos.width - right_x) < 1e-10\n                \n                self.tick_params(axis='y', labelleft=is_left, labelright=is_right)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 802fd3c997..8823179de1 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1141,6 +1141,7 @@ class _AxesBase(martist.Artist):\n         return OrderedDict((side, mspines.Spine.linear_spine(self, side))\n                            for side in ['left', 'right', 'bottom', 'top'])\n \n+\n     def sharex(self, other):\n         \"\"\"\n         Share the x-axis with *other*.\n@@ -1159,6 +1160,13 @@ class _AxesBase(martist.Artist):\n         x0, x1 = other.get_xlim()\n         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n         self.xaxis._scale = other.xaxis._scale\n+        \n+        # Configure tick label visibility for shared x-axis\n+        # Copy tick label visibility settings from the shared axis\n+        other_labelbottom = other.xaxis._major_tick_kw.get('labelbottom', True)\n+        other_labeltop = other.xaxis._major_tick_kw.get('labeltop', False)\n+        self.tick_params(axis='x', labelbottom=other_labelbottom, labeltop=other_labeltop)\n+\n \n     def sharey(self, other):\n         \"\"\"\n@@ -1178,6 +1186,12 @@ class _AxesBase(martist.Artist):\n         y0, y1 = other.get_ylim()\n         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n         self.yaxis._scale = other.yaxis._scale\n+        \n+        # Configure tick label visibility for shared y-axis\n+        # Copy tick label visibility settings from the shared axis\n+        other_labelleft = other.yaxis._major_tick_kw.get('labelleft', True)\n+        other_labelright = other.yaxis._major_tick_kw.get('labelright', False)\n+        self.tick_params(axis='y', labelleft=other_labelleft, labelright=other_labelright)\n \n     def cla(self):\n         \"\"\"Clear the axes.\"\"\"\n@@ -1192,6 +1206,19 @@ class _AxesBase(martist.Artist):\n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n \n+\n+        # stash the current visibility state and tick label visibility\n+        xaxis_tick_params = {}\n+        yaxis_tick_params = {}\n+        \n+        # Store tick label visibility states for shared axes\n+        if self._sharex is not None:\n+            xaxis_tick_params['labelbottom'] = self.xaxis._major_tick_kw.get('labelbottom', True)\n+            xaxis_tick_params['labeltop'] = self.xaxis._major_tick_kw.get('labeltop', False)\n+        if self._sharey is not None:\n+            yaxis_tick_params['labelleft'] = self.yaxis._major_tick_kw.get('labelleft', True)\n+            yaxis_tick_params['labelright'] = self.yaxis._major_tick_kw.get('labelright', False)\n+\n         self.xaxis.clear()\n         self.yaxis.clear()\n \n@@ -1201,8 +1228,12 @@ class _AxesBase(martist.Artist):\n         self.ignore_existing_data_limits = True\n         self.callbacks = cbook.CallbackRegistry()\n \n+\n         if self._sharex is not None:\n             self.sharex(self._sharex)\n+            # Restore tick label visibility for shared x-axis\n+            if xaxis_tick_params:\n+                self.tick_params(axis='x', **xaxis_tick_params)\n         else:\n             self.xaxis._set_scale('linear')\n             try:\n@@ -1211,6 +1242,9 @@ class _AxesBase(martist.Artist):\n                 pass\n         if self._sharey is not None:\n             self.sharey(self._sharey)\n+            # Restore tick label visibility for shared y-axis\n+            if yaxis_tick_params:\n+                self.tick_params(axis='y', **yaxis_tick_params)\n         else:\n             self.yaxis._set_scale('linear')\n             try:\n@@ -1302,12 +1336,19 @@ class _AxesBase(martist.Artist):\n \n         self._shared_axes[\"x\"].clean()\n         self._shared_axes[\"y\"].clean()\n+\n         if self._sharex is not None:\n             self.xaxis.set_visible(xaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore tick label visibility for shared x-axis\n+            if 'xaxis_tick_params' in locals() and xaxis_tick_params:\n+                self.tick_params(axis='x', **xaxis_tick_params)\n         if self._sharey is not None:\n             self.yaxis.set_visible(yaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore tick label visibility for shared y-axis\n+            if 'yaxis_tick_params' in locals() and yaxis_tick_params:\n+                self.tick_params(axis='y', **yaxis_tick_params)\n \n         self.stale = True\n \n",
    "variant_0": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 802fd3c997..2111d2c7a9 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1141,6 +1141,7 @@ class _AxesBase(martist.Artist):\n         return OrderedDict((side, mspines.Spine.linear_spine(self, side))\n                            for side in ['left', 'right', 'bottom', 'top'])\n \n+\n     def sharex(self, other):\n         \"\"\"\n         Share the x-axis with *other*.\n@@ -1159,6 +1160,26 @@ class _AxesBase(martist.Artist):\n         x0, x1 = other.get_xlim()\n         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n         self.xaxis._scale = other.xaxis._scale\n+        \n+        # Ensure proper tick label visibility for shared x-axis\n+        # Get all axes sharing the x-axis\n+        shared_x_axes = self._shared_axes[\"x\"].get_siblings(self)\n+        if len(shared_x_axes) > 1:\n+            # For shared x-axis, typically only bottom-most axes should show labels\n+            for ax in shared_x_axes:\n+                # Check if this is the bottom-most axis by comparing positions\n+                is_bottom = True\n+                ax_bbox = ax.get_position()\n+                for other_ax in shared_x_axes:\n+                    if other_ax != ax:\n+                        other_bbox = other_ax.get_position()\n+                        if other_bbox.y0 < ax_bbox.y0:\n+                            is_bottom = False\n+                            break\n+                \n+                # Set tick label visibility based on position\n+                ax.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n+\n \n     def sharey(self, other):\n         \"\"\"\n@@ -1178,6 +1199,43 @@ class _AxesBase(martist.Artist):\n         y0, y1 = other.get_ylim()\n         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n         self.yaxis._scale = other.yaxis._scale\n+        \n+        # Configure tick label visibility for shared y-axis\n+        # Find all axes that share this y-axis to determine proper label visibility\n+        shared_y_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n+        if len(shared_y_axes) > 1:\n+            # For shared y-axes, typically only leftmost should show left labels\n+            # and only rightmost should show right labels\n+            leftmost_axes = []\n+            rightmost_axes = []\n+            \n+            # Group by subplot position if available, otherwise use axes position\n+            positions = {}\n+            for ax in shared_y_axes:\n+                if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n+                    spec = ax.get_subplotspec()\n+                    col = spec.colspan.start if hasattr(spec, 'colspan') else 0\n+                    positions[ax] = col\n+                else:\n+                    # Fallback to axes position\n+                    bbox = ax.get_position()\n+                    positions[ax] = bbox.x0\n+            \n+            if positions:\n+                min_pos = min(positions.values())\n+                max_pos = max(positions.values())\n+                \n+                for ax in shared_y_axes:\n+                    pos = positions[ax]\n+                    is_leftmost = (pos == min_pos)\n+                    is_rightmost = (pos == max_pos)\n+                    \n+                    ax.tick_params(axis='y', labelleft=is_leftmost, labelright=False)\n+                    # Only show right labels if this is the rightmost and there are multiple columns\n+                    if is_rightmost and max_pos > min_pos:\n+                        # Check if right labels should be shown based on spine visibility\n+                        if hasattr(ax.spines, 'right') and ax.spines['right'].get_visible():\n+                            ax.tick_params(axis='y', labelright=True)\n \n     def cla(self):\n         \"\"\"Clear the axes.\"\"\"\n@@ -1192,6 +1250,26 @@ class _AxesBase(martist.Artist):\n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n \n+\n+        # stash the current visibility state\n+        if hasattr(self, 'patch'):\n+            patch_visible = self.patch.get_visible()\n+        else:\n+            patch_visible = True\n+\n+        xaxis_visible = self.xaxis.get_visible()\n+        yaxis_visible = self.yaxis.get_visible()\n+\n+        # Store tick label visibility states before clearing\n+        x_tick_params = {\n+            'labelbottom': self.xaxis._major_tick_kw.get('labelbottom', True),\n+            'labeltop': self.xaxis._major_tick_kw.get('labeltop', True)\n+        }\n+        y_tick_params = {\n+            'labelleft': self.yaxis._major_tick_kw.get('labelleft', True),\n+            'labelright': self.yaxis._major_tick_kw.get('labelright', True)\n+        }\n+\n         self.xaxis.clear()\n         self.yaxis.clear()\n \n@@ -1203,6 +1281,38 @@ class _AxesBase(martist.Artist):\n \n         if self._sharex is not None:\n             self.sharex(self._sharex)\n+            # Restore x-axis tick label visibility for shared axes\n+            self.tick_params(axis='x', **x_tick_params)\n+        else:\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+\n+        self.xaxis.clear()\n+        self.yaxis.clear()\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+        if self._sharex is not None:\n+            self.sharex(self._sharex)\n+            # Ensure proper tick label visibility for shared x-axis\n+            shared_axes = self._shared_axes['x'].get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # Find the bottommost axes in the shared group\n+                bottommost = min(shared_axes, key=lambda ax: ax.get_position().y0)\n+                for ax in shared_axes:\n+                    if ax is bottommost:\n+                        ax.tick_params(labelbottom=True, labeltop=False)\n+                    else:\n+                        ax.tick_params(labelbottom=False, labeltop=False)\n         else:\n             self.xaxis._set_scale('linear')\n             try:\n@@ -1211,6 +1321,16 @@ class _AxesBase(martist.Artist):\n                 pass\n         if self._sharey is not None:\n             self.sharey(self._sharey)\n+            # Ensure proper tick label visibility for shared y-axis\n+            shared_axes = self._shared_axes['y'].get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # Find the leftmost axes in the shared group\n+                leftmost = min(shared_axes, key=lambda ax: ax.get_position().x0)\n+                for ax in shared_axes:\n+                    if ax is leftmost:\n+                        ax.tick_params(labelleft=True, labelright=False)\n+                    else:\n+                        ax.tick_params(labelleft=False, labelright=False)\n         else:\n             self.yaxis._set_scale('linear')\n             try:\n@@ -1302,12 +1422,27 @@ class _AxesBase(martist.Artist):\n \n         self._shared_axes[\"x\"].clean()\n         self._shared_axes[\"y\"].clean()\n+\n         if self._sharex is not None:\n             self.xaxis.set_visible(xaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared x-axis\n+            shared_x_axes = self._shared_axes[\"x\"].get_siblings(self)\n+            if shared_x_axes:\n+                # Only show bottom labels on the bottom row of shared axes\n+                is_bottom_row = all(self.get_position().y0 <= other.get_position().y0 \n+                                  for other in shared_x_axes if other != self)\n+                self.tick_params(axis='x', labelbottom=is_bottom_row, labeltop=False)\n         if self._sharey is not None:\n             self.yaxis.set_visible(yaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared y-axis\n+            shared_y_axes = self._shared_axes[\"y\"].get_siblings(self)\n+            if shared_y_axes:\n+                # Only show left labels on the leftmost column of shared axes\n+                is_left_column = all(self.get_position().x0 <= other.get_position().x0 \n+                                   for other in shared_y_axes if other != self)\n+                self.tick_params(axis='y', labelleft=is_left_column, labelright=False)\n \n         self.stale = True\n \n",
    "variant_1": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 802fd3c997..acf03420c1 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1141,6 +1141,7 @@ class _AxesBase(martist.Artist):\n         return OrderedDict((side, mspines.Spine.linear_spine(self, side))\n                            for side in ['left', 'right', 'bottom', 'top'])\n \n+\n     def sharex(self, other):\n         \"\"\"\n         Share the x-axis with *other*.\n@@ -1159,6 +1160,22 @@ class _AxesBase(martist.Artist):\n         x0, x1 = other.get_xlim()\n         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n         self.xaxis._scale = other.xaxis._scale\n+        \n+        # Ensure proper tick label visibility for shared x-axes\n+        shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n+        if len(shared_axes) > 1:\n+            # Find which axes should show x-axis labels (typically bottom row)\n+            for ax in shared_axes:\n+                if hasattr(ax, '_position') and ax._position is not None:\n+                    row, col = ax._position\n+                    is_bottom = True\n+                    for other_ax in shared_axes:\n+                        if (hasattr(other_ax, '_position') and other_ax._position is not None and\n+                            other_ax._position[1] == col and other_ax._position[0] > row):\n+                            is_bottom = False\n+                            break\n+                    ax.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n+\n \n     def sharey(self, other):\n         \"\"\"\n@@ -1178,6 +1195,19 @@ class _AxesBase(martist.Artist):\n         y0, y1 = other.get_ylim()\n         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n         self.yaxis._scale = other.yaxis._scale\n+        \n+        # Configure tick label visibility for shared y-axis\n+        # Only the leftmost axes in a shared group should show left labels\n+        # Only the rightmost axes in a shared group should show right labels\n+        shared_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n+        if len(shared_axes) > 1:\n+            # For shared y-axis, typically only leftmost shows left labels\n+            # and rightmost shows right labels\n+            for ax in shared_axes:\n+                # Default to hiding labels, specific positioning logic\n+                # will be handled by subplot arrangements\n+                ax.tick_params(axis='y', which='both', \n+                             labelleft=True, labelright=False)\n \n     def cla(self):\n         \"\"\"Clear the axes.\"\"\"\n@@ -1192,6 +1222,41 @@ class _AxesBase(martist.Artist):\n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n \n+\n+        # stash the current visibility state\n+        if hasattr(self, 'patch'):\n+            patch_visible = self.patch.get_visible()\n+        else:\n+            patch_visible = True\n+\n+        xaxis_visible = self.xaxis.get_visible()\n+        yaxis_visible = self.yaxis.get_visible()\n+\n+        # Preserve tick label visibility states for shared axes\n+        xaxis_tick_params = {}\n+        yaxis_tick_params = {}\n+        if hasattr(self.xaxis, 'get_tick_params'):\n+            # Store current tick label visibility states\n+            xaxis_tick_params = {\n+                'labelbottom': any(tick.label1.get_visible() for tick in self.xaxis.get_major_ticks()),\n+                'labeltop': any(tick.label2.get_visible() for tick in self.xaxis.get_major_ticks()),\n+            }\n+        if hasattr(self.yaxis, 'get_tick_params'):\n+            yaxis_tick_params = {\n+                'labelleft': any(tick.label1.get_visible() for tick in self.yaxis.get_major_ticks()),\n+                'labelright': any(tick.label2.get_visible() for tick in self.yaxis.get_major_ticks()),\n+            }\n+\n+        self.xaxis.clear()\n+        self.yaxis.clear()\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+\n         self.xaxis.clear()\n         self.yaxis.clear()\n \n@@ -1203,6 +1268,8 @@ class _AxesBase(martist.Artist):\n \n         if self._sharex is not None:\n             self.sharex(self._sharex)\n+            # Ensure proper tick label visibility for shared x-axis\n+            self._update_shared_x_labels()\n         else:\n             self.xaxis._set_scale('linear')\n             try:\n@@ -1211,6 +1278,8 @@ class _AxesBase(martist.Artist):\n                 pass\n         if self._sharey is not None:\n             self.sharey(self._sharey)\n+            # Ensure proper tick label visibility for shared y-axis\n+            self._update_shared_y_labels()\n         else:\n             self.yaxis._set_scale('linear')\n             try:\n@@ -1302,12 +1371,27 @@ class _AxesBase(martist.Artist):\n \n         self._shared_axes[\"x\"].clean()\n         self._shared_axes[\"y\"].clean()\n+\n         if self._sharex is not None:\n             self.xaxis.set_visible(xaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared x-axis\n+            shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # Determine if this is the bottom-most axes in the shared group\n+                is_bottom = all(self.get_position().y0 <= other.get_position().y0 \n+                              for other in shared_axes if other != self)\n+                self.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n         if self._sharey is not None:\n             self.yaxis.set_visible(yaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared y-axis\n+            shared_axes = self._shared_axes[\"y\"].get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # Determine if this is the left-most axes in the shared group\n+                is_left = all(self.get_position().x0 <= other.get_position().x0 \n+                            for other in shared_axes if other != self)\n+                self.tick_params(axis='y', labelleft=is_left, labelright=False)\n \n         self.stale = True\n \n",
    "variant_2": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 802fd3c997..9c69da686d 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1141,6 +1141,7 @@ class _AxesBase(martist.Artist):\n         return OrderedDict((side, mspines.Spine.linear_spine(self, side))\n                            for side in ['left', 'right', 'bottom', 'top'])\n \n+\n     def sharex(self, other):\n         \"\"\"\n         Share the x-axis with *other*.\n@@ -1159,6 +1160,16 @@ class _AxesBase(martist.Artist):\n         x0, x1 = other.get_xlim()\n         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n         self.xaxis._scale = other.xaxis._scale\n+        \n+        # Ensure proper tick label visibility for shared axes\n+        # Only show labels on appropriate edges based on sharing group\n+        shared_group = self._shared_axes[\"x\"].get_siblings(self)\n+        if len(shared_group) > 1:\n+            # For shared x-axes, typically only bottom axes show labels\n+            # This is a heuristic - in practice, subplot creation handles this properly\n+            # but we need to maintain it after clearing\n+            pass  # Let the existing tick visibility logic handle this\n+\n \n     def sharey(self, other):\n         \"\"\"\n@@ -1178,6 +1189,27 @@ class _AxesBase(martist.Artist):\n         y0, y1 = other.get_ylim()\n         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n         self.yaxis._scale = other.yaxis._scale\n+        \n+        # Configure tick label visibility for shared y-axis\n+        # Only the leftmost axes in a shared group should show left labels\n+        # Only the rightmost axes in a shared group should show right labels\n+        shared_y_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n+        for ax in shared_y_axes:\n+            # Default: hide all y-axis labels\n+            ax.tick_params(axis='y', labelleft=False, labelright=False)\n+        \n+        # Find leftmost and rightmost axes to show appropriate labels\n+        if shared_y_axes:\n+            # Sort by x-position to find leftmost/rightmost\n+            sorted_axes = sorted(shared_y_axes, key=lambda ax: ax.get_position().x0)\n+            leftmost = sorted_axes[0]\n+            rightmost = sorted_axes[-1]\n+            \n+            # Show left labels on leftmost axes\n+            leftmost.tick_params(axis='y', labelleft=True)\n+            # Show right labels on rightmost axes if it's different from leftmost\n+            if rightmost != leftmost:\n+                rightmost.tick_params(axis='y', labelright=False)  # Keep right labels hidden\n \n     def cla(self):\n         \"\"\"Clear the axes.\"\"\"\n@@ -1192,6 +1224,52 @@ class _AxesBase(martist.Artist):\n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n \n+\n+        # stash the current visibility state\n+        if hasattr(self, 'patch'):\n+            patch_visible = self.patch.get_visible()\n+        else:\n+            patch_visible = True\n+\n+        xaxis_visible = self.xaxis.get_visible()\n+        yaxis_visible = self.yaxis.get_visible()\n+\n+        # Preserve tick label visibility for shared axes\n+        x_tick_params = {}\n+        y_tick_params = {}\n+        if hasattr(self.xaxis, '_major_tick_kw'):\n+            x_tick_params = self.xaxis._major_tick_kw.copy()\n+        if hasattr(self.yaxis, '_major_tick_kw'):\n+            y_tick_params = self.yaxis._major_tick_kw.copy()\n+        \n+        # Store current tick label visibility states\n+        labelbottom = any(tick.label1.get_visible() for tick in self.xaxis.get_major_ticks())\n+        labeltop = any(tick.label2.get_visible() for tick in self.xaxis.get_major_ticks())\n+        labelleft = any(tick.label1.get_visible() for tick in self.yaxis.get_major_ticks())\n+        labelright = any(tick.label2.get_visible() for tick in self.yaxis.get_major_ticks())\n+\n+        self.xaxis.clear()\n+        self.yaxis.clear()\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+        if self._sharex is not None:\n+            self.sharex(self._sharex)\n+            # Restore tick label visibility for shared x-axis\n+            self.tick_params(axis='x', labelbottom=labelbottom, labeltop=labeltop)\n+        else:\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+\n         self.xaxis.clear()\n         self.yaxis.clear()\n \n@@ -1302,12 +1380,19 @@ class _AxesBase(martist.Artist):\n \n         self._shared_axes[\"x\"].clean()\n         self._shared_axes[\"y\"].clean()\n+\n         if self._sharex is not None:\n             self.xaxis.set_visible(xaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore tick label visibility for shared x-axis\n+            if hasattr(self, '_saved_tick_params'):\n+                self.tick_params(axis='x', **self._saved_tick_params.get('x', {}))\n         if self._sharey is not None:\n             self.yaxis.set_visible(yaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore tick label visibility for shared y-axis\n+            if hasattr(self, '_saved_tick_params'):\n+                self.tick_params(axis='y', **self._saved_tick_params.get('y', {}))\n \n         self.stale = True\n \n",
    "variant_3": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 802fd3c997..5214124f55 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1141,6 +1141,7 @@ class _AxesBase(martist.Artist):\n         return OrderedDict((side, mspines.Spine.linear_spine(self, side))\n                            for side in ['left', 'right', 'bottom', 'top'])\n \n+\n     def sharex(self, other):\n         \"\"\"\n         Share the x-axis with *other*.\n@@ -1159,6 +1160,30 @@ class _AxesBase(martist.Artist):\n         x0, x1 = other.get_xlim()\n         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n         self.xaxis._scale = other.xaxis._scale\n+        \n+        # Ensure proper tick label visibility for shared axes\n+        # Get all axes sharing the x-axis\n+        shared_x_axes = self._shared_axes[\"x\"].get_siblings(self)\n+        \n+        # For shared x-axes, typically only bottom row should show labels\n+        for ax in shared_x_axes:\n+            # Check if this axes is at the bottom of its subplot arrangement\n+            # by checking if there are any shared axes below it\n+            is_bottom = True\n+            for other_ax in shared_x_axes:\n+                if (other_ax is not ax and \n+                    hasattr(other_ax, 'get_position') and \n+                    hasattr(ax, 'get_position')):\n+                    other_pos = other_ax.get_position()\n+                    ax_pos = ax.get_position()\n+                    # If another axes is below this one, this is not bottom\n+                    if other_pos.y0 < ax_pos.y0:\n+                        is_bottom = False\n+                        break\n+            \n+            # Set tick label visibility based on position\n+            ax.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n+\n \n     def sharey(self, other):\n         \"\"\"\n@@ -1178,6 +1203,45 @@ class _AxesBase(martist.Artist):\n         y0, y1 = other.get_ylim()\n         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n         self.yaxis._scale = other.yaxis._scale\n+        \n+        # Configure tick label visibility for shared y-axis\n+        # Find all axes in the shared group to determine proper label visibility\n+        shared_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n+        \n+        # For shared y-axis, typically only leftmost axes show left labels\n+        # and rightmost axes show right labels\n+        leftmost_axes = []\n+        rightmost_axes = []\n+        \n+        for ax in shared_axes:\n+            if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n+                # For subplot axes, use column position\n+                ss = ax.get_subplotspec()\n+                if hasattr(ss, 'colspan') and hasattr(ss, 'rowspan'):\n+                    col_start = ss.colspan.start\n+                    col_stop = ss.colspan.stop\n+                    if not leftmost_axes or col_start <= min(a.get_subplotspec().colspan.start for a in leftmost_axes):\n+                        if not leftmost_axes or col_start < min(a.get_subplotspec().colspan.start for a in leftmost_axes):\n+                            leftmost_axes = [ax]\n+                        else:\n+                            leftmost_axes.append(ax)\n+                    if not rightmost_axes or col_stop >= max(a.get_subplotspec().colspan.stop for a in rightmost_axes):\n+                        if not rightmost_axes or col_stop > max(a.get_subplotspec().colspan.stop for a in rightmost_axes):\n+                            rightmost_axes = [ax]\n+                        else:\n+                            rightmost_axes.append(ax)\n+        \n+        # If we can't determine positions, fall back to simpler logic\n+        if not leftmost_axes:\n+            leftmost_axes = [shared_axes[0]]  # Default to first axis\n+        if not rightmost_axes:\n+            rightmost_axes = [shared_axes[-1]]  # Default to last axis\n+            \n+        # Set tick label visibility\n+        for ax in shared_axes:\n+            labelleft = ax in leftmost_axes\n+            labelright = ax in rightmost_axes and len(rightmost_axes) > 0\n+            ax.tick_params(axis='y', labelleft=labelleft, labelright=labelright)\n \n     def cla(self):\n         \"\"\"Clear the axes.\"\"\"\n@@ -1192,6 +1256,52 @@ class _AxesBase(martist.Artist):\n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n \n+\n+        # stash the current visibility state\n+        if hasattr(self, 'patch'):\n+            patch_visible = self.patch.get_visible()\n+        else:\n+            patch_visible = True\n+\n+        xaxis_visible = self.xaxis.get_visible()\n+        yaxis_visible = self.yaxis.get_visible()\n+\n+        # Preserve tick label visibility states for shared axes\n+        x_tick_params = {}\n+        y_tick_params = {}\n+        if hasattr(self.xaxis, '_major_tick_kw'):\n+            x_tick_params = self.xaxis._major_tick_kw.copy()\n+        if hasattr(self.yaxis, '_major_tick_kw'):\n+            y_tick_params = self.yaxis._major_tick_kw.copy()\n+        \n+        # Store current tick label visibility\n+        x_labelbottom = any(tick.label1.get_visible() for tick in self.xaxis.get_major_ticks())\n+        x_labeltop = any(tick.label2.get_visible() for tick in self.xaxis.get_major_ticks())\n+        y_labelleft = any(tick.label1.get_visible() for tick in self.yaxis.get_major_ticks())\n+        y_labelright = any(tick.label2.get_visible() for tick in self.yaxis.get_major_ticks())\n+\n+        self.xaxis.clear()\n+        self.yaxis.clear()\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+        if self._sharex is not None:\n+            self.sharex(self._sharex)\n+            # Restore x-axis tick label visibility for shared axes\n+            self.tick_params(axis='x', labelbottom=x_labelbottom, labeltop=x_labeltop)\n+        else:\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+\n         self.xaxis.clear()\n         self.yaxis.clear()\n \n@@ -1203,6 +1313,16 @@ class _AxesBase(martist.Artist):\n \n         if self._sharex is not None:\n             self.sharex(self._sharex)\n+            # Ensure proper tick label visibility for shared x-axis\n+            shared_axes = self._sharex.get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # Find the bottom-most axes in the shared group\n+                bottom_axes = min(shared_axes, key=lambda ax: ax.get_position().y0)\n+                for ax in shared_axes:\n+                    if ax is bottom_axes:\n+                        ax.tick_params(axis='x', labelbottom=True, labeltop=False)\n+                    else:\n+                        ax.tick_params(axis='x', labelbottom=False, labeltop=False)\n         else:\n             self.xaxis._set_scale('linear')\n             try:\n@@ -1211,6 +1331,16 @@ class _AxesBase(martist.Artist):\n                 pass\n         if self._sharey is not None:\n             self.sharey(self._sharey)\n+            # Ensure proper tick label visibility for shared y-axis\n+            shared_axes = self._sharey.get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # Find the left-most axes in the shared group\n+                left_axes = min(shared_axes, key=lambda ax: ax.get_position().x0)\n+                for ax in shared_axes:\n+                    if ax is left_axes:\n+                        ax.tick_params(axis='y', labelleft=True, labelright=False)\n+                    else:\n+                        ax.tick_params(axis='y', labelleft=False, labelright=False)\n         else:\n             self.yaxis._set_scale('linear')\n             try:\n@@ -1302,12 +1432,19 @@ class _AxesBase(martist.Artist):\n \n         self._shared_axes[\"x\"].clean()\n         self._shared_axes[\"y\"].clean()\n+\n         if self._sharex is not None:\n             self.xaxis.set_visible(xaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared x-axis\n+            if hasattr(self, '_saved_tick_params'):\n+                self.tick_params(axis='x', **self._saved_tick_params.get('x', {}))\n         if self._sharey is not None:\n             self.yaxis.set_visible(yaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared y-axis\n+            if hasattr(self, '_saved_tick_params'):\n+                self.tick_params(axis='y', **self._saved_tick_params.get('y', {}))\n \n         self.stale = True\n \n",
    "variant_4": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 802fd3c997..dd56887448 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1141,6 +1141,7 @@ class _AxesBase(martist.Artist):\n         return OrderedDict((side, mspines.Spine.linear_spine(self, side))\n                            for side in ['left', 'right', 'bottom', 'top'])\n \n+\n     def sharex(self, other):\n         \"\"\"\n         Share the x-axis with *other*.\n@@ -1159,6 +1160,29 @@ class _AxesBase(martist.Artist):\n         x0, x1 = other.get_xlim()\n         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n         self.xaxis._scale = other.xaxis._scale\n+        \n+        # Ensure proper tick label visibility for shared x-axis\n+        # Only the bottom-most axes in a shared group should show x-axis labels\n+        shared_axes = list(self._shared_axes[\"x\"])\n+        for ax in shared_axes:\n+            # Check if this axes is at the bottom of its subplot arrangement\n+            # by comparing with other shared axes\n+            is_bottom = True\n+            for other_ax in shared_axes:\n+                if (other_ax != ax and \n+                    hasattr(other_ax, 'get_position') and \n+                    hasattr(ax, 'get_position')):\n+                    other_pos = other_ax.get_position()\n+                    ax_pos = ax.get_position()\n+                    # If there's another axes below this one, it's not the bottom\n+                    if (abs(other_pos.x0 - ax_pos.x0) < 1e-6 and \n+                        other_pos.y0 < ax_pos.y0):\n+                        is_bottom = False\n+                        break\n+            \n+            # Set tick label visibility based on position\n+            ax.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n+\n \n     def sharey(self, other):\n         \"\"\"\n@@ -1178,6 +1202,22 @@ class _AxesBase(martist.Artist):\n         y0, y1 = other.get_ylim()\n         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n         self.yaxis._scale = other.yaxis._scale\n+        \n+        # Configure tick label visibility for shared y-axis\n+        # Get all axes that share this y-axis\n+        shared_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n+        if len(shared_axes) > 1:\n+            # For shared y-axis, typically only leftmost axes show left labels\n+            # and only rightmost axes show right labels\n+            for ax in shared_axes:\n+                # Get position info if available (for subplots)\n+                if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n+                    subplotspec = ax.get_subplotspec()\n+                    # Show left labels only for leftmost column\n+                    show_left = subplotspec.colspan.start == 0\n+                    # Show right labels only for rightmost column  \n+                    show_right = subplotspec.colspan.stop == subplotspec.get_gridspec().ncols\n+                    ax.tick_params(axis='y', labelleft=show_left, labelright=show_right)\n \n     def cla(self):\n         \"\"\"Clear the axes.\"\"\"\n@@ -1192,6 +1232,30 @@ class _AxesBase(martist.Artist):\n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n \n+\n+        # stash the current visibility state\n+        if hasattr(self, 'patch'):\n+            patch_visible = self.patch.get_visible()\n+        else:\n+            patch_visible = True\n+\n+        xaxis_visible = self.xaxis.get_visible()\n+        yaxis_visible = self.yaxis.get_visible()\n+        \n+        # Preserve tick label visibility states for shared axes\n+        x_tick_params = {}\n+        y_tick_params = {}\n+        if hasattr(self.xaxis, '_major_tick_kw'):\n+            x_tick_params = self.xaxis._major_tick_kw.copy()\n+        if hasattr(self.yaxis, '_major_tick_kw'):\n+            y_tick_params = self.yaxis._major_tick_kw.copy()\n+        \n+        # Store current tick label visibility\n+        x_labelbottom = self.xaxis._major_tick_kw.get('labelbottom', True)\n+        x_labeltop = self.xaxis._major_tick_kw.get('labeltop', False)\n+        y_labelleft = self.yaxis._major_tick_kw.get('labelleft', True)\n+        y_labelright = self.yaxis._major_tick_kw.get('labelright', False)\n+\n         self.xaxis.clear()\n         self.yaxis.clear()\n \n@@ -1203,6 +1267,39 @@ class _AxesBase(martist.Artist):\n \n         if self._sharex is not None:\n             self.sharex(self._sharex)\n+            # Restore x-axis tick label visibility for shared axes\n+            self.tick_params(axis='x', labelbottom=x_labelbottom, labeltop=x_labeltop)\n+        else:\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+\n+        self.xaxis.clear()\n+        self.yaxis.clear()\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+        if self._sharex is not None:\n+            self.sharex(self._sharex)\n+            # Ensure proper tick label visibility for shared x-axis\n+            if hasattr(self._sharex, '_shared_axes'):\n+                shared_group = self._sharex._shared_axes['x']\n+                if self in shared_group:\n+                    # Find position in shared group to determine label visibility\n+                    axes_list = list(shared_group)\n+                    if len(axes_list) > 1:\n+                        # Only show labels on bottom-most axes\n+                        bottom_axes = max(axes_list, key=lambda ax: ax.get_position().y0 if ax.get_position() else 0)\n+                        if self != bottom_axes:\n+                            self.tick_params(axis='x', labelbottom=False, labeltop=False)\n         else:\n             self.xaxis._set_scale('linear')\n             try:\n@@ -1211,6 +1308,17 @@ class _AxesBase(martist.Artist):\n                 pass\n         if self._sharey is not None:\n             self.sharey(self._sharey)\n+            # Ensure proper tick label visibility for shared y-axis\n+            if hasattr(self._sharey, '_shared_axes'):\n+                shared_group = self._sharey._shared_axes['y']\n+                if self in shared_group:\n+                    # Find position in shared group to determine label visibility\n+                    axes_list = list(shared_group)\n+                    if len(axes_list) > 1:\n+                        # Only show labels on left-most axes\n+                        left_axes = min(axes_list, key=lambda ax: ax.get_position().x0 if ax.get_position() else 0)\n+                        if self != left_axes:\n+                            self.tick_params(axis='y', labelleft=False, labelright=False)\n         else:\n             self.yaxis._set_scale('linear')\n             try:\n@@ -1302,12 +1410,49 @@ class _AxesBase(martist.Artist):\n \n         self._shared_axes[\"x\"].clean()\n         self._shared_axes[\"y\"].clean()\n+\n         if self._sharex is not None:\n             self.xaxis.set_visible(xaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared x-axis\n+            shared_group = self._shared_axes[\"x\"].get_siblings(self)\n+            if len(shared_group) > 1:\n+                # Determine if this axis should show x tick labels\n+                # Only bottom-most axes in shared group should show bottom labels\n+                should_show_bottom = True\n+                should_show_top = True\n+                for other_ax in shared_group:\n+                    if other_ax is not self:\n+                        # Simple heuristic: if another axis is below this one, hide bottom labels\n+                        if hasattr(other_ax, 'get_position') and hasattr(self, 'get_position'):\n+                            other_pos = other_ax.get_position()\n+                            self_pos = self.get_position()\n+                            if other_pos.y0 < self_pos.y0:\n+                                should_show_bottom = False\n+                            if other_pos.y0 > self_pos.y0:\n+                                should_show_top = False\n+                self.tick_params(axis='x', labelbottom=should_show_bottom, labeltop=should_show_top)\n         if self._sharey is not None:\n             self.yaxis.set_visible(yaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared y-axis\n+            shared_group = self._shared_axes[\"y\"].get_siblings(self)\n+            if len(shared_group) > 1:\n+                # Determine if this axis should show y tick labels\n+                # Only left-most axes in shared group should show left labels\n+                should_show_left = True\n+                should_show_right = True\n+                for other_ax in shared_group:\n+                    if other_ax is not self:\n+                        # Simple heuristic: if another axis is to the left, hide left labels\n+                        if hasattr(other_ax, 'get_position') and hasattr(self, 'get_position'):\n+                            other_pos = other_ax.get_position()\n+                            self_pos = self.get_position()\n+                            if other_pos.x0 < self_pos.x0:\n+                                should_show_left = False\n+                            if other_pos.x0 > self_pos.x0:\n+                                should_show_right = False\n+                self.tick_params(axis='y', labelleft=should_show_left, labelright=should_show_right)\n \n         self.stale = True\n \n",
    "variant_5": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 802fd3c997..a32f1ff7c4 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1141,6 +1141,7 @@ class _AxesBase(martist.Artist):\n         return OrderedDict((side, mspines.Spine.linear_spine(self, side))\n                            for side in ['left', 'right', 'bottom', 'top'])\n \n+\n     def sharex(self, other):\n         \"\"\"\n         Share the x-axis with *other*.\n@@ -1159,6 +1160,26 @@ class _AxesBase(martist.Artist):\n         x0, x1 = other.get_xlim()\n         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n         self.xaxis._scale = other.xaxis._scale\n+        \n+        # Ensure proper tick label visibility for shared axes\n+        # Only the bottom-most axes in a shared group should show x labels\n+        shared_axes = list(self._shared_axes[\"x\"].get_siblings(self))\n+        if len(shared_axes) > 1:\n+            # Find which axes should show labels (typically the bottom ones)\n+            axes_with_positions = []\n+            for ax in shared_axes:\n+                if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n+                    spec = ax.get_subplotspec()\n+                    axes_with_positions.append((ax, spec.rowspan.stop - 1))\n+            \n+            if axes_with_positions:\n+                max_row = max(pos[1] for pos in axes_with_positions)\n+                for ax, row in axes_with_positions:\n+                    if row == max_row:\n+                        ax.tick_params(axis='x', labelbottom=True, labeltop=False)\n+                    else:\n+                        ax.tick_params(axis='x', labelbottom=False, labeltop=False)\n+\n \n     def sharey(self, other):\n         \"\"\"\n@@ -1178,6 +1199,25 @@ class _AxesBase(martist.Artist):\n         y0, y1 = other.get_ylim()\n         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n         self.yaxis._scale = other.yaxis._scale\n+        \n+        # Update tick parameters to handle shared axis visibility properly\n+        # For shared y-axis, we need to manage left/right tick label visibility\n+        shared_axes = list(self._shared_axes[\"y\"])\n+        for ax in shared_axes:\n+            # Determine position in shared group to set appropriate visibility\n+            ax_bbox = ax.get_position()\n+            leftmost = True\n+            rightmost = True\n+            for other_ax in shared_axes:\n+                if other_ax is not ax:\n+                    other_bbox = other_ax.get_position()\n+                    if other_bbox.x0 < ax_bbox.x0:\n+                        leftmost = False\n+                    if other_bbox.x1 > ax_bbox.x1:\n+                        rightmost = False\n+            \n+            # Set tick label visibility based on position\n+            ax.tick_params(axis='y', labelleft=leftmost, labelright=False)\n \n     def cla(self):\n         \"\"\"Clear the axes.\"\"\"\n@@ -1192,6 +1232,58 @@ class _AxesBase(martist.Artist):\n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n \n+\n+        # stash the current visibility state\n+        if hasattr(self, 'patch'):\n+            patch_visible = self.patch.get_visible()\n+        else:\n+            patch_visible = True\n+\n+        xaxis_visible = self.xaxis.get_visible()\n+        yaxis_visible = self.yaxis.get_visible()\n+        \n+        # Preserve tick label visibility states for shared axes\n+        x_tick_params = {}\n+        y_tick_params = {}\n+        if hasattr(self.xaxis, '_major_tick_kw'):\n+            x_tick_params = self.xaxis._major_tick_kw.copy()\n+        if hasattr(self.yaxis, '_major_tick_kw'):\n+            y_tick_params = self.yaxis._major_tick_kw.copy()\n+            \n+        # Store current tick label visibility\n+        x_labelbottom = any(tick.label1.get_visible() for tick in self.xaxis.get_major_ticks())\n+        x_labeltop = any(tick.label2.get_visible() for tick in self.xaxis.get_major_ticks())\n+        y_labelleft = any(tick.label1.get_visible() for tick in self.yaxis.get_major_ticks())\n+        y_labelright = any(tick.label2.get_visible() for tick in self.yaxis.get_major_ticks())\n+\n+        self.xaxis.clear()\n+        self.yaxis.clear()\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+\n+    def cla(self):\n+        \"\"\"Clear the axes.\"\"\"\n+        # Stash the current visibility and sharing state\n+        xaxis_visible = self.xaxis.get_visible()\n+        yaxis_visible = self.yaxis.get_visible()\n+        \n+        # Store tick label visibility states for shared axes\n+        tick_label_state = {}\n+        if self._sharex is not None or self._sharey is not None:\n+            tick_label_state = {\n+                'labelbottom': self.xaxis._major_tick_kw.get('labelbottom', True),\n+                'labeltop': self.xaxis._major_tick_kw.get('labeltop', False),\n+                'labelleft': self.yaxis._major_tick_kw.get('labelleft', True),\n+                'labelright': self.yaxis._major_tick_kw.get('labelright', False),\n+            }\n+\n+        # We are clearing the axes of data, but preserving the axes\n+        # instances, and some of their state.\n         self.xaxis.clear()\n         self.yaxis.clear()\n \n@@ -1218,6 +1310,34 @@ class _AxesBase(martist.Artist):\n             except TypeError:\n                 pass\n \n+        # update the minor locator for x and y axis based on rcParams\n+        if mpl.rcParams['xtick.minor.visible']:\n+            self.xaxis.set_minor_locator(mticker.AutoMinorLocator())\n+        if mpl.rcParams['ytick.minor.visible']:\n+            self.yaxis.set_minor_locator(mticker.AutoMinorLocator())\n+\n+        if self._sharex is None:\n+            self._autoscaleXon = True\n+        if self._sharey is None:\n+            self._autoscaleYon = True\n+\n+        self._update_transScale()\n+\n+        # Restore visibility\n+        self.xaxis.set_visible(xaxis_visible)\n+        self.yaxis.set_visible(yaxis_visible)\n+        \n+        # Restore tick label visibility for shared axes\n+        if tick_label_state:\n+            self.tick_params(\n+                labelbottom=tick_label_state['labelbottom'],\n+                labeltop=tick_label_state['labeltop'],\n+                labelleft=tick_label_state['labelleft'],\n+                labelright=tick_label_state['labelright']\n+            )\n+\n+        self.stale = True\n+\n         # update the minor locator for x and y axis based on rcParams\n         if mpl.rcParams['xtick.minor.visible']:\n             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())\n@@ -1302,12 +1422,19 @@ class _AxesBase(martist.Artist):\n \n         self._shared_axes[\"x\"].clean()\n         self._shared_axes[\"y\"].clean()\n+\n         if self._sharex is not None:\n             self.xaxis.set_visible(xaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore tick label visibility for shared x-axis\n+            self._sharex._adjust_autoscale_locked()\n+            self._sharex._shared_axes[\"x\"]._update_ticks()\n         if self._sharey is not None:\n             self.yaxis.set_visible(yaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore tick label visibility for shared y-axis\n+            self._sharey._adjust_autoscale_locked()\n+            self._sharey._shared_axes[\"y\"]._update_ticks()\n \n         self.stale = True\n \n",
    "variant_6": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 802fd3c997..5b632e86be 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1141,6 +1141,7 @@ class _AxesBase(martist.Artist):\n         return OrderedDict((side, mspines.Spine.linear_spine(self, side))\n                            for side in ['left', 'right', 'bottom', 'top'])\n \n+\n     def sharex(self, other):\n         \"\"\"\n         Share the x-axis with *other*.\n@@ -1159,25 +1160,85 @@ class _AxesBase(martist.Artist):\n         x0, x1 = other.get_xlim()\n         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n         self.xaxis._scale = other.xaxis._scale\n+        \n+        # Configure tick label visibility for shared x-axis\n+        shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n+        if len(shared_axes) > 1:\n+            # For shared x-axes, only bottom-most axes should show bottom labels\n+            # and only top-most axes should show top labels\n+            positions = [ax.get_position() for ax in shared_axes]\n+            bottom_y = min(pos.y0 for pos in positions)\n+            top_y = max(pos.y1 for pos in positions)\n+            \n+            for ax in shared_axes:\n+                pos = ax.get_position()\n+                show_bottom = abs(pos.y0 - bottom_y) < 1e-6\n+                show_top = abs(pos.y1 - top_y) < 1e-6\n+                ax.tick_params(axis='x', which='both', \n+                              labelbottom=show_bottom, labeltop=show_top)\n+\n+\n+def sharey(self, other):\n+    \"\"\"\n+    Share the y-axis with *other*.\n \n-    def sharey(self, other):\n-        \"\"\"\n-        Share the y-axis with *other*.\n-\n-        This is equivalent to passing ``sharey=other`` when constructing the\n-        axes, and cannot be used if the y-axis is already being shared with\n-        another axes.\n-        \"\"\"\n-        _api.check_isinstance(_AxesBase, other=other)\n-        if self._sharey is not None and other is not self._sharey:\n-            raise ValueError(\"y-axis is already shared\")\n-        self._shared_axes[\"y\"].join(self, other)\n-        self._sharey = other\n-        self.yaxis.major = other.yaxis.major  # Ticker instances holding\n-        self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n-        y0, y1 = other.get_ylim()\n-        self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n-        self.yaxis._scale = other.yaxis._scale\n+    This is equivalent to passing ``sharey=other`` when constructing the\n+    axes, and cannot be used if the y-axis is already being shared with\n+    another axes.\n+    \"\"\"\n+    _api.check_isinstance(_AxesBase, other=other)\n+    if self._sharey is not None and other is not self._sharey:\n+        raise ValueError(\"y-axis is already shared\")\n+    self._shared_axes[\"y\"].join(self, other)\n+    self._sharey = other\n+    self.yaxis.major = other.yaxis.major  # Ticker instances holding\n+    self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n+    y0, y1 = other.get_ylim()\n+    self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n+    self.yaxis._scale = other.yaxis._scale\n+    \n+    # Ensure proper tick label visibility for shared y-axis\n+    # Get all axes sharing the y-axis\n+    shared_axes = self._shared_axes[\"y\"].get_siblings(self)\n+    if len(shared_axes) > 1:\n+        # For shared y-axes, typically only leftmost axes should show left labels\n+        # and only rightmost axes should show right labels\n+        for ax in shared_axes:\n+            # Default to hiding both left and right labels\n+            ax.tick_params(axis='y', labelleft=False, labelright=False)\n+        \n+        # Find leftmost and rightmost axes based on their position\n+        leftmost_axes = []\n+        rightmost_axes = []\n+        \n+        for ax in shared_axes:\n+            is_leftmost = True\n+            is_rightmost = True\n+            \n+            for other_ax in shared_axes:\n+                if other_ax != ax:\n+                    # Check if there's an axes to the left\n+                    if (hasattr(ax, 'get_position') and hasattr(other_ax, 'get_position') and\n+                        other_ax.get_position().x0 < ax.get_position().x0):\n+                        is_leftmost = False\n+                    # Check if there's an axes to the right  \n+                    if (hasattr(ax, 'get_position') and hasattr(other_ax, 'get_position') and\n+                        other_ax.get_position().x1 > ax.get_position().x1):\n+                        is_rightmost = False\n+            \n+            if is_leftmost:\n+                leftmost_axes.append(ax)\n+            if is_rightmost:\n+                rightmost_axes.append(ax)\n+        \n+        # Enable left labels for leftmost axes\n+        for ax in leftmost_axes:\n+            ax.tick_params(axis='y', labelleft=True)\n+            \n+        # Enable right labels for rightmost axes if they have right spine visible\n+        for ax in rightmost_axes:\n+            if ax.spines['right'].get_visible():\n+                ax.tick_params(axis='y', labelright=True)\n \n     def cla(self):\n         \"\"\"Clear the axes.\"\"\"\n@@ -1192,6 +1253,70 @@ class _AxesBase(martist.Artist):\n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n \n+\n+        # stash the current visibility state\n+        if hasattr(self, 'patch'):\n+            patch_visible = self.patch.get_visible()\n+        else:\n+            patch_visible = True\n+\n+        xaxis_visible = self.xaxis.get_visible()\n+        yaxis_visible = self.yaxis.get_visible()\n+\n+        # Preserve tick label visibility for shared axes\n+        x_tick_params = {}\n+        y_tick_params = {}\n+        if hasattr(self.xaxis, '_major_tick_kw'):\n+            x_tick_params = self.xaxis._major_tick_kw.copy()\n+        if hasattr(self.yaxis, '_major_tick_kw'):\n+            y_tick_params = self.yaxis._major_tick_kw.copy()\n+            \n+        # Store current tick label visibility states\n+        labelbottom = any(tick.label1.get_visible() for tick in self.xaxis.get_major_ticks())\n+        labeltop = any(tick.label2.get_visible() for tick in self.xaxis.get_major_ticks())\n+        labelleft = any(tick.label1.get_visible() for tick in self.yaxis.get_major_ticks())\n+        labelright = any(tick.label2.get_visible() for tick in self.yaxis.get_major_ticks())\n+\n+        self.xaxis.clear()\n+        self.yaxis.clear()\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+        if self._sharex is not None:\n+            self.sharex(self._sharex)\n+            # Restore tick label visibility for shared x-axis\n+            self.tick_params(axis='x', labelbottom=labelbottom, labeltop=labeltop)\n+        else:\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+\n+    def cla(self):\n+        \"\"\"Clear the Axes.\"\"\"\n+        # Stash the current view lim as an optimization for the resize\n+        # observer.\n+        self._stale_viewlim_x = False\n+        self._stale_viewlim_y = False\n+\n+        # Store tick label visibility for shared axes before clearing\n+        xaxis_labelbottom = self.xaxis._major_tick_kw.get('labelbottom', True)\n+        xaxis_labeltop = self.xaxis._major_tick_kw.get('labeltop', False)\n+        yaxis_labelleft = self.yaxis._major_tick_kw.get('labelleft', True)\n+        yaxis_labelright = self.yaxis._major_tick_kw.get('labelright', False)\n+\n+        # Clear all the children except for the background patch.\n+        for child in self.get_children():\n+            if child is not self.patch:\n+                child.remove()\n+\n         self.xaxis.clear()\n         self.yaxis.clear()\n \n@@ -1203,6 +1328,8 @@ class _AxesBase(martist.Artist):\n \n         if self._sharex is not None:\n             self.sharex(self._sharex)\n+            # Restore tick label visibility for shared x-axis\n+            self.tick_params(axis='x', labelbottom=xaxis_labelbottom, labeltop=xaxis_labeltop)\n         else:\n             self.xaxis._set_scale('linear')\n             try:\n@@ -1211,6 +1338,8 @@ class _AxesBase(martist.Artist):\n                 pass\n         if self._sharey is not None:\n             self.sharey(self._sharey)\n+            # Restore tick label visibility for shared y-axis\n+            self.tick_params(axis='y', labelleft=yaxis_labelleft, labelright=yaxis_labelright)\n         else:\n             self.yaxis._set_scale('linear')\n             try:\n@@ -1302,12 +1431,27 @@ class _AxesBase(martist.Artist):\n \n         self._shared_axes[\"x\"].clean()\n         self._shared_axes[\"y\"].clean()\n+\n         if self._sharex is not None:\n             self.xaxis.set_visible(xaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared x-axes\n+            shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # Determine if this is a bottom axis that should show labels\n+                is_bottom = all(ax.get_position().y0 >= self.get_position().y0 \n+                              for ax in shared_axes if ax is not self)\n+                self.tick_params(axis='x', labelbottom=is_bottom, labeltop=False)\n         if self._sharey is not None:\n             self.yaxis.set_visible(yaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared y-axes\n+            shared_axes = self._shared_axes[\"y\"].get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # Determine if this is a left axis that should show labels\n+                is_left = all(ax.get_position().x0 >= self.get_position().x0 \n+                            for ax in shared_axes if ax is not self)\n+                self.tick_params(axis='y', labelleft=is_left, labelright=False)\n \n         self.stale = True\n \n",
    "variant_7": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 802fd3c997..beebfdd93a 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1141,6 +1141,7 @@ class _AxesBase(martist.Artist):\n         return OrderedDict((side, mspines.Spine.linear_spine(self, side))\n                            for side in ['left', 'right', 'bottom', 'top'])\n \n+\n     def sharex(self, other):\n         \"\"\"\n         Share the x-axis with *other*.\n@@ -1159,6 +1160,42 @@ class _AxesBase(martist.Artist):\n         x0, x1 = other.get_xlim()\n         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n         self.xaxis._scale = other.xaxis._scale\n+        # Ensure proper tick label visibility for shared axes\n+        # Get all axes sharing the same x-axis\n+        shared_x_axes = self._shared_axes[\"x\"].get_siblings(self)\n+        if len(shared_x_axes) > 1:\n+            # Find the bottom-most axes in the shared group\n+            bottom_axes = []\n+            for ax in shared_x_axes:\n+                if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n+                    # For subplot axes, check if this is the bottom row\n+                    subplotspec = ax.get_subplotspec()\n+                    if hasattr(subplotspec, 'rowspan'):\n+                        row_end = subplotspec.rowspan.stop - 1\n+                        # Check if this is the last row by comparing with other axes\n+                        is_bottom = True\n+                        for other_ax in shared_x_axes:\n+                            if (hasattr(other_ax, 'get_subplotspec') and \n+                                other_ax.get_subplotspec() is not None):\n+                                other_spec = other_ax.get_subplotspec()\n+                                if hasattr(other_spec, 'rowspan'):\n+                                    other_row_end = other_spec.rowspan.stop - 1\n+                                    if other_row_end > row_end:\n+                                        is_bottom = False\n+                                        break\n+                        if is_bottom:\n+                            bottom_axes.append(ax)\n+                else:\n+                    # For non-subplot axes, assume they should show labels\n+                    bottom_axes.append(ax)\n+            \n+            # Set tick label visibility\n+            for ax in shared_x_axes:\n+                if ax in bottom_axes:\n+                    ax.tick_params(axis='x', labelbottom=True, labeltop=False)\n+                else:\n+                    ax.tick_params(axis='x', labelbottom=False, labeltop=False)\n+\n \n     def sharey(self, other):\n         \"\"\"\n@@ -1178,6 +1215,21 @@ class _AxesBase(martist.Artist):\n         y0, y1 = other.get_ylim()\n         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n         self.yaxis._scale = other.yaxis._scale\n+        \n+        # Ensure proper tick label visibility for shared axes\n+        # Check if this axes should show y-axis labels based on its position\n+        # in the shared group - typically only the leftmost column should show labels\n+        shared_axes = list(self._shared_axes[\"y\"])\n+        if len(shared_axes) > 1:\n+            # Find the leftmost axes in the shared group\n+            leftmost_axes = min(shared_axes, \n+                              key=lambda ax: ax.get_position().x0 if hasattr(ax.get_position(), 'x0') else 0)\n+            \n+            # Only the leftmost axes should show left labels\n+            if self is leftmost_axes:\n+                self.tick_params(labelleft=True, labelright=False)\n+            else:\n+                self.tick_params(labelleft=False, labelright=False)\n \n     def cla(self):\n         \"\"\"Clear the axes.\"\"\"\n@@ -1192,6 +1244,28 @@ class _AxesBase(martist.Artist):\n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n \n+\n+        # stash the current visibility state\n+        if hasattr(self, 'patch'):\n+            patch_visible = self.patch.get_visible()\n+        else:\n+            patch_visible = True\n+\n+        xaxis_visible = self.xaxis.get_visible()\n+        yaxis_visible = self.yaxis.get_visible()\n+\n+        # Preserve tick label visibility states for shared axes\n+        xaxis_tick_params = {}\n+        yaxis_tick_params = {}\n+        if hasattr(self.xaxis, '_major_tick_kw'):\n+            for key in ['labeltop', 'labelbottom']:\n+                if key in self.xaxis._major_tick_kw:\n+                    xaxis_tick_params[key] = self.xaxis._major_tick_kw[key]\n+        if hasattr(self.yaxis, '_major_tick_kw'):\n+            for key in ['labelleft', 'labelright']:\n+                if key in self.yaxis._major_tick_kw:\n+                    yaxis_tick_params[key] = self.yaxis._major_tick_kw[key]\n+\n         self.xaxis.clear()\n         self.yaxis.clear()\n \n@@ -1203,6 +1277,35 @@ class _AxesBase(martist.Artist):\n \n         if self._sharex is not None:\n             self.sharex(self._sharex)\n+            # Restore x-axis tick label visibility for shared axes\n+            if xaxis_tick_params:\n+                self.tick_params(axis='x', **xaxis_tick_params)\n+        else:\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+\n+        self.xaxis.clear()\n+        self.yaxis.clear()\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+        if self._sharex is not None:\n+            self.sharex(self._sharex)\n+            # Ensure proper tick label visibility for shared x-axis\n+            if hasattr(self, '_shared_x_axes') and self._sharex in self._shared_x_axes:\n+                shared_axes = self._shared_x_axes[self._sharex]\n+                for ax in shared_axes:\n+                    if ax != self._sharex:  # Don't modify the master axis\n+                        ax.tick_params(labelbottom=False, labeltop=False)\n         else:\n             self.xaxis._set_scale('linear')\n             try:\n@@ -1211,6 +1314,12 @@ class _AxesBase(martist.Artist):\n                 pass\n         if self._sharey is not None:\n             self.sharey(self._sharey)\n+            # Ensure proper tick label visibility for shared y-axis\n+            if hasattr(self, '_shared_y_axes') and self._sharey in self._shared_y_axes:\n+                shared_axes = self._shared_y_axes[self._sharey]\n+                for ax in shared_axes:\n+                    if ax != self._sharey:  # Don't modify the master axis\n+                        ax.tick_params(labelleft=False, labelright=False)\n         else:\n             self.yaxis._set_scale('linear')\n             try:\n@@ -1302,12 +1411,27 @@ class _AxesBase(martist.Artist):\n \n         self._shared_axes[\"x\"].clean()\n         self._shared_axes[\"y\"].clean()\n+\n         if self._sharex is not None:\n             self.xaxis.set_visible(xaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared x-axis\n+            shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # For shared x-axis, typically only bottom axes show labels\n+                is_bottom = all(other.get_position().y0 >= self.get_position().y0 \n+                              for other in shared_axes if other != self)\n+                self.tick_params(labelbottom=is_bottom, labeltop=False)\n         if self._sharey is not None:\n             self.yaxis.set_visible(yaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared y-axis\n+            shared_axes = self._shared_axes[\"y\"].get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # For shared y-axis, typically only left axes show labels\n+                is_left = all(other.get_position().x0 >= self.get_position().x0 \n+                            for other in shared_axes if other != self)\n+                self.tick_params(labelleft=is_left, labelright=False)\n \n         self.stale = True\n \n",
    "variant_8": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 802fd3c997..d21f69867e 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1141,6 +1141,7 @@ class _AxesBase(martist.Artist):\n         return OrderedDict((side, mspines.Spine.linear_spine(self, side))\n                            for side in ['left', 'right', 'bottom', 'top'])\n \n+\n     def sharex(self, other):\n         \"\"\"\n         Share the x-axis with *other*.\n@@ -1159,6 +1160,25 @@ class _AxesBase(martist.Artist):\n         x0, x1 = other.get_xlim()\n         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n         self.xaxis._scale = other.xaxis._scale\n+        \n+        # Configure tick label visibility for shared x-axis\n+        # Get all axes sharing the same x-axis\n+        shared_x_axes = list(self._shared_axes[\"x\"].get_siblings(self))\n+        if len(shared_x_axes) > 1:\n+            # Find the bottom-most axes in the shared group\n+            bottom_axes = []\n+            max_row = max(ax.get_position().y0 for ax in shared_x_axes if hasattr(ax, 'get_position'))\n+            for ax in shared_x_axes:\n+                if hasattr(ax, 'get_position') and ax.get_position().y0 == max_row:\n+                    bottom_axes.append(ax)\n+            \n+            # Only bottom axes should show x-axis labels\n+            for ax in shared_x_axes:\n+                if ax in bottom_axes:\n+                    ax.tick_params(axis='x', labelbottom=True, labeltop=False)\n+                else:\n+                    ax.tick_params(axis='x', labelbottom=False, labeltop=False)\n+\n \n     def sharey(self, other):\n         \"\"\"\n@@ -1178,6 +1198,33 @@ class _AxesBase(martist.Artist):\n         y0, y1 = other.get_ylim()\n         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n         self.yaxis._scale = other.yaxis._scale\n+        \n+        # Configure tick label visibility for shared y-axis\n+        # Find all axes that share this y-axis\n+        shared_y_axes = list(self._shared_axes[\"y\"].get_siblings(self))\n+        \n+        # Determine which axes should show y-axis labels (leftmost column)\n+        if len(shared_y_axes) > 1:\n+            # Get positions of all shared axes\n+            positions = []\n+            for ax in shared_y_axes:\n+                if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() is not None:\n+                    spec = ax.get_subplotspec()\n+                    positions.append((ax, spec.colspan.start))\n+                else:\n+                    # Fallback: use axes position\n+                    bbox = ax.get_position()\n+                    positions.append((ax, bbox.x0))\n+            \n+            if positions:\n+                # Sort by x position to find leftmost\n+                positions.sort(key=lambda x: x[1])\n+                leftmost_x = positions[0][1]\n+                \n+                for ax, x_pos in positions:\n+                    # Only leftmost axes should show left labels\n+                    show_left = abs(x_pos - leftmost_x) < 1e-10\n+                    ax.tick_params(axis='y', labelleft=show_left, labelright=False)\n \n     def cla(self):\n         \"\"\"Clear the axes.\"\"\"\n@@ -1192,6 +1239,28 @@ class _AxesBase(martist.Artist):\n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n \n+\n+        # stash the current visibility state\n+        if hasattr(self, 'patch'):\n+            patch_visible = self.patch.get_visible()\n+        else:\n+            patch_visible = True\n+\n+        xaxis_visible = self.xaxis.get_visible()\n+        yaxis_visible = self.yaxis.get_visible()\n+\n+        # Store tick label visibility states before clearing for shared axes\n+        xaxis_tick_params = {}\n+        yaxis_tick_params = {}\n+        if hasattr(self.xaxis, '_major_tick_kw'):\n+            for key in ['labelbottom', 'labeltop']:\n+                if key in self.xaxis._major_tick_kw:\n+                    xaxis_tick_params[key] = self.xaxis._major_tick_kw[key]\n+        if hasattr(self.yaxis, '_major_tick_kw'):\n+            for key in ['labelleft', 'labelright']:\n+                if key in self.yaxis._major_tick_kw:\n+                    yaxis_tick_params[key] = self.yaxis._major_tick_kw[key]\n+\n         self.xaxis.clear()\n         self.yaxis.clear()\n \n@@ -1204,19 +1273,83 @@ class _AxesBase(martist.Artist):\n         if self._sharex is not None:\n             self.sharex(self._sharex)\n         else:\n-            self.xaxis._set_scale('linear')\n-            try:\n-                self.set_xlim(0, 1)\n-            except TypeError:\n-                pass\n+            # Restore x-axis tick label visibility if no sharing\n+            if xaxis_tick_params:\n+                self.tick_params(axis='x', **xaxis_tick_params)\n+\n         if self._sharey is not None:\n             self.sharey(self._sharey)\n         else:\n-            self.yaxis._set_scale('linear')\n-            try:\n-                self.set_ylim(0, 1)\n-            except TypeError:\n-                pass\n+            # Restore y-axis tick label visibility if no sharing\n+            if yaxis_tick_params:\n+                self.tick_params(axis='y', **yaxis_tick_params)\n+\n+        for name, spine in self.spines.items():\n+            spine.clear()\n+\n+        self.ignore_existing_data_limits = True\n+        self.callbacks = cbook.CallbackRegistry()\n+\n+\n+def cla(self):\n+    \"\"\"Clear the axes.\"\"\"\n+    # Stash the current visibility state so that layout engines have the\n+    # information they need to make decisions.\n+    self.stale = True\n+\n+    # Store sharing and tick visibility state before clearing\n+    sharex_state = self._sharex\n+    sharey_state = self._sharey\n+    \n+    # Store tick label visibility states for shared axes\n+    tick_label_state = {}\n+    if sharex_state is not None:\n+        tick_label_state['labelbottom'] = self.xaxis._major_tick_kw.get('label1On', True)\n+        tick_label_state['labeltop'] = self.xaxis._major_tick_kw.get('label2On', False)\n+    if sharey_state is not None:\n+        tick_label_state['labelleft'] = self.yaxis._major_tick_kw.get('label1On', True)\n+        tick_label_state['labelright'] = self.yaxis._major_tick_kw.get('label2On', False)\n+\n+    self._axes_locator = None\n+    self.relim()\n+    self.set_axis_off()  # clear the axis\n+    self._set_lim_and_transforms()\n+\n+    self.xaxis.clear()\n+    self.yaxis.clear()\n+\n+    for name, spine in self.spines.items():\n+        spine.clear()\n+\n+    self.ignore_existing_data_limits = True\n+    self.callbacks = cbook.CallbackRegistry()\n+\n+    if self._sharex is not None:\n+        self.sharex(self._sharex)\n+        # Restore tick label visibility for shared x-axis\n+        if 'labelbottom' in tick_label_state:\n+            self.tick_params(axis='x', labelbottom=tick_label_state['labelbottom'])\n+        if 'labeltop' in tick_label_state:\n+            self.tick_params(axis='x', labeltop=tick_label_state['labeltop'])\n+    else:\n+        self.xaxis._set_scale('linear')\n+        try:\n+            self.set_xlim(0, 1)\n+        except TypeError:\n+            pass\n+    if self._sharey is not None:\n+        self.sharey(self._sharey)\n+        # Restore tick label visibility for shared y-axis\n+        if 'labelleft' in tick_label_state:\n+            self.tick_params(axis='y', labelleft=tick_label_state['labelleft'])\n+        if 'labelright' in tick_label_state:\n+            self.tick_params(axis='y', labelright=tick_label_state['labelright'])\n+    else:\n+        self.yaxis._set_scale('linear')\n+        try:\n+            self.set_ylim(0, 1)\n+        except TypeError:\n+            pass\n \n         # update the minor locator for x and y axis based on rcParams\n         if mpl.rcParams['xtick.minor.visible']:\n@@ -1302,12 +1435,41 @@ class _AxesBase(martist.Artist):\n \n         self._shared_axes[\"x\"].clean()\n         self._shared_axes[\"y\"].clean()\n+\n         if self._sharex is not None:\n             self.xaxis.set_visible(xaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared x-axis\n+            shared_axes = self._shared_axes[\"x\"].get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # For shared x-axis, only bottom-most axes should show bottom labels\n+                # and only top-most axes should show top labels\n+                positions = [ax.get_position() for ax in shared_axes]\n+                bottom_y = min(pos.y0 for pos in positions)\n+                top_y = max(pos.y0 + pos.height for pos in positions)\n+                \n+                current_pos = self.get_position()\n+                is_bottom = abs(current_pos.y0 - bottom_y) < 1e-10\n+                is_top = abs(current_pos.y0 + current_pos.height - top_y) < 1e-10\n+                \n+                self.tick_params(axis='x', labelbottom=is_bottom, labeltop=is_top)\n         if self._sharey is not None:\n             self.yaxis.set_visible(yaxis_visible)\n             self.patch.set_visible(patch_visible)\n+            # Restore proper tick label visibility for shared y-axis\n+            shared_axes = self._shared_axes[\"y\"].get_siblings(self)\n+            if len(shared_axes) > 1:\n+                # For shared y-axis, only left-most axes should show left labels\n+                # and only right-most axes should show right labels\n+                positions = [ax.get_position() for ax in shared_axes]\n+                left_x = min(pos.x0 for pos in positions)\n+                right_x = max(pos.x0 + pos.width for pos in positions)\n+                \n+                current_pos = self.get_position()\n+                is_left = abs(current_pos.x0 - left_x) < 1e-10\n+                is_right = abs(current_pos.x0 + current_pos.width - right_x) < 1e-10\n+                \n+                self.tick_params(axis='y', labelleft=is_left, labelright=is_right)\n \n         self.stale = True\n \n"
  }
}