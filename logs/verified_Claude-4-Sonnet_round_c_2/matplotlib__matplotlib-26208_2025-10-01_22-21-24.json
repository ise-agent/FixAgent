{
  "zero_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1955-1957)": "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1940-1943)": "\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/stackplot.py lines 118-118)": "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 4411-4413)": "\n        if adjust_y:\n            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n            x0, x1 = x_trf.transform(self.get_xbound())\n            y0, y1 = y_trf.transform(self.get_ybound())\n",
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1995-2000)": "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1955-1957)": [
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n"
    ],
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1940-1943)": [
      "\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n"
    ],
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/stackplot.py lines 118-118)": [
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n"
    ],
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 4411-4413)": [
      "\n        if aspect == 'equal':\n            A = abs(aspect_scale_mode(ax.bbox.height, ax.bbox.width,\n                                      *ax.viewLim.size))\n        else:\n            A = aspect\n\n        # Ensure at this point A is a positive number.\n        if A is None or A <= 0:\n            return\n\n        figW, figH = self.get_figure().get_size_inches()\n        fig_aspect = figH / figW\n        if self._adjustable == 'box':\n            if self in self._twinned_axes:\n                raise RuntimeError(\"Adjustable 'box' is not allowed for \"\n                                   \"twinned Axes\")\n            box_aspect = A * self.get_data_ratio()\n            pb = self.get_position(original=True).frozen()\n            pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n            self.set_position(pb1)\n            return\n\n        # The following is only seen if self._adjustable == 'datalim'\n        # (which is the default).\n\n        xmin, xmax, ymin, ymax = self.viewLim.bounds\n        if self._sharex is not None and xmin == xmax:\n            xmin, xmax = self._sharex.viewLim.intervalx\n        if self._sharey is not None and ymin == ymax:\n            ymin, ymax = self._sharey.viewLim.intervaly\n\n        # Use axis transforms to get the transformed view limits\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        xmin, xmax = x_trf.transform(self.get_xbound())\n        ymin, ymax = y_trf.transform(self.get_ybound())\n        xsize = max(abs(xmax - xmin), 1e-30)\n        ysize = max(abs(ymax - ymin), 1e-30)\n\n        # Scale the axes such that in screen space, one unit in data\n        # coordinates along the x-axis is equal in length to A units\n        # along the y-axis.  Here, we need *screen space*, or the\n        # relative units of the axes in their position in the figure.\n        box = self.get_position(original=True)\n\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        if adjust_y:\n            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n            x0, x1 = x_trf.transform(self.get_xbound())\n            y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        if adjust_y:\n            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n            x0, x1 = x_trf.transform(self.get_xbound())\n            y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        if adjust_y:\n            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n            x0, x1 = x_trf.transform(self.get_xbound())\n            y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        dL = self.dataLim\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        if adjust_x:\n            # Determine the width of the display area in inches\n            box = self.get_window_extent().transformed(\n                self.figure.dpi_scale_trans.inverted())\n            Xsize = box.width / box.height * Ysize\n        else:\n            # Determine the height of the display area in inches\n            box = self.get_window_extent().transformed(\n                self.figure.dpi_scale_trans.inverted())\n            Ysize = box.height / box.width * Xsize\n\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n        xsize = max(abs(x1 - x0), 1e-30)\n        ysize = max(abs(y1 - y0), 1e-30)\n",
      "\n        if adjust_y:\n            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n            x0, x1 = x_trf.transform(self.get_xbound())\n            y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        if adjust_x:\n            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n            x0, x1 = x_trf.transform(self.get_xbound())\n            y0, y1 = y_trf.transform(self.get_ybound())\n"
    ],
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_base.py lines 1995-2000)": [
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Get the data limits in display space\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        dL = self.dataLim\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n",
      "\n        dL = self.dataLim\n        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n        x0, x1 = x_trf.transform(self.get_xbound())\n        y0, y1 = y_trf.transform(self.get_ybound())\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..c06f84bbde 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1937,6 +1937,7 @@ class _AxesBase(martist.Artist):\n         else:\n             position = pb1.anchored(self.get_anchor(), pb)\n \n+\n         x_trf = self.xaxis.get_transform()\n         y_trf = self.yaxis.get_transform()\n         xmin, xmax = x_trf.transform(self.get_xbound())\n@@ -1952,9 +1953,10 @@ class _AxesBase(martist.Artist):\n         if abs(y_expander) < 0.005:\n             return\n \n-        dL = self.dataLim\n-        x0, x1 = x_trf.transform(dL.intervalx)\n-        y0, y1 = y_trf.transform(dL.intervaly)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xr = 1.05 * (x1 - x0)\n         yr = 1.05 * (y1 - y0)\n \n@@ -1992,6 +1994,7 @@ class _AxesBase(martist.Artist):\n             yc = 0.5 * (ymin + ymax)\n             y0 = yc - Ysize / 2.0\n             y1 = yc + Ysize / 2.0\n+\n             self.set_ybound(y_trf.inverted().transform([y0, y1]))\n         else:\n             xc = 0.5 * (xmin + xmax)\n@@ -4408,6 +4411,7 @@ class _AxesBase(martist.Artist):\n                 self.get_position(True), *args, **kwargs,\n                 axes_locator=_TransformedBoundsLocator(\n                     [0, 0, 1, 1], self.transAxes))\n+\n         self.set_adjustable('datalim')\n         twin.set_adjustable('datalim')\n         self._twinned_axes.join(self, twin)\ndiff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c97a21e029..2f953019f1 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -115,6 +115,7 @@ def stackplot(axes, x, *args,\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n+\n     coll.sticky_edges.y[:] = [0]\n     r = [coll]\n \n",
    "variant_0": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..e5db3f3273 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1937,10 +1937,12 @@ class _AxesBase(martist.Artist):\n         else:\n             position = pb1.anchored(self.get_anchor(), pb)\n \n+\n         x_trf = self.xaxis.get_transform()\n         y_trf = self.yaxis.get_transform()\n-        xmin, xmax = x_trf.transform(self.get_xbound())\n-        ymin, ymax = y_trf.transform(self.get_ybound())\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xsize = max(abs(xmax - xmin), 1e-30)\n         ysize = max(abs(ymax - ymin), 1e-30)\n \n@@ -1952,9 +1954,10 @@ class _AxesBase(martist.Artist):\n         if abs(y_expander) < 0.005:\n             return\n \n-        dL = self.dataLim\n-        x0, x1 = x_trf.transform(dL.intervalx)\n-        y0, y1 = y_trf.transform(dL.intervaly)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xr = 1.05 * (x1 - x0)\n         yr = 1.05 * (y1 - y0)\n \n@@ -1992,12 +1995,10 @@ class _AxesBase(martist.Artist):\n             yc = 0.5 * (ymin + ymax)\n             y0 = yc - Ysize / 2.0\n             y1 = yc + Ysize / 2.0\n-            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n-        else:\n-            xc = 0.5 * (xmin + xmax)\n-            x0 = xc - Xsize / 2.0\n-            x1 = xc + Xsize / 2.0\n-            self.set_xbound(x_trf.inverted().transform([x0, x1]))\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n \n     def axis(self, arg=None, /, *, emit=True, **kwargs):\n         \"\"\"\n@@ -4408,9 +4409,11 @@ class _AxesBase(martist.Artist):\n                 self.get_position(True), *args, **kwargs,\n                 axes_locator=_TransformedBoundsLocator(\n                     [0, 0, 1, 1], self.transAxes))\n-        self.set_adjustable('datalim')\n-        twin.set_adjustable('datalim')\n-        self._twinned_axes.join(self, twin)\n+\n+        if adjust_y:\n+            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+            x0, x1 = x_trf.transform(self.get_xbound())\n+            y0, y1 = y_trf.transform(self.get_ybound())\n         return twin\n \n     def twinx(self):\ndiff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c97a21e029..1e6ce8b6fb 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -115,7 +115,10 @@ def stackplot(axes, x, *args,\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n-    coll.sticky_edges.y[:] = [0]\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n     r = [coll]\n \n     # Color between array i-1 and array i\n",
    "variant_1": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..7e2ad64a3a 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1937,10 +1937,12 @@ class _AxesBase(martist.Artist):\n         else:\n             position = pb1.anchored(self.get_anchor(), pb)\n \n+\n         x_trf = self.xaxis.get_transform()\n         y_trf = self.yaxis.get_transform()\n-        xmin, xmax = x_trf.transform(self.get_xbound())\n-        ymin, ymax = y_trf.transform(self.get_ybound())\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xsize = max(abs(xmax - xmin), 1e-30)\n         ysize = max(abs(ymax - ymin), 1e-30)\n \n@@ -1952,9 +1954,10 @@ class _AxesBase(martist.Artist):\n         if abs(y_expander) < 0.005:\n             return\n \n-        dL = self.dataLim\n-        x0, x1 = x_trf.transform(dL.intervalx)\n-        y0, y1 = y_trf.transform(dL.intervaly)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xr = 1.05 * (x1 - x0)\n         yr = 1.05 * (y1 - y0)\n \n@@ -1992,12 +1995,10 @@ class _AxesBase(martist.Artist):\n             yc = 0.5 * (ymin + ymax)\n             y0 = yc - Ysize / 2.0\n             y1 = yc + Ysize / 2.0\n-            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n-        else:\n-            xc = 0.5 * (xmin + xmax)\n-            x0 = xc - Xsize / 2.0\n-            x1 = xc + Xsize / 2.0\n-            self.set_xbound(x_trf.inverted().transform([x0, x1]))\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n \n     def axis(self, arg=None, /, *, emit=True, **kwargs):\n         \"\"\"\n@@ -4408,9 +4409,55 @@ class _AxesBase(martist.Artist):\n                 self.get_position(True), *args, **kwargs,\n                 axes_locator=_TransformedBoundsLocator(\n                     [0, 0, 1, 1], self.transAxes))\n-        self.set_adjustable('datalim')\n-        twin.set_adjustable('datalim')\n-        self._twinned_axes.join(self, twin)\n+\n+        if aspect == 'equal':\n+            A = abs(aspect_scale_mode(ax.bbox.height, ax.bbox.width,\n+                                      *ax.viewLim.size))\n+        else:\n+            A = aspect\n+\n+        # Ensure at this point A is a positive number.\n+        if A is None or A <= 0:\n+            return\n+\n+        figW, figH = self.get_figure().get_size_inches()\n+        fig_aspect = figH / figW\n+        if self._adjustable == 'box':\n+            if self in self._twinned_axes:\n+                raise RuntimeError(\"Adjustable 'box' is not allowed for \"\n+                                   \"twinned Axes\")\n+            box_aspect = A * self.get_data_ratio()\n+            pb = self.get_position(original=True).frozen()\n+            pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n+            self.set_position(pb1)\n+            return\n+\n+        # The following is only seen if self._adjustable == 'datalim'\n+        # (which is the default).\n+\n+        xmin, xmax, ymin, ymax = self.viewLim.bounds\n+        if self._sharex is not None and xmin == xmax:\n+            xmin, xmax = self._sharex.viewLim.intervalx\n+        if self._sharey is not None and ymin == ymax:\n+            ymin, ymax = self._sharey.viewLim.intervaly\n+\n+        # Use axis transforms to get the transformed view limits\n+        x_trf = self.xaxis.get_transform()\n+        y_trf = self.yaxis.get_transform()\n+        xmin, xmax = x_trf.transform(self.get_xbound())\n+        ymin, ymax = y_trf.transform(self.get_ybound())\n+        xsize = max(abs(xmax - xmin), 1e-30)\n+        ysize = max(abs(ymax - ymin), 1e-30)\n+\n+        # Scale the axes such that in screen space, one unit in data\n+        # coordinates along the x-axis is equal in length to A units\n+        # along the y-axis.  Here, we need *screen space*, or the\n+        # relative units of the axes in their position in the figure.\n+        box = self.get_position(original=True)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         return twin\n \n     def twinx(self):\ndiff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c97a21e029..1e6ce8b6fb 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -115,7 +115,10 @@ def stackplot(axes, x, *args,\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n-    coll.sticky_edges.y[:] = [0]\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n     r = [coll]\n \n     # Color between array i-1 and array i\n",
    "variant_2": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..d40c500d48 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1937,10 +1937,12 @@ class _AxesBase(martist.Artist):\n         else:\n             position = pb1.anchored(self.get_anchor(), pb)\n \n+\n         x_trf = self.xaxis.get_transform()\n         y_trf = self.yaxis.get_transform()\n-        xmin, xmax = x_trf.transform(self.get_xbound())\n-        ymin, ymax = y_trf.transform(self.get_ybound())\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xsize = max(abs(xmax - xmin), 1e-30)\n         ysize = max(abs(ymax - ymin), 1e-30)\n \n@@ -1952,9 +1954,10 @@ class _AxesBase(martist.Artist):\n         if abs(y_expander) < 0.005:\n             return\n \n-        dL = self.dataLim\n-        x0, x1 = x_trf.transform(dL.intervalx)\n-        y0, y1 = y_trf.transform(dL.intervaly)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xr = 1.05 * (x1 - x0)\n         yr = 1.05 * (y1 - y0)\n \n@@ -1992,12 +1995,13 @@ class _AxesBase(martist.Artist):\n             yc = 0.5 * (ymin + ymax)\n             y0 = yc - Ysize / 2.0\n             y1 = yc + Ysize / 2.0\n-            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n-        else:\n-            xc = 0.5 * (xmin + xmax)\n-            x0 = xc - Xsize / 2.0\n-            x1 = xc + Xsize / 2.0\n-            self.set_xbound(x_trf.inverted().transform([x0, x1]))\n+\n+        # Get the data limits in display space\n+        x_trf = self.xaxis.get_transform()\n+        y_trf = self.yaxis.get_transform()\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n \n     def axis(self, arg=None, /, *, emit=True, **kwargs):\n         \"\"\"\n@@ -4408,9 +4412,11 @@ class _AxesBase(martist.Artist):\n                 self.get_position(True), *args, **kwargs,\n                 axes_locator=_TransformedBoundsLocator(\n                     [0, 0, 1, 1], self.transAxes))\n-        self.set_adjustable('datalim')\n-        twin.set_adjustable('datalim')\n-        self._twinned_axes.join(self, twin)\n+\n+        if adjust_y:\n+            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+            x0, x1 = x_trf.transform(self.get_xbound())\n+            y0, y1 = y_trf.transform(self.get_ybound())\n         return twin\n \n     def twinx(self):\ndiff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c97a21e029..1e6ce8b6fb 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -115,7 +115,10 @@ def stackplot(axes, x, *args,\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n-    coll.sticky_edges.y[:] = [0]\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n     r = [coll]\n \n     # Color between array i-1 and array i\n",
    "variant_3": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..7cd4d042ae 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1937,10 +1937,10 @@ class _AxesBase(martist.Artist):\n         else:\n             position = pb1.anchored(self.get_anchor(), pb)\n \n-        x_trf = self.xaxis.get_transform()\n-        y_trf = self.yaxis.get_transform()\n-        xmin, xmax = x_trf.transform(self.get_xbound())\n-        ymin, ymax = y_trf.transform(self.get_ybound())\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xsize = max(abs(xmax - xmin), 1e-30)\n         ysize = max(abs(ymax - ymin), 1e-30)\n \n@@ -1952,9 +1952,10 @@ class _AxesBase(martist.Artist):\n         if abs(y_expander) < 0.005:\n             return\n \n-        dL = self.dataLim\n-        x0, x1 = x_trf.transform(dL.intervalx)\n-        y0, y1 = y_trf.transform(dL.intervaly)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xr = 1.05 * (x1 - x0)\n         yr = 1.05 * (y1 - y0)\n \n@@ -1992,12 +1993,10 @@ class _AxesBase(martist.Artist):\n             yc = 0.5 * (ymin + ymax)\n             y0 = yc - Ysize / 2.0\n             y1 = yc + Ysize / 2.0\n-            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n-        else:\n-            xc = 0.5 * (xmin + xmax)\n-            x0 = xc - Xsize / 2.0\n-            x1 = xc + Xsize / 2.0\n-            self.set_xbound(x_trf.inverted().transform([x0, x1]))\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n \n     def axis(self, arg=None, /, *, emit=True, **kwargs):\n         \"\"\"\n@@ -4408,9 +4407,11 @@ class _AxesBase(martist.Artist):\n                 self.get_position(True), *args, **kwargs,\n                 axes_locator=_TransformedBoundsLocator(\n                     [0, 0, 1, 1], self.transAxes))\n-        self.set_adjustable('datalim')\n-        twin.set_adjustable('datalim')\n-        self._twinned_axes.join(self, twin)\n+\n+        if adjust_y:\n+            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+            x0, x1 = x_trf.transform(self.get_xbound())\n+            y0, y1 = y_trf.transform(self.get_ybound())\n         return twin\n \n     def twinx(self):\ndiff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c97a21e029..1e6ce8b6fb 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -115,7 +115,10 @@ def stackplot(axes, x, *args,\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n-    coll.sticky_edges.y[:] = [0]\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n     r = [coll]\n \n     # Color between array i-1 and array i\n",
    "variant_4": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..e5db3f3273 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1937,10 +1937,12 @@ class _AxesBase(martist.Artist):\n         else:\n             position = pb1.anchored(self.get_anchor(), pb)\n \n+\n         x_trf = self.xaxis.get_transform()\n         y_trf = self.yaxis.get_transform()\n-        xmin, xmax = x_trf.transform(self.get_xbound())\n-        ymin, ymax = y_trf.transform(self.get_ybound())\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xsize = max(abs(xmax - xmin), 1e-30)\n         ysize = max(abs(ymax - ymin), 1e-30)\n \n@@ -1952,9 +1954,10 @@ class _AxesBase(martist.Artist):\n         if abs(y_expander) < 0.005:\n             return\n \n-        dL = self.dataLim\n-        x0, x1 = x_trf.transform(dL.intervalx)\n-        y0, y1 = y_trf.transform(dL.intervaly)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xr = 1.05 * (x1 - x0)\n         yr = 1.05 * (y1 - y0)\n \n@@ -1992,12 +1995,10 @@ class _AxesBase(martist.Artist):\n             yc = 0.5 * (ymin + ymax)\n             y0 = yc - Ysize / 2.0\n             y1 = yc + Ysize / 2.0\n-            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n-        else:\n-            xc = 0.5 * (xmin + xmax)\n-            x0 = xc - Xsize / 2.0\n-            x1 = xc + Xsize / 2.0\n-            self.set_xbound(x_trf.inverted().transform([x0, x1]))\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n \n     def axis(self, arg=None, /, *, emit=True, **kwargs):\n         \"\"\"\n@@ -4408,9 +4409,11 @@ class _AxesBase(martist.Artist):\n                 self.get_position(True), *args, **kwargs,\n                 axes_locator=_TransformedBoundsLocator(\n                     [0, 0, 1, 1], self.transAxes))\n-        self.set_adjustable('datalim')\n-        twin.set_adjustable('datalim')\n-        self._twinned_axes.join(self, twin)\n+\n+        if adjust_y:\n+            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+            x0, x1 = x_trf.transform(self.get_xbound())\n+            y0, y1 = y_trf.transform(self.get_ybound())\n         return twin\n \n     def twinx(self):\ndiff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c97a21e029..1e6ce8b6fb 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -115,7 +115,10 @@ def stackplot(axes, x, *args,\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n-    coll.sticky_edges.y[:] = [0]\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n     r = [coll]\n \n     # Color between array i-1 and array i\n",
    "variant_5": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..7da0d38eb1 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1937,10 +1937,10 @@ class _AxesBase(martist.Artist):\n         else:\n             position = pb1.anchored(self.get_anchor(), pb)\n \n-        x_trf = self.xaxis.get_transform()\n-        y_trf = self.yaxis.get_transform()\n-        xmin, xmax = x_trf.transform(self.get_xbound())\n-        ymin, ymax = y_trf.transform(self.get_ybound())\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xsize = max(abs(xmax - xmin), 1e-30)\n         ysize = max(abs(ymax - ymin), 1e-30)\n \n@@ -1952,9 +1952,10 @@ class _AxesBase(martist.Artist):\n         if abs(y_expander) < 0.005:\n             return\n \n-        dL = self.dataLim\n-        x0, x1 = x_trf.transform(dL.intervalx)\n-        y0, y1 = y_trf.transform(dL.intervaly)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xr = 1.05 * (x1 - x0)\n         yr = 1.05 * (y1 - y0)\n \n@@ -1992,12 +1993,10 @@ class _AxesBase(martist.Artist):\n             yc = 0.5 * (ymin + ymax)\n             y0 = yc - Ysize / 2.0\n             y1 = yc + Ysize / 2.0\n-            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n-        else:\n-            xc = 0.5 * (xmin + xmax)\n-            x0 = xc - Xsize / 2.0\n-            x1 = xc + Xsize / 2.0\n-            self.set_xbound(x_trf.inverted().transform([x0, x1]))\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n \n     def axis(self, arg=None, /, *, emit=True, **kwargs):\n         \"\"\"\n@@ -4408,9 +4407,10 @@ class _AxesBase(martist.Artist):\n                 self.get_position(True), *args, **kwargs,\n                 axes_locator=_TransformedBoundsLocator(\n                     [0, 0, 1, 1], self.transAxes))\n-        self.set_adjustable('datalim')\n-        twin.set_adjustable('datalim')\n-        self._twinned_axes.join(self, twin)\n+\n+        dL = self.dataLim\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         return twin\n \n     def twinx(self):\ndiff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c97a21e029..1e6ce8b6fb 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -115,7 +115,10 @@ def stackplot(axes, x, *args,\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n-    coll.sticky_edges.y[:] = [0]\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n     r = [coll]\n \n     # Color between array i-1 and array i\n",
    "variant_6": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..447be5bbd0 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1937,10 +1937,12 @@ class _AxesBase(martist.Artist):\n         else:\n             position = pb1.anchored(self.get_anchor(), pb)\n \n+\n         x_trf = self.xaxis.get_transform()\n         y_trf = self.yaxis.get_transform()\n-        xmin, xmax = x_trf.transform(self.get_xbound())\n-        ymin, ymax = y_trf.transform(self.get_ybound())\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xsize = max(abs(xmax - xmin), 1e-30)\n         ysize = max(abs(ymax - ymin), 1e-30)\n \n@@ -1952,9 +1954,10 @@ class _AxesBase(martist.Artist):\n         if abs(y_expander) < 0.005:\n             return\n \n-        dL = self.dataLim\n-        x0, x1 = x_trf.transform(dL.intervalx)\n-        y0, y1 = y_trf.transform(dL.intervaly)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xr = 1.05 * (x1 - x0)\n         yr = 1.05 * (y1 - y0)\n \n@@ -1992,12 +1995,10 @@ class _AxesBase(martist.Artist):\n             yc = 0.5 * (ymin + ymax)\n             y0 = yc - Ysize / 2.0\n             y1 = yc + Ysize / 2.0\n-            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n-        else:\n-            xc = 0.5 * (xmin + xmax)\n-            x0 = xc - Xsize / 2.0\n-            x1 = xc + Xsize / 2.0\n-            self.set_xbound(x_trf.inverted().transform([x0, x1]))\n+\n+        dL = self.dataLim\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n \n     def axis(self, arg=None, /, *, emit=True, **kwargs):\n         \"\"\"\n@@ -4408,9 +4409,23 @@ class _AxesBase(martist.Artist):\n                 self.get_position(True), *args, **kwargs,\n                 axes_locator=_TransformedBoundsLocator(\n                     [0, 0, 1, 1], self.transAxes))\n-        self.set_adjustable('datalim')\n-        twin.set_adjustable('datalim')\n-        self._twinned_axes.join(self, twin)\n+\n+        if adjust_x:\n+            # Determine the width of the display area in inches\n+            box = self.get_window_extent().transformed(\n+                self.figure.dpi_scale_trans.inverted())\n+            Xsize = box.width / box.height * Ysize\n+        else:\n+            # Determine the height of the display area in inches\n+            box = self.get_window_extent().transformed(\n+                self.figure.dpi_scale_trans.inverted())\n+            Ysize = box.height / box.width * Xsize\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n+        xsize = max(abs(x1 - x0), 1e-30)\n+        ysize = max(abs(y1 - y0), 1e-30)\n         return twin\n \n     def twinx(self):\ndiff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c97a21e029..1e6ce8b6fb 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -115,7 +115,10 @@ def stackplot(axes, x, *args,\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n-    coll.sticky_edges.y[:] = [0]\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n     r = [coll]\n \n     # Color between array i-1 and array i\n",
    "variant_7": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..e5db3f3273 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1937,10 +1937,12 @@ class _AxesBase(martist.Artist):\n         else:\n             position = pb1.anchored(self.get_anchor(), pb)\n \n+\n         x_trf = self.xaxis.get_transform()\n         y_trf = self.yaxis.get_transform()\n-        xmin, xmax = x_trf.transform(self.get_xbound())\n-        ymin, ymax = y_trf.transform(self.get_ybound())\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xsize = max(abs(xmax - xmin), 1e-30)\n         ysize = max(abs(ymax - ymin), 1e-30)\n \n@@ -1952,9 +1954,10 @@ class _AxesBase(martist.Artist):\n         if abs(y_expander) < 0.005:\n             return\n \n-        dL = self.dataLim\n-        x0, x1 = x_trf.transform(dL.intervalx)\n-        y0, y1 = y_trf.transform(dL.intervaly)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xr = 1.05 * (x1 - x0)\n         yr = 1.05 * (y1 - y0)\n \n@@ -1992,12 +1995,10 @@ class _AxesBase(martist.Artist):\n             yc = 0.5 * (ymin + ymax)\n             y0 = yc - Ysize / 2.0\n             y1 = yc + Ysize / 2.0\n-            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n-        else:\n-            xc = 0.5 * (xmin + xmax)\n-            x0 = xc - Xsize / 2.0\n-            x1 = xc + Xsize / 2.0\n-            self.set_xbound(x_trf.inverted().transform([x0, x1]))\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n \n     def axis(self, arg=None, /, *, emit=True, **kwargs):\n         \"\"\"\n@@ -4408,9 +4409,11 @@ class _AxesBase(martist.Artist):\n                 self.get_position(True), *args, **kwargs,\n                 axes_locator=_TransformedBoundsLocator(\n                     [0, 0, 1, 1], self.transAxes))\n-        self.set_adjustable('datalim')\n-        twin.set_adjustable('datalim')\n-        self._twinned_axes.join(self, twin)\n+\n+        if adjust_y:\n+            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+            x0, x1 = x_trf.transform(self.get_xbound())\n+            y0, y1 = y_trf.transform(self.get_ybound())\n         return twin\n \n     def twinx(self):\ndiff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c97a21e029..1e6ce8b6fb 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -115,7 +115,10 @@ def stackplot(axes, x, *args,\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n-    coll.sticky_edges.y[:] = [0]\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n     r = [coll]\n \n     # Color between array i-1 and array i\n",
    "variant_8": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..3eb010e506 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -1937,10 +1937,12 @@ class _AxesBase(martist.Artist):\n         else:\n             position = pb1.anchored(self.get_anchor(), pb)\n \n+\n         x_trf = self.xaxis.get_transform()\n         y_trf = self.yaxis.get_transform()\n-        xmin, xmax = x_trf.transform(self.get_xbound())\n-        ymin, ymax = y_trf.transform(self.get_ybound())\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xsize = max(abs(xmax - xmin), 1e-30)\n         ysize = max(abs(ymax - ymin), 1e-30)\n \n@@ -1952,9 +1954,10 @@ class _AxesBase(martist.Artist):\n         if abs(y_expander) < 0.005:\n             return\n \n-        dL = self.dataLim\n-        x0, x1 = x_trf.transform(dL.intervalx)\n-        y0, y1 = y_trf.transform(dL.intervaly)\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n         xr = 1.05 * (x1 - x0)\n         yr = 1.05 * (y1 - y0)\n \n@@ -1992,12 +1995,11 @@ class _AxesBase(martist.Artist):\n             yc = 0.5 * (ymin + ymax)\n             y0 = yc - Ysize / 2.0\n             y1 = yc + Ysize / 2.0\n-            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n-        else:\n-            xc = 0.5 * (xmin + xmax)\n-            x0 = xc - Xsize / 2.0\n-            x1 = xc + Xsize / 2.0\n-            self.set_xbound(x_trf.inverted().transform([x0, x1]))\n+\n+        dL = self.dataLim\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n \n     def axis(self, arg=None, /, *, emit=True, **kwargs):\n         \"\"\"\n@@ -4408,9 +4410,11 @@ class _AxesBase(martist.Artist):\n                 self.get_position(True), *args, **kwargs,\n                 axes_locator=_TransformedBoundsLocator(\n                     [0, 0, 1, 1], self.transAxes))\n-        self.set_adjustable('datalim')\n-        twin.set_adjustable('datalim')\n-        self._twinned_axes.join(self, twin)\n+\n+        if adjust_x:\n+            # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+            x0, x1 = x_trf.transform(self.get_xbound())\n+            y0, y1 = y_trf.transform(self.get_ybound())\n         return twin\n \n     def twinx(self):\ndiff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c97a21e029..1e6ce8b6fb 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -115,7 +115,10 @@ def stackplot(axes, x, *args,\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n-    coll.sticky_edges.y[:] = [0]\n+\n+        # Use axis-specific bounds instead of raw dataLim to handle twinned axes properly\n+        x0, x1 = x_trf.transform(self.get_xbound())\n+        y0, y1 = y_trf.transform(self.get_ybound())\n     r = [coll]\n \n     # Color between array i-1 and array i\n"
  }
}