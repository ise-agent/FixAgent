{
  "zero_patches": {
    "Location 1 (/root/hy/projects/scikit-learn/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py lines 428-430)": "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode y_small_train for classifiers to match predict() output\n        y_small_train_decoded = (self.classes_[y_small_train.astype(int)] \n                                if hasattr(self, 'classes_') else y_small_train)\n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n        )\n\n        if self._use_validation_data:\n            # Decode y_val for classifiers to match predict() output\n            y_val_decoded = (self.classes_[y_val.astype(int)] \n                           if hasattr(self, 'classes_') else y_val)\n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_decoded)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
    "Location 2 (/root/hy/projects/scikit-learn/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py lines 433-436)": "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode encoded targets back to original classes for scorer\n        y_small_train_for_scorer = y_small_train\n        if hasattr(self, 'classes_'):\n            y_small_train_for_scorer = self.classes_[y_small_train.astype(int)]\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_for_scorer)\n        )\n\n        if self._use_validation_data:\n            # Decode encoded targets back to original classes for scorer\n            y_val_for_scorer = y_val\n            if hasattr(self, 'classes_'):\n                y_val_for_scorer = self.classes_[y_val.astype(int)]\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scorer)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/scikit-learn/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py lines 428-430)": [
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode encoded targets back to original classes for scoring\n        y_small_train_for_scoring = y_small_train\n        if hasattr(self, 'classes_'):\n            y_small_train_for_scoring = self.classes_[y_small_train.astype(int)]\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_for_scoring)\n        )\n\n        if self._use_validation_data:\n            # Decode encoded targets back to original classes for scoring\n            y_val_for_scoring = y_val\n            if hasattr(self, 'classes_'):\n                y_val_for_scoring = self.classes_[y_val.astype(int)]\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scoring)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # For classifiers, decode y_small_train back to original classes\n        y_small_train_for_scorer = y_small_train\n        if hasattr(self, 'classes_'):\n            y_small_train_for_scorer = self.classes_[y_small_train.astype(int)]\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_for_scorer)\n        )\n\n        if self._use_validation_data:\n            # For classifiers, decode y_val back to original classes\n            y_val_for_scorer = y_val\n            if hasattr(self, 'classes_'):\n                y_val_for_scorer = self.classes_[y_val.astype(int)]\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scorer)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode targets for scoring if this is a classifier\n        if hasattr(self, 'classes_'):\n            y_small_train_decoded = self.classes_[y_small_train.astype(int)]\n        else:\n            y_small_train_decoded = y_small_train\n            \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n        )\n\n        if self._use_validation_data:\n            # Decode validation targets for scoring if this is a classifier\n            if hasattr(self, 'classes_'):\n                y_val_decoded = self.classes_[y_val.astype(int)]\n            else:\n                y_val_decoded = y_val\n                \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_decoded)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode targets for classifiers to match predict() output\n        y_train_for_scorer = y_small_train\n        if hasattr(self, 'classes_'):\n            y_train_for_scorer = self.classes_[y_small_train.astype(int)]\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_train_for_scorer)\n        )\n\n        if self._use_validation_data:\n            # Decode targets for classifiers to match predict() output\n            y_val_for_scorer = y_val\n            if hasattr(self, 'classes_'):\n                y_val_for_scorer = self.classes_[y_val.astype(int)]\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scorer)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # For classifiers, decode encoded targets back to original classes\n        if hasattr(self, 'classes_'):\n            y_small_train_decoded = self.classes_[y_small_train.astype(int)]\n        else:\n            y_small_train_decoded = y_small_train\n            \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n        )\n\n        if self._use_validation_data:\n            # For classifiers, decode encoded targets back to original classes\n            if hasattr(self, 'classes_'):\n                y_val_decoded = self.classes_[y_val.astype(int)]\n            else:\n                y_val_decoded = y_val\n                \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_decoded)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # For classifiers, decode integer targets back to original classes\n        # to match the output type of predict()\n        if hasattr(self, 'classes_'):\n            y_small_train_decoded = self.classes_[y_small_train.astype(int)]\n        else:\n            y_small_train_decoded = y_small_train\n            \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n        )\n\n        if self._use_validation_data:\n            # For classifiers, decode integer targets back to original classes\n            if hasattr(self, 'classes_'):\n                y_val_decoded = self.classes_[y_val.astype(int)]\n            else:\n                y_val_decoded = y_val\n                \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_decoded)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode y_small_train for classifiers to match predict() output\n        y_train_for_scorer = (self.classes_[y_small_train.astype(int)] \n                             if hasattr(self, 'classes_') else y_small_train)\n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_train_for_scorer)\n        )\n\n        if self._use_validation_data:\n            # Decode y_val for classifiers to match predict() output\n            y_val_for_scorer = (self.classes_[y_val.astype(int)] \n                               if hasattr(self, 'classes_') else y_val)\n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scorer)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode targets back to original classes for scoring if this is a classifier\n        y_small_train_for_scoring = y_small_train\n        if hasattr(self, 'classes_'):\n            y_small_train_for_scoring = self.classes_[y_small_train.astype(int)]\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_for_scoring)\n        )\n\n        if self._use_validation_data:\n            # Decode validation targets back to original classes for scoring if this is a classifier\n            y_val_for_scoring = y_val\n            if hasattr(self, 'classes_'):\n                y_val_for_scoring = self.classes_[y_val.astype(int)]\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scoring)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n"
    ],
    "Location 2 (/root/hy/projects/scikit-learn/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py lines 433-436)": [
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode encoded targets back to original classes for scorer\n        if hasattr(self, 'classes_'):\n            y_small_train_decoded = self.classes_[y_small_train.astype(int)]\n        else:\n            y_small_train_decoded = y_small_train\n            \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n        )\n\n        if self._use_validation_data:\n            # Decode encoded targets back to original classes for scorer\n            if hasattr(self, 'classes_'):\n                y_val_decoded = self.classes_[y_val.astype(int)]\n            else:\n                y_val_decoded = y_val\n                \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_decoded)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode encoded targets back to original classes for scoring\n        y_small_train_for_scoring = y_small_train\n        if hasattr(self, 'classes_'):\n            y_small_train_for_scoring = self.classes_[y_small_train.astype(int)]\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_for_scoring)\n        )\n\n        if self._use_validation_data:\n            # Decode encoded targets back to original classes for scoring\n            y_val_for_scoring = y_val\n            if hasattr(self, 'classes_'):\n                y_val_for_scoring = self.classes_[y_val.astype(int)]\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scoring)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode encoded targets back to original classes for scorer\n        y_small_train_for_scorer = y_small_train\n        if hasattr(self, 'classes_'):\n            y_small_train_for_scorer = self.classes_[y_small_train.astype(int)]\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_for_scorer)\n        )\n\n        if self._use_validation_data:\n            # Decode encoded targets back to original classes for scorer\n            y_val_for_scorer = y_val\n            if hasattr(self, 'classes_'):\n                y_val_for_scorer = self.classes_[y_val.astype(int)]\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scorer)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode y_small_train for classifiers to match predict() output\n        y_train_for_scorer = y_small_train\n        if hasattr(self, 'classes_'):\n            y_train_for_scorer = self.classes_[y_small_train.astype(int)]\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_train_for_scorer)\n        )\n\n        if self._use_validation_data:\n            # Decode y_val for classifiers to match predict() output\n            y_val_for_scorer = y_val\n            if hasattr(self, 'classes_'):\n                y_val_for_scorer = self.classes_[y_val.astype(int)]\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scorer)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n        if self._use_validation_data:\n            # For classifiers, decode y_val back to original classes before scoring\n            y_val_for_scoring = (self.classes_[y_val.astype(int)] \n                               if hasattr(self, 'classes_') else y_val)\n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scoring)\n            )\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode y_small_train for scorer if this is a classifier\n        y_train_for_scorer = y_small_train\n        if hasattr(self, 'classes_'):\n            y_train_for_scorer = self.classes_[y_small_train.astype(int)]\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_train_for_scorer)\n        )\n\n        if self._use_validation_data:\n            # Decode y_val for scorer if this is a classifier\n            y_val_for_scorer = y_val\n            if hasattr(self, 'classes_'):\n                y_val_for_scorer = self.classes_[y_val.astype(int)]\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scorer)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode encoded targets back to original classes for scorer\n        y_small_train_decoded = (self.classes_[y_small_train.astype(int)] \n                                if hasattr(self, 'classes_') else y_small_train)\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n        )\n\n        if self._use_validation_data:\n            # Decode encoded targets back to original classes for scorer\n            y_val_decoded = (self.classes_[y_val.astype(int)] \n                           if hasattr(self, 'classes_') else y_val)\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_decoded)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n",
      "\n    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                     X_binned_val, y_val):\n        \"\"\"Check if fitting should be early-stopped based on scorer.\n\n        Scores are computed on validation data or on training data.\n        \"\"\"\n        # Decode encoded targets back to original classes for scorer\n        y_small_train_for_scorer = y_small_train\n        if hasattr(self, 'classes_'):\n            y_small_train_for_scorer = self.classes_[y_small_train.astype(int)]\n        \n        self.train_score_.append(\n            self.scorer_(self, X_binned_small_train, y_small_train_for_scorer)\n        )\n\n        if self._use_validation_data:\n            # Decode encoded targets back to original classes for scorer\n            y_val_for_scorer = y_val\n            if hasattr(self, 'classes_'):\n                y_val_for_scorer = self.classes_[y_val.astype(int)]\n            \n            self.validation_score_.append(\n                self.scorer_(self, X_binned_val, y_val_for_scorer)\n            )\n            return self._should_stop(self.validation_score_)\n        else:\n            return self._should_stop(self.train_score_)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex ad6a5a8ca..6fe0f2e55 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -425,12 +425,19 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n         \"\"\"Check if fitting should be early-stopped based on scorer.\n \n         Scores are computed on validation data or on training data.\n+\n         \"\"\"\n+        if hasattr(self, 'classes_'):\n+            y_small_train = self.classes_[y_small_train.astype(int)]\n         self.train_score_.append(\n             self.scorer_(self, X_binned_small_train, y_small_train)\n         )\n+        )\n+\n \n         if self._use_validation_data:\n+            if hasattr(self, 'classes_'):\n+                y_val = self.classes_[y_val.astype(int)]\n             self.validation_score_.append(\n                 self.scorer_(self, X_binned_val, y_val)\n             )\n",
    "variant_0": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex ad6a5a8ca..973bfd50b 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -420,23 +420,68 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n         else:\n             return X_binned_train, y_train\n \n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+\n     def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                      X_binned_val, y_val):\n         \"\"\"Check if fitting should be early-stopped based on scorer.\n \n         Scores are computed on validation data or on training data.\n         \"\"\"\n+        # Decode y_small_train for classifiers to match predict() output\n+        y_small_train_decoded = (self.classes_[y_small_train.astype(int)] \n+                                if hasattr(self, 'classes_') else y_small_train)\n         self.train_score_.append(\n-            self.scorer_(self, X_binned_small_train, y_small_train)\n+            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n         )\n \n         if self._use_validation_data:\n+            # Decode y_val for classifiers to match predict() output\n+            y_val_decoded = (self.classes_[y_val.astype(int)] \n+                           if hasattr(self, 'classes_') else y_val)\n             self.validation_score_.append(\n-                self.scorer_(self, X_binned_val, y_val)\n+                self.scorer_(self, X_binned_val, y_val_decoded)\n             )\n             return self._should_stop(self.validation_score_)\n         else:\n             return self._should_stop(self.train_score_)\n+        )\n+\n+\n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+        \"\"\"\n+        # Decode encoded targets back to original classes for scorer\n+        y_small_train_for_scorer = y_small_train\n+        if hasattr(self, 'classes_'):\n+            y_small_train_for_scorer = self.classes_[y_small_train.astype(int)]\n+        \n+        self.train_score_.append(\n+            self.scorer_(self, X_binned_small_train, y_small_train_for_scorer)\n+        )\n+\n+        if self._use_validation_data:\n+            # Decode encoded targets back to original classes for scorer\n+            y_val_for_scorer = y_val\n+            if hasattr(self, 'classes_'):\n+                y_val_for_scorer = self.classes_[y_val.astype(int)]\n+            \n+            self.validation_score_.append(\n+                self.scorer_(self, X_binned_val, y_val_for_scorer)\n+            )\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n \n     def _check_early_stopping_loss(self,\n                                    raw_predictions,\n",
    "variant_1": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex ad6a5a8ca..52ff5c2e3 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -420,23 +420,74 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n         else:\n             return X_binned_train, y_train\n \n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+\n     def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                      X_binned_val, y_val):\n         \"\"\"Check if fitting should be early-stopped based on scorer.\n \n         Scores are computed on validation data or on training data.\n         \"\"\"\n+        # Decode encoded targets back to original classes for scoring\n+        y_small_train_for_scoring = y_small_train\n+        if hasattr(self, 'classes_'):\n+            y_small_train_for_scoring = self.classes_[y_small_train.astype(int)]\n+        \n         self.train_score_.append(\n-            self.scorer_(self, X_binned_small_train, y_small_train)\n+            self.scorer_(self, X_binned_small_train, y_small_train_for_scoring)\n         )\n \n         if self._use_validation_data:\n+            # Decode encoded targets back to original classes for scoring\n+            y_val_for_scoring = y_val\n+            if hasattr(self, 'classes_'):\n+                y_val_for_scoring = self.classes_[y_val.astype(int)]\n+            \n             self.validation_score_.append(\n-                self.scorer_(self, X_binned_val, y_val)\n+                self.scorer_(self, X_binned_val, y_val_for_scoring)\n             )\n             return self._should_stop(self.validation_score_)\n         else:\n             return self._should_stop(self.train_score_)\n+        )\n+\n+\n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+        \"\"\"\n+        # Decode encoded targets back to original classes for scorer\n+        if hasattr(self, 'classes_'):\n+            y_small_train_decoded = self.classes_[y_small_train.astype(int)]\n+        else:\n+            y_small_train_decoded = y_small_train\n+            \n+        self.train_score_.append(\n+            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n+        )\n+\n+        if self._use_validation_data:\n+            # Decode encoded targets back to original classes for scorer\n+            if hasattr(self, 'classes_'):\n+                y_val_decoded = self.classes_[y_val.astype(int)]\n+            else:\n+                y_val_decoded = y_val\n+                \n+            self.validation_score_.append(\n+                self.scorer_(self, X_binned_val, y_val_decoded)\n+            )\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n \n     def _check_early_stopping_loss(self,\n                                    raw_predictions,\n",
    "variant_2": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex ad6a5a8ca..39f7061ec 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -420,23 +420,72 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n         else:\n             return X_binned_train, y_train\n \n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+\n     def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                      X_binned_val, y_val):\n         \"\"\"Check if fitting should be early-stopped based on scorer.\n \n         Scores are computed on validation data or on training data.\n         \"\"\"\n+        # For classifiers, decode y_small_train back to original classes\n+        y_small_train_for_scorer = y_small_train\n+        if hasattr(self, 'classes_'):\n+            y_small_train_for_scorer = self.classes_[y_small_train.astype(int)]\n+        \n         self.train_score_.append(\n-            self.scorer_(self, X_binned_small_train, y_small_train)\n+            self.scorer_(self, X_binned_small_train, y_small_train_for_scorer)\n         )\n \n         if self._use_validation_data:\n+            # For classifiers, decode y_val back to original classes\n+            y_val_for_scorer = y_val\n+            if hasattr(self, 'classes_'):\n+                y_val_for_scorer = self.classes_[y_val.astype(int)]\n+            \n             self.validation_score_.append(\n-                self.scorer_(self, X_binned_val, y_val)\n+                self.scorer_(self, X_binned_val, y_val_for_scorer)\n             )\n             return self._should_stop(self.validation_score_)\n         else:\n             return self._should_stop(self.train_score_)\n+        )\n+\n+\n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+        \"\"\"\n+        # Decode encoded targets back to original classes for scoring\n+        y_small_train_for_scoring = y_small_train\n+        if hasattr(self, 'classes_'):\n+            y_small_train_for_scoring = self.classes_[y_small_train.astype(int)]\n+        \n+        self.train_score_.append(\n+            self.scorer_(self, X_binned_small_train, y_small_train_for_scoring)\n+        )\n+\n+        if self._use_validation_data:\n+            # Decode encoded targets back to original classes for scoring\n+            y_val_for_scoring = y_val\n+            if hasattr(self, 'classes_'):\n+                y_val_for_scoring = self.classes_[y_val.astype(int)]\n+            \n+            self.validation_score_.append(\n+                self.scorer_(self, X_binned_val, y_val_for_scoring)\n+            )\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n \n     def _check_early_stopping_loss(self,\n                                    raw_predictions,\n",
    "variant_3": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex ad6a5a8ca..ff1922789 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -420,23 +420,74 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n         else:\n             return X_binned_train, y_train\n \n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+\n     def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                      X_binned_val, y_val):\n         \"\"\"Check if fitting should be early-stopped based on scorer.\n \n         Scores are computed on validation data or on training data.\n         \"\"\"\n+        # Decode targets for scoring if this is a classifier\n+        if hasattr(self, 'classes_'):\n+            y_small_train_decoded = self.classes_[y_small_train.astype(int)]\n+        else:\n+            y_small_train_decoded = y_small_train\n+            \n         self.train_score_.append(\n-            self.scorer_(self, X_binned_small_train, y_small_train)\n+            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n         )\n \n         if self._use_validation_data:\n+            # Decode validation targets for scoring if this is a classifier\n+            if hasattr(self, 'classes_'):\n+                y_val_decoded = self.classes_[y_val.astype(int)]\n+            else:\n+                y_val_decoded = y_val\n+                \n             self.validation_score_.append(\n-                self.scorer_(self, X_binned_val, y_val)\n+                self.scorer_(self, X_binned_val, y_val_decoded)\n             )\n             return self._should_stop(self.validation_score_)\n         else:\n             return self._should_stop(self.train_score_)\n+        )\n+\n+\n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+        \"\"\"\n+        # Decode encoded targets back to original classes for scorer\n+        y_small_train_for_scorer = y_small_train\n+        if hasattr(self, 'classes_'):\n+            y_small_train_for_scorer = self.classes_[y_small_train.astype(int)]\n+        \n+        self.train_score_.append(\n+            self.scorer_(self, X_binned_small_train, y_small_train_for_scorer)\n+        )\n+\n+        if self._use_validation_data:\n+            # Decode encoded targets back to original classes for scorer\n+            y_val_for_scorer = y_val\n+            if hasattr(self, 'classes_'):\n+                y_val_for_scorer = self.classes_[y_val.astype(int)]\n+            \n+            self.validation_score_.append(\n+                self.scorer_(self, X_binned_val, y_val_for_scorer)\n+            )\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n \n     def _check_early_stopping_loss(self,\n                                    raw_predictions,\n",
    "variant_4": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex ad6a5a8ca..123251314 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -420,23 +420,72 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n         else:\n             return X_binned_train, y_train\n \n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+\n     def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                      X_binned_val, y_val):\n         \"\"\"Check if fitting should be early-stopped based on scorer.\n \n         Scores are computed on validation data or on training data.\n         \"\"\"\n+        # Decode targets for classifiers to match predict() output\n+        y_train_for_scorer = y_small_train\n+        if hasattr(self, 'classes_'):\n+            y_train_for_scorer = self.classes_[y_small_train.astype(int)]\n+        \n         self.train_score_.append(\n-            self.scorer_(self, X_binned_small_train, y_small_train)\n+            self.scorer_(self, X_binned_small_train, y_train_for_scorer)\n         )\n \n         if self._use_validation_data:\n+            # Decode targets for classifiers to match predict() output\n+            y_val_for_scorer = y_val\n+            if hasattr(self, 'classes_'):\n+                y_val_for_scorer = self.classes_[y_val.astype(int)]\n+            \n             self.validation_score_.append(\n-                self.scorer_(self, X_binned_val, y_val)\n+                self.scorer_(self, X_binned_val, y_val_for_scorer)\n             )\n             return self._should_stop(self.validation_score_)\n         else:\n             return self._should_stop(self.train_score_)\n+        )\n+\n+\n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+        \"\"\"\n+        # Decode y_small_train for classifiers to match predict() output\n+        y_train_for_scorer = y_small_train\n+        if hasattr(self, 'classes_'):\n+            y_train_for_scorer = self.classes_[y_small_train.astype(int)]\n+        \n+        self.train_score_.append(\n+            self.scorer_(self, X_binned_small_train, y_train_for_scorer)\n+        )\n+\n+        if self._use_validation_data:\n+            # Decode y_val for classifiers to match predict() output\n+            y_val_for_scorer = y_val\n+            if hasattr(self, 'classes_'):\n+                y_val_for_scorer = self.classes_[y_val.astype(int)]\n+            \n+            self.validation_score_.append(\n+                self.scorer_(self, X_binned_val, y_val_for_scorer)\n+            )\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n \n     def _check_early_stopping_loss(self,\n                                    raw_predictions,\n",
    "variant_5": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex ad6a5a8ca..2282a9121 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -420,19 +420,50 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n         else:\n             return X_binned_train, y_train\n \n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+\n     def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                      X_binned_val, y_val):\n         \"\"\"Check if fitting should be early-stopped based on scorer.\n \n         Scores are computed on validation data or on training data.\n         \"\"\"\n+        # For classifiers, decode encoded targets back to original classes\n+        if hasattr(self, 'classes_'):\n+            y_small_train_decoded = self.classes_[y_small_train.astype(int)]\n+        else:\n+            y_small_train_decoded = y_small_train\n+            \n         self.train_score_.append(\n-            self.scorer_(self, X_binned_small_train, y_small_train)\n+            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n         )\n \n         if self._use_validation_data:\n+            # For classifiers, decode encoded targets back to original classes\n+            if hasattr(self, 'classes_'):\n+                y_val_decoded = self.classes_[y_val.astype(int)]\n+            else:\n+                y_val_decoded = y_val\n+                \n+            self.validation_score_.append(\n+                self.scorer_(self, X_binned_val, y_val_decoded)\n+            )\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n+        )\n+\n+\n+        if self._use_validation_data:\n+            # For classifiers, decode y_val back to original classes before scoring\n+            y_val_for_scoring = (self.classes_[y_val.astype(int)] \n+                               if hasattr(self, 'classes_') else y_val)\n             self.validation_score_.append(\n-                self.scorer_(self, X_binned_val, y_val)\n+                self.scorer_(self, X_binned_val, y_val_for_scoring)\n             )\n             return self._should_stop(self.validation_score_)\n         else:\n",
    "variant_6": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex ad6a5a8ca..5a466adf6 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -420,23 +420,75 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n         else:\n             return X_binned_train, y_train\n \n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+\n     def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                      X_binned_val, y_val):\n         \"\"\"Check if fitting should be early-stopped based on scorer.\n \n         Scores are computed on validation data or on training data.\n         \"\"\"\n+        # For classifiers, decode integer targets back to original classes\n+        # to match the output type of predict()\n+        if hasattr(self, 'classes_'):\n+            y_small_train_decoded = self.classes_[y_small_train.astype(int)]\n+        else:\n+            y_small_train_decoded = y_small_train\n+            \n         self.train_score_.append(\n-            self.scorer_(self, X_binned_small_train, y_small_train)\n+            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n         )\n \n         if self._use_validation_data:\n+            # For classifiers, decode integer targets back to original classes\n+            if hasattr(self, 'classes_'):\n+                y_val_decoded = self.classes_[y_val.astype(int)]\n+            else:\n+                y_val_decoded = y_val\n+                \n             self.validation_score_.append(\n-                self.scorer_(self, X_binned_val, y_val)\n+                self.scorer_(self, X_binned_val, y_val_decoded)\n             )\n             return self._should_stop(self.validation_score_)\n         else:\n             return self._should_stop(self.train_score_)\n+        )\n+\n+\n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+        \"\"\"\n+        # Decode y_small_train for scorer if this is a classifier\n+        y_train_for_scorer = y_small_train\n+        if hasattr(self, 'classes_'):\n+            y_train_for_scorer = self.classes_[y_small_train.astype(int)]\n+        \n+        self.train_score_.append(\n+            self.scorer_(self, X_binned_small_train, y_train_for_scorer)\n+        )\n+\n+        if self._use_validation_data:\n+            # Decode y_val for scorer if this is a classifier\n+            y_val_for_scorer = y_val\n+            if hasattr(self, 'classes_'):\n+                y_val_for_scorer = self.classes_[y_val.astype(int)]\n+            \n+            self.validation_score_.append(\n+                self.scorer_(self, X_binned_val, y_val_for_scorer)\n+            )\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n \n     def _check_early_stopping_loss(self,\n                                    raw_predictions,\n",
    "variant_7": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex ad6a5a8ca..71731574c 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -420,23 +420,66 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n         else:\n             return X_binned_train, y_train\n \n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+\n     def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                      X_binned_val, y_val):\n         \"\"\"Check if fitting should be early-stopped based on scorer.\n \n         Scores are computed on validation data or on training data.\n         \"\"\"\n+        # Decode y_small_train for classifiers to match predict() output\n+        y_train_for_scorer = (self.classes_[y_small_train.astype(int)] \n+                             if hasattr(self, 'classes_') else y_small_train)\n         self.train_score_.append(\n-            self.scorer_(self, X_binned_small_train, y_small_train)\n+            self.scorer_(self, X_binned_small_train, y_train_for_scorer)\n         )\n \n         if self._use_validation_data:\n+            # Decode y_val for classifiers to match predict() output\n+            y_val_for_scorer = (self.classes_[y_val.astype(int)] \n+                               if hasattr(self, 'classes_') else y_val)\n             self.validation_score_.append(\n-                self.scorer_(self, X_binned_val, y_val)\n+                self.scorer_(self, X_binned_val, y_val_for_scorer)\n             )\n             return self._should_stop(self.validation_score_)\n         else:\n             return self._should_stop(self.train_score_)\n+        )\n+\n+\n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+        \"\"\"\n+        # Decode encoded targets back to original classes for scorer\n+        y_small_train_decoded = (self.classes_[y_small_train.astype(int)] \n+                                if hasattr(self, 'classes_') else y_small_train)\n+        \n+        self.train_score_.append(\n+            self.scorer_(self, X_binned_small_train, y_small_train_decoded)\n+        )\n+\n+        if self._use_validation_data:\n+            # Decode encoded targets back to original classes for scorer\n+            y_val_decoded = (self.classes_[y_val.astype(int)] \n+                           if hasattr(self, 'classes_') else y_val)\n+            \n+            self.validation_score_.append(\n+                self.scorer_(self, X_binned_val, y_val_decoded)\n+            )\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n \n     def _check_early_stopping_loss(self,\n                                    raw_predictions,\n",
    "variant_8": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\nindex ad6a5a8ca..f8d0d3e39 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py\n@@ -420,23 +420,72 @@ class BaseHistGradientBoosting(BaseEstimator, ABC):\n         else:\n             return X_binned_train, y_train\n \n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+\n     def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n                                      X_binned_val, y_val):\n         \"\"\"Check if fitting should be early-stopped based on scorer.\n \n         Scores are computed on validation data or on training data.\n         \"\"\"\n+        # Decode targets back to original classes for scoring if this is a classifier\n+        y_small_train_for_scoring = y_small_train\n+        if hasattr(self, 'classes_'):\n+            y_small_train_for_scoring = self.classes_[y_small_train.astype(int)]\n+        \n         self.train_score_.append(\n-            self.scorer_(self, X_binned_small_train, y_small_train)\n+            self.scorer_(self, X_binned_small_train, y_small_train_for_scoring)\n         )\n \n         if self._use_validation_data:\n+            # Decode validation targets back to original classes for scoring if this is a classifier\n+            y_val_for_scoring = y_val\n+            if hasattr(self, 'classes_'):\n+                y_val_for_scoring = self.classes_[y_val.astype(int)]\n+            \n             self.validation_score_.append(\n-                self.scorer_(self, X_binned_val, y_val)\n+                self.scorer_(self, X_binned_val, y_val_for_scoring)\n             )\n             return self._should_stop(self.validation_score_)\n         else:\n             return self._should_stop(self.train_score_)\n+        )\n+\n+\n+    def _check_early_stopping_scorer(self, X_binned_small_train, y_small_train,\n+                                     X_binned_val, y_val):\n+        \"\"\"Check if fitting should be early-stopped based on scorer.\n+\n+        Scores are computed on validation data or on training data.\n+        \"\"\"\n+        # Decode encoded targets back to original classes for scorer\n+        y_small_train_for_scorer = y_small_train\n+        if hasattr(self, 'classes_'):\n+            y_small_train_for_scorer = self.classes_[y_small_train.astype(int)]\n+        \n+        self.train_score_.append(\n+            self.scorer_(self, X_binned_small_train, y_small_train_for_scorer)\n+        )\n+\n+        if self._use_validation_data:\n+            # Decode encoded targets back to original classes for scorer\n+            y_val_for_scorer = y_val\n+            if hasattr(self, 'classes_'):\n+                y_val_for_scorer = self.classes_[y_val.astype(int)]\n+            \n+            self.validation_score_.append(\n+                self.scorer_(self, X_binned_val, y_val_for_scorer)\n+            )\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n+            return self._should_stop(self.validation_score_)\n+        else:\n+            return self._should_stop(self.train_score_)\n \n     def _check_early_stopping_loss(self,\n                                    raw_predictions,\n"
  }
}