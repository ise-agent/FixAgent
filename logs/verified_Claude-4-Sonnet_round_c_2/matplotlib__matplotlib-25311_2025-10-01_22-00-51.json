{
  "zero_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/offsetbox.py lines 1508-1515)": "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self._setup_callbacks()\n\n    def _setup_callbacks(self):\n        \"\"\"Setup canvas callbacks if canvas is available.\"\"\"\n        if self.canvas is not None:\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n        else:\n            self.cids = []\n",
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/offsetbox.py lines 1574-1581)": "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling, excluding unpickleable canvas and cids.\"\"\"\n        state = self.__dict__.copy()\n        # Remove the unpickleable canvas reference and callback IDs\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling and reinitialize canvas if available.\"\"\"\n        self.__dict__.update(state)\n        # Try to restore canvas from ref_artist if it has a valid figure\n        if hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None:\n            if hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reinitialize callback IDs as empty list\n                self.cids = []\n            else:\n                self.canvas = None\n                self.cids = []\n        else:\n            self.canvas = None\n            self.cids = []\n",
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/offsetbox.py lines 1563-1572)": "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            for cid in self.cids:\n                self.canvas.mpl_disconnect(cid)\n            try:\n                c1 = self._c1\n            except AttributeError:\n                pass\n            else:\n                self.canvas.mpl_disconnect(c1)\n",
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/offsetbox.py lines 1516-1562)": "\n    def on_motion(self, evt):\n        if self._check_still_parented() and self.got_artist:\n            if self.canvas is None:\n                return\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            if self.canvas is None:\n                return\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            self._c1 = self.canvas.callbacks._connect_picklable(\n                \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n\n    def on_release(self, event):\n        if self._check_still_parented() and self.got_artist:\n            if self.canvas is None:\n                return\n            self.finalize_offset()\n            self.got_artist = False\n            self.canvas.mpl_disconnect(self._c1)\n\n            if self._use_blit:\n                self.ref_artist.set_animated(False)\n\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas connection if it was lost during unpickling\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                self._use_blit = self._use_blit and self.canvas.supports_blit\n                # Reconnect the main callbacks\n                self.cids = [\n                    self.canvas.callbacks._connect_picklable(\n                        'pick_event', self.on_pick),\n                    self.canvas.callbacks._connect_picklable(\n                        'button_release_event', self.on_release),\n                ]\n            return True\n",
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/offsetbox.py lines 1555-1561)": "\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas connection after unpickling if needed\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect callbacks if canvas is available\n                self.cids = [\n                    self.canvas.mpl_connect('pick_event', self.on_pick),\n                    self.canvas.mpl_connect('button_release_event', self.on_release),\n                ]\n            return True\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/offsetbox.py lines 1508-1515)": [
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = []\n        self._connect_callbacks()\n    \n    def _connect_callbacks(self):\n        \"\"\"Connect canvas callbacks if canvas is available.\"\"\"\n        if self.canvas is not None:\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = []\n        if self.canvas is not None:\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas if self.ref_artist.figure else None\n        self._use_blit = use_blit and self.canvas and self.canvas.supports_blit\n        self.cids = []\n        if self.canvas is not None:\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas if self.ref_artist.figure else None\n        self._use_blit = use_blit and self.canvas and self.canvas.supports_blit\n        self.cids = []\n        if self.canvas:\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self._reconnect_callbacks()\n\n    def _reconnect_callbacks(self):\n        \"\"\"Connect or reconnect canvas callbacks.\"\"\"\n        if self.canvas is not None:\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n        else:\n            self.cids = []\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = []\n        self._connect_callbacks()\n\n    def _connect_callbacks(self):\n        \"\"\"Connect callbacks if canvas is available.\"\"\"\n        if self.canvas is not None:\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas if self.ref_artist.figure else None\n        self._use_blit = use_blit and self.canvas and self.canvas.supports_blit\n        self.cids = []\n        if self.canvas is not None:\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = []\n        if self.canvas is not None:\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n"
    ],
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/offsetbox.py lines 1574-1581)": [
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpickleable canvas reference.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpickleable canvas and callback IDs\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling and reconnect to canvas if available.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be restored when needed through _check_still_parented\n        # or when the figure is next displayed\n        self.canvas = None\n        self.cids = []\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        # Exclude canvas and connection IDs from pickle state\n        state = self.__dict__.copy()\n        state['canvas'] = None\n        state['cids'] = []\n        if hasattr(self, '_c1'):\n            state['_c1'] = None\n        return state\n\n    def __setstate__(self, state):\n        # Restore state and canvas reference\n        self.__dict__.update(state)\n        if self.ref_artist and self.ref_artist.figure:\n            self.canvas = self.ref_artist.figure.canvas\n            if self.canvas is not None:\n                # Reconnect callbacks\n                self.cids = [\n                    self.canvas.mpl_connect('motion_notify_event', self.on_motion),\n                    self.canvas.mpl_connect('button_release_event', self.on_release),\n                ]\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Custom pickle state that excludes unpickleable canvas reference.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpickleable canvas and callback IDs\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Custom unpickle state that restores canvas reference if available.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference from ref_artist if available\n        if hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None:\n            canvas = self.ref_artist.figure.canvas\n            if canvas is not None:\n                self.canvas = canvas\n                self.cids = []\n                # Reconnect callbacks if canvas is available\n                self._reconnect_callbacks()\n            else:\n                self.canvas = None\n                self.cids = []\n        else:\n            self.canvas = None\n            self.cids = []\n\n    def _reconnect_callbacks(self):\n        \"\"\"Reconnect callbacks after unpickling if canvas is available.\"\"\"\n        if self.canvas is not None and hasattr(self, 'cids'):\n            # Clear existing callbacks\n            self.cids.clear()\n            # Reconnect the standard callbacks\n            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n            self.cids.append(self.canvas.mpl_connect(\"button_release_event\", self.on_release))\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpickleable canvas reference.\"\"\"\n        state = self.__dict__.copy()\n        # Remove canvas reference and callback IDs as they cannot be pickled\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling and reinitialize canvas reference.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference from ref_artist if available\n        if hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None:\n            canvas = getattr(self.ref_artist.figure, 'canvas', None)\n            if canvas is not None:\n                self.canvas = canvas\n                # Reinitialize callbacks when canvas becomes available\n                self.cids = [\n                    self.canvas.mpl_connect('pick_event', self.on_pick),\n                    self.canvas.mpl_connect('button_release_event', self.on_release),\n                ]\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Prepare state for pickling by excluding unpickleable canvas reference.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpickleable canvas and callback IDs\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state after unpickling and reconnect canvas if available.\"\"\"\n        self.__dict__.update(state)\n        # Try to restore canvas reference from ref_artist\n        if hasattr(self.ref_artist, 'figure') and hasattr(self.ref_artist.figure, 'canvas'):\n            canvas = self.ref_artist.figure.canvas\n            if canvas is not None:\n                self.canvas = canvas\n                # Reinitialize callback IDs list\n                self.cids = []\n                # Note: Actual callback connections will be restored when needed\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpickleable canvas reference.\"\"\"\n        state = self.__dict__.copy()\n        # Remove the unpickleable canvas reference and callback IDs\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling and reinitialize canvas reference.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be restored when needed via _check_still_parented\n        self.canvas = None\n        self.cids = []\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpickleable canvas reference.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpickleable canvas and callback IDs\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling and reinitialize canvas if available.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference if ref_artist has a valid figure\n        if hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None:\n            if hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reinitialize callbacks if canvas is available\n                self.cids = []\n                self.cids.append(self.canvas.mpl_connect('motion_notify_event', self.on_motion))\n                self.cids.append(self.canvas.mpl_connect('button_release_event', self.on_release))\n            else:\n                self.canvas = None\n        else:\n            self.canvas = None\n        \n        # Ensure cids is initialized even if canvas is None\n        if not hasattr(self, 'cids'):\n            self.cids = []\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpickleable canvas reference.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpickleable canvas and callback IDs\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object state after unpickling and reinitialize canvas if available.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference from ref_artist if available\n        if hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None:\n            if hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reinitialize callback IDs as empty list\n                self.cids = []\n            else:\n                self.canvas = None\n                self.cids = []\n        else:\n            self.canvas = None\n            self.cids = []\n"
    ],
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/offsetbox.py lines 1563-1572)": [
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            for cid in self.cids:\n                self.canvas.mpl_disconnect(cid)\n            try:\n                c1 = self._c1\n            except AttributeError:\n                pass\n            else:\n                self.canvas.mpl_disconnect(c1)\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            for cid in self.cids:\n                self.canvas.mpl_disconnect(cid)\n            try:\n                c1 = self._c1\n            except AttributeError:\n                pass\n            else:\n                self.canvas.mpl_disconnect(c1)\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            for cid in self.cids:\n                self.canvas.mpl_disconnect(cid)\n            try:\n                c1 = self._c1\n            except AttributeError:\n                pass\n            else:\n                self.canvas.mpl_disconnect(c1)\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            for cid in self.cids:\n                self.canvas.mpl_disconnect(cid)\n            try:\n                c1 = self._c1\n            except AttributeError:\n                pass\n            else:\n                self.canvas.mpl_disconnect(c1)\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            for cid in self.cids:\n                self.canvas.mpl_disconnect(cid)\n            try:\n                c1 = self._c1\n            except AttributeError:\n                pass\n            else:\n                self.canvas.mpl_disconnect(c1)\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            for cid in self.cids:\n                self.canvas.mpl_disconnect(cid)\n            try:\n                c1 = self._c1\n            except AttributeError:\n                pass\n            else:\n                self.canvas.mpl_disconnect(c1)\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            for cid in self.cids:\n                self.canvas.mpl_disconnect(cid)\n            try:\n                c1 = self._c1\n            except AttributeError:\n                pass\n            else:\n                self.canvas.mpl_disconnect(c1)\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            for cid in self.cids:\n                self.canvas.mpl_disconnect(cid)\n            try:\n                c1 = self._c1\n            except AttributeError:\n                pass\n            else:\n                self.canvas.mpl_disconnect(c1)\n"
    ],
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/offsetbox.py lines 1516-1562)": [
      "\ndef on_motion(self, evt):\n    if self._check_still_parented() and self.got_artist and self.canvas is not None:\n        dx = evt.x - self.mouse_x\n        dy = evt.y - self.mouse_y\n        self.update_offset(dx, dy)\n        if self._use_blit:\n            self.canvas.restore_region(self.background)\n            self.ref_artist.draw(\n                self.ref_artist.figure._get_renderer())\n            self.canvas.blit()\n        else:\n            self.canvas.draw()\n\ndef on_pick(self, evt):\n    if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n        self.mouse_x = evt.mouseevent.x\n        self.mouse_y = evt.mouseevent.y\n        self.got_artist = True\n        if self._use_blit:\n            self.ref_artist.set_animated(True)\n            self.canvas.draw()\n            self.background = \\\n                self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n            self.ref_artist.draw(\n                self.ref_artist.figure._get_renderer())\n            self.canvas.blit()\n        self._c1 = self.canvas.callbacks._connect_picklable(\n            \"motion_notify_event\", self.on_motion)\n        self.save_offset()\n\ndef on_release(self, event):\n    if self._check_still_parented() and self.got_artist and self.canvas is not None:\n        self.finalize_offset()\n        self.got_artist = False\n        self.canvas.mpl_disconnect(self._c1)\n\n        if self._use_blit:\n            self.ref_artist.set_animated(False)\n\ndef _check_still_parented(self):\n    if self.ref_artist.figure is None:\n        self.disconnect()\n        return False\n    else:\n        # Restore canvas connection after unpickling if needed\n        if self.canvas is None and self.ref_artist.figure.canvas is not None:\n            self.canvas = self.ref_artist.figure.canvas\n            self._use_blit = self._use_blit and self.canvas.supports_blit\n            # Reconnect the persistent callbacks\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n        return True\n",
      "\n    def on_motion(self, evt):\n        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            self._c1 = self.canvas.callbacks._connect_picklable(\n                \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n\n    def on_release(self, event):\n        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n            self.finalize_offset()\n            self.got_artist = False\n            self.canvas.mpl_disconnect(self._c1)\n\n            if self._use_blit:\n                self.ref_artist.set_animated(False)\n\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas if it was None (e.g., after unpickling)\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                self._use_blit = self._use_blit and self.canvas.supports_blit\n                # Reconnect callbacks if they were lost\n                if not hasattr(self, 'cids') or not self.cids:\n                    self.cids = [\n                        self.canvas.callbacks._connect_picklable(\n                            'pick_event', self.on_pick),\n                        self.canvas.callbacks._connect_picklable(\n                            'button_release_event', self.on_release),\n                    ]\n            return True\n",
      "\n    def on_motion(self, evt):\n        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            self._c1 = self.canvas.callbacks._connect_picklable(\n                \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n\n    def on_release(self, event):\n        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n            self.finalize_offset()\n            self.got_artist = False\n            self.canvas.mpl_disconnect(self._c1)\n\n            if self._use_blit:\n                self.ref_artist.set_animated(False)\n\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        elif self.canvas is None and self.ref_artist.figure.canvas is not None:\n            # Restore canvas connection after unpickling\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n        return True\n",
      "\n    def on_motion(self, evt):\n        if self.canvas is None:\n            return\n        if self._check_still_parented() and self.got_artist:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self.canvas is None:\n            return\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            self._c1 = self.canvas.callbacks._connect_picklable(\n                \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n\n    def on_release(self, event):\n        if self.canvas is None:\n            return\n        if self._check_still_parented() and self.got_artist:\n            self.finalize_offset()\n            self.got_artist = False\n            self.canvas.mpl_disconnect(self._c1)\n\n            if self._use_blit:\n                self.ref_artist.set_animated(False)\n\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas and callbacks if they were lost during unpickling\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                self._use_blit = self._use_blit and self.canvas.supports_blit\n                self.cids = [\n                    self.canvas.callbacks._connect_picklable(\n                        'pick_event', self.on_pick),\n                    self.canvas.callbacks._connect_picklable(\n                        'button_release_event', self.on_release),\n                ]\n            return True\n",
      "\n    def on_motion(self, evt):\n        if self.canvas is not None and self._check_still_parented() and self.got_artist:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self.canvas is not None and self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            self._c1 = self.canvas.callbacks._connect_picklable(\n                \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n\n    def on_release(self, event):\n        if self.canvas is not None and self._check_still_parented() and self.got_artist:\n            self.finalize_offset()\n            self.got_artist = False\n            self.canvas.mpl_disconnect(self._c1)\n\n            if self._use_blit:\n                self.ref_artist.set_animated(False)\n\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas connection if needed after unpickling\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                self.cids = [\n                    self.canvas.callbacks._connect_picklable(\n                        'pick_event', self.on_pick),\n                    self.canvas.callbacks._connect_picklable(\n                        'button_release_event', self.on_release),\n                ]\n            return True\n",
      "\n    def on_motion(self, evt):\n        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            self._c1 = self.canvas.callbacks._connect_picklable(\n                \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n\n    def on_release(self, event):\n        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n            self.finalize_offset()\n            self.got_artist = False\n            self.canvas.mpl_disconnect(self._c1)\n\n            if self._use_blit:\n                self.ref_artist.set_animated(False)\n\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas reference if it was lost during unpickling\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect main callbacks if they were disconnected\n                if not hasattr(self, 'cids') or not self.cids:\n                    self.cids = [\n                        self.canvas.callbacks._connect_picklable(\n                            'pick_event', self.on_pick),\n                        self.canvas.callbacks._connect_picklable(\n                            'button_release_event', self.on_release),\n                    ]\n            return True\n",
      "\n    def on_motion(self, evt):\n        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            self._c1 = self.canvas.callbacks._connect_picklable(\n                \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n\n    def on_release(self, event):\n        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n            self.finalize_offset()\n            self.got_artist = False\n            self.canvas.mpl_disconnect(self._c1)\n\n            if self._use_blit:\n                self.ref_artist.set_animated(False)\n\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas connection if it was lost during unpickling\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                self._use_blit = self._use_blit and self.canvas.supports_blit\n                self.cids = [\n                    self.canvas.callbacks._connect_picklable(\n                        'pick_event', self.on_pick),\n                    self.canvas.callbacks._connect_picklable(\n                        'button_release_event', self.on_release),\n                ]\n            return True\n",
      "\n    def on_motion(self, evt):\n        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n            dx = evt.x - self.mouse_x\n            dy = evt.y - self.mouse_y\n            self.update_offset(dx, dy)\n            if self._use_blit:\n                self.canvas.restore_region(self.background)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            else:\n                self.canvas.draw()\n\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            self._c1 = self.canvas.callbacks._connect_picklable(\n                \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n\n    def on_release(self, event):\n        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n            self.finalize_offset()\n            self.got_artist = False\n            self.canvas.mpl_disconnect(self._c1)\n\n            if self._use_blit:\n                self.ref_artist.set_animated(False)\n\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas if it's None but figure has a canvas\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect callbacks if needed\n                if not hasattr(self, 'cids') or not self.cids:\n                    self.cids = [\n                        self.canvas.callbacks._connect_picklable(\n                            'pick_event', self.on_pick),\n                        self.canvas.callbacks._connect_picklable(\n                            'button_release_event', self.on_release),\n                    ]\n            return True\n"
    ],
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/offsetbox.py lines 1555-1561)": [
      "\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Handle canvas restoration after unpickling\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect callbacks if they were disconnected\n                if hasattr(self, 'cids') and not self.cids:\n                    self.cids = [\n                        self.canvas.mpl_connect('pick_event', self.on_pick),\n                        self.canvas.mpl_connect('button_release_event', self.on_release),\n                    ]\n            return True\n",
      "\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Handle canvas restoration after unpickling\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect callbacks if needed\n                if hasattr(self, 'cids') and not self.cids:\n                    self.connect()\n            return True\n",
      "\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas connection after unpickling if needed\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect callbacks if canvas is available\n                self.cids = [\n                    self.canvas.mpl_connect('pick_event', self.on_pick),\n                    self.canvas.mpl_connect('button_release_event', self.on_release),\n                ]\n            return True\n",
      "\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas connection if it was lost during unpickling\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect callbacks if canvas was restored\n                self.cids = [\n                    self.canvas.mpl_connect('pick_event', self.on_pick),\n                    self.canvas.mpl_connect('button_release_event', self.on_release),\n                ]\n            return True\n",
      "\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # After unpickling, canvas might be None but ref_artist.figure.canvas exists\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect callbacks if needed\n                if hasattr(self, 'cids') and not self.cids:\n                    self.cids = [\n                        self.canvas.mpl_connect('pick_event', self.on_pick),\n                        self.canvas.mpl_connect('button_release_event', self.on_release)\n                    ]\n            return True\n",
      "\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # If canvas is None (e.g., after unpickling), try to restore it\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect callbacks if canvas was restored\n                self.cids = [\n                    self.canvas.mpl_connect('pick_event', self.on_pick),\n                    self.canvas.mpl_connect('button_release_event', self.on_release),\n                ]\n            return True\n",
      "\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # If canvas is None (e.g., after unpickling), try to restore it\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect the press event if we have a valid canvas\n                if hasattr(self, 'cids') and len(self.cids) == 1:\n                    # Only reconnect if we haven't already reconnected\n                    pass\n                else:\n                    self.cids = [self.canvas.mpl_connect('button_press_event', self.on_pick)]\n            return True\n",
      "\n    def _check_still_parented(self):\n        if self.ref_artist.figure is None:\n            self.disconnect()\n            return False\n        else:\n            # Restore canvas reference if it was lost during unpickling\n            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n                self.canvas = self.ref_artist.figure.canvas\n                # Reconnect callbacks if needed\n                if hasattr(self, '_unpickled') and self._unpickled:\n                    self.cids = [\n                        self.canvas.mpl_connect('pick_event', self.on_pick),\n                        self.canvas.mpl_connect('button_release_event', self.on_release)\n                    ]\n                    self._unpickled = False\n            return True\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..7304cf364e 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,6 +1505,7 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n+\n         self.canvas = self.ref_artist.figure.canvas\n         self._use_blit = use_blit and self.canvas.supports_blit\n         self.cids = [\n@@ -1514,8 +1515,9 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+\n     def on_motion(self, evt):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             dx = evt.x - self.mouse_x\n             dy = evt.y - self.mouse_y\n             self.update_offset(dx, dy)\n@@ -1528,7 +1530,7 @@ class DraggableBase:\n                 self.canvas.draw()\n \n     def on_pick(self, evt):\n-        if self._check_still_parented() and evt.artist == self.ref_artist:\n+        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n             self.got_artist = True\n@@ -1545,7 +1547,7 @@ class DraggableBase:\n             self.save_offset()\n \n     def on_release(self, event):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             self.finalize_offset()\n             self.got_artist = False\n             self.canvas.mpl_disconnect(self._c1)\n@@ -1558,18 +1560,41 @@ class DraggableBase:\n             self.disconnect()\n             return False\n         else:\n+            # Restore canvas reference if it was lost during unpickling\n+            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if canvas is restored\n+                self.cids = [\n+                    self.canvas.callbacks._connect_picklable(\n+                        'pick_event', self.on_pick),\n+                    self.canvas.callbacks._connect_picklable(\n+                        'button_release_event', self.on_release),\n+                ]\n+            return True\n+            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if canvas is restored\n+                self.cids = [\n+                    self.canvas.callbacks._connect_picklable(\n+                        'pick_event', self.on_pick),\n+                    self.canvas.callbacks._connect_picklable(\n+                        'button_release_event', self.on_release),\n+                ]\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if self.canvas is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1605,34 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Exclude unpickleable canvas reference during serialization.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove the unpickleable canvas and callback IDs\n+        state['canvas'] = None\n+        state['cids'] = []\n+        if hasattr(self, '_c1'):\n+            state['_c1'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore canvas reference and callbacks after deserialization.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference from the ref_artist\n+        if self.ref_artist.figure is not None:\n+            self.canvas = self.ref_artist.figure.canvas\n+            if self.canvas is not None:\n+                # Reconnect the basic callbacks\n+                self.cids = [\n+                    self.canvas.callbacks._connect_picklable(\n+                        'pick_event', self.on_pick),\n+                    self.canvas.callbacks._connect_picklable(\n+                        'button_release_event', self.on_release),\n+                ]\n+        else:\n+            self.canvas = None\n+            self.cids = []\n+\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_0": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..c9e4f0f623 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,12 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+    def __init__(self, ref_artist, use_blit=False):\n+        self.ref_artist = ref_artist\n+        if not ref_artist.pickable():\n+            ref_artist.set_picker(True)\n+        self.got_artist = False\n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1507,15 +1513,24 @@ class DraggableBase:\n         self.got_artist = False\n         self.canvas = self.ref_artist.figure.canvas\n         self._use_blit = use_blit and self.canvas.supports_blit\n-        self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n-        ]\n+        self._setup_callbacks()\n+\n+    def _setup_callbacks(self):\n+        \"\"\"Setup canvas callbacks if canvas is available.\"\"\"\n+        if self.canvas is not None:\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+        else:\n+            self.cids = []\n \n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n+            if self.canvas is None:\n+                return\n             dx = evt.x - self.mouse_x\n             dy = evt.y - self.mouse_y\n             self.update_offset(dx, dy)\n@@ -1529,6 +1544,8 @@ class DraggableBase:\n \n     def on_pick(self, evt):\n         if self._check_still_parented() and evt.artist == self.ref_artist:\n+            if self.canvas is None:\n+                return\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n             self.got_artist = True\n@@ -1546,6 +1563,8 @@ class DraggableBase:\n \n     def on_release(self, event):\n         if self._check_still_parented() and self.got_artist:\n+            if self.canvas is None:\n+                return\n             self.finalize_offset()\n             self.got_artist = False\n             self.canvas.mpl_disconnect(self._c1)\n@@ -1558,18 +1577,39 @@ class DraggableBase:\n             self.disconnect()\n             return False\n         else:\n+            # Restore canvas connection if it was lost during unpickling\n+            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                self._use_blit = self._use_blit and self.canvas.supports_blit\n+                # Reconnect the main callbacks\n+                self.cids = [\n+                    self.canvas.callbacks._connect_picklable(\n+                        'pick_event', self.on_pick),\n+                    self.canvas.callbacks._connect_picklable(\n+                        'button_release_event', self.on_release),\n+                ]\n+            return True\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if canvas is available\n+                self.cids = [\n+                    self.canvas.mpl_connect('pick_event', self.on_pick),\n+                    self.canvas.mpl_connect('button_release_event', self.on_release),\n+                ]\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1620,31 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Return state for pickling, excluding unpickleable canvas and cids.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove the unpickleable canvas reference and callback IDs\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling and reinitialize canvas if available.\"\"\"\n+        self.__dict__.update(state)\n+        # Try to restore canvas from ref_artist if it has a valid figure\n+        if hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None:\n+            if hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reinitialize callback IDs as empty list\n+                self.cids = []\n+            else:\n+                self.canvas = None\n+                self.cids = []\n+        else:\n+            self.canvas = None\n+            self.cids = []\n+\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_1": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..d0b81f69f9 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,12 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+    def __init__(self, ref_artist, use_blit=False):\n+        self.ref_artist = ref_artist\n+        if not ref_artist.pickable():\n+            ref_artist.set_picker(True)\n+        self.got_artist = False\n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1507,69 +1513,97 @@ class DraggableBase:\n         self.got_artist = False\n         self.canvas = self.ref_artist.figure.canvas\n         self._use_blit = use_blit and self.canvas.supports_blit\n-        self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n-        ]\n-\n-    def on_motion(self, evt):\n-        if self._check_still_parented() and self.got_artist:\n-            dx = evt.x - self.mouse_x\n-            dy = evt.y - self.mouse_y\n-            self.update_offset(dx, dy)\n-            if self._use_blit:\n-                self.canvas.restore_region(self.background)\n-                self.ref_artist.draw(\n-                    self.ref_artist.figure._get_renderer())\n-                self.canvas.blit()\n-            else:\n-                self.canvas.draw()\n-\n-    def on_pick(self, evt):\n-        if self._check_still_parented() and evt.artist == self.ref_artist:\n-            self.mouse_x = evt.mouseevent.x\n-            self.mouse_y = evt.mouseevent.y\n-            self.got_artist = True\n-            if self._use_blit:\n-                self.ref_artist.set_animated(True)\n-                self.canvas.draw()\n-                self.background = \\\n-                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n-                self.ref_artist.draw(\n-                    self.ref_artist.figure._get_renderer())\n-                self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n-            self.save_offset()\n-\n-    def on_release(self, event):\n-        if self._check_still_parented() and self.got_artist:\n-            self.finalize_offset()\n-            self.got_artist = False\n-            self.canvas.mpl_disconnect(self._c1)\n-\n-            if self._use_blit:\n-                self.ref_artist.set_animated(False)\n-\n-    def _check_still_parented(self):\n-        if self.ref_artist.figure is None:\n-            self.disconnect()\n-            return False\n+        self.cids = []\n+        self._connect_callbacks()\n+    \n+    def _connect_callbacks(self):\n+        \"\"\"Connect canvas callbacks if canvas is available.\"\"\"\n+        if self.canvas is not None:\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+\n+def on_motion(self, evt):\n+    if self._check_still_parented() and self.got_artist and self.canvas is not None:\n+        dx = evt.x - self.mouse_x\n+        dy = evt.y - self.mouse_y\n+        self.update_offset(dx, dy)\n+        if self._use_blit:\n+            self.canvas.restore_region(self.background)\n+            self.ref_artist.draw(\n+                self.ref_artist.figure._get_renderer())\n+            self.canvas.blit()\n         else:\n+            self.canvas.draw()\n+\n+def on_pick(self, evt):\n+    if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n+        self.mouse_x = evt.mouseevent.x\n+        self.mouse_y = evt.mouseevent.y\n+        self.got_artist = True\n+        if self._use_blit:\n+            self.ref_artist.set_animated(True)\n+            self.canvas.draw()\n+            self.background = \\\n+                self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n+            self.ref_artist.draw(\n+                self.ref_artist.figure._get_renderer())\n+            self.canvas.blit()\n+        self._c1 = self.canvas.callbacks._connect_picklable(\n+            \"motion_notify_event\", self.on_motion)\n+        self.save_offset()\n+\n+def on_release(self, event):\n+    if self._check_still_parented() and self.got_artist and self.canvas is not None:\n+        self.finalize_offset()\n+        self.got_artist = False\n+        self.canvas.mpl_disconnect(self._c1)\n+\n+        if self._use_blit:\n+            self.ref_artist.set_animated(False)\n+\n+def _check_still_parented(self):\n+    if self.ref_artist.figure is None:\n+        self.disconnect()\n+        return False\n+    else:\n+        # Restore canvas connection after unpickling if needed\n+        if self.canvas is None and self.ref_artist.figure.canvas is not None:\n+            self.canvas = self.ref_artist.figure.canvas\n+            self._use_blit = self._use_blit and self.canvas.supports_blit\n+            # Reconnect the persistent callbacks\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+        return True\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if they were disconnected\n+                if hasattr(self, 'cids') and not self.cids:\n+                    self.cids = [\n+                        self.canvas.mpl_connect('pick_event', self.on_pick),\n+                        self.canvas.mpl_connect('button_release_event', self.on_release),\n+                    ]\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1614,23 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpickleable canvas reference.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpickleable canvas and callback IDs\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling and reconnect to canvas if available.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be restored when needed through _check_still_parented\n+        # or when the figure is next displayed\n+        self.canvas = None\n+        self.cids = []\n+\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_2": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..66ffd73401 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,12 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+    def __init__(self, ref_artist, use_blit=False):\n+        self.ref_artist = ref_artist\n+        if not ref_artist.pickable():\n+            ref_artist.set_picker(True)\n+        self.got_artist = False\n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1507,15 +1513,17 @@ class DraggableBase:\n         self.got_artist = False\n         self.canvas = self.ref_artist.figure.canvas\n         self._use_blit = use_blit and self.canvas.supports_blit\n-        self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n-        ]\n+        self.cids = []\n+        if self.canvas is not None:\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n \n     def on_motion(self, evt):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             dx = evt.x - self.mouse_x\n             dy = evt.y - self.mouse_y\n             self.update_offset(dx, dy)\n@@ -1528,7 +1536,7 @@ class DraggableBase:\n                 self.canvas.draw()\n \n     def on_pick(self, evt):\n-        if self._check_still_parented() and evt.artist == self.ref_artist:\n+        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n             self.got_artist = True\n@@ -1545,7 +1553,7 @@ class DraggableBase:\n             self.save_offset()\n \n     def on_release(self, event):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             self.finalize_offset()\n             self.got_artist = False\n             self.canvas.mpl_disconnect(self._c1)\n@@ -1558,18 +1566,38 @@ class DraggableBase:\n             self.disconnect()\n             return False\n         else:\n+            # Restore canvas if it was None (e.g., after unpickling)\n+            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                self._use_blit = self._use_blit and self.canvas.supports_blit\n+                # Reconnect callbacks if they were lost\n+                if not hasattr(self, 'cids') or not self.cids:\n+                    self.cids = [\n+                        self.canvas.callbacks._connect_picklable(\n+                            'pick_event', self.on_pick),\n+                        self.canvas.callbacks._connect_picklable(\n+                            'button_release_event', self.on_release),\n+                    ]\n+            return True\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if needed\n+                if hasattr(self, 'cids') and not self.cids:\n+                    self.connect()\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1608,27 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        # Exclude canvas and connection IDs from pickle state\n+        state = self.__dict__.copy()\n+        state['canvas'] = None\n+        state['cids'] = []\n+        if hasattr(self, '_c1'):\n+            state['_c1'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore state and canvas reference\n+        self.__dict__.update(state)\n+        if self.ref_artist and self.ref_artist.figure:\n+            self.canvas = self.ref_artist.figure.canvas\n+            if self.canvas is not None:\n+                # Reconnect callbacks\n+                self.cids = [\n+                    self.canvas.mpl_connect('motion_notify_event', self.on_motion),\n+                    self.canvas.mpl_connect('button_release_event', self.on_release),\n+                ]\n+\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_3": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..561baa7921 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,17 +1505,25 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n-        self.canvas = self.ref_artist.figure.canvas\n-        self._use_blit = use_blit and self.canvas.supports_blit\n-        self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n-        ]\n+\n+    def __init__(self, ref_artist, use_blit=False):\n+        self.ref_artist = ref_artist\n+        if not ref_artist.pickable():\n+            ref_artist.set_picker(True)\n+        self.got_artist = False\n+        self.canvas = self.ref_artist.figure.canvas if self.ref_artist.figure else None\n+        self._use_blit = use_blit and self.canvas and self.canvas.supports_blit\n+        self.cids = []\n+        if self.canvas is not None:\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n \n     def on_motion(self, evt):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             dx = evt.x - self.mouse_x\n             dy = evt.y - self.mouse_y\n             self.update_offset(dx, dy)\n@@ -1528,7 +1536,7 @@ class DraggableBase:\n                 self.canvas.draw()\n \n     def on_pick(self, evt):\n-        if self._check_still_parented() and evt.artist == self.ref_artist:\n+        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n             self.got_artist = True\n@@ -1545,7 +1553,7 @@ class DraggableBase:\n             self.save_offset()\n \n     def on_release(self, event):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             self.finalize_offset()\n             self.got_artist = False\n             self.canvas.mpl_disconnect(self._c1)\n@@ -1557,19 +1565,37 @@ class DraggableBase:\n         if self.ref_artist.figure is None:\n             self.disconnect()\n             return False\n-        else:\n+        elif self.canvas is None and self.ref_artist.figure.canvas is not None:\n+            # Restore canvas connection after unpickling\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+        return True\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if canvas is available\n+                self.cids = [\n+                    self.canvas.mpl_connect('pick_event', self.on_pick),\n+                    self.canvas.mpl_connect('button_release_event', self.on_release),\n+                ]\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1606,42 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Custom pickle state that excludes unpickleable canvas reference.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpickleable canvas and callback IDs\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Custom unpickle state that restores canvas reference if available.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference from ref_artist if available\n+        if hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None:\n+            canvas = self.ref_artist.figure.canvas\n+            if canvas is not None:\n+                self.canvas = canvas\n+                self.cids = []\n+                # Reconnect callbacks if canvas is available\n+                self._reconnect_callbacks()\n+            else:\n+                self.canvas = None\n+                self.cids = []\n+        else:\n+            self.canvas = None\n+            self.cids = []\n+\n+    def _reconnect_callbacks(self):\n+        \"\"\"Reconnect callbacks after unpickling if canvas is available.\"\"\"\n+        if self.canvas is not None and hasattr(self, 'cids'):\n+            # Clear existing callbacks\n+            self.cids.clear()\n+            # Reconnect the standard callbacks\n+            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n+            self.cids.append(self.canvas.mpl_connect(\"button_release_event\", self.on_release))\n+\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_4": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..17bdd0034c 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,16 +1505,26 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n-        self.canvas = self.ref_artist.figure.canvas\n-        self._use_blit = use_blit and self.canvas.supports_blit\n-        self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n-        ]\n+\n+    def __init__(self, ref_artist, use_blit=False):\n+        self.ref_artist = ref_artist\n+        if not ref_artist.pickable():\n+            ref_artist.set_picker(True)\n+        self.got_artist = False\n+        self.canvas = self.ref_artist.figure.canvas if self.ref_artist.figure else None\n+        self._use_blit = use_blit and self.canvas and self.canvas.supports_blit\n+        self.cids = []\n+        if self.canvas:\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n \n     def on_motion(self, evt):\n+        if self.canvas is None:\n+            return\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n             dy = evt.y - self.mouse_y\n@@ -1528,6 +1538,8 @@ class DraggableBase:\n                 self.canvas.draw()\n \n     def on_pick(self, evt):\n+        if self.canvas is None:\n+            return\n         if self._check_still_parented() and evt.artist == self.ref_artist:\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n@@ -1545,6 +1557,8 @@ class DraggableBase:\n             self.save_offset()\n \n     def on_release(self, event):\n+        if self.canvas is None:\n+            return\n         if self._check_still_parented() and self.got_artist:\n             self.finalize_offset()\n             self.got_artist = False\n@@ -1558,18 +1572,38 @@ class DraggableBase:\n             self.disconnect()\n             return False\n         else:\n+            # Restore canvas and callbacks if they were lost during unpickling\n+            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                self._use_blit = self._use_blit and self.canvas.supports_blit\n+                self.cids = [\n+                    self.canvas.callbacks._connect_picklable(\n+                        'pick_event', self.on_pick),\n+                    self.canvas.callbacks._connect_picklable(\n+                        'button_release_event', self.on_release),\n+                ]\n+            return True\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if canvas was restored\n+                self.cids = [\n+                    self.canvas.mpl_connect('pick_event', self.on_pick),\n+                    self.canvas.mpl_connect('button_release_event', self.on_release),\n+                ]\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1614,29 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpickleable canvas reference.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove canvas reference and callback IDs as they cannot be pickled\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling and reinitialize canvas reference.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference from ref_artist if available\n+        if hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None:\n+            canvas = getattr(self.ref_artist.figure, 'canvas', None)\n+            if canvas is not None:\n+                self.canvas = canvas\n+                # Reinitialize callbacks when canvas becomes available\n+                self.cids = [\n+                    self.canvas.mpl_connect('pick_event', self.on_pick),\n+                    self.canvas.mpl_connect('button_release_event', self.on_release),\n+                ]\n+\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_5": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..d789fd0d69 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,12 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+    def __init__(self, ref_artist, use_blit=False):\n+        self.ref_artist = ref_artist\n+        if not ref_artist.pickable():\n+            ref_artist.set_picker(True)\n+        self.got_artist = False\n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1507,15 +1513,22 @@ class DraggableBase:\n         self.got_artist = False\n         self.canvas = self.ref_artist.figure.canvas\n         self._use_blit = use_blit and self.canvas.supports_blit\n-        self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n-        ]\n+        self._reconnect_callbacks()\n+\n+    def _reconnect_callbacks(self):\n+        \"\"\"Connect or reconnect canvas callbacks.\"\"\"\n+        if self.canvas is not None:\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+        else:\n+            self.cids = []\n \n     def on_motion(self, evt):\n-        if self._check_still_parented() and self.got_artist:\n+        if self.canvas is not None and self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n             dy = evt.y - self.mouse_y\n             self.update_offset(dx, dy)\n@@ -1528,7 +1541,7 @@ class DraggableBase:\n                 self.canvas.draw()\n \n     def on_pick(self, evt):\n-        if self._check_still_parented() and evt.artist == self.ref_artist:\n+        if self.canvas is not None and self._check_still_parented() and evt.artist == self.ref_artist:\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n             self.got_artist = True\n@@ -1545,7 +1558,7 @@ class DraggableBase:\n             self.save_offset()\n \n     def on_release(self, event):\n-        if self._check_still_parented() and self.got_artist:\n+        if self.canvas is not None and self._check_still_parented() and self.got_artist:\n             self.finalize_offset()\n             self.got_artist = False\n             self.canvas.mpl_disconnect(self._c1)\n@@ -1558,18 +1571,38 @@ class DraggableBase:\n             self.disconnect()\n             return False\n         else:\n+            # Restore canvas connection if needed after unpickling\n+            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                self.cids = [\n+                    self.canvas.callbacks._connect_picklable(\n+                        'pick_event', self.on_pick),\n+                    self.canvas.callbacks._connect_picklable(\n+                        'button_release_event', self.on_release),\n+                ]\n             return True\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if needed\n+                if hasattr(self, 'cids') and not self.cids:\n+                    self.cids = [\n+                        self.canvas.mpl_connect('pick_event', self.on_pick),\n+                        self.canvas.mpl_connect('button_release_event', self.on_release)\n+                    ]\n+            return True\n+\n \n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1613,27 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Prepare state for pickling by excluding unpickleable canvas reference.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpickleable canvas and callback IDs\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state after unpickling and reconnect canvas if available.\"\"\"\n+        self.__dict__.update(state)\n+        # Try to restore canvas reference from ref_artist\n+        if hasattr(self.ref_artist, 'figure') and hasattr(self.ref_artist.figure, 'canvas'):\n+            canvas = self.ref_artist.figure.canvas\n+            if canvas is not None:\n+                self.canvas = canvas\n+                # Reinitialize callback IDs list\n+                self.cids = []\n+                # Note: Actual callback connections will be restored when needed\n+\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_6": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..e250a3c2b6 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,12 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+    def __init__(self, ref_artist, use_blit=False):\n+        self.ref_artist = ref_artist\n+        if not ref_artist.pickable():\n+            ref_artist.set_picker(True)\n+        self.got_artist = False\n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1507,15 +1513,21 @@ class DraggableBase:\n         self.got_artist = False\n         self.canvas = self.ref_artist.figure.canvas\n         self._use_blit = use_blit and self.canvas.supports_blit\n-        self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n-        ]\n+        self.cids = []\n+        self._connect_callbacks()\n+\n+    def _connect_callbacks(self):\n+        \"\"\"Connect callbacks if canvas is available.\"\"\"\n+        if self.canvas is not None:\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n \n     def on_motion(self, evt):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             dx = evt.x - self.mouse_x\n             dy = evt.y - self.mouse_y\n             self.update_offset(dx, dy)\n@@ -1528,7 +1540,7 @@ class DraggableBase:\n                 self.canvas.draw()\n \n     def on_pick(self, evt):\n-        if self._check_still_parented() and evt.artist == self.ref_artist:\n+        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n             self.got_artist = True\n@@ -1545,7 +1557,7 @@ class DraggableBase:\n             self.save_offset()\n \n     def on_release(self, event):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             self.finalize_offset()\n             self.got_artist = False\n             self.canvas.mpl_disconnect(self._c1)\n@@ -1558,18 +1570,39 @@ class DraggableBase:\n             self.disconnect()\n             return False\n         else:\n+            # Restore canvas reference if it was lost during unpickling\n+            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect main callbacks if they were disconnected\n+                if not hasattr(self, 'cids') or not self.cids:\n+                    self.cids = [\n+                        self.canvas.callbacks._connect_picklable(\n+                            'pick_event', self.on_pick),\n+                        self.canvas.callbacks._connect_picklable(\n+                            'button_release_event', self.on_release),\n+                    ]\n+            return True\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if canvas was restored\n+                self.cids = [\n+                    self.canvas.mpl_connect('pick_event', self.on_pick),\n+                    self.canvas.mpl_connect('button_release_event', self.on_release),\n+                ]\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1613,22 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpickleable canvas reference.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove the unpickleable canvas reference and callback IDs\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling and reinitialize canvas reference.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be restored when needed via _check_still_parented\n+        self.canvas = None\n+        self.cids = []\n+\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_7": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..90c165fa9a 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,17 +1505,25 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n-        self.canvas = self.ref_artist.figure.canvas\n-        self._use_blit = use_blit and self.canvas.supports_blit\n-        self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n-        ]\n+\n+    def __init__(self, ref_artist, use_blit=False):\n+        self.ref_artist = ref_artist\n+        if not ref_artist.pickable():\n+            ref_artist.set_picker(True)\n+        self.got_artist = False\n+        self.canvas = self.ref_artist.figure.canvas if self.ref_artist.figure else None\n+        self._use_blit = use_blit and self.canvas and self.canvas.supports_blit\n+        self.cids = []\n+        if self.canvas is not None:\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n \n     def on_motion(self, evt):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             dx = evt.x - self.mouse_x\n             dy = evt.y - self.mouse_y\n             self.update_offset(dx, dy)\n@@ -1528,7 +1536,7 @@ class DraggableBase:\n                 self.canvas.draw()\n \n     def on_pick(self, evt):\n-        if self._check_still_parented() and evt.artist == self.ref_artist:\n+        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n             self.got_artist = True\n@@ -1545,7 +1553,7 @@ class DraggableBase:\n             self.save_offset()\n \n     def on_release(self, event):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             self.finalize_offset()\n             self.got_artist = False\n             self.canvas.mpl_disconnect(self._c1)\n@@ -1558,18 +1566,39 @@ class DraggableBase:\n             self.disconnect()\n             return False\n         else:\n+            # Restore canvas connection if it was lost during unpickling\n+            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                self._use_blit = self._use_blit and self.canvas.supports_blit\n+                self.cids = [\n+                    self.canvas.callbacks._connect_picklable(\n+                        'pick_event', self.on_pick),\n+                    self.canvas.callbacks._connect_picklable(\n+                        'button_release_event', self.on_release),\n+                ]\n             return True\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect the press event if we have a valid canvas\n+                if hasattr(self, 'cids') and len(self.cids) == 1:\n+                    # Only reconnect if we haven't already reconnected\n+                    pass\n+                else:\n+                    self.cids = [self.canvas.mpl_connect('button_press_event', self.on_pick)]\n+            return True\n+\n \n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1609,35 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpickleable canvas reference.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpickleable canvas and callback IDs\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling and reinitialize canvas if available.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference if ref_artist has a valid figure\n+        if hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None:\n+            if hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reinitialize callbacks if canvas is available\n+                self.cids = []\n+                self.cids.append(self.canvas.mpl_connect('motion_notify_event', self.on_motion))\n+                self.cids.append(self.canvas.mpl_connect('button_release_event', self.on_release))\n+            else:\n+                self.canvas = None\n+        else:\n+            self.canvas = None\n+        \n+        # Ensure cids is initialized even if canvas is None\n+        if not hasattr(self, 'cids'):\n+            self.cids = []\n+\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_8": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..d0732c12e4 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,12 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+    def __init__(self, ref_artist, use_blit=False):\n+        self.ref_artist = ref_artist\n+        if not ref_artist.pickable():\n+            ref_artist.set_picker(True)\n+        self.got_artist = False\n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1507,15 +1513,17 @@ class DraggableBase:\n         self.got_artist = False\n         self.canvas = self.ref_artist.figure.canvas\n         self._use_blit = use_blit and self.canvas.supports_blit\n-        self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n-        ]\n+        self.cids = []\n+        if self.canvas is not None:\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n \n     def on_motion(self, evt):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             dx = evt.x - self.mouse_x\n             dy = evt.y - self.mouse_y\n             self.update_offset(dx, dy)\n@@ -1528,7 +1536,7 @@ class DraggableBase:\n                 self.canvas.draw()\n \n     def on_pick(self, evt):\n-        if self._check_still_parented() and evt.artist == self.ref_artist:\n+        if self._check_still_parented() and evt.artist == self.ref_artist and self.canvas is not None:\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n             self.got_artist = True\n@@ -1545,7 +1553,7 @@ class DraggableBase:\n             self.save_offset()\n \n     def on_release(self, event):\n-        if self._check_still_parented() and self.got_artist:\n+        if self._check_still_parented() and self.got_artist and self.canvas is not None:\n             self.finalize_offset()\n             self.got_artist = False\n             self.canvas.mpl_disconnect(self._c1)\n@@ -1558,18 +1566,41 @@ class DraggableBase:\n             self.disconnect()\n             return False\n         else:\n+            # Restore canvas if it's None but figure has a canvas\n+            if self.canvas is None and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if needed\n+                if not hasattr(self, 'cids') or not self.cids:\n+                    self.cids = [\n+                        self.canvas.callbacks._connect_picklable(\n+                            'pick_event', self.on_pick),\n+                        self.canvas.callbacks._connect_picklable(\n+                            'button_release_event', self.on_release),\n+                    ]\n             return True\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reconnect callbacks if needed\n+                if hasattr(self, '_unpickled') and self._unpickled:\n+                    self.cids = [\n+                        self.canvas.mpl_connect('pick_event', self.on_pick),\n+                        self.canvas.mpl_connect('button_release_event', self.on_release)\n+                    ]\n+                    self._unpickled = False\n+            return True\n+\n \n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n+            try:\n+                c1 = self._c1\n+            except AttributeError:\n+                pass\n+            else:\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1611,31 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpickleable canvas reference.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpickleable canvas and callback IDs\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object state after unpickling and reinitialize canvas if available.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference from ref_artist if available\n+        if hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None:\n+            if hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None:\n+                self.canvas = self.ref_artist.figure.canvas\n+                # Reinitialize callback IDs as empty list\n+                self.cids = []\n+            else:\n+                self.canvas = None\n+                self.cids = []\n+        else:\n+            self.canvas = None\n+            self.cids = []\n+\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n"
  }
}