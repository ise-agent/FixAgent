{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/builders/linkcheck.py lines 215-216)": "\ndef check() -> Tuple[str, str, int]:\n    # check for various conditions without bothering the network\n    if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n        return 'unchecked', '', 0\n    elif not uri.startswith(('http:', 'https:')):\n        # Validate local links instead of immediately returning 'local'\n        if uri.startswith('/'):\n            # Absolute path - check if file exists relative to source directory\n            local_path = path.join(self.app.srcdir, uri.lstrip('/'))\n            if path.exists(local_path) or path.exists(local_path + '.rst') or path.exists(local_path + '.md'):\n                return 'working', '', 0\n            else:\n                return 'broken', f'Local file not found: {uri}', 0\n        else:\n            # Relative path - check relative to current document\n            if docname:\n                doc_dir = path.dirname(self.app.env.doc2path(docname, base=None))\n                local_path = path.join(self.app.srcdir, doc_dir, uri)\n                local_path = path.normpath(local_path)\n                if path.exists(local_path) or path.exists(local_path + '.rst') or path.exists(local_path + '.md'):\n                    return 'working', '', 0\n            \n            # Check if it's a document reference\n            if '#' in uri:\n                doc_part, anchor = uri.split('#', 1)\n            else:\n                doc_part, anchor = uri, ''\n            \n            # Check if document exists in the project\n            if doc_part in self.app.env.found_docs or doc_part.replace('/', '.') in self.app.env.found_docs:\n                if anchor:\n                    # For now, assume anchors are valid if document exists\n                    # Full anchor validation would require parsing the target document\n                    return 'working', '', 0\n                else:\n                    return 'working', '', 0\n            else:\n                return 'broken', f'Local document not found: {uri}', 0\n    elif uri in self.good:\n        return 'working', 'old', 0\n    elif uri in self.broken:\n        return 'broken', self.broken[uri], 0\n    elif uri in self.redirected:\n        return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n    for rex in self.to_ignore:\n        if rex.match(uri):\n            return 'ignored', '', 0\n",
    "Location 2 (/root/hy/projects/sphinx/sphinx/builders/linkcheck.py lines 300-310)": "\n    def check(self, docname: str, uri: str, hyperlink_type: str) -> Tuple[str, str, int]:\n        # check for various conditions without bothering the network\n        if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'tel:')):\n            return 'unchecked', '', 0\n        elif not (uri.startswith('http:') or uri.startswith('https:')):\n            # Local link validation\n            if uri.startswith('file:'):\n                return 'local', '', 0  # Keep existing behavior for file: URIs\n            \n            # Check if it's an internal reference (anchor only)\n            if uri.startswith('#'):\n                return 'unchecked', '', 0\n            \n            # Parse potential anchor from local URI\n            if '#' in uri:\n                path_part, anchor = uri.split('#', 1)\n            else:\n                path_part, anchor = uri, None\n            \n            # Check if local document exists\n            if path_part:\n                # Resolve relative to current document\n                if not path_part.startswith('/'):\n                    # Relative path - resolve against current docname\n                    current_dir = path.dirname(docname)\n                    if current_dir:\n                        resolved_path = path.join(current_dir, path_part)\n                    else:\n                        resolved_path = path_part\n                else:\n                    # Absolute path within project\n                    resolved_path = path_part.lstrip('/')\n                \n                # Normalize path separators and remove extension for doc lookup\n                resolved_path = resolved_path.replace('\\\\', '/').replace('.html', '').replace('.rst', '')\n                \n                # Check if document exists in Sphinx environment\n                if resolved_path in self.env.found_docs:\n                    # Document exists, now check anchor if present\n                    if anchor:\n                        # For now, assume anchors are valid if document exists\n                        # Full anchor validation would require parsing the target document\n                        return 'working', '', 0\n                    return 'working', '', 0\n                else:\n                    # Check if it might be a static file\n                    static_path = path.join(self.env.srcdir, path_part)\n                    if path.exists(static_path):\n                        return 'working', '', 0\n                    \n                    return 'broken', 'local document or file not found', 0\n            else:\n                # Empty path with anchor only - treat as internal reference\n                return 'unchecked', '', 0\n        elif uri in self.config.linkcheck_ignore:\n            return 'ignored', '', 0\n        else:\n            return self.check_uri(uri, hyperlink_type)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/builders/linkcheck.py lines 215-216)": [
      "\n        def check() -> Tuple[str, str, int]:\n            # check for various conditions without bothering the network\n            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                return 'unchecked', '', 0\n            elif not uri.startswith(('http:', 'https:')):\n                # Validate local links instead of immediately returning 'local'\n                return self._check_local_link(uri, docname)\n            elif uri in self.good:\n                return 'working', 'old', 0\n            elif uri in self.broken:\n                return 'broken', self.broken[uri], 0\n            elif uri in self.redirected:\n                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n            for rex in self.to_ignore:\n                if rex.match(uri):\n                    return 'ignored', '', 0\n",
      "\ndef check() -> Tuple[str, str, int]:\n    # check for various conditions without bothering the network\n    if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n        return 'unchecked', '', 0\n    elif not uri.startswith(('http:', 'https:')):\n        # Local link validation\n        def validate_local_link(local_uri: str) -> Tuple[str, str, int]:\n            # Handle relative paths and anchors\n            if '#' in local_uri:\n                doc_path, anchor = local_uri.split('#', 1)\n            else:\n                doc_path, anchor = local_uri, None\n            \n            # Check if it's a document reference\n            if doc_path:\n                # Try to resolve as a document\n                try:\n                    # Check if document exists in the environment\n                    if doc_path in self.env.all_docs:\n                        if anchor:\n                            # TODO: Validate anchor exists in the document\n                            return 'working', '', 0\n                        return 'working', '', 0\n                    \n                    # Check for file extensions and resolve paths\n                    from os.path import exists, join, normpath\n                    \n                    # Try different possible paths\n                    possible_paths = []\n                    \n                    # Relative to current document\n                    if hasattr(self.env, 'temp_data') and 'docname' in self.env.temp_data:\n                        current_doc = self.env.temp_data['docname']\n                        doc_dir = path.dirname(self.env.doc2path(current_doc))\n                        possible_paths.append(normpath(join(doc_dir, doc_path)))\n                    \n                    # Relative to source directory\n                    possible_paths.append(normpath(join(self.env.srcdir, doc_path)))\n                    \n                    # Check if any of the possible paths exist\n                    for full_path in possible_paths:\n                        if exists(full_path):\n                            return 'working', '', 0\n                    \n                    return 'broken', 'local file not found', 0\n                    \n                except Exception:\n                    return 'broken', 'local link validation error', 0\n            else:\n                # Just an anchor reference\n                if anchor:\n                    # TODO: Validate anchor in current document\n                    return 'working', '', 0\n                return 'broken', 'empty local reference', 0\n        \n        return validate_local_link(uri)\n    elif uri in self.good:\n        return 'working', 'old', 0\n    elif uri in self.broken:\n        return 'broken', self.broken[uri], 0\n    elif uri in self.redirected:\n        return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n    for rex in self.to_ignore:\n        if rex.match(uri):\n            return 'ignored', '', 0\n",
      "\n            elif not uri.startswith(('http:', 'https:')):\n                # Validate local links instead of immediately returning 'local'\n                return self._check_local_link(uri, docname, lineno)\n",
      "\n            def check() -> Tuple[str, str, int]:\n                # check for various conditions without bothering the network\n                if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                    return 'unchecked', '', 0\n                elif not uri.startswith(('http:', 'https:')):\n                    # Validate local links instead of immediately returning 'local'\n                    return self._check_local_uri(uri, docname, lineno)\n                elif uri in self.good:\n                    return 'working', 'old', 0\n                elif uri in self.broken:\n                    return 'broken', self.broken[uri], 0\n                elif uri in self.redirected:\n                    return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n                for rex in self.to_ignore:\n                    if rex.match(uri):\n                        return 'ignored', '', 0\n",
      "\n        def check() -> Tuple[str, str, int]:\n            # check for various conditions without bothering the network\n            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                return 'unchecked', '', 0\n            elif not uri.startswith(('http:', 'https:')):\n                # Validate local links instead of immediately returning 'local'\n                return self._validate_local_link(uri, docname)\n            elif uri in self.good:\n                return 'working', 'old', 0\n            elif uri in self.broken:\n                return 'broken', self.broken[uri], 0\n            elif uri in self.redirected:\n                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n            for rex in self.to_ignore:\n                if rex.match(uri):\n                    return 'ignored', '', 0\n",
      "\n        def check() -> Tuple[str, str, int]:\n            # check for various conditions without bothering the network\n            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                return 'unchecked', '', 0\n            elif not uri.startswith(('http:', 'https:')):\n                # Validate local links instead of immediately returning 'local'\n                return self._check_local_link(uri, docname)\n            elif uri in self.good:\n                return 'working', 'old', 0\n            elif uri in self.broken:\n                return 'broken', self.broken[uri], 0\n            elif uri in self.redirected:\n                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n            for rex in self.to_ignore:\n                if rex.match(uri):\n                    return 'ignored', '', 0\n",
      "\n        def check() -> Tuple[str, str, int]:\n            # check for various conditions without bothering the network\n            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                return 'unchecked', '', 0\n            elif not uri.startswith(('http:', 'https:')):\n                # Validate local links instead of immediately returning 'local'\n                return self._check_local_link(uri, docname)\n            elif uri in self.good:\n                return 'working', 'old', 0\n            elif uri in self.broken:\n                return 'broken', self.broken[uri], 0\n            elif uri in self.redirected:\n                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n            for rex in self.to_ignore:\n                if rex.match(uri):\n                    return 'ignored', '', 0\n",
      "\n        def check() -> Tuple[str, str, int]:\n            # check for various conditions without bothering the network\n            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                return 'unchecked', '', 0\n            elif not uri.startswith(('http:', 'https:')):\n                # Validate local links instead of just marking as 'local'\n                return self._check_local_link(uri, docname)\n            elif uri in self.good:\n                return 'working', 'old', 0\n            elif uri in self.broken:\n                return 'broken', self.broken[uri], 0\n            elif uri in self.redirected:\n                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n            for rex in self.to_ignore:\n                if rex.match(uri):\n                    return 'ignored', '', 0\n"
    ],
    "Location 2 (/root/hy/projects/sphinx/sphinx/builders/linkcheck.py lines 300-310)": [
      "\ndef check(self, hyperlinks: Dict[str, Hyperlink]) -> Tuple[str, str, int]:\n    # check for various conditions without bothering the network\n    if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n        return 'unchecked', '', 0\n    elif not (self.uri.startswith(('http:', 'https:')) or self.uri.startswith('ftp:')):\n        # Local link validation\n        if self.uri.startswith('/'):\n            # Absolute path - check if file exists in source directory\n            file_path = path.join(self.app.srcdir, self.uri.lstrip('/'))\n            if path.exists(file_path):\n                return 'working', '', 0\n            else:\n                return 'broken', 'file not found', 404\n        else:\n            # Relative path or document reference\n            # Check if it's a document reference\n            docname = self.uri.split('#')[0] if '#' in self.uri else self.uri\n            \n            # Remove file extension if present\n            if docname.endswith(('.rst', '.md', '.txt')):\n                docname = docname.rsplit('.', 1)[0]\n            \n            # Check if document exists in the project\n            if docname in self.app.env.found_docs or docname == '':\n                # If there's an anchor, we could validate it too, but for now just mark as working\n                return 'working', '', 0\n            else:\n                # Check if it's a file path relative to current document\n                if hasattr(self, 'docname') and self.docname:\n                    current_dir = path.dirname(path.join(self.app.srcdir, self.docname))\n                    file_path = path.join(current_dir, self.uri.split('#')[0])\n                    if path.exists(file_path):\n                        return 'working', '', 0\n                \n                return 'broken', 'document or file not found', 404\n    elif self.uri in hyperlinks:\n        return 'working', '', 0\n",
      "\n    def check(self) -> Tuple[str, str, int]:\n        # check for various conditions without bothering the network\n        if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n            return 'unchecked', '', 0\n        elif not (self.uri.startswith('http:') or self.uri.startswith('https:')):\n            # Local link validation\n            if self.uri.startswith('file:'):\n                return 'local', '', 0\n            \n            # Check if it's a relative path or document reference\n            if '/' in self.uri or self.uri.endswith(('.rst', '.md', '.txt')):\n                # File path reference\n                if self.uri.startswith('/'):\n                    # Absolute path from source root\n                    full_path = path.join(self.app.srcdir, self.uri.lstrip('/'))\n                else:\n                    # Relative path from current document\n                    doc_dir = path.dirname(path.join(self.app.srcdir, self.docname))\n                    full_path = path.join(doc_dir, self.uri)\n                \n                if path.exists(full_path):\n                    return 'working', '', 0\n                else:\n                    return 'broken', 'file not found', 0\n            else:\n                # Document reference (possibly with anchor)\n                if '#' in self.uri:\n                    docref, anchor = self.uri.split('#', 1)\n                else:\n                    docref, anchor = self.uri, ''\n                \n                # Check if document exists in the project\n                if docref == '':\n                    # Same document anchor reference\n                    target_docname = self.docname\n                else:\n                    # Cross-document reference\n                    target_docname = docref\n                \n                # Normalize document name\n                if target_docname in self.app.env.found_docs:\n                    if anchor:\n                        # TODO: Validate anchor exists in target document\n                        # For now, assume anchor validation is working\n                        return 'working', '', 0\n                    else:\n                        return 'working', '', 0\n                else:\n                    return 'broken', 'document not found', 0\n        elif self.uri in self.app.config.linkcheck_ignore:\n            return 'ignored', '', 0\n        else:\n            # External link - proceed with network check\n            for rex in self.app.config.linkcheck_ignore_re:\n                if rex.match(self.uri):\n                    return 'ignored', '', 0\n\n            # need to actually check the URI\n            for _ in range(self.app.config.linkcheck_retries):\n                status, info, code = self.check_uri()\n                if status != \"broken\":\n                    break\n\n            return (status, info, code)\n",
      "\n    def check(self) -> Tuple[str, str, int]:\n        # check for various conditions without bothering the network\n        if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n            return 'unchecked', '', 0\n        elif not (self.uri.startswith('http:') or self.uri.startswith('https:')):\n            # Local link validation\n            return self._check_local_link()\n        elif self.uri in self.config.linkcheck_ignore:\n            return 'ignored', '', 0\n        elif self.auth:\n            return self._check_external_link()\n        else:\n            return self._check_external_link()\n\n    def _check_local_link(self) -> Tuple[str, str, int]:\n        \"\"\"Check if a local link is valid within the Sphinx project.\"\"\"\n        uri = self.uri\n        \n        # Handle anchors in local links\n        if '#' in uri:\n            uri, anchor = uri.split('#', 1)\n        else:\n            anchor = None\n            \n        # Empty URI after anchor split means current document\n        if not uri:\n            if anchor:\n                # Check if anchor exists in current document\n                if self._check_anchor_in_doc(self.docname, anchor):\n                    return 'working', '', 0\n                else:\n                    return 'broken', 'Anchor not found in current document', 0\n            return 'working', '', 0\n            \n        # Check if it's a document reference\n        if self._is_document_reference(uri):\n            target_docname = self._resolve_document_name(uri)\n            if target_docname in self.env.found_docs:\n                if anchor and not self._check_anchor_in_doc(target_docname, anchor):\n                    return 'broken', f'Anchor #{anchor} not found in document', 0\n                return 'working', '', 0\n            else:\n                return 'broken', 'Document not found', 0\n                \n        # Check if it's a file reference\n        if self._is_file_reference(uri):\n            file_path = self._resolve_file_path(uri)\n            if path.exists(file_path):\n                return 'working', '', 0\n            else:\n                return 'broken', 'File not found', 0\n                \n        # Default to broken for unrecognized local references\n        return 'broken', 'Local reference not found', 0\n        \n    def _is_document_reference(self, uri: str) -> bool:\n        \"\"\"Check if URI refers to a Sphinx document.\"\"\"\n        # Remove file extensions that Sphinx handles\n        for suffix in ['.html', '.htm']:\n            if uri.endswith(suffix):\n                return True\n        # Check if it's a document name without extension\n        return '.' not in uri or uri.endswith('.rst') or uri.endswith('.md')\n        \n    def _resolve_document_name(self, uri: str) -> str:\n        \"\"\"Resolve URI to document name.\"\"\"\n        # Remove HTML extensions\n        for suffix in ['.html', '.htm']:\n            if uri.endswith(suffix):\n                uri = uri[:-len(suffix)]\n                break\n                \n        # Handle relative paths\n        if uri.startswith('./'):\n            uri = uri[2:]\n        elif uri.startswith('../'):\n            # Handle relative navigation\n            docname_parts = self.docname.split('/')\n            uri_parts = uri.split('/')\n            \n            # Process .. components\n            result_parts = docname_parts[:-1]  # Remove current doc name\n            for part in uri_parts:\n                if part == '..':\n                    if result_parts:\n                        result_parts.pop()\n                elif part and part != '.':\n                    result_parts.append(part)\n                    \n            uri = '/'.join(result_parts)\n            \n        return uri\n        \n    def _is_file_reference(self, uri: str) -> bool:\n        \"\"\"Check if URI refers to a static file.\"\"\"\n        # Common file extensions\n        file_extensions = ['.png', '.jpg', '.jpeg', '.gif', '.svg', '.pdf', \n                          '.css', '.js', '.txt', '.zip', '.tar', '.gz']\n        return any(uri.lower().endswith(ext) for ext in file_extensions)\n        \n    def _resolve_file_path(self, uri: str) -> str:\n        \"\"\"Resolve URI to actual file path.\"\"\"\n        # Handle relative paths\n        if uri.startswith('./'):\n            uri = uri[2:]\n        elif uri.startswith('../'):\n            # Handle relative navigation from document directory\n            doc_dir = path.dirname(path.join(self.env.srcdir, self.docname))\n            return path.normpath(path.join(doc_dir, uri))\n            \n        # Check in source directory\n        src_path = path.join(self.env.srcdir, uri)\n        if path.exists(src_path):\n            return src_path\n            \n        # Check in static directories\n        for static_dir in getattr(self.config, 'html_static_path', []):\n            static_path = path.join(self.env.srcdir, static_dir, uri)\n            if path.exists(static_path):\n                return static_path\n                \n        return path.join(self.env.srcdir, uri)\n        \n    def _check_anchor_in_doc(self, docname: str, anchor: str) -> bool:\n        \"\"\"Check if anchor exists in the specified document.\"\"\"\n        try:\n            doctree = self.env.get_doctree(docname)\n            # Look for nodes with matching ids\n            for node in doctree.traverse():\n                if hasattr(node, 'attributes') and 'ids' in node.attributes:\n                    if anchor in node['ids']:\n                        return True\n                # Also check names attribute\n                if hasattr(node, 'attributes') and 'names' in node.attributes:\n                    if anchor in node['names']:\n                        return True\n            return False\n        except Exception:\n            # If we can't load the document, assume anchor doesn't exist\n            return False\n            \n    def _check_external_link(self) -> Tuple[str, str, int]:\n        \"\"\"Check external HTTP/HTTPS links.\"\"\"\n        # Original external link checking logic\n        req_url, delimiter, anchor = self.uri.partition('#')\n        for rex in self.anchors_ignore:\n            if rex.match(anchor):\n                anchor = None\n                break\n\n        # handle non-ASCII URIs\n        try:\n            req_url.encode('ascii')\n        except UnicodeError:\n            req_url = encode_uri(req_url)\n\n        # Get auth info\n        auth_info = self.auth\n        if auth_info:\n            auth_info = (unquote(auth_info[0]), unquote(auth_info[1]))\n\n        # update request headers for the URL\n        kwargs = {}\n        if auth_info:\n            kwargs['auth'] = auth_info\n        if self.config.linkcheck_request_headers:\n            for u in self.config.linkcheck_request_headers:\n                if u.match(req_url):\n                    headers = dict(DEFAULT_REQUEST_HEADERS)\n                    headers.update(self.config.linkcheck_request_headers[u])\n                    kwargs['headers'] = headers\n                    break\n            else:\n                kwargs['headers'] = dict(DEFAULT_REQUEST_HEADERS)\n        else:\n            kwargs['headers'] = dict(DEFAULT_REQUEST_HEADERS)\n        kwargs['config'] = self.config\n        kwargs['allow_redirects'] = True\n        kwargs['stream'] = True\n        try:\n            if anchor and self.config.linkcheck_anchors:\n                # Read the whole document and see if #anchor exists\n                # Disabled by default because it's slow\n                response = requests.get(req_url, **kwargs)\n                response.raise_for_status()\n                parser = AnchorCheckParser(unquote(anchor))\n                # Read file in chunks. If we find a matching anchor, we\n                # don't need to read the whole file.\n                for chunk in response.iter_content(chunk_size=4096, decode_unicode=True):\n                    if isinstance(chunk, bytes):    # requests failed to decode\n                        chunk = chunk.decode()       # fallback decoding\n                    parser.feed(chunk)\n                    if parser.found:\n                        break\n                parser.close()\n                if not parser.found:\n                    raise Exception(\"Anchor '%s' not found\" % anchor)\n            else:\n                try:\n                    # try a HEAD request first, which should be easier on\n                    # the server and the network\n                    response = requests.head(req_url, **kwargs)\n                    response.raise_for_status()\n                except (HTTPError, *QUEUE_POLL_EXCEPTIONS) as err:\n                    if isinstance(err, HTTPError) and err.response.status_code == 405:\n                        # retry with GET request if that fails, some servers\n                        # don't like HEAD requests.\n                        response = requests.get(req_url, **kwargs)\n                        response.raise_for_status()\n                    else:\n                        raise\n        except SSLError as err:\n            if is_ssl_error(err):\n                return 'ignored', str(err), 0\n            else:\n                return 'broken', str(err), 0\n        except (ConnectionError, TooManyRedirects) as err:\n            return 'broken', str(err), 0\n        except HTTPError as err:\n            if err.response.status_code == 401:\n                # We'll take \"Unauthorized\" as working.\n                return 'working', 'Unauthorized', 0\n            elif err.response.status_code == 403:\n                return 'broken', 'Forbidden', 0\n            elif err.response.status_code in (301, 302, 303, 307, 308):\n                return 'redirected', \\\n                       err.response.headers.get('location', 'with unknown location'), \\\n                       err.response.status_code\n            else:\n                return 'broken', str(err), 0\n        except Exception as err:\n            return 'broken', str(err), 0\n        else:\n            if response.url.rstrip('/') == req_url.rstrip('/'):\n                return 'working', '', 0\n            elif response.history:\n                # history contains any redirects, get last\n                code = response.history[-1].status_code\n                return 'redirected', response.url, code\n            else:\n                return 'redirected', response.url, 0\n",
      "\n    def check(self) -> Tuple[str, str, int]:\n        # check for various conditions without bothering the network\n        if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n            return 'unchecked', '', 0\n        elif not (self.uri.startswith(('http:', 'https:')) or self.uri.startswith(('ftp:', 'ftps:'))):\n            # Local link validation\n            return self._check_local_link()\n        elif self.uri in self.config.linkcheck_ignore:\n            return 'ignored', '', 0\n        elif self.config.linkcheck_anchors_ignore_for_url(self.uri):\n            self.anchor = None\n        \n        # rate limiting\n        with self.rqueue.get_request_rate_delay_time(self.uri) as delay_time:\n            if delay_time is not None:\n                self.wqueue.put(CheckRequest(self.next_check, self.hyperlink), False)\n                return 'rate-limited', '', delay_time\n\n        return self._check_uri()\n\n    def _check_local_link(self) -> Tuple[str, str, int]:\n        \"\"\"Check if a local link is valid within the Sphinx project.\"\"\"\n        uri = self.uri\n        \n        # Handle anchors in local links\n        if '#' in uri:\n            uri_part, anchor = uri.split('#', 1)\n            self.anchor = anchor\n        else:\n            uri_part = uri\n            \n        # Remove leading slash for relative paths\n        if uri_part.startswith('/'):\n            uri_part = uri_part[1:]\n            \n        # Check if it's a reference to another document\n        if uri_part:\n            # Try to resolve as a document reference\n            docname = uri_part\n            if docname.endswith('.html'):\n                docname = docname[:-5]  # Remove .html extension\n                \n            # Check if document exists in the environment\n            if docname in self.env.all_docs:\n                if self.anchor:\n                    # For now, assume anchor exists if document exists\n                    # Full anchor validation would require parsing the target document\n                    return 'working', '', 0\n                else:\n                    return 'working', '', 0\n            \n            # Check if it's a file that exists relative to source directory\n            from os.path import join, exists\n            full_path = join(self.env.srcdir, uri_part)\n            if exists(full_path):\n                return 'working', '', 0\n                \n        # If we have only an anchor (empty uri_part), check current document\n        elif self.anchor:\n            # This would be an anchor in the current document\n            # For now, assume it's valid - full validation would require parsing\n            return 'working', '', 0\n            \n        # Link doesn't resolve to anything\n        return 'broken', 'Local link not found', 404\n",
      "\n    def check(self) -> Tuple[str, str, int]:\n        # check for various conditions without actually checking the URL\n        if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n            return 'unchecked', '', 0\n\n        # Handle local links (non-http/https URIs)\n        if not self.uri.startswith(('http:', 'https:')):\n            # Parse the URI to extract path and anchor\n            if '#' in self.uri:\n                path_part, anchor = self.uri.split('#', 1)\n            else:\n                path_part, anchor = self.uri, None\n            \n            # Check if it's a document reference\n            if path_part:\n                # Remove leading slash and normalize path\n                clean_path = path_part.lstrip('/')\n                \n                # Check if it's a reference to another document\n                if clean_path:\n                    # Try to resolve as document reference\n                    docname = clean_path\n                    if docname.endswith('.html'):\n                        docname = docname[:-5]  # Remove .html extension\n                    \n                    # Check if document exists in the project\n                    if docname in self.env.all_docs:\n                        # If anchor specified, we'd need to validate it exists in target doc\n                        # For now, assume document reference is valid\n                        return 'working', '', 0\n                    else:\n                        # Check if it's a file path relative to source directory\n                        source_dir = self.env.srcdir\n                        full_path = path.join(source_dir, clean_path)\n                        if path.exists(full_path):\n                            return 'working', '', 0\n                        else:\n                            return 'broken', 'local file or document not found', 0\n                else:\n                    # Empty path with anchor - check anchor in current document\n                    if anchor:\n                        # For same-document anchors, assume valid for now\n                        # Could be enhanced to validate anchor exists\n                        return 'working', '', 0\n                    else:\n                        return 'broken', 'empty local reference', 0\n            else:\n                # Only anchor, no path - same document reference\n                return 'working', '', 0\n\n        # Continue with existing external URL validation\n        for rex in self.anchors_ignore:\n            if rex.match(self.uri):\n                return 'unchecked', '', 0\n",
      "\n    def check(self, docname: str, uri: str, node: Node) -> Tuple[str, str, int]:\n        # check for various conditions without bothering the network\n        if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'tel:')):\n            return 'unchecked', '', 0\n        elif not uri.startswith(('http:', 'https:')):\n            # Local link validation\n            if uri.startswith('/'):\n                # Absolute path - check if file exists relative to source directory\n                local_path = path.join(self.srcdir, uri.lstrip('/'))\n                if path.exists(local_path):\n                    return 'working', '', 0\n                else:\n                    return 'broken', 'file not found', 0\n            else:\n                # Relative link - check if target document or file exists\n                if '#' in uri:\n                    base_uri, anchor = uri.split('#', 1)\n                else:\n                    base_uri, anchor = uri, ''\n                \n                # Check if it's a document reference\n                if base_uri:\n                    # Try to resolve as a document\n                    current_dir = path.dirname(docname)\n                    if current_dir:\n                        target_doc = path.join(current_dir, base_uri)\n                    else:\n                        target_doc = base_uri\n                    \n                    # Remove file extension if present and normalize\n                    target_doc = re.sub(r'\\.(rst|md|txt)$', '', target_doc)\n                    target_doc = target_doc.replace('\\\\', '/')\n                    \n                    if target_doc in self.env.found_docs:\n                        # Document exists, check anchor if present\n                        if anchor:\n                            # For now, assume anchor exists - full anchor validation would require more complex logic\n                            return 'working', '', 0\n                        return 'working', '', 0\n                    else:\n                        # Check if it's a static file\n                        current_doc_dir = path.dirname(path.join(self.srcdir, docname))\n                        static_file_path = path.join(current_doc_dir, base_uri)\n                        if path.exists(static_file_path):\n                            return 'working', '', 0\n                        else:\n                            return 'broken', 'document or file not found', 0\n                else:\n                    # Just an anchor reference to current document\n                    return 'working', '', 0\n        \n        # Continue with existing external link validation\n        for rex in self.anchors_ignore:\n            if rex.match(uri):\n                return 'unchecked', '', 0\n        \n        # split off anchor\n        if '#' in uri:\n            req_url, anchor = uri.split('#', 1)\n            for rex in self.anchors_ignore:\n                if rex.match(anchor):\n                    anchor = None\n                    break\n        else:\n            req_url = uri\n            anchor = None\n\n        # handle non-ASCII URIs\n        try:\n            req_url.encode('ascii')\n        except UnicodeError:\n            req_url = encode_uri(req_url)\n\n        # Get auth info\n        for pattern, auth_info in self.auth:  # type: ignore\n            if pattern.match(uri):\n                break\n        else:\n            auth_info = None\n\n        # update request headers for the URL\n        kwargs = {}\n        if self.config.linkcheck_request_headers:\n            for pattern in self.config.linkcheck_request_headers:\n                if pattern.match(req_url):\n                    headers = dict(DEFAULT_REQUEST_HEADERS)\n                    headers.update(self.config.linkcheck_request_headers[pattern])\n                    kwargs['headers'] = headers\n                    break\n        else:\n            kwargs['headers'] = dict(DEFAULT_REQUEST_HEADERS)\n\n        # Robots.txt validation\n        if self.check_anchors and self.config.linkcheck_anchors_ignore_for_url:\n            for pattern in self.config.linkcheck_anchors_ignore_for_url:\n                if pattern.match(uri):\n                    anchor = None\n                    break\n\n        # Read the whole document and see if #anchor exists\n        status, info, code = self._check_uri(req_url, anchor, **kwargs)\n        if status == 'broken' and anchor and self.config.linkcheck_anchors:\n            # Check if the anchor exists by fetching the page\n            logger.info(__('(checking link anchor...)'))\n            status, info, code = self._check_uri(req_url, None, **kwargs)\n            if status == 'working':\n                status, info, code = self._check_anchor(req_url, anchor, **kwargs)\n\n        return status, info, code\n",
      "\n    def check(self) -> Tuple[str, str, int]:\n        # check for various conditions without bothering the network\n        if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n            return 'unchecked', '', 0\n        elif not (self.uri.startswith(('http:', 'https:')) or self.uri.startswith('/')):\n            # Local link validation\n            return self._check_local_link()\n        elif self.uri in self.config.linkcheck_ignore:\n            return 'ignored', '', 0\n        else:\n            # External link validation\n            return self._check_external_link()\n\n    def _check_local_link(self) -> Tuple[str, str, int]:\n        \"\"\"Validate local links against Sphinx project structure.\"\"\"\n        uri = self.uri\n        \n        # Handle anchor-only links\n        if uri.startswith('#'):\n            # Check if anchor exists in current document\n            if self._check_anchor_in_document(uri[1:], self.docname):\n                return 'working', '', 0\n            else:\n                return 'broken', 'Anchor not found in document', 0\n        \n        # Parse potential anchor\n        if '#' in uri:\n            path_part, anchor = uri.split('#', 1)\n        else:\n            path_part, anchor = uri, None\n        \n        # Check if it's a document reference\n        if self._is_document_reference(path_part):\n            target_doc = self._resolve_document_reference(path_part)\n            if target_doc and target_doc in self.env.found_docs:\n                if anchor and not self._check_anchor_in_document(anchor, target_doc):\n                    return 'broken', f'Anchor #{anchor} not found in document', 0\n                return 'working', '', 0\n            else:\n                return 'broken', 'Document not found', 0\n        \n        # Check if it's a file reference\n        if self._is_file_reference(path_part):\n            if self._check_file_exists(path_part):\n                return 'working', '', 0\n            else:\n                return 'broken', 'File not found', 0\n        \n        # Default to broken if we can't identify the reference type\n        return 'broken', 'Local reference not found', 0\n    \n    def _is_document_reference(self, path: str) -> bool:\n        \"\"\"Check if path appears to be a document reference.\"\"\"\n        # Remove leading/trailing slashes and file extensions\n        clean_path = path.strip('/').replace('.html', '').replace('.rst', '')\n        return bool(clean_path) and not path.startswith(('_static/', '_images/'))\n    \n    def _resolve_document_reference(self, path: str) -> str:\n        \"\"\"Resolve document reference to docname.\"\"\"\n        clean_path = path.strip('/').replace('.html', '').replace('.rst', '')\n        \n        # Try exact match first\n        if clean_path in self.env.found_docs:\n            return clean_path\n        \n        # Try with current document's directory\n        if '/' in self.docname:\n            doc_dir = '/'.join(self.docname.split('/')[:-1])\n            candidate = f\"{doc_dir}/{clean_path}\"\n            if candidate in self.env.found_docs:\n                return candidate\n        \n        # Try relative to source directory\n        from os.path import normpath\n        normalized = normpath(clean_path).replace('\\\\', '/')\n        if normalized in self.env.found_docs:\n            return normalized\n            \n        return clean_path\n    \n    def _is_file_reference(self, path: str) -> bool:\n        \"\"\"Check if path appears to be a static file reference.\"\"\"\n        return path.startswith(('_static/', '_images/')) or '.' in path.split('/')[-1]\n    \n    def _check_file_exists(self, path: str) -> bool:\n        \"\"\"Check if static file exists in the project.\"\"\"\n        from os.path import exists, join\n        \n        # Check in source directory\n        source_path = join(self.env.srcdir, path.lstrip('/'))\n        if exists(source_path):\n            return True\n        \n        # Check in build directory for generated files\n        if hasattr(self.env.app, 'outdir'):\n            build_path = join(self.env.app.outdir, path.lstrip('/'))\n            if exists(build_path):\n                return True\n        \n        return False\n    \n    def _check_anchor_in_document(self, anchor: str, docname: str) -> bool:\n        \"\"\"Check if anchor exists in specified document.\"\"\"\n        if not anchor or docname not in self.env.found_docs:\n            return False\n        \n        # Get document's title and section IDs if available\n        doctree = self.env.get_doctree(docname)\n        \n        # Check for section titles and explicit IDs\n        for node in doctree.traverse():\n            # Check explicit IDs\n            if hasattr(node, 'attributes') and 'ids' in node.attributes:\n                if anchor in node.attributes['ids']:\n                    return True\n            \n            # Check section titles converted to anchors\n            if hasattr(node, 'astext') and hasattr(node, 'tagname'):\n                if node.tagname in ('title', 'section'):\n                    # Convert title to anchor format (simplified)\n                    title_anchor = re.sub(r'[^\\w\\s-]', '', node.astext().strip())\n                    title_anchor = re.sub(r'[-\\s]+', '-', title_anchor).lower()\n                    if title_anchor == anchor.lower():\n                        return True\n        \n        return False\n\n    def _check_external_link(self) -> Tuple[str, str, int]:\n        \"\"\"Check external HTTP/HTTPS links.\"\"\"\n        # existing external link checking logic would go here\n        # This is a placeholder for the current external checking code\n        return self.check_uri()\n",
      "\n        # handle non-HTTP URIs\n        if not uri.lower().startswith(('http:', 'https:')):\n            # Local link validation\n            if uri.startswith('#'):\n                # Fragment-only link (same document)\n                return 'working', '', 0\n            elif uri.startswith('mailto:') or uri.startswith('ftp:') or '://' in uri:\n                # Other protocols - skip validation\n                return 'local', '', 0\n            else:\n                # Local file/document reference - validate it\n                # Remove any fragment identifier\n                local_uri = uri.split('#')[0] if '#' in uri else uri\n                \n                # Check if it's a document reference\n                if local_uri.endswith(('.rst', '.md', '.txt')) or '.' not in local_uri:\n                    # Document reference - check if document exists\n                    docname = local_uri.rstrip('/').replace('/', path.sep)\n                    if docname.endswith(('.rst', '.md', '.txt')):\n                        docname = docname.rsplit('.', 1)[0]\n                    \n                    if docname in self.env.found_docs or docname in self.env.all_docs:\n                        return 'working', '', 0\n                    else:\n                        return 'broken', 'document not found', 0\n                else:\n                    # File reference - check if file exists relative to source directory\n                    file_path = path.join(self.env.srcdir, local_uri)\n                    if path.exists(file_path):\n                        return 'working', '', 0\n                    else:\n                        return 'broken', 'file not found', 0\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..f3b6f7e2c 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -212,8 +212,38 @@ class CheckExternalLinksBuilder(Builder):\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n+\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # Validate local links instead of immediately returning 'local'\n+                # Check if it's a document reference or file path\n+                if uri.startswith('/'):\n+                    # Absolute path - check if file exists relative to source directory\n+                    local_path = path.join(self.env.srcdir, uri.lstrip('/'))\n+                    if path.exists(local_path):\n+                        return 'working', '', 0\n+                    else:\n+                        return 'broken', 'Local file not found: %s' % uri, 0\n+                elif '#' in uri:\n+                    # Check for document reference with anchor\n+                    doc_part, anchor = uri.split('#', 1)\n+                    if doc_part == '':\n+                        # Same document anchor - assume valid for now\n+                        return 'working', '', 0\n+                    elif doc_part in self.env.all_docs:\n+                        return 'working', '', 0\n+                    else:\n+                        return 'broken', 'Document not found: %s' % doc_part, 0\n+                elif uri in self.env.all_docs:\n+                    # Direct document reference\n+                    return 'working', '', 0\n+                else:\n+                    # Check if it's a file path relative to current document\n+                    current_docdir = path.dirname(self.env.doc2path(docname))\n+                    local_path = path.join(current_docdir, uri)\n+                    if path.exists(local_path):\n+                        return 'working', '', 0\n+                    else:\n+                        return 'broken', 'Local reference not found: %s' % uri, 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n@@ -297,6 +327,7 @@ class CheckExternalLinksBuilder(Builder):\n             logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n             self.write_entry('redirected ' + text, docname, filename,\n                              lineno, uri + ' to ' + info)\n+\n             self.write_linkstat(linkstat)\n \n     def get_target_uri(self, docname: str, typ: str = None) -> str:\n@@ -307,7 +338,6 @@ class CheckExternalLinksBuilder(Builder):\n \n     def prepare_writing(self, docnames: Set[str]) -> None:\n         return\n-\n     def write_doc(self, docname: str, doctree: Node) -> None:\n         logger.info('')\n         n = 0\n",
    "variant_0": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..a7b1d45d3 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -212,8 +212,54 @@ class CheckExternalLinksBuilder(Builder):\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n-            elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+\n+def check() -> Tuple[str, str, int]:\n+    # check for various conditions without bothering the network\n+    if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n+        return 'unchecked', '', 0\n+    elif not uri.startswith(('http:', 'https:')):\n+        # Validate local links instead of immediately returning 'local'\n+        if uri.startswith('/'):\n+            # Absolute path - check if file exists relative to source directory\n+            local_path = path.join(self.app.srcdir, uri.lstrip('/'))\n+            if path.exists(local_path) or path.exists(local_path + '.rst') or path.exists(local_path + '.md'):\n+                return 'working', '', 0\n+            else:\n+                return 'broken', f'Local file not found: {uri}', 0\n+        else:\n+            # Relative path - check relative to current document\n+            if docname:\n+                doc_dir = path.dirname(self.app.env.doc2path(docname, base=None))\n+                local_path = path.join(self.app.srcdir, doc_dir, uri)\n+                local_path = path.normpath(local_path)\n+                if path.exists(local_path) or path.exists(local_path + '.rst') or path.exists(local_path + '.md'):\n+                    return 'working', '', 0\n+            \n+            # Check if it's a document reference\n+            if '#' in uri:\n+                doc_part, anchor = uri.split('#', 1)\n+            else:\n+                doc_part, anchor = uri, ''\n+            \n+            # Check if document exists in the project\n+            if doc_part in self.app.env.found_docs or doc_part.replace('/', '.') in self.app.env.found_docs:\n+                if anchor:\n+                    # For now, assume anchors are valid if document exists\n+                    # Full anchor validation would require parsing the target document\n+                    return 'working', '', 0\n+                else:\n+                    return 'working', '', 0\n+            else:\n+                return 'broken', f'Local document not found: {uri}', 0\n+    elif uri in self.good:\n+        return 'working', 'old', 0\n+    elif uri in self.broken:\n+        return 'broken', self.broken[uri], 0\n+    elif uri in self.redirected:\n+        return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n+    for rex in self.to_ignore:\n+        if rex.match(uri):\n+            return 'ignored', '', 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n@@ -297,17 +343,65 @@ class CheckExternalLinksBuilder(Builder):\n             logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n             self.write_entry('redirected ' + text, docname, filename,\n                              lineno, uri + ' to ' + info)\n-            self.write_linkstat(linkstat)\n-\n-    def get_target_uri(self, docname: str, typ: str = None) -> str:\n-        return ''\n-\n-    def get_outdated_docs(self) -> Set[str]:\n-        return self.env.found_docs\n-\n-    def prepare_writing(self, docnames: Set[str]) -> None:\n-        return\n \n+    def check(self, docname: str, uri: str, hyperlink_type: str) -> Tuple[str, str, int]:\n+        # check for various conditions without bothering the network\n+        if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'tel:')):\n+            return 'unchecked', '', 0\n+        elif not (uri.startswith('http:') or uri.startswith('https:')):\n+            # Local link validation\n+            if uri.startswith('file:'):\n+                return 'local', '', 0  # Keep existing behavior for file: URIs\n+            \n+            # Check if it's an internal reference (anchor only)\n+            if uri.startswith('#'):\n+                return 'unchecked', '', 0\n+            \n+            # Parse potential anchor from local URI\n+            if '#' in uri:\n+                path_part, anchor = uri.split('#', 1)\n+            else:\n+                path_part, anchor = uri, None\n+            \n+            # Check if local document exists\n+            if path_part:\n+                # Resolve relative to current document\n+                if not path_part.startswith('/'):\n+                    # Relative path - resolve against current docname\n+                    current_dir = path.dirname(docname)\n+                    if current_dir:\n+                        resolved_path = path.join(current_dir, path_part)\n+                    else:\n+                        resolved_path = path_part\n+                else:\n+                    # Absolute path within project\n+                    resolved_path = path_part.lstrip('/')\n+                \n+                # Normalize path separators and remove extension for doc lookup\n+                resolved_path = resolved_path.replace('\\\\', '/').replace('.html', '').replace('.rst', '')\n+                \n+                # Check if document exists in Sphinx environment\n+                if resolved_path in self.env.found_docs:\n+                    # Document exists, now check anchor if present\n+                    if anchor:\n+                        # For now, assume anchors are valid if document exists\n+                        # Full anchor validation would require parsing the target document\n+                        return 'working', '', 0\n+                    return 'working', '', 0\n+                else:\n+                    # Check if it might be a static file\n+                    static_path = path.join(self.env.srcdir, path_part)\n+                    if path.exists(static_path):\n+                        return 'working', '', 0\n+                    \n+                    return 'broken', 'local document or file not found', 0\n+            else:\n+                # Empty path with anchor only - treat as internal reference\n+                return 'unchecked', '', 0\n+        elif uri in self.config.linkcheck_ignore:\n+            return 'ignored', '', 0\n+        else:\n+            return self.check_uri(uri, hyperlink_type)\n     def write_doc(self, docname: str, doctree: Node) -> None:\n         logger.info('')\n         n = 0\n",
    "variant_1": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..90896182d 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -208,12 +208,27 @@ class CheckExternalLinksBuilder(Builder):\n                 else:\n                     return 'redirected', new_url, 0\n \n+        def check() -> Tuple[str, str, int]:\n+            # check for various conditions without bothering the network\n+            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n+                return 'unchecked', '', 0\n+\n         def check() -> Tuple[str, str, int]:\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # Validate local links instead of immediately returning 'local'\n+                return self._check_local_link(uri, docname)\n+            elif uri in self.good:\n+                return 'working', 'old', 0\n+            elif uri in self.broken:\n+                return 'broken', self.broken[uri], 0\n+            elif uri in self.redirected:\n+                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n+            for rex in self.to_ignore:\n+                if rex.match(uri):\n+                    return 'ignored', '', 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n@@ -297,17 +312,44 @@ class CheckExternalLinksBuilder(Builder):\n             logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n             self.write_entry('redirected ' + text, docname, filename,\n                              lineno, uri + ' to ' + info)\n-            self.write_linkstat(linkstat)\n-\n-    def get_target_uri(self, docname: str, typ: str = None) -> str:\n-        return ''\n-\n-    def get_outdated_docs(self) -> Set[str]:\n-        return self.env.found_docs\n-\n-    def prepare_writing(self, docnames: Set[str]) -> None:\n-        return\n \n+def check(self, hyperlinks: Dict[str, Hyperlink]) -> Tuple[str, str, int]:\n+    # check for various conditions without bothering the network\n+    if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n+        return 'unchecked', '', 0\n+    elif not (self.uri.startswith(('http:', 'https:')) or self.uri.startswith('ftp:')):\n+        # Local link validation\n+        if self.uri.startswith('/'):\n+            # Absolute path - check if file exists in source directory\n+            file_path = path.join(self.app.srcdir, self.uri.lstrip('/'))\n+            if path.exists(file_path):\n+                return 'working', '', 0\n+            else:\n+                return 'broken', 'file not found', 404\n+        else:\n+            # Relative path or document reference\n+            # Check if it's a document reference\n+            docname = self.uri.split('#')[0] if '#' in self.uri else self.uri\n+            \n+            # Remove file extension if present\n+            if docname.endswith(('.rst', '.md', '.txt')):\n+                docname = docname.rsplit('.', 1)[0]\n+            \n+            # Check if document exists in the project\n+            if docname in self.app.env.found_docs or docname == '':\n+                # If there's an anchor, we could validate it too, but for now just mark as working\n+                return 'working', '', 0\n+            else:\n+                # Check if it's a file path relative to current document\n+                if hasattr(self, 'docname') and self.docname:\n+                    current_dir = path.dirname(path.join(self.app.srcdir, self.docname))\n+                    file_path = path.join(current_dir, self.uri.split('#')[0])\n+                    if path.exists(file_path):\n+                        return 'working', '', 0\n+                \n+                return 'broken', 'document or file not found', 404\n+    elif self.uri in hyperlinks:\n+        return 'working', '', 0\n     def write_doc(self, docname: str, doctree: Node) -> None:\n         logger.info('')\n         n = 0\n",
    "variant_2": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..a0fa0212b 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -212,8 +212,72 @@ class CheckExternalLinksBuilder(Builder):\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n-            elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+\n+def check() -> Tuple[str, str, int]:\n+    # check for various conditions without bothering the network\n+    if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n+        return 'unchecked', '', 0\n+    elif not uri.startswith(('http:', 'https:')):\n+        # Local link validation\n+        def validate_local_link(local_uri: str) -> Tuple[str, str, int]:\n+            # Handle relative paths and anchors\n+            if '#' in local_uri:\n+                doc_path, anchor = local_uri.split('#', 1)\n+            else:\n+                doc_path, anchor = local_uri, None\n+            \n+            # Check if it's a document reference\n+            if doc_path:\n+                # Try to resolve as a document\n+                try:\n+                    # Check if document exists in the environment\n+                    if doc_path in self.env.all_docs:\n+                        if anchor:\n+                            # TODO: Validate anchor exists in the document\n+                            return 'working', '', 0\n+                        return 'working', '', 0\n+                    \n+                    # Check for file extensions and resolve paths\n+                    from os.path import exists, join, normpath\n+                    \n+                    # Try different possible paths\n+                    possible_paths = []\n+                    \n+                    # Relative to current document\n+                    if hasattr(self.env, 'temp_data') and 'docname' in self.env.temp_data:\n+                        current_doc = self.env.temp_data['docname']\n+                        doc_dir = path.dirname(self.env.doc2path(current_doc))\n+                        possible_paths.append(normpath(join(doc_dir, doc_path)))\n+                    \n+                    # Relative to source directory\n+                    possible_paths.append(normpath(join(self.env.srcdir, doc_path)))\n+                    \n+                    # Check if any of the possible paths exist\n+                    for full_path in possible_paths:\n+                        if exists(full_path):\n+                            return 'working', '', 0\n+                    \n+                    return 'broken', 'local file not found', 0\n+                    \n+                except Exception:\n+                    return 'broken', 'local link validation error', 0\n+            else:\n+                # Just an anchor reference\n+                if anchor:\n+                    # TODO: Validate anchor in current document\n+                    return 'working', '', 0\n+                return 'broken', 'empty local reference', 0\n+        \n+        return validate_local_link(uri)\n+    elif uri in self.good:\n+        return 'working', 'old', 0\n+    elif uri in self.broken:\n+        return 'broken', self.broken[uri], 0\n+    elif uri in self.redirected:\n+        return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n+    for rex in self.to_ignore:\n+        if rex.match(uri):\n+            return 'ignored', '', 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n@@ -297,17 +361,71 @@ class CheckExternalLinksBuilder(Builder):\n             logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n             self.write_entry('redirected ' + text, docname, filename,\n                              lineno, uri + ' to ' + info)\n-            self.write_linkstat(linkstat)\n-\n-    def get_target_uri(self, docname: str, typ: str = None) -> str:\n-        return ''\n \n-    def get_outdated_docs(self) -> Set[str]:\n-        return self.env.found_docs\n+    def check(self) -> Tuple[str, str, int]:\n+        # check for various conditions without bothering the network\n+        if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n+            return 'unchecked', '', 0\n+        elif not (self.uri.startswith('http:') or self.uri.startswith('https:')):\n+            # Local link validation\n+            if self.uri.startswith('file:'):\n+                return 'local', '', 0\n+            \n+            # Check if it's a relative path or document reference\n+            if '/' in self.uri or self.uri.endswith(('.rst', '.md', '.txt')):\n+                # File path reference\n+                if self.uri.startswith('/'):\n+                    # Absolute path from source root\n+                    full_path = path.join(self.app.srcdir, self.uri.lstrip('/'))\n+                else:\n+                    # Relative path from current document\n+                    doc_dir = path.dirname(path.join(self.app.srcdir, self.docname))\n+                    full_path = path.join(doc_dir, self.uri)\n+                \n+                if path.exists(full_path):\n+                    return 'working', '', 0\n+                else:\n+                    return 'broken', 'file not found', 0\n+            else:\n+                # Document reference (possibly with anchor)\n+                if '#' in self.uri:\n+                    docref, anchor = self.uri.split('#', 1)\n+                else:\n+                    docref, anchor = self.uri, ''\n+                \n+                # Check if document exists in the project\n+                if docref == '':\n+                    # Same document anchor reference\n+                    target_docname = self.docname\n+                else:\n+                    # Cross-document reference\n+                    target_docname = docref\n+                \n+                # Normalize document name\n+                if target_docname in self.app.env.found_docs:\n+                    if anchor:\n+                        # TODO: Validate anchor exists in target document\n+                        # For now, assume anchor validation is working\n+                        return 'working', '', 0\n+                    else:\n+                        return 'working', '', 0\n+                else:\n+                    return 'broken', 'document not found', 0\n+        elif self.uri in self.app.config.linkcheck_ignore:\n+            return 'ignored', '', 0\n+        else:\n+            # External link - proceed with network check\n+            for rex in self.app.config.linkcheck_ignore_re:\n+                if rex.match(self.uri):\n+                    return 'ignored', '', 0\n \n-    def prepare_writing(self, docnames: Set[str]) -> None:\n-        return\n+            # need to actually check the URI\n+            for _ in range(self.app.config.linkcheck_retries):\n+                status, info, code = self.check_uri()\n+                if status != \"broken\":\n+                    break\n \n+            return (status, info, code)\n     def write_doc(self, docname: str, doctree: Node) -> None:\n         logger.info('')\n         n = 0\n",
    "variant_3": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..b42804b2e 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -212,8 +212,10 @@ class CheckExternalLinksBuilder(Builder):\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n+\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # Validate local links instead of immediately returning 'local'\n+                return self._check_local_link(uri, docname, lineno)\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n@@ -297,17 +299,248 @@ class CheckExternalLinksBuilder(Builder):\n             logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n             self.write_entry('redirected ' + text, docname, filename,\n                              lineno, uri + ' to ' + info)\n-            self.write_linkstat(linkstat)\n-\n-    def get_target_uri(self, docname: str, typ: str = None) -> str:\n-        return ''\n-\n-    def get_outdated_docs(self) -> Set[str]:\n-        return self.env.found_docs\n \n-    def prepare_writing(self, docnames: Set[str]) -> None:\n-        return\n+    def check(self) -> Tuple[str, str, int]:\n+        # check for various conditions without bothering the network\n+        if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n+            return 'unchecked', '', 0\n+        elif not (self.uri.startswith('http:') or self.uri.startswith('https:')):\n+            # Local link validation\n+            return self._check_local_link()\n+        elif self.uri in self.config.linkcheck_ignore:\n+            return 'ignored', '', 0\n+        elif self.auth:\n+            return self._check_external_link()\n+        else:\n+            return self._check_external_link()\n+\n+    def _check_local_link(self) -> Tuple[str, str, int]:\n+        \"\"\"Check if a local link is valid within the Sphinx project.\"\"\"\n+        uri = self.uri\n+        \n+        # Handle anchors in local links\n+        if '#' in uri:\n+            uri, anchor = uri.split('#', 1)\n+        else:\n+            anchor = None\n+            \n+        # Empty URI after anchor split means current document\n+        if not uri:\n+            if anchor:\n+                # Check if anchor exists in current document\n+                if self._check_anchor_in_doc(self.docname, anchor):\n+                    return 'working', '', 0\n+                else:\n+                    return 'broken', 'Anchor not found in current document', 0\n+            return 'working', '', 0\n+            \n+        # Check if it's a document reference\n+        if self._is_document_reference(uri):\n+            target_docname = self._resolve_document_name(uri)\n+            if target_docname in self.env.found_docs:\n+                if anchor and not self._check_anchor_in_doc(target_docname, anchor):\n+                    return 'broken', f'Anchor #{anchor} not found in document', 0\n+                return 'working', '', 0\n+            else:\n+                return 'broken', 'Document not found', 0\n+                \n+        # Check if it's a file reference\n+        if self._is_file_reference(uri):\n+            file_path = self._resolve_file_path(uri)\n+            if path.exists(file_path):\n+                return 'working', '', 0\n+            else:\n+                return 'broken', 'File not found', 0\n+                \n+        # Default to broken for unrecognized local references\n+        return 'broken', 'Local reference not found', 0\n+        \n+    def _is_document_reference(self, uri: str) -> bool:\n+        \"\"\"Check if URI refers to a Sphinx document.\"\"\"\n+        # Remove file extensions that Sphinx handles\n+        for suffix in ['.html', '.htm']:\n+            if uri.endswith(suffix):\n+                return True\n+        # Check if it's a document name without extension\n+        return '.' not in uri or uri.endswith('.rst') or uri.endswith('.md')\n+        \n+    def _resolve_document_name(self, uri: str) -> str:\n+        \"\"\"Resolve URI to document name.\"\"\"\n+        # Remove HTML extensions\n+        for suffix in ['.html', '.htm']:\n+            if uri.endswith(suffix):\n+                uri = uri[:-len(suffix)]\n+                break\n+                \n+        # Handle relative paths\n+        if uri.startswith('./'):\n+            uri = uri[2:]\n+        elif uri.startswith('../'):\n+            # Handle relative navigation\n+            docname_parts = self.docname.split('/')\n+            uri_parts = uri.split('/')\n+            \n+            # Process .. components\n+            result_parts = docname_parts[:-1]  # Remove current doc name\n+            for part in uri_parts:\n+                if part == '..':\n+                    if result_parts:\n+                        result_parts.pop()\n+                elif part and part != '.':\n+                    result_parts.append(part)\n+                    \n+            uri = '/'.join(result_parts)\n+            \n+        return uri\n+        \n+    def _is_file_reference(self, uri: str) -> bool:\n+        \"\"\"Check if URI refers to a static file.\"\"\"\n+        # Common file extensions\n+        file_extensions = ['.png', '.jpg', '.jpeg', '.gif', '.svg', '.pdf', \n+                          '.css', '.js', '.txt', '.zip', '.tar', '.gz']\n+        return any(uri.lower().endswith(ext) for ext in file_extensions)\n+        \n+    def _resolve_file_path(self, uri: str) -> str:\n+        \"\"\"Resolve URI to actual file path.\"\"\"\n+        # Handle relative paths\n+        if uri.startswith('./'):\n+            uri = uri[2:]\n+        elif uri.startswith('../'):\n+            # Handle relative navigation from document directory\n+            doc_dir = path.dirname(path.join(self.env.srcdir, self.docname))\n+            return path.normpath(path.join(doc_dir, uri))\n+            \n+        # Check in source directory\n+        src_path = path.join(self.env.srcdir, uri)\n+        if path.exists(src_path):\n+            return src_path\n+            \n+        # Check in static directories\n+        for static_dir in getattr(self.config, 'html_static_path', []):\n+            static_path = path.join(self.env.srcdir, static_dir, uri)\n+            if path.exists(static_path):\n+                return static_path\n+                \n+        return path.join(self.env.srcdir, uri)\n+        \n+    def _check_anchor_in_doc(self, docname: str, anchor: str) -> bool:\n+        \"\"\"Check if anchor exists in the specified document.\"\"\"\n+        try:\n+            doctree = self.env.get_doctree(docname)\n+            # Look for nodes with matching ids\n+            for node in doctree.traverse():\n+                if hasattr(node, 'attributes') and 'ids' in node.attributes:\n+                    if anchor in node['ids']:\n+                        return True\n+                # Also check names attribute\n+                if hasattr(node, 'attributes') and 'names' in node.attributes:\n+                    if anchor in node['names']:\n+                        return True\n+            return False\n+        except Exception:\n+            # If we can't load the document, assume anchor doesn't exist\n+            return False\n+            \n+    def _check_external_link(self) -> Tuple[str, str, int]:\n+        \"\"\"Check external HTTP/HTTPS links.\"\"\"\n+        # Original external link checking logic\n+        req_url, delimiter, anchor = self.uri.partition('#')\n+        for rex in self.anchors_ignore:\n+            if rex.match(anchor):\n+                anchor = None\n+                break\n \n+        # handle non-ASCII URIs\n+        try:\n+            req_url.encode('ascii')\n+        except UnicodeError:\n+            req_url = encode_uri(req_url)\n+\n+        # Get auth info\n+        auth_info = self.auth\n+        if auth_info:\n+            auth_info = (unquote(auth_info[0]), unquote(auth_info[1]))\n+\n+        # update request headers for the URL\n+        kwargs = {}\n+        if auth_info:\n+            kwargs['auth'] = auth_info\n+        if self.config.linkcheck_request_headers:\n+            for u in self.config.linkcheck_request_headers:\n+                if u.match(req_url):\n+                    headers = dict(DEFAULT_REQUEST_HEADERS)\n+                    headers.update(self.config.linkcheck_request_headers[u])\n+                    kwargs['headers'] = headers\n+                    break\n+            else:\n+                kwargs['headers'] = dict(DEFAULT_REQUEST_HEADERS)\n+        else:\n+            kwargs['headers'] = dict(DEFAULT_REQUEST_HEADERS)\n+        kwargs['config'] = self.config\n+        kwargs['allow_redirects'] = True\n+        kwargs['stream'] = True\n+        try:\n+            if anchor and self.config.linkcheck_anchors:\n+                # Read the whole document and see if #anchor exists\n+                # Disabled by default because it's slow\n+                response = requests.get(req_url, **kwargs)\n+                response.raise_for_status()\n+                parser = AnchorCheckParser(unquote(anchor))\n+                # Read file in chunks. If we find a matching anchor, we\n+                # don't need to read the whole file.\n+                for chunk in response.iter_content(chunk_size=4096, decode_unicode=True):\n+                    if isinstance(chunk, bytes):    # requests failed to decode\n+                        chunk = chunk.decode()       # fallback decoding\n+                    parser.feed(chunk)\n+                    if parser.found:\n+                        break\n+                parser.close()\n+                if not parser.found:\n+                    raise Exception(\"Anchor '%s' not found\" % anchor)\n+            else:\n+                try:\n+                    # try a HEAD request first, which should be easier on\n+                    # the server and the network\n+                    response = requests.head(req_url, **kwargs)\n+                    response.raise_for_status()\n+                except (HTTPError, *QUEUE_POLL_EXCEPTIONS) as err:\n+                    if isinstance(err, HTTPError) and err.response.status_code == 405:\n+                        # retry with GET request if that fails, some servers\n+                        # don't like HEAD requests.\n+                        response = requests.get(req_url, **kwargs)\n+                        response.raise_for_status()\n+                    else:\n+                        raise\n+        except SSLError as err:\n+            if is_ssl_error(err):\n+                return 'ignored', str(err), 0\n+            else:\n+                return 'broken', str(err), 0\n+        except (ConnectionError, TooManyRedirects) as err:\n+            return 'broken', str(err), 0\n+        except HTTPError as err:\n+            if err.response.status_code == 401:\n+                # We'll take \"Unauthorized\" as working.\n+                return 'working', 'Unauthorized', 0\n+            elif err.response.status_code == 403:\n+                return 'broken', 'Forbidden', 0\n+            elif err.response.status_code in (301, 302, 303, 307, 308):\n+                return 'redirected', \\\n+                       err.response.headers.get('location', 'with unknown location'), \\\n+                       err.response.status_code\n+            else:\n+                return 'broken', str(err), 0\n+        except Exception as err:\n+            return 'broken', str(err), 0\n+        else:\n+            if response.url.rstrip('/') == req_url.rstrip('/'):\n+                return 'working', '', 0\n+            elif response.history:\n+                # history contains any redirects, get last\n+                code = response.history[-1].status_code\n+                return 'redirected', response.url, code\n+            else:\n+                return 'redirected', response.url, 0\n     def write_doc(self, docname: str, doctree: Node) -> None:\n         logger.info('')\n         n = 0\n",
    "variant_4": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..237495f53 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -212,8 +212,23 @@ class CheckExternalLinksBuilder(Builder):\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n-            elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+\n+            def check() -> Tuple[str, str, int]:\n+                # check for various conditions without bothering the network\n+                if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n+                    return 'unchecked', '', 0\n+                elif not uri.startswith(('http:', 'https:')):\n+                    # Validate local links instead of immediately returning 'local'\n+                    return self._check_local_uri(uri, docname, lineno)\n+                elif uri in self.good:\n+                    return 'working', 'old', 0\n+                elif uri in self.broken:\n+                    return 'broken', self.broken[uri], 0\n+                elif uri in self.redirected:\n+                    return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n+                for rex in self.to_ignore:\n+                    if rex.match(uri):\n+                        return 'ignored', '', 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n@@ -297,17 +312,72 @@ class CheckExternalLinksBuilder(Builder):\n             logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n             self.write_entry('redirected ' + text, docname, filename,\n                              lineno, uri + ' to ' + info)\n-            self.write_linkstat(linkstat)\n-\n-    def get_target_uri(self, docname: str, typ: str = None) -> str:\n-        return ''\n-\n-    def get_outdated_docs(self) -> Set[str]:\n-        return self.env.found_docs\n-\n-    def prepare_writing(self, docnames: Set[str]) -> None:\n-        return\n \n+    def check(self) -> Tuple[str, str, int]:\n+        # check for various conditions without bothering the network\n+        if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n+            return 'unchecked', '', 0\n+        elif not (self.uri.startswith(('http:', 'https:')) or self.uri.startswith(('ftp:', 'ftps:'))):\n+            # Local link validation\n+            return self._check_local_link()\n+        elif self.uri in self.config.linkcheck_ignore:\n+            return 'ignored', '', 0\n+        elif self.config.linkcheck_anchors_ignore_for_url(self.uri):\n+            self.anchor = None\n+        \n+        # rate limiting\n+        with self.rqueue.get_request_rate_delay_time(self.uri) as delay_time:\n+            if delay_time is not None:\n+                self.wqueue.put(CheckRequest(self.next_check, self.hyperlink), False)\n+                return 'rate-limited', '', delay_time\n+\n+        return self._check_uri()\n+\n+    def _check_local_link(self) -> Tuple[str, str, int]:\n+        \"\"\"Check if a local link is valid within the Sphinx project.\"\"\"\n+        uri = self.uri\n+        \n+        # Handle anchors in local links\n+        if '#' in uri:\n+            uri_part, anchor = uri.split('#', 1)\n+            self.anchor = anchor\n+        else:\n+            uri_part = uri\n+            \n+        # Remove leading slash for relative paths\n+        if uri_part.startswith('/'):\n+            uri_part = uri_part[1:]\n+            \n+        # Check if it's a reference to another document\n+        if uri_part:\n+            # Try to resolve as a document reference\n+            docname = uri_part\n+            if docname.endswith('.html'):\n+                docname = docname[:-5]  # Remove .html extension\n+                \n+            # Check if document exists in the environment\n+            if docname in self.env.all_docs:\n+                if self.anchor:\n+                    # For now, assume anchor exists if document exists\n+                    # Full anchor validation would require parsing the target document\n+                    return 'working', '', 0\n+                else:\n+                    return 'working', '', 0\n+            \n+            # Check if it's a file that exists relative to source directory\n+            from os.path import join, exists\n+            full_path = join(self.env.srcdir, uri_part)\n+            if exists(full_path):\n+                return 'working', '', 0\n+                \n+        # If we have only an anchor (empty uri_part), check current document\n+        elif self.anchor:\n+            # This would be an anchor in the current document\n+            # For now, assume it's valid - full validation would require parsing\n+            return 'working', '', 0\n+            \n+        # Link doesn't resolve to anything\n+        return 'broken', 'Local link not found', 404\n     def write_doc(self, docname: str, doctree: Node) -> None:\n         logger.info('')\n         n = 0\n",
    "variant_5": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..fef694cc8 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -208,12 +208,27 @@ class CheckExternalLinksBuilder(Builder):\n                 else:\n                     return 'redirected', new_url, 0\n \n+        def check() -> Tuple[str, str, int]:\n+            # check for various conditions without bothering the network\n+            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n+                return 'unchecked', '', 0\n+\n         def check() -> Tuple[str, str, int]:\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # Validate local links instead of immediately returning 'local'\n+                return self._validate_local_link(uri, docname)\n+            elif uri in self.good:\n+                return 'working', 'old', 0\n+            elif uri in self.broken:\n+                return 'broken', self.broken[uri], 0\n+            elif uri in self.redirected:\n+                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n+            for rex in self.to_ignore:\n+                if rex.match(uri):\n+                    return 'ignored', '', 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n@@ -297,17 +312,61 @@ class CheckExternalLinksBuilder(Builder):\n             logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n             self.write_entry('redirected ' + text, docname, filename,\n                              lineno, uri + ' to ' + info)\n-            self.write_linkstat(linkstat)\n-\n-    def get_target_uri(self, docname: str, typ: str = None) -> str:\n-        return ''\n \n-    def get_outdated_docs(self) -> Set[str]:\n-        return self.env.found_docs\n+    def check(self) -> Tuple[str, str, int]:\n+        # check for various conditions without actually checking the URL\n+        if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n+            return 'unchecked', '', 0\n \n-    def prepare_writing(self, docnames: Set[str]) -> None:\n-        return\n+        # Handle local links (non-http/https URIs)\n+        if not self.uri.startswith(('http:', 'https:')):\n+            # Parse the URI to extract path and anchor\n+            if '#' in self.uri:\n+                path_part, anchor = self.uri.split('#', 1)\n+            else:\n+                path_part, anchor = self.uri, None\n+            \n+            # Check if it's a document reference\n+            if path_part:\n+                # Remove leading slash and normalize path\n+                clean_path = path_part.lstrip('/')\n+                \n+                # Check if it's a reference to another document\n+                if clean_path:\n+                    # Try to resolve as document reference\n+                    docname = clean_path\n+                    if docname.endswith('.html'):\n+                        docname = docname[:-5]  # Remove .html extension\n+                    \n+                    # Check if document exists in the project\n+                    if docname in self.env.all_docs:\n+                        # If anchor specified, we'd need to validate it exists in target doc\n+                        # For now, assume document reference is valid\n+                        return 'working', '', 0\n+                    else:\n+                        # Check if it's a file path relative to source directory\n+                        source_dir = self.env.srcdir\n+                        full_path = path.join(source_dir, clean_path)\n+                        if path.exists(full_path):\n+                            return 'working', '', 0\n+                        else:\n+                            return 'broken', 'local file or document not found', 0\n+                else:\n+                    # Empty path with anchor - check anchor in current document\n+                    if anchor:\n+                        # For same-document anchors, assume valid for now\n+                        # Could be enhanced to validate anchor exists\n+                        return 'working', '', 0\n+                    else:\n+                        return 'broken', 'empty local reference', 0\n+            else:\n+                # Only anchor, no path - same document reference\n+                return 'working', '', 0\n \n+        # Continue with existing external URL validation\n+        for rex in self.anchors_ignore:\n+            if rex.match(self.uri):\n+                return 'unchecked', '', 0\n     def write_doc(self, docname: str, doctree: Node) -> None:\n         logger.info('')\n         n = 0\n",
    "variant_6": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..80f3a4901 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -208,12 +208,27 @@ class CheckExternalLinksBuilder(Builder):\n                 else:\n                     return 'redirected', new_url, 0\n \n+        def check() -> Tuple[str, str, int]:\n+            # check for various conditions without bothering the network\n+            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n+                return 'unchecked', '', 0\n+\n         def check() -> Tuple[str, str, int]:\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # Validate local links instead of immediately returning 'local'\n+                return self._check_local_link(uri, docname)\n+            elif uri in self.good:\n+                return 'working', 'old', 0\n+            elif uri in self.broken:\n+                return 'broken', self.broken[uri], 0\n+            elif uri in self.redirected:\n+                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n+            for rex in self.to_ignore:\n+                if rex.match(uri):\n+                    return 'ignored', '', 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n@@ -297,17 +312,116 @@ class CheckExternalLinksBuilder(Builder):\n             logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n             self.write_entry('redirected ' + text, docname, filename,\n                              lineno, uri + ' to ' + info)\n-            self.write_linkstat(linkstat)\n \n-    def get_target_uri(self, docname: str, typ: str = None) -> str:\n-        return ''\n+    def check(self, docname: str, uri: str, node: Node) -> Tuple[str, str, int]:\n+        # check for various conditions without bothering the network\n+        if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'tel:')):\n+            return 'unchecked', '', 0\n+        elif not uri.startswith(('http:', 'https:')):\n+            # Local link validation\n+            if uri.startswith('/'):\n+                # Absolute path - check if file exists relative to source directory\n+                local_path = path.join(self.srcdir, uri.lstrip('/'))\n+                if path.exists(local_path):\n+                    return 'working', '', 0\n+                else:\n+                    return 'broken', 'file not found', 0\n+            else:\n+                # Relative link - check if target document or file exists\n+                if '#' in uri:\n+                    base_uri, anchor = uri.split('#', 1)\n+                else:\n+                    base_uri, anchor = uri, ''\n+                \n+                # Check if it's a document reference\n+                if base_uri:\n+                    # Try to resolve as a document\n+                    current_dir = path.dirname(docname)\n+                    if current_dir:\n+                        target_doc = path.join(current_dir, base_uri)\n+                    else:\n+                        target_doc = base_uri\n+                    \n+                    # Remove file extension if present and normalize\n+                    target_doc = re.sub(r'\\.(rst|md|txt)$', '', target_doc)\n+                    target_doc = target_doc.replace('\\\\', '/')\n+                    \n+                    if target_doc in self.env.found_docs:\n+                        # Document exists, check anchor if present\n+                        if anchor:\n+                            # For now, assume anchor exists - full anchor validation would require more complex logic\n+                            return 'working', '', 0\n+                        return 'working', '', 0\n+                    else:\n+                        # Check if it's a static file\n+                        current_doc_dir = path.dirname(path.join(self.srcdir, docname))\n+                        static_file_path = path.join(current_doc_dir, base_uri)\n+                        if path.exists(static_file_path):\n+                            return 'working', '', 0\n+                        else:\n+                            return 'broken', 'document or file not found', 0\n+                else:\n+                    # Just an anchor reference to current document\n+                    return 'working', '', 0\n+        \n+        # Continue with existing external link validation\n+        for rex in self.anchors_ignore:\n+            if rex.match(uri):\n+                return 'unchecked', '', 0\n+        \n+        # split off anchor\n+        if '#' in uri:\n+            req_url, anchor = uri.split('#', 1)\n+            for rex in self.anchors_ignore:\n+                if rex.match(anchor):\n+                    anchor = None\n+                    break\n+        else:\n+            req_url = uri\n+            anchor = None\n+\n+        # handle non-ASCII URIs\n+        try:\n+            req_url.encode('ascii')\n+        except UnicodeError:\n+            req_url = encode_uri(req_url)\n+\n+        # Get auth info\n+        for pattern, auth_info in self.auth:  # type: ignore\n+            if pattern.match(uri):\n+                break\n+        else:\n+            auth_info = None\n+\n+        # update request headers for the URL\n+        kwargs = {}\n+        if self.config.linkcheck_request_headers:\n+            for pattern in self.config.linkcheck_request_headers:\n+                if pattern.match(req_url):\n+                    headers = dict(DEFAULT_REQUEST_HEADERS)\n+                    headers.update(self.config.linkcheck_request_headers[pattern])\n+                    kwargs['headers'] = headers\n+                    break\n+        else:\n+            kwargs['headers'] = dict(DEFAULT_REQUEST_HEADERS)\n \n-    def get_outdated_docs(self) -> Set[str]:\n-        return self.env.found_docs\n+        # Robots.txt validation\n+        if self.check_anchors and self.config.linkcheck_anchors_ignore_for_url:\n+            for pattern in self.config.linkcheck_anchors_ignore_for_url:\n+                if pattern.match(uri):\n+                    anchor = None\n+                    break\n \n-    def prepare_writing(self, docnames: Set[str]) -> None:\n-        return\n+        # Read the whole document and see if #anchor exists\n+        status, info, code = self._check_uri(req_url, anchor, **kwargs)\n+        if status == 'broken' and anchor and self.config.linkcheck_anchors:\n+            # Check if the anchor exists by fetching the page\n+            logger.info(__('(checking link anchor...)'))\n+            status, info, code = self._check_uri(req_url, None, **kwargs)\n+            if status == 'working':\n+                status, info, code = self._check_anchor(req_url, anchor, **kwargs)\n \n+        return status, info, code\n     def write_doc(self, docname: str, doctree: Node) -> None:\n         logger.info('')\n         n = 0\n",
    "variant_7": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..239b42ae1 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -208,12 +208,27 @@ class CheckExternalLinksBuilder(Builder):\n                 else:\n                     return 'redirected', new_url, 0\n \n+        def check() -> Tuple[str, str, int]:\n+            # check for various conditions without bothering the network\n+            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n+                return 'unchecked', '', 0\n+\n         def check() -> Tuple[str, str, int]:\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # Validate local links instead of immediately returning 'local'\n+                return self._check_local_link(uri, docname)\n+            elif uri in self.good:\n+                return 'working', 'old', 0\n+            elif uri in self.broken:\n+                return 'broken', self.broken[uri], 0\n+            elif uri in self.redirected:\n+                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n+            for rex in self.to_ignore:\n+                if rex.match(uri):\n+                    return 'ignored', '', 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n@@ -297,17 +312,139 @@ class CheckExternalLinksBuilder(Builder):\n             logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n             self.write_entry('redirected ' + text, docname, filename,\n                              lineno, uri + ' to ' + info)\n-            self.write_linkstat(linkstat)\n-\n-    def get_target_uri(self, docname: str, typ: str = None) -> str:\n-        return ''\n-\n-    def get_outdated_docs(self) -> Set[str]:\n-        return self.env.found_docs\n-\n-    def prepare_writing(self, docnames: Set[str]) -> None:\n-        return\n \n+    def check(self) -> Tuple[str, str, int]:\n+        # check for various conditions without bothering the network\n+        if len(self.uri) == 0 or self.uri.startswith(('#', 'mailto:', 'tel:')):\n+            return 'unchecked', '', 0\n+        elif not (self.uri.startswith(('http:', 'https:')) or self.uri.startswith('/')):\n+            # Local link validation\n+            return self._check_local_link()\n+        elif self.uri in self.config.linkcheck_ignore:\n+            return 'ignored', '', 0\n+        else:\n+            # External link validation\n+            return self._check_external_link()\n+\n+    def _check_local_link(self) -> Tuple[str, str, int]:\n+        \"\"\"Validate local links against Sphinx project structure.\"\"\"\n+        uri = self.uri\n+        \n+        # Handle anchor-only links\n+        if uri.startswith('#'):\n+            # Check if anchor exists in current document\n+            if self._check_anchor_in_document(uri[1:], self.docname):\n+                return 'working', '', 0\n+            else:\n+                return 'broken', 'Anchor not found in document', 0\n+        \n+        # Parse potential anchor\n+        if '#' in uri:\n+            path_part, anchor = uri.split('#', 1)\n+        else:\n+            path_part, anchor = uri, None\n+        \n+        # Check if it's a document reference\n+        if self._is_document_reference(path_part):\n+            target_doc = self._resolve_document_reference(path_part)\n+            if target_doc and target_doc in self.env.found_docs:\n+                if anchor and not self._check_anchor_in_document(anchor, target_doc):\n+                    return 'broken', f'Anchor #{anchor} not found in document', 0\n+                return 'working', '', 0\n+            else:\n+                return 'broken', 'Document not found', 0\n+        \n+        # Check if it's a file reference\n+        if self._is_file_reference(path_part):\n+            if self._check_file_exists(path_part):\n+                return 'working', '', 0\n+            else:\n+                return 'broken', 'File not found', 0\n+        \n+        # Default to broken if we can't identify the reference type\n+        return 'broken', 'Local reference not found', 0\n+    \n+    def _is_document_reference(self, path: str) -> bool:\n+        \"\"\"Check if path appears to be a document reference.\"\"\"\n+        # Remove leading/trailing slashes and file extensions\n+        clean_path = path.strip('/').replace('.html', '').replace('.rst', '')\n+        return bool(clean_path) and not path.startswith(('_static/', '_images/'))\n+    \n+    def _resolve_document_reference(self, path: str) -> str:\n+        \"\"\"Resolve document reference to docname.\"\"\"\n+        clean_path = path.strip('/').replace('.html', '').replace('.rst', '')\n+        \n+        # Try exact match first\n+        if clean_path in self.env.found_docs:\n+            return clean_path\n+        \n+        # Try with current document's directory\n+        if '/' in self.docname:\n+            doc_dir = '/'.join(self.docname.split('/')[:-1])\n+            candidate = f\"{doc_dir}/{clean_path}\"\n+            if candidate in self.env.found_docs:\n+                return candidate\n+        \n+        # Try relative to source directory\n+        from os.path import normpath\n+        normalized = normpath(clean_path).replace('\\\\', '/')\n+        if normalized in self.env.found_docs:\n+            return normalized\n+            \n+        return clean_path\n+    \n+    def _is_file_reference(self, path: str) -> bool:\n+        \"\"\"Check if path appears to be a static file reference.\"\"\"\n+        return path.startswith(('_static/', '_images/')) or '.' in path.split('/')[-1]\n+    \n+    def _check_file_exists(self, path: str) -> bool:\n+        \"\"\"Check if static file exists in the project.\"\"\"\n+        from os.path import exists, join\n+        \n+        # Check in source directory\n+        source_path = join(self.env.srcdir, path.lstrip('/'))\n+        if exists(source_path):\n+            return True\n+        \n+        # Check in build directory for generated files\n+        if hasattr(self.env.app, 'outdir'):\n+            build_path = join(self.env.app.outdir, path.lstrip('/'))\n+            if exists(build_path):\n+                return True\n+        \n+        return False\n+    \n+    def _check_anchor_in_document(self, anchor: str, docname: str) -> bool:\n+        \"\"\"Check if anchor exists in specified document.\"\"\"\n+        if not anchor or docname not in self.env.found_docs:\n+            return False\n+        \n+        # Get document's title and section IDs if available\n+        doctree = self.env.get_doctree(docname)\n+        \n+        # Check for section titles and explicit IDs\n+        for node in doctree.traverse():\n+            # Check explicit IDs\n+            if hasattr(node, 'attributes') and 'ids' in node.attributes:\n+                if anchor in node.attributes['ids']:\n+                    return True\n+            \n+            # Check section titles converted to anchors\n+            if hasattr(node, 'astext') and hasattr(node, 'tagname'):\n+                if node.tagname in ('title', 'section'):\n+                    # Convert title to anchor format (simplified)\n+                    title_anchor = re.sub(r'[^\\w\\s-]', '', node.astext().strip())\n+                    title_anchor = re.sub(r'[-\\s]+', '-', title_anchor).lower()\n+                    if title_anchor == anchor.lower():\n+                        return True\n+        \n+        return False\n+\n+    def _check_external_link(self) -> Tuple[str, str, int]:\n+        \"\"\"Check external HTTP/HTTPS links.\"\"\"\n+        # existing external link checking logic would go here\n+        # This is a placeholder for the current external checking code\n+        return self.check_uri()\n     def write_doc(self, docname: str, doctree: Node) -> None:\n         logger.info('')\n         n = 0\n",
    "variant_8": "diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..3f3f20ac5 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -208,12 +208,27 @@ class CheckExternalLinksBuilder(Builder):\n                 else:\n                     return 'redirected', new_url, 0\n \n+        def check() -> Tuple[str, str, int]:\n+            # check for various conditions without bothering the network\n+            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n+                return 'unchecked', '', 0\n+\n         def check() -> Tuple[str, str, int]:\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # Validate local links instead of just marking as 'local'\n+                return self._check_local_link(uri, docname)\n+            elif uri in self.good:\n+                return 'working', 'old', 0\n+            elif uri in self.broken:\n+                return 'broken', self.broken[uri], 0\n+            elif uri in self.redirected:\n+                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n+            for rex in self.to_ignore:\n+                if rex.match(uri):\n+                    return 'ignored', '', 0\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\n@@ -297,17 +312,39 @@ class CheckExternalLinksBuilder(Builder):\n             logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n             self.write_entry('redirected ' + text, docname, filename,\n                              lineno, uri + ' to ' + info)\n-            self.write_linkstat(linkstat)\n-\n-    def get_target_uri(self, docname: str, typ: str = None) -> str:\n-        return ''\n-\n-    def get_outdated_docs(self) -> Set[str]:\n-        return self.env.found_docs\n-\n-    def prepare_writing(self, docnames: Set[str]) -> None:\n-        return\n \n+        # handle non-HTTP URIs\n+        if not uri.lower().startswith(('http:', 'https:')):\n+            # Local link validation\n+            if uri.startswith('#'):\n+                # Fragment-only link (same document)\n+                return 'working', '', 0\n+            elif uri.startswith('mailto:') or uri.startswith('ftp:') or '://' in uri:\n+                # Other protocols - skip validation\n+                return 'local', '', 0\n+            else:\n+                # Local file/document reference - validate it\n+                # Remove any fragment identifier\n+                local_uri = uri.split('#')[0] if '#' in uri else uri\n+                \n+                # Check if it's a document reference\n+                if local_uri.endswith(('.rst', '.md', '.txt')) or '.' not in local_uri:\n+                    # Document reference - check if document exists\n+                    docname = local_uri.rstrip('/').replace('/', path.sep)\n+                    if docname.endswith(('.rst', '.md', '.txt')):\n+                        docname = docname.rsplit('.', 1)[0]\n+                    \n+                    if docname in self.env.found_docs or docname in self.env.all_docs:\n+                        return 'working', '', 0\n+                    else:\n+                        return 'broken', 'document not found', 0\n+                else:\n+                    # File reference - check if file exists relative to source directory\n+                    file_path = path.join(self.env.srcdir, local_uri)\n+                    if path.exists(file_path):\n+                        return 'working', '', 0\n+                    else:\n+                        return 'broken', 'file not found', 0\n     def write_doc(self, docname: str, doctree: Node) -> None:\n         logger.info('')\n         n = 0\n"
  }
}