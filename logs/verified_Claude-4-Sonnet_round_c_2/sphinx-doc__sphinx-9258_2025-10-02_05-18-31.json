{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/util/docfields.py lines 184-187)": "\nif len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n    typename = fieldtype[0].astext()\n    \n    # Check if typename contains pipe syntax for union types\n    if ' | ' in typename or '|' in typename:\n        # Split by pipe and create separate cross-references for each type\n        type_parts = [part.strip() for part in typename.split('|')]\n        for i, type_part in enumerate(type_parts):\n            if i > 0:\n                par += nodes.Text(' | ')\n            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n                                       addnodes.literal_emphasis, env=env))\n    else:\n        # Original behavior for non-union types\n        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n                                   addnodes.literal_emphasis, env=env))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/util/docfields.py lines 184-187)": [
      "\n        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n            par = nodes.paragraph()\n            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n                                       addnodes.literal_strong, env=env))\n            if fieldarg in types:\n                par += nodes.Text(' (')\n                # NOTE: using .pop() here to prevent a single type node to be\n                # inserted twice into the doctree, which leads to\n                # inconsistencies later when references are resolved\n                fieldtype = types.pop(fieldarg)\n                if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                    typename = fieldtype[0].astext()\n                    \n                    # Check if typename contains pipe syntax for union types\n                    if ' | ' in typename or '|' in typename:\n                        # Split by pipe and create separate cross-references for each type\n                        type_parts = [part.strip() for part in typename.split('|')]\n                        for i, type_part in enumerate(type_parts):\n                            if i > 0:\n                                par += nodes.Text(' | ')\n                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n                                                       addnodes.literal_emphasis, env=env))\n                    else:\n                        # Original behavior for non-union types\n                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n                                                   addnodes.literal_emphasis, env=env))\n                else:\n                    par += fieldtype\n                par += nodes.Text(')')\n            par += nodes.Text(' -- ')\n            par += content\n            return par\n",
      "\n        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n            par = nodes.paragraph()\n            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n                                       addnodes.literal_strong, env=env))\n            if fieldarg in types:\n                par += nodes.Text(' (')\n                # NOTE: using .pop() here to prevent a single type node to be\n                # inserted twice into the doctree, which leads to\n                # inconsistencies later when references are resolved\n                fieldtype = types.pop(fieldarg)\n                if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                    typename = fieldtype[0].astext()\n                    \n                    # Check if typename contains pipe syntax for union types\n                    if ' | ' in typename or '|' in typename:\n                        # Split by pipe and create separate cross-references for each type\n                        type_parts = [part.strip() for part in typename.split('|')]\n                        for i, type_part in enumerate(type_parts):\n                            if i > 0:\n                                par += nodes.Text(' | ')\n                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n                                                       addnodes.literal_emphasis, env=env))\n                    else:\n                        # Original behavior for non-union types\n                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n                                                   addnodes.literal_emphasis, env=env))\n                else:\n                    par += fieldtype\n                par += nodes.Text(')')\n            par += nodes.Text(' -- ')\n            par += content\n            return par\n",
      "\n        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n            par = nodes.paragraph()\n            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n                                       addnodes.literal_strong, env=env))\n            if fieldarg in types:\n                par += nodes.Text(' (')\n                # NOTE: using .pop() here to prevent a single type node to be\n                # inserted twice into the doctree, which leads to\n                # inconsistencies later when references are resolved\n                fieldtype = types.pop(fieldarg)\n                if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                    typename = fieldtype[0].astext()\n                    \n                    # Check if typename contains pipe syntax for union types\n                    if ' | ' in typename or '|' in typename:\n                        # Split by pipe and create separate cross-references for each type\n                        type_parts = [part.strip() for part in typename.split('|')]\n                        for i, type_part in enumerate(type_parts):\n                            if i > 0:\n                                par += nodes.Text(' | ')\n                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n                                                       addnodes.literal_emphasis, env=env))\n                    else:\n                        # Original behavior for non-union types\n                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n                                                   addnodes.literal_emphasis, env=env))\n                else:\n                    par += fieldtype\n                par += nodes.Text(')')\n            par += nodes.Text(' -- ')\n            par += content\n            return par\n",
      "\n        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n            par = nodes.paragraph()\n            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n                                       addnodes.literal_strong, env=env))\n            if fieldarg in types:\n                par += nodes.Text(' (')\n                # NOTE: using .pop() here to prevent a single type node to be\n                # inserted twice into the doctree, which leads to\n                # inconsistencies later when references are resolved\n                fieldtype = types.pop(fieldarg)\n                if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                    typename = fieldtype[0].astext()\n                    \n                    # Check if typename contains pipe syntax for union types\n                    if ' | ' in typename or '|' in typename:\n                        # Split by pipe and create separate cross-references for each type\n                        type_parts = [part.strip() for part in typename.split('|')]\n                        for i, type_part in enumerate(type_parts):\n                            if i > 0:\n                                par += nodes.Text(' | ')\n                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n                                                       addnodes.literal_emphasis, env=env))\n                    else:\n                        # Original behavior for non-union types\n                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n                                                   addnodes.literal_emphasis, env=env))\n                else:\n                    par += fieldtype\n                par += nodes.Text(')')\n            par += nodes.Text(' -- ')\n            par += content\n            return par\n",
      "\n        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n            par = nodes.paragraph()\n            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n                                       addnodes.literal_strong, env=env))\n            if fieldarg in types:\n                par += nodes.Text(' (')\n                # NOTE: using .pop() here to prevent a single type node to be\n                # inserted twice into the doctree, which leads to\n                # inconsistencies later when references are resolved\n                fieldtype = types.pop(fieldarg)\n                if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                    typename = fieldtype[0].astext()\n                    \n                    # Check if typename contains pipe syntax for union types\n                    if ' | ' in typename or '|' in typename:\n                        # Split by pipe and create separate cross-references for each type\n                        type_parts = [part.strip() for part in typename.split('|')]\n                        for i, type_part in enumerate(type_parts):\n                            if i > 0:\n                                par += nodes.Text(' | ')\n                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n                                                       addnodes.literal_emphasis, env=env))\n                    else:\n                        # Original behavior for non-union types\n                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n                                                   addnodes.literal_emphasis, env=env))\n                else:\n                    par += fieldtype\n                par += nodes.Text(')')\n            par += nodes.Text(' -- ')\n            par += content\n            return par\n",
      "\n        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n            par = nodes.paragraph()\n            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n                                       addnodes.literal_strong, env=env))\n            if fieldarg in types:\n                par += nodes.Text(' (')\n                # NOTE: using .pop() here to prevent a single type node to be\n                # inserted twice into the doctree, which leads to\n                # inconsistencies later when references are resolved\n                fieldtype = types.pop(fieldarg)\n                if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                    typename = fieldtype[0].astext()\n                    \n                    # Check if typename contains pipe syntax for union types\n                    if ' | ' in typename or '|' in typename:\n                        # Split by pipe and create separate cross-references for each type\n                        type_parts = [part.strip() for part in typename.split('|')]\n                        for i, type_part in enumerate(type_parts):\n                            if i > 0:\n                                par += nodes.Text(' | ')\n                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n                                                       addnodes.literal_emphasis, env=env))\n                    else:\n                        # Original behavior for non-union types\n                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n                                                   addnodes.literal_emphasis, env=env))\n                else:\n                    par += fieldtype\n                par += nodes.Text(')')\n            par += nodes.Text(' -- ')\n            par += content\n            return par\n",
      "\n        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n            par = nodes.paragraph()\n            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n                                       addnodes.literal_strong, env=env))\n            if fieldarg in types:\n                par += nodes.Text(' (')\n                # NOTE: using .pop() here to prevent a single type node to be\n                # inserted twice into the doctree, which leads to\n                # inconsistencies later when references are resolved\n                fieldtype = types.pop(fieldarg)\n                if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                    typename = fieldtype[0].astext()\n                    \n                    # Check if typename contains pipe syntax for union types\n                    if ' | ' in typename or '|' in typename:\n                        # Split by pipe and create separate cross-references for each type\n                        type_parts = [part.strip() for part in typename.split('|')]\n                        for i, type_part in enumerate(type_parts):\n                            if i > 0:\n                                par += nodes.Text(' | ')\n                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n                                                       addnodes.literal_emphasis, env=env))\n                    else:\n                        # Original behavior for non-union types\n                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n                                                   addnodes.literal_emphasis, env=env))\n                else:\n                    par += fieldtype\n                par += nodes.Text(')')\n            par += nodes.Text(' -- ')\n            par += content\n            return par\n",
      "\n        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n            par = nodes.paragraph()\n            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n                                       addnodes.literal_strong, env=env))\n            if fieldarg in types:\n                par += nodes.Text(' (')\n                # NOTE: using .pop() here to prevent a single type node to be\n                # inserted twice into the doctree, which leads to\n                # inconsistencies later when references are resolved\n                fieldtype = types.pop(fieldarg)\n                if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                    typename = fieldtype[0].astext()\n                    \n                    # Check if typename contains pipe syntax for union types\n                    if ' | ' in typename or '|' in typename:\n                        # Split by pipe and create separate cross-references for each type\n                        type_parts = [part.strip() for part in typename.split('|')]\n                        for i, type_part in enumerate(type_parts):\n                            if i > 0:\n                                par += nodes.Text(' | ')\n                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n                                                       addnodes.literal_emphasis, env=env))\n                    else:\n                        # Original behavior for non-union types\n                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n                                                   addnodes.literal_emphasis, env=env))\n                else:\n                    par += fieldtype\n                par += nodes.Text(')')\n            par += nodes.Text(' -- ')\n            par += content\n            return par\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..8dce2baaa 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -181,10 +181,23 @@ class TypedField(GroupedField):\n                 # inserted twice into the doctree, which leads to\n                 # inconsistencies later when references are resolved\n                 fieldtype = types.pop(fieldarg)\n+\n                 if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                     typename = fieldtype[0].astext()\n-                    par.extend(self.make_xrefs(self.typerolename, domain, typename,\n-                                               addnodes.literal_emphasis, env=env))\n+                    \n+                    # Check if typename contains pipe syntax for union types\n+                    if ' | ' in typename or '|' in typename:\n+                        # Split by pipe and create separate cross-references for each type\n+                        type_parts = [part.strip() for part in typename.split('|')]\n+                        for i, type_part in enumerate(type_parts):\n+                            if i > 0:\n+                                par += nodes.Text(' | ')\n+                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n+                                                       addnodes.literal_emphasis, env=env))\n+                    else:\n+                        # Original behavior for non-union types\n+                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n+                                                   addnodes.literal_emphasis, env=env))\n                 else:\n                     par += fieldtype\n                 par += nodes.Text(')')\n",
    "variant_0": "diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..90e754849 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -181,10 +181,23 @@ class TypedField(GroupedField):\n                 # inserted twice into the doctree, which leads to\n                 # inconsistencies later when references are resolved\n                 fieldtype = types.pop(fieldarg)\n-                if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n-                    typename = fieldtype[0].astext()\n-                    par.extend(self.make_xrefs(self.typerolename, domain, typename,\n-                                               addnodes.literal_emphasis, env=env))\n+\n+if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n+    typename = fieldtype[0].astext()\n+    \n+    # Check if typename contains pipe syntax for union types\n+    if ' | ' in typename or '|' in typename:\n+        # Split by pipe and create separate cross-references for each type\n+        type_parts = [part.strip() for part in typename.split('|')]\n+        for i, type_part in enumerate(type_parts):\n+            if i > 0:\n+                par += nodes.Text(' | ')\n+            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n+                                       addnodes.literal_emphasis, env=env))\n+    else:\n+        # Original behavior for non-union types\n+        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n+                                   addnodes.literal_emphasis, env=env))\n                 else:\n                     par += fieldtype\n                 par += nodes.Text(')')\n",
    "variant_1": "diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..760439b0e 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -171,6 +171,17 @@ class TypedField(GroupedField):\n \n     def make_field(self, types: Dict[str, List[Node]], domain: str,\n                    items: Tuple, env: BuildEnvironment = None) -> nodes.field:\n+        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n+            par = nodes.paragraph()\n+            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n+                                       addnodes.literal_strong, env=env))\n+            if fieldarg in types:\n+                par += nodes.Text(' (')\n+                # NOTE: using .pop() here to prevent a single type node to be\n+                # inserted twice into the doctree, which leads to\n+                # inconsistencies later when references are resolved\n+                fieldtype = types.pop(fieldarg)\n+\n         def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n             par = nodes.paragraph()\n             par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n@@ -183,8 +194,26 @@ class TypedField(GroupedField):\n                 fieldtype = types.pop(fieldarg)\n                 if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                     typename = fieldtype[0].astext()\n-                    par.extend(self.make_xrefs(self.typerolename, domain, typename,\n-                                               addnodes.literal_emphasis, env=env))\n+                    \n+                    # Check if typename contains pipe syntax for union types\n+                    if ' | ' in typename or '|' in typename:\n+                        # Split by pipe and create separate cross-references for each type\n+                        type_parts = [part.strip() for part in typename.split('|')]\n+                        for i, type_part in enumerate(type_parts):\n+                            if i > 0:\n+                                par += nodes.Text(' | ')\n+                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n+                                                       addnodes.literal_emphasis, env=env))\n+                    else:\n+                        # Original behavior for non-union types\n+                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n+                                                   addnodes.literal_emphasis, env=env))\n+                else:\n+                    par += fieldtype\n+                par += nodes.Text(')')\n+            par += nodes.Text(' -- ')\n+            par += content\n+            return par\n                 else:\n                     par += fieldtype\n                 par += nodes.Text(')')\n",
    "variant_2": "diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..760439b0e 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -171,6 +171,17 @@ class TypedField(GroupedField):\n \n     def make_field(self, types: Dict[str, List[Node]], domain: str,\n                    items: Tuple, env: BuildEnvironment = None) -> nodes.field:\n+        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n+            par = nodes.paragraph()\n+            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n+                                       addnodes.literal_strong, env=env))\n+            if fieldarg in types:\n+                par += nodes.Text(' (')\n+                # NOTE: using .pop() here to prevent a single type node to be\n+                # inserted twice into the doctree, which leads to\n+                # inconsistencies later when references are resolved\n+                fieldtype = types.pop(fieldarg)\n+\n         def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n             par = nodes.paragraph()\n             par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n@@ -183,8 +194,26 @@ class TypedField(GroupedField):\n                 fieldtype = types.pop(fieldarg)\n                 if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                     typename = fieldtype[0].astext()\n-                    par.extend(self.make_xrefs(self.typerolename, domain, typename,\n-                                               addnodes.literal_emphasis, env=env))\n+                    \n+                    # Check if typename contains pipe syntax for union types\n+                    if ' | ' in typename or '|' in typename:\n+                        # Split by pipe and create separate cross-references for each type\n+                        type_parts = [part.strip() for part in typename.split('|')]\n+                        for i, type_part in enumerate(type_parts):\n+                            if i > 0:\n+                                par += nodes.Text(' | ')\n+                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n+                                                       addnodes.literal_emphasis, env=env))\n+                    else:\n+                        # Original behavior for non-union types\n+                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n+                                                   addnodes.literal_emphasis, env=env))\n+                else:\n+                    par += fieldtype\n+                par += nodes.Text(')')\n+            par += nodes.Text(' -- ')\n+            par += content\n+            return par\n                 else:\n                     par += fieldtype\n                 par += nodes.Text(')')\n",
    "variant_3": "diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..760439b0e 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -171,6 +171,17 @@ class TypedField(GroupedField):\n \n     def make_field(self, types: Dict[str, List[Node]], domain: str,\n                    items: Tuple, env: BuildEnvironment = None) -> nodes.field:\n+        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n+            par = nodes.paragraph()\n+            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n+                                       addnodes.literal_strong, env=env))\n+            if fieldarg in types:\n+                par += nodes.Text(' (')\n+                # NOTE: using .pop() here to prevent a single type node to be\n+                # inserted twice into the doctree, which leads to\n+                # inconsistencies later when references are resolved\n+                fieldtype = types.pop(fieldarg)\n+\n         def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n             par = nodes.paragraph()\n             par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n@@ -183,8 +194,26 @@ class TypedField(GroupedField):\n                 fieldtype = types.pop(fieldarg)\n                 if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                     typename = fieldtype[0].astext()\n-                    par.extend(self.make_xrefs(self.typerolename, domain, typename,\n-                                               addnodes.literal_emphasis, env=env))\n+                    \n+                    # Check if typename contains pipe syntax for union types\n+                    if ' | ' in typename or '|' in typename:\n+                        # Split by pipe and create separate cross-references for each type\n+                        type_parts = [part.strip() for part in typename.split('|')]\n+                        for i, type_part in enumerate(type_parts):\n+                            if i > 0:\n+                                par += nodes.Text(' | ')\n+                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n+                                                       addnodes.literal_emphasis, env=env))\n+                    else:\n+                        # Original behavior for non-union types\n+                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n+                                                   addnodes.literal_emphasis, env=env))\n+                else:\n+                    par += fieldtype\n+                par += nodes.Text(')')\n+            par += nodes.Text(' -- ')\n+            par += content\n+            return par\n                 else:\n                     par += fieldtype\n                 par += nodes.Text(')')\n",
    "variant_4": "diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..760439b0e 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -171,6 +171,17 @@ class TypedField(GroupedField):\n \n     def make_field(self, types: Dict[str, List[Node]], domain: str,\n                    items: Tuple, env: BuildEnvironment = None) -> nodes.field:\n+        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n+            par = nodes.paragraph()\n+            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n+                                       addnodes.literal_strong, env=env))\n+            if fieldarg in types:\n+                par += nodes.Text(' (')\n+                # NOTE: using .pop() here to prevent a single type node to be\n+                # inserted twice into the doctree, which leads to\n+                # inconsistencies later when references are resolved\n+                fieldtype = types.pop(fieldarg)\n+\n         def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n             par = nodes.paragraph()\n             par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n@@ -183,8 +194,26 @@ class TypedField(GroupedField):\n                 fieldtype = types.pop(fieldarg)\n                 if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                     typename = fieldtype[0].astext()\n-                    par.extend(self.make_xrefs(self.typerolename, domain, typename,\n-                                               addnodes.literal_emphasis, env=env))\n+                    \n+                    # Check if typename contains pipe syntax for union types\n+                    if ' | ' in typename or '|' in typename:\n+                        # Split by pipe and create separate cross-references for each type\n+                        type_parts = [part.strip() for part in typename.split('|')]\n+                        for i, type_part in enumerate(type_parts):\n+                            if i > 0:\n+                                par += nodes.Text(' | ')\n+                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n+                                                       addnodes.literal_emphasis, env=env))\n+                    else:\n+                        # Original behavior for non-union types\n+                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n+                                                   addnodes.literal_emphasis, env=env))\n+                else:\n+                    par += fieldtype\n+                par += nodes.Text(')')\n+            par += nodes.Text(' -- ')\n+            par += content\n+            return par\n                 else:\n                     par += fieldtype\n                 par += nodes.Text(')')\n",
    "variant_5": "diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..760439b0e 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -171,6 +171,17 @@ class TypedField(GroupedField):\n \n     def make_field(self, types: Dict[str, List[Node]], domain: str,\n                    items: Tuple, env: BuildEnvironment = None) -> nodes.field:\n+        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n+            par = nodes.paragraph()\n+            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n+                                       addnodes.literal_strong, env=env))\n+            if fieldarg in types:\n+                par += nodes.Text(' (')\n+                # NOTE: using .pop() here to prevent a single type node to be\n+                # inserted twice into the doctree, which leads to\n+                # inconsistencies later when references are resolved\n+                fieldtype = types.pop(fieldarg)\n+\n         def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n             par = nodes.paragraph()\n             par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n@@ -183,8 +194,26 @@ class TypedField(GroupedField):\n                 fieldtype = types.pop(fieldarg)\n                 if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                     typename = fieldtype[0].astext()\n-                    par.extend(self.make_xrefs(self.typerolename, domain, typename,\n-                                               addnodes.literal_emphasis, env=env))\n+                    \n+                    # Check if typename contains pipe syntax for union types\n+                    if ' | ' in typename or '|' in typename:\n+                        # Split by pipe and create separate cross-references for each type\n+                        type_parts = [part.strip() for part in typename.split('|')]\n+                        for i, type_part in enumerate(type_parts):\n+                            if i > 0:\n+                                par += nodes.Text(' | ')\n+                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n+                                                       addnodes.literal_emphasis, env=env))\n+                    else:\n+                        # Original behavior for non-union types\n+                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n+                                                   addnodes.literal_emphasis, env=env))\n+                else:\n+                    par += fieldtype\n+                par += nodes.Text(')')\n+            par += nodes.Text(' -- ')\n+            par += content\n+            return par\n                 else:\n                     par += fieldtype\n                 par += nodes.Text(')')\n",
    "variant_6": "diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..760439b0e 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -171,6 +171,17 @@ class TypedField(GroupedField):\n \n     def make_field(self, types: Dict[str, List[Node]], domain: str,\n                    items: Tuple, env: BuildEnvironment = None) -> nodes.field:\n+        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n+            par = nodes.paragraph()\n+            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n+                                       addnodes.literal_strong, env=env))\n+            if fieldarg in types:\n+                par += nodes.Text(' (')\n+                # NOTE: using .pop() here to prevent a single type node to be\n+                # inserted twice into the doctree, which leads to\n+                # inconsistencies later when references are resolved\n+                fieldtype = types.pop(fieldarg)\n+\n         def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n             par = nodes.paragraph()\n             par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n@@ -183,8 +194,26 @@ class TypedField(GroupedField):\n                 fieldtype = types.pop(fieldarg)\n                 if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                     typename = fieldtype[0].astext()\n-                    par.extend(self.make_xrefs(self.typerolename, domain, typename,\n-                                               addnodes.literal_emphasis, env=env))\n+                    \n+                    # Check if typename contains pipe syntax for union types\n+                    if ' | ' in typename or '|' in typename:\n+                        # Split by pipe and create separate cross-references for each type\n+                        type_parts = [part.strip() for part in typename.split('|')]\n+                        for i, type_part in enumerate(type_parts):\n+                            if i > 0:\n+                                par += nodes.Text(' | ')\n+                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n+                                                       addnodes.literal_emphasis, env=env))\n+                    else:\n+                        # Original behavior for non-union types\n+                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n+                                                   addnodes.literal_emphasis, env=env))\n+                else:\n+                    par += fieldtype\n+                par += nodes.Text(')')\n+            par += nodes.Text(' -- ')\n+            par += content\n+            return par\n                 else:\n                     par += fieldtype\n                 par += nodes.Text(')')\n",
    "variant_7": "diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..760439b0e 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -171,6 +171,17 @@ class TypedField(GroupedField):\n \n     def make_field(self, types: Dict[str, List[Node]], domain: str,\n                    items: Tuple, env: BuildEnvironment = None) -> nodes.field:\n+        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n+            par = nodes.paragraph()\n+            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n+                                       addnodes.literal_strong, env=env))\n+            if fieldarg in types:\n+                par += nodes.Text(' (')\n+                # NOTE: using .pop() here to prevent a single type node to be\n+                # inserted twice into the doctree, which leads to\n+                # inconsistencies later when references are resolved\n+                fieldtype = types.pop(fieldarg)\n+\n         def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n             par = nodes.paragraph()\n             par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n@@ -183,8 +194,26 @@ class TypedField(GroupedField):\n                 fieldtype = types.pop(fieldarg)\n                 if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                     typename = fieldtype[0].astext()\n-                    par.extend(self.make_xrefs(self.typerolename, domain, typename,\n-                                               addnodes.literal_emphasis, env=env))\n+                    \n+                    # Check if typename contains pipe syntax for union types\n+                    if ' | ' in typename or '|' in typename:\n+                        # Split by pipe and create separate cross-references for each type\n+                        type_parts = [part.strip() for part in typename.split('|')]\n+                        for i, type_part in enumerate(type_parts):\n+                            if i > 0:\n+                                par += nodes.Text(' | ')\n+                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n+                                                       addnodes.literal_emphasis, env=env))\n+                    else:\n+                        # Original behavior for non-union types\n+                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n+                                                   addnodes.literal_emphasis, env=env))\n+                else:\n+                    par += fieldtype\n+                par += nodes.Text(')')\n+            par += nodes.Text(' -- ')\n+            par += content\n+            return par\n                 else:\n                     par += fieldtype\n                 par += nodes.Text(')')\n",
    "variant_8": "diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..760439b0e 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -171,6 +171,17 @@ class TypedField(GroupedField):\n \n     def make_field(self, types: Dict[str, List[Node]], domain: str,\n                    items: Tuple, env: BuildEnvironment = None) -> nodes.field:\n+        def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n+            par = nodes.paragraph()\n+            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n+                                       addnodes.literal_strong, env=env))\n+            if fieldarg in types:\n+                par += nodes.Text(' (')\n+                # NOTE: using .pop() here to prevent a single type node to be\n+                # inserted twice into the doctree, which leads to\n+                # inconsistencies later when references are resolved\n+                fieldtype = types.pop(fieldarg)\n+\n         def handle_item(fieldarg: str, content: str) -> nodes.paragraph:\n             par = nodes.paragraph()\n             par.extend(self.make_xrefs(self.rolename, domain, fieldarg,\n@@ -183,8 +194,26 @@ class TypedField(GroupedField):\n                 fieldtype = types.pop(fieldarg)\n                 if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):\n                     typename = fieldtype[0].astext()\n-                    par.extend(self.make_xrefs(self.typerolename, domain, typename,\n-                                               addnodes.literal_emphasis, env=env))\n+                    \n+                    # Check if typename contains pipe syntax for union types\n+                    if ' | ' in typename or '|' in typename:\n+                        # Split by pipe and create separate cross-references for each type\n+                        type_parts = [part.strip() for part in typename.split('|')]\n+                        for i, type_part in enumerate(type_parts):\n+                            if i > 0:\n+                                par += nodes.Text(' | ')\n+                            par.extend(self.make_xrefs(self.typerolename, domain, type_part,\n+                                                       addnodes.literal_emphasis, env=env))\n+                    else:\n+                        # Original behavior for non-union types\n+                        par.extend(self.make_xrefs(self.typerolename, domain, typename,\n+                                                   addnodes.literal_emphasis, env=env))\n+                else:\n+                    par += fieldtype\n+                par += nodes.Text(')')\n+            par += nodes.Text(' -- ')\n+            par += content\n+            return par\n                 else:\n                     par += fieldtype\n                 par += nodes.Text(')')\n"
  }
}