{
  "zero_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/contour.py lines 1131-1134)": "\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            # Check if levels_arg is a boolean array and auto-detect levels\n            levels_array = np.asarray(levels_arg)\n            if levels_array.dtype == bool:\n                # For boolean arrays, use [0.5] as the default contour level\n                self.levels = np.array([0.5], dtype=np.float64)\n            else:\n                self.levels = np.asarray(levels_arg, np.float64)\n",
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/contour.py lines 1124-1130)": "\n    def _process_contour_level_args(self, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n",
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/contour.py lines 1458-1465)": "\n        z = ma.masked_invalid(z, copy=False)\n        \n        # Check if original z was boolean before conversion to float64\n        if hasattr(z, '_boolean_contour_detected'):\n            # For boolean arrays, use 0.5 as the single contour level\n            if self.levels is None:\n                self.levels = [0.5]\n        \n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            _api.warn_external('Log scale: values of z <= 0 have been masked')\n            self.zmin = float(z.min())\n        self._process_contour_level_args(args)\n",
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/contour.py lines 1144-1148)": "\n        if self.filled and len(self.levels) < 2:\n            # Allow single level for boolean arrays (auto-detected as [0.5])\n            if not (len(self.levels) == 1 and self.levels[0] == 0.5 and \n                    hasattr(self, '_boolean_data') and self._boolean_data):\n                raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")\n",
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/contour.py lines 1449-1452)": "\n        if nargs <= 2:\n            # Check if first argument is boolean array before conversion\n            first_arg = args[0]\n            is_boolean_array = (hasattr(first_arg, 'dtype') and \n                              first_arg.dtype == bool)\n            \n            z = ma.asarray(first_arg, dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n            \n            # Store boolean flag for level processing\n            if is_boolean_array:\n                self._is_boolean_data = True\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/contour.py lines 1131-1134)": [
      "\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            # Check if levels_arg is a boolean array and auto-detect appropriate levels\n            levels_array = np.asarray(levels_arg)\n            if levels_array.dtype == bool:\n                # For boolean arrays, use a single level at 0.5 to create a boundary\n                # between True (1) and False (0) regions\n                self.levels = np.array([0.5], dtype=np.float64)\n            else:\n                self.levels = np.asarray(levels_arg, np.float64)\n",
      "\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            # Check if levels_arg is a boolean array\n            levels_array = np.asarray(levels_arg)\n            if levels_array.dtype == bool:\n                # For boolean arrays, use a single contour level at 0.5\n                self.levels = np.array([0.5], dtype=np.float64)\n            else:\n                self.levels = np.asarray(levels_arg, np.float64)\n",
      "\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            # Check if levels_arg is a boolean array and auto-detect appropriate levels\n            levels_array = np.asarray(levels_arg)\n            if levels_array.dtype == bool:\n                # For boolean arrays, use a single contour at 0.5 to separate True/False regions\n                self.levels = np.array([0.5], dtype=np.float64)\n            else:\n                self.levels = np.asarray(levels_arg, np.float64)\n",
      "\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            # Check if levels_arg is a boolean array and auto-detect appropriate level\n            levels_array = np.asarray(levels_arg)\n            if levels_array.dtype == bool:\n                # For boolean arrays, use a single level at 0.5 to create clean contours\n                self.levels = np.array([0.5], dtype=np.float64)\n            else:\n                self.levels = np.asarray(levels_arg, np.float64)\n",
      "\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            # Check if levels_arg is a boolean array and auto-detect appropriate level\n            levels_array = np.asarray(levels_arg)\n            if levels_array.dtype == bool:\n                # For boolean arrays, use 0.5 as the default contour level\n                self.levels = np.array([0.5], dtype=np.float64)\n            else:\n                self.levels = np.asarray(levels_arg, np.float64)\n",
      "\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            # Check if levels_arg is a boolean array and auto-detect appropriate level\n            levels_array = np.asarray(levels_arg)\n            if levels_array.dtype == bool:\n                # For boolean arrays, use 0.5 as the default contour level\n                self.levels = np.array([0.5], dtype=np.float64)\n            else:\n                self.levels = np.asarray(levels_arg, np.float64)\n",
      "\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            # Check if levels_arg is a boolean array and auto-detect appropriate level\n            levels_array = np.asarray(levels_arg)\n            if levels_array.dtype == bool:\n                # For boolean arrays, use [0.5] as the default contour level\n                self.levels = np.array([0.5], dtype=np.float64)\n            else:\n                self.levels = np.asarray(levels_arg, np.float64)\n",
      "\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            # Check if levels_arg is a boolean array and auto-detect appropriate levels\n            levels_array = np.asarray(levels_arg)\n            if levels_array.dtype == bool:\n                # For boolean arrays, use [0.5] as the default contour level\n                self.levels = np.array([0.5], np.float64)\n            else:\n                self.levels = np.asarray(levels_arg, np.float64)\n"
    ],
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/contour.py lines 1124-1130)": [
      "\n    def _process_contour_level_args(self, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n",
      "\n    def _process_contour_level_args(self, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n",
      "\n    def _process_contour_level_args(self, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n",
      "\n    def _process_contour_level_args(self, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n",
      "\n    def _process_contour_level_args(self, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n        \n        # Auto-detect boolean arrays and set appropriate default level\n        if hasattr(levels_arg, 'dtype') and levels_arg.dtype == bool:\n            self.levels = np.array([0.5])\n            return\n            \n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            self.levels = np.asarray(levels_arg, np.float64)\n",
      "\n    def _process_contour_level_args(self, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n        \n        # Check if levels_arg is a boolean array and auto-set levels to [0.5]\n        if hasattr(levels_arg, 'dtype') and levels_arg.dtype == bool:\n            self.levels = np.array([0.5])\n        elif isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            self.levels = np.asarray(levels_arg, np.float64)\n",
      "\n    def _process_contour_level_args(self, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n",
      "\n    def _process_contour_level_args(self, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n"
    ],
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/contour.py lines 1458-1465)": [
      "\n        z = ma.masked_invalid(z, copy=False)\n        # Check if original data was boolean before conversion to float64\n        original_z_dtype = getattr(z, '_original_dtype', z.dtype)\n        is_boolean_data = original_z_dtype == bool or (hasattr(z, 'dtype') and z.dtype == bool)\n        \n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            _api.warn_external('Log scale: values of z <= 0 have been masked')\n            self.zmin = float(z.min())\n        \n        # Store boolean flag for level processing\n        self._is_boolean_data = is_boolean_data\n        self._process_contour_level_args(args)\n",
      "\n        z = ma.masked_invalid(z, copy=False)\n        # Check if original z was boolean before conversion to float64\n        if hasattr(z, '_matplotlib_original_dtype') and z._matplotlib_original_dtype == bool:\n            # For boolean arrays, use a single contour at 0.5 by default\n            if not hasattr(self, '_levels_explicitly_set') or not self._levels_explicitly_set:\n                self.levels = [0.5]\n        \n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            _api.warn_external('Log scale: values of z <= 0 have been masked')\n            self.zmin = float(z.min())\n        self._process_contour_level_args(args)\n",
      "\n        z = ma.masked_invalid(z, copy=False)\n        # Check if original z was boolean before conversion to float64\n        if hasattr(z, 'dtype') and z.dtype == bool:\n            self._is_boolean_data = True\n        else:\n            self._is_boolean_data = False\n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            _api.warn_external('Log scale: values of z <= 0 have been masked')\n            self.zmin = float(z.min())\n        self._process_contour_level_args(args)\n",
      "\n        z = ma.masked_invalid(z, copy=False)\n        \n        # Check if original data was boolean before conversion to float64\n        if hasattr(z, '_original_dtype') and z._original_dtype == bool:\n            # For boolean arrays, use 0.5 as the default contour level\n            if self.levels is None:\n                self.levels = [0.5]\n        \n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            _api.warn_external('Log scale: values of z <= 0 have been masked')\n            self.zmin = float(z.min())\n        self._process_contour_level_args(args)\n",
      "\n        z = ma.masked_invalid(z, copy=False)\n        # Check if original z was boolean before conversion to float64\n        if hasattr(z, '_original_dtype') and z._original_dtype == bool:\n            # For boolean arrays, use 0.5 as the default level\n            if not hasattr(self, '_boolean_array_detected'):\n                self._boolean_array_detected = True\n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            _api.warn_external('Log scale: values of z <= 0 have been masked')\n            self.zmin = float(z.min())\n        self._process_contour_level_args(args)\n",
      "\n        z = ma.masked_invalid(z, copy=False)\n        # Check if original z was boolean before conversion to float64\n        if hasattr(z, '_boolean_array_detected'):\n            # For boolean arrays, use 0.5 as the single contour level\n            if not hasattr(self, 'levels') or self.levels is None:\n                self.levels = [0.5]\n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            _api.warn_external('Log scale: values of z <= 0 have been masked')\n            self.zmin = float(z.min())\n        self._process_contour_level_args(args)\n",
      "\n        z = ma.masked_invalid(z, copy=False)\n        # Check if original z was boolean before conversion to float64\n        if hasattr(z, '_boolean_contour_data') and z._boolean_contour_data:\n            # For boolean arrays, use 0.5 as the single contour level\n            if not hasattr(self, '_levels_set_explicitly'):\n                self.levels = [0.5]\n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            _api.warn_external('Log scale: values of z <= 0 have been masked')\n            self.zmin = float(z.min())\n        self._process_contour_level_args(args)\n",
      "\n        z = ma.masked_invalid(z, copy=False)\n        \n        # Check if original z was boolean before conversion to float64\n        if hasattr(z, '_original_dtype') and z._original_dtype == bool:\n            # For boolean arrays, use 0.5 as the default level if no levels specified\n            if self.levels is None and not hasattr(self, '_levels_specified'):\n                self.levels = [0.5]\n        \n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            _api.warn_external('Log scale: values of z <= 0 have been masked')\n            self.zmin = float(z.min())\n        self._process_contour_level_args(args)\n"
    ],
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/contour.py lines 1144-1148)": [
      "\n        if self.filled and len(self.levels) < 2:\n            # Special case: allow single level for boolean arrays (auto-detected as [0.5])\n            if not (len(self.levels) == 1 and self.levels[0] == 0.5 and \n                    hasattr(self, '_boolean_array_detected') and self._boolean_array_detected):\n                raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")\n",
      "\n        if self.filled and len(self.levels) < 2:\n            # Allow boolean arrays with single level [0.5] for filled contours\n            if hasattr(self, '_is_boolean_data') and self._is_boolean_data and len(self.levels) == 1:\n                pass  # Boolean data with single level is acceptable\n            else:\n                raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")\n",
      "\n        if self.filled and len(self.levels) < 2:\n            # Allow single level for boolean arrays (auto-detected as [0.5])\n            if not (len(self.levels) == 1 and np.allclose(self.levels, [0.5])):\n                raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")\n",
      "\n        if self.filled and len(self.levels) < 2:\n            # Allow boolean arrays with auto-detected single level [0.5]\n            if hasattr(self, '_boolean_data') and self._boolean_data:\n                pass  # Boolean data with single level is acceptable\n            else:\n                raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")\n",
      "\n        if self.filled and len(self.levels) < 2:\n            # Allow single level for boolean arrays (auto-detected as [0.5])\n            if not (len(self.levels) == 1 and self.levels[0] == 0.5 and \n                    hasattr(self, '_boolean_data') and self._boolean_data):\n                raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")\n",
      "\n        if self.filled and len(self.levels) < 2:\n            # Allow single level for boolean arrays (auto-detected as [0.5])\n            if hasattr(self, '_boolean_array_detected') and self._boolean_array_detected:\n                pass  # Single level [0.5] is valid for boolean arrays\n            else:\n                raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")\n",
      "\n        if self.filled and len(self.levels) < 2:\n            # Allow single level for boolean arrays (auto-detected as [0.5])\n            if not (len(self.levels) == 1 and self.levels[0] == 0.5 and \n                    hasattr(self, '_boolean_data') and self._boolean_data):\n                raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")\n",
      "\n        if self.filled and len(self.levels) < 2:\n            # Allow boolean arrays with auto-detected single level [0.5]\n            if hasattr(self, '_boolean_array_detected') and self._boolean_array_detected:\n                pass  # Boolean arrays are allowed with single level\n            else:\n                raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")\n"
    ],
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/contour.py lines 1449-1452)": [
      "\n        if nargs <= 2:\n            z_arg = args[0]\n            # Check if the input is a boolean array before converting to float64\n            if hasattr(z_arg, 'dtype') and np.issubdtype(z_arg.dtype, np.bool_):\n                # Store boolean flag for later level processing\n                self._input_is_boolean = True\n                z = ma.asarray(z_arg, dtype=np.float64)\n            else:\n                self._input_is_boolean = False\n                z = ma.asarray(z_arg, dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n",
      "\n        if nargs <= 2:\n            z_arg = args[0]\n            # Check if input is boolean before converting to float64\n            is_boolean_input = (hasattr(z_arg, 'dtype') and \n                               np.issubdtype(z_arg.dtype, np.bool_)) or \\\n                              (isinstance(z_arg, (list, tuple)) and \n                               all(isinstance(x, (bool, np.bool_)) for row in z_arg for x in (row if hasattr(row, '__iter__') and not isinstance(row, str) else [row])))\n            \n            z = ma.asarray(z_arg, dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n            \n            # Store boolean flag for level processing\n            if not hasattr(self, '_is_boolean_input'):\n                self._is_boolean_input = is_boolean_input\n",
      "\n        if nargs <= 2:\n            z_arg = args[0]\n            # Preserve boolean dtype for auto-level detection\n            if hasattr(z_arg, 'dtype') and z_arg.dtype == bool:\n                z = ma.asarray(z_arg, dtype=bool)\n            else:\n                z = ma.asarray(z_arg, dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n",
      "\n        if nargs <= 2:\n            z_arg = args[0]\n            # Check if this is a boolean array before converting to float64\n            if hasattr(z_arg, 'dtype') and np.issubdtype(z_arg.dtype, np.bool_):\n                self._boolean_array_detected = True\n            z = ma.asarray(z_arg, dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n",
      "\n        if nargs <= 2:\n            z_input = args[0]\n            # Check if input is boolean before converting to float64\n            if hasattr(z_input, 'dtype') and z_input.dtype == bool:\n                self._boolean_input = True\n            z = ma.asarray(z_input, dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n",
      "\n        if nargs <= 2:\n            z_raw = args[0]  # Preserve original data for boolean detection\n            z = ma.asarray(z_raw, dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n",
      "\n        if nargs <= 2:\n            z_orig = args[0]  # Keep original for boolean detection\n            z = ma.asarray(args[0], dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n            # Store original array info for boolean detection in level processing\n            if hasattr(z_orig, 'dtype') and z_orig.dtype == bool:\n                self._input_was_boolean = True\n",
      "\n        if nargs <= 2:\n            z_original = args[0]  # Keep original for boolean detection\n            z = ma.asarray(args[0], dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n            # Store original z for boolean detection in level processing\n            if hasattr(z_original, 'dtype') and z_original.dtype == bool:\n                self._original_z_dtype = bool\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 144eadeae2..79b2ee8fc3 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1121,6 +1121,7 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n         \"\"\"\n         Determine the contour levels and store in self.levels.\n         \"\"\"\n+\n         if self.levels is None:\n             if len(args) == 0:\n                 levels_arg = 7  # Default, hard-wired.\n@@ -1128,10 +1129,17 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 levels_arg = args[0]\n         else:\n             levels_arg = self.levels\n+\n         if isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n-            self.levels = np.asarray(levels_arg, np.float64)\n+            # Check if levels_arg is a boolean array and auto-detect appropriate level\n+            levels_array = np.asarray(levels_arg)\n+            if levels_array.dtype == bool:\n+                # For boolean arrays, use a single level at 0.5\n+                self.levels = np.array([0.5])\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n \n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n@@ -1141,7 +1149,14 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 _api.warn_external(\n                     \"No contour levels were found within the data range.\")\n \n-        if self.filled and len(self.levels) < 2:\n+\n+        # Check if this is a boolean array case with auto-detected single level\n+        is_bool_auto_level = (len(self.levels) == 1 and \n+                             np.allclose(self.levels, [0.5]) and\n+                             hasattr(self, '_is_boolean_data') and \n+                             getattr(self, '_is_boolean_data', False))\n+        \n+        if self.filled and len(self.levels) < 2 and not is_bool_auto_level:\n             raise ValueError(\"Filled contours require at least 2 levels.\")\n \n         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n@@ -1446,7 +1461,12 @@ class QuadContourSet(ContourSet):\n         else:\n             fn = 'contour'\n         nargs = len(args)\n+\n         if nargs <= 2:\n+            # Preserve boolean dtype information for auto-detection\n+            z_orig = ma.asarray(args[0])\n+            if z_orig.dtype == bool:\n+                self._is_boolean_data = True\n             z = ma.asarray(args[0], dtype=np.float64)\n             x, y = self._initialize_x_y(z)\n             args = args[1:]\n@@ -1455,6 +1475,7 @@ class QuadContourSet(ContourSet):\n             args = args[3:]\n         else:\n             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n+\n         z = ma.masked_invalid(z, copy=False)\n         self.zmax = float(z.max())\n         self.zmin = float(z.min())\n",
    "variant_0": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 144eadeae2..8f1d63ecee 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1117,6 +1117,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n \n         return lev[i0:i1]\n \n+    def _process_contour_level_args(self, args):\n+        \"\"\"\n+        Determine the contour levels and store in self.levels.\n+        \"\"\"\n+\n     def _process_contour_level_args(self, args):\n         \"\"\"\n         Determine the contour levels and store in self.levels.\n@@ -1128,10 +1133,17 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 levels_arg = args[0]\n         else:\n             levels_arg = self.levels\n+\n         if isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n-            self.levels = np.asarray(levels_arg, np.float64)\n+            # Check if levels_arg is a boolean array and auto-detect levels\n+            levels_array = np.asarray(levels_arg)\n+            if levels_array.dtype == bool:\n+                # For boolean arrays, use [0.5] as the default contour level\n+                self.levels = np.array([0.5], dtype=np.float64)\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n \n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n@@ -1141,8 +1153,12 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 _api.warn_external(\n                     \"No contour levels were found within the data range.\")\n \n+\n         if self.filled and len(self.levels) < 2:\n-            raise ValueError(\"Filled contours require at least 2 levels.\")\n+            # Allow single level for boolean arrays (auto-detected as [0.5])\n+            if not (len(self.levels) == 1 and self.levels[0] == 0.5 and \n+                    hasattr(self, '_boolean_data') and self._boolean_data):\n+                raise ValueError(\"Filled contours require at least 2 levels.\")\n \n         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n             raise ValueError(\"Contour levels must be increasing\")\n@@ -1446,16 +1462,34 @@ class QuadContourSet(ContourSet):\n         else:\n             fn = 'contour'\n         nargs = len(args)\n+\n         if nargs <= 2:\n-            z = ma.asarray(args[0], dtype=np.float64)\n+            # Check if first argument is boolean array before conversion\n+            first_arg = args[0]\n+            is_boolean_array = (hasattr(first_arg, 'dtype') and \n+                              first_arg.dtype == bool)\n+            \n+            z = ma.asarray(first_arg, dtype=np.float64)\n             x, y = self._initialize_x_y(z)\n             args = args[1:]\n+            \n+            # Store boolean flag for level processing\n+            if is_boolean_array:\n+                self._is_boolean_data = True\n         elif nargs <= 4:\n             x, y, z = self._check_xyz(args[:3], kwargs)\n             args = args[3:]\n         else:\n             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n+\n         z = ma.masked_invalid(z, copy=False)\n+        \n+        # Check if original z was boolean before conversion to float64\n+        if hasattr(z, '_boolean_contour_detected'):\n+            # For boolean arrays, use 0.5 as the single contour level\n+            if self.levels is None:\n+                self.levels = [0.5]\n+        \n         self.zmax = float(z.max())\n         self.zmin = float(z.min())\n         if self.logscale and self.zmin <= 0:\n",
    "variant_1": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 144eadeae2..af493b84ba 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1117,6 +1117,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n \n         return lev[i0:i1]\n \n+    def _process_contour_level_args(self, args):\n+        \"\"\"\n+        Determine the contour levels and store in self.levels.\n+        \"\"\"\n+\n     def _process_contour_level_args(self, args):\n         \"\"\"\n         Determine the contour levels and store in self.levels.\n@@ -1128,10 +1133,18 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 levels_arg = args[0]\n         else:\n             levels_arg = self.levels\n+\n         if isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n-            self.levels = np.asarray(levels_arg, np.float64)\n+            # Check if levels_arg is a boolean array and auto-detect appropriate levels\n+            levels_array = np.asarray(levels_arg)\n+            if levels_array.dtype == bool:\n+                # For boolean arrays, use a single level at 0.5 to create a boundary\n+                # between True (1) and False (0) regions\n+                self.levels = np.array([0.5], dtype=np.float64)\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n \n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n@@ -1141,8 +1154,12 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 _api.warn_external(\n                     \"No contour levels were found within the data range.\")\n \n+\n         if self.filled and len(self.levels) < 2:\n-            raise ValueError(\"Filled contours require at least 2 levels.\")\n+            # Special case: allow single level for boolean arrays (auto-detected as [0.5])\n+            if not (len(self.levels) == 1 and self.levels[0] == 0.5 and \n+                    hasattr(self, '_boolean_array_detected') and self._boolean_array_detected):\n+                raise ValueError(\"Filled contours require at least 2 levels.\")\n \n         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n             raise ValueError(\"Contour levels must be increasing\")\n@@ -1446,8 +1463,17 @@ class QuadContourSet(ContourSet):\n         else:\n             fn = 'contour'\n         nargs = len(args)\n+\n         if nargs <= 2:\n-            z = ma.asarray(args[0], dtype=np.float64)\n+            z_arg = args[0]\n+            # Check if the input is a boolean array before converting to float64\n+            if hasattr(z_arg, 'dtype') and np.issubdtype(z_arg.dtype, np.bool_):\n+                # Store boolean flag for later level processing\n+                self._input_is_boolean = True\n+                z = ma.asarray(z_arg, dtype=np.float64)\n+            else:\n+                self._input_is_boolean = False\n+                z = ma.asarray(z_arg, dtype=np.float64)\n             x, y = self._initialize_x_y(z)\n             args = args[1:]\n         elif nargs <= 4:\n@@ -1455,13 +1481,21 @@ class QuadContourSet(ContourSet):\n             args = args[3:]\n         else:\n             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n+\n         z = ma.masked_invalid(z, copy=False)\n+        # Check if original data was boolean before conversion to float64\n+        original_z_dtype = getattr(z, '_original_dtype', z.dtype)\n+        is_boolean_data = original_z_dtype == bool or (hasattr(z, 'dtype') and z.dtype == bool)\n+        \n         self.zmax = float(z.max())\n         self.zmin = float(z.min())\n         if self.logscale and self.zmin <= 0:\n             z = ma.masked_where(z <= 0, z)\n             _api.warn_external('Log scale: values of z <= 0 have been masked')\n             self.zmin = float(z.min())\n+        \n+        # Store boolean flag for level processing\n+        self._is_boolean_data = is_boolean_data\n         self._process_contour_level_args(args)\n         return (x, y, z)\n \n",
    "variant_2": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 144eadeae2..b1d470d83f 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1117,6 +1117,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n \n         return lev[i0:i1]\n \n+    def _process_contour_level_args(self, args):\n+        \"\"\"\n+        Determine the contour levels and store in self.levels.\n+        \"\"\"\n+\n     def _process_contour_level_args(self, args):\n         \"\"\"\n         Determine the contour levels and store in self.levels.\n@@ -1128,10 +1133,17 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 levels_arg = args[0]\n         else:\n             levels_arg = self.levels\n+\n         if isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n-            self.levels = np.asarray(levels_arg, np.float64)\n+            # Check if levels_arg is a boolean array\n+            levels_array = np.asarray(levels_arg)\n+            if levels_array.dtype == bool:\n+                # For boolean arrays, use a single contour level at 0.5\n+                self.levels = np.array([0.5], dtype=np.float64)\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n \n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n@@ -1141,8 +1153,13 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 _api.warn_external(\n                     \"No contour levels were found within the data range.\")\n \n+\n         if self.filled and len(self.levels) < 2:\n-            raise ValueError(\"Filled contours require at least 2 levels.\")\n+            # Allow boolean arrays with single level [0.5] for filled contours\n+            if hasattr(self, '_is_boolean_data') and self._is_boolean_data and len(self.levels) == 1:\n+                pass  # Boolean data with single level is acceptable\n+            else:\n+                raise ValueError(\"Filled contours require at least 2 levels.\")\n \n         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n             raise ValueError(\"Contour levels must be increasing\")\n@@ -1446,16 +1463,35 @@ class QuadContourSet(ContourSet):\n         else:\n             fn = 'contour'\n         nargs = len(args)\n+\n         if nargs <= 2:\n-            z = ma.asarray(args[0], dtype=np.float64)\n+            z_arg = args[0]\n+            # Check if input is boolean before converting to float64\n+            is_boolean_input = (hasattr(z_arg, 'dtype') and \n+                               np.issubdtype(z_arg.dtype, np.bool_)) or \\\n+                              (isinstance(z_arg, (list, tuple)) and \n+                               all(isinstance(x, (bool, np.bool_)) for row in z_arg for x in (row if hasattr(row, '__iter__') and not isinstance(row, str) else [row])))\n+            \n+            z = ma.asarray(z_arg, dtype=np.float64)\n             x, y = self._initialize_x_y(z)\n             args = args[1:]\n+            \n+            # Store boolean flag for level processing\n+            if not hasattr(self, '_is_boolean_input'):\n+                self._is_boolean_input = is_boolean_input\n         elif nargs <= 4:\n             x, y, z = self._check_xyz(args[:3], kwargs)\n             args = args[3:]\n         else:\n             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n+\n         z = ma.masked_invalid(z, copy=False)\n+        # Check if original z was boolean before conversion to float64\n+        if hasattr(z, '_matplotlib_original_dtype') and z._matplotlib_original_dtype == bool:\n+            # For boolean arrays, use a single contour at 0.5 by default\n+            if not hasattr(self, '_levels_explicitly_set') or not self._levels_explicitly_set:\n+                self.levels = [0.5]\n+        \n         self.zmax = float(z.max())\n         self.zmin = float(z.min())\n         if self.logscale and self.zmin <= 0:\n",
    "variant_3": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 144eadeae2..4eaa892a77 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1117,6 +1117,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n \n         return lev[i0:i1]\n \n+    def _process_contour_level_args(self, args):\n+        \"\"\"\n+        Determine the contour levels and store in self.levels.\n+        \"\"\"\n+\n     def _process_contour_level_args(self, args):\n         \"\"\"\n         Determine the contour levels and store in self.levels.\n@@ -1128,10 +1133,17 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 levels_arg = args[0]\n         else:\n             levels_arg = self.levels\n+\n         if isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n-            self.levels = np.asarray(levels_arg, np.float64)\n+            # Check if levels_arg is a boolean array and auto-detect appropriate levels\n+            levels_array = np.asarray(levels_arg)\n+            if levels_array.dtype == bool:\n+                # For boolean arrays, use a single contour at 0.5 to separate True/False regions\n+                self.levels = np.array([0.5], dtype=np.float64)\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n \n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n@@ -1141,8 +1153,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 _api.warn_external(\n                     \"No contour levels were found within the data range.\")\n \n+\n         if self.filled and len(self.levels) < 2:\n-            raise ValueError(\"Filled contours require at least 2 levels.\")\n+            # Allow single level for boolean arrays (auto-detected as [0.5])\n+            if not (len(self.levels) == 1 and np.allclose(self.levels, [0.5])):\n+                raise ValueError(\"Filled contours require at least 2 levels.\")\n \n         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n             raise ValueError(\"Contour levels must be increasing\")\n@@ -1446,8 +1461,14 @@ class QuadContourSet(ContourSet):\n         else:\n             fn = 'contour'\n         nargs = len(args)\n+\n         if nargs <= 2:\n-            z = ma.asarray(args[0], dtype=np.float64)\n+            z_arg = args[0]\n+            # Preserve boolean dtype for auto-level detection\n+            if hasattr(z_arg, 'dtype') and z_arg.dtype == bool:\n+                z = ma.asarray(z_arg, dtype=bool)\n+            else:\n+                z = ma.asarray(z_arg, dtype=np.float64)\n             x, y = self._initialize_x_y(z)\n             args = args[1:]\n         elif nargs <= 4:\n@@ -1455,7 +1476,13 @@ class QuadContourSet(ContourSet):\n             args = args[3:]\n         else:\n             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n+\n         z = ma.masked_invalid(z, copy=False)\n+        # Check if original z was boolean before conversion to float64\n+        if hasattr(z, 'dtype') and z.dtype == bool:\n+            self._is_boolean_data = True\n+        else:\n+            self._is_boolean_data = False\n         self.zmax = float(z.max())\n         self.zmin = float(z.min())\n         if self.logscale and self.zmin <= 0:\n",
    "variant_4": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 144eadeae2..8e26e1816a 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1117,6 +1117,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n \n         return lev[i0:i1]\n \n+    def _process_contour_level_args(self, args):\n+        \"\"\"\n+        Determine the contour levels and store in self.levels.\n+        \"\"\"\n+\n     def _process_contour_level_args(self, args):\n         \"\"\"\n         Determine the contour levels and store in self.levels.\n@@ -1128,10 +1133,17 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 levels_arg = args[0]\n         else:\n             levels_arg = self.levels\n+\n         if isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n-            self.levels = np.asarray(levels_arg, np.float64)\n+            # Check if levels_arg is a boolean array and auto-detect appropriate level\n+            levels_array = np.asarray(levels_arg)\n+            if levels_array.dtype == bool:\n+                # For boolean arrays, use a single level at 0.5 to create clean contours\n+                self.levels = np.array([0.5], dtype=np.float64)\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n \n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n@@ -1141,8 +1153,13 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 _api.warn_external(\n                     \"No contour levels were found within the data range.\")\n \n+\n         if self.filled and len(self.levels) < 2:\n-            raise ValueError(\"Filled contours require at least 2 levels.\")\n+            # Allow boolean arrays with auto-detected single level [0.5]\n+            if hasattr(self, '_boolean_data') and self._boolean_data:\n+                pass  # Boolean data with single level is acceptable\n+            else:\n+                raise ValueError(\"Filled contours require at least 2 levels.\")\n \n         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n             raise ValueError(\"Contour levels must be increasing\")\n@@ -1446,8 +1463,13 @@ class QuadContourSet(ContourSet):\n         else:\n             fn = 'contour'\n         nargs = len(args)\n+\n         if nargs <= 2:\n-            z = ma.asarray(args[0], dtype=np.float64)\n+            z_arg = args[0]\n+            # Check if this is a boolean array before converting to float64\n+            if hasattr(z_arg, 'dtype') and np.issubdtype(z_arg.dtype, np.bool_):\n+                self._boolean_array_detected = True\n+            z = ma.asarray(z_arg, dtype=np.float64)\n             x, y = self._initialize_x_y(z)\n             args = args[1:]\n         elif nargs <= 4:\n@@ -1455,7 +1477,15 @@ class QuadContourSet(ContourSet):\n             args = args[3:]\n         else:\n             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n+\n         z = ma.masked_invalid(z, copy=False)\n+        \n+        # Check if original data was boolean before conversion to float64\n+        if hasattr(z, '_original_dtype') and z._original_dtype == bool:\n+            # For boolean arrays, use 0.5 as the default contour level\n+            if self.levels is None:\n+                self.levels = [0.5]\n+        \n         self.zmax = float(z.max())\n         self.zmin = float(z.min())\n         if self.logscale and self.zmin <= 0:\n",
    "variant_5": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 144eadeae2..8d5d22e448 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1117,6 +1117,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n \n         return lev[i0:i1]\n \n+    def _process_contour_level_args(self, args):\n+        \"\"\"\n+        Determine the contour levels and store in self.levels.\n+        \"\"\"\n+\n     def _process_contour_level_args(self, args):\n         \"\"\"\n         Determine the contour levels and store in self.levels.\n@@ -1128,11 +1133,28 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 levels_arg = args[0]\n         else:\n             levels_arg = self.levels\n+        \n+        # Auto-detect boolean arrays and set appropriate default level\n+        if hasattr(levels_arg, 'dtype') and levels_arg.dtype == bool:\n+            self.levels = np.array([0.5])\n+            return\n+            \n         if isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n             self.levels = np.asarray(levels_arg, np.float64)\n \n+        if isinstance(levels_arg, Integral):\n+            self.levels = self._autolev(levels_arg)\n+        else:\n+            # Check if levels_arg is a boolean array and auto-detect appropriate level\n+            levels_array = np.asarray(levels_arg)\n+            if levels_array.dtype == bool:\n+                # For boolean arrays, use 0.5 as the default contour level\n+                self.levels = np.array([0.5], dtype=np.float64)\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n+\n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n             levels_in = self.levels[inside]\n@@ -1141,8 +1163,12 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 _api.warn_external(\n                     \"No contour levels were found within the data range.\")\n \n+\n         if self.filled and len(self.levels) < 2:\n-            raise ValueError(\"Filled contours require at least 2 levels.\")\n+            # Allow single level for boolean arrays (auto-detected as [0.5])\n+            if not (len(self.levels) == 1 and self.levels[0] == 0.5 and \n+                    hasattr(self, '_boolean_data') and self._boolean_data):\n+                raise ValueError(\"Filled contours require at least 2 levels.\")\n \n         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n             raise ValueError(\"Contour levels must be increasing\")\n@@ -1446,8 +1472,13 @@ class QuadContourSet(ContourSet):\n         else:\n             fn = 'contour'\n         nargs = len(args)\n+\n         if nargs <= 2:\n-            z = ma.asarray(args[0], dtype=np.float64)\n+            z_input = args[0]\n+            # Check if input is boolean before converting to float64\n+            if hasattr(z_input, 'dtype') and z_input.dtype == bool:\n+                self._boolean_input = True\n+            z = ma.asarray(z_input, dtype=np.float64)\n             x, y = self._initialize_x_y(z)\n             args = args[1:]\n         elif nargs <= 4:\n@@ -1455,7 +1486,13 @@ class QuadContourSet(ContourSet):\n             args = args[3:]\n         else:\n             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n+\n         z = ma.masked_invalid(z, copy=False)\n+        # Check if original z was boolean before conversion to float64\n+        if hasattr(z, '_original_dtype') and z._original_dtype == bool:\n+            # For boolean arrays, use 0.5 as the default level\n+            if not hasattr(self, '_boolean_array_detected'):\n+                self._boolean_array_detected = True\n         self.zmax = float(z.max())\n         self.zmin = float(z.min())\n         if self.logscale and self.zmin <= 0:\n",
    "variant_6": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 144eadeae2..7ce23f821e 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1117,6 +1117,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n \n         return lev[i0:i1]\n \n+    def _process_contour_level_args(self, args):\n+        \"\"\"\n+        Determine the contour levels and store in self.levels.\n+        \"\"\"\n+\n     def _process_contour_level_args(self, args):\n         \"\"\"\n         Determine the contour levels and store in self.levels.\n@@ -1128,11 +1133,26 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 levels_arg = args[0]\n         else:\n             levels_arg = self.levels\n-        if isinstance(levels_arg, Integral):\n+        \n+        # Check if levels_arg is a boolean array and auto-set levels to [0.5]\n+        if hasattr(levels_arg, 'dtype') and levels_arg.dtype == bool:\n+            self.levels = np.array([0.5])\n+        elif isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n             self.levels = np.asarray(levels_arg, np.float64)\n \n+        if isinstance(levels_arg, Integral):\n+            self.levels = self._autolev(levels_arg)\n+        else:\n+            # Check if levels_arg is a boolean array and auto-detect appropriate level\n+            levels_array = np.asarray(levels_arg)\n+            if levels_array.dtype == bool:\n+                # For boolean arrays, use 0.5 as the default contour level\n+                self.levels = np.array([0.5], dtype=np.float64)\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n+\n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n             levels_in = self.levels[inside]\n@@ -1141,8 +1161,13 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 _api.warn_external(\n                     \"No contour levels were found within the data range.\")\n \n+\n         if self.filled and len(self.levels) < 2:\n-            raise ValueError(\"Filled contours require at least 2 levels.\")\n+            # Allow single level for boolean arrays (auto-detected as [0.5])\n+            if hasattr(self, '_boolean_array_detected') and self._boolean_array_detected:\n+                pass  # Single level [0.5] is valid for boolean arrays\n+            else:\n+                raise ValueError(\"Filled contours require at least 2 levels.\")\n \n         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n             raise ValueError(\"Contour levels must be increasing\")\n@@ -1446,8 +1471,10 @@ class QuadContourSet(ContourSet):\n         else:\n             fn = 'contour'\n         nargs = len(args)\n+\n         if nargs <= 2:\n-            z = ma.asarray(args[0], dtype=np.float64)\n+            z_raw = args[0]  # Preserve original data for boolean detection\n+            z = ma.asarray(z_raw, dtype=np.float64)\n             x, y = self._initialize_x_y(z)\n             args = args[1:]\n         elif nargs <= 4:\n@@ -1455,7 +1482,13 @@ class QuadContourSet(ContourSet):\n             args = args[3:]\n         else:\n             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n+\n         z = ma.masked_invalid(z, copy=False)\n+        # Check if original z was boolean before conversion to float64\n+        if hasattr(z, '_boolean_array_detected'):\n+            # For boolean arrays, use 0.5 as the single contour level\n+            if not hasattr(self, 'levels') or self.levels is None:\n+                self.levels = [0.5]\n         self.zmax = float(z.max())\n         self.zmin = float(z.min())\n         if self.logscale and self.zmin <= 0:\n",
    "variant_7": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 144eadeae2..af81bf15df 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1117,6 +1117,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n \n         return lev[i0:i1]\n \n+    def _process_contour_level_args(self, args):\n+        \"\"\"\n+        Determine the contour levels and store in self.levels.\n+        \"\"\"\n+\n     def _process_contour_level_args(self, args):\n         \"\"\"\n         Determine the contour levels and store in self.levels.\n@@ -1128,10 +1133,17 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 levels_arg = args[0]\n         else:\n             levels_arg = self.levels\n+\n         if isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n-            self.levels = np.asarray(levels_arg, np.float64)\n+            # Check if levels_arg is a boolean array and auto-detect appropriate level\n+            levels_array = np.asarray(levels_arg)\n+            if levels_array.dtype == bool:\n+                # For boolean arrays, use [0.5] as the default contour level\n+                self.levels = np.array([0.5], dtype=np.float64)\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n \n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n@@ -1141,8 +1153,12 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 _api.warn_external(\n                     \"No contour levels were found within the data range.\")\n \n+\n         if self.filled and len(self.levels) < 2:\n-            raise ValueError(\"Filled contours require at least 2 levels.\")\n+            # Allow single level for boolean arrays (auto-detected as [0.5])\n+            if not (len(self.levels) == 1 and self.levels[0] == 0.5 and \n+                    hasattr(self, '_boolean_data') and self._boolean_data):\n+                raise ValueError(\"Filled contours require at least 2 levels.\")\n \n         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n             raise ValueError(\"Contour levels must be increasing\")\n@@ -1446,16 +1462,27 @@ class QuadContourSet(ContourSet):\n         else:\n             fn = 'contour'\n         nargs = len(args)\n+\n         if nargs <= 2:\n+            z_orig = args[0]  # Keep original for boolean detection\n             z = ma.asarray(args[0], dtype=np.float64)\n             x, y = self._initialize_x_y(z)\n             args = args[1:]\n+            # Store original array info for boolean detection in level processing\n+            if hasattr(z_orig, 'dtype') and z_orig.dtype == bool:\n+                self._input_was_boolean = True\n         elif nargs <= 4:\n             x, y, z = self._check_xyz(args[:3], kwargs)\n             args = args[3:]\n         else:\n             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n+\n         z = ma.masked_invalid(z, copy=False)\n+        # Check if original z was boolean before conversion to float64\n+        if hasattr(z, '_boolean_contour_data') and z._boolean_contour_data:\n+            # For boolean arrays, use 0.5 as the single contour level\n+            if not hasattr(self, '_levels_set_explicitly'):\n+                self.levels = [0.5]\n         self.zmax = float(z.max())\n         self.zmin = float(z.min())\n         if self.logscale and self.zmin <= 0:\n",
    "variant_8": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 144eadeae2..529579e7c4 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -1117,6 +1117,11 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n \n         return lev[i0:i1]\n \n+    def _process_contour_level_args(self, args):\n+        \"\"\"\n+        Determine the contour levels and store in self.levels.\n+        \"\"\"\n+\n     def _process_contour_level_args(self, args):\n         \"\"\"\n         Determine the contour levels and store in self.levels.\n@@ -1128,10 +1133,17 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 levels_arg = args[0]\n         else:\n             levels_arg = self.levels\n+\n         if isinstance(levels_arg, Integral):\n             self.levels = self._autolev(levels_arg)\n         else:\n-            self.levels = np.asarray(levels_arg, np.float64)\n+            # Check if levels_arg is a boolean array and auto-detect appropriate levels\n+            levels_array = np.asarray(levels_arg)\n+            if levels_array.dtype == bool:\n+                # For boolean arrays, use [0.5] as the default contour level\n+                self.levels = np.array([0.5], np.float64)\n+            else:\n+                self.levels = np.asarray(levels_arg, np.float64)\n \n         if not self.filled:\n             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n@@ -1141,8 +1153,13 @@ class ContourSet(cm.ScalarMappable, ContourLabeler):\n                 _api.warn_external(\n                     \"No contour levels were found within the data range.\")\n \n+\n         if self.filled and len(self.levels) < 2:\n-            raise ValueError(\"Filled contours require at least 2 levels.\")\n+            # Allow boolean arrays with auto-detected single level [0.5]\n+            if hasattr(self, '_boolean_array_detected') and self._boolean_array_detected:\n+                pass  # Boolean arrays are allowed with single level\n+            else:\n+                raise ValueError(\"Filled contours require at least 2 levels.\")\n \n         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n             raise ValueError(\"Contour levels must be increasing\")\n@@ -1446,16 +1463,29 @@ class QuadContourSet(ContourSet):\n         else:\n             fn = 'contour'\n         nargs = len(args)\n+\n         if nargs <= 2:\n+            z_original = args[0]  # Keep original for boolean detection\n             z = ma.asarray(args[0], dtype=np.float64)\n             x, y = self._initialize_x_y(z)\n             args = args[1:]\n+            # Store original z for boolean detection in level processing\n+            if hasattr(z_original, 'dtype') and z_original.dtype == bool:\n+                self._original_z_dtype = bool\n         elif nargs <= 4:\n             x, y, z = self._check_xyz(args[:3], kwargs)\n             args = args[3:]\n         else:\n             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n+\n         z = ma.masked_invalid(z, copy=False)\n+        \n+        # Check if original z was boolean before conversion to float64\n+        if hasattr(z, '_original_dtype') and z._original_dtype == bool:\n+            # For boolean arrays, use 0.5 as the default level if no levels specified\n+            if self.levels is None and not hasattr(self, '_levels_specified'):\n+                self.levels = [0.5]\n+        \n         self.zmax = float(z.max())\n         self.zmin = float(z.min())\n         if self.logscale and self.zmin <= 0:\n"
  }
}