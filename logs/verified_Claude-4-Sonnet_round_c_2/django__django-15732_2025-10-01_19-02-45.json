{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/backends/base/schema.py lines 565-570)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
    "Location 2 (/root/hy/projects/django/django/db/backends/base/schema.py lines 571-579)": "\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
    "Location 3 (/root/hy/projects/django/django/db/backends/base/schema.py lines 530-532)": "\ndef alter_unique_together(self, model, old_unique_together, new_unique_together):\n    \"\"\"\n    Deal with a model changing its unique_together. The input\n    unique_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_unique_together}\n    news = {tuple(fields) for fields in new_unique_together}\n    # Deleted uniques\n    for fields in olds.difference(news):\n        self._delete_composed_index(\n            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n        )\n    # Created uniques\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_unique_sql(model, fields))\n",
    "Location 4 (/root/hy/projects/django/django/db/migrations/operations/models.py lines 560-569)": "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/backends/base/schema.py lines 565-570)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/backends/base/schema.py lines 571-579)": [
      "\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Exclude primary key constraints when dropping unique constraints\n        constraint_search_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get(\"unique\"):\n            constraint_search_kwargs[\"primary_key\"] = False\n        \n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_search_kwargs,\n        )\n        if len(constraint_names) != 1:\n            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n            raise ValueError(\n                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n                \"Expected exactly one non-primary-key constraint.\"\n                % (\n                    len(constraint_names),\n                    constraint_type,\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/backends/base/schema.py lines 530-532)": [
      "\ndef alter_unique_together(self, model, old_unique_together, new_unique_together):\n    \"\"\"\n    Deal with a model changing its unique_together. The input\n    unique_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_unique_together}\n    news = {tuple(fields) for fields in new_unique_together}\n    # Deleted uniques\n    for fields in olds.difference(news):\n        self._delete_composed_index(\n            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n        )\n    # Created uniques\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_unique_sql(model, fields))\n",
      "\ndef alter_unique_together(self, model, old_unique_together, new_unique_together):\n    \"\"\"\n    Deal with a model changing its unique_together. The input\n    unique_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_unique_together}\n    news = {tuple(fields) for fields in new_unique_together}\n    # Deleted uniques\n    for fields in olds.difference(news):\n        self._delete_composed_index(\n            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n        )\n    # Created uniques\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\ndef alter_unique_together(self, model, old_unique_together, new_unique_together):\n    \"\"\"\n    Deal with a model changing its unique_together. The input\n    unique_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_unique_together}\n    news = {tuple(fields) for fields in new_unique_together}\n    # Deleted uniques\n    for fields in olds.difference(news):\n        self._delete_composed_index(\n            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n        )\n    # Created uniques\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n            )\n",
      "\ndef alter_unique_together(self, model, old_unique_together, new_unique_together):\n    \"\"\"\n    Deal with a model changing its unique_together. The input\n    unique_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_unique_together}\n    news = {tuple(fields) for fields in new_unique_together}\n    # Deleted uniques\n    for fields in olds.difference(news):\n        self._delete_composed_index(\n            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n        )\n    # Created uniques\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_unique_sql(model, fields))\n",
      "\ndef alter_unique_together(self, model, old_unique_together, new_unique_together):\n    \"\"\"\n    Deal with a model changing its unique_together. The input\n    unique_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_unique_together}\n    news = {tuple(fields) for fields in new_unique_together}\n    # Deleted uniques\n    for fields in olds.difference(news):\n        self._delete_composed_index(\n            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n        )\n    # Created uniques\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_unique_sql(model, fields))\n",
      "\ndef alter_unique_together(self, model, old_unique_together, new_unique_together):\n    \"\"\"\n    Deal with a model changing its unique_together. The input\n    unique_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_unique_together}\n    news = {tuple(fields) for fields in new_unique_together}\n    # Deleted uniques\n    for fields in olds.difference(news):\n        self._delete_composed_index(\n            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n        )\n    # Created uniques\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_unique_sql(model, fields))\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/migrations/operations/models.py lines 560-569)": [
      "\ndef database_forwards(self, app_label, schema_editor, from_state, to_state):\n    new_model = to_state.apps.get_model(app_label, self.name)\n    if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n        old_model = from_state.apps.get_model(app_label, self.name)\n        alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n        alter_together(\n            new_model,\n            getattr(old_model._meta, self.option_name, set()),\n            getattr(new_model._meta, self.option_name, set()),\n        )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..6ae6368496 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -527,6 +527,7 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n+\n             self._delete_composed_index(\n                 model, fields, {\"unique\": True}, self.sql_delete_unique\n             )\n@@ -562,17 +563,27 @@ class BaseDatabaseSchemaEditor:\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n         constraint_names = self._constraint_names(\n             model,\n             columns,\n             exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+            **constraint_search_kwargs,\n         )\n+\n         if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n             raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n                 % (\n                     len(constraint_names),\n+                    constraint_type,\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..1537ddd31c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..b227760c12 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -527,9 +527,24 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model, fields, {\"unique\": True}, self.sql_delete_unique\n-            )\n+\n+def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+    \"\"\"\n+    Deal with a model changing its unique_together. The input\n+    unique_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_unique_together}\n+    news = {tuple(fields) for fields in new_unique_together}\n+    # Deleted uniques\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(\n+            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n+        )\n+    # Created uniques\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_unique_sql(model, fields))\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -562,17 +577,64 @@ class BaseDatabaseSchemaEditor:\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n+        constraint_names = self._constraint_names(\n+            model,\n+            columns,\n+            exclude=meta_constraint_names | meta_index_names,\n+            **constraint_search_kwargs,\n+        )\n+        if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n+                % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n         constraint_names = self._constraint_names(\n             model,\n             columns,\n             exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+            **constraint_search_kwargs,\n         )\n         if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n             raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n                 % (\n                     len(constraint_names),\n+                    constraint_type,\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..1537ddd31c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..b227760c12 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -527,9 +527,24 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model, fields, {\"unique\": True}, self.sql_delete_unique\n-            )\n+\n+def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+    \"\"\"\n+    Deal with a model changing its unique_together. The input\n+    unique_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_unique_together}\n+    news = {tuple(fields) for fields in new_unique_together}\n+    # Deleted uniques\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(\n+            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n+        )\n+    # Created uniques\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_unique_sql(model, fields))\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -562,17 +577,64 @@ class BaseDatabaseSchemaEditor:\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n+        constraint_names = self._constraint_names(\n+            model,\n+            columns,\n+            exclude=meta_constraint_names | meta_index_names,\n+            **constraint_search_kwargs,\n+        )\n+        if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n+                % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n         constraint_names = self._constraint_names(\n             model,\n             columns,\n             exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+            **constraint_search_kwargs,\n         )\n         if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n             raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n                 % (\n                     len(constraint_names),\n+                    constraint_type,\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..67c5193841 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,16 +557,17 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n-    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n-        new_model = to_state.apps.get_model(app_label, self.name)\n-        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n-            old_model = from_state.apps.get_model(app_label, self.name)\n-            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n-            alter_together(\n-                new_model,\n-                getattr(old_model._meta, self.option_name, set()),\n-                getattr(new_model._meta, self.option_name, set()),\n-            )\n+\n+def database_forwards(self, app_label, schema_editor, from_state, to_state):\n+    new_model = to_state.apps.get_model(app_label, self.name)\n+    if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n+        old_model = from_state.apps.get_model(app_label, self.name)\n+        alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n+        alter_together(\n+            new_model,\n+            getattr(old_model._meta, self.option_name, set()),\n+            getattr(new_model._meta, self.option_name, set()),\n+        )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n         return self.database_forwards(app_label, schema_editor, from_state, to_state)\n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..b227760c12 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -527,9 +527,24 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model, fields, {\"unique\": True}, self.sql_delete_unique\n-            )\n+\n+def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+    \"\"\"\n+    Deal with a model changing its unique_together. The input\n+    unique_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_unique_together}\n+    news = {tuple(fields) for fields in new_unique_together}\n+    # Deleted uniques\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(\n+            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n+        )\n+    # Created uniques\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_unique_sql(model, fields))\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -562,17 +577,64 @@ class BaseDatabaseSchemaEditor:\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n+        constraint_names = self._constraint_names(\n+            model,\n+            columns,\n+            exclude=meta_constraint_names | meta_index_names,\n+            **constraint_search_kwargs,\n+        )\n+        if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n+                % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n         constraint_names = self._constraint_names(\n             model,\n             columns,\n             exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+            **constraint_search_kwargs,\n         )\n         if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n             raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n                 % (\n                     len(constraint_names),\n+                    constraint_type,\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..1537ddd31c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..1610e65f15 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,6 +517,17 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+\n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n@@ -528,12 +539,16 @@ class BaseDatabaseSchemaEditor:\n         # Deleted uniques\n         for fields in olds.difference(news):\n             self._delete_composed_index(\n-                model, fields, {\"unique\": True}, self.sql_delete_unique\n+                model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n \n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n@@ -562,17 +577,51 @@ class BaseDatabaseSchemaEditor:\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n+        constraint_names = self._constraint_names(\n+            model,\n+            columns,\n+            exclude=meta_constraint_names | meta_index_names,\n+            **constraint_search_kwargs,\n+        )\n+\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n         constraint_names = self._constraint_names(\n             model,\n             columns,\n             exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+            **constraint_search_kwargs,\n         )\n         if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n             raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n                 % (\n                     len(constraint_names),\n+                    constraint_type,\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..1537ddd31c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..b227760c12 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -527,9 +527,24 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model, fields, {\"unique\": True}, self.sql_delete_unique\n-            )\n+\n+def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+    \"\"\"\n+    Deal with a model changing its unique_together. The input\n+    unique_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_unique_together}\n+    news = {tuple(fields) for fields in new_unique_together}\n+    # Deleted uniques\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(\n+            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n+        )\n+    # Created uniques\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_unique_sql(model, fields))\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -562,17 +577,64 @@ class BaseDatabaseSchemaEditor:\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n+        constraint_names = self._constraint_names(\n+            model,\n+            columns,\n+            exclude=meta_constraint_names | meta_index_names,\n+            **constraint_search_kwargs,\n+        )\n+        if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n+                % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n         constraint_names = self._constraint_names(\n             model,\n             columns,\n             exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+            **constraint_search_kwargs,\n         )\n         if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n             raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n                 % (\n                     len(constraint_names),\n+                    constraint_type,\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..1537ddd31c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..a7754f38f6 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,6 +517,17 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+\n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n@@ -528,7 +539,7 @@ class BaseDatabaseSchemaEditor:\n         # Deleted uniques\n         for fields in olds.difference(news):\n             self._delete_composed_index(\n-                model, fields, {\"unique\": True}, self.sql_delete_unique\n+                model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n@@ -562,17 +573,64 @@ class BaseDatabaseSchemaEditor:\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n+        constraint_names = self._constraint_names(\n+            model,\n+            columns,\n+            exclude=meta_constraint_names | meta_index_names,\n+            **constraint_search_kwargs,\n+        )\n+        if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n+                % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n         constraint_names = self._constraint_names(\n             model,\n             columns,\n             exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+            **constraint_search_kwargs,\n         )\n         if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n             raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n                 % (\n                     len(constraint_names),\n+                    constraint_type,\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..1537ddd31c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..b227760c12 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -527,9 +527,24 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model, fields, {\"unique\": True}, self.sql_delete_unique\n-            )\n+\n+def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+    \"\"\"\n+    Deal with a model changing its unique_together. The input\n+    unique_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_unique_together}\n+    news = {tuple(fields) for fields in new_unique_together}\n+    # Deleted uniques\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(\n+            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n+        )\n+    # Created uniques\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_unique_sql(model, fields))\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -562,17 +577,64 @@ class BaseDatabaseSchemaEditor:\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n+        constraint_names = self._constraint_names(\n+            model,\n+            columns,\n+            exclude=meta_constraint_names | meta_index_names,\n+            **constraint_search_kwargs,\n+        )\n+        if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n+                % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n         constraint_names = self._constraint_names(\n             model,\n             columns,\n             exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+            **constraint_search_kwargs,\n         )\n         if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n             raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n                 % (\n                     len(constraint_names),\n+                    constraint_type,\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..1537ddd31c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..b227760c12 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -527,9 +527,24 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model, fields, {\"unique\": True}, self.sql_delete_unique\n-            )\n+\n+def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+    \"\"\"\n+    Deal with a model changing its unique_together. The input\n+    unique_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_unique_together}\n+    news = {tuple(fields) for fields in new_unique_together}\n+    # Deleted uniques\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(\n+            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n+        )\n+    # Created uniques\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_unique_sql(model, fields))\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -562,17 +577,64 @@ class BaseDatabaseSchemaEditor:\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n+        constraint_names = self._constraint_names(\n+            model,\n+            columns,\n+            exclude=meta_constraint_names | meta_index_names,\n+            **constraint_search_kwargs,\n+        )\n+        if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n+                % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n         constraint_names = self._constraint_names(\n             model,\n             columns,\n             exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+            **constraint_search_kwargs,\n         )\n         if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n             raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n                 % (\n                     len(constraint_names),\n+                    constraint_type,\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..1537ddd31c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..b227760c12 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -527,9 +527,24 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model, fields, {\"unique\": True}, self.sql_delete_unique\n-            )\n+\n+def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+    \"\"\"\n+    Deal with a model changing its unique_together. The input\n+    unique_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_unique_together}\n+    news = {tuple(fields) for fields in new_unique_together}\n+    # Deleted uniques\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(\n+            model, fields, {\"unique\": True, \"primary_key\": False}, self.sql_delete_unique\n+        )\n+    # Created uniques\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_unique_sql(model, fields))\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -562,17 +577,64 @@ class BaseDatabaseSchemaEditor:\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n+        constraint_names = self._constraint_names(\n+            model,\n+            columns,\n+            exclude=meta_constraint_names | meta_index_names,\n+            **constraint_search_kwargs,\n+        )\n+        if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n+                % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Exclude primary key constraints when dropping unique constraints\n+        constraint_search_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get(\"unique\"):\n+            constraint_search_kwargs[\"primary_key\"] = False\n+        \n         constraint_names = self._constraint_names(\n             model,\n             columns,\n             exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+            **constraint_search_kwargs,\n         )\n         if len(constraint_names) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get(\"unique\") else \"index\"\n             raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Expected exactly one non-primary-key constraint.\"\n                 % (\n                     len(constraint_names),\n+                    constraint_type,\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..1537ddd31c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n"
  }
}