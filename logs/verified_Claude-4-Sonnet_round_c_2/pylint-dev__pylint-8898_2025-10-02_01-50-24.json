{
  "zero_patches": {
    "Location 1 (/root/hy/projects/pylint/pylint/config/argument.py lines 114-119)": "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _splitstrip(value, sep=\";\"):\n        patterns.append(_regex_transformer(pattern))\n    return patterns\n",
    "Location 2 (/root/hy/projects/pylint/pylint/config/argument.py lines 51-53)": "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated string into compiled regexes.\"\"\"\n    if not value:\n        return []\n    \n    # Use semicolon as separator to avoid conflicts with regex syntax like {1,3}\n    patterns = [pattern.strip() for pattern in value.split(';') if pattern.strip()]\n    compiled_patterns = []\n    \n    for pattern in patterns:\n        try:\n            compiled_patterns.append(re.compile(pattern))\n        except re.error as e:\n            raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\")\n    \n    return compiled_patterns\n",
    "Location 3 (/root/hy/projects/pylint/pylint/utils/utils.py lines 212-232)": "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a string of semicolon-separated regex patterns into compiled regex patterns.\n    \n    Uses semicolon (;) as separator instead of comma to avoid conflicts with regex syntax\n    like quantifiers {1,3}.\n    \n    Args:\n        value: semicolon-separated regex patterns\n        \n    Returns:\n        List of compiled regex patterns\n        \n    Raises:\n        argparse.ArgumentTypeError: if any pattern fails to compile\n    \"\"\"\n    patterns = []\n    for pattern in _splitstrip(value, \";\"):\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            msg = f\"Error in provided regular expression: {pattern} beginning at index {e.pos}: {e.msg}\"\n            raise argparse.ArgumentTypeError(msg) from e\n    return patterns\n",
    "Location 4 (/root/hy/projects/pylint/pylint/utils/utils.py lines 250-253)": "\ndef _regexp_csv_transformer(value: str) -> list[Pattern[str]]:\n    \"\"\"Transforms a string of semicolon-separated regex patterns into compiled patterns.\"\"\"\n    patterns = []\n    if not value.strip():\n        return patterns\n    \n    # Use semicolon as separator to avoid conflicts with regex syntax like {1,3}\n    for pattern_str in value.split(';'):\n        pattern_str = pattern_str.strip()\n        if pattern_str:\n            patterns.append(re.compile(pattern_str))\n    return patterns\n",
    "Location 5 (/root/hy/projects/pylint/pylint/config/argument.py lines 147-147)": "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transform a comma separated list of regular expressions.\"\"\"\n    patterns = []\n    for pattern in _csv_transformer(value, separator=\";\"):\n        patterns.append(re.compile(pattern))\n    return patterns\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/pylint/pylint/config/argument.py lines 114-119)": [
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value, separator=';'):\n        patterns.append(_regex_transformer(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _semicolon_transformer(value):\n        patterns.append(_regex_transformer(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _splitstrip(value, sep=\";\"):\n        patterns.append(_regex_transformer(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _splitstrip(value, sep=';'):\n        patterns.append(_regex_transformer(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _splitstrip(value, sep=\";\"):\n        patterns.append(_regex_transformer(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _splitstrip(value, sep=\";\"):\n        patterns.append(_regex_transformer(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _splitstrip(value, sep=';'):\n        patterns.append(_regex_transformer(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _splitstrip(value, sep=';'):\n        patterns.append(_regex_transformer(pattern))\n    return patterns\n"
    ],
    "Location 2 (/root/hy/projects/pylint/pylint/config/argument.py lines 51-53)": [
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated string into compiled regular expressions.\n    \n    Uses semicolon as separator to avoid conflicts with regex syntax that may\n    contain commas (e.g., quantifiers like {1,3}).\n    \"\"\"\n    patterns = []\n    for pattern_str in value.split(';'):\n        pattern_str = pattern_str.strip()\n        if pattern_str:\n            try:\n                patterns.append(re.compile(pattern_str))\n            except re.error as e:\n                raise argparse.ArgumentTypeError(\n                    f\"Error compiling regular expression '{pattern_str}': {e}\"\n                )\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated string of regexes.\"\"\"\n    patterns = []\n    if not value.strip():\n        return patterns\n    \n    # Split on semicolon to avoid conflicts with regex comma syntax\n    for pattern_str in value.split(';'):\n        pattern_str = pattern_str.strip()\n        if pattern_str:\n            try:\n                patterns.append(re.compile(pattern_str))\n            except re.error as e:\n                raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern_str}': {e}\")\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated string into compiled regular expressions.\n    \n    Uses semicolon (;) as separator to avoid conflicts with regex syntax that\n    may contain commas (e.g., quantifiers like {1,3}).\n    \"\"\"\n    patterns = []\n    if not value.strip():\n        return patterns\n    \n    # Split on semicolon and strip whitespace from each pattern\n    for pattern_str in value.split(';'):\n        pattern_str = pattern_str.strip()\n        if pattern_str:\n            try:\n                patterns.append(re.compile(pattern_str))\n            except re.error as e:\n                raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern_str}': {e}\")\n    \n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated string into compiled regular expressions.\n    \n    Uses semicolon as separator to avoid conflicts with regex syntax that may contain commas.\n    \"\"\"\n    patterns = []\n    # Split on semicolon instead of comma to avoid regex syntax conflicts\n    for pattern_str in value.split(';'):\n        pattern_str = pattern_str.strip()\n        if pattern_str:  # Skip empty patterns\n            try:\n                patterns.append(re.compile(pattern_str))\n            except re.error as e:\n                raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern_str}': {e}\")\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated string of regexps.\"\"\"\n    patterns = []\n    # Use semicolon as separator to avoid conflicts with regex comma syntax\n    for pattern_str in value.split(';'):\n        pattern_str = pattern_str.strip()\n        if pattern_str:\n            try:\n                patterns.append(re.compile(pattern_str))\n            except re.error as e:\n                raise argparse.ArgumentTypeError(\n                    f\"Error in regular expression '{pattern_str}': {e}\"\n                ) from e\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated string of regexps.\"\"\"\n    patterns = []\n    if not value:\n        return patterns\n    # Use semicolon as separator to avoid conflicts with regex syntax like {1,3}\n    for pattern_str in value.split(';'):\n        pattern_str = pattern_str.strip()\n        if pattern_str:\n            try:\n                patterns.append(re.compile(pattern_str))\n            except re.error as e:\n                raise argparse.ArgumentTypeError(\n                    f\"Invalid regular expression '{pattern_str}': {e}\"\n                )\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated string into compiled regular expressions.\n    \n    Uses semicolon as separator to avoid conflicts with regex syntax that\n    commonly uses commas (e.g., quantifiers like {1,3}).\n    \"\"\"\n    patterns = []\n    if not value.strip():\n        return patterns\n    \n    # Split on semicolon and strip whitespace\n    for pattern_str in value.split(';'):\n        pattern_str = pattern_str.strip()\n        if pattern_str:\n            try:\n                patterns.append(re.compile(pattern_str))\n            except re.error as exc:\n                raise argparse.ArgumentTypeError(\n                    f\"Error in regular expression '{pattern_str}': {exc}\"\n                )\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a semicolon separated string into compiled regexes.\n    \n    Uses semicolon as separator to avoid conflicts with regex syntax\n    that may contain commas (e.g., quantifiers like {1,3}).\n    \"\"\"\n    return [re.compile(pattern.strip()) for pattern in value.split(\";\") if pattern.strip()]\n"
    ],
    "Location 3 (/root/hy/projects/pylint/pylint/utils/utils.py lines 212-232)": [
      "\ndef _regexp_csv_transformer(value: str) -> list[re.Pattern[str]]:\n    \"\"\"Transform a comma-separated list of regular expressions into compiled patterns.\n    \n    For regular expressions, we use semicolon (;) as the separator instead of comma\n    to avoid conflicts with regex syntax like quantifiers {1,3}.\n    \n    Args:\n        value: A semicolon-separated string of regular expressions\n        \n    Returns:\n        A list of compiled regular expression patterns\n        \n    Raises:\n        argparse.ArgumentTypeError: If any regex pattern is invalid\n    \"\"\"\n    patterns = []\n    for pattern_str in _splitstrip(value, sep=\";\"):\n        try:\n            patterns.append(re.compile(pattern_str))\n        except re.error as e:\n            raise argparse.ArgumentTypeError(\n                f\"Invalid regular expression '{pattern_str}': {e}\"\n            ) from e\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transform a comma separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    # Use semicolon as separator to avoid conflicts with regex comma syntax\n    for pattern in _splitstrip(value, sep=\";\"):\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            msg = f\"Error in provided regular expression: {pattern} beginning at index {e.pos}: {e.msg}\"\n            raise argparse.ArgumentTypeError(msg) from e\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns = []\n    for pattern in _splitstrip(value, sep=\";\"):\n        patterns.append(re.compile(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transform a comma or semicolon separated list of regexps into a sequence\n    of compiled patterns. Semicolons are preferred to avoid conflicts with\n    regex syntax that uses commas (e.g., quantifiers like {1,3}).\n    \"\"\"\n    # Use semicolon as primary separator, fall back to comma for backward compatibility\n    if ';' in value:\n        separator = ';'\n    else:\n        separator = ','\n    \n    patterns = []\n    for pattern_str in _splitstrip(value, separator):\n        try:\n            patterns.append(re.compile(pattern_str))\n        except re.error as exc:\n            msg = f\"Error in provided regexp: {pattern_str!r}: {exc}\"\n            raise argparse.ArgumentTypeError(msg) from exc\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma or semicolon separated list of regular expressions.\"\"\"\n    patterns = []\n    # First try semicolon separation (preferred for regex patterns)\n    if ';' in value:\n        parts = [word.strip() for word in value.split(';') if word.strip()]\n    else:\n        # Fall back to comma separation for backward compatibility\n        parts = [word.strip() for word in value.split(',') if word.strip()]\n    \n    for pattern in parts:\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            raise ValueError(f\"Invalid regular expression '{pattern}': {e}\")\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns = []\n    # Use semicolon as separator to avoid conflicts with regex syntax like {1,3}\n    for pattern_str in _splitstrip(value, sep=\";\"):\n        try:\n            patterns.append(re.compile(pattern_str))\n        except re.error as exc:\n            msg = f\"Error in provided regular expression: {pattern_str} beginning at index {exc.pos}: {exc.msg}\"\n            raise argparse.ArgumentTypeError(msg) from exc\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a CSV string of regular expressions into a sequence of compiled patterns.\n    \n    Uses semicolon (;) as separator to avoid conflicts with regex comma syntax.\n    \"\"\"\n    patterns = []\n    for pattern_str in _splitstrip(value, sep=\";\"):\n        patterns.append(re.compile(pattern_str))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(string: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transform a comma separated list of regular expressions.\"\"\"\n    return [\n        re.compile(regexp)\n        for regexp in _splitstrip(string, sep=\";\")\n        if regexp is not None\n    ]\n"
    ],
    "Location 4 (/root/hy/projects/pylint/pylint/utils/utils.py lines 250-253)": [
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transform a semicolon-separated string of regexps into a sequence of compiled patterns.\"\"\"\n    patterns = []\n    if value.strip():\n        # Use semicolon as separator to avoid conflicts with regex comma syntax\n        for pattern_str in value.split(';'):\n            pattern_str = pattern_str.strip()\n            if pattern_str:\n                try:\n                    patterns.append(re.compile(pattern_str))\n                except re.error as e:\n                    raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern_str}': {e}\")\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> list[re.Pattern[str]]:\n    \"\"\"Transforms a semicolon-separated string of regexes into compiled patterns.\"\"\"\n    patterns = []\n    if value:\n        for pattern in _splitstrip(value, separator=\";\"):\n            patterns.append(re.compile(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> list[re.Pattern[str]]:\n    \"\"\"Transform a semicolon-separated string into a list of compiled regex patterns.\n    \n    Uses semicolon as separator to avoid conflicts with comma quantifiers in regex.\n    \"\"\"\n    patterns = []\n    for pattern in _splitstrip(value, separator=';'):\n        patterns.append(re.compile(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transform a semicolon-separated list of regular expressions.\"\"\"\n    patterns = []\n    # Use semicolon as separator to avoid conflicts with regex syntax like {1,3}\n    for pattern_str in _splitstrip(value, separator=';'):\n        try:\n            patterns.append(re.compile(pattern_str))\n        except re.error as e:\n            raise argparse.ArgumentTypeError(f\"Invalid regular expression '{pattern_str}': {e}\")\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Return `value` as a list of compiled regular expressions, using semicolon as separator.\"\"\"\n    patterns = []\n    if value:\n        for pattern in value.split(';'):\n            pattern = pattern.strip()\n            if pattern:\n                patterns.append(re.compile(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma or semicolon separated list of regular expressions.\"\"\"\n    patterns = []\n    \n    # Try semicolon separation first (preferred for regex patterns)\n    if ';' in value:\n        raw_patterns = _splitstrip(value, separator=';')\n    else:\n        # Fall back to comma separation for backward compatibility\n        raw_patterns = _splitstrip(value)\n    \n    for pattern in raw_patterns:\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            raise argparse.ArgumentTypeError(f\"Invalid regular expression '{pattern}': {e}\")\n    \n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transform a comma-separated list of regexps into a sequence of compiled patterns.\n    \n    Uses semicolon (;) as separator to avoid conflicts with regex syntax that may contain commas.\n    \"\"\"\n    patterns = []\n    # Split on semicolon to avoid conflicts with regex comma syntax like {1,3}\n    for pattern in _splitstrip(value, separator=';'):\n        patterns.append(re.compile(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transform a string of semicolon-separated regex patterns into a sequence of compiled patterns.\"\"\"\n    patterns = []\n    if not value.strip():\n        return patterns\n    \n    # Split on semicolon to avoid conflicts with regex comma syntax\n    for pattern_str in value.split(';'):\n        pattern_str = pattern_str.strip()\n        if pattern_str:\n            try:\n                patterns.append(re.compile(pattern_str))\n            except re.error as exc:\n                msg = f\"Error in provided regular expression: {pattern_str} beginning at index {exc.pos}: {exc.msg}\"\n                raise argparse.ArgumentTypeError(msg) from exc\n    return patterns\n"
    ],
    "Location 5 (/root/hy/projects/pylint/pylint/config/argument.py lines 147-147)": [
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Return `re.compile()` objects for each pattern in a semicolon-separated string.\"\"\"\n    patterns = []\n    for pattern in _splitstrip(value, separator=\";\"):\n        patterns.append(re.compile(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma or semicolon separated list of regular expressions.\"\"\"\n    # Use semicolon as primary separator to avoid conflicts with regex syntax\n    # Fall back to comma splitting for backward compatibility if no semicolons found\n    if ';' in value:\n        patterns = _splitstrip(value, sep=';')\n    else:\n        patterns = _splitstrip(value)\n    \n    return [_regex_transformer(pattern) for pattern in patterns]\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns = []\n    for pattern in _splitstrip(value, sep=\";\"):\n        patterns.append(re.compile(pattern))\n    return patterns\n",
      "\n    \"regexp_csv\": _regexp_csv_transformer,\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Return `re.compile()` objects for a comma-separated list of regexes.\"\"\"\n    patterns = []\n    for pattern in _splitstrip(value, sep=\";\"):\n        patterns.append(re.compile(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns = []\n    for pattern in _semicolon_splitstrip(value):\n        patterns.append(_regex_transformer(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transform a comma or semicolon separated list of regexes.\"\"\"\n    # Use semicolon as primary separator to avoid conflicts with regex syntax like {1,3}\n    # Fall back to comma for backward compatibility if no semicolons found\n    if ';' in value:\n        patterns = _splitstrip(value, sep=';')\n    else:\n        patterns = _splitstrip(value)\n    return [_regex_transformer(pattern) for pattern in patterns]\n",
      "\ndef _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns = []\n    for pattern in _splitstrip(value, sep=\";\"):\n        patterns.append(re.compile(pattern))\n    return patterns\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..7b22935c6 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -48,6 +48,7 @@ def _confidence_transformer(value: str) -> Sequence[str]:\n     return values\n \n \n+\n def _csv_transformer(value: str) -> Sequence[str]:\n     \"\"\"Transforms a comma separated string.\"\"\"\n     return pylint_utils._check_csv(value)\n@@ -111,10 +112,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n-def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in pylint_utils._check_csv_with_separator(value, \";\"):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -144,7 +146,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"glob_paths_csv\": _glob_paths_csv_transformer,\n     \"py_version\": _py_version_transformer,\n     \"regexp\": _regex_transformer,\n-    \"regexp_csv\": _regexp_csv_transfomer,\n+\n+    \"regexp_csv\": _regexp_csv_transformer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\n     \"yn\": _yn_transformer,\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92f..c5d673e91 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -209,6 +209,7 @@ def register_plugins(linter: PyLinter, directory: str) -> None:\n                     imported[base] = 1\n \n \n+\n def _splitstrip(string: str, sep: str = \",\") -> list[str]:\n     \"\"\"Return a list of stripped string by splitting the string given as\n     argument on `sep` (',' by default), empty strings are discarded.\n@@ -247,12 +248,19 @@ def _unquote(string: str) -> str:\n     return string\n \n \n+\n def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n     if isinstance(value, (list, tuple)):\n         return value\n     return _splitstrip(value)\n \n \n+def _check_csv_with_separator(value: list[str] | tuple[str] | str, sep: str = \",\") -> Sequence[str]:\n+    if isinstance(value, (list, tuple)):\n+        return value\n+    return _splitstrip(value, sep)\n+\n+\n def _comment(string: str) -> str:\n     \"\"\"Return string as a comment.\"\"\"\n     lines = [line.strip() for line in string.splitlines()]\n",
    "variant_0": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..487118592 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -48,9 +48,23 @@ def _confidence_transformer(value: str) -> Sequence[str]:\n     return values\n \n \n-def _csv_transformer(value: str) -> Sequence[str]:\n-    \"\"\"Transforms a comma separated string.\"\"\"\n-    return pylint_utils._check_csv(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated string into compiled regexes.\"\"\"\n+    if not value:\n+        return []\n+    \n+    # Use semicolon as separator to avoid conflicts with regex syntax like {1,3}\n+    patterns = [pattern.strip() for pattern in value.split(';') if pattern.strip()]\n+    compiled_patterns = []\n+    \n+    for pattern in patterns:\n+        try:\n+            compiled_patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\")\n+    \n+    return compiled_patterns\n \n \n YES_VALUES = {\"y\", \"yes\", \"true\"}\n@@ -111,10 +125,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n-def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _splitstrip(value, sep=\";\"):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -144,7 +159,13 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"glob_paths_csv\": _glob_paths_csv_transformer,\n     \"py_version\": _py_version_transformer,\n     \"regexp\": _regex_transformer,\n-    \"regexp_csv\": _regexp_csv_transfomer,\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transform a comma separated list of regular expressions.\"\"\"\n+    patterns = []\n+    for pattern in _csv_transformer(value, separator=\";\"):\n+        patterns.append(re.compile(pattern))\n+    return patterns\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\n     \"yn\": _yn_transformer,\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92f..c18500d9e 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -209,27 +209,30 @@ def register_plugins(linter: PyLinter, directory: str) -> None:\n                     imported[base] = 1\n \n \n-def _splitstrip(string: str, sep: str = \",\") -> list[str]:\n-    \"\"\"Return a list of stripped string by splitting the string given as\n-    argument on `sep` (',' by default), empty strings are discarded.\n \n-    >>> _splitstrip('a, b, c   ,  4,,')\n-    ['a', 'b', 'c', '4']\n-    >>> _splitstrip('a')\n-    ['a']\n-    >>> _splitstrip('a,\\nb,\\nc,')\n-    ['a', 'b', 'c']\n-\n-    :type string: str or unicode\n-    :param string: a csv line\n-\n-    :type sep: str or unicode\n-    :param sep: field separator, default to the comma (',')\n-\n-    :rtype: str or unicode\n-    :return: the unquoted string (or the input string if it wasn't quoted)\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a string of semicolon-separated regex patterns into compiled regex patterns.\n+    \n+    Uses semicolon (;) as separator instead of comma to avoid conflicts with regex syntax\n+    like quantifiers {1,3}.\n+    \n+    Args:\n+        value: semicolon-separated regex patterns\n+        \n+    Returns:\n+        List of compiled regex patterns\n+        \n+    Raises:\n+        argparse.ArgumentTypeError: if any pattern fails to compile\n     \"\"\"\n-    return [word.strip() for word in string.split(sep) if word.strip()]\n+    patterns = []\n+    for pattern in _splitstrip(value, \";\"):\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            msg = f\"Error in provided regular expression: {pattern} beginning at index {e.pos}: {e.msg}\"\n+            raise argparse.ArgumentTypeError(msg) from e\n+    return patterns\n \n \n def _unquote(string: str) -> str:\n@@ -247,10 +250,19 @@ def _unquote(string: str) -> str:\n     return string\n \n \n-def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n-    if isinstance(value, (list, tuple)):\n-        return value\n-    return _splitstrip(value)\n+\n+def _regexp_csv_transformer(value: str) -> list[Pattern[str]]:\n+    \"\"\"Transforms a string of semicolon-separated regex patterns into compiled patterns.\"\"\"\n+    patterns = []\n+    if not value.strip():\n+        return patterns\n+    \n+    # Use semicolon as separator to avoid conflicts with regex syntax like {1,3}\n+    for pattern_str in value.split(';'):\n+        pattern_str = pattern_str.strip()\n+        if pattern_str:\n+            patterns.append(re.compile(pattern_str))\n+    return patterns\n \n \n def _comment(string: str) -> str:\n",
    "variant_1": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..23b4a24d9 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -48,9 +48,24 @@ def _confidence_transformer(value: str) -> Sequence[str]:\n     return values\n \n \n-def _csv_transformer(value: str) -> Sequence[str]:\n-    \"\"\"Transforms a comma separated string.\"\"\"\n-    return pylint_utils._check_csv(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated string into compiled regular expressions.\n+    \n+    Uses semicolon as separator to avoid conflicts with regex syntax that may\n+    contain commas (e.g., quantifiers like {1,3}).\n+    \"\"\"\n+    patterns = []\n+    for pattern_str in value.split(';'):\n+        pattern_str = pattern_str.strip()\n+        if pattern_str:\n+            try:\n+                patterns.append(re.compile(pattern_str))\n+            except re.error as e:\n+                raise argparse.ArgumentTypeError(\n+                    f\"Error compiling regular expression '{pattern_str}': {e}\"\n+                )\n+    return patterns\n \n \n YES_VALUES = {\"y\", \"yes\", \"true\"}\n@@ -111,10 +126,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n-def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _csv_transformer(value, separator=';'):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -144,7 +160,13 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"glob_paths_csv\": _glob_paths_csv_transformer,\n     \"py_version\": _py_version_transformer,\n     \"regexp\": _regex_transformer,\n-    \"regexp_csv\": _regexp_csv_transfomer,\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Return `re.compile()` objects for each pattern in a semicolon-separated string.\"\"\"\n+    patterns = []\n+    for pattern in _splitstrip(value, separator=\";\"):\n+        patterns.append(re.compile(pattern))\n+    return patterns\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\n     \"yn\": _yn_transformer,\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92f..012ed44dd 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -209,27 +209,31 @@ def register_plugins(linter: PyLinter, directory: str) -> None:\n                     imported[base] = 1\n \n \n-def _splitstrip(string: str, sep: str = \",\") -> list[str]:\n-    \"\"\"Return a list of stripped string by splitting the string given as\n-    argument on `sep` (',' by default), empty strings are discarded.\n \n-    >>> _splitstrip('a, b, c   ,  4,,')\n-    ['a', 'b', 'c', '4']\n-    >>> _splitstrip('a')\n-    ['a']\n-    >>> _splitstrip('a,\\nb,\\nc,')\n-    ['a', 'b', 'c']\n-\n-    :type string: str or unicode\n-    :param string: a csv line\n-\n-    :type sep: str or unicode\n-    :param sep: field separator, default to the comma (',')\n-\n-    :rtype: str or unicode\n-    :return: the unquoted string (or the input string if it wasn't quoted)\n+def _regexp_csv_transformer(value: str) -> list[re.Pattern[str]]:\n+    \"\"\"Transform a comma-separated list of regular expressions into compiled patterns.\n+    \n+    For regular expressions, we use semicolon (;) as the separator instead of comma\n+    to avoid conflicts with regex syntax like quantifiers {1,3}.\n+    \n+    Args:\n+        value: A semicolon-separated string of regular expressions\n+        \n+    Returns:\n+        A list of compiled regular expression patterns\n+        \n+    Raises:\n+        argparse.ArgumentTypeError: If any regex pattern is invalid\n     \"\"\"\n-    return [word.strip() for word in string.split(sep) if word.strip()]\n+    patterns = []\n+    for pattern_str in _splitstrip(value, sep=\";\"):\n+        try:\n+            patterns.append(re.compile(pattern_str))\n+        except re.error as e:\n+            raise argparse.ArgumentTypeError(\n+                f\"Invalid regular expression '{pattern_str}': {e}\"\n+            ) from e\n+    return patterns\n \n \n def _unquote(string: str) -> str:\n@@ -247,10 +251,20 @@ def _unquote(string: str) -> str:\n     return string\n \n \n-def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n-    if isinstance(value, (list, tuple)):\n-        return value\n-    return _splitstrip(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transform a semicolon-separated string of regexps into a sequence of compiled patterns.\"\"\"\n+    patterns = []\n+    if value.strip():\n+        # Use semicolon as separator to avoid conflicts with regex comma syntax\n+        for pattern_str in value.split(';'):\n+            pattern_str = pattern_str.strip()\n+            if pattern_str:\n+                try:\n+                    patterns.append(re.compile(pattern_str))\n+                except re.error as e:\n+                    raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern_str}': {e}\")\n+    return patterns\n \n \n def _comment(string: str) -> str:\n",
    "variant_2": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..53367786e 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -48,9 +48,22 @@ def _confidence_transformer(value: str) -> Sequence[str]:\n     return values\n \n \n-def _csv_transformer(value: str) -> Sequence[str]:\n-    \"\"\"Transforms a comma separated string.\"\"\"\n-    return pylint_utils._check_csv(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated string of regexes.\"\"\"\n+    patterns = []\n+    if not value.strip():\n+        return patterns\n+    \n+    # Split on semicolon to avoid conflicts with regex comma syntax\n+    for pattern_str in value.split(';'):\n+        pattern_str = pattern_str.strip()\n+        if pattern_str:\n+            try:\n+                patterns.append(re.compile(pattern_str))\n+            except re.error as e:\n+                raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern_str}': {e}\")\n+    return patterns\n \n \n YES_VALUES = {\"y\", \"yes\", \"true\"}\n@@ -111,10 +124,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n-def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _semicolon_transformer(value):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -144,7 +158,17 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"glob_paths_csv\": _glob_paths_csv_transformer,\n     \"py_version\": _py_version_transformer,\n     \"regexp\": _regex_transformer,\n-    \"regexp_csv\": _regexp_csv_transfomer,\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma or semicolon separated list of regular expressions.\"\"\"\n+    # Use semicolon as primary separator to avoid conflicts with regex syntax\n+    # Fall back to comma splitting for backward compatibility if no semicolons found\n+    if ';' in value:\n+        patterns = _splitstrip(value, sep=';')\n+    else:\n+        patterns = _splitstrip(value)\n+    \n+    return [_regex_transformer(pattern) for pattern in patterns]\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\n     \"yn\": _yn_transformer,\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92f..d5549a08f 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -209,27 +209,18 @@ def register_plugins(linter: PyLinter, directory: str) -> None:\n                     imported[base] = 1\n \n \n-def _splitstrip(string: str, sep: str = \",\") -> list[str]:\n-    \"\"\"Return a list of stripped string by splitting the string given as\n-    argument on `sep` (',' by default), empty strings are discarded.\n \n-    >>> _splitstrip('a, b, c   ,  4,,')\n-    ['a', 'b', 'c', '4']\n-    >>> _splitstrip('a')\n-    ['a']\n-    >>> _splitstrip('a,\\nb,\\nc,')\n-    ['a', 'b', 'c']\n-\n-    :type string: str or unicode\n-    :param string: a csv line\n-\n-    :type sep: str or unicode\n-    :param sep: field separator, default to the comma (',')\n-\n-    :rtype: str or unicode\n-    :return: the unquoted string (or the input string if it wasn't quoted)\n-    \"\"\"\n-    return [word.strip() for word in string.split(sep) if word.strip()]\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transform a comma separated list of regular expressions.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+    # Use semicolon as separator to avoid conflicts with regex comma syntax\n+    for pattern in _splitstrip(value, sep=\";\"):\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            msg = f\"Error in provided regular expression: {pattern} beginning at index {e.pos}: {e.msg}\"\n+            raise argparse.ArgumentTypeError(msg) from e\n+    return patterns\n \n \n def _unquote(string: str) -> str:\n@@ -247,10 +238,14 @@ def _unquote(string: str) -> str:\n     return string\n \n \n-def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n-    if isinstance(value, (list, tuple)):\n-        return value\n-    return _splitstrip(value)\n+\n+def _regexp_csv_transformer(value: str) -> list[re.Pattern[str]]:\n+    \"\"\"Transforms a semicolon-separated string of regexes into compiled patterns.\"\"\"\n+    patterns = []\n+    if value:\n+        for pattern in _splitstrip(value, separator=\";\"):\n+            patterns.append(re.compile(pattern))\n+    return patterns\n \n \n def _comment(string: str) -> str:\n",
    "variant_3": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..31c1e9692 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -48,9 +48,27 @@ def _confidence_transformer(value: str) -> Sequence[str]:\n     return values\n \n \n-def _csv_transformer(value: str) -> Sequence[str]:\n-    \"\"\"Transforms a comma separated string.\"\"\"\n-    return pylint_utils._check_csv(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated string into compiled regular expressions.\n+    \n+    Uses semicolon (;) as separator to avoid conflicts with regex syntax that\n+    may contain commas (e.g., quantifiers like {1,3}).\n+    \"\"\"\n+    patterns = []\n+    if not value.strip():\n+        return patterns\n+    \n+    # Split on semicolon and strip whitespace from each pattern\n+    for pattern_str in value.split(';'):\n+        pattern_str = pattern_str.strip()\n+        if pattern_str:\n+            try:\n+                patterns.append(re.compile(pattern_str))\n+            except re.error as e:\n+                raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern_str}': {e}\")\n+    \n+    return patterns\n \n \n YES_VALUES = {\"y\", \"yes\", \"true\"}\n@@ -111,10 +129,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n-def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _splitstrip(value, sep=\";\"):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -144,7 +163,13 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"glob_paths_csv\": _glob_paths_csv_transformer,\n     \"py_version\": _py_version_transformer,\n     \"regexp\": _regex_transformer,\n-    \"regexp_csv\": _regexp_csv_transfomer,\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns = []\n+    for pattern in _splitstrip(value, sep=\";\"):\n+        patterns.append(re.compile(pattern))\n+    return patterns\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\n     \"yn\": _yn_transformer,\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92f..5c1e98226 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -209,27 +209,13 @@ def register_plugins(linter: PyLinter, directory: str) -> None:\n                     imported[base] = 1\n \n \n-def _splitstrip(string: str, sep: str = \",\") -> list[str]:\n-    \"\"\"Return a list of stripped string by splitting the string given as\n-    argument on `sep` (',' by default), empty strings are discarded.\n \n-    >>> _splitstrip('a, b, c   ,  4,,')\n-    ['a', 'b', 'c', '4']\n-    >>> _splitstrip('a')\n-    ['a']\n-    >>> _splitstrip('a,\\nb,\\nc,')\n-    ['a', 'b', 'c']\n-\n-    :type string: str or unicode\n-    :param string: a csv line\n-\n-    :type sep: str or unicode\n-    :param sep: field separator, default to the comma (',')\n-\n-    :rtype: str or unicode\n-    :return: the unquoted string (or the input string if it wasn't quoted)\n-    \"\"\"\n-    return [word.strip() for word in string.split(sep) if word.strip()]\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns = []\n+    for pattern in _splitstrip(value, sep=\";\"):\n+        patterns.append(re.compile(pattern))\n+    return patterns\n \n \n def _unquote(string: str) -> str:\n@@ -247,10 +233,16 @@ def _unquote(string: str) -> str:\n     return string\n \n \n-def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n-    if isinstance(value, (list, tuple)):\n-        return value\n-    return _splitstrip(value)\n+\n+def _regexp_csv_transformer(value: str) -> list[re.Pattern[str]]:\n+    \"\"\"Transform a semicolon-separated string into a list of compiled regex patterns.\n+    \n+    Uses semicolon as separator to avoid conflicts with comma quantifiers in regex.\n+    \"\"\"\n+    patterns = []\n+    for pattern in _splitstrip(value, separator=';'):\n+        patterns.append(re.compile(pattern))\n+    return patterns\n \n \n def _comment(string: str) -> str:\n",
    "variant_4": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..997dc6b7b 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -48,9 +48,22 @@ def _confidence_transformer(value: str) -> Sequence[str]:\n     return values\n \n \n-def _csv_transformer(value: str) -> Sequence[str]:\n-    \"\"\"Transforms a comma separated string.\"\"\"\n-    return pylint_utils._check_csv(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated string into compiled regular expressions.\n+    \n+    Uses semicolon as separator to avoid conflicts with regex syntax that may contain commas.\n+    \"\"\"\n+    patterns = []\n+    # Split on semicolon instead of comma to avoid regex syntax conflicts\n+    for pattern_str in value.split(';'):\n+        pattern_str = pattern_str.strip()\n+        if pattern_str:  # Skip empty patterns\n+            try:\n+                patterns.append(re.compile(pattern_str))\n+            except re.error as e:\n+                raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern_str}': {e}\")\n+    return patterns\n \n \n YES_VALUES = {\"y\", \"yes\", \"true\"}\n@@ -111,10 +124,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n-def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _splitstrip(value, sep=';'):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -144,7 +158,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"glob_paths_csv\": _glob_paths_csv_transformer,\n     \"py_version\": _py_version_transformer,\n     \"regexp\": _regex_transformer,\n-    \"regexp_csv\": _regexp_csv_transfomer,\n+\n+    \"regexp_csv\": _regexp_csv_transformer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\n     \"yn\": _yn_transformer,\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92f..ffebe941c 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -209,27 +209,26 @@ def register_plugins(linter: PyLinter, directory: str) -> None:\n                     imported[base] = 1\n \n \n-def _splitstrip(string: str, sep: str = \",\") -> list[str]:\n-    \"\"\"Return a list of stripped string by splitting the string given as\n-    argument on `sep` (',' by default), empty strings are discarded.\n \n-    >>> _splitstrip('a, b, c   ,  4,,')\n-    ['a', 'b', 'c', '4']\n-    >>> _splitstrip('a')\n-    ['a']\n-    >>> _splitstrip('a,\\nb,\\nc,')\n-    ['a', 'b', 'c']\n-\n-    :type string: str or unicode\n-    :param string: a csv line\n-\n-    :type sep: str or unicode\n-    :param sep: field separator, default to the comma (',')\n-\n-    :rtype: str or unicode\n-    :return: the unquoted string (or the input string if it wasn't quoted)\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transform a comma or semicolon separated list of regexps into a sequence\n+    of compiled patterns. Semicolons are preferred to avoid conflicts with\n+    regex syntax that uses commas (e.g., quantifiers like {1,3}).\n     \"\"\"\n-    return [word.strip() for word in string.split(sep) if word.strip()]\n+    # Use semicolon as primary separator, fall back to comma for backward compatibility\n+    if ';' in value:\n+        separator = ';'\n+    else:\n+        separator = ','\n+    \n+    patterns = []\n+    for pattern_str in _splitstrip(value, separator):\n+        try:\n+            patterns.append(re.compile(pattern_str))\n+        except re.error as exc:\n+            msg = f\"Error in provided regexp: {pattern_str!r}: {exc}\"\n+            raise argparse.ArgumentTypeError(msg) from exc\n+    return patterns\n \n \n def _unquote(string: str) -> str:\n@@ -247,10 +246,17 @@ def _unquote(string: str) -> str:\n     return string\n \n \n-def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n-    if isinstance(value, (list, tuple)):\n-        return value\n-    return _splitstrip(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transform a semicolon-separated list of regular expressions.\"\"\"\n+    patterns = []\n+    # Use semicolon as separator to avoid conflicts with regex syntax like {1,3}\n+    for pattern_str in _splitstrip(value, separator=';'):\n+        try:\n+            patterns.append(re.compile(pattern_str))\n+        except re.error as e:\n+            raise argparse.ArgumentTypeError(f\"Invalid regular expression '{pattern_str}': {e}\")\n+    return patterns\n \n \n def _comment(string: str) -> str:\n",
    "variant_5": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..81bc23a1b 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -48,9 +48,21 @@ def _confidence_transformer(value: str) -> Sequence[str]:\n     return values\n \n \n-def _csv_transformer(value: str) -> Sequence[str]:\n-    \"\"\"Transforms a comma separated string.\"\"\"\n-    return pylint_utils._check_csv(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated string of regexps.\"\"\"\n+    patterns = []\n+    # Use semicolon as separator to avoid conflicts with regex comma syntax\n+    for pattern_str in value.split(';'):\n+        pattern_str = pattern_str.strip()\n+        if pattern_str:\n+            try:\n+                patterns.append(re.compile(pattern_str))\n+            except re.error as e:\n+                raise argparse.ArgumentTypeError(\n+                    f\"Error in regular expression '{pattern_str}': {e}\"\n+                ) from e\n+    return patterns\n \n \n YES_VALUES = {\"y\", \"yes\", \"true\"}\n@@ -111,10 +123,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n-def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _splitstrip(value, sep=\";\"):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -144,7 +157,13 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"glob_paths_csv\": _glob_paths_csv_transformer,\n     \"py_version\": _py_version_transformer,\n     \"regexp\": _regex_transformer,\n-    \"regexp_csv\": _regexp_csv_transfomer,\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Return `re.compile()` objects for a comma-separated list of regexes.\"\"\"\n+    patterns = []\n+    for pattern in _splitstrip(value, sep=\";\"):\n+        patterns.append(re.compile(pattern))\n+    return patterns\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\n     \"yn\": _yn_transformer,\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92f..4863683ae 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -209,27 +209,23 @@ def register_plugins(linter: PyLinter, directory: str) -> None:\n                     imported[base] = 1\n \n \n-def _splitstrip(string: str, sep: str = \",\") -> list[str]:\n-    \"\"\"Return a list of stripped string by splitting the string given as\n-    argument on `sep` (',' by default), empty strings are discarded.\n \n-    >>> _splitstrip('a, b, c   ,  4,,')\n-    ['a', 'b', 'c', '4']\n-    >>> _splitstrip('a')\n-    ['a']\n-    >>> _splitstrip('a,\\nb,\\nc,')\n-    ['a', 'b', 'c']\n-\n-    :type string: str or unicode\n-    :param string: a csv line\n-\n-    :type sep: str or unicode\n-    :param sep: field separator, default to the comma (',')\n-\n-    :rtype: str or unicode\n-    :return: the unquoted string (or the input string if it wasn't quoted)\n-    \"\"\"\n-    return [word.strip() for word in string.split(sep) if word.strip()]\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma or semicolon separated list of regular expressions.\"\"\"\n+    patterns = []\n+    # First try semicolon separation (preferred for regex patterns)\n+    if ';' in value:\n+        parts = [word.strip() for word in value.split(';') if word.strip()]\n+    else:\n+        # Fall back to comma separation for backward compatibility\n+        parts = [word.strip() for word in value.split(',') if word.strip()]\n+    \n+    for pattern in parts:\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            raise ValueError(f\"Invalid regular expression '{pattern}': {e}\")\n+    return patterns\n \n \n def _unquote(string: str) -> str:\n@@ -247,10 +243,16 @@ def _unquote(string: str) -> str:\n     return string\n \n \n-def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n-    if isinstance(value, (list, tuple)):\n-        return value\n-    return _splitstrip(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Return `value` as a list of compiled regular expressions, using semicolon as separator.\"\"\"\n+    patterns = []\n+    if value:\n+        for pattern in value.split(';'):\n+            pattern = pattern.strip()\n+            if pattern:\n+                patterns.append(re.compile(pattern))\n+    return patterns\n \n \n def _comment(string: str) -> str:\n",
    "variant_6": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..949eb9978 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -48,9 +48,23 @@ def _confidence_transformer(value: str) -> Sequence[str]:\n     return values\n \n \n-def _csv_transformer(value: str) -> Sequence[str]:\n-    \"\"\"Transforms a comma separated string.\"\"\"\n-    return pylint_utils._check_csv(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated string of regexps.\"\"\"\n+    patterns = []\n+    if not value:\n+        return patterns\n+    # Use semicolon as separator to avoid conflicts with regex syntax like {1,3}\n+    for pattern_str in value.split(';'):\n+        pattern_str = pattern_str.strip()\n+        if pattern_str:\n+            try:\n+                patterns.append(re.compile(pattern_str))\n+            except re.error as e:\n+                raise argparse.ArgumentTypeError(\n+                    f\"Invalid regular expression '{pattern_str}': {e}\"\n+                )\n+    return patterns\n \n \n YES_VALUES = {\"y\", \"yes\", \"true\"}\n@@ -111,10 +125,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n-def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _splitstrip(value, sep=\";\"):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -144,7 +159,13 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"glob_paths_csv\": _glob_paths_csv_transformer,\n     \"py_version\": _py_version_transformer,\n     \"regexp\": _regex_transformer,\n-    \"regexp_csv\": _regexp_csv_transfomer,\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns = []\n+    for pattern in _semicolon_splitstrip(value):\n+        patterns.append(_regex_transformer(pattern))\n+    return patterns\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\n     \"yn\": _yn_transformer,\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92f..bf325a9a0 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -209,27 +209,18 @@ def register_plugins(linter: PyLinter, directory: str) -> None:\n                     imported[base] = 1\n \n \n-def _splitstrip(string: str, sep: str = \",\") -> list[str]:\n-    \"\"\"Return a list of stripped string by splitting the string given as\n-    argument on `sep` (',' by default), empty strings are discarded.\n \n-    >>> _splitstrip('a, b, c   ,  4,,')\n-    ['a', 'b', 'c', '4']\n-    >>> _splitstrip('a')\n-    ['a']\n-    >>> _splitstrip('a,\\nb,\\nc,')\n-    ['a', 'b', 'c']\n-\n-    :type string: str or unicode\n-    :param string: a csv line\n-\n-    :type sep: str or unicode\n-    :param sep: field separator, default to the comma (',')\n-\n-    :rtype: str or unicode\n-    :return: the unquoted string (or the input string if it wasn't quoted)\n-    \"\"\"\n-    return [word.strip() for word in string.split(sep) if word.strip()]\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns = []\n+    # Use semicolon as separator to avoid conflicts with regex syntax like {1,3}\n+    for pattern_str in _splitstrip(value, sep=\";\"):\n+        try:\n+            patterns.append(re.compile(pattern_str))\n+        except re.error as exc:\n+            msg = f\"Error in provided regular expression: {pattern_str} beginning at index {exc.pos}: {exc.msg}\"\n+            raise argparse.ArgumentTypeError(msg) from exc\n+    return patterns\n \n \n def _unquote(string: str) -> str:\n@@ -247,10 +238,25 @@ def _unquote(string: str) -> str:\n     return string\n \n \n-def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n-    if isinstance(value, (list, tuple)):\n-        return value\n-    return _splitstrip(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma or semicolon separated list of regular expressions.\"\"\"\n+    patterns = []\n+    \n+    # Try semicolon separation first (preferred for regex patterns)\n+    if ';' in value:\n+        raw_patterns = _splitstrip(value, separator=';')\n+    else:\n+        # Fall back to comma separation for backward compatibility\n+        raw_patterns = _splitstrip(value)\n+    \n+    for pattern in raw_patterns:\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            raise argparse.ArgumentTypeError(f\"Invalid regular expression '{pattern}': {e}\")\n+    \n+    return patterns\n \n \n def _comment(string: str) -> str:\n",
    "variant_7": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..f2a3a86bd 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -48,9 +48,28 @@ def _confidence_transformer(value: str) -> Sequence[str]:\n     return values\n \n \n-def _csv_transformer(value: str) -> Sequence[str]:\n-    \"\"\"Transforms a comma separated string.\"\"\"\n-    return pylint_utils._check_csv(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated string into compiled regular expressions.\n+    \n+    Uses semicolon as separator to avoid conflicts with regex syntax that\n+    commonly uses commas (e.g., quantifiers like {1,3}).\n+    \"\"\"\n+    patterns = []\n+    if not value.strip():\n+        return patterns\n+    \n+    # Split on semicolon and strip whitespace\n+    for pattern_str in value.split(';'):\n+        pattern_str = pattern_str.strip()\n+        if pattern_str:\n+            try:\n+                patterns.append(re.compile(pattern_str))\n+            except re.error as exc:\n+                raise argparse.ArgumentTypeError(\n+                    f\"Error in regular expression '{pattern_str}': {exc}\"\n+                )\n+    return patterns\n \n \n YES_VALUES = {\"y\", \"yes\", \"true\"}\n@@ -111,10 +130,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n-def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _splitstrip(value, sep=';'):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -144,7 +164,16 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"glob_paths_csv\": _glob_paths_csv_transformer,\n     \"py_version\": _py_version_transformer,\n     \"regexp\": _regex_transformer,\n-    \"regexp_csv\": _regexp_csv_transfomer,\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transform a comma or semicolon separated list of regexes.\"\"\"\n+    # Use semicolon as primary separator to avoid conflicts with regex syntax like {1,3}\n+    # Fall back to comma for backward compatibility if no semicolons found\n+    if ';' in value:\n+        patterns = _splitstrip(value, sep=';')\n+    else:\n+        patterns = _splitstrip(value)\n+    return [_regex_transformer(pattern) for pattern in patterns]\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\n     \"yn\": _yn_transformer,\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92f..7e38262ee 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -209,27 +209,16 @@ def register_plugins(linter: PyLinter, directory: str) -> None:\n                     imported[base] = 1\n \n \n-def _splitstrip(string: str, sep: str = \",\") -> list[str]:\n-    \"\"\"Return a list of stripped string by splitting the string given as\n-    argument on `sep` (',' by default), empty strings are discarded.\n \n-    >>> _splitstrip('a, b, c   ,  4,,')\n-    ['a', 'b', 'c', '4']\n-    >>> _splitstrip('a')\n-    ['a']\n-    >>> _splitstrip('a,\\nb,\\nc,')\n-    ['a', 'b', 'c']\n-\n-    :type string: str or unicode\n-    :param string: a csv line\n-\n-    :type sep: str or unicode\n-    :param sep: field separator, default to the comma (',')\n-\n-    :rtype: str or unicode\n-    :return: the unquoted string (or the input string if it wasn't quoted)\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a CSV string of regular expressions into a sequence of compiled patterns.\n+    \n+    Uses semicolon (;) as separator to avoid conflicts with regex comma syntax.\n     \"\"\"\n-    return [word.strip() for word in string.split(sep) if word.strip()]\n+    patterns = []\n+    for pattern_str in _splitstrip(value, sep=\";\"):\n+        patterns.append(re.compile(pattern_str))\n+    return patterns\n \n \n def _unquote(string: str) -> str:\n@@ -247,10 +236,17 @@ def _unquote(string: str) -> str:\n     return string\n \n \n-def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n-    if isinstance(value, (list, tuple)):\n-        return value\n-    return _splitstrip(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transform a comma-separated list of regexps into a sequence of compiled patterns.\n+    \n+    Uses semicolon (;) as separator to avoid conflicts with regex syntax that may contain commas.\n+    \"\"\"\n+    patterns = []\n+    # Split on semicolon to avoid conflicts with regex comma syntax like {1,3}\n+    for pattern in _splitstrip(value, separator=';'):\n+        patterns.append(re.compile(pattern))\n+    return patterns\n \n \n def _comment(string: str) -> str:\n",
    "variant_8": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..02ec40b7c 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -48,9 +48,14 @@ def _confidence_transformer(value: str) -> Sequence[str]:\n     return values\n \n \n-def _csv_transformer(value: str) -> Sequence[str]:\n-    \"\"\"Transforms a comma separated string.\"\"\"\n-    return pylint_utils._check_csv(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated string into compiled regexes.\n+    \n+    Uses semicolon as separator to avoid conflicts with regex syntax\n+    that may contain commas (e.g., quantifiers like {1,3}).\n+    \"\"\"\n+    return [re.compile(pattern.strip()) for pattern in value.split(\";\") if pattern.strip()]\n \n \n YES_VALUES = {\"y\", \"yes\", \"true\"}\n@@ -111,10 +116,11 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n-def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n-    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a semicolon separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _splitstrip(value, sep=';'):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -144,7 +150,13 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"glob_paths_csv\": _glob_paths_csv_transformer,\n     \"py_version\": _py_version_transformer,\n     \"regexp\": _regex_transformer,\n-    \"regexp_csv\": _regexp_csv_transfomer,\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns = []\n+    for pattern in _splitstrip(value, sep=\";\"):\n+        patterns.append(re.compile(pattern))\n+    return patterns\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\n     \"yn\": _yn_transformer,\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92f..cd267d92f 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -209,27 +209,14 @@ def register_plugins(linter: PyLinter, directory: str) -> None:\n                     imported[base] = 1\n \n \n-def _splitstrip(string: str, sep: str = \",\") -> list[str]:\n-    \"\"\"Return a list of stripped string by splitting the string given as\n-    argument on `sep` (',' by default), empty strings are discarded.\n \n-    >>> _splitstrip('a, b, c   ,  4,,')\n-    ['a', 'b', 'c', '4']\n-    >>> _splitstrip('a')\n-    ['a']\n-    >>> _splitstrip('a,\\nb,\\nc,')\n-    ['a', 'b', 'c']\n-\n-    :type string: str or unicode\n-    :param string: a csv line\n-\n-    :type sep: str or unicode\n-    :param sep: field separator, default to the comma (',')\n-\n-    :rtype: str or unicode\n-    :return: the unquoted string (or the input string if it wasn't quoted)\n-    \"\"\"\n-    return [word.strip() for word in string.split(sep) if word.strip()]\n+def _regexp_csv_transformer(string: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transform a comma separated list of regular expressions.\"\"\"\n+    return [\n+        re.compile(regexp)\n+        for regexp in _splitstrip(string, sep=\";\")\n+        if regexp is not None\n+    ]\n \n \n def _unquote(string: str) -> str:\n@@ -247,10 +234,23 @@ def _unquote(string: str) -> str:\n     return string\n \n \n-def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n-    if isinstance(value, (list, tuple)):\n-        return value\n-    return _splitstrip(value)\n+\n+def _regexp_csv_transformer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transform a string of semicolon-separated regex patterns into a sequence of compiled patterns.\"\"\"\n+    patterns = []\n+    if not value.strip():\n+        return patterns\n+    \n+    # Split on semicolon to avoid conflicts with regex comma syntax\n+    for pattern_str in value.split(';'):\n+        pattern_str = pattern_str.strip()\n+        if pattern_str:\n+            try:\n+                patterns.append(re.compile(pattern_str))\n+            except re.error as exc:\n+                msg = f\"Error in provided regular expression: {pattern_str} beginning at index {exc.pos}: {exc.msg}\"\n+                raise argparse.ArgumentTypeError(msg) from exc\n+    return patterns\n \n \n def _comment(string: str) -> str:\n"
  }
}