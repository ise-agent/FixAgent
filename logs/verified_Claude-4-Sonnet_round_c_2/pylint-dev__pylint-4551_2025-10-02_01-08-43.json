{
  "zero_patches": {
    "Location 1 (/root/hy/projects/pylint/pylint/pyreverse/inspector.py lines 175-185)": "\ndef visit_functiondef(self, node):\n    \"\"\"visit an astroid.Function node\n\n    * set the locals_type mapping\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    \n    # Extract parameter type annotations\n    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n        node.param_types = {}\n        for i, arg in enumerate(node.args.args):\n            if i < len(node.args.annotations) and node.args.annotations[i]:\n                try:\n                    # Convert annotation to string representation\n                    annotation_str = node.args.annotations[i].as_string()\n                    node.param_types[arg.name] = annotation_str\n                except AttributeError:\n                    pass\n    \n    # Extract return type annotation\n    if hasattr(node, 'returns') and node.returns:\n        try:\n            node.return_type = node.returns.as_string()\n        except AttributeError:\n            pass\n            \n    if self.tag:\n        node.uid = self.generate_id()\n",
    "Location 2 (/root/hy/projects/pylint/pylint/pyreverse/inspector.py lines 146-173)": "\ndef visit_classdef(self, node):\n    \"\"\"visit an astroid.Class node\n\n    * set the locals_type and instance_attrs_type mappings\n    * set the implements list and build it\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    if self.tag:\n        node.uid = self.generate_id()\n    \n    # resolve ancestors\n    for baseobj in node.ancestors(recurs=False):\n        specializations = getattr(baseobj, \"specializations\", [])\n        specializations.append(node)\n        baseobj.specializations = specializations\n    \n    # resolve instance attributes\n    node.instance_attrs_type = collections.defaultdict(list)\n    \n    # NEW: Extract class variable type annotations from __annotations__\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        node.instance_attrs_type[attr_name].append(type_str)\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for assignattrs in node.instance_attrs.values():\n        for assignattr in assignattrs:\n            if not isinstance(assignattr, astroid.Unknown):\n                self.handle_assignattr_type(assignattr, node)\n    # resolve implemented interface\n    try:\n        node.implements = list(utils.interfaces(node, self.inherited_interfaces))\n    except astroid.InferenceError:\n        node.implements = ()\n",
    "Location 3 (/root/hy/projects/pylint/pylint/pyreverse/diagrams.py lines 87-90)": "\ndef get_attrs(self, node):\n    \"\"\"return visible attributes, possibly with class name\"\"\"\n    attrs = []\n    properties = [\n        (n, m)\n        for n, m in node.items()\n        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n    ]\n    \n    # Include direct type annotations from __annotations__\n    annotation_attrs = []\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        annotation_attrs.append((attr_name, [type_str]))\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for node_name, associated_nodes in (\n        list(node.instance_attrs_type.items())\n        + list(node.locals_type.items())\n        + properties\n        + annotation_attrs\n    ):\n        if not self.show_attr(node_name):\n            continue\n        names = self.class_names(associated_nodes)\n        if names:\n            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n        attrs.append(node_name)\n    return sorted(attrs)\n",
    "Location 4 (/root/hy/projects/pylint/pylint/pyreverse/diagrams.py lines 100-109)": "\ndef get_methods(self, node):\n    \"\"\"return visible methods\"\"\"\n    methods = [\n        m\n        for m in node.values()\n        if isinstance(m, astroid.FunctionDef)\n        and not decorated_with_property(m)\n        and self.show_attr(m.name)\n    ]\n    \n    # Ensure type annotation data is preserved on method nodes\n    for method in methods:\n        if not hasattr(method, 'param_types'):\n            method.param_types = {}\n        if not hasattr(method, 'return_type'):\n            method.return_type = None\n            \n    return sorted(methods, key=lambda n: n.name)\n",
    "Location 5 (/root/hy/projects/pylint/pylint/pyreverse/writer.py lines 126-145)": "\ndef get_values(self, obj):\n    \"\"\"get label and shape for classes.\n\n    The label contains all attributes and methods\n    \"\"\"\n    label = obj.title\n    if obj.shape == \"interface\":\n        label = \"«interface»\\\\n%s\" % label\n    if not self.config.only_classnames:\n        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n        for func in obj.methods:\n            if func.args.args:\n                args = []\n                for arg in func.args.args:\n                    if arg.name == \"self\":\n                        continue\n                    # Include type annotation if available\n                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                    else:\n                        args.append(arg.name)\n            else:\n                args = []\n            \n            # Build method signature with return type if available\n            method_sig = f\"{func.name}({', '.join(args)})\"\n            if hasattr(func, 'return_type') and func.return_type:\n                method_sig += f\" -> {func.return_type}\"\n                \n            label = r\"{}{}\\l\".format(label, method_sig)\n        label = \"{%s}\" % label\n    if is_exception(obj.node):\n        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n    return dict(label=label, shape=\"record\")\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/pylint/pylint/pyreverse/inspector.py lines 175-185)": [
      "\ndef visit_functiondef(self, node):\n    \"\"\"visit an astroid.Function node\n\n    * set the locals_type mapping\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    \n    # Extract parameter type annotations\n    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n        node.param_types = {}\n        for i, arg in enumerate(node.args.args):\n            if i < len(node.args.annotations) and node.args.annotations[i]:\n                try:\n                    # Convert annotation to string representation\n                    annotation_str = node.args.annotations[i].as_string()\n                    node.param_types[arg.name] = annotation_str\n                except AttributeError:\n                    pass\n    \n    # Extract return type annotation\n    if hasattr(node, 'returns') and node.returns:\n        try:\n            node.return_type = node.returns.as_string()\n        except AttributeError:\n            pass\n            \n    if self.tag:\n        node.uid = self.generate_id()\n",
      "\ndef visit_functiondef(self, node):\n    \"\"\"visit an astroid.Function node\n\n    * set the locals_type mapping\n    * extract parameter and return type annotations\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    \n    # Extract parameter type annotations\n    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n        node.param_types = {}\n        for i, arg in enumerate(node.args.args):\n            if i < len(node.args.annotations) and node.args.annotations[i]:\n                try:\n                    annotation_str = node.args.annotations[i].as_string()\n                    node.param_types[arg.name] = annotation_str\n                except AttributeError:\n                    pass\n    else:\n        node.param_types = {}\n    \n    # Extract return type annotation\n    if hasattr(node, 'returns') and node.returns:\n        try:\n            node.return_type = node.returns.as_string()\n        except AttributeError:\n            node.return_type = None\n    else:\n        node.return_type = None\n        \n    if self.tag:\n        node.uid = self.generate_id()\n",
      "\ndef visit_functiondef(self, node):\n    \"\"\"visit an astroid.Function node\n\n    * set the locals_type mapping\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    \n    # Extract parameter type annotations\n    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n        node.param_types = {}\n        for i, arg in enumerate(node.args.args):\n            if i < len(node.args.annotations) and node.args.annotations[i]:\n                try:\n                    # Convert annotation to string representation\n                    annotation_str = node.args.annotations[i].as_string()\n                    node.param_types[arg.name] = annotation_str\n                except AttributeError:\n                    pass\n    \n    # Extract return type annotation\n    if hasattr(node, 'returns') and node.returns:\n        try:\n            node.return_type = node.returns.as_string()\n        except AttributeError:\n            pass\n            \n    if self.tag:\n        node.uid = self.generate_id()\n",
      "\ndef visit_functiondef(self, node):\n    \"\"\"visit an astroid.Function node\n\n    * set the locals_type mapping\n    * extract parameter and return type annotations\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    \n    # Extract parameter type annotations\n    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n        node.param_types = {}\n        for i, arg in enumerate(node.args.args):\n            if i < len(node.args.annotations) and node.args.annotations[i]:\n                try:\n                    annotation_str = node.args.annotations[i].as_string()\n                    node.param_types[arg.name] = annotation_str\n                except AttributeError:\n                    pass\n    \n    # Extract return type annotation\n    if hasattr(node, 'returns') and node.returns:\n        try:\n            node.return_type = node.returns.as_string()\n        except AttributeError:\n            pass\n            \n    if self.tag:\n        node.uid = self.generate_id()\n",
      "\ndef visit_functiondef(self, node):\n    \"\"\"visit an astroid.Function node\n\n    * set the locals_type mapping\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    \n    # Extract parameter type annotations\n    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n        node.param_types = {}\n        for i, arg in enumerate(node.args.args):\n            if i < len(node.args.annotations) and node.args.annotations[i]:\n                try:\n                    # Convert annotation to string representation\n                    annotation_str = node.args.annotations[i].as_string()\n                    node.param_types[arg.name] = annotation_str\n                except AttributeError:\n                    pass\n    \n    # Extract return type annotation\n    if hasattr(node, 'returns') and node.returns:\n        try:\n            node.return_type = node.returns.as_string()\n        except AttributeError:\n            pass\n            \n    if self.tag:\n        node.uid = self.generate_id()\n",
      "\ndef visit_functiondef(self, node):\n    \"\"\"visit an astroid.Function node\n\n    * set the locals_type mapping\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    \n    # Extract parameter type annotations\n    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n        node.param_types = {}\n        for i, arg in enumerate(node.args.args):\n            if i < len(node.args.annotations) and node.args.annotations[i]:\n                try:\n                    # Convert annotation to string representation\n                    annotation_str = node.args.annotations[i].as_string()\n                    node.param_types[arg.name] = annotation_str\n                except AttributeError:\n                    pass\n    \n    # Extract return type annotation\n    if hasattr(node, 'returns') and node.returns:\n        try:\n            node.return_type = node.returns.as_string()\n        except AttributeError:\n            pass\n            \n    if self.tag:\n        node.uid = self.generate_id()\n",
      "\ndef visit_functiondef(self, node):\n    \"\"\"visit an astroid.Function node\n\n    * set the locals_type mapping\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    \n    # Extract parameter type annotations\n    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n        node.param_types = {}\n        for i, arg in enumerate(node.args.args):\n            if i < len(node.args.annotations) and node.args.annotations[i]:\n                try:\n                    # Convert annotation to string representation\n                    annotation_str = node.args.annotations[i].as_string()\n                    node.param_types[arg.name] = annotation_str\n                except AttributeError:\n                    pass\n    \n    # Extract return type annotation\n    if hasattr(node, 'returns') and node.returns:\n        try:\n            node.return_type = node.returns.as_string()\n        except AttributeError:\n            pass\n            \n    if self.tag:\n        node.uid = self.generate_id()\n",
      "\ndef visit_functiondef(self, node):\n    \"\"\"visit an astroid.Function node\n\n    * set the locals_type mapping\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    \n    # Extract parameter type annotations\n    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n        node.param_types = {}\n        for i, arg in enumerate(node.args.args):\n            if i < len(node.args.annotations) and node.args.annotations[i]:\n                try:\n                    annotation_str = node.args.annotations[i].as_string()\n                    node.param_types[arg.name] = annotation_str\n                except AttributeError:\n                    pass\n    \n    # Extract return type annotation\n    if hasattr(node, 'returns') and node.returns:\n        try:\n            node.return_type = node.returns.as_string()\n        except AttributeError:\n            pass\n            \n    if self.tag:\n        node.uid = self.generate_id()\n"
    ],
    "Location 2 (/root/hy/projects/pylint/pylint/pyreverse/inspector.py lines 146-173)": [
      "\ndef visit_classdef(self, node):\n    \"\"\"visit an astroid.Class node\n\n    * set the locals_type and instance_attrs_type mappings\n    * set the implements list and build it\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    if self.tag:\n        node.uid = self.generate_id()\n    \n    # NEW: Extract class variable type annotations\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        # Store in instance_attrs_type for consistency\n                        if not hasattr(node, 'instance_attrs_type'):\n                            node.instance_attrs_type = collections.defaultdict(list)\n                        node.instance_attrs_type[attr_name] = [type_str]\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    # resolve ancestors\n    for baseobj in node.ancestors(recurs=False):\n        specializations = getattr(baseobj, \"specializations\", [])\n        specializations.append(node)\n        baseobj.specializations = specializations\n    # resolve instance attributes\n    node.instance_attrs_type = collections.defaultdict(list)\n    for assignattrs in node.instance_attrs.values():\n        for assignattr in assignattrs:\n            if not isinstance(assignattr, astroid.Unknown):\n                self.handle_assignattr_type(assignattr, node)\n    # resolve implemented interface\n    try:\n        node.implements = list(interfaces(node, self.inherited_interfaces))\n    except astroid.InferenceError:\n        node.implements = ()\n",
      "\n    def visit_classdef(self, node):\n        \"\"\"visit an astroid.Class node\n\n        * set the locals_type and instance_attrs_type mappings\n        * set the implements list and build it\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n        node.locals_type = collections.defaultdict(list)\n        if self.tag:\n            node.uid = self.generate_id()\n        \n        # NEW: Extract class variable type annotations\n        if hasattr(node, 'locals') and '__annotations__' in node.locals:\n            try:\n                annotations_node = node.locals['__annotations__'][0]\n                if hasattr(annotations_node, 'items'):\n                    for key, value in annotations_node.items:\n                        if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                            attr_name = key.value\n                            type_str = value.as_string()\n                            # Store in instance_attrs_type for consistency\n                            if not hasattr(node, 'instance_attrs_type'):\n                                node.instance_attrs_type = collections.defaultdict(list)\n                            node.instance_attrs_type[attr_name] = [type_str]\n            except (AttributeError, IndexError, KeyError):\n                pass\n        \n        # resolve ancestors\n        for baseobj in node.ancestors(recurs=False):\n            specializations = getattr(baseobj, \"specializations\", [])\n            specializations.append(node)\n            baseobj.specializations = specializations\n        # resolve instance attributes\n        node.instance_attrs_type = collections.defaultdict(list)\n        for assignattrs in node.instance_attrs.values():\n            for assignattr in assignattrs:\n                if not isinstance(assignattr, astroid.Unknown):\n                    self.handle_assignattr_type(assignattr, node)\n        # resolve implemented interface\n        try:\n            node.implements = list(utils.interfaces(node, self.inherited_interfaces))\n        except astroid.InferenceError:\n            node.implements = ()\n",
      "\ndef visit_classdef(self, node):\n    \"\"\"visit an astroid.Class node\n\n    * set the locals_type and instance_attrs_type mappings\n    * set the implements list and build it\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    if self.tag:\n        node.uid = self.generate_id()\n    \n    # NEW: Extract class variable type annotations\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        # Store in instance_attrs_type for consistency\n                        if not hasattr(node, 'instance_attrs_type'):\n                            node.instance_attrs_type = collections.defaultdict(list)\n                        node.instance_attrs_type[attr_name] = [type_str]\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    # resolve ancestors\n    for baseobj in node.ancestors(recurs=False):\n        specializations = getattr(baseobj, \"specializations\", [])\n        specializations.append(node)\n        baseobj.specializations = specializations\n    # resolve instance attributes\n    node.instance_attrs_type = collections.defaultdict(list)\n    for assignattrs in node.instance_attrs.values():\n        for assignattr in assignattrs:\n            if not isinstance(assignattr, astroid.Unknown):\n                self.handle_assignattr_type(assignattr, node)\n    # resolve implemented interface\n    try:\n        node.implements = list(interfaces(node, self.inherited_interfaces))\n    except astroid.InferenceError:\n        node.implements = ()\n",
      "\ndef visit_classdef(self, node):\n    \"\"\"visit an astroid.Class node\n\n    * set the locals_type and instance_attrs_type mappings\n    * set the implements list and build it\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    if self.tag:\n        node.uid = self.generate_id()\n    # resolve ancestors\n    for baseobj in node.ancestors(recurs=False):\n        specializations = getattr(baseobj, \"specializations\", [])\n        specializations.append(node)\n        baseobj.specializations = specializations\n    # resolve instance attributes\n    node.instance_attrs_type = collections.defaultdict(list)\n    for assignattrs in node.instance_attrs.values():\n        for assignattr in assignattrs:\n            if not isinstance(assignattr, astroid.Unknown):\n                self.handle_assignattr_type(assignattr, node)\n    \n    # NEW: Extract class variable type annotations\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        node.instance_attrs_type[attr_name].append(type_str)\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    # resolve implemented interface\n    try:\n        node.implements = list(interfaces(node, self.inherited_interfaces))\n    except astroid.InferenceError:\n        node.implements = ()\n",
      "\ndef visit_classdef(self, node):\n    \"\"\"visit an astroid.Class node\n\n    * set the locals_type and instance_attrs_type mappings\n    * set the implements list and build it\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    if self.tag:\n        node.uid = self.generate_id()\n    \n    # NEW: Extract class variable type annotations\n    node.class_annotations = {}\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        node.class_annotations[attr_name] = type_str\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    # resolve ancestors\n    for baseobj in node.ancestors(recurs=False):\n        specializations = getattr(baseobj, \"specializations\", [])\n        specializations.append(node)\n        baseobj.specializations = specializations\n    # resolve instance attributes\n    node.instance_attrs_type = collections.defaultdict(list)\n    for assignattrs in node.instance_attrs.values():\n        for assignattr in assignattrs:\n            if not isinstance(assignattr, astroid.Unknown):\n                self.handle_assignattr_type(assignattr, node)\n    # resolve implemented interface\n    try:\n        node.implements = list(interfaces(node, self.inherited_interfaces))\n    except astroid.InferenceError:\n        node.implements = ()\n",
      "\ndef visit_classdef(self, node):\n    \"\"\"visit an astroid.Class node\n\n    * set the locals_type and instance_attrs_type mappings\n    * set the implements list and build it\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    if self.tag:\n        node.uid = self.generate_id()\n    # resolve ancestors\n    for baseobj in node.ancestors(recurs=False):\n        specializations = getattr(baseobj, \"specializations\", [])\n        specializations.append(node)\n        baseobj.specializations = specializations\n    # resolve instance attributes\n    node.instance_attrs_type = collections.defaultdict(list)\n    \n    # NEW: Extract class variable type annotations\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        node.instance_attrs_type[attr_name].append(type_str)\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for assignattrs in node.instance_attrs.values():\n        for assignattr in assignattrs:\n            if not isinstance(assignattr, astroid.Unknown):\n                self.handle_assignattr_type(assignattr, node)\n    # resolve implemented interface\n    try:\n        node.implements = list(utils.interfaces(node, self.inherited_interfaces))\n    except astroid.InferenceError:\n        node.implements = ()\n",
      "\ndef visit_classdef(self, node):\n    \"\"\"visit an astroid.Class node\n\n    * set the locals_type and instance_attrs_type mappings\n    * set the implements list and build it\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    if self.tag:\n        node.uid = self.generate_id()\n    \n    # NEW: Extract class variable type annotations\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        # Store in instance_attrs_type for consistency\n                        if not hasattr(node, 'instance_attrs_type'):\n                            node.instance_attrs_type = collections.defaultdict(list)\n                        node.instance_attrs_type[attr_name] = [type_str]\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    # resolve ancestors\n    for baseobj in node.ancestors(recurs=False):\n        specializations = getattr(baseobj, \"specializations\", [])\n        specializations.append(node)\n        baseobj.specializations = specializations\n    # resolve instance attributes\n    node.instance_attrs_type = collections.defaultdict(list)\n    for assignattrs in node.instance_attrs.values():\n        for assignattr in assignattrs:\n            if not isinstance(assignattr, astroid.Unknown):\n                self.handle_assignattr_type(assignattr, node)\n    # resolve implemented interface\n    try:\n        node.implements = list(interfaces(node, self.inherited_interfaces))\n    except astroid.InferenceError:\n        node.implements = ()\n",
      "\ndef visit_classdef(self, node):\n    \"\"\"visit an astroid.Class node\n\n    * set the locals_type and instance_attrs_type mappings\n    * set the implements list and build it\n    * optionally tag the node with a unique id\n    \"\"\"\n    if hasattr(node, \"locals_type\"):\n        return\n    node.locals_type = collections.defaultdict(list)\n    if self.tag:\n        node.uid = self.generate_id()\n    \n    # NEW: Extract class variable type annotations\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        # Store in instance_attrs_type for consistency\n                        if not hasattr(node, 'instance_attrs_type'):\n                            node.instance_attrs_type = collections.defaultdict(list)\n                        node.instance_attrs_type[attr_name] = [type_str]\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    # resolve ancestors\n    for baseobj in node.ancestors(recurs=False):\n        specializations = getattr(baseobj, \"specializations\", [])\n        specializations.append(node)\n        baseobj.specializations = specializations\n    # resolve instance attributes\n    node.instance_attrs_type = collections.defaultdict(list)\n    for assignattrs in node.instance_attrs.values():\n        for assignattr in assignattrs:\n            if not isinstance(assignattr, astroid.Unknown):\n                self.handle_assignattr_type(assignattr, node)\n    # resolve implemented interface\n    try:\n        node.implements = list(interfaces(node, self.inherited_interfaces))\n    except astroid.InferenceError:\n        node.implements = ()\n"
    ],
    "Location 3 (/root/hy/projects/pylint/pylint/pyreverse/diagrams.py lines 87-90)": [
      "\ndef get_attrs(self, node):\n    \"\"\"return visible attributes, possibly with class name\"\"\"\n    attrs = []\n    properties = [\n        (n, m)\n        for n, m in node.items()\n        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n    ]\n    \n    # Include direct type annotations from __annotations__\n    annotation_attrs = []\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        annotation_attrs.append((attr_name, [type_str]))\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for node_name, associated_nodes in (\n        list(node.instance_attrs_type.items())\n        + list(node.locals_type.items())\n        + properties\n        + annotation_attrs\n    ):\n        if not self.show_attr(node_name):\n            continue\n        names = self.class_names(associated_nodes)\n        if names:\n            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n        attrs.append(node_name)\n    return sorted(attrs)\n",
      "\ndef get_attrs(self, node):\n    \"\"\"return visible attributes, possibly with class name\"\"\"\n    attrs = []\n    properties = [\n        (n, m)\n        for n, m in node.items()\n        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n    ]\n    \n    # Include direct type annotations from __annotations__\n    annotation_attrs = []\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        annotation_attrs.append((attr_name, [type_str]))\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for node_name, associated_nodes in (\n        list(node.instance_attrs_type.items())\n        + list(node.locals_type.items())\n        + properties\n        + annotation_attrs\n    ):\n        if not self.show_attr(node_name):\n            continue\n        names = self.class_names(associated_nodes)\n        if names:\n            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n        attrs.append(node_name)\n    return sorted(attrs)\n",
      "\ndef get_attrs(self, node):\n    \"\"\"return visible attributes, possibly with class name\"\"\"\n    attrs = []\n    properties = [\n        (n, m)\n        for n, m in node.items()\n        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n    ]\n    \n    # Include direct type annotations from __annotations__\n    annotation_attrs = []\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        annotation_attrs.append((attr_name, [type_str]))\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for node_name, associated_nodes in (\n        list(node.instance_attrs_type.items())\n        + list(node.locals_type.items())\n        + properties\n        + annotation_attrs\n    ):\n        if not self.show_attr(node_name):\n            continue\n        names = self.class_names(associated_nodes)\n        if names:\n            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n        attrs.append(node_name)\n    return sorted(attrs)\n",
      "\ndef get_attrs(self, node):\n    \"\"\"return visible attributes, possibly with class name\"\"\"\n    attrs = []\n    properties = [\n        (n, m)\n        for n, m in node.items()\n        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n    ]\n    \n    # Include direct type annotations from __annotations__\n    annotation_attrs = []\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        annotation_attrs.append((attr_name, [type_str]))\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for node_name, associated_nodes in (\n        list(node.instance_attrs_type.items())\n        + list(node.locals_type.items())\n        + properties\n        + annotation_attrs\n    ):\n        if not self.show_attr(node_name):\n            continue\n        names = self.class_names(associated_nodes)\n        if names:\n            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n        attrs.append(node_name)\n    return sorted(attrs)\n",
      "\ndef get_attrs(self, node):\n    \"\"\"return visible attributes, possibly with class name\"\"\"\n    attrs = []\n    properties = [\n        (n, m)\n        for n, m in node.items()\n        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n    ]\n    \n    # Include direct type annotations from __annotations__\n    annotation_attrs = []\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        annotation_attrs.append((attr_name, [type_str]))\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for node_name, associated_nodes in (\n        list(node.instance_attrs_type.items())\n        + list(node.locals_type.items())\n        + properties\n        + annotation_attrs\n    ):\n        if not self.show_attr(node_name):\n            continue\n        names = self.class_names(associated_nodes)\n        if names:\n            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n        attrs.append(node_name)\n    return sorted(attrs)\n",
      "\ndef get_attrs(self, node):\n    \"\"\"return visible attributes, possibly with class name\"\"\"\n    attrs = []\n    properties = [\n        (n, m)\n        for n, m in node.items()\n        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n    ]\n    \n    # Include direct type annotations from __annotations__\n    annotation_attrs = []\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        annotation_attrs.append((attr_name, [type_str]))\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for node_name, associated_nodes in (\n        list(node.instance_attrs_type.items())\n        + list(node.locals_type.items())\n        + properties\n        + annotation_attrs\n    ):\n        if not self.show_attr(node_name):\n            continue\n        names = self.class_names(associated_nodes)\n        if names:\n            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n        attrs.append(node_name)\n    return sorted(attrs)\n",
      "\ndef get_attrs(self, node):\n    \"\"\"return visible attributes, possibly with class name\"\"\"\n    attrs = []\n    properties = [\n        (n, m)\n        for n, m in node.items()\n        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n    ]\n    \n    # Include direct type annotations from __annotations__\n    annotation_attrs = []\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        annotation_attrs.append((attr_name, [type_str]))\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for node_name, associated_nodes in (\n        list(node.instance_attrs_type.items())\n        + list(node.locals_type.items())\n        + properties\n        + annotation_attrs\n    ):\n        if not self.show_attr(node_name):\n            continue\n        names = self.class_names(associated_nodes)\n        if names:\n            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n        attrs.append(node_name)\n    return sorted(attrs)\n",
      "\ndef get_attrs(self, node):\n    \"\"\"return visible attributes, possibly with class name\"\"\"\n    attrs = []\n    properties = [\n        (n, m)\n        for n, m in node.items()\n        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n    ]\n    \n    # Include direct type annotations from __annotations__\n    annotation_attrs = []\n    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n        try:\n            annotations_node = node.locals['__annotations__'][0]\n            if hasattr(annotations_node, 'items'):\n                for key, value in annotations_node.items:\n                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n                        attr_name = key.value\n                        type_str = value.as_string()\n                        annotation_attrs.append((attr_name, [type_str]))\n        except (AttributeError, IndexError, KeyError):\n            pass\n    \n    for node_name, associated_nodes in (\n        list(node.instance_attrs_type.items())\n        + list(node.locals_type.items())\n        + properties\n        + annotation_attrs\n    ):\n        if not self.show_attr(node_name):\n            continue\n        names = self.class_names(associated_nodes)\n        if names:\n            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n        attrs.append(node_name)\n    return sorted(attrs)\n"
    ],
    "Location 4 (/root/hy/projects/pylint/pylint/pyreverse/diagrams.py lines 100-109)": [
      "\ndef get_methods(self, node):\n    \"\"\"return visible methods\"\"\"\n    methods = [\n        m\n        for m in node.values()\n        if isinstance(m, astroid.FunctionDef)\n        and not decorated_with_property(m)\n        and self.show_attr(m.name)\n    ]\n    \n    # Ensure type annotation data is preserved on method nodes\n    for method in methods:\n        if not hasattr(method, 'param_types'):\n            method.param_types = {}\n        if not hasattr(method, 'return_type'):\n            method.return_type = None\n            \n    return sorted(methods, key=lambda n: n.name)\n",
      "\ndef get_methods(self, node):\n    \"\"\"return visible methods\"\"\"\n    methods = [\n        m\n        for m in node.values()\n        if isinstance(m, astroid.FunctionDef)\n        and not decorated_with_property(m)\n        and self.show_attr(m.name)\n    ]\n    \n    # Ensure type annotation data is preserved on method nodes\n    for method in methods:\n        if not hasattr(method, 'param_types'):\n            method.param_types = {}\n        if not hasattr(method, 'return_type'):\n            method.return_type = None\n            \n    return sorted(methods, key=lambda n: n.name)\n",
      "\ndef get_methods(self, node):\n    \"\"\"return visible methods\"\"\"\n    methods = [\n        m\n        for m in node.values()\n        if isinstance(m, astroid.FunctionDef)\n        and not decorated_with_property(m)\n        and self.show_attr(m.name)\n    ]\n    \n    # Ensure type annotation data is preserved on method nodes\n    for method in methods:\n        if not hasattr(method, 'param_types'):\n            method.param_types = {}\n        if not hasattr(method, 'return_type'):\n            method.return_type = None\n            \n    return sorted(methods, key=lambda n: n.name)\n",
      "\ndef get_methods(self, node):\n    \"\"\"return visible methods\"\"\"\n    methods = [\n        m\n        for m in node.values()\n        if isinstance(m, astroid.FunctionDef)\n        and not decorated_with_property(m)\n        and self.show_attr(m.name)\n    ]\n    \n    # Ensure type annotation data is preserved on method nodes\n    for method in methods:\n        if not hasattr(method, 'param_types'):\n            method.param_types = {}\n        if not hasattr(method, 'return_type'):\n            method.return_type = None\n            \n    return sorted(methods, key=lambda n: n.name)\n",
      "\ndef get_methods(self, node):\n    \"\"\"return visible methods\"\"\"\n    methods = [\n        m\n        for m in node.values()\n        if isinstance(m, astroid.FunctionDef)\n        and not decorated_with_property(m)\n        and self.show_attr(m.name)\n    ]\n    \n    # Ensure type annotation data is preserved on method nodes\n    for method in methods:\n        if not hasattr(method, 'param_types'):\n            method.param_types = {}\n        if not hasattr(method, 'return_type'):\n            method.return_type = None\n            \n    return sorted(methods, key=lambda n: n.name)\n",
      "\ndef get_methods(self, node):\n    \"\"\"return visible methods\"\"\"\n    methods = [\n        m\n        for m in node.values()\n        if isinstance(m, astroid.FunctionDef)\n        and not decorated_with_property(m)\n        and self.show_attr(m.name)\n    ]\n    \n    # Ensure type annotation data is preserved on method nodes\n    for method in methods:\n        if not hasattr(method, 'param_types'):\n            method.param_types = {}\n        if not hasattr(method, 'return_type'):\n            method.return_type = None\n            \n    return sorted(methods, key=lambda n: n.name)\n",
      "\ndef get_methods(self, node):\n    \"\"\"return visible methods\"\"\"\n    methods = [\n        m\n        for m in node.values()\n        if isinstance(m, astroid.FunctionDef)\n        and not decorated_with_property(m)\n        and self.show_attr(m.name)\n    ]\n    \n    # Ensure type annotation data is preserved on method nodes\n    for method in methods:\n        if not hasattr(method, 'param_types'):\n            method.param_types = {}\n        if not hasattr(method, 'return_type'):\n            method.return_type = None\n            \n    return sorted(methods, key=lambda n: n.name)\n",
      "\ndef get_methods(self, node):\n    \"\"\"return visible methods\"\"\"\n    methods = [\n        m\n        for m in node.values()\n        if isinstance(m, astroid.FunctionDef)\n        and not decorated_with_property(m)\n        and self.show_attr(m.name)\n    ]\n    \n    # Ensure type annotation data is preserved on method nodes\n    for method in methods:\n        if not hasattr(method, 'param_types'):\n            method.param_types = {}\n        if not hasattr(method, 'return_type'):\n            method.return_type = None\n            \n    return sorted(methods, key=lambda n: n.name)\n"
    ],
    "Location 5 (/root/hy/projects/pylint/pylint/pyreverse/writer.py lines 126-145)": [
      "\ndef get_values(self, obj):\n    \"\"\"get label and shape for classes.\n\n    The label contains all attributes and methods\n    \"\"\"\n    label = obj.title\n    if obj.shape == \"interface\":\n        label = \"«interface»\\\\n%s\" % label\n    if not self.config.only_classnames:\n        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n        for func in obj.methods:\n            # Build parameter list with type annotations\n            args = []\n            if func.args.args:\n                for arg in func.args.args:\n                    if arg.name == \"self\":\n                        continue\n                    # Include type annotation if available\n                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                    else:\n                        args.append(arg.name)\n            \n            # Build method signature with return type if available\n            method_sig = f\"{func.name}({', '.join(args)})\"\n            if hasattr(func, 'return_type') and func.return_type:\n                method_sig += f\" -> {func.return_type}\"\n                \n            label = r\"{}{}\\l\".format(label, method_sig)\n        label = \"{%s}\" % label\n    if is_exception(obj.node):\n        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n    return dict(label=label, shape=\"record\")\n",
      "\ndef get_values(self, obj):\n    \"\"\"get label and shape for classes.\n\n    The label contains all attributes and methods\n    \"\"\"\n    label = obj.title\n    if obj.shape == \"interface\":\n        label = \"«interface»\\\\n%s\" % label\n    if not self.config.only_classnames:\n        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n        for func in obj.methods:\n            # Build parameter list with type annotations\n            args = []\n            if func.args.args:\n                for arg in func.args.args:\n                    if arg.name == \"self\":\n                        continue\n                    # Include type annotation if available\n                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                    else:\n                        args.append(arg.name)\n            \n            # Build method signature with return type if available\n            method_sig = f\"{func.name}({', '.join(args)})\"\n            if hasattr(func, 'return_type') and func.return_type:\n                method_sig += f\" -> {func.return_type}\"\n                \n            label = r\"{}{}\\l\".format(label, method_sig)\n        label = \"{%s}\" % label\n    if is_exception(obj.node):\n        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n    return dict(label=label, shape=\"record\")\n",
      "\ndef get_values(self, obj):\n    \"\"\"get label and shape for classes.\n\n    The label contains all attributes and methods\n    \"\"\"\n    label = obj.title\n    if obj.shape == \"interface\":\n        label = \"«interface»\\\\n%s\" % label\n    if not self.config.only_classnames:\n        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n        for func in obj.methods:\n            # Build parameter list with type annotations\n            args = []\n            for arg in func.args.args:\n                if arg.name == \"self\":\n                    continue\n                # Include type annotation if available\n                if hasattr(func, 'param_types') and arg.name in func.param_types:\n                    args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                else:\n                    args.append(arg.name)\n            \n            # Include return type if available\n            method_sig = f\"{func.name}({', '.join(args)})\"\n            if hasattr(func, 'return_type') and func.return_type:\n                method_sig += f\" -> {func.return_type}\"\n                \n            label = r\"{}{}\\l\".format(label, method_sig)\n        label = \"{%s}\" % label\n    if is_exception(obj.node):\n        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n    return dict(label=label, shape=\"record\")\n",
      "\ndef get_values(self, obj):\n    \"\"\"get label and shape for classes.\n\n    The label contains all attributes and methods\n    \"\"\"\n    label = obj.title\n    if obj.shape == \"interface\":\n        label = \"«interface»\\\\n%s\" % label\n    if not self.config.only_classnames:\n        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n        for func in obj.methods:\n            # Build parameter list with type annotations\n            args = []\n            if func.args.args:\n                for arg in func.args.args:\n                    if arg.name == \"self\":\n                        continue\n                    # Include type annotation if available\n                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                    else:\n                        args.append(arg.name)\n            \n            # Build method signature with return type if available\n            method_sig = f\"{func.name}({', '.join(args)})\"\n            if hasattr(func, 'return_type') and func.return_type:\n                method_sig += f\" -> {func.return_type}\"\n                \n            label = r\"{}{}\\l\".format(label, method_sig)\n        label = \"{%s}\" % label\n    if is_exception(obj.node):\n        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n    return dict(label=label, shape=\"record\")\n",
      "\n    def get_values(self, obj):\n        \"\"\"get label and shape for classes.\n\n        The label contains all attributes and methods\n        \"\"\"\n        label = obj.title\n        if obj.shape == \"interface\":\n            label = \"«interface»\\\\n%s\" % label\n        if not self.config.only_classnames:\n            label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n            for func in obj.methods:\n                # Build parameter list with type annotations\n                args = []\n                if func.args.args:\n                    for arg in func.args.args:\n                        if arg.name == \"self\":\n                            continue\n                        # Include type annotation if available\n                        if hasattr(func, 'param_types') and arg.name in func.param_types:\n                            args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                        else:\n                            args.append(arg.name)\n                \n                # Build method signature with return type\n                method_sig = f\"{func.name}({', '.join(args)})\"\n                if hasattr(func, 'return_type') and func.return_type:\n                    method_sig += f\" -> {func.return_type}\"\n                    \n                label = r\"{}{}\\l\".format(label, method_sig)\n            label = \"{%s}\" % label\n        if is_exception(obj.node):\n            return dict(fontcolor=\"red\", label=label, shape=\"record\")\n        return dict(label=label, shape=\"record\")\n",
      "\ndef get_values(self, obj):\n    \"\"\"get label and shape for classes.\n\n    The label contains all attributes and methods\n    \"\"\"\n    label = obj.title\n    if obj.shape == \"interface\":\n        label = \"«interface»\\\\n%s\" % label\n    if not self.config.only_classnames:\n        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n        for func in obj.methods:\n            # Build parameter list with type annotations\n            args = []\n            if func.args.args:\n                for arg in func.args.args:\n                    if arg.name == \"self\":\n                        continue\n                    # Include type annotation if available\n                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                    else:\n                        args.append(arg.name)\n            \n            # Build method signature with return type if available\n            method_sig = f\"{func.name}({', '.join(args)})\"\n            if hasattr(func, 'return_type') and func.return_type:\n                method_sig += f\" -> {func.return_type}\"\n                \n            label = r\"{}{}\\l\".format(label, method_sig)\n        label = \"{%s}\" % label\n    if is_exception(obj.node):\n        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n    return dict(label=label, shape=\"record\")\n",
      "\ndef get_values(self, obj):\n    \"\"\"get label and shape for classes.\n\n    The label contains all attributes and methods\n    \"\"\"\n    label = obj.title\n    if obj.shape == \"interface\":\n        label = \"«interface»\\\\n%s\" % label\n    if not self.config.only_classnames:\n        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n        for func in obj.methods:\n            if func.args.args:\n                args = []\n                for arg in func.args.args:\n                    if arg.name == \"self\":\n                        continue\n                    # Include type annotation if available\n                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                    else:\n                        args.append(arg.name)\n            else:\n                args = []\n            \n            # Build method signature with return type if available\n            method_sig = f\"{func.name}({', '.join(args)})\"\n            if hasattr(func, 'return_type') and func.return_type:\n                method_sig += f\" -> {func.return_type}\"\n                \n            label = r\"{}{}\\l\".format(label, method_sig)\n        label = \"{%s}\" % label\n    if is_exception(obj.node):\n        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n    return dict(label=label, shape=\"record\")\n",
      "\ndef get_values(self, obj):\n    \"\"\"get label and shape for classes.\n\n    The label contains all attributes and methods\n    \"\"\"\n    label = obj.title\n    if obj.shape == \"interface\":\n        label = \"«interface»\\\\n%s\" % label\n    if not self.config.only_classnames:\n        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n        for func in obj.methods:\n            # Build parameter list with type annotations\n            args = []\n            for arg in func.args.args:\n                if arg.name == \"self\":\n                    continue\n                # Include type annotation if available\n                if hasattr(func, 'param_types') and arg.name in func.param_types:\n                    args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                else:\n                    args.append(arg.name)\n            \n            # Include return type if available\n            method_sig = f\"{func.name}({', '.join(args)})\"\n            if hasattr(func, 'return_type') and func.return_type:\n                method_sig += f\" -> {func.return_type}\"\n                \n            label = r\"{}{}\\l\".format(label, method_sig)\n        label = \"{%s}\" % label\n    if is_exception(obj.node):\n        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n    return dict(label=label, shape=\"record\")\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..1d430644b 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -84,10 +84,26 @@ class ClassDiagram(Figure, FilterMixIn):\n             for n, m in node.items()\n             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n         ]\n+\n+        # Include direct type annotations from __annotations__\n+        annotation_attrs = []\n+        if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+            try:\n+                annotations_node = node.locals['__annotations__'][0]\n+                if hasattr(annotations_node, 'items'):\n+                    for key, value in annotations_node.items:\n+                        if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                            attr_name = key.value\n+                            type_str = value.as_string()\n+                            annotation_attrs.append((attr_name, [type_str]))\n+            except (AttributeError, IndexError, KeyError):\n+                pass\n+        \n         for node_name, associated_nodes in (\n             list(node.instance_attrs_type.items())\n             + list(node.locals_type.items())\n             + properties\n+            + annotation_attrs  # Include annotation-based attributes\n         ):\n             if not self.show_attr(node_name):\n                 continue\n@@ -97,6 +113,7 @@ class ClassDiagram(Figure, FilterMixIn):\n             attrs.append(node_name)\n         return sorted(attrs)\n \n+\n     def get_methods(self, node):\n         \"\"\"return visible methods\"\"\"\n         methods = [\n@@ -106,6 +123,14 @@ class ClassDiagram(Figure, FilterMixIn):\n             and not decorated_with_property(m)\n             and self.show_attr(m.name)\n         ]\n+        \n+        # Ensure type annotation data is preserved on method nodes\n+        for method in methods:\n+            if not hasattr(method, 'param_types'):\n+                method.param_types = {}\n+            if not hasattr(method, 'return_type'):\n+                method.return_type = None\n+                \n         return sorted(methods, key=lambda n: n.name)\n \n     def add_object(self, title, node):\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..ffc83623c 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -143,6 +143,7 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if self.tag:\n             node.uid = self.generate_id()\n \n+\n     def visit_classdef(self, node):\n         \"\"\"visit an astroid.Class node\n \n@@ -162,6 +163,21 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n             baseobj.specializations = specializations\n         # resolve instance attributes\n         node.instance_attrs_type = collections.defaultdict(list)\n+        \n+        # Extract class variable type annotations\n+        if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+            try:\n+                annotations_node = node.locals['__annotations__'][0]\n+                if hasattr(annotations_node, 'items'):\n+                    for key, value in annotations_node.items:\n+                        if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                            attr_name = key.value\n+                            type_str = value.as_string()\n+                            # Store in instance_attrs_type for consistency\n+                            node.instance_attrs_type[attr_name] = [type_str]\n+            except (AttributeError, IndexError, KeyError):\n+                pass\n+        \n         for assignattrs in node.instance_attrs.values():\n             for assignattr in assignattrs:\n                 if not isinstance(assignattr, astroid.Unknown):\n@@ -172,6 +188,7 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         except astroid.InferenceError:\n             node.implements = ()\n \n+\n     def visit_functiondef(self, node):\n         \"\"\"visit an astroid.Function node\n \n@@ -181,6 +198,26 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if hasattr(node, \"locals_type\"):\n             return\n         node.locals_type = collections.defaultdict(list)\n+        \n+        # Extract parameter type annotations\n+        if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n+            node.param_types = {}\n+            for i, arg in enumerate(node.args.args):\n+                if i < len(node.args.annotations) and node.args.annotations[i]:\n+                    try:\n+                        # Convert annotation to string representation\n+                        annotation_str = node.args.annotations[i].as_string()\n+                        node.param_types[arg.name] = annotation_str\n+                    except AttributeError:\n+                        pass\n+        \n+        # Extract return type annotation\n+        if hasattr(node, 'returns') and node.returns:\n+            try:\n+                node.return_type = node.returns.as_string()\n+            except AttributeError:\n+                pass\n+                \n         if self.tag:\n             node.uid = self.generate_id()\n \ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..714794de2 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -123,6 +123,7 @@ class DotWriter(DiagramWriter):\n         \"\"\"get project title\"\"\"\n         return obj.title\n \n+\n     def get_values(self, obj):\n         \"\"\"get label and shape for classes.\n \n@@ -135,10 +136,25 @@ class DotWriter(DiagramWriter):\n             label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n             for func in obj.methods:\n                 if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n+                    # Build parameter list with type annotations\n+                    args = []\n+                    for arg in func.args.args:\n+                        if arg.name == \"self\":\n+                            continue\n+                        # Include type annotation if available\n+                        if hasattr(func, 'param_types') and arg.name in func.param_types:\n+                            args.append(\"{}: {}\".format(arg.name, func.param_types[arg.name]))\n+                        else:\n+                            args.append(arg.name)\n                 else:\n                     args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n+                \n+                # Include return type if available\n+                method_sig = \"{}({})\".format(func.name, \", \".join(args))\n+                if hasattr(func, 'return_type') and func.return_type:\n+                    method_sig += \" -> {}\".format(func.return_type)\n+                    \n+                label = r\"{}{}\\l\".format(label, method_sig)\n             label = \"{%s}\" % label\n         if is_exception(obj.node):\n             return dict(fontcolor=\"red\", label=label, shape=\"record\")\n",
    "variant_0": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..9dcae19eb 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -84,10 +84,43 @@ class ClassDiagram(Figure, FilterMixIn):\n             for n, m in node.items()\n             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n         ]\n-        for node_name, associated_nodes in (\n-            list(node.instance_attrs_type.items())\n-            + list(node.locals_type.items())\n-            + properties\n+\n+def get_attrs(self, node):\n+    \"\"\"return visible attributes, possibly with class name\"\"\"\n+    attrs = []\n+    properties = [\n+        (n, m)\n+        for n, m in node.items()\n+        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n+    ]\n+    \n+    # Include direct type annotations from __annotations__\n+    annotation_attrs = []\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+        try:\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        annotation_attrs.append((attr_name, [type_str]))\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for node_name, associated_nodes in (\n+        list(node.instance_attrs_type.items())\n+        + list(node.locals_type.items())\n+        + properties\n+        + annotation_attrs\n+    ):\n+        if not self.show_attr(node_name):\n+            continue\n+        names = self.class_names(associated_nodes)\n+        if names:\n+            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n+        attrs.append(node_name)\n+    return sorted(attrs)\n         ):\n             if not self.show_attr(node_name):\n                 continue\n@@ -97,16 +130,25 @@ class ClassDiagram(Figure, FilterMixIn):\n             attrs.append(node_name)\n         return sorted(attrs)\n \n-    def get_methods(self, node):\n-        \"\"\"return visible methods\"\"\"\n-        methods = [\n-            m\n-            for m in node.values()\n-            if isinstance(m, astroid.FunctionDef)\n-            and not decorated_with_property(m)\n-            and self.show_attr(m.name)\n-        ]\n-        return sorted(methods, key=lambda n: n.name)\n+\n+def get_methods(self, node):\n+    \"\"\"return visible methods\"\"\"\n+    methods = [\n+        m\n+        for m in node.values()\n+        if isinstance(m, astroid.FunctionDef)\n+        and not decorated_with_property(m)\n+        and self.show_attr(m.name)\n+    ]\n+    \n+    # Ensure type annotation data is preserved on method nodes\n+    for method in methods:\n+        if not hasattr(method, 'param_types'):\n+            method.param_types = {}\n+        if not hasattr(method, 'return_type'):\n+            method.return_type = None\n+            \n+    return sorted(methods, key=lambda n: n.name)\n \n     def add_object(self, title, node):\n         \"\"\"create a diagram object\"\"\"\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..1f4d7b7ba 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -143,46 +143,84 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if self.tag:\n             node.uid = self.generate_id()\n \n-    def visit_classdef(self, node):\n-        \"\"\"visit an astroid.Class node\n \n-        * set the locals_type and instance_attrs_type mappings\n-        * set the implements list and build it\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n-        # resolve ancestors\n-        for baseobj in node.ancestors(recurs=False):\n-            specializations = getattr(baseobj, \"specializations\", [])\n-            specializations.append(node)\n-            baseobj.specializations = specializations\n-        # resolve instance attributes\n-        node.instance_attrs_type = collections.defaultdict(list)\n-        for assignattrs in node.instance_attrs.values():\n-            for assignattr in assignattrs:\n-                if not isinstance(assignattr, astroid.Unknown):\n-                    self.handle_assignattr_type(assignattr, node)\n-        # resolve implemented interface\n+def visit_classdef(self, node):\n+    \"\"\"visit an astroid.Class node\n+\n+    * set the locals_type and instance_attrs_type mappings\n+    * set the implements list and build it\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    if self.tag:\n+        node.uid = self.generate_id()\n+    \n+    # resolve ancestors\n+    for baseobj in node.ancestors(recurs=False):\n+        specializations = getattr(baseobj, \"specializations\", [])\n+        specializations.append(node)\n+        baseobj.specializations = specializations\n+    \n+    # resolve instance attributes\n+    node.instance_attrs_type = collections.defaultdict(list)\n+    \n+    # NEW: Extract class variable type annotations from __annotations__\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n         try:\n-            node.implements = list(interfaces(node, self.inherited_interfaces))\n-        except astroid.InferenceError:\n-            node.implements = ()\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        node.instance_attrs_type[attr_name].append(type_str)\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for assignattrs in node.instance_attrs.values():\n+        for assignattr in assignattrs:\n+            if not isinstance(assignattr, astroid.Unknown):\n+                self.handle_assignattr_type(assignattr, node)\n+    # resolve implemented interface\n+    try:\n+        node.implements = list(utils.interfaces(node, self.inherited_interfaces))\n+    except astroid.InferenceError:\n+        node.implements = ()\n \n-    def visit_functiondef(self, node):\n-        \"\"\"visit an astroid.Function node\n \n-        * set the locals_type mapping\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n+def visit_functiondef(self, node):\n+    \"\"\"visit an astroid.Function node\n+\n+    * set the locals_type mapping\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    \n+    # Extract parameter type annotations\n+    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n+        node.param_types = {}\n+        for i, arg in enumerate(node.args.args):\n+            if i < len(node.args.annotations) and node.args.annotations[i]:\n+                try:\n+                    # Convert annotation to string representation\n+                    annotation_str = node.args.annotations[i].as_string()\n+                    node.param_types[arg.name] = annotation_str\n+                except AttributeError:\n+                    pass\n+    \n+    # Extract return type annotation\n+    if hasattr(node, 'returns') and node.returns:\n+        try:\n+            node.return_type = node.returns.as_string()\n+        except AttributeError:\n+            pass\n+            \n+    if self.tag:\n+        node.uid = self.generate_id()\n \n     link_project = visit_project\n     link_module = visit_module\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..4800ad388 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -123,26 +123,41 @@ class DotWriter(DiagramWriter):\n         \"\"\"get project title\"\"\"\n         return obj.title\n \n-    def get_values(self, obj):\n-        \"\"\"get label and shape for classes.\n \n-        The label contains all attributes and methods\n-        \"\"\"\n-        label = obj.title\n-        if obj.shape == \"interface\":\n-            label = \"«interface»\\\\n%s\" % label\n-        if not self.config.only_classnames:\n-            label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n-            for func in obj.methods:\n-                if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n-                else:\n-                    args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n-            label = \"{%s}\" % label\n-        if is_exception(obj.node):\n-            return dict(fontcolor=\"red\", label=label, shape=\"record\")\n-        return dict(label=label, shape=\"record\")\n+def get_values(self, obj):\n+    \"\"\"get label and shape for classes.\n+\n+    The label contains all attributes and methods\n+    \"\"\"\n+    label = obj.title\n+    if obj.shape == \"interface\":\n+        label = \"«interface»\\\\n%s\" % label\n+    if not self.config.only_classnames:\n+        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n+        for func in obj.methods:\n+            if func.args.args:\n+                args = []\n+                for arg in func.args.args:\n+                    if arg.name == \"self\":\n+                        continue\n+                    # Include type annotation if available\n+                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n+                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n+                    else:\n+                        args.append(arg.name)\n+            else:\n+                args = []\n+            \n+            # Build method signature with return type if available\n+            method_sig = f\"{func.name}({', '.join(args)})\"\n+            if hasattr(func, 'return_type') and func.return_type:\n+                method_sig += f\" -> {func.return_type}\"\n+                \n+            label = r\"{}{}\\l\".format(label, method_sig)\n+        label = \"{%s}\" % label\n+    if is_exception(obj.node):\n+        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n+    return dict(label=label, shape=\"record\")\n \n     def close_graph(self):\n         \"\"\"print the dot graph into <file_name>\"\"\"\n",
    "variant_1": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..9dcae19eb 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -84,10 +84,43 @@ class ClassDiagram(Figure, FilterMixIn):\n             for n, m in node.items()\n             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n         ]\n-        for node_name, associated_nodes in (\n-            list(node.instance_attrs_type.items())\n-            + list(node.locals_type.items())\n-            + properties\n+\n+def get_attrs(self, node):\n+    \"\"\"return visible attributes, possibly with class name\"\"\"\n+    attrs = []\n+    properties = [\n+        (n, m)\n+        for n, m in node.items()\n+        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n+    ]\n+    \n+    # Include direct type annotations from __annotations__\n+    annotation_attrs = []\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+        try:\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        annotation_attrs.append((attr_name, [type_str]))\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for node_name, associated_nodes in (\n+        list(node.instance_attrs_type.items())\n+        + list(node.locals_type.items())\n+        + properties\n+        + annotation_attrs\n+    ):\n+        if not self.show_attr(node_name):\n+            continue\n+        names = self.class_names(associated_nodes)\n+        if names:\n+            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n+        attrs.append(node_name)\n+    return sorted(attrs)\n         ):\n             if not self.show_attr(node_name):\n                 continue\n@@ -97,16 +130,25 @@ class ClassDiagram(Figure, FilterMixIn):\n             attrs.append(node_name)\n         return sorted(attrs)\n \n-    def get_methods(self, node):\n-        \"\"\"return visible methods\"\"\"\n-        methods = [\n-            m\n-            for m in node.values()\n-            if isinstance(m, astroid.FunctionDef)\n-            and not decorated_with_property(m)\n-            and self.show_attr(m.name)\n-        ]\n-        return sorted(methods, key=lambda n: n.name)\n+\n+def get_methods(self, node):\n+    \"\"\"return visible methods\"\"\"\n+    methods = [\n+        m\n+        for m in node.values()\n+        if isinstance(m, astroid.FunctionDef)\n+        and not decorated_with_property(m)\n+        and self.show_attr(m.name)\n+    ]\n+    \n+    # Ensure type annotation data is preserved on method nodes\n+    for method in methods:\n+        if not hasattr(method, 'param_types'):\n+            method.param_types = {}\n+        if not hasattr(method, 'return_type'):\n+            method.return_type = None\n+            \n+    return sorted(methods, key=lambda n: n.name)\n \n     def add_object(self, title, node):\n         \"\"\"create a diagram object\"\"\"\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..f23dd2209 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -143,46 +143,85 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if self.tag:\n             node.uid = self.generate_id()\n \n-    def visit_classdef(self, node):\n-        \"\"\"visit an astroid.Class node\n \n-        * set the locals_type and instance_attrs_type mappings\n-        * set the implements list and build it\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n-        # resolve ancestors\n-        for baseobj in node.ancestors(recurs=False):\n-            specializations = getattr(baseobj, \"specializations\", [])\n-            specializations.append(node)\n-            baseobj.specializations = specializations\n-        # resolve instance attributes\n-        node.instance_attrs_type = collections.defaultdict(list)\n-        for assignattrs in node.instance_attrs.values():\n-            for assignattr in assignattrs:\n-                if not isinstance(assignattr, astroid.Unknown):\n-                    self.handle_assignattr_type(assignattr, node)\n-        # resolve implemented interface\n+def visit_classdef(self, node):\n+    \"\"\"visit an astroid.Class node\n+\n+    * set the locals_type and instance_attrs_type mappings\n+    * set the implements list and build it\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    if self.tag:\n+        node.uid = self.generate_id()\n+    \n+    # NEW: Extract class variable type annotations\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n         try:\n-            node.implements = list(interfaces(node, self.inherited_interfaces))\n-        except astroid.InferenceError:\n-            node.implements = ()\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        # Store in instance_attrs_type for consistency\n+                        if not hasattr(node, 'instance_attrs_type'):\n+                            node.instance_attrs_type = collections.defaultdict(list)\n+                        node.instance_attrs_type[attr_name] = [type_str]\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    # resolve ancestors\n+    for baseobj in node.ancestors(recurs=False):\n+        specializations = getattr(baseobj, \"specializations\", [])\n+        specializations.append(node)\n+        baseobj.specializations = specializations\n+    # resolve instance attributes\n+    node.instance_attrs_type = collections.defaultdict(list)\n+    for assignattrs in node.instance_attrs.values():\n+        for assignattr in assignattrs:\n+            if not isinstance(assignattr, astroid.Unknown):\n+                self.handle_assignattr_type(assignattr, node)\n+    # resolve implemented interface\n+    try:\n+        node.implements = list(interfaces(node, self.inherited_interfaces))\n+    except astroid.InferenceError:\n+        node.implements = ()\n \n-    def visit_functiondef(self, node):\n-        \"\"\"visit an astroid.Function node\n \n-        * set the locals_type mapping\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n+def visit_functiondef(self, node):\n+    \"\"\"visit an astroid.Function node\n+\n+    * set the locals_type mapping\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    \n+    # Extract parameter type annotations\n+    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n+        node.param_types = {}\n+        for i, arg in enumerate(node.args.args):\n+            if i < len(node.args.annotations) and node.args.annotations[i]:\n+                try:\n+                    # Convert annotation to string representation\n+                    annotation_str = node.args.annotations[i].as_string()\n+                    node.param_types[arg.name] = annotation_str\n+                except AttributeError:\n+                    pass\n+    \n+    # Extract return type annotation\n+    if hasattr(node, 'returns') and node.returns:\n+        try:\n+            node.return_type = node.returns.as_string()\n+        except AttributeError:\n+            pass\n+            \n+    if self.tag:\n+        node.uid = self.generate_id()\n \n     link_project = visit_project\n     link_module = visit_module\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..978a8d9c6 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -123,26 +123,40 @@ class DotWriter(DiagramWriter):\n         \"\"\"get project title\"\"\"\n         return obj.title\n \n-    def get_values(self, obj):\n-        \"\"\"get label and shape for classes.\n \n-        The label contains all attributes and methods\n-        \"\"\"\n-        label = obj.title\n-        if obj.shape == \"interface\":\n-            label = \"«interface»\\\\n%s\" % label\n-        if not self.config.only_classnames:\n-            label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n-            for func in obj.methods:\n-                if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n-                else:\n-                    args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n-            label = \"{%s}\" % label\n-        if is_exception(obj.node):\n-            return dict(fontcolor=\"red\", label=label, shape=\"record\")\n-        return dict(label=label, shape=\"record\")\n+def get_values(self, obj):\n+    \"\"\"get label and shape for classes.\n+\n+    The label contains all attributes and methods\n+    \"\"\"\n+    label = obj.title\n+    if obj.shape == \"interface\":\n+        label = \"«interface»\\\\n%s\" % label\n+    if not self.config.only_classnames:\n+        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n+        for func in obj.methods:\n+            # Build parameter list with type annotations\n+            args = []\n+            if func.args.args:\n+                for arg in func.args.args:\n+                    if arg.name == \"self\":\n+                        continue\n+                    # Include type annotation if available\n+                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n+                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n+                    else:\n+                        args.append(arg.name)\n+            \n+            # Build method signature with return type if available\n+            method_sig = f\"{func.name}({', '.join(args)})\"\n+            if hasattr(func, 'return_type') and func.return_type:\n+                method_sig += f\" -> {func.return_type}\"\n+                \n+            label = r\"{}{}\\l\".format(label, method_sig)\n+        label = \"{%s}\" % label\n+    if is_exception(obj.node):\n+        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n+    return dict(label=label, shape=\"record\")\n \n     def close_graph(self):\n         \"\"\"print the dot graph into <file_name>\"\"\"\n",
    "variant_2": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..9dcae19eb 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -84,10 +84,43 @@ class ClassDiagram(Figure, FilterMixIn):\n             for n, m in node.items()\n             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n         ]\n-        for node_name, associated_nodes in (\n-            list(node.instance_attrs_type.items())\n-            + list(node.locals_type.items())\n-            + properties\n+\n+def get_attrs(self, node):\n+    \"\"\"return visible attributes, possibly with class name\"\"\"\n+    attrs = []\n+    properties = [\n+        (n, m)\n+        for n, m in node.items()\n+        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n+    ]\n+    \n+    # Include direct type annotations from __annotations__\n+    annotation_attrs = []\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+        try:\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        annotation_attrs.append((attr_name, [type_str]))\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for node_name, associated_nodes in (\n+        list(node.instance_attrs_type.items())\n+        + list(node.locals_type.items())\n+        + properties\n+        + annotation_attrs\n+    ):\n+        if not self.show_attr(node_name):\n+            continue\n+        names = self.class_names(associated_nodes)\n+        if names:\n+            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n+        attrs.append(node_name)\n+    return sorted(attrs)\n         ):\n             if not self.show_attr(node_name):\n                 continue\n@@ -97,16 +130,25 @@ class ClassDiagram(Figure, FilterMixIn):\n             attrs.append(node_name)\n         return sorted(attrs)\n \n-    def get_methods(self, node):\n-        \"\"\"return visible methods\"\"\"\n-        methods = [\n-            m\n-            for m in node.values()\n-            if isinstance(m, astroid.FunctionDef)\n-            and not decorated_with_property(m)\n-            and self.show_attr(m.name)\n-        ]\n-        return sorted(methods, key=lambda n: n.name)\n+\n+def get_methods(self, node):\n+    \"\"\"return visible methods\"\"\"\n+    methods = [\n+        m\n+        for m in node.values()\n+        if isinstance(m, astroid.FunctionDef)\n+        and not decorated_with_property(m)\n+        and self.show_attr(m.name)\n+    ]\n+    \n+    # Ensure type annotation data is preserved on method nodes\n+    for method in methods:\n+        if not hasattr(method, 'param_types'):\n+            method.param_types = {}\n+        if not hasattr(method, 'return_type'):\n+            method.return_type = None\n+            \n+    return sorted(methods, key=lambda n: n.name)\n \n     def add_object(self, title, node):\n         \"\"\"create a diagram object\"\"\"\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..7b539ed77 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -143,6 +143,7 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if self.tag:\n             node.uid = self.generate_id()\n \n+\n     def visit_classdef(self, node):\n         \"\"\"visit an astroid.Class node\n \n@@ -155,6 +156,23 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         node.locals_type = collections.defaultdict(list)\n         if self.tag:\n             node.uid = self.generate_id()\n+        \n+        # NEW: Extract class variable type annotations\n+        if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+            try:\n+                annotations_node = node.locals['__annotations__'][0]\n+                if hasattr(annotations_node, 'items'):\n+                    for key, value in annotations_node.items:\n+                        if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                            attr_name = key.value\n+                            type_str = value.as_string()\n+                            # Store in instance_attrs_type for consistency\n+                            if not hasattr(node, 'instance_attrs_type'):\n+                                node.instance_attrs_type = collections.defaultdict(list)\n+                            node.instance_attrs_type[attr_name] = [type_str]\n+            except (AttributeError, IndexError, KeyError):\n+                pass\n+        \n         # resolve ancestors\n         for baseobj in node.ancestors(recurs=False):\n             specializations = getattr(baseobj, \"specializations\", [])\n@@ -168,21 +186,46 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n                     self.handle_assignattr_type(assignattr, node)\n         # resolve implemented interface\n         try:\n-            node.implements = list(interfaces(node, self.inherited_interfaces))\n+            node.implements = list(utils.interfaces(node, self.inherited_interfaces))\n         except astroid.InferenceError:\n             node.implements = ()\n \n-    def visit_functiondef(self, node):\n-        \"\"\"visit an astroid.Function node\n \n-        * set the locals_type mapping\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n+def visit_functiondef(self, node):\n+    \"\"\"visit an astroid.Function node\n+\n+    * set the locals_type mapping\n+    * extract parameter and return type annotations\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    \n+    # Extract parameter type annotations\n+    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n+        node.param_types = {}\n+        for i, arg in enumerate(node.args.args):\n+            if i < len(node.args.annotations) and node.args.annotations[i]:\n+                try:\n+                    annotation_str = node.args.annotations[i].as_string()\n+                    node.param_types[arg.name] = annotation_str\n+                except AttributeError:\n+                    pass\n+    else:\n+        node.param_types = {}\n+    \n+    # Extract return type annotation\n+    if hasattr(node, 'returns') and node.returns:\n+        try:\n+            node.return_type = node.returns.as_string()\n+        except AttributeError:\n+            node.return_type = None\n+    else:\n+        node.return_type = None\n+        \n+    if self.tag:\n+        node.uid = self.generate_id()\n \n     link_project = visit_project\n     link_module = visit_module\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..978a8d9c6 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -123,26 +123,40 @@ class DotWriter(DiagramWriter):\n         \"\"\"get project title\"\"\"\n         return obj.title\n \n-    def get_values(self, obj):\n-        \"\"\"get label and shape for classes.\n \n-        The label contains all attributes and methods\n-        \"\"\"\n-        label = obj.title\n-        if obj.shape == \"interface\":\n-            label = \"«interface»\\\\n%s\" % label\n-        if not self.config.only_classnames:\n-            label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n-            for func in obj.methods:\n-                if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n-                else:\n-                    args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n-            label = \"{%s}\" % label\n-        if is_exception(obj.node):\n-            return dict(fontcolor=\"red\", label=label, shape=\"record\")\n-        return dict(label=label, shape=\"record\")\n+def get_values(self, obj):\n+    \"\"\"get label and shape for classes.\n+\n+    The label contains all attributes and methods\n+    \"\"\"\n+    label = obj.title\n+    if obj.shape == \"interface\":\n+        label = \"«interface»\\\\n%s\" % label\n+    if not self.config.only_classnames:\n+        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n+        for func in obj.methods:\n+            # Build parameter list with type annotations\n+            args = []\n+            if func.args.args:\n+                for arg in func.args.args:\n+                    if arg.name == \"self\":\n+                        continue\n+                    # Include type annotation if available\n+                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n+                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n+                    else:\n+                        args.append(arg.name)\n+            \n+            # Build method signature with return type if available\n+            method_sig = f\"{func.name}({', '.join(args)})\"\n+            if hasattr(func, 'return_type') and func.return_type:\n+                method_sig += f\" -> {func.return_type}\"\n+                \n+            label = r\"{}{}\\l\".format(label, method_sig)\n+        label = \"{%s}\" % label\n+    if is_exception(obj.node):\n+        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n+    return dict(label=label, shape=\"record\")\n \n     def close_graph(self):\n         \"\"\"print the dot graph into <file_name>\"\"\"\n",
    "variant_3": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..9dcae19eb 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -84,10 +84,43 @@ class ClassDiagram(Figure, FilterMixIn):\n             for n, m in node.items()\n             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n         ]\n-        for node_name, associated_nodes in (\n-            list(node.instance_attrs_type.items())\n-            + list(node.locals_type.items())\n-            + properties\n+\n+def get_attrs(self, node):\n+    \"\"\"return visible attributes, possibly with class name\"\"\"\n+    attrs = []\n+    properties = [\n+        (n, m)\n+        for n, m in node.items()\n+        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n+    ]\n+    \n+    # Include direct type annotations from __annotations__\n+    annotation_attrs = []\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+        try:\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        annotation_attrs.append((attr_name, [type_str]))\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for node_name, associated_nodes in (\n+        list(node.instance_attrs_type.items())\n+        + list(node.locals_type.items())\n+        + properties\n+        + annotation_attrs\n+    ):\n+        if not self.show_attr(node_name):\n+            continue\n+        names = self.class_names(associated_nodes)\n+        if names:\n+            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n+        attrs.append(node_name)\n+    return sorted(attrs)\n         ):\n             if not self.show_attr(node_name):\n                 continue\n@@ -97,16 +130,25 @@ class ClassDiagram(Figure, FilterMixIn):\n             attrs.append(node_name)\n         return sorted(attrs)\n \n-    def get_methods(self, node):\n-        \"\"\"return visible methods\"\"\"\n-        methods = [\n-            m\n-            for m in node.values()\n-            if isinstance(m, astroid.FunctionDef)\n-            and not decorated_with_property(m)\n-            and self.show_attr(m.name)\n-        ]\n-        return sorted(methods, key=lambda n: n.name)\n+\n+def get_methods(self, node):\n+    \"\"\"return visible methods\"\"\"\n+    methods = [\n+        m\n+        for m in node.values()\n+        if isinstance(m, astroid.FunctionDef)\n+        and not decorated_with_property(m)\n+        and self.show_attr(m.name)\n+    ]\n+    \n+    # Ensure type annotation data is preserved on method nodes\n+    for method in methods:\n+        if not hasattr(method, 'param_types'):\n+            method.param_types = {}\n+        if not hasattr(method, 'return_type'):\n+            method.return_type = None\n+            \n+    return sorted(methods, key=lambda n: n.name)\n \n     def add_object(self, title, node):\n         \"\"\"create a diagram object\"\"\"\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..f23dd2209 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -143,46 +143,85 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if self.tag:\n             node.uid = self.generate_id()\n \n-    def visit_classdef(self, node):\n-        \"\"\"visit an astroid.Class node\n \n-        * set the locals_type and instance_attrs_type mappings\n-        * set the implements list and build it\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n-        # resolve ancestors\n-        for baseobj in node.ancestors(recurs=False):\n-            specializations = getattr(baseobj, \"specializations\", [])\n-            specializations.append(node)\n-            baseobj.specializations = specializations\n-        # resolve instance attributes\n-        node.instance_attrs_type = collections.defaultdict(list)\n-        for assignattrs in node.instance_attrs.values():\n-            for assignattr in assignattrs:\n-                if not isinstance(assignattr, astroid.Unknown):\n-                    self.handle_assignattr_type(assignattr, node)\n-        # resolve implemented interface\n+def visit_classdef(self, node):\n+    \"\"\"visit an astroid.Class node\n+\n+    * set the locals_type and instance_attrs_type mappings\n+    * set the implements list and build it\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    if self.tag:\n+        node.uid = self.generate_id()\n+    \n+    # NEW: Extract class variable type annotations\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n         try:\n-            node.implements = list(interfaces(node, self.inherited_interfaces))\n-        except astroid.InferenceError:\n-            node.implements = ()\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        # Store in instance_attrs_type for consistency\n+                        if not hasattr(node, 'instance_attrs_type'):\n+                            node.instance_attrs_type = collections.defaultdict(list)\n+                        node.instance_attrs_type[attr_name] = [type_str]\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    # resolve ancestors\n+    for baseobj in node.ancestors(recurs=False):\n+        specializations = getattr(baseobj, \"specializations\", [])\n+        specializations.append(node)\n+        baseobj.specializations = specializations\n+    # resolve instance attributes\n+    node.instance_attrs_type = collections.defaultdict(list)\n+    for assignattrs in node.instance_attrs.values():\n+        for assignattr in assignattrs:\n+            if not isinstance(assignattr, astroid.Unknown):\n+                self.handle_assignattr_type(assignattr, node)\n+    # resolve implemented interface\n+    try:\n+        node.implements = list(interfaces(node, self.inherited_interfaces))\n+    except astroid.InferenceError:\n+        node.implements = ()\n \n-    def visit_functiondef(self, node):\n-        \"\"\"visit an astroid.Function node\n \n-        * set the locals_type mapping\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n+def visit_functiondef(self, node):\n+    \"\"\"visit an astroid.Function node\n+\n+    * set the locals_type mapping\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    \n+    # Extract parameter type annotations\n+    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n+        node.param_types = {}\n+        for i, arg in enumerate(node.args.args):\n+            if i < len(node.args.annotations) and node.args.annotations[i]:\n+                try:\n+                    # Convert annotation to string representation\n+                    annotation_str = node.args.annotations[i].as_string()\n+                    node.param_types[arg.name] = annotation_str\n+                except AttributeError:\n+                    pass\n+    \n+    # Extract return type annotation\n+    if hasattr(node, 'returns') and node.returns:\n+        try:\n+            node.return_type = node.returns.as_string()\n+        except AttributeError:\n+            pass\n+            \n+    if self.tag:\n+        node.uid = self.generate_id()\n \n     link_project = visit_project\n     link_module = visit_module\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..766ad49da 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -123,26 +123,39 @@ class DotWriter(DiagramWriter):\n         \"\"\"get project title\"\"\"\n         return obj.title\n \n-    def get_values(self, obj):\n-        \"\"\"get label and shape for classes.\n \n-        The label contains all attributes and methods\n-        \"\"\"\n-        label = obj.title\n-        if obj.shape == \"interface\":\n-            label = \"«interface»\\\\n%s\" % label\n-        if not self.config.only_classnames:\n-            label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n-            for func in obj.methods:\n-                if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n+def get_values(self, obj):\n+    \"\"\"get label and shape for classes.\n+\n+    The label contains all attributes and methods\n+    \"\"\"\n+    label = obj.title\n+    if obj.shape == \"interface\":\n+        label = \"«interface»\\\\n%s\" % label\n+    if not self.config.only_classnames:\n+        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n+        for func in obj.methods:\n+            # Build parameter list with type annotations\n+            args = []\n+            for arg in func.args.args:\n+                if arg.name == \"self\":\n+                    continue\n+                # Include type annotation if available\n+                if hasattr(func, 'param_types') and arg.name in func.param_types:\n+                    args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                 else:\n-                    args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n-            label = \"{%s}\" % label\n-        if is_exception(obj.node):\n-            return dict(fontcolor=\"red\", label=label, shape=\"record\")\n-        return dict(label=label, shape=\"record\")\n+                    args.append(arg.name)\n+            \n+            # Include return type if available\n+            method_sig = f\"{func.name}({', '.join(args)})\"\n+            if hasattr(func, 'return_type') and func.return_type:\n+                method_sig += f\" -> {func.return_type}\"\n+                \n+            label = r\"{}{}\\l\".format(label, method_sig)\n+        label = \"{%s}\" % label\n+    if is_exception(obj.node):\n+        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n+    return dict(label=label, shape=\"record\")\n \n     def close_graph(self):\n         \"\"\"print the dot graph into <file_name>\"\"\"\n",
    "variant_4": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..9dcae19eb 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -84,10 +84,43 @@ class ClassDiagram(Figure, FilterMixIn):\n             for n, m in node.items()\n             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n         ]\n-        for node_name, associated_nodes in (\n-            list(node.instance_attrs_type.items())\n-            + list(node.locals_type.items())\n-            + properties\n+\n+def get_attrs(self, node):\n+    \"\"\"return visible attributes, possibly with class name\"\"\"\n+    attrs = []\n+    properties = [\n+        (n, m)\n+        for n, m in node.items()\n+        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n+    ]\n+    \n+    # Include direct type annotations from __annotations__\n+    annotation_attrs = []\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+        try:\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        annotation_attrs.append((attr_name, [type_str]))\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for node_name, associated_nodes in (\n+        list(node.instance_attrs_type.items())\n+        + list(node.locals_type.items())\n+        + properties\n+        + annotation_attrs\n+    ):\n+        if not self.show_attr(node_name):\n+            continue\n+        names = self.class_names(associated_nodes)\n+        if names:\n+            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n+        attrs.append(node_name)\n+    return sorted(attrs)\n         ):\n             if not self.show_attr(node_name):\n                 continue\n@@ -97,16 +130,25 @@ class ClassDiagram(Figure, FilterMixIn):\n             attrs.append(node_name)\n         return sorted(attrs)\n \n-    def get_methods(self, node):\n-        \"\"\"return visible methods\"\"\"\n-        methods = [\n-            m\n-            for m in node.values()\n-            if isinstance(m, astroid.FunctionDef)\n-            and not decorated_with_property(m)\n-            and self.show_attr(m.name)\n-        ]\n-        return sorted(methods, key=lambda n: n.name)\n+\n+def get_methods(self, node):\n+    \"\"\"return visible methods\"\"\"\n+    methods = [\n+        m\n+        for m in node.values()\n+        if isinstance(m, astroid.FunctionDef)\n+        and not decorated_with_property(m)\n+        and self.show_attr(m.name)\n+    ]\n+    \n+    # Ensure type annotation data is preserved on method nodes\n+    for method in methods:\n+        if not hasattr(method, 'param_types'):\n+            method.param_types = {}\n+        if not hasattr(method, 'return_type'):\n+            method.return_type = None\n+            \n+    return sorted(methods, key=lambda n: n.name)\n \n     def add_object(self, title, node):\n         \"\"\"create a diagram object\"\"\"\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..189469d88 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -143,46 +143,82 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if self.tag:\n             node.uid = self.generate_id()\n \n-    def visit_classdef(self, node):\n-        \"\"\"visit an astroid.Class node\n \n-        * set the locals_type and instance_attrs_type mappings\n-        * set the implements list and build it\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n-        # resolve ancestors\n-        for baseobj in node.ancestors(recurs=False):\n-            specializations = getattr(baseobj, \"specializations\", [])\n-            specializations.append(node)\n-            baseobj.specializations = specializations\n-        # resolve instance attributes\n-        node.instance_attrs_type = collections.defaultdict(list)\n-        for assignattrs in node.instance_attrs.values():\n-            for assignattr in assignattrs:\n-                if not isinstance(assignattr, astroid.Unknown):\n-                    self.handle_assignattr_type(assignattr, node)\n-        # resolve implemented interface\n+def visit_classdef(self, node):\n+    \"\"\"visit an astroid.Class node\n+\n+    * set the locals_type and instance_attrs_type mappings\n+    * set the implements list and build it\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    if self.tag:\n+        node.uid = self.generate_id()\n+    # resolve ancestors\n+    for baseobj in node.ancestors(recurs=False):\n+        specializations = getattr(baseobj, \"specializations\", [])\n+        specializations.append(node)\n+        baseobj.specializations = specializations\n+    # resolve instance attributes\n+    node.instance_attrs_type = collections.defaultdict(list)\n+    for assignattrs in node.instance_attrs.values():\n+        for assignattr in assignattrs:\n+            if not isinstance(assignattr, astroid.Unknown):\n+                self.handle_assignattr_type(assignattr, node)\n+    \n+    # NEW: Extract class variable type annotations\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n         try:\n-            node.implements = list(interfaces(node, self.inherited_interfaces))\n-        except astroid.InferenceError:\n-            node.implements = ()\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        node.instance_attrs_type[attr_name].append(type_str)\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    # resolve implemented interface\n+    try:\n+        node.implements = list(interfaces(node, self.inherited_interfaces))\n+    except astroid.InferenceError:\n+        node.implements = ()\n \n-    def visit_functiondef(self, node):\n-        \"\"\"visit an astroid.Function node\n \n-        * set the locals_type mapping\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n+def visit_functiondef(self, node):\n+    \"\"\"visit an astroid.Function node\n+\n+    * set the locals_type mapping\n+    * extract parameter and return type annotations\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    \n+    # Extract parameter type annotations\n+    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n+        node.param_types = {}\n+        for i, arg in enumerate(node.args.args):\n+            if i < len(node.args.annotations) and node.args.annotations[i]:\n+                try:\n+                    annotation_str = node.args.annotations[i].as_string()\n+                    node.param_types[arg.name] = annotation_str\n+                except AttributeError:\n+                    pass\n+    \n+    # Extract return type annotation\n+    if hasattr(node, 'returns') and node.returns:\n+        try:\n+            node.return_type = node.returns.as_string()\n+        except AttributeError:\n+            pass\n+            \n+    if self.tag:\n+        node.uid = self.generate_id()\n \n     link_project = visit_project\n     link_module = visit_module\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..978a8d9c6 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -123,26 +123,40 @@ class DotWriter(DiagramWriter):\n         \"\"\"get project title\"\"\"\n         return obj.title\n \n-    def get_values(self, obj):\n-        \"\"\"get label and shape for classes.\n \n-        The label contains all attributes and methods\n-        \"\"\"\n-        label = obj.title\n-        if obj.shape == \"interface\":\n-            label = \"«interface»\\\\n%s\" % label\n-        if not self.config.only_classnames:\n-            label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n-            for func in obj.methods:\n-                if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n-                else:\n-                    args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n-            label = \"{%s}\" % label\n-        if is_exception(obj.node):\n-            return dict(fontcolor=\"red\", label=label, shape=\"record\")\n-        return dict(label=label, shape=\"record\")\n+def get_values(self, obj):\n+    \"\"\"get label and shape for classes.\n+\n+    The label contains all attributes and methods\n+    \"\"\"\n+    label = obj.title\n+    if obj.shape == \"interface\":\n+        label = \"«interface»\\\\n%s\" % label\n+    if not self.config.only_classnames:\n+        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n+        for func in obj.methods:\n+            # Build parameter list with type annotations\n+            args = []\n+            if func.args.args:\n+                for arg in func.args.args:\n+                    if arg.name == \"self\":\n+                        continue\n+                    # Include type annotation if available\n+                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n+                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n+                    else:\n+                        args.append(arg.name)\n+            \n+            # Build method signature with return type if available\n+            method_sig = f\"{func.name}({', '.join(args)})\"\n+            if hasattr(func, 'return_type') and func.return_type:\n+                method_sig += f\" -> {func.return_type}\"\n+                \n+            label = r\"{}{}\\l\".format(label, method_sig)\n+        label = \"{%s}\" % label\n+    if is_exception(obj.node):\n+        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n+    return dict(label=label, shape=\"record\")\n \n     def close_graph(self):\n         \"\"\"print the dot graph into <file_name>\"\"\"\n",
    "variant_5": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..9dcae19eb 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -84,10 +84,43 @@ class ClassDiagram(Figure, FilterMixIn):\n             for n, m in node.items()\n             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n         ]\n-        for node_name, associated_nodes in (\n-            list(node.instance_attrs_type.items())\n-            + list(node.locals_type.items())\n-            + properties\n+\n+def get_attrs(self, node):\n+    \"\"\"return visible attributes, possibly with class name\"\"\"\n+    attrs = []\n+    properties = [\n+        (n, m)\n+        for n, m in node.items()\n+        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n+    ]\n+    \n+    # Include direct type annotations from __annotations__\n+    annotation_attrs = []\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+        try:\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        annotation_attrs.append((attr_name, [type_str]))\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for node_name, associated_nodes in (\n+        list(node.instance_attrs_type.items())\n+        + list(node.locals_type.items())\n+        + properties\n+        + annotation_attrs\n+    ):\n+        if not self.show_attr(node_name):\n+            continue\n+        names = self.class_names(associated_nodes)\n+        if names:\n+            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n+        attrs.append(node_name)\n+    return sorted(attrs)\n         ):\n             if not self.show_attr(node_name):\n                 continue\n@@ -97,16 +130,25 @@ class ClassDiagram(Figure, FilterMixIn):\n             attrs.append(node_name)\n         return sorted(attrs)\n \n-    def get_methods(self, node):\n-        \"\"\"return visible methods\"\"\"\n-        methods = [\n-            m\n-            for m in node.values()\n-            if isinstance(m, astroid.FunctionDef)\n-            and not decorated_with_property(m)\n-            and self.show_attr(m.name)\n-        ]\n-        return sorted(methods, key=lambda n: n.name)\n+\n+def get_methods(self, node):\n+    \"\"\"return visible methods\"\"\"\n+    methods = [\n+        m\n+        for m in node.values()\n+        if isinstance(m, astroid.FunctionDef)\n+        and not decorated_with_property(m)\n+        and self.show_attr(m.name)\n+    ]\n+    \n+    # Ensure type annotation data is preserved on method nodes\n+    for method in methods:\n+        if not hasattr(method, 'param_types'):\n+            method.param_types = {}\n+        if not hasattr(method, 'return_type'):\n+            method.return_type = None\n+            \n+    return sorted(methods, key=lambda n: n.name)\n \n     def add_object(self, title, node):\n         \"\"\"create a diagram object\"\"\"\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..bc18281e9 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -143,46 +143,83 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if self.tag:\n             node.uid = self.generate_id()\n \n-    def visit_classdef(self, node):\n-        \"\"\"visit an astroid.Class node\n \n-        * set the locals_type and instance_attrs_type mappings\n-        * set the implements list and build it\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n-        # resolve ancestors\n-        for baseobj in node.ancestors(recurs=False):\n-            specializations = getattr(baseobj, \"specializations\", [])\n-            specializations.append(node)\n-            baseobj.specializations = specializations\n-        # resolve instance attributes\n-        node.instance_attrs_type = collections.defaultdict(list)\n-        for assignattrs in node.instance_attrs.values():\n-            for assignattr in assignattrs:\n-                if not isinstance(assignattr, astroid.Unknown):\n-                    self.handle_assignattr_type(assignattr, node)\n-        # resolve implemented interface\n+def visit_classdef(self, node):\n+    \"\"\"visit an astroid.Class node\n+\n+    * set the locals_type and instance_attrs_type mappings\n+    * set the implements list and build it\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    if self.tag:\n+        node.uid = self.generate_id()\n+    \n+    # NEW: Extract class variable type annotations\n+    node.class_annotations = {}\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n         try:\n-            node.implements = list(interfaces(node, self.inherited_interfaces))\n-        except astroid.InferenceError:\n-            node.implements = ()\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        node.class_annotations[attr_name] = type_str\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    # resolve ancestors\n+    for baseobj in node.ancestors(recurs=False):\n+        specializations = getattr(baseobj, \"specializations\", [])\n+        specializations.append(node)\n+        baseobj.specializations = specializations\n+    # resolve instance attributes\n+    node.instance_attrs_type = collections.defaultdict(list)\n+    for assignattrs in node.instance_attrs.values():\n+        for assignattr in assignattrs:\n+            if not isinstance(assignattr, astroid.Unknown):\n+                self.handle_assignattr_type(assignattr, node)\n+    # resolve implemented interface\n+    try:\n+        node.implements = list(interfaces(node, self.inherited_interfaces))\n+    except astroid.InferenceError:\n+        node.implements = ()\n \n-    def visit_functiondef(self, node):\n-        \"\"\"visit an astroid.Function node\n \n-        * set the locals_type mapping\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n+def visit_functiondef(self, node):\n+    \"\"\"visit an astroid.Function node\n+\n+    * set the locals_type mapping\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    \n+    # Extract parameter type annotations\n+    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n+        node.param_types = {}\n+        for i, arg in enumerate(node.args.args):\n+            if i < len(node.args.annotations) and node.args.annotations[i]:\n+                try:\n+                    # Convert annotation to string representation\n+                    annotation_str = node.args.annotations[i].as_string()\n+                    node.param_types[arg.name] = annotation_str\n+                except AttributeError:\n+                    pass\n+    \n+    # Extract return type annotation\n+    if hasattr(node, 'returns') and node.returns:\n+        try:\n+            node.return_type = node.returns.as_string()\n+        except AttributeError:\n+            pass\n+            \n+    if self.tag:\n+        node.uid = self.generate_id()\n \n     link_project = visit_project\n     link_module = visit_module\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..6e1037f5e 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -123,6 +123,7 @@ class DotWriter(DiagramWriter):\n         \"\"\"get project title\"\"\"\n         return obj.title\n \n+\n     def get_values(self, obj):\n         \"\"\"get label and shape for classes.\n \n@@ -134,11 +135,24 @@ class DotWriter(DiagramWriter):\n         if not self.config.only_classnames:\n             label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n             for func in obj.methods:\n+                # Build parameter list with type annotations\n+                args = []\n                 if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n-                else:\n-                    args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n+                    for arg in func.args.args:\n+                        if arg.name == \"self\":\n+                            continue\n+                        # Include type annotation if available\n+                        if hasattr(func, 'param_types') and arg.name in func.param_types:\n+                            args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n+                        else:\n+                            args.append(arg.name)\n+                \n+                # Build method signature with return type\n+                method_sig = f\"{func.name}({', '.join(args)})\"\n+                if hasattr(func, 'return_type') and func.return_type:\n+                    method_sig += f\" -> {func.return_type}\"\n+                    \n+                label = r\"{}{}\\l\".format(label, method_sig)\n             label = \"{%s}\" % label\n         if is_exception(obj.node):\n             return dict(fontcolor=\"red\", label=label, shape=\"record\")\n",
    "variant_6": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..9dcae19eb 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -84,10 +84,43 @@ class ClassDiagram(Figure, FilterMixIn):\n             for n, m in node.items()\n             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n         ]\n-        for node_name, associated_nodes in (\n-            list(node.instance_attrs_type.items())\n-            + list(node.locals_type.items())\n-            + properties\n+\n+def get_attrs(self, node):\n+    \"\"\"return visible attributes, possibly with class name\"\"\"\n+    attrs = []\n+    properties = [\n+        (n, m)\n+        for n, m in node.items()\n+        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n+    ]\n+    \n+    # Include direct type annotations from __annotations__\n+    annotation_attrs = []\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+        try:\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        annotation_attrs.append((attr_name, [type_str]))\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for node_name, associated_nodes in (\n+        list(node.instance_attrs_type.items())\n+        + list(node.locals_type.items())\n+        + properties\n+        + annotation_attrs\n+    ):\n+        if not self.show_attr(node_name):\n+            continue\n+        names = self.class_names(associated_nodes)\n+        if names:\n+            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n+        attrs.append(node_name)\n+    return sorted(attrs)\n         ):\n             if not self.show_attr(node_name):\n                 continue\n@@ -97,16 +130,25 @@ class ClassDiagram(Figure, FilterMixIn):\n             attrs.append(node_name)\n         return sorted(attrs)\n \n-    def get_methods(self, node):\n-        \"\"\"return visible methods\"\"\"\n-        methods = [\n-            m\n-            for m in node.values()\n-            if isinstance(m, astroid.FunctionDef)\n-            and not decorated_with_property(m)\n-            and self.show_attr(m.name)\n-        ]\n-        return sorted(methods, key=lambda n: n.name)\n+\n+def get_methods(self, node):\n+    \"\"\"return visible methods\"\"\"\n+    methods = [\n+        m\n+        for m in node.values()\n+        if isinstance(m, astroid.FunctionDef)\n+        and not decorated_with_property(m)\n+        and self.show_attr(m.name)\n+    ]\n+    \n+    # Ensure type annotation data is preserved on method nodes\n+    for method in methods:\n+        if not hasattr(method, 'param_types'):\n+            method.param_types = {}\n+        if not hasattr(method, 'return_type'):\n+            method.return_type = None\n+            \n+    return sorted(methods, key=lambda n: n.name)\n \n     def add_object(self, title, node):\n         \"\"\"create a diagram object\"\"\"\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..7819ea516 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -143,46 +143,82 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if self.tag:\n             node.uid = self.generate_id()\n \n-    def visit_classdef(self, node):\n-        \"\"\"visit an astroid.Class node\n \n-        * set the locals_type and instance_attrs_type mappings\n-        * set the implements list and build it\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n-        # resolve ancestors\n-        for baseobj in node.ancestors(recurs=False):\n-            specializations = getattr(baseobj, \"specializations\", [])\n-            specializations.append(node)\n-            baseobj.specializations = specializations\n-        # resolve instance attributes\n-        node.instance_attrs_type = collections.defaultdict(list)\n-        for assignattrs in node.instance_attrs.values():\n-            for assignattr in assignattrs:\n-                if not isinstance(assignattr, astroid.Unknown):\n-                    self.handle_assignattr_type(assignattr, node)\n-        # resolve implemented interface\n+def visit_classdef(self, node):\n+    \"\"\"visit an astroid.Class node\n+\n+    * set the locals_type and instance_attrs_type mappings\n+    * set the implements list and build it\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    if self.tag:\n+        node.uid = self.generate_id()\n+    # resolve ancestors\n+    for baseobj in node.ancestors(recurs=False):\n+        specializations = getattr(baseobj, \"specializations\", [])\n+        specializations.append(node)\n+        baseobj.specializations = specializations\n+    # resolve instance attributes\n+    node.instance_attrs_type = collections.defaultdict(list)\n+    \n+    # NEW: Extract class variable type annotations\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n         try:\n-            node.implements = list(interfaces(node, self.inherited_interfaces))\n-        except astroid.InferenceError:\n-            node.implements = ()\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        node.instance_attrs_type[attr_name].append(type_str)\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for assignattrs in node.instance_attrs.values():\n+        for assignattr in assignattrs:\n+            if not isinstance(assignattr, astroid.Unknown):\n+                self.handle_assignattr_type(assignattr, node)\n+    # resolve implemented interface\n+    try:\n+        node.implements = list(utils.interfaces(node, self.inherited_interfaces))\n+    except astroid.InferenceError:\n+        node.implements = ()\n \n-    def visit_functiondef(self, node):\n-        \"\"\"visit an astroid.Function node\n \n-        * set the locals_type mapping\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n+def visit_functiondef(self, node):\n+    \"\"\"visit an astroid.Function node\n+\n+    * set the locals_type mapping\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    \n+    # Extract parameter type annotations\n+    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n+        node.param_types = {}\n+        for i, arg in enumerate(node.args.args):\n+            if i < len(node.args.annotations) and node.args.annotations[i]:\n+                try:\n+                    # Convert annotation to string representation\n+                    annotation_str = node.args.annotations[i].as_string()\n+                    node.param_types[arg.name] = annotation_str\n+                except AttributeError:\n+                    pass\n+    \n+    # Extract return type annotation\n+    if hasattr(node, 'returns') and node.returns:\n+        try:\n+            node.return_type = node.returns.as_string()\n+        except AttributeError:\n+            pass\n+            \n+    if self.tag:\n+        node.uid = self.generate_id()\n \n     link_project = visit_project\n     link_module = visit_module\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..978a8d9c6 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -123,26 +123,40 @@ class DotWriter(DiagramWriter):\n         \"\"\"get project title\"\"\"\n         return obj.title\n \n-    def get_values(self, obj):\n-        \"\"\"get label and shape for classes.\n \n-        The label contains all attributes and methods\n-        \"\"\"\n-        label = obj.title\n-        if obj.shape == \"interface\":\n-            label = \"«interface»\\\\n%s\" % label\n-        if not self.config.only_classnames:\n-            label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n-            for func in obj.methods:\n-                if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n-                else:\n-                    args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n-            label = \"{%s}\" % label\n-        if is_exception(obj.node):\n-            return dict(fontcolor=\"red\", label=label, shape=\"record\")\n-        return dict(label=label, shape=\"record\")\n+def get_values(self, obj):\n+    \"\"\"get label and shape for classes.\n+\n+    The label contains all attributes and methods\n+    \"\"\"\n+    label = obj.title\n+    if obj.shape == \"interface\":\n+        label = \"«interface»\\\\n%s\" % label\n+    if not self.config.only_classnames:\n+        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n+        for func in obj.methods:\n+            # Build parameter list with type annotations\n+            args = []\n+            if func.args.args:\n+                for arg in func.args.args:\n+                    if arg.name == \"self\":\n+                        continue\n+                    # Include type annotation if available\n+                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n+                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n+                    else:\n+                        args.append(arg.name)\n+            \n+            # Build method signature with return type if available\n+            method_sig = f\"{func.name}({', '.join(args)})\"\n+            if hasattr(func, 'return_type') and func.return_type:\n+                method_sig += f\" -> {func.return_type}\"\n+                \n+            label = r\"{}{}\\l\".format(label, method_sig)\n+        label = \"{%s}\" % label\n+    if is_exception(obj.node):\n+        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n+    return dict(label=label, shape=\"record\")\n \n     def close_graph(self):\n         \"\"\"print the dot graph into <file_name>\"\"\"\n",
    "variant_7": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..9dcae19eb 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -84,10 +84,43 @@ class ClassDiagram(Figure, FilterMixIn):\n             for n, m in node.items()\n             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n         ]\n-        for node_name, associated_nodes in (\n-            list(node.instance_attrs_type.items())\n-            + list(node.locals_type.items())\n-            + properties\n+\n+def get_attrs(self, node):\n+    \"\"\"return visible attributes, possibly with class name\"\"\"\n+    attrs = []\n+    properties = [\n+        (n, m)\n+        for n, m in node.items()\n+        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n+    ]\n+    \n+    # Include direct type annotations from __annotations__\n+    annotation_attrs = []\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+        try:\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        annotation_attrs.append((attr_name, [type_str]))\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for node_name, associated_nodes in (\n+        list(node.instance_attrs_type.items())\n+        + list(node.locals_type.items())\n+        + properties\n+        + annotation_attrs\n+    ):\n+        if not self.show_attr(node_name):\n+            continue\n+        names = self.class_names(associated_nodes)\n+        if names:\n+            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n+        attrs.append(node_name)\n+    return sorted(attrs)\n         ):\n             if not self.show_attr(node_name):\n                 continue\n@@ -97,16 +130,25 @@ class ClassDiagram(Figure, FilterMixIn):\n             attrs.append(node_name)\n         return sorted(attrs)\n \n-    def get_methods(self, node):\n-        \"\"\"return visible methods\"\"\"\n-        methods = [\n-            m\n-            for m in node.values()\n-            if isinstance(m, astroid.FunctionDef)\n-            and not decorated_with_property(m)\n-            and self.show_attr(m.name)\n-        ]\n-        return sorted(methods, key=lambda n: n.name)\n+\n+def get_methods(self, node):\n+    \"\"\"return visible methods\"\"\"\n+    methods = [\n+        m\n+        for m in node.values()\n+        if isinstance(m, astroid.FunctionDef)\n+        and not decorated_with_property(m)\n+        and self.show_attr(m.name)\n+    ]\n+    \n+    # Ensure type annotation data is preserved on method nodes\n+    for method in methods:\n+        if not hasattr(method, 'param_types'):\n+            method.param_types = {}\n+        if not hasattr(method, 'return_type'):\n+            method.return_type = None\n+            \n+    return sorted(methods, key=lambda n: n.name)\n \n     def add_object(self, title, node):\n         \"\"\"create a diagram object\"\"\"\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..f23dd2209 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -143,46 +143,85 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if self.tag:\n             node.uid = self.generate_id()\n \n-    def visit_classdef(self, node):\n-        \"\"\"visit an astroid.Class node\n \n-        * set the locals_type and instance_attrs_type mappings\n-        * set the implements list and build it\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n-        # resolve ancestors\n-        for baseobj in node.ancestors(recurs=False):\n-            specializations = getattr(baseobj, \"specializations\", [])\n-            specializations.append(node)\n-            baseobj.specializations = specializations\n-        # resolve instance attributes\n-        node.instance_attrs_type = collections.defaultdict(list)\n-        for assignattrs in node.instance_attrs.values():\n-            for assignattr in assignattrs:\n-                if not isinstance(assignattr, astroid.Unknown):\n-                    self.handle_assignattr_type(assignattr, node)\n-        # resolve implemented interface\n+def visit_classdef(self, node):\n+    \"\"\"visit an astroid.Class node\n+\n+    * set the locals_type and instance_attrs_type mappings\n+    * set the implements list and build it\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    if self.tag:\n+        node.uid = self.generate_id()\n+    \n+    # NEW: Extract class variable type annotations\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n         try:\n-            node.implements = list(interfaces(node, self.inherited_interfaces))\n-        except astroid.InferenceError:\n-            node.implements = ()\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        # Store in instance_attrs_type for consistency\n+                        if not hasattr(node, 'instance_attrs_type'):\n+                            node.instance_attrs_type = collections.defaultdict(list)\n+                        node.instance_attrs_type[attr_name] = [type_str]\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    # resolve ancestors\n+    for baseobj in node.ancestors(recurs=False):\n+        specializations = getattr(baseobj, \"specializations\", [])\n+        specializations.append(node)\n+        baseobj.specializations = specializations\n+    # resolve instance attributes\n+    node.instance_attrs_type = collections.defaultdict(list)\n+    for assignattrs in node.instance_attrs.values():\n+        for assignattr in assignattrs:\n+            if not isinstance(assignattr, astroid.Unknown):\n+                self.handle_assignattr_type(assignattr, node)\n+    # resolve implemented interface\n+    try:\n+        node.implements = list(interfaces(node, self.inherited_interfaces))\n+    except astroid.InferenceError:\n+        node.implements = ()\n \n-    def visit_functiondef(self, node):\n-        \"\"\"visit an astroid.Function node\n \n-        * set the locals_type mapping\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n+def visit_functiondef(self, node):\n+    \"\"\"visit an astroid.Function node\n+\n+    * set the locals_type mapping\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    \n+    # Extract parameter type annotations\n+    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n+        node.param_types = {}\n+        for i, arg in enumerate(node.args.args):\n+            if i < len(node.args.annotations) and node.args.annotations[i]:\n+                try:\n+                    # Convert annotation to string representation\n+                    annotation_str = node.args.annotations[i].as_string()\n+                    node.param_types[arg.name] = annotation_str\n+                except AttributeError:\n+                    pass\n+    \n+    # Extract return type annotation\n+    if hasattr(node, 'returns') and node.returns:\n+        try:\n+            node.return_type = node.returns.as_string()\n+        except AttributeError:\n+            pass\n+            \n+    if self.tag:\n+        node.uid = self.generate_id()\n \n     link_project = visit_project\n     link_module = visit_module\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..4800ad388 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -123,26 +123,41 @@ class DotWriter(DiagramWriter):\n         \"\"\"get project title\"\"\"\n         return obj.title\n \n-    def get_values(self, obj):\n-        \"\"\"get label and shape for classes.\n \n-        The label contains all attributes and methods\n-        \"\"\"\n-        label = obj.title\n-        if obj.shape == \"interface\":\n-            label = \"«interface»\\\\n%s\" % label\n-        if not self.config.only_classnames:\n-            label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n-            for func in obj.methods:\n-                if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n-                else:\n-                    args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n-            label = \"{%s}\" % label\n-        if is_exception(obj.node):\n-            return dict(fontcolor=\"red\", label=label, shape=\"record\")\n-        return dict(label=label, shape=\"record\")\n+def get_values(self, obj):\n+    \"\"\"get label and shape for classes.\n+\n+    The label contains all attributes and methods\n+    \"\"\"\n+    label = obj.title\n+    if obj.shape == \"interface\":\n+        label = \"«interface»\\\\n%s\" % label\n+    if not self.config.only_classnames:\n+        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n+        for func in obj.methods:\n+            if func.args.args:\n+                args = []\n+                for arg in func.args.args:\n+                    if arg.name == \"self\":\n+                        continue\n+                    # Include type annotation if available\n+                    if hasattr(func, 'param_types') and arg.name in func.param_types:\n+                        args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n+                    else:\n+                        args.append(arg.name)\n+            else:\n+                args = []\n+            \n+            # Build method signature with return type if available\n+            method_sig = f\"{func.name}({', '.join(args)})\"\n+            if hasattr(func, 'return_type') and func.return_type:\n+                method_sig += f\" -> {func.return_type}\"\n+                \n+            label = r\"{}{}\\l\".format(label, method_sig)\n+        label = \"{%s}\" % label\n+    if is_exception(obj.node):\n+        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n+    return dict(label=label, shape=\"record\")\n \n     def close_graph(self):\n         \"\"\"print the dot graph into <file_name>\"\"\"\n",
    "variant_8": "diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..9dcae19eb 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -84,10 +84,43 @@ class ClassDiagram(Figure, FilterMixIn):\n             for n, m in node.items()\n             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n         ]\n-        for node_name, associated_nodes in (\n-            list(node.instance_attrs_type.items())\n-            + list(node.locals_type.items())\n-            + properties\n+\n+def get_attrs(self, node):\n+    \"\"\"return visible attributes, possibly with class name\"\"\"\n+    attrs = []\n+    properties = [\n+        (n, m)\n+        for n, m in node.items()\n+        if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n+    ]\n+    \n+    # Include direct type annotations from __annotations__\n+    annotation_attrs = []\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n+        try:\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        annotation_attrs.append((attr_name, [type_str]))\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    for node_name, associated_nodes in (\n+        list(node.instance_attrs_type.items())\n+        + list(node.locals_type.items())\n+        + properties\n+        + annotation_attrs\n+    ):\n+        if not self.show_attr(node_name):\n+            continue\n+        names = self.class_names(associated_nodes)\n+        if names:\n+            node_name = \"{} : {}\".format(node_name, \", \".join(names))\n+        attrs.append(node_name)\n+    return sorted(attrs)\n         ):\n             if not self.show_attr(node_name):\n                 continue\n@@ -97,16 +130,25 @@ class ClassDiagram(Figure, FilterMixIn):\n             attrs.append(node_name)\n         return sorted(attrs)\n \n-    def get_methods(self, node):\n-        \"\"\"return visible methods\"\"\"\n-        methods = [\n-            m\n-            for m in node.values()\n-            if isinstance(m, astroid.FunctionDef)\n-            and not decorated_with_property(m)\n-            and self.show_attr(m.name)\n-        ]\n-        return sorted(methods, key=lambda n: n.name)\n+\n+def get_methods(self, node):\n+    \"\"\"return visible methods\"\"\"\n+    methods = [\n+        m\n+        for m in node.values()\n+        if isinstance(m, astroid.FunctionDef)\n+        and not decorated_with_property(m)\n+        and self.show_attr(m.name)\n+    ]\n+    \n+    # Ensure type annotation data is preserved on method nodes\n+    for method in methods:\n+        if not hasattr(method, 'param_types'):\n+            method.param_types = {}\n+        if not hasattr(method, 'return_type'):\n+            method.return_type = None\n+            \n+    return sorted(methods, key=lambda n: n.name)\n \n     def add_object(self, title, node):\n         \"\"\"create a diagram object\"\"\"\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa122022..d43362876 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -143,46 +143,84 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n         if self.tag:\n             node.uid = self.generate_id()\n \n-    def visit_classdef(self, node):\n-        \"\"\"visit an astroid.Class node\n \n-        * set the locals_type and instance_attrs_type mappings\n-        * set the implements list and build it\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n-        # resolve ancestors\n-        for baseobj in node.ancestors(recurs=False):\n-            specializations = getattr(baseobj, \"specializations\", [])\n-            specializations.append(node)\n-            baseobj.specializations = specializations\n-        # resolve instance attributes\n-        node.instance_attrs_type = collections.defaultdict(list)\n-        for assignattrs in node.instance_attrs.values():\n-            for assignattr in assignattrs:\n-                if not isinstance(assignattr, astroid.Unknown):\n-                    self.handle_assignattr_type(assignattr, node)\n-        # resolve implemented interface\n+def visit_classdef(self, node):\n+    \"\"\"visit an astroid.Class node\n+\n+    * set the locals_type and instance_attrs_type mappings\n+    * set the implements list and build it\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    if self.tag:\n+        node.uid = self.generate_id()\n+    \n+    # NEW: Extract class variable type annotations\n+    if hasattr(node, 'locals') and '__annotations__' in node.locals:\n         try:\n-            node.implements = list(interfaces(node, self.inherited_interfaces))\n-        except astroid.InferenceError:\n-            node.implements = ()\n+            annotations_node = node.locals['__annotations__'][0]\n+            if hasattr(annotations_node, 'items'):\n+                for key, value in annotations_node.items:\n+                    if hasattr(key, 'value') and hasattr(value, 'as_string'):\n+                        attr_name = key.value\n+                        type_str = value.as_string()\n+                        # Store in instance_attrs_type for consistency\n+                        if not hasattr(node, 'instance_attrs_type'):\n+                            node.instance_attrs_type = collections.defaultdict(list)\n+                        node.instance_attrs_type[attr_name] = [type_str]\n+        except (AttributeError, IndexError, KeyError):\n+            pass\n+    \n+    # resolve ancestors\n+    for baseobj in node.ancestors(recurs=False):\n+        specializations = getattr(baseobj, \"specializations\", [])\n+        specializations.append(node)\n+        baseobj.specializations = specializations\n+    # resolve instance attributes\n+    node.instance_attrs_type = collections.defaultdict(list)\n+    for assignattrs in node.instance_attrs.values():\n+        for assignattr in assignattrs:\n+            if not isinstance(assignattr, astroid.Unknown):\n+                self.handle_assignattr_type(assignattr, node)\n+    # resolve implemented interface\n+    try:\n+        node.implements = list(interfaces(node, self.inherited_interfaces))\n+    except astroid.InferenceError:\n+        node.implements = ()\n \n-    def visit_functiondef(self, node):\n-        \"\"\"visit an astroid.Function node\n \n-        * set the locals_type mapping\n-        * optionally tag the node with a unique id\n-        \"\"\"\n-        if hasattr(node, \"locals_type\"):\n-            return\n-        node.locals_type = collections.defaultdict(list)\n-        if self.tag:\n-            node.uid = self.generate_id()\n+def visit_functiondef(self, node):\n+    \"\"\"visit an astroid.Function node\n+\n+    * set the locals_type mapping\n+    * optionally tag the node with a unique id\n+    \"\"\"\n+    if hasattr(node, \"locals_type\"):\n+        return\n+    node.locals_type = collections.defaultdict(list)\n+    \n+    # Extract parameter type annotations\n+    if hasattr(node, 'args') and hasattr(node.args, 'annotations'):\n+        node.param_types = {}\n+        for i, arg in enumerate(node.args.args):\n+            if i < len(node.args.annotations) and node.args.annotations[i]:\n+                try:\n+                    annotation_str = node.args.annotations[i].as_string()\n+                    node.param_types[arg.name] = annotation_str\n+                except AttributeError:\n+                    pass\n+    \n+    # Extract return type annotation\n+    if hasattr(node, 'returns') and node.returns:\n+        try:\n+            node.return_type = node.returns.as_string()\n+        except AttributeError:\n+            pass\n+            \n+    if self.tag:\n+        node.uid = self.generate_id()\n \n     link_project = visit_project\n     link_module = visit_module\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..766ad49da 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -123,26 +123,39 @@ class DotWriter(DiagramWriter):\n         \"\"\"get project title\"\"\"\n         return obj.title\n \n-    def get_values(self, obj):\n-        \"\"\"get label and shape for classes.\n \n-        The label contains all attributes and methods\n-        \"\"\"\n-        label = obj.title\n-        if obj.shape == \"interface\":\n-            label = \"«interface»\\\\n%s\" % label\n-        if not self.config.only_classnames:\n-            label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n-            for func in obj.methods:\n-                if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n+def get_values(self, obj):\n+    \"\"\"get label and shape for classes.\n+\n+    The label contains all attributes and methods\n+    \"\"\"\n+    label = obj.title\n+    if obj.shape == \"interface\":\n+        label = \"«interface»\\\\n%s\" % label\n+    if not self.config.only_classnames:\n+        label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n+        for func in obj.methods:\n+            # Build parameter list with type annotations\n+            args = []\n+            for arg in func.args.args:\n+                if arg.name == \"self\":\n+                    continue\n+                # Include type annotation if available\n+                if hasattr(func, 'param_types') and arg.name in func.param_types:\n+                    args.append(f\"{arg.name}: {func.param_types[arg.name]}\")\n                 else:\n-                    args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n-            label = \"{%s}\" % label\n-        if is_exception(obj.node):\n-            return dict(fontcolor=\"red\", label=label, shape=\"record\")\n-        return dict(label=label, shape=\"record\")\n+                    args.append(arg.name)\n+            \n+            # Include return type if available\n+            method_sig = f\"{func.name}({', '.join(args)})\"\n+            if hasattr(func, 'return_type') and func.return_type:\n+                method_sig += f\" -> {func.return_type}\"\n+                \n+            label = r\"{}{}\\l\".format(label, method_sig)\n+        label = \"{%s}\" % label\n+    if is_exception(obj.node):\n+        return dict(fontcolor=\"red\", label=label, shape=\"record\")\n+    return dict(label=label, shape=\"record\")\n \n     def close_graph(self):\n         \"\"\"print the dot graph into <file_name>\"\"\"\n"
  }
}