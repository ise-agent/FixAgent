{
  "zero_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_axes.py lines 6886-6891)": "\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n\n            # Remove sticky edges from all but the bottom-most patches to allow\n            # margin expansion for autoscaling (similar to bar histograms)\n            if len(patches) > 1:\n                for patch_list in patches[:-1]:  # All but the last (bottom-most)\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_axes.py lines 6816-6821)": "\n            # Remove stickies from all bars but the lowest ones, as otherwise\n            # margin expansion would be unable to cross the stickies in the\n            # middle of the bars.\n            for bars in patches[1:]:\n                for patch in bars:\n                    patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n",
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_axes.py lines 6893-6894)": "\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n            \n            # For step histograms with multiple datasets, remove sticky edges from\n            # all but the baseline patches to allow proper autoscaling margins\n            if len(patches) > 1:\n                for patch_list in patches[1:]:  # Skip the first (baseline) patches\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_axes.py lines 6823-6825)": "\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n            y = np.zeros(4 * len(bins) - 3)\n\n            x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n            x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n\n            if bottom is None:\n                bottom = 0\n\n            y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom\n            y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n",
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_axes.py lines 6878-6885)": "\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None,\n                    zorder=None if fill else mlines.Line2D.zorder))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_axes.py lines 6886-6891)": [
      "\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n\n            # Remove sticky edges from non-baseline patches to allow proper autoscaling\n            # This matches the behavior of bar histograms\n            if len(patches) > 1:\n                for patch_list in patches[1:]:  # Skip the first (baseline) patch\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n\n            # Remove sticky edges from all but the bottom-most patches to allow\n            # margin expansion for autoscaling (similar to bar histograms)\n            if len(patches) > 1:\n                for patch_list in patches[:-1]:  # All but the last (bottom-most)\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n\n            # For step histograms, remove sticky edges from all but the baseline patches\n            # to allow proper autoscaling margins (similar to bar histograms)\n            if histtype == 'step':\n                # After patches.reverse() below, first patches are topmost in stack\n                # Remove sticky edges from all but baseline (last in visual stack)\n                for patch_list in patches[:-1]:  # All except the last (baseline)\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n\n            # Remove sticky edges from all but the bottommost patches to allow\n            # proper autoscaling margins, similar to bar histograms\n            if len(patches) > 1:\n                for patch_list in patches[1:]:  # Skip the bottommost patches\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n\n            # Remove sticky edges from all but the baseline patches to allow\n            # proper margin expansion for autoscaling (similar to bar histograms)\n            if len(patches) > 1:\n                for patch_list in patches[:-1]:  # All except the last (baseline) patch\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n\n            # Remove sticky edges from all but the bottom patches to allow\n            # autoscaling margins, similar to bar histograms\n            for patch_list in patches[1:]:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.clear()\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.clear()\n",
      "\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n            \n            # Remove sticky edges from non-baseline patches to allow margin expansion\n            # Keep sticky edges only on the baseline (first after reversal)\n            if len(patches) > 1:\n                for patch_list in patches[1:]:  # Skip baseline patches\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n            \n            # Remove sticky edges from all but the bottom-most patches to allow\n            # autoscaling margins for step histograms (similar to bar histograms)\n            if len(patches) > 1:\n                for patch_list in patches[:-1]:  # All but the last (bottom-most) patch\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n"
    ],
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_axes.py lines 6816-6821)": [
      "\n            # Remove stickies from all bars but the lowest ones, as otherwise\n            # margin expansion would be unable to cross the stickies in the\n            # middle of the bars.\n            for bars in patches[1:]:\n                for patch in bars:\n                    patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n",
      "\n            # Remove stickies from all bars but the lowest ones, as otherwise\n            # margin expansion would be unable to cross the stickies in the\n            # middle of the bars.\n            for bars in patches[1:]:\n                for patch in bars:\n                    patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n",
      "\n            # Remove stickies from all bars but the lowest ones, as otherwise\n            # margin expansion would be unable to cross the stickies in the\n            # middle of the bars.\n            for bars in patches[1:]:\n                for patch in bars:\n                    patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n",
      "\n            # Remove stickies from all bars but the lowest ones, as otherwise\n            # margin expansion would be unable to cross the stickies in the\n            # middle of the bars.\n            for bars in patches[1:]:\n                for patch in bars:\n                    patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n",
      "\n            # Remove stickies from all bars but the lowest ones, as otherwise\n            # margin expansion would be unable to cross the stickies in the\n            # middle of the bars.\n            for bars in patches[1:]:\n                for patch in bars:\n                    patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n",
      "\n            # Remove stickies from all bars but the lowest ones, as otherwise\n            # margin expansion would be unable to cross the stickies in the\n            # middle of the bars.\n            for bars in patches[1:]:\n                for patch in bars:\n                    patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n",
      "\n            # Remove stickies from all bars but the lowest ones, as otherwise\n            # margin expansion would be unable to cross the stickies in the\n            # middle of the bars.\n            for bars in patches[1:]:\n                for patch in bars:\n                    patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n",
      "\n            # Remove stickies from all bars but the lowest ones, as otherwise\n            # margin expansion would be unable to cross the stickies in the\n            # middle of the bars.\n            for bars in patches[1:]:\n                for patch in bars:\n                    patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n"
    ],
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_axes.py lines 6893-6894)": [
      "\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n            \n            # For step histograms, manage sticky edges like bar histograms\n            # Remove sticky edges from all but the bottom patches to allow autoscaling\n            if len(patches) > 1:\n                for patch_list in patches[1:]:  # Skip the bottom patches\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n            \n            # For step histograms, remove sticky edges from all but the baseline patches\n            # to allow proper margin expansion during autoscaling (similar to bar histograms)\n            if histtype == 'step' or histtype == 'stepfilled':\n                # After reverse(), patches[0] contains the baseline/bottom patches\n                # Remove sticky edges from stacked patches (patches[1:]) to enable margins\n                for patch_list in patches[1:]:\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n            \n            # For step histograms, remove sticky edges from all but the baseline patches\n            # to allow proper autoscaling margins, similar to bar histograms\n            if histtype == 'step' or histtype == 'stepfilled':\n                for patch_list in patches[1:]:  # Skip the first (baseline) patch list\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n            \n            # For step histograms, manage sticky edges like bar histograms\n            # Remove sticky edges from all but the bottom patches to allow autoscaling\n            if len(patches) > 1:\n                for patch_list in patches[1:]:  # Skip the bottom patches\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n            \n            # For step histograms, manage sticky edges similar to bar histograms\n            # Remove sticky edges from all but the bottom patches to allow proper autoscaling\n            if histtype == 'step' and len(patches) > 1:\n                for patch_list in patches[1:]:  # Skip the first (bottom) patch\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            if 0 in patch.sticky_edges.y:\n                                patch.sticky_edges.y.remove(0)\n                        elif orientation == 'horizontal':\n                            if 0 in patch.sticky_edges.x:\n                                patch.sticky_edges.x.remove(0)\n",
      "\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n            \n            # For step histograms, manage sticky edges like bar histograms\n            # Remove sticky edges from all but the bottom patches to allow autoscaling\n            if len(patches) > 1:\n                for patch_list in patches[1:]:  # Skip the bottom patches\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n",
      "\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n            \n            # For step histograms, manage sticky edges like bar histograms\n            # Remove sticky edges from all but the bottom-most patches to allow proper autoscaling\n            if len(patches) > 1:\n                for patch_list in patches[1:]:  # Skip the bottom-most patches\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            if 0 in patch.sticky_edges.y:\n                                patch.sticky_edges.y.remove(0)\n                        elif orientation == 'horizontal':\n                            if 0 in patch.sticky_edges.x:\n                                patch.sticky_edges.x.remove(0)\n",
      "\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n            \n            # For step histograms, remove sticky edges from all but the bottom patches\n            # to allow proper autoscaling margins, similar to bar histograms\n            if histtype == 'step' and len(patches) > 1:\n                for patch_list in patches[1:]:  # Skip the bottom/baseline patches\n                    for patch in patch_list:\n                        if orientation == 'vertical':\n                            patch.sticky_edges.y.clear()\n                        elif orientation == 'horizontal':\n                            patch.sticky_edges.x.clear()\n"
    ],
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_axes.py lines 6823-6825)": [
      "\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n            y = np.zeros(4 * len(bins) - 3)\n\n            x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n            x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n\n            if bottom is None:\n                bottom = 0\n\n            y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom\n            y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n",
      "\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n",
      "\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n",
      "\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n            y = np.zeros(4 * len(bins) - 3)\n\n            x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n            x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n\n            if bottom is None:\n                bottom = 0\n\n            y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom\n            y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n",
      "\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n            y = np.zeros(4 * len(bins) - 3)\n\n            x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n            x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n\n            if bottom is None:\n                bottom = 0\n\n            y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom\n            y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n",
      "\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n",
      "\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n",
      "\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n"
    ],
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/axes/_axes.py lines 6878-6885)": [
      "\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None,\n                    zorder=None if fill else mlines.Line2D.zorder))\n",
      "\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None,\n                    zorder=None if fill else mlines.Line2D.zorder))\n",
      "\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None,\n                    zorder=None if fill else mlines.Line2D.zorder))\n",
      "\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None,\n                    zorder=None if fill else mlines.Line2D.zorder))\n",
      "\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None,\n                    zorder=None if fill else mlines.Line2D.zorder))\n",
      "\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None,\n                    zorder=None if fill else mlines.Line2D.zorder))\n",
      "\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None,\n                    zorder=None if fill else mlines.Line2D.zorder))\n",
      "\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None,\n                    zorder=None if fill else mlines.Line2D.zorder))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 2412f815cd..cdf8cfed51 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6813,6 +6813,7 @@ such objects\n                 if stacked:\n                     bottom = m\n                 boffset += dw\n+\n             # Remove stickies from all bars but the lowest ones, as otherwise\n             # margin expansion would be unable to cross the stickies in the\n             # middle of the bars.\n@@ -6820,6 +6821,7 @@ such objects\n                 for patch in bars:\n                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n \n+\n         elif histtype.startswith('step'):\n             # these define the perimeter of the polygon\n             x = np.zeros(4 * len(bins) - 3)\n@@ -6875,6 +6877,7 @@ such objects\n             # add patches in reverse order so that when stacking,\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n+\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                 patches.append(self.fill(\n                     x[:split], y[:split],\n@@ -6883,12 +6886,23 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n+\n+            # Set sticky edges only on the baseline patches, similar to bar histograms.\n+            # First, set sticky edges on all patches.\n             for patch_list in patches:\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n                         patch.sticky_edges.y.append(0)\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n+            \n+            # Remove stickies from all patches but the lowest ones, as otherwise\n+            # margin expansion would be unable to cross the stickies in the\n+            # middle of the patches.\n+            for patch_list in patches[1:]:\n+                for patch in patch_list:\n+                    patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n+\n \n             # we return patches, so put it back in the expected order\n             patches.reverse()\n",
    "variant_0": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 2412f815cd..54756f434c 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6813,6 +6813,7 @@ such objects\n                 if stacked:\n                     bottom = m\n                 boffset += dw\n+\n             # Remove stickies from all bars but the lowest ones, as otherwise\n             # margin expansion would be unable to cross the stickies in the\n             # middle of the bars.\n@@ -6820,6 +6821,7 @@ such objects\n                 for patch in bars:\n                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n \n+\n         elif histtype.startswith('step'):\n             # these define the perimeter of the polygon\n             x = np.zeros(4 * len(bins) - 3)\n@@ -6828,6 +6830,16 @@ such objects\n             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n \n+            if bottom is None:\n+                bottom = 0\n+\n+            y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom\n+            y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n+            y = np.zeros(4 * len(bins) - 3)\n+\n+            x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n+            x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n+\n             if bottom is None:\n                 bottom = 0\n \n@@ -6875,6 +6887,7 @@ such objects\n             # add patches in reverse order so that when stacking,\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n+\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                 patches.append(self.fill(\n                     x[:split], y[:split],\n@@ -6883,6 +6896,7 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n+\n             for patch_list in patches:\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n@@ -6890,8 +6904,29 @@ such objects\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n \n+            # Remove sticky edges from all but the bottom-most patches to allow\n+            # margin expansion for autoscaling (similar to bar histograms)\n+            if len(patches) > 1:\n+                for patch_list in patches[:-1]:  # All but the last (bottom-most)\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n+\n+\n             # we return patches, so put it back in the expected order\n             patches.reverse()\n+            \n+            # For step histograms with multiple datasets, remove sticky edges from\n+            # all but the baseline patches to allow proper autoscaling margins\n+            if len(patches) > 1:\n+                for patch_list in patches[1:]:  # Skip the first (baseline) patches\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n \n         # If None, make all labels None (via zip_longest below); otherwise,\n         # cast each element to str, but keep a single str as it.\n",
    "variant_1": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 2412f815cd..5ca1aee835 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6813,6 +6813,7 @@ such objects\n                 if stacked:\n                     bottom = m\n                 boffset += dw\n+\n             # Remove stickies from all bars but the lowest ones, as otherwise\n             # margin expansion would be unable to cross the stickies in the\n             # middle of the bars.\n@@ -6820,6 +6821,7 @@ such objects\n                 for patch in bars:\n                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n \n+\n         elif histtype.startswith('step'):\n             # these define the perimeter of the polygon\n             x = np.zeros(4 * len(bins) - 3)\n@@ -6828,6 +6830,16 @@ such objects\n             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n \n+            if bottom is None:\n+                bottom = 0\n+\n+            y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom\n+            y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n+            y = np.zeros(4 * len(bins) - 3)\n+\n+            x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n+            x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n+\n             if bottom is None:\n                 bottom = 0\n \n@@ -6875,6 +6887,7 @@ such objects\n             # add patches in reverse order so that when stacking,\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n+\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                 patches.append(self.fill(\n                     x[:split], y[:split],\n@@ -6883,6 +6896,7 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n+\n             for patch_list in patches:\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n@@ -6890,8 +6904,29 @@ such objects\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n \n+            # Remove sticky edges from non-baseline patches to allow proper autoscaling\n+            # This matches the behavior of bar histograms\n+            if len(patches) > 1:\n+                for patch_list in patches[1:]:  # Skip the first (baseline) patch\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n+\n+\n             # we return patches, so put it back in the expected order\n             patches.reverse()\n+            \n+            # For step histograms, manage sticky edges like bar histograms\n+            # Remove sticky edges from all but the bottom patches to allow autoscaling\n+            if len(patches) > 1:\n+                for patch_list in patches[1:]:  # Skip the bottom patches\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n \n         # If None, make all labels None (via zip_longest below); otherwise,\n         # cast each element to str, but keep a single str as it.\n",
    "variant_2": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 2412f815cd..9bf2663342 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6813,6 +6813,7 @@ such objects\n                 if stacked:\n                     bottom = m\n                 boffset += dw\n+\n             # Remove stickies from all bars but the lowest ones, as otherwise\n             # margin expansion would be unable to cross the stickies in the\n             # middle of the bars.\n@@ -6820,6 +6821,7 @@ such objects\n                 for patch in bars:\n                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n \n+\n         elif histtype.startswith('step'):\n             # these define the perimeter of the polygon\n             x = np.zeros(4 * len(bins) - 3)\n@@ -6875,6 +6877,7 @@ such objects\n             # add patches in reverse order so that when stacking,\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n+\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                 patches.append(self.fill(\n                     x[:split], y[:split],\n@@ -6883,6 +6886,7 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n+\n             for patch_list in patches:\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n@@ -6890,8 +6894,31 @@ such objects\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n \n+            # Remove sticky edges from all but the bottom-most patches to allow\n+            # margin expansion for autoscaling (similar to bar histograms)\n+            if len(patches) > 1:\n+                for patch_list in patches[:-1]:  # All but the last (bottom-most)\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n+\n+\n             # we return patches, so put it back in the expected order\n             patches.reverse()\n+            \n+            # For step histograms, remove sticky edges from all but the baseline patches\n+            # to allow proper margin expansion during autoscaling (similar to bar histograms)\n+            if histtype == 'step' or histtype == 'stepfilled':\n+                # After reverse(), patches[0] contains the baseline/bottom patches\n+                # Remove sticky edges from stacked patches (patches[1:]) to enable margins\n+                for patch_list in patches[1:]:\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n \n         # If None, make all labels None (via zip_longest below); otherwise,\n         # cast each element to str, but keep a single str as it.\n",
    "variant_3": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 2412f815cd..19a3017af8 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6813,6 +6813,7 @@ such objects\n                 if stacked:\n                     bottom = m\n                 boffset += dw\n+\n             # Remove stickies from all bars but the lowest ones, as otherwise\n             # margin expansion would be unable to cross the stickies in the\n             # middle of the bars.\n@@ -6820,6 +6821,7 @@ such objects\n                 for patch in bars:\n                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n \n+\n         elif histtype.startswith('step'):\n             # these define the perimeter of the polygon\n             x = np.zeros(4 * len(bins) - 3)\n@@ -6875,6 +6877,7 @@ such objects\n             # add patches in reverse order so that when stacking,\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n+\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                 patches.append(self.fill(\n                     x[:split], y[:split],\n@@ -6883,6 +6886,7 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n+\n             for patch_list in patches:\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n@@ -6890,8 +6894,31 @@ such objects\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n \n+            # For step histograms, remove sticky edges from all but the baseline patches\n+            # to allow proper autoscaling margins (similar to bar histograms)\n+            if histtype == 'step':\n+                # After patches.reverse() below, first patches are topmost in stack\n+                # Remove sticky edges from all but baseline (last in visual stack)\n+                for patch_list in patches[:-1]:  # All except the last (baseline)\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n+\n+\n             # we return patches, so put it back in the expected order\n             patches.reverse()\n+            \n+            # For step histograms, remove sticky edges from all but the baseline patches\n+            # to allow proper autoscaling margins, similar to bar histograms\n+            if histtype == 'step' or histtype == 'stepfilled':\n+                for patch_list in patches[1:]:  # Skip the first (baseline) patch list\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n \n         # If None, make all labels None (via zip_longest below); otherwise,\n         # cast each element to str, but keep a single str as it.\n",
    "variant_4": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 2412f815cd..2d6937d8af 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6813,6 +6813,7 @@ such objects\n                 if stacked:\n                     bottom = m\n                 boffset += dw\n+\n             # Remove stickies from all bars but the lowest ones, as otherwise\n             # margin expansion would be unable to cross the stickies in the\n             # middle of the bars.\n@@ -6820,6 +6821,7 @@ such objects\n                 for patch in bars:\n                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n \n+\n         elif histtype.startswith('step'):\n             # these define the perimeter of the polygon\n             x = np.zeros(4 * len(bins) - 3)\n@@ -6828,6 +6830,16 @@ such objects\n             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n \n+            if bottom is None:\n+                bottom = 0\n+\n+            y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom\n+            y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n+            y = np.zeros(4 * len(bins) - 3)\n+\n+            x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n+            x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n+\n             if bottom is None:\n                 bottom = 0\n \n@@ -6875,6 +6887,7 @@ such objects\n             # add patches in reverse order so that when stacking,\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n+\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                 patches.append(self.fill(\n                     x[:split], y[:split],\n@@ -6883,6 +6896,7 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n+\n             for patch_list in patches:\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n@@ -6890,8 +6904,29 @@ such objects\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n \n+            # Remove sticky edges from all but the bottommost patches to allow\n+            # proper autoscaling margins, similar to bar histograms\n+            if len(patches) > 1:\n+                for patch_list in patches[1:]:  # Skip the bottommost patches\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n+\n+\n             # we return patches, so put it back in the expected order\n             patches.reverse()\n+            \n+            # For step histograms, manage sticky edges like bar histograms\n+            # Remove sticky edges from all but the bottom patches to allow autoscaling\n+            if len(patches) > 1:\n+                for patch_list in patches[1:]:  # Skip the bottom patches\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n \n         # If None, make all labels None (via zip_longest below); otherwise,\n         # cast each element to str, but keep a single str as it.\n",
    "variant_5": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 2412f815cd..a9bd939981 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6813,6 +6813,7 @@ such objects\n                 if stacked:\n                     bottom = m\n                 boffset += dw\n+\n             # Remove stickies from all bars but the lowest ones, as otherwise\n             # margin expansion would be unable to cross the stickies in the\n             # middle of the bars.\n@@ -6820,6 +6821,7 @@ such objects\n                 for patch in bars:\n                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n \n+\n         elif histtype.startswith('step'):\n             # these define the perimeter of the polygon\n             x = np.zeros(4 * len(bins) - 3)\n@@ -6828,6 +6830,16 @@ such objects\n             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n \n+            if bottom is None:\n+                bottom = 0\n+\n+            y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom\n+            y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n+            y = np.zeros(4 * len(bins) - 3)\n+\n+            x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n+            x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n+\n             if bottom is None:\n                 bottom = 0\n \n@@ -6875,6 +6887,7 @@ such objects\n             # add patches in reverse order so that when stacking,\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n+\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                 patches.append(self.fill(\n                     x[:split], y[:split],\n@@ -6883,6 +6896,7 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n+\n             for patch_list in patches:\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n@@ -6890,8 +6904,31 @@ such objects\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n \n+            # Remove sticky edges from all but the baseline patches to allow\n+            # proper margin expansion for autoscaling (similar to bar histograms)\n+            if len(patches) > 1:\n+                for patch_list in patches[:-1]:  # All except the last (baseline) patch\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n+\n+\n             # we return patches, so put it back in the expected order\n             patches.reverse()\n+            \n+            # For step histograms, manage sticky edges similar to bar histograms\n+            # Remove sticky edges from all but the bottom patches to allow proper autoscaling\n+            if histtype == 'step' and len(patches) > 1:\n+                for patch_list in patches[1:]:  # Skip the first (bottom) patch\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            if 0 in patch.sticky_edges.y:\n+                                patch.sticky_edges.y.remove(0)\n+                        elif orientation == 'horizontal':\n+                            if 0 in patch.sticky_edges.x:\n+                                patch.sticky_edges.x.remove(0)\n \n         # If None, make all labels None (via zip_longest below); otherwise,\n         # cast each element to str, but keep a single str as it.\n",
    "variant_6": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 2412f815cd..755aebb070 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6813,6 +6813,7 @@ such objects\n                 if stacked:\n                     bottom = m\n                 boffset += dw\n+\n             # Remove stickies from all bars but the lowest ones, as otherwise\n             # margin expansion would be unable to cross the stickies in the\n             # middle of the bars.\n@@ -6820,6 +6821,7 @@ such objects\n                 for patch in bars:\n                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n \n+\n         elif histtype.startswith('step'):\n             # these define the perimeter of the polygon\n             x = np.zeros(4 * len(bins) - 3)\n@@ -6875,6 +6877,7 @@ such objects\n             # add patches in reverse order so that when stacking,\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n+\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                 patches.append(self.fill(\n                     x[:split], y[:split],\n@@ -6883,6 +6886,7 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n+\n             for patch_list in patches:\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n@@ -6890,8 +6894,28 @@ such objects\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n \n+            # Remove sticky edges from all but the bottom patches to allow\n+            # autoscaling margins, similar to bar histograms\n+            for patch_list in patches[1:]:\n+                for patch in patch_list:\n+                    if orientation == 'vertical':\n+                        patch.sticky_edges.y.clear()\n+                    elif orientation == 'horizontal':\n+                        patch.sticky_edges.x.clear()\n+\n+\n             # we return patches, so put it back in the expected order\n             patches.reverse()\n+            \n+            # For step histograms, manage sticky edges like bar histograms\n+            # Remove sticky edges from all but the bottom patches to allow autoscaling\n+            if len(patches) > 1:\n+                for patch_list in patches[1:]:  # Skip the bottom patches\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n \n         # If None, make all labels None (via zip_longest below); otherwise,\n         # cast each element to str, but keep a single str as it.\n",
    "variant_7": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 2412f815cd..c587df8094 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6813,6 +6813,7 @@ such objects\n                 if stacked:\n                     bottom = m\n                 boffset += dw\n+\n             # Remove stickies from all bars but the lowest ones, as otherwise\n             # margin expansion would be unable to cross the stickies in the\n             # middle of the bars.\n@@ -6820,6 +6821,7 @@ such objects\n                 for patch in bars:\n                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n \n+\n         elif histtype.startswith('step'):\n             # these define the perimeter of the polygon\n             x = np.zeros(4 * len(bins) - 3)\n@@ -6875,6 +6877,7 @@ such objects\n             # add patches in reverse order so that when stacking,\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n+\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                 patches.append(self.fill(\n                     x[:split], y[:split],\n@@ -6883,15 +6886,39 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n+\n             for patch_list in patches:\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n                         patch.sticky_edges.y.append(0)\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n+            \n+            # Remove sticky edges from non-baseline patches to allow margin expansion\n+            # Keep sticky edges only on the baseline (first after reversal)\n+            if len(patches) > 1:\n+                for patch_list in patches[1:]:  # Skip baseline patches\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n+\n \n             # we return patches, so put it back in the expected order\n             patches.reverse()\n+            \n+            # For step histograms, manage sticky edges like bar histograms\n+            # Remove sticky edges from all but the bottom-most patches to allow proper autoscaling\n+            if len(patches) > 1:\n+                for patch_list in patches[1:]:  # Skip the bottom-most patches\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            if 0 in patch.sticky_edges.y:\n+                                patch.sticky_edges.y.remove(0)\n+                        elif orientation == 'horizontal':\n+                            if 0 in patch.sticky_edges.x:\n+                                patch.sticky_edges.x.remove(0)\n \n         # If None, make all labels None (via zip_longest below); otherwise,\n         # cast each element to str, but keep a single str as it.\n",
    "variant_8": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 2412f815cd..e00f07f84d 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -6813,6 +6813,7 @@ such objects\n                 if stacked:\n                     bottom = m\n                 boffset += dw\n+\n             # Remove stickies from all bars but the lowest ones, as otherwise\n             # margin expansion would be unable to cross the stickies in the\n             # middle of the bars.\n@@ -6820,6 +6821,7 @@ such objects\n                 for patch in bars:\n                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []\n \n+\n         elif histtype.startswith('step'):\n             # these define the perimeter of the polygon\n             x = np.zeros(4 * len(bins) - 3)\n@@ -6875,6 +6877,7 @@ such objects\n             # add patches in reverse order so that when stacking,\n             # items lower in the stack are plotted on top of\n             # items higher in the stack\n+\n             for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                 patches.append(self.fill(\n                     x[:split], y[:split],\n@@ -6883,15 +6886,37 @@ such objects\n                     edgecolor=None if fill else c,\n                     fill=fill if fill else None,\n                     zorder=None if fill else mlines.Line2D.zorder))\n+\n             for patch_list in patches:\n                 for patch in patch_list:\n                     if orientation == 'vertical':\n                         patch.sticky_edges.y.append(0)\n                     elif orientation == 'horizontal':\n                         patch.sticky_edges.x.append(0)\n+            \n+            # Remove sticky edges from all but the bottom-most patches to allow\n+            # autoscaling margins for step histograms (similar to bar histograms)\n+            if len(patches) > 1:\n+                for patch_list in patches[:-1]:  # All but the last (bottom-most) patch\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n+\n \n             # we return patches, so put it back in the expected order\n             patches.reverse()\n+            \n+            # For step histograms, remove sticky edges from all but the bottom patches\n+            # to allow proper autoscaling margins, similar to bar histograms\n+            if histtype == 'step' and len(patches) > 1:\n+                for patch_list in patches[1:]:  # Skip the bottom/baseline patches\n+                    for patch in patch_list:\n+                        if orientation == 'vertical':\n+                            patch.sticky_edges.y.clear()\n+                        elif orientation == 'horizontal':\n+                            patch.sticky_edges.x.clear()\n \n         # If None, make all labels None (via zip_longest below); otherwise,\n         # cast each element to str, but keep a single str as it.\n"
  }
}