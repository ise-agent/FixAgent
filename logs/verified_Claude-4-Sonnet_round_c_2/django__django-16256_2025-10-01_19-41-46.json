{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 65-65)": "\n\nfrom asgiref.sync import sync_to_async\n",
    "Location 2 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 796-812)": "\nfrom django.core.exceptions import FieldError\nfrom django.db import (\n    DEFAULT_DB_ALIAS,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import Q, Window, signals\nfrom django.db.models.functions import RowNumber\nfrom django.db.models.lookups import GreaterThan, LessThanOrEqual\nfrom django.db.models.query import QuerySet\nfrom django.db.models.query_utils import DeferredAttribute\nfrom django.db.models.utils import AltersData, resolve_callables\nfrom django.utils.functional import cached_property\nfrom django.db.models import Model\nfrom asgiref.sync import sync_to_async\n",
    "Location 3 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 1194-1220)": "\n        def update_or_create(self, *, through_defaults=None, **kwargs):\n            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n            obj, created = super(\n                ManyRelatedManager, self.db_manager(db)\n            ).update_or_create(**kwargs)\n            # We only need to add() if created because if we got an object back\n            # from get() then the relationship already exists.\n            if created:\n                self.add(obj, through_defaults=through_defaults)\n            return obj, created\n\n        update_or_create.alters_data = True\n\n        async def acreate(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        acreate.alters_data = True\n\n        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.get_or_create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        aget_or_create.alters_data = True\n\n        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.update_or_create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        aupdate_or_create.alters_data = True\n\n        def _get_target_ids(self, target_field_name, objs):\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 65-65)": [
      "\n\nfrom asgiref.sync import sync_to_async\n",
      "\n\nfrom asgiref.sync import sync_to_async\n",
      "\n\nfrom asgiref.sync import sync_to_async\n",
      "\n\nfrom asgiref.sync import sync_to_async\n",
      "\n\nfrom asgiref.sync import sync_to_async\n",
      "\n\nfrom asgiref.sync import sync_to_async\n",
      "\n\nfrom asgiref.sync import sync_to_async\n",
      "\n\nfrom asgiref.sync import sync_to_async\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 796-812)": [
      "\nfrom django.core.exceptions import FieldError\nfrom django.db import (\n    DEFAULT_DB_ALIAS,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import Q, Window, signals\nfrom django.db.models.functions import RowNumber\nfrom django.db.models.lookups import GreaterThan, LessThanOrEqual\nfrom django.db.models.query import QuerySet\nfrom django.db.models.query_utils import DeferredAttribute\nfrom django.db.models.utils import AltersData, resolve_callables\nfrom django.utils.functional import cached_property\nfrom django.db.models import Model\nfrom asgiref.sync import sync_to_async\n",
      "\nfrom django.core.exceptions import FieldError\nfrom django.db import (\n    DEFAULT_DB_ALIAS,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import Q, Window, signals\nfrom django.db.models.functions import RowNumber\nfrom django.db.models.lookups import GreaterThan, LessThanOrEqual\nfrom django.db.models.query import QuerySet\nfrom django.db.models.query_utils import DeferredAttribute\nfrom django.db.models.utils import AltersData, resolve_callables\nfrom django.utils.functional import cached_property\nfrom django.db.models import Model\nfrom asgiref.sync import sync_to_async\n",
      "\nfrom django.core.exceptions import FieldError\nfrom django.db import (\n    IntegrityError,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import Q, Window, signals\nfrom django.db.models.functions import RowNumber\nfrom django.db.models.lookups import GreaterThan, LessThanOrEqual\nfrom django.db.models.query import QuerySet\nfrom django.db.models.query_utils import DeferredAttribute\nfrom django.db.models.utils import AltersData, resolve_callables\nfrom django.utils.functional import cached_property\nfrom django.db.models import Model\nfrom asgiref.sync import sync_to_async\n",
      "\nfrom django.core.exceptions import FieldError\nfrom django.db import (\n    DEFAULT_DB_ALIAS,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import Q, Window, signals\nfrom django.db.models.functions import RowNumber\nfrom django.db.models.lookups import GreaterThan, LessThanOrEqual\nfrom django.db.models.query import QuerySet\nfrom django.db.models.query_utils import DeferredAttribute\nfrom django.db.models.utils import AltersData, resolve_callables\nfrom django.utils.functional import cached_property\nfrom django.db.models import Model\nfrom asgiref.sync import sync_to_async\n",
      "\nfrom asgiref.sync import sync_to_async\nfrom django.core.exceptions import FieldError\nfrom django.db import (\n    DEFAULT_DB_ALIAS,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import Q, Window, signals\nfrom django.db.models.functions import RowNumber\nfrom django.db.models.lookups import GreaterThan, LessThanOrEqual\nfrom django.db.models.query import QuerySet\nfrom django.db.models.query_utils import DeferredAttribute\nfrom django.db.models.utils import AltersData, resolve_callables\nfrom django.utils.functional import cached_property\nfrom django.db.models import Model\n",
      "\nfrom asgiref.sync import sync_to_async\nfrom django.core.exceptions import FieldError\nfrom django.db import (\n    DEFAULT_DB_ALIAS,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import Q, Window, signals\nfrom django.db.models.functions import RowNumber\nfrom django.db.models.lookups import GreaterThan, LessThanOrEqual\nfrom django.db.models.query import QuerySet\nfrom django.db.models.query_utils import DeferredAttribute\nfrom django.db.models.utils import AltersData, resolve_callables\nfrom django.utils.functional import cached_property\nfrom django.db.models import Model\n",
      "\nfrom django.core.exceptions import FieldError\nfrom django.db import (\n    DEFAULT_DB_ALIAS,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import Q, Window, signals\nfrom django.db.models.functions import RowNumber\nfrom django.db.models.lookups import GreaterThan, LessThanOrEqual\nfrom django.db.models.query import QuerySet\nfrom django.db.models.query_utils import DeferredAttribute\nfrom django.db.models.utils import AltersData, resolve_callables\nfrom django.utils.functional import cached_property\nfrom django.db.models import Model\nfrom asgiref.sync import sync_to_async\n",
      "\nfrom django.core.exceptions import FieldError\nfrom django.db import (\n    DEFAULT_DB_ALIAS,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import Q, Window, signals\nfrom django.db.models.functions import RowNumber\nfrom django.db.models.lookups import GreaterThan, LessThanOrEqual\nfrom django.db.models.query import QuerySet\nfrom django.db.models.query_utils import DeferredAttribute\nfrom django.db.models.utils import AltersData, resolve_callables\nfrom django.utils.functional import cached_property\nfrom django.db.models import Model\nfrom asgiref.sync import sync_to_async\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 1194-1220)": [
      "\n        def get_or_create(self, *, through_defaults=None, **kwargs):\n            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n                **kwargs\n            )\n            # We only need to add() if created because if we got an object back\n            # from get() then the relationship already exists.\n            if created:\n                self.add(obj, through_defaults=through_defaults)\n            return obj, created\n\n        get_or_create.alters_data = True\n\n        def update_or_create(self, *, through_defaults=None, **kwargs):\n            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n            obj, created = super(\n                ManyRelatedManager, self.db_manager(db)\n            ).update_or_create(**kwargs)\n            # We only need to add() if created because if we got an object back\n            # from get() then the relationship already exists.\n            if created:\n                self.add(obj, through_defaults=through_defaults)\n            return obj, created\n\n        update_or_create.alters_data = True\n\n        async def acreate(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.create)(through_defaults=through_defaults, **kwargs)\n\n        acreate.alters_data = True\n\n        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.get_or_create)(through_defaults=through_defaults, **kwargs)\n\n        aget_or_create.alters_data = True\n\n        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.update_or_create)(through_defaults=through_defaults, **kwargs)\n\n        aupdate_or_create.alters_data = True\n",
      "\nfrom django.core.exceptions import FieldError\nfrom django.db import (\n    DEFAULT_DB_ALIAS,\n    connections,\n    router,\n    transaction,\n)\nfrom django.db.models import Q, Window, signals\nfrom django.db.models.functions import RowNumber\nfrom django.db.models.lookups import GreaterThan, LessThanOrEqual\nfrom django.db.models.query import QuerySet\nfrom django.db.models.query_utils import DeferredAttribute\nfrom django.db.models.utils import AltersData, resolve_callables\nfrom django.utils.functional import cached_property\nfrom django.db.models import Model\nfrom asgiref.sync import sync_to_async\n",
      "\n        update_or_create.alters_data = True\n\n        async def acreate(self, **kwargs):\n            return await sync_to_async(self.create)(**kwargs)\n\n        acreate.alters_data = True\n\n        async def aget_or_create(self, **kwargs):\n            return await sync_to_async(self.get_or_create)(**kwargs)\n\n        aget_or_create.alters_data = True\n\n        async def aupdate_or_create(self, **kwargs):\n            return await sync_to_async(self.update_or_create)(**kwargs)\n\n        aupdate_or_create.alters_data = True\n\n        def _get_target_ids(self, target_field_name, objs):\n",
      "\n        def get_or_create(self, *, through_defaults=None, **kwargs):\n            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n                **kwargs\n            )\n            # We only need to add() if created because if we got an object back\n            # from get() then the relationship already exists.\n            if created:\n                self.add(obj, through_defaults=through_defaults)\n            return obj, created\n\n        get_or_create.alters_data = True\n\n        def update_or_create(self, *, through_defaults=None, **kwargs):\n            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n            obj, created = super(\n                ManyRelatedManager, self.db_manager(db)\n            ).update_or_create(**kwargs)\n            # We only need to add() if created because if we got an object back\n            # from get() then the relationship already exists.\n            if created:\n                self.add(obj, through_defaults=through_defaults)\n            return obj, created\n\n        update_or_create.alters_data = True\n\n        async def acreate(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        acreate.alters_data = True\n\n        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.get_or_create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        aget_or_create.alters_data = True\n\n        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.update_or_create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        aupdate_or_create.alters_data = True\n",
      "\n        def update_or_create(self, *, through_defaults=None, **kwargs):\n            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n            obj, created = super(\n                ManyRelatedManager, self.db_manager(db)\n            ).update_or_create(**kwargs)\n            # We only need to add() if created because if we got an object back\n            # from get() then the relationship already exists.\n            if created:\n                self.add(obj, through_defaults=through_defaults)\n            return obj, created\n\n        update_or_create.alters_data = True\n\n        async def acreate(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        acreate.alters_data = True\n\n        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.get_or_create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        aget_or_create.alters_data = True\n\n        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.update_or_create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        aupdate_or_create.alters_data = True\n\n        def _get_target_ids(self, target_field_name, objs):\n",
      "\n        def update_or_create(self, *, through_defaults=None, **kwargs):\n            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n            obj, created = super(\n                ManyRelatedManager, self.db_manager(db)\n            ).update_or_create(**kwargs)\n            # We only need to add() if created because if we got an object back\n            # from get() then the relationship already exists.\n            if created:\n                self.add(obj, through_defaults=through_defaults)\n            return obj, created\n\n        update_or_create.alters_data = True\n\n        async def acreate(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        acreate.alters_data = True\n\n        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.get_or_create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        aget_or_create.alters_data = True\n\n        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.update_or_create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        aupdate_or_create.alters_data = True\n\n        def _get_target_ids(self, target_field_name, objs):\n",
      "\n        update_or_create.alters_data = True\n\n        async def acreate(self, **kwargs):\n            return await sync_to_async(self.create)(**kwargs)\n\n        acreate.alters_data = True\n\n        async def aget_or_create(self, **kwargs):\n            return await sync_to_async(self.get_or_create)(**kwargs)\n\n        aget_or_create.alters_data = True\n\n        async def aupdate_or_create(self, **kwargs):\n            return await sync_to_async(self.update_or_create)(**kwargs)\n\n        aupdate_or_create.alters_data = True\n\n        def _get_target_ids(self, target_field_name, objs):\n",
      "\n        def update_or_create(self, *, through_defaults=None, **kwargs):\n            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n            obj, created = super(\n                ManyRelatedManager, self.db_manager(db)\n            ).update_or_create(**kwargs)\n            # We only need to add() if created because if we got an object back\n            # from get() then the relationship already exists.\n            if created:\n                self.add(obj, through_defaults=through_defaults)\n            return obj, created\n\n        update_or_create.alters_data = True\n\n        async def acreate(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        acreate.alters_data = True\n\n        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.get_or_create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        aget_or_create.alters_data = True\n\n        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n            return await sync_to_async(self.update_or_create)(\n                through_defaults=through_defaults, **kwargs\n            )\n\n        aupdate_or_create.alters_data = True\n\n        def _get_target_ids(self, target_field_name, objs):\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex c5d87f647a..235ec7c627 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -63,6 +63,7 @@ and two directions (forward and reverse) for a total of six combinations.\n    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n \"\"\"\n \n+from asgiref.sync import sync_to_async\n from django.core.exceptions import FieldError\n from django.db import (\n     DEFAULT_DB_ALIAS,\n@@ -793,6 +794,7 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         create.alters_data = True\n \n+\n         def get_or_create(self, **kwargs):\n             self._check_fk_val()\n             kwargs[self.field.name] = self.instance\n@@ -809,6 +811,21 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         update_or_create.alters_data = True\n \n+        async def acreate(self, **kwargs):\n+            return await sync_to_async(self.create)(**kwargs)\n+\n+        acreate.alters_data = True\n+\n+        async def aget_or_create(self, **kwargs):\n+            return await sync_to_async(self.get_or_create)(**kwargs)\n+\n+        aget_or_create.alters_data = True\n+\n+        async def aupdate_or_create(self, **kwargs):\n+            return await sync_to_async(self.update_or_create)(**kwargs)\n+\n+        aupdate_or_create.alters_data = True\n+\n         # remove() and clear() are only provided if the ForeignKey can have a\n         # value of null.\n         if rel.field.null:\n@@ -1191,6 +1208,7 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         create.alters_data = True\n \n+\n         def get_or_create(self, *, through_defaults=None, **kwargs):\n             db = router.db_for_write(self.instance.__class__, instance=self.instance)\n             obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n@@ -1217,6 +1235,21 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         update_or_create.alters_data = True\n \n+        async def acreate(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.create)(through_defaults=through_defaults, **kwargs)\n+\n+        acreate.alters_data = True\n+\n+        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.get_or_create)(through_defaults=through_defaults, **kwargs)\n+\n+        aget_or_create.alters_data = True\n+\n+        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.update_or_create)(through_defaults=through_defaults, **kwargs)\n+\n+        aupdate_or_create.alters_data = True\n+\n         def _get_target_ids(self, target_field_name, objs):\n             \"\"\"\n             Return the set of ids of `objs` that the target field references.\n",
    "variant_0": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex c5d87f647a..294d783bf2 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -63,6 +63,8 @@ and two directions (forward and reverse) for a total of six combinations.\n    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n \"\"\"\n \n+\n+from asgiref.sync import sync_to_async\n from django.core.exceptions import FieldError\n from django.db import (\n     DEFAULT_DB_ALIAS,\n@@ -793,23 +795,23 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         create.alters_data = True\n \n-        def get_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n-\n-        get_or_create.alters_data = True\n-\n-        def update_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n-\n-        update_or_create.alters_data = True\n \n-        # remove() and clear() are only provided if the ForeignKey can have a\n+from django.core.exceptions import FieldError\n+from django.db import (\n+    DEFAULT_DB_ALIAS,\n+    connections,\n+    router,\n+    transaction,\n+)\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n+from django.db.models.query import QuerySet\n+from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.utils import AltersData, resolve_callables\n+from django.utils.functional import cached_property\n+from django.db.models import Model\n+from asgiref.sync import sync_to_async\n         # value of null.\n         if rel.field.null:\n \n@@ -1191,18 +1193,6 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         create.alters_data = True\n \n-        def get_or_create(self, *, through_defaults=None, **kwargs):\n-            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n-            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n-                **kwargs\n-            )\n-            # We only need to add() if created because if we got an object back\n-            # from get() then the relationship already exists.\n-            if created:\n-                self.add(obj, through_defaults=through_defaults)\n-            return obj, created\n-\n-        get_or_create.alters_data = True\n \n         def update_or_create(self, *, through_defaults=None, **kwargs):\n             db = router.db_for_write(self.instance.__class__, instance=self.instance)\n@@ -1217,6 +1207,27 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         update_or_create.alters_data = True\n \n+        async def acreate(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        acreate.alters_data = True\n+\n+        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.get_or_create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        aget_or_create.alters_data = True\n+\n+        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.update_or_create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        aupdate_or_create.alters_data = True\n+\n         def _get_target_ids(self, target_field_name, objs):\n             \"\"\"\n             Return the set of ids of `objs` that the target field references.\n",
    "variant_1": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex c5d87f647a..8a75e054e0 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -63,6 +63,8 @@ and two directions (forward and reverse) for a total of six combinations.\n    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n \"\"\"\n \n+\n+from asgiref.sync import sync_to_async\n from django.core.exceptions import FieldError\n from django.db import (\n     DEFAULT_DB_ALIAS,\n@@ -793,23 +795,23 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         create.alters_data = True\n \n-        def get_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n-\n-        get_or_create.alters_data = True\n-\n-        def update_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n-\n-        update_or_create.alters_data = True\n \n-        # remove() and clear() are only provided if the ForeignKey can have a\n+from django.core.exceptions import FieldError\n+from django.db import (\n+    DEFAULT_DB_ALIAS,\n+    connections,\n+    router,\n+    transaction,\n+)\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n+from django.db.models.query import QuerySet\n+from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.utils import AltersData, resolve_callables\n+from django.utils.functional import cached_property\n+from django.db.models import Model\n+from asgiref.sync import sync_to_async\n         # value of null.\n         if rel.field.null:\n \n@@ -1191,6 +1193,7 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         create.alters_data = True\n \n+\n         def get_or_create(self, *, through_defaults=None, **kwargs):\n             db = router.db_for_write(self.instance.__class__, instance=self.instance)\n             obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n@@ -1217,7 +1220,20 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         update_or_create.alters_data = True\n \n-        def _get_target_ids(self, target_field_name, objs):\n+        async def acreate(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.create)(through_defaults=through_defaults, **kwargs)\n+\n+        acreate.alters_data = True\n+\n+        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.get_or_create)(through_defaults=through_defaults, **kwargs)\n+\n+        aget_or_create.alters_data = True\n+\n+        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.update_or_create)(through_defaults=through_defaults, **kwargs)\n+\n+        aupdate_or_create.alters_data = True\n             \"\"\"\n             Return the set of ids of `objs` that the target field references.\n             \"\"\"\n",
    "variant_2": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex c5d87f647a..ec7a2fd4fa 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -63,6 +63,8 @@ and two directions (forward and reverse) for a total of six combinations.\n    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n \"\"\"\n \n+\n+from asgiref.sync import sync_to_async\n from django.core.exceptions import FieldError\n from django.db import (\n     DEFAULT_DB_ALIAS,\n@@ -793,23 +795,23 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         create.alters_data = True\n \n-        def get_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n-\n-        get_or_create.alters_data = True\n \n-        def update_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n-\n-        update_or_create.alters_data = True\n-\n-        # remove() and clear() are only provided if the ForeignKey can have a\n+from django.core.exceptions import FieldError\n+from django.db import (\n+    DEFAULT_DB_ALIAS,\n+    connections,\n+    router,\n+    transaction,\n+)\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n+from django.db.models.query import QuerySet\n+from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.utils import AltersData, resolve_callables\n+from django.utils.functional import cached_property\n+from django.db.models import Model\n+from asgiref.sync import sync_to_async\n         # value of null.\n         if rel.field.null:\n \n@@ -1191,33 +1193,23 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         create.alters_data = True\n \n-        def get_or_create(self, *, through_defaults=None, **kwargs):\n-            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n-            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n-                **kwargs\n-            )\n-            # We only need to add() if created because if we got an object back\n-            # from get() then the relationship already exists.\n-            if created:\n-                self.add(obj, through_defaults=through_defaults)\n-            return obj, created\n-\n-        get_or_create.alters_data = True\n \n-        def update_or_create(self, *, through_defaults=None, **kwargs):\n-            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n-            obj, created = super(\n-                ManyRelatedManager, self.db_manager(db)\n-            ).update_or_create(**kwargs)\n-            # We only need to add() if created because if we got an object back\n-            # from get() then the relationship already exists.\n-            if created:\n-                self.add(obj, through_defaults=through_defaults)\n-            return obj, created\n-\n-        update_or_create.alters_data = True\n-\n-        def _get_target_ids(self, target_field_name, objs):\n+from django.core.exceptions import FieldError\n+from django.db import (\n+    DEFAULT_DB_ALIAS,\n+    connections,\n+    router,\n+    transaction,\n+)\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n+from django.db.models.query import QuerySet\n+from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.utils import AltersData, resolve_callables\n+from django.utils.functional import cached_property\n+from django.db.models import Model\n+from asgiref.sync import sync_to_async\n             \"\"\"\n             Return the set of ids of `objs` that the target field references.\n             \"\"\"\n",
    "variant_3": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex c5d87f647a..393e00697f 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -63,6 +63,8 @@ and two directions (forward and reverse) for a total of six combinations.\n    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n \"\"\"\n \n+\n+from asgiref.sync import sync_to_async\n from django.core.exceptions import FieldError\n from django.db import (\n     DEFAULT_DB_ALIAS,\n@@ -793,23 +795,23 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         create.alters_data = True\n \n-        def get_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n-\n-        get_or_create.alters_data = True\n-\n-        def update_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n \n-        update_or_create.alters_data = True\n-\n-        # remove() and clear() are only provided if the ForeignKey can have a\n+from django.core.exceptions import FieldError\n+from django.db import (\n+    IntegrityError,\n+    connections,\n+    router,\n+    transaction,\n+)\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n+from django.db.models.query import QuerySet\n+from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.utils import AltersData, resolve_callables\n+from django.utils.functional import cached_property\n+from django.db.models import Model\n+from asgiref.sync import sync_to_async\n         # value of null.\n         if rel.field.null:\n \n@@ -1191,31 +1193,23 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         create.alters_data = True\n \n-        def get_or_create(self, *, through_defaults=None, **kwargs):\n-            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n-            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n-                **kwargs\n-            )\n-            # We only need to add() if created because if we got an object back\n-            # from get() then the relationship already exists.\n-            if created:\n-                self.add(obj, through_defaults=through_defaults)\n-            return obj, created\n \n-        get_or_create.alters_data = True\n+        update_or_create.alters_data = True\n \n-        def update_or_create(self, *, through_defaults=None, **kwargs):\n-            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n-            obj, created = super(\n-                ManyRelatedManager, self.db_manager(db)\n-            ).update_or_create(**kwargs)\n-            # We only need to add() if created because if we got an object back\n-            # from get() then the relationship already exists.\n-            if created:\n-                self.add(obj, through_defaults=through_defaults)\n-            return obj, created\n+        async def acreate(self, **kwargs):\n+            return await sync_to_async(self.create)(**kwargs)\n \n-        update_or_create.alters_data = True\n+        acreate.alters_data = True\n+\n+        async def aget_or_create(self, **kwargs):\n+            return await sync_to_async(self.get_or_create)(**kwargs)\n+\n+        aget_or_create.alters_data = True\n+\n+        async def aupdate_or_create(self, **kwargs):\n+            return await sync_to_async(self.update_or_create)(**kwargs)\n+\n+        aupdate_or_create.alters_data = True\n \n         def _get_target_ids(self, target_field_name, objs):\n             \"\"\"\n",
    "variant_4": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex c5d87f647a..51e4db9268 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -63,6 +63,8 @@ and two directions (forward and reverse) for a total of six combinations.\n    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n \"\"\"\n \n+\n+from asgiref.sync import sync_to_async\n from django.core.exceptions import FieldError\n from django.db import (\n     DEFAULT_DB_ALIAS,\n@@ -793,23 +795,23 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         create.alters_data = True\n \n-        def get_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n-\n-        get_or_create.alters_data = True\n-\n-        def update_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n-\n-        update_or_create.alters_data = True\n \n-        # remove() and clear() are only provided if the ForeignKey can have a\n+from django.core.exceptions import FieldError\n+from django.db import (\n+    DEFAULT_DB_ALIAS,\n+    connections,\n+    router,\n+    transaction,\n+)\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n+from django.db.models.query import QuerySet\n+from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.utils import AltersData, resolve_callables\n+from django.utils.functional import cached_property\n+from django.db.models import Model\n+from asgiref.sync import sync_to_async\n         # value of null.\n         if rel.field.null:\n \n@@ -1191,6 +1193,7 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         create.alters_data = True\n \n+\n         def get_or_create(self, *, through_defaults=None, **kwargs):\n             db = router.db_for_write(self.instance.__class__, instance=self.instance)\n             obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n@@ -1217,7 +1220,26 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         update_or_create.alters_data = True\n \n-        def _get_target_ids(self, target_field_name, objs):\n+        async def acreate(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        acreate.alters_data = True\n+\n+        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.get_or_create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        aget_or_create.alters_data = True\n+\n+        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.update_or_create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        aupdate_or_create.alters_data = True\n             \"\"\"\n             Return the set of ids of `objs` that the target field references.\n             \"\"\"\n",
    "variant_5": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex c5d87f647a..db2623aa85 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -63,6 +63,8 @@ and two directions (forward and reverse) for a total of six combinations.\n    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n \"\"\"\n \n+\n+from asgiref.sync import sync_to_async\n from django.core.exceptions import FieldError\n from django.db import (\n     DEFAULT_DB_ALIAS,\n@@ -793,23 +795,23 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         create.alters_data = True\n \n-        def get_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n-\n-        get_or_create.alters_data = True\n-\n-        def update_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n-\n-        update_or_create.alters_data = True\n \n-        # remove() and clear() are only provided if the ForeignKey can have a\n+from asgiref.sync import sync_to_async\n+from django.core.exceptions import FieldError\n+from django.db import (\n+    DEFAULT_DB_ALIAS,\n+    connections,\n+    router,\n+    transaction,\n+)\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n+from django.db.models.query import QuerySet\n+from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.utils import AltersData, resolve_callables\n+from django.utils.functional import cached_property\n+from django.db.models import Model\n         # value of null.\n         if rel.field.null:\n \n@@ -1191,18 +1193,6 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         create.alters_data = True\n \n-        def get_or_create(self, *, through_defaults=None, **kwargs):\n-            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n-            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n-                **kwargs\n-            )\n-            # We only need to add() if created because if we got an object back\n-            # from get() then the relationship already exists.\n-            if created:\n-                self.add(obj, through_defaults=through_defaults)\n-            return obj, created\n-\n-        get_or_create.alters_data = True\n \n         def update_or_create(self, *, through_defaults=None, **kwargs):\n             db = router.db_for_write(self.instance.__class__, instance=self.instance)\n@@ -1217,6 +1207,27 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         update_or_create.alters_data = True\n \n+        async def acreate(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        acreate.alters_data = True\n+\n+        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.get_or_create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        aget_or_create.alters_data = True\n+\n+        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.update_or_create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        aupdate_or_create.alters_data = True\n+\n         def _get_target_ids(self, target_field_name, objs):\n             \"\"\"\n             Return the set of ids of `objs` that the target field references.\n",
    "variant_6": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex c5d87f647a..db2623aa85 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -63,6 +63,8 @@ and two directions (forward and reverse) for a total of six combinations.\n    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n \"\"\"\n \n+\n+from asgiref.sync import sync_to_async\n from django.core.exceptions import FieldError\n from django.db import (\n     DEFAULT_DB_ALIAS,\n@@ -793,23 +795,23 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         create.alters_data = True\n \n-        def get_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n-\n-        get_or_create.alters_data = True\n-\n-        def update_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n-\n-        update_or_create.alters_data = True\n \n-        # remove() and clear() are only provided if the ForeignKey can have a\n+from asgiref.sync import sync_to_async\n+from django.core.exceptions import FieldError\n+from django.db import (\n+    DEFAULT_DB_ALIAS,\n+    connections,\n+    router,\n+    transaction,\n+)\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n+from django.db.models.query import QuerySet\n+from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.utils import AltersData, resolve_callables\n+from django.utils.functional import cached_property\n+from django.db.models import Model\n         # value of null.\n         if rel.field.null:\n \n@@ -1191,18 +1193,6 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         create.alters_data = True\n \n-        def get_or_create(self, *, through_defaults=None, **kwargs):\n-            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n-            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n-                **kwargs\n-            )\n-            # We only need to add() if created because if we got an object back\n-            # from get() then the relationship already exists.\n-            if created:\n-                self.add(obj, through_defaults=through_defaults)\n-            return obj, created\n-\n-        get_or_create.alters_data = True\n \n         def update_or_create(self, *, through_defaults=None, **kwargs):\n             db = router.db_for_write(self.instance.__class__, instance=self.instance)\n@@ -1217,6 +1207,27 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         update_or_create.alters_data = True\n \n+        async def acreate(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        acreate.alters_data = True\n+\n+        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.get_or_create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        aget_or_create.alters_data = True\n+\n+        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.update_or_create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        aupdate_or_create.alters_data = True\n+\n         def _get_target_ids(self, target_field_name, objs):\n             \"\"\"\n             Return the set of ids of `objs` that the target field references.\n",
    "variant_7": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex c5d87f647a..880ba78f72 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -63,6 +63,8 @@ and two directions (forward and reverse) for a total of six combinations.\n    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n \"\"\"\n \n+\n+from asgiref.sync import sync_to_async\n from django.core.exceptions import FieldError\n from django.db import (\n     DEFAULT_DB_ALIAS,\n@@ -793,23 +795,23 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         create.alters_data = True\n \n-        def get_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n-\n-        get_or_create.alters_data = True\n-\n-        def update_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n \n-        update_or_create.alters_data = True\n-\n-        # remove() and clear() are only provided if the ForeignKey can have a\n+from django.core.exceptions import FieldError\n+from django.db import (\n+    DEFAULT_DB_ALIAS,\n+    connections,\n+    router,\n+    transaction,\n+)\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n+from django.db.models.query import QuerySet\n+from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.utils import AltersData, resolve_callables\n+from django.utils.functional import cached_property\n+from django.db.models import Model\n+from asgiref.sync import sync_to_async\n         # value of null.\n         if rel.field.null:\n \n@@ -1191,31 +1193,23 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         create.alters_data = True\n \n-        def get_or_create(self, *, through_defaults=None, **kwargs):\n-            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n-            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n-                **kwargs\n-            )\n-            # We only need to add() if created because if we got an object back\n-            # from get() then the relationship already exists.\n-            if created:\n-                self.add(obj, through_defaults=through_defaults)\n-            return obj, created\n \n-        get_or_create.alters_data = True\n+        update_or_create.alters_data = True\n \n-        def update_or_create(self, *, through_defaults=None, **kwargs):\n-            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n-            obj, created = super(\n-                ManyRelatedManager, self.db_manager(db)\n-            ).update_or_create(**kwargs)\n-            # We only need to add() if created because if we got an object back\n-            # from get() then the relationship already exists.\n-            if created:\n-                self.add(obj, through_defaults=through_defaults)\n-            return obj, created\n+        async def acreate(self, **kwargs):\n+            return await sync_to_async(self.create)(**kwargs)\n \n-        update_or_create.alters_data = True\n+        acreate.alters_data = True\n+\n+        async def aget_or_create(self, **kwargs):\n+            return await sync_to_async(self.get_or_create)(**kwargs)\n+\n+        aget_or_create.alters_data = True\n+\n+        async def aupdate_or_create(self, **kwargs):\n+            return await sync_to_async(self.update_or_create)(**kwargs)\n+\n+        aupdate_or_create.alters_data = True\n \n         def _get_target_ids(self, target_field_name, objs):\n             \"\"\"\n",
    "variant_8": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex c5d87f647a..294d783bf2 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -63,6 +63,8 @@ and two directions (forward and reverse) for a total of six combinations.\n    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n \"\"\"\n \n+\n+from asgiref.sync import sync_to_async\n from django.core.exceptions import FieldError\n from django.db import (\n     DEFAULT_DB_ALIAS,\n@@ -793,23 +795,23 @@ def create_reverse_many_to_one_manager(superclass, rel):\n \n         create.alters_data = True\n \n-        def get_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n-\n-        get_or_create.alters_data = True\n-\n-        def update_or_create(self, **kwargs):\n-            self._check_fk_val()\n-            kwargs[self.field.name] = self.instance\n-            db = router.db_for_write(self.model, instance=self.instance)\n-            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n-\n-        update_or_create.alters_data = True\n \n-        # remove() and clear() are only provided if the ForeignKey can have a\n+from django.core.exceptions import FieldError\n+from django.db import (\n+    DEFAULT_DB_ALIAS,\n+    connections,\n+    router,\n+    transaction,\n+)\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n+from django.db.models.query import QuerySet\n+from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.utils import AltersData, resolve_callables\n+from django.utils.functional import cached_property\n+from django.db.models import Model\n+from asgiref.sync import sync_to_async\n         # value of null.\n         if rel.field.null:\n \n@@ -1191,18 +1193,6 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         create.alters_data = True\n \n-        def get_or_create(self, *, through_defaults=None, **kwargs):\n-            db = router.db_for_write(self.instance.__class__, instance=self.instance)\n-            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n-                **kwargs\n-            )\n-            # We only need to add() if created because if we got an object back\n-            # from get() then the relationship already exists.\n-            if created:\n-                self.add(obj, through_defaults=through_defaults)\n-            return obj, created\n-\n-        get_or_create.alters_data = True\n \n         def update_or_create(self, *, through_defaults=None, **kwargs):\n             db = router.db_for_write(self.instance.__class__, instance=self.instance)\n@@ -1217,6 +1207,27 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n \n         update_or_create.alters_data = True\n \n+        async def acreate(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        acreate.alters_data = True\n+\n+        async def aget_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.get_or_create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        aget_or_create.alters_data = True\n+\n+        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):\n+            return await sync_to_async(self.update_or_create)(\n+                through_defaults=through_defaults, **kwargs\n+            )\n+\n+        aupdate_or_create.alters_data = True\n+\n         def _get_target_ids(self, target_field_name, objs):\n             \"\"\"\n             Return the set of ids of `objs` that the target field references.\n"
  }
}