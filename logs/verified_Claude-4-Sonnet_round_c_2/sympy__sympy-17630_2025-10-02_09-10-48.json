{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/matrices/expressions/blockmatrix.py lines 154-155)": "\n    @property\n    def colblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[1]):\n            block = self.blocks[0, i]\n            if hasattr(block, 'cols'):\n                sizes.append(block.cols)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same column to get the dimension\n                for j in range(self.blockshape[0]):\n                    alt_block = self.blocks[j, i]\n                    if hasattr(alt_block, 'cols'):\n                        sizes.append(alt_block.cols)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(\"Cannot determine column size for block at position (0, %d)\" % i)\n        return sizes\n",
    "Location 2 (/root/hy/projects/sympy/sympy/matrices/expressions/blockmatrix.py lines 150-151)": "\n    @property\n    def rowblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[0]):\n            block = self.blocks[i, 0]\n            if hasattr(block, 'rows'):\n                sizes.append(block.rows)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same row to get the dimension\n                for j in range(self.blockshape[1]):\n                    alt_block = self.blocks[i, j]\n                    if hasattr(alt_block, 'rows'):\n                        sizes.append(alt_block.rows)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n        return sizes\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/matrices/expressions/blockmatrix.py lines 154-155)": [
      "\n    @property\n    def colblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[1]):\n            block = self.blocks[0, i]\n            if hasattr(block, 'cols'):\n                sizes.append(block.cols)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same column to get the dimension\n                for j in range(self.blockshape[0]):\n                    alt_block = self.blocks[j, i]\n                    if hasattr(alt_block, 'cols'):\n                        sizes.append(alt_block.cols)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n        return sizes\n",
      "\n    @property\n    def colblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[1]):\n            block = self.blocks[0, i]\n            if hasattr(block, 'cols'):\n                sizes.append(block.cols)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same column to get the dimension\n                for j in range(self.blockshape[0]):\n                    alt_block = self.blocks[j, i]\n                    if hasattr(alt_block, 'cols'):\n                        sizes.append(alt_block.cols)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n        return sizes\n",
      "\n@property\ndef colblocksizes(self):\n    sizes = []\n    for i in range(self.blockshape[1]):\n        block = self.blocks[0, i]\n        if hasattr(block, 'cols'):\n            sizes.append(block.cols)\n        else:\n            # Handle Zero objects by inferring dimensions from context\n            # Look for a non-Zero block in the same column to get the dimension\n            for j in range(self.blockshape[0]):\n                alt_block = self.blocks[j, i]\n                if hasattr(alt_block, 'cols'):\n                    sizes.append(alt_block.cols)\n                    break\n            else:\n                # Fallback: assume dimension 1 or raise informative error\n                raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n    return sizes\n",
      "\n    @property\n    def colblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[1]):\n            block = self.blocks[0, i]\n            if hasattr(block, 'cols'):\n                sizes.append(block.cols)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same column to get the dimension\n                for j in range(self.blockshape[0]):\n                    alt_block = self.blocks[j, i]\n                    if hasattr(alt_block, 'cols'):\n                        sizes.append(alt_block.cols)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n        return sizes\n",
      "\n    @property\n    def colblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[1]):\n            block = self.blocks[0, i]\n            if hasattr(block, 'cols'):\n                sizes.append(block.cols)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same column to get the dimension\n                for j in range(self.blockshape[0]):\n                    alt_block = self.blocks[j, i]\n                    if hasattr(alt_block, 'cols'):\n                        sizes.append(alt_block.cols)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n        return sizes\n",
      "\n    @property\n    def colblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[1]):\n            block = self.blocks[0, i]\n            if hasattr(block, 'cols'):\n                sizes.append(block.cols)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same column to get the dimension\n                for j in range(self.blockshape[0]):\n                    alt_block = self.blocks[j, i]\n                    if hasattr(alt_block, 'cols'):\n                        sizes.append(alt_block.cols)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n        return sizes\n",
      "\n@property\ndef colblocksizes(self):\n    sizes = []\n    for i in range(self.blockshape[1]):\n        block = self.blocks[0, i]\n        if hasattr(block, 'cols'):\n            sizes.append(block.cols)\n        else:\n            # Handle Zero objects by inferring dimensions from context\n            # Look for a non-Zero block in the same column to get the dimension\n            for j in range(self.blockshape[0]):\n                alt_block = self.blocks[j, i]\n                if hasattr(alt_block, 'cols'):\n                    sizes.append(alt_block.cols)\n                    break\n            else:\n                # Fallback: assume dimension 1 or raise informative error\n                raise ValueError(\"Cannot determine column size for block at position (0, {})\".format(i))\n    return sizes\n",
      "\n    @property\n    def colblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[1]):\n            block = self.blocks[0, i]\n            if hasattr(block, 'cols'):\n                sizes.append(block.cols)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same column to get the dimension\n                for j in range(self.blockshape[0]):\n                    alt_block = self.blocks[j, i]\n                    if hasattr(alt_block, 'cols'):\n                        sizes.append(alt_block.cols)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n        return sizes\n"
    ],
    "Location 2 (/root/hy/projects/sympy/sympy/matrices/expressions/blockmatrix.py lines 150-151)": [
      "\n    @property\n    def rowblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[0]):\n            block = self.blocks[i, 0]\n            if hasattr(block, 'rows'):\n                sizes.append(block.rows)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same row to get the dimension\n                for j in range(self.blockshape[1]):\n                    alt_block = self.blocks[i, j]\n                    if hasattr(alt_block, 'rows'):\n                        sizes.append(alt_block.rows)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n        return sizes\n",
      "\n    @property\n    def rowblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[0]):\n            block = self.blocks[i, 0]\n            if hasattr(block, 'rows'):\n                sizes.append(block.rows)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same row to get the dimension\n                for j in range(self.blockshape[1]):\n                    alt_block = self.blocks[i, j]\n                    if hasattr(alt_block, 'rows'):\n                        sizes.append(alt_block.rows)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n        return sizes\n",
      "\n    @property\n    def rowblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[0]):\n            block = self.blocks[i, 0]\n            if hasattr(block, 'rows'):\n                sizes.append(block.rows)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same row to get the dimension\n                for j in range(self.blockshape[1]):\n                    alt_block = self.blocks[i, j]\n                    if hasattr(alt_block, 'rows'):\n                        sizes.append(alt_block.rows)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(\"Cannot determine row size for block at position ({}, 0)\".format(i))\n        return sizes\n",
      "\n    @property\n    def rowblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[0]):\n            block = self.blocks[i, 0]\n            if hasattr(block, 'rows'):\n                sizes.append(block.rows)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same row to get the dimension\n                for j in range(self.blockshape[1]):\n                    alt_block = self.blocks[i, j]\n                    if hasattr(alt_block, 'rows'):\n                        sizes.append(alt_block.rows)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n        return sizes\n",
      "\n    @property\n    def rowblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[0]):\n            block = self.blocks[i, 0]\n            if hasattr(block, 'rows'):\n                sizes.append(block.rows)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same row to get the dimension\n                for j in range(self.blockshape[1]):\n                    alt_block = self.blocks[i, j]\n                    if hasattr(alt_block, 'rows'):\n                        sizes.append(alt_block.rows)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n        return sizes\n",
      "\n    @property\n    def rowblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[0]):\n            block = self.blocks[i, 0]\n            if hasattr(block, 'rows'):\n                sizes.append(block.rows)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same row to get the dimension\n                for j in range(self.blockshape[1]):\n                    alt_block = self.blocks[i, j]\n                    if hasattr(alt_block, 'rows'):\n                        sizes.append(alt_block.rows)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n        return sizes\n",
      "\n    @property\n    def rowblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[0]):\n            block = self.blocks[i, 0]\n            if hasattr(block, 'rows'):\n                sizes.append(block.rows)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same row to get the dimension\n                for j in range(self.blockshape[1]):\n                    alt_block = self.blocks[i, j]\n                    if hasattr(alt_block, 'rows'):\n                        sizes.append(alt_block.rows)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n        return sizes\n",
      "\n    @property\n    def rowblocksizes(self):\n        sizes = []\n        for i in range(self.blockshape[0]):\n            block = self.blocks[i, 0]\n            if hasattr(block, 'rows'):\n                sizes.append(block.rows)\n            else:\n                # Handle Zero objects by inferring dimensions from context\n                # Look for a non-Zero block in the same row to get the dimension\n                for j in range(self.blockshape[1]):\n                    alt_block = self.blocks[i, j]\n                    if hasattr(alt_block, 'rows'):\n                        sizes.append(alt_block.rows)\n                        break\n                else:\n                    # Fallback: assume dimension 1 or raise informative error\n                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n        return sizes\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..5aa6af0ca9 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -146,13 +146,49 @@ def blockshape(self):\n     def blocks(self):\n         return self.args[0]\n \n+    @property\n+\n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same row to get the dimension\n+                for j in range(self.blockshape[1]):\n+                    alt_block = self.blocks[i, j]\n+                    if hasattr(alt_block, 'rows'):\n+                        sizes.append(alt_block.rows)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(\"Cannot determine row size for block at position ({}, 0)\".format(i))\n+        return sizes\n+\n+    @property\n \n     @property\n     def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+        sizes = []\n+        for i in range(self.blockshape[1]):\n+            block = self.blocks[0, i]\n+            if hasattr(block, 'cols'):\n+                sizes.append(block.cols)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same column to get the dimension\n+                for j in range(self.blockshape[0]):\n+                    alt_block = self.blocks[j, i]\n+                    if hasattr(alt_block, 'cols'):\n+                        sizes.append(alt_block.cols)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(\"Cannot determine column size for block at position (0, {})\".format(i))\n+        return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n",
    "variant_0": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..9c688556e4 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -146,13 +146,49 @@ def blockshape(self):\n     def blocks(self):\n         return self.args[0]\n \n+    @property\n+\n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same row to get the dimension\n+                for j in range(self.blockshape[1]):\n+                    alt_block = self.blocks[i, j]\n+                    if hasattr(alt_block, 'rows'):\n+                        sizes.append(alt_block.rows)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n+        return sizes\n+\n+    @property\n \n     @property\n     def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+        sizes = []\n+        for i in range(self.blockshape[1]):\n+            block = self.blocks[0, i]\n+            if hasattr(block, 'cols'):\n+                sizes.append(block.cols)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same column to get the dimension\n+                for j in range(self.blockshape[0]):\n+                    alt_block = self.blocks[j, i]\n+                    if hasattr(alt_block, 'cols'):\n+                        sizes.append(alt_block.cols)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(\"Cannot determine column size for block at position (0, %d)\" % i)\n+        return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n",
    "variant_1": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..be8c1611d8 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -146,13 +146,49 @@ def blockshape(self):\n     def blocks(self):\n         return self.args[0]\n \n+    @property\n+\n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same row to get the dimension\n+                for j in range(self.blockshape[1]):\n+                    alt_block = self.blocks[i, j]\n+                    if hasattr(alt_block, 'rows'):\n+                        sizes.append(alt_block.rows)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n+        return sizes\n+\n+    @property\n \n     @property\n     def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+        sizes = []\n+        for i in range(self.blockshape[1]):\n+            block = self.blocks[0, i]\n+            if hasattr(block, 'cols'):\n+                sizes.append(block.cols)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same column to get the dimension\n+                for j in range(self.blockshape[0]):\n+                    alt_block = self.blocks[j, i]\n+                    if hasattr(alt_block, 'cols'):\n+                        sizes.append(alt_block.cols)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n+        return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n",
    "variant_2": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..be8c1611d8 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -146,13 +146,49 @@ def blockshape(self):\n     def blocks(self):\n         return self.args[0]\n \n+    @property\n+\n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same row to get the dimension\n+                for j in range(self.blockshape[1]):\n+                    alt_block = self.blocks[i, j]\n+                    if hasattr(alt_block, 'rows'):\n+                        sizes.append(alt_block.rows)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n+        return sizes\n+\n+    @property\n \n     @property\n     def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+        sizes = []\n+        for i in range(self.blockshape[1]):\n+            block = self.blocks[0, i]\n+            if hasattr(block, 'cols'):\n+                sizes.append(block.cols)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same column to get the dimension\n+                for j in range(self.blockshape[0]):\n+                    alt_block = self.blocks[j, i]\n+                    if hasattr(alt_block, 'cols'):\n+                        sizes.append(alt_block.cols)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n+        return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n",
    "variant_3": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..c0f8f6617c 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -146,13 +146,49 @@ def blockshape(self):\n     def blocks(self):\n         return self.args[0]\n \n+    @property\n+\n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same row to get the dimension\n+                for j in range(self.blockshape[1]):\n+                    alt_block = self.blocks[i, j]\n+                    if hasattr(alt_block, 'rows'):\n+                        sizes.append(alt_block.rows)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(\"Cannot determine row size for block at position ({}, 0)\".format(i))\n+        return sizes\n \n     @property\n-    def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+\n+@property\n+def colblocksizes(self):\n+    sizes = []\n+    for i in range(self.blockshape[1]):\n+        block = self.blocks[0, i]\n+        if hasattr(block, 'cols'):\n+            sizes.append(block.cols)\n+        else:\n+            # Handle Zero objects by inferring dimensions from context\n+            # Look for a non-Zero block in the same column to get the dimension\n+            for j in range(self.blockshape[0]):\n+                alt_block = self.blocks[j, i]\n+                if hasattr(alt_block, 'cols'):\n+                    sizes.append(alt_block.cols)\n+                    break\n+            else:\n+                # Fallback: assume dimension 1 or raise informative error\n+                raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n+    return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n",
    "variant_4": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..be8c1611d8 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -146,13 +146,49 @@ def blockshape(self):\n     def blocks(self):\n         return self.args[0]\n \n+    @property\n+\n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same row to get the dimension\n+                for j in range(self.blockshape[1]):\n+                    alt_block = self.blocks[i, j]\n+                    if hasattr(alt_block, 'rows'):\n+                        sizes.append(alt_block.rows)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n+        return sizes\n+\n+    @property\n \n     @property\n     def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+        sizes = []\n+        for i in range(self.blockshape[1]):\n+            block = self.blocks[0, i]\n+            if hasattr(block, 'cols'):\n+                sizes.append(block.cols)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same column to get the dimension\n+                for j in range(self.blockshape[0]):\n+                    alt_block = self.blocks[j, i]\n+                    if hasattr(alt_block, 'cols'):\n+                        sizes.append(alt_block.cols)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n+        return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n",
    "variant_5": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..be8c1611d8 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -146,13 +146,49 @@ def blockshape(self):\n     def blocks(self):\n         return self.args[0]\n \n+    @property\n+\n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same row to get the dimension\n+                for j in range(self.blockshape[1]):\n+                    alt_block = self.blocks[i, j]\n+                    if hasattr(alt_block, 'rows'):\n+                        sizes.append(alt_block.rows)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n+        return sizes\n+\n+    @property\n \n     @property\n     def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+        sizes = []\n+        for i in range(self.blockshape[1]):\n+            block = self.blocks[0, i]\n+            if hasattr(block, 'cols'):\n+                sizes.append(block.cols)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same column to get the dimension\n+                for j in range(self.blockshape[0]):\n+                    alt_block = self.blocks[j, i]\n+                    if hasattr(alt_block, 'cols'):\n+                        sizes.append(alt_block.cols)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n+        return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n",
    "variant_6": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..be8c1611d8 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -146,13 +146,49 @@ def blockshape(self):\n     def blocks(self):\n         return self.args[0]\n \n+    @property\n+\n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same row to get the dimension\n+                for j in range(self.blockshape[1]):\n+                    alt_block = self.blocks[i, j]\n+                    if hasattr(alt_block, 'rows'):\n+                        sizes.append(alt_block.rows)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n+        return sizes\n+\n+    @property\n \n     @property\n     def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+        sizes = []\n+        for i in range(self.blockshape[1]):\n+            block = self.blocks[0, i]\n+            if hasattr(block, 'cols'):\n+                sizes.append(block.cols)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same column to get the dimension\n+                for j in range(self.blockshape[0]):\n+                    alt_block = self.blocks[j, i]\n+                    if hasattr(alt_block, 'cols'):\n+                        sizes.append(alt_block.cols)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n+        return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n",
    "variant_7": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..9da2107c4a 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -146,13 +146,49 @@ def blockshape(self):\n     def blocks(self):\n         return self.args[0]\n \n+    @property\n+\n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same row to get the dimension\n+                for j in range(self.blockshape[1]):\n+                    alt_block = self.blocks[i, j]\n+                    if hasattr(alt_block, 'rows'):\n+                        sizes.append(alt_block.rows)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n+        return sizes\n \n     @property\n-    def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+\n+@property\n+def colblocksizes(self):\n+    sizes = []\n+    for i in range(self.blockshape[1]):\n+        block = self.blocks[0, i]\n+        if hasattr(block, 'cols'):\n+            sizes.append(block.cols)\n+        else:\n+            # Handle Zero objects by inferring dimensions from context\n+            # Look for a non-Zero block in the same column to get the dimension\n+            for j in range(self.blockshape[0]):\n+                alt_block = self.blocks[j, i]\n+                if hasattr(alt_block, 'cols'):\n+                    sizes.append(alt_block.cols)\n+                    break\n+            else:\n+                # Fallback: assume dimension 1 or raise informative error\n+                raise ValueError(\"Cannot determine column size for block at position (0, {})\".format(i))\n+    return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n",
    "variant_8": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..be8c1611d8 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -146,13 +146,49 @@ def blockshape(self):\n     def blocks(self):\n         return self.args[0]\n \n+    @property\n+\n     @property\n     def rowblocksizes(self):\n-        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]\n+        sizes = []\n+        for i in range(self.blockshape[0]):\n+            block = self.blocks[i, 0]\n+            if hasattr(block, 'rows'):\n+                sizes.append(block.rows)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same row to get the dimension\n+                for j in range(self.blockshape[1]):\n+                    alt_block = self.blocks[i, j]\n+                    if hasattr(alt_block, 'rows'):\n+                        sizes.append(alt_block.rows)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine row size for block at position ({i}, 0)\")\n+        return sizes\n+\n+    @property\n \n     @property\n     def colblocksizes(self):\n-        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]\n+        sizes = []\n+        for i in range(self.blockshape[1]):\n+            block = self.blocks[0, i]\n+            if hasattr(block, 'cols'):\n+                sizes.append(block.cols)\n+            else:\n+                # Handle Zero objects by inferring dimensions from context\n+                # Look for a non-Zero block in the same column to get the dimension\n+                for j in range(self.blockshape[0]):\n+                    alt_block = self.blocks[j, i]\n+                    if hasattr(alt_block, 'cols'):\n+                        sizes.append(alt_block.cols)\n+                        break\n+                else:\n+                    # Fallback: assume dimension 1 or raise informative error\n+                    raise ValueError(f\"Cannot determine column size for block at position (0, {i})\")\n+        return sizes\n \n     def structurally_equal(self, other):\n         return (isinstance(other, BlockMatrix)\n"
  }
}