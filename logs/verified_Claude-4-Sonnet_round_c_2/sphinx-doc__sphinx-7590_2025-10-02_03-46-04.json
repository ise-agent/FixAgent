{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/domains/cpp.py lines 825-839)": "\nclass ASTNumberLiteral(ASTLiteral):\n    def __init__(self, data: str) -> None:\n        self.data = data\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.data\n\n    def get_id(self, version: int) -> str:\n        return \"L%sE\" % self.data\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n\n\nclass ASTUserDefinedLiteral(ASTLiteral):\n    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n        self.literal_value = literal_value\n        self.udl_suffix = udl_suffix\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.literal_value + self.udl_suffix\n\n    def get_id(self, version: int) -> str:\n        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n",
    "Location 2 (/root/hy/projects/sphinx/sphinx/domains/cpp.py lines 4665-4667)": "\n                while self.current_char in 'uUlLfF':\n                    self.pos += 1\n                # Check for user-defined literal suffix after built-in suffixes\n                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                        self.pos += 1\n                    if self.pos > suffix_start:\n                        base_literal = self.definition[pos:suffix_start]\n                        udl_suffix = self.definition[suffix_start:self.pos]\n                        return ASTUserDefinedLiteral(base_literal, udl_suffix)\n                return ASTNumberLiteral(self.definition[pos:self.pos])\n",
    "Location 3 (/root/hy/projects/sphinx/sphinx/domains/cpp.py lines 4685-4685)": "\n        # TODO: user-defined literal suffixes\n        # Check if we're at a user-defined literal suffix\n        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n            # Parse UDL suffix: _identifier or identifier\n            suffix_start = self.pos\n            if self.current_char == '_':\n                self.pos += 1\n                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                    self.pos = suffix_start  # Reset position\n                    return None\n            \n            # Continue parsing identifier characters\n            while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                self.pos += 1\n            \n            if self.pos > suffix_start:\n                # We found a UDL suffix, but we need the base literal\n                # This is a fallback case - normally UDLs should be caught during literal parsing\n                return None\n",
    "Location 4 (/root/hy/projects/sphinx/sphinx/domains/cpp.py lines 4669-4671)": "\n        string = self._parse_string()\n        if string is not None:\n            # Check for UDL suffix after string literal\n            pos = self.pos\n            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                # Parse UDL suffix\n                while (self.current_char and \n                       (self.current_char.isalnum() or self.current_char == '_')):\n                    self.pos += 1\n                if self.pos > pos:  # We found a suffix\n                    udl_suffix = self.definition[pos:self.pos]\n                    return ASTUserDefinedLiteral(string, udl_suffix)\n            return ASTStringLiteral(string)\n",
    "Location 5 (/root/hy/projects/sphinx/sphinx/domains/cpp.py lines 4674-4683)": "\n        # character-literal\n        if self.match(char_literal_re):\n            prefix = self.last_match.group(1)  # may be None when no prefix\n            data = self.last_match.group(2)\n            try:\n                char_literal = ASTCharLiteral(prefix, data)\n                # Check for user-defined literal suffix\n                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                    while self.pos < len(self.definition) and (self.definition[self.pos].isalnum() or self.definition[self.pos] == '_'):\n                        self.pos += 1\n                    if self.pos > suffix_start:\n                        udl_suffix = self.definition[suffix_start:self.pos]\n                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n                return char_literal\n            except UnicodeDecodeError as e:\n                self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n            except UnsupportedMultiCharacterCharLiteral:\n                self.fail(\"Can not handle character literal\"\n                          \" resulting in multiple decoded characters.\")\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/domains/cpp.py lines 825-839)": [
      "\nclass ASTNumberLiteral(ASTLiteral):\n    def __init__(self, data: str) -> None:\n        self.data = data\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.data\n\n    def get_id(self, version: int) -> str:\n        return \"L%sE\" % self.data\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n\n\nclass ASTUserDefinedLiteral(ASTLiteral):\n    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n        self.literal_value = literal_value\n        self.udl_suffix = udl_suffix\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.literal_value + self.udl_suffix\n\n    def get_id(self, version: int) -> str:\n        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n",
      "\nclass ASTNumberLiteral(ASTLiteral):\n    def __init__(self, data: str) -> None:\n        self.data = data\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.data\n\n    def get_id(self, version: int) -> str:\n        return \"L%sE\" % self.data\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n\n\nclass ASTUserDefinedLiteral(ASTLiteral):\n    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n        self.literal_value = literal_value\n        self.udl_suffix = udl_suffix\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.literal_value + self.udl_suffix\n\n    def get_id(self, version: int) -> str:\n        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n",
      "\nclass ASTUserDefinedLiteral(ASTLiteral):\n    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n        self.literal_value = literal_value\n        self.udl_suffix = udl_suffix\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.literal_value + self.udl_suffix\n\n    def get_id(self, version: int) -> str:\n        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n\n\nclass ASTNumberLiteral(ASTLiteral):\n    def __init__(self, data: str) -> None:\n        self.data = data\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.data\n\n    def get_id(self, version: int) -> str:\n        return \"L%sE\" % self.data\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n",
      "\nclass ASTNumberLiteral(ASTLiteral):\n    def __init__(self, data: str) -> None:\n        self.data = data\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.data\n\n    def get_id(self, version: int) -> str:\n        return \"L%sE\" % self.data\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n\n\nclass ASTUserDefinedLiteral(ASTLiteral):\n    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n        self.literal_value = literal_value\n        self.udl_suffix = udl_suffix\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.literal_value + self.udl_suffix\n\n    def get_id(self, version: int) -> str:\n        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n",
      "\nclass ASTNumberLiteral(ASTLiteral):\n    def __init__(self, data: str) -> None:\n        self.data = data\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.data\n\n    def get_id(self, version: int) -> str:\n        return \"L%sE\" % self.data\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n\n\nclass ASTUserDefinedLiteral(ASTLiteral):\n    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n        self.literal_value = literal_value\n        self.udl_suffix = udl_suffix\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.literal_value + self.udl_suffix\n\n    def get_id(self, version: int) -> str:\n        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n",
      "\nclass ASTNumberLiteral(ASTLiteral):\n    def __init__(self, data: str) -> None:\n        self.data = data\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.data\n\n    def get_id(self, version: int) -> str:\n        return \"L%sE\" % self.data\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n\n\nclass ASTUserDefinedLiteral(ASTLiteral):\n    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n        self.literal_value = literal_value\n        self.udl_suffix = udl_suffix\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.literal_value + self.udl_suffix\n\n    def get_id(self, version: int) -> str:\n        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n",
      "\nclass ASTNumberLiteral(ASTLiteral):\n    def __init__(self, data: str) -> None:\n        self.data = data\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.data\n\n    def get_id(self, version: int) -> str:\n        return \"L%sE\" % self.data\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n\n\nclass ASTUserDefinedLiteral(ASTLiteral):\n    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n        self.literal_value = literal_value\n        self.udl_suffix = udl_suffix\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.literal_value + self.udl_suffix\n\n    def get_id(self, version: int) -> str:\n        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n",
      "\nclass ASTUserDefinedLiteral(ASTLiteral):\n    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n        self.literal_value = literal_value\n        self.udl_suffix = udl_suffix\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.literal_value + self.udl_suffix\n\n    def get_id(self, version: int) -> str:\n        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n\n\nclass ASTNumberLiteral(ASTLiteral):\n    def __init__(self, data: str) -> None:\n        self.data = data\n\n    def _stringify(self, transform: StringifyTransform) -> str:\n        return self.data\n\n    def get_id(self, version: int) -> str:\n        return \"L%sE\" % self.data\n\n    def describe_signature(self, signode: TextElement, mode: str,\n                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n        txt = str(self)\n        signode.append(nodes.Text(txt, txt))\n"
    ],
    "Location 2 (/root/hy/projects/sphinx/sphinx/domains/cpp.py lines 4665-4667)": [
      "\n            if self.match(regex):\n                base_literal = self.definition[pos:self.pos]\n                \n                # Check for User Defined Literal suffix\n                suffix_start = self.pos\n                if (self.current_char == '_' or \n                    (self.current_char and self.current_char.isalpha())):\n                    # Parse UDL suffix: _identifier or identifier\n                    if self.current_char == '_':\n                        self.pos += 1\n                        if not (self.current_char and \n                               (self.current_char.isalpha() or self.current_char == '_')):\n                            # Invalid UDL suffix starting with _\n                            self.pos = suffix_start\n                            return ASTNumberLiteral(base_literal)\n                    \n                    # Continue parsing identifier part\n                    while (self.current_char and \n                           (self.current_char.isalnum() or self.current_char == '_')):\n                        self.pos += 1\n                    \n                    udl_suffix = self.definition[suffix_start:self.pos]\n                    return ASTUserDefinedLiteral(base_literal, udl_suffix)\n                \n                # Check for built-in suffixes (uUlLfF)\n                while self.current_char in 'uUlLfF':\n                    self.pos += 1\n                return ASTNumberLiteral(self.definition[pos:self.pos])\n",
      "\n            if self.match(regex):\n                base_literal = self.definition[pos:self.pos]\n                # Check for user-defined literal suffix\n                suffix_start = self.pos\n                if (self.current_char == '_' or \n                    (self.current_char and self.current_char.isalpha())):\n                    # Parse UDL suffix: _identifier or identifier\n                    if self.current_char == '_':\n                        self.pos += 1\n                    while (self.current_char and \n                           (self.current_char.isalnum() or self.current_char == '_')):\n                        self.pos += 1\n                    if self.pos > suffix_start:\n                        udl_suffix = self.definition[suffix_start:self.pos]\n                        return ASTUserDefinedLiteral(base_literal, udl_suffix)\n                \n                # Handle built-in suffixes for regular literals\n                while self.current_char in 'uUlLfF':\n                    self.pos += 1\n                return ASTNumberLiteral(self.definition[pos:self.pos])\n",
      "\n            while self.current_char in 'uUlLfF':\n                self.pos += 1\n            # Check for User Defined Literal suffix after built-in suffixes\n            if (self.current_char == '_' or \n                (self.current_char and self.current_char.isalpha())):\n                udl_start = self.pos\n                if self.current_char == '_':\n                    self.pos += 1\n                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                        self.pos = udl_start  # rollback if invalid UDL\n                        return ASTNumberLiteral(self.definition[pos:self.pos])\n                while (self.current_char and \n                       (self.current_char.isalnum() or self.current_char == '_')):\n                    self.pos += 1\n                if self.pos > udl_start:\n                    base_literal = self.definition[pos:udl_start]\n                    udl_suffix = self.definition[udl_start:self.pos]\n                    return ASTUserDefinedLiteral(base_literal, udl_suffix)\n            return ASTNumberLiteral(self.definition[pos:self.pos])\n",
      "\n                while self.current_char in 'uUlLfF':\n                    self.pos += 1\n                # Check for User Defined Literal suffix after built-in suffixes\n                udl_start = self.pos\n                if (self.current_char == '_' or self.current_char.isalpha()) and self.current_char is not None:\n                    # Parse UDL suffix: starts with _ or letter, followed by alphanumeric/underscore\n                    if self.current_char == '_':\n                        self.pos += 1\n                    while (self.current_char is not None and \n                           (self.current_char.isalnum() or self.current_char == '_')):\n                        self.pos += 1\n                    if self.pos > udl_start:\n                        # Found UDL suffix\n                        base_literal = self.definition[pos:udl_start]\n                        udl_suffix = self.definition[udl_start:self.pos]\n                        return ASTUserDefinedLiteral(base_literal, udl_suffix)\n                return ASTNumberLiteral(self.definition[pos:self.pos])\n",
      "\n            if self.match(regex):\n                # Check if this is a user-defined literal\n                suffix_start = self.pos\n                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                    self.pos += 1\n                \n                if suffix_start < self.pos:\n                    # We have a suffix - check if it's built-in or UDL\n                    suffix = self.definition[suffix_start:self.pos]\n                    if re.match(r'^[uUlLfF]+$', suffix):\n                        # Built-in suffix\n                        return ASTNumberLiteral(self.definition[pos:self.pos])\n                    else:\n                        # User-defined literal suffix\n                        base_literal = self.definition[pos:suffix_start]\n                        return ASTUserDefinedLiteral(base_literal, suffix)\n                else:\n                    # No suffix\n                    return ASTNumberLiteral(self.definition[pos:self.pos])\n",
      "\n                while self.current_char in 'uUlLfF':\n                    self.pos += 1\n                \n                # Check for user-defined literal suffix after built-in suffixes\n                if (self.current_char == '_' or \n                    (self.current_char and self.current_char.isalpha())):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                    while (self.current_char and \n                           (self.current_char.isalnum() or self.current_char == '_')):\n                        self.pos += 1\n                    udl_suffix = self.definition[suffix_start:self.pos]\n                    base_literal = self.definition[pos:suffix_start]\n                    return ASTUserDefinedLiteral(base_literal, udl_suffix)\n                \n                return ASTNumberLiteral(self.definition[pos:self.pos])\n",
      "\n            while self.current_char in 'uUlLfF':\n                self.pos += 1\n            \n            # Check for User Defined Literal suffix after built-in suffixes\n            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                udl_start = self.pos\n                if self.current_char == '_':\n                    self.pos += 1\n                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                        self.pos = udl_start  # Reset if invalid UDL\n                        return ASTNumberLiteral(self.definition[pos:self.pos])\n                \n                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                    self.pos += 1\n                \n                base_literal = self.definition[pos:udl_start]\n                udl_suffix = self.definition[udl_start:self.pos]\n                return ASTUserDefinedLiteral(base_literal, udl_suffix)\n            \n            return ASTNumberLiteral(self.definition[pos:self.pos])\n",
      "\n                while self.current_char in 'uUlLfF':\n                    self.pos += 1\n                # Check for user-defined literal suffix after built-in suffixes\n                if self.current_char == '_' or (self.current_char and self.current_char.isalpha()):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                        if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                            self.pos = suffix_start  # Invalid UDL, backtrack\n                            return ASTNumberLiteral(self.definition[pos:self.pos])\n                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                        self.pos += 1\n                    udl_suffix = self.definition[suffix_start:self.pos]\n                    base_literal = self.definition[pos:suffix_start]\n                    return ASTUserDefinedLiteral(base_literal, udl_suffix)\n                return ASTNumberLiteral(self.definition[pos:self.pos])\n"
    ],
    "Location 3 (/root/hy/projects/sphinx/sphinx/domains/cpp.py lines 4685-4685)": [
      "\n        # TODO: user-defined lit\n        # Check for user-defined literal suffix\n        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n            # Parse UDL suffix: _identifier or identifier\n            start_pos = self.pos\n            if self.current_char == '_':\n                self._advance()\n                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                    self.pos = start_pos\n                    return None\n            \n            # Parse identifier part\n            while (self.current_char and \n                   (self.current_char.isalnum() or self.current_char == '_')):\n                self._advance()\n            \n            udl_suffix = self.definition[start_pos:self.pos]\n            # Return a simple identifier for now - full UDL support needs ASTUserDefinedLiteral\n            return ASTIdentifier(udl_suffix)\n        \n        return None\n",
      "\n        # TODO: user-defined literals\n        # Check if we're at the start of a user-defined literal suffix\n        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n            # Parse UDL suffix: _identifier or identifier\n            suffix_start = self.pos\n            if self.current_char == '_':\n                self._advance()\n                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                    self.pos = suffix_start  # backtrack\n                    return None\n            \n            # Parse the rest of the identifier\n            while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                self._advance()\n            \n            if self.pos > suffix_start:\n                # We found a UDL suffix, but we need the base literal\n                # This is a fallback case - ideally UDLs should be caught during specific literal parsing\n                self.fail(\"User-defined literal suffix found without base literal\")\n        \n        return None\n",
      "\n        # Parse user-defined literals\n        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n            # Parse UDL suffix\n            start_pos = self.pos\n            if self.current_char == '_':\n                self.pos += 1\n                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                    self.pos = start_pos\n                    return None\n            \n            # Parse the rest of the identifier\n            while (self.current_char and \n                   (self.current_char.isalnum() or self.current_char == '_')):\n                self.pos += 1\n            \n            udl_suffix = self.definition[start_pos:self.pos]\n            # For now, create a simple literal representation\n            # This would need the ASTUserDefinedLiteral class from location 1\n            return ASTNumberLiteral(udl_suffix)  # Temporary until ASTUserDefinedLiteral is available\n        \n        return None\n",
      "\n        # User-defined literals\n        # Check if we're at a position where a UDL suffix might follow a literal\n        if self.current_char and (self.current_char.isalpha() or self.current_char == '_'):\n            # Look backwards to see if we just parsed a literal that could have a UDL suffix\n            # This is a fallback for cases where literal parsing didn't handle UDL suffixes\n            start_pos = self.pos\n            if self.current_char == '_':\n                self.pos += 1\n                if not self.current_char or not (self.current_char.isalpha() or self.current_char == '_'):\n                    self.pos = start_pos\n                    return None\n            \n            # Parse UDL suffix: [a-zA-Z_][a-zA-Z0-9_]*\n            while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                self.pos += 1\n            \n            if self.pos > start_pos:\n                # We found a potential UDL suffix, but without the base literal\n                # This shouldn't happen in normal parsing, so reset and return None\n                self.pos = start_pos\n                return None\n        \n        return None\n",
      "\n        # TODO: user-defined literals - check for UDL suffix pattern\n        pos = self.pos\n        if pos < len(self.definition) and (self.definition[pos] == '_' or self.definition[pos].isalpha()):\n            # Parse UDL suffix: _identifier or identifier\n            suffix_start = pos\n            if self.definition[pos] == '_':\n                pos += 1\n            while pos < len(self.definition) and (self.definition[pos].isalnum() or self.definition[pos] == '_'):\n                pos += 1\n            if pos > suffix_start:\n                udl_suffix = self.definition[suffix_start:pos]\n                self.pos = pos\n                # Need to determine what literal this suffix applies to\n                # This is a fallback - most UDLs should be caught by specific literal parsers\n                return ASTUserDefinedLiteral(\"\", udl_suffix)\n",
      "\n        # TODO: user-defined literals\n        # Check if we're at a user-defined literal suffix\n        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n            # Parse UDL suffix: _identifier or identifier\n            suffix_start = self.pos\n            if self.current_char == '_':\n                self.pos += 1\n                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                    self.pos = suffix_start  # Reset if invalid\n                    return None\n            \n            # Continue parsing identifier characters\n            while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                self.pos += 1\n            \n            if self.pos > suffix_start:\n                udl_suffix = self.definition[suffix_start:self.pos]\n                # This is a standalone UDL suffix, which shouldn't happen in valid C++\n                # UDLs should be attached to literals, so this is likely an error\n                self.pos = suffix_start  # Reset position\n                return None\n        \n        return None\n",
      "\n        # TODO: user-defined literal suffix parsing\n        # Check if we're at a user-defined literal suffix\n        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n            # Parse UDL suffix: _identifier or identifier\n            suffix_start = self.pos\n            if self.current_char == '_':\n                self._advance()\n                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                    self.pos = suffix_start  # backtrack\n                    return None\n            \n            # Parse the rest of the identifier\n            while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                self._advance()\n            \n            # If we consumed characters, we have a potential UDL suffix\n            if self.pos > suffix_start:\n                udl_suffix = self.definition[suffix_start:self.pos]\n                # For now, we'll fail with a descriptive message since ASTUserDefinedLiteral doesn't exist yet\n                self.fail(f\"User-defined literal suffix '{udl_suffix}' is not yet supported\")\n        \n        return None\n",
      "\n        # TODO: user-defined literals - check for UDL suffix pattern\n        # UDL suffix must start with underscore or letter, followed by alphanumeric/underscore\n        if (self.current_char and \n            (self.current_char == '_' or self.current_char.isalpha())):\n            # Look ahead to validate UDL suffix pattern\n            pos = self.pos\n            if self.current_char == '_':\n                self.pos += 1\n                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                    self.pos = pos  # Reset if invalid pattern\n                    return None\n            \n            # Consume the UDL suffix\n            suffix_start = self.pos\n            while (self.current_char and \n                   (self.current_char.isalnum() or self.current_char == '_')):\n                self.pos += 1\n            \n            if self.pos > suffix_start:  # We found a valid suffix\n                udl_suffix = self.definition[suffix_start:self.pos]\n                # This is a standalone UDL (shouldn't happen in normal parsing)\n                # but we'll handle it gracefully\n                self.fail(\"Unexpected user-defined literal suffix without base literal\")\n"
    ],
    "Location 4 (/root/hy/projects/sphinx/sphinx/domains/cpp.py lines 4669-4671)": [
      "\n        string = self._parse_string()\n        if string is not None:\n            # Check for user-defined literal suffix after string\n            pos = self.pos\n            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                # Parse UDL suffix: _identifier or identifier\n                if self.current_char == '_':\n                    self.pos += 1\n                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                        self.pos = pos  # Reset if invalid suffix\n                        return ASTStringLiteral(string)\n                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                    self.pos += 1\n                if self.pos > pos:\n                    udl_suffix = self.definition[pos:self.pos]\n                    return ASTUserDefinedLiteral(string, udl_suffix)\n            return ASTStringLiteral(string)\n",
      "\n        string = self._parse_string()\n        if string is not None:\n            # Check for user-defined literal suffix after string literal\n            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                suffix_start = self.pos\n                if self.current_char == '_':\n                    self.pos += 1\n                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                        self.pos = suffix_start  # backtrack\n                        return ASTStringLiteral(string)\n                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                    self.pos += 1\n                if self.pos > suffix_start:\n                    udl_suffix = self.definition[suffix_start:self.pos]\n                    return ASTUserDefinedLiteral(string, udl_suffix)\n            return ASTStringLiteral(string)\n",
      "\n        string = self._parse_string()\n        if string is not None:\n            # Check for UDL suffix after string literal\n            udl_suffix = self._parse_udl_suffix()\n            if udl_suffix is not None:\n                return ASTUserDefinedLiteral(string, udl_suffix)\n            return ASTStringLiteral(string)\n",
      "\n        string = self._parse_string()\n        if string is not None:\n            # Check for user-defined literal suffix after string\n            pos = self.pos\n            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                # Parse UDL suffix: _identifier or identifier\n                suffix_start = self.pos\n                if self.current_char == '_':\n                    self.pos += 1\n                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                        self.pos = pos  # Reset if invalid suffix\n                        return ASTStringLiteral(string)\n                \n                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                    self.pos += 1\n                \n                if self.pos > suffix_start:\n                    udl_suffix = self.definition[suffix_start:self.pos]\n                    return ASTUserDefinedLiteral(string, udl_suffix)\n            \n            return ASTStringLiteral(string)\n",
      "\n        string = self._parse_string()\n        if string is not None:\n            # Check for user-defined literal suffix after string\n            pos = self.pos\n            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                # Parse UDL suffix: _identifier or identifier\n                if self.current_char == '_':\n                    self.pos += 1\n                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                        self.pos = pos  # Reset if invalid suffix\n                        return ASTStringLiteral(string)\n                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                    self.pos += 1\n                if self.pos > pos:\n                    udl_suffix = self.definition[pos:self.pos]\n                    return ASTUserDefinedLiteral(string, udl_suffix)\n            return ASTStringLiteral(string)\n",
      "\n        string = self._parse_string()\n        if string is not None:\n            # Check for user-defined literal suffix\n            pos = self.pos\n            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                # Parse UDL suffix: _identifier or identifier\n                if self.current_char == '_':\n                    self.pos += 1\n                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                        self.pos = pos  # Reset if invalid\n                        return ASTStringLiteral(string)\n                \n                start_suffix = self.pos\n                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                    self.pos += 1\n                \n                if self.pos > start_suffix:  # Valid suffix found\n                    suffix = self.definition[pos:self.pos]\n                    return ASTUserDefinedLiteral(string, suffix)\n                else:\n                    self.pos = pos  # Reset if no valid identifier after _\n            \n            return ASTStringLiteral(string)\n",
      "\n        string = self._parse_string()\n        if string is not None:\n            # Check for user-defined literal suffix after string\n            suffix_start = self.pos\n            if self._parse_udl_suffix():\n                udl_suffix = self.definition[suffix_start:self.pos]\n                return ASTUserDefinedLiteral(string, udl_suffix)\n            return ASTStringLiteral(string)\n",
      "\n        string = self._parse_string()\n        if string is not None:\n            # Check for user-defined literal suffix after string\n            if self.current_char and (self.current_char.isalpha() or self.current_char == '_'):\n                suffix_start = self.pos\n                if self.current_char == '_':\n                    self.pos += 1\n                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                        self.pos = suffix_start  # Invalid UDL suffix, backtrack\n                        return ASTStringLiteral(string)\n                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                    self.pos += 1\n                if self.pos > suffix_start:\n                    udl_suffix = self.definition[suffix_start:self.pos]\n                    return ASTUserDefinedLiteral(string, udl_suffix)\n            return ASTStringLiteral(string)\n"
    ],
    "Location 5 (/root/hy/projects/sphinx/sphinx/domains/cpp.py lines 4674-4683)": [
      "\n        # character-literal\n        if self.match(char_literal_re):\n            prefix = self.last_match.group(1)  # may be None when no prefix\n            data = self.last_match.group(2)\n            try:\n                char_literal = ASTCharLiteral(prefix, data)\n                # Check for user-defined literal suffix after character literal\n                pos = self.pos\n                if self.pos < len(self.definition) and (self.definition[self.pos] == '_' or self.definition[self.pos].isalpha()):\n                    # Parse UDL suffix: _identifier or identifier\n                    if self.definition[self.pos] == '_':\n                        self.pos += 1\n                        if self.pos >= len(self.definition) or not (self.definition[self.pos].isalpha() or self.definition[self.pos] == '_'):\n                            self.pos = pos  # Reset if invalid\n                        else:\n                            while self.pos < len(self.definition) and (self.definition[self.pos].isalnum() or self.definition[self.pos] == '_'):\n                                self.pos += 1\n                            udl_suffix = self.definition[pos:self.pos]\n                            return ASTUserDefinedLiteral(char_literal, udl_suffix)\n                    elif self.definition[self.pos].isalpha():\n                        start_pos = self.pos\n                        while self.pos < len(self.definition) and (self.definition[self.pos].isalnum() or self.definition[self.pos] == '_'):\n                            self.pos += 1\n                        udl_suffix = self.definition[start_pos:self.pos]\n                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n                return char_literal\n            except UnicodeDecodeError as e:\n                self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n            except UnsupportedMultiCharacterCharLiteral:\n                self.fail(\"Can not handle character literal\"\n                          \" resulting in multiple decoded characters.\")\n",
      "\n        # character-literal\n        if self.match(char_literal_re):\n            prefix = self.last_match.group(1)  # may be None when no prefix\n            data = self.last_match.group(2)\n            try:\n                char_literal = ASTCharLiteral(prefix, data)\n                # Check for user-defined literal suffix\n                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                    while self.pos < len(self.definition) and (self.definition[self.pos].isalnum() or self.definition[self.pos] == '_'):\n                        self.pos += 1\n                    if self.pos > suffix_start:\n                        udl_suffix = self.definition[suffix_start:self.pos]\n                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n                return char_literal\n            except UnicodeDecodeError as e:\n                self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n            except UnsupportedMultiCharacterCharLiteral:\n                self.fail(\"Can not handle character literal\"\n                          \" resulting in multiple decoded characters.\")\n",
      "\n        # character-literal\n        if self.match(char_literal_re):\n            prefix = self.last_match.group(1)  # may be None when no prefix\n            data = self.last_match.group(2)\n            try:\n                char_literal = ASTCharLiteral(prefix, data)\n                # Check for user-defined literal suffix\n                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                        if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                            self.pos = suffix_start  # Reset if invalid UDL suffix\n                            return char_literal\n                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                        self.pos += 1\n                    if self.pos > suffix_start:\n                        udl_suffix = self.definition[suffix_start:self.pos]\n                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n                return char_literal\n            except UnicodeDecodeError as e:\n                self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n            except UnsupportedMultiCharacterCharLiteral:\n                self.fail(\"Can not handle character literal\"\n                          \" resulting in multiple decoded characters.\")\n",
      "\n        # character-literal\n        if self.match(char_literal_re):\n            prefix = self.last_match.group(1)  # may be None when no prefix\n            data = self.last_match.group(2)\n            try:\n                char_literal = ASTCharLiteral(prefix, data)\n                # Check for user-defined literal suffix after character literal\n                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                    while self.pos < len(self.definition) and (self.definition[self.pos].isalnum() or self.definition[self.pos] == '_'):\n                        self.pos += 1\n                    if self.pos > suffix_start:\n                        udl_suffix = self.definition[suffix_start:self.pos]\n                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n                return char_literal\n            except UnicodeDecodeError as e:\n                self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n            except UnsupportedMultiCharacterCharLiteral:\n                self.fail(\"Can not handle character literal\"\n                          \" resulting in multiple decoded characters.\")\n",
      "\n        # character-literal\n        if self.match(char_literal_re):\n            prefix = self.last_match.group(1)  # may be None when no prefix\n            data = self.last_match.group(2)\n            try:\n                char_literal = ASTCharLiteral(prefix, data)\n                # Check for user-defined literal suffix after character literal\n                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                        if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                            self.pos = suffix_start  # backtrack\n                            return char_literal\n                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                        self.pos += 1\n                    udl_suffix = self.definition[suffix_start:self.pos]\n                    return ASTUserDefinedLiteral(char_literal, udl_suffix)\n                return char_literal\n            except UnicodeDecodeError as e:\n                self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n            except UnsupportedMultiCharacterCharLiteral:\n                self.fail(\"Can not handle character literal\"\n                          \" resulting in multiple decoded characters.\")\n",
      "\n        # character-literal\n        if self.match(char_literal_re):\n            prefix = self.last_match.group(1)  # may be None when no prefix\n            data = self.last_match.group(2)\n            try:\n                char_literal = ASTCharLiteral(prefix, data)\n                # Check for user-defined literal suffix\n                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                    while self.pos < self.end and (self.current_char.isalnum() or self.current_char == '_'):\n                        self.pos += 1\n                    if self.pos > suffix_start:\n                        udl_suffix = self.definition[suffix_start:self.pos]\n                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n                return char_literal\n            except UnicodeDecodeError as e:\n                self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n            except UnsupportedMultiCharacterCharLiteral:\n                self.fail(\"Can not handle character literal\"\n                          \" resulting in multiple decoded characters.\")\n",
      "\n        # character-literal\n        if self.match(char_literal_re):\n            prefix = self.last_match.group(1)  # may be None when no prefix\n            data = self.last_match.group(2)\n            try:\n                char_literal = ASTCharLiteral(prefix, data)\n                # Check for user-defined literal suffix after character literal\n                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                        if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                            self.pos = suffix_start  # Reset if invalid UDL suffix\n                            return char_literal\n                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                        self.pos += 1\n                    if self.pos > suffix_start:\n                        udl_suffix = self.definition[suffix_start:self.pos]\n                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n                return char_literal\n            except UnicodeDecodeError as e:\n                self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n            except UnsupportedMultiCharacterCharLiteral:\n                self.fail(\"Can not handle character literal\"\n                          \" resulting in multiple decoded characters.\")\n",
      "\n        # character-literal\n        if self.match(char_literal_re):\n            prefix = self.last_match.group(1)  # may be None when no prefix\n            data = self.last_match.group(2)\n            try:\n                char_literal = ASTCharLiteral(prefix, data)\n                # Check for user-defined literal suffix after character literal\n                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n                    suffix_start = self.pos\n                    if self.current_char == '_':\n                        self.pos += 1\n                        if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n                            self.pos = suffix_start  # Reset if invalid UDL suffix\n                            return char_literal\n                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                        self.pos += 1\n                    if self.pos > suffix_start:\n                        udl_suffix = self.definition[suffix_start:self.pos]\n                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n                return char_literal\n            except UnicodeDecodeError as e:\n                self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n            except UnsupportedMultiCharacterCharLiteral:\n                self.fail(\"Can not handle character literal\"\n                          \" resulting in multiple decoded characters.\")\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..dbed2ef82 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -822,6 +822,7 @@ class ASTBooleanLiteral(ASTLiteral):\n         signode.append(nodes.Text(str(self)))\n \n \n+\n class ASTNumberLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -838,6 +839,24 @@ class ASTNumberLiteral(ASTLiteral):\n         signode.append(nodes.Text(txt, txt))\n \n \n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n+        self.literal_value = literal_value\n+        self.udl_suffix = udl_suffix\n+\n+    def _stringify(self, transform: StringifyTransform) -> str:\n+        return self.literal_value + self.udl_suffix\n+\n+    def get_id(self, version: int) -> str:\n+        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n+\n+    def describe_signature(self, signode: TextElement, mode: str,\n+                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n+        txt = str(self)\n+        signode.append(nodes.Text(txt, txt))\n+\n+\n+\n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -4662,27 +4681,56 @@ class DefinitionParser(BaseParser):\n                       integer_literal_re, octal_literal_re]:\n             pos = self.pos\n             if self.match(regex):\n+\n+                # Check for UDL suffix first\n+                suffix_start = self.pos\n+                udl_suffix = self._parse_udl_suffix()\n+                if udl_suffix:\n+                    base_literal = self.definition[pos:suffix_start]\n+                    return ASTUserDefinedLiteral(base_literal, udl_suffix)\n+                \n+                # Handle built-in suffixes\n                 while self.current_char in 'uUlLfF':\n                     self.pos += 1\n                 return ASTNumberLiteral(self.definition[pos:self.pos])\n \n+\n         string = self._parse_string()\n         if string is not None:\n+            # Check for UDL suffix after string literal\n+            udl_suffix = self._parse_udl_suffix()\n+            if udl_suffix:\n+                return ASTUserDefinedLiteral(string, udl_suffix)\n             return ASTStringLiteral(string)\n \n         # character-literal\n+\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n             try:\n-                return ASTCharLiteral(prefix, data)\n+                char_literal = ASTCharLiteral(prefix, data)\n+                # Check for UDL suffix after character literal\n+                udl_suffix = self._parse_udl_suffix()\n+                if udl_suffix:\n+                    # Convert char literal to string representation for UDL\n+                    char_str = str(char_literal)\n+                    return ASTUserDefinedLiteral(char_str, udl_suffix)\n+                return char_literal\n             except UnicodeDecodeError as e:\n                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n             except UnsupportedMultiCharacterCharLiteral:\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+\n+        # user-defined literal\n+        udl_suffix = self._parse_udl_suffix()\n+        if udl_suffix:\n+            # This shouldn't happen if UDL parsing is properly handled above\n+            # but kept as fallback\n+            return None\n+        return None\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n",
    "variant_0": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..8d6fc661d 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -822,6 +822,7 @@ class ASTBooleanLiteral(ASTLiteral):\n         signode.append(nodes.Text(str(self)))\n \n \n+\n class ASTNumberLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -838,6 +839,22 @@ class ASTNumberLiteral(ASTLiteral):\n         signode.append(nodes.Text(txt, txt))\n \n \n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n+        self.literal_value = literal_value\n+        self.udl_suffix = udl_suffix\n+\n+    def _stringify(self, transform: StringifyTransform) -> str:\n+        return self.literal_value + self.udl_suffix\n+\n+    def get_id(self, version: int) -> str:\n+        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n+\n+    def describe_signature(self, signode: TextElement, mode: str,\n+                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n+        txt = str(self)\n+        signode.append(nodes.Text(txt, txt))\n+\n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -4662,27 +4679,82 @@ class DefinitionParser(BaseParser):\n                       integer_literal_re, octal_literal_re]:\n             pos = self.pos\n             if self.match(regex):\n+\n                 while self.current_char in 'uUlLfF':\n                     self.pos += 1\n+                # Check for user-defined literal suffix after built-in suffixes\n+                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                        self.pos += 1\n+                    if self.pos > suffix_start:\n+                        base_literal = self.definition[pos:suffix_start]\n+                        udl_suffix = self.definition[suffix_start:self.pos]\n+                        return ASTUserDefinedLiteral(base_literal, udl_suffix)\n                 return ASTNumberLiteral(self.definition[pos:self.pos])\n \n+\n         string = self._parse_string()\n         if string is not None:\n+            # Check for UDL suffix after string literal\n+            pos = self.pos\n+            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                # Parse UDL suffix\n+                while (self.current_char and \n+                       (self.current_char.isalnum() or self.current_char == '_')):\n+                    self.pos += 1\n+                if self.pos > pos:  # We found a suffix\n+                    udl_suffix = self.definition[pos:self.pos]\n+                    return ASTUserDefinedLiteral(string, udl_suffix)\n             return ASTStringLiteral(string)\n \n+        # character-literal\n+\n         # character-literal\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n             try:\n-                return ASTCharLiteral(prefix, data)\n+                char_literal = ASTCharLiteral(prefix, data)\n+                # Check for user-defined literal suffix\n+                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                    while self.pos < len(self.definition) and (self.definition[self.pos].isalnum() or self.definition[self.pos] == '_'):\n+                        self.pos += 1\n+                    if self.pos > suffix_start:\n+                        udl_suffix = self.definition[suffix_start:self.pos]\n+                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n+                return char_literal\n             except UnicodeDecodeError as e:\n                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n             except UnsupportedMultiCharacterCharLiteral:\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+\n+        # TODO: user-defined literal suffixes\n+        # Check if we're at a user-defined literal suffix\n+        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+            # Parse UDL suffix: _identifier or identifier\n+            suffix_start = self.pos\n+            if self.current_char == '_':\n+                self.pos += 1\n+                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                    self.pos = suffix_start  # Reset position\n+                    return None\n+            \n+            # Continue parsing identifier characters\n+            while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                self.pos += 1\n+            \n+            if self.pos > suffix_start:\n+                # We found a UDL suffix, but we need the base literal\n+                # This is a fallback case - normally UDLs should be caught during literal parsing\n+                return None\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n",
    "variant_1": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..369565383 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -822,6 +822,7 @@ class ASTBooleanLiteral(ASTLiteral):\n         signode.append(nodes.Text(str(self)))\n \n \n+\n class ASTNumberLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -838,6 +839,22 @@ class ASTNumberLiteral(ASTLiteral):\n         signode.append(nodes.Text(txt, txt))\n \n \n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n+        self.literal_value = literal_value\n+        self.udl_suffix = udl_suffix\n+\n+    def _stringify(self, transform: StringifyTransform) -> str:\n+        return self.literal_value + self.udl_suffix\n+\n+    def get_id(self, version: int) -> str:\n+        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n+\n+    def describe_signature(self, signode: TextElement, mode: str,\n+                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n+        txt = str(self)\n+        signode.append(nodes.Text(txt, txt))\n+\n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -4662,27 +4679,111 @@ class DefinitionParser(BaseParser):\n                       integer_literal_re, octal_literal_re]:\n             pos = self.pos\n             if self.match(regex):\n+\n+            if self.match(regex):\n+                base_literal = self.definition[pos:self.pos]\n+                \n+                # Check for User Defined Literal suffix\n+                suffix_start = self.pos\n+                if (self.current_char == '_' or \n+                    (self.current_char and self.current_char.isalpha())):\n+                    # Parse UDL suffix: _identifier or identifier\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                        if not (self.current_char and \n+                               (self.current_char.isalpha() or self.current_char == '_')):\n+                            # Invalid UDL suffix starting with _\n+                            self.pos = suffix_start\n+                            return ASTNumberLiteral(base_literal)\n+                    \n+                    # Continue parsing identifier part\n+                    while (self.current_char and \n+                           (self.current_char.isalnum() or self.current_char == '_')):\n+                        self.pos += 1\n+                    \n+                    udl_suffix = self.definition[suffix_start:self.pos]\n+                    return ASTUserDefinedLiteral(base_literal, udl_suffix)\n+                \n+                # Check for built-in suffixes (uUlLfF)\n                 while self.current_char in 'uUlLfF':\n                     self.pos += 1\n                 return ASTNumberLiteral(self.definition[pos:self.pos])\n \n+\n         string = self._parse_string()\n         if string is not None:\n+            # Check for user-defined literal suffix after string\n+            pos = self.pos\n+            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                # Parse UDL suffix: _identifier or identifier\n+                if self.current_char == '_':\n+                    self.pos += 1\n+                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                        self.pos = pos  # Reset if invalid suffix\n+                        return ASTStringLiteral(string)\n+                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                    self.pos += 1\n+                if self.pos > pos:\n+                    udl_suffix = self.definition[pos:self.pos]\n+                    return ASTUserDefinedLiteral(string, udl_suffix)\n             return ASTStringLiteral(string)\n \n+        # character-literal\n+\n         # character-literal\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n             try:\n-                return ASTCharLiteral(prefix, data)\n+                char_literal = ASTCharLiteral(prefix, data)\n+                # Check for user-defined literal suffix after character literal\n+                pos = self.pos\n+                if self.pos < len(self.definition) and (self.definition[self.pos] == '_' or self.definition[self.pos].isalpha()):\n+                    # Parse UDL suffix: _identifier or identifier\n+                    if self.definition[self.pos] == '_':\n+                        self.pos += 1\n+                        if self.pos >= len(self.definition) or not (self.definition[self.pos].isalpha() or self.definition[self.pos] == '_'):\n+                            self.pos = pos  # Reset if invalid\n+                        else:\n+                            while self.pos < len(self.definition) and (self.definition[self.pos].isalnum() or self.definition[self.pos] == '_'):\n+                                self.pos += 1\n+                            udl_suffix = self.definition[pos:self.pos]\n+                            return ASTUserDefinedLiteral(char_literal, udl_suffix)\n+                    elif self.definition[self.pos].isalpha():\n+                        start_pos = self.pos\n+                        while self.pos < len(self.definition) and (self.definition[self.pos].isalnum() or self.definition[self.pos] == '_'):\n+                            self.pos += 1\n+                        udl_suffix = self.definition[start_pos:self.pos]\n+                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n+                return char_literal\n             except UnicodeDecodeError as e:\n                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n             except UnsupportedMultiCharacterCharLiteral:\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n+\n         # TODO: user-defined lit\n+        # Check for user-defined literal suffix\n+        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+            # Parse UDL suffix: _identifier or identifier\n+            start_pos = self.pos\n+            if self.current_char == '_':\n+                self._advance()\n+                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                    self.pos = start_pos\n+                    return None\n+            \n+            # Parse identifier part\n+            while (self.current_char and \n+                   (self.current_char.isalnum() or self.current_char == '_')):\n+                self._advance()\n+            \n+            udl_suffix = self.definition[start_pos:self.pos]\n+            # Return a simple identifier for now - full UDL support needs ASTUserDefinedLiteral\n+            return ASTIdentifier(udl_suffix)\n+        \n+        return None\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n",
    "variant_2": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..db4a06537 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -822,6 +822,7 @@ class ASTBooleanLiteral(ASTLiteral):\n         signode.append(nodes.Text(str(self)))\n \n \n+\n class ASTNumberLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -838,6 +839,22 @@ class ASTNumberLiteral(ASTLiteral):\n         signode.append(nodes.Text(txt, txt))\n \n \n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n+        self.literal_value = literal_value\n+        self.udl_suffix = udl_suffix\n+\n+    def _stringify(self, transform: StringifyTransform) -> str:\n+        return self.literal_value + self.udl_suffix\n+\n+    def get_id(self, version: int) -> str:\n+        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n+\n+    def describe_signature(self, signode: TextElement, mode: str,\n+                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n+        txt = str(self)\n+        signode.append(nodes.Text(txt, txt))\n+\n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -4662,27 +4679,93 @@ class DefinitionParser(BaseParser):\n                       integer_literal_re, octal_literal_re]:\n             pos = self.pos\n             if self.match(regex):\n+\n+            if self.match(regex):\n+                base_literal = self.definition[pos:self.pos]\n+                # Check for user-defined literal suffix\n+                suffix_start = self.pos\n+                if (self.current_char == '_' or \n+                    (self.current_char and self.current_char.isalpha())):\n+                    # Parse UDL suffix: _identifier or identifier\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                    while (self.current_char and \n+                           (self.current_char.isalnum() or self.current_char == '_')):\n+                        self.pos += 1\n+                    if self.pos > suffix_start:\n+                        udl_suffix = self.definition[suffix_start:self.pos]\n+                        return ASTUserDefinedLiteral(base_literal, udl_suffix)\n+                \n+                # Handle built-in suffixes for regular literals\n                 while self.current_char in 'uUlLfF':\n                     self.pos += 1\n                 return ASTNumberLiteral(self.definition[pos:self.pos])\n \n+\n         string = self._parse_string()\n         if string is not None:\n+            # Check for user-defined literal suffix after string literal\n+            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                suffix_start = self.pos\n+                if self.current_char == '_':\n+                    self.pos += 1\n+                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                        self.pos = suffix_start  # backtrack\n+                        return ASTStringLiteral(string)\n+                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                    self.pos += 1\n+                if self.pos > suffix_start:\n+                    udl_suffix = self.definition[suffix_start:self.pos]\n+                    return ASTUserDefinedLiteral(string, udl_suffix)\n             return ASTStringLiteral(string)\n \n+        # character-literal\n+\n         # character-literal\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n             try:\n-                return ASTCharLiteral(prefix, data)\n+                char_literal = ASTCharLiteral(prefix, data)\n+                # Check for user-defined literal suffix\n+                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                    while self.pos < len(self.definition) and (self.definition[self.pos].isalnum() or self.definition[self.pos] == '_'):\n+                        self.pos += 1\n+                    if self.pos > suffix_start:\n+                        udl_suffix = self.definition[suffix_start:self.pos]\n+                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n+                return char_literal\n             except UnicodeDecodeError as e:\n                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n             except UnsupportedMultiCharacterCharLiteral:\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+\n+        # TODO: user-defined literals\n+        # Check if we're at the start of a user-defined literal suffix\n+        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+            # Parse UDL suffix: _identifier or identifier\n+            suffix_start = self.pos\n+            if self.current_char == '_':\n+                self._advance()\n+                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                    self.pos = suffix_start  # backtrack\n+                    return None\n+            \n+            # Parse the rest of the identifier\n+            while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                self._advance()\n+            \n+            if self.pos > suffix_start:\n+                # We found a UDL suffix, but we need the base literal\n+                # This is a fallback case - ideally UDLs should be caught during specific literal parsing\n+                self.fail(\"User-defined literal suffix found without base literal\")\n+        \n+        return None\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n",
    "variant_3": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..c902a2871 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -822,6 +822,24 @@ class ASTBooleanLiteral(ASTLiteral):\n         signode.append(nodes.Text(str(self)))\n \n \n+\n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n+        self.literal_value = literal_value\n+        self.udl_suffix = udl_suffix\n+\n+    def _stringify(self, transform: StringifyTransform) -> str:\n+        return self.literal_value + self.udl_suffix\n+\n+    def get_id(self, version: int) -> str:\n+        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n+\n+    def describe_signature(self, signode: TextElement, mode: str,\n+                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n+        txt = str(self)\n+        signode.append(nodes.Text(txt, txt))\n+\n+\n class ASTNumberLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -837,7 +855,6 @@ class ASTNumberLiteral(ASTLiteral):\n         txt = str(self)\n         signode.append(nodes.Text(txt, txt))\n \n-\n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -4662,27 +4679,86 @@ class DefinitionParser(BaseParser):\n                       integer_literal_re, octal_literal_re]:\n             pos = self.pos\n             if self.match(regex):\n-                while self.current_char in 'uUlLfF':\n+\n+            while self.current_char in 'uUlLfF':\n+                self.pos += 1\n+            # Check for User Defined Literal suffix after built-in suffixes\n+            if (self.current_char == '_' or \n+                (self.current_char and self.current_char.isalpha())):\n+                udl_start = self.pos\n+                if self.current_char == '_':\n                     self.pos += 1\n-                return ASTNumberLiteral(self.definition[pos:self.pos])\n+                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                        self.pos = udl_start  # rollback if invalid UDL\n+                        return ASTNumberLiteral(self.definition[pos:self.pos])\n+                while (self.current_char and \n+                       (self.current_char.isalnum() or self.current_char == '_')):\n+                    self.pos += 1\n+                if self.pos > udl_start:\n+                    base_literal = self.definition[pos:udl_start]\n+                    udl_suffix = self.definition[udl_start:self.pos]\n+                    return ASTUserDefinedLiteral(base_literal, udl_suffix)\n+            return ASTNumberLiteral(self.definition[pos:self.pos])\n+\n \n         string = self._parse_string()\n         if string is not None:\n+            # Check for UDL suffix after string literal\n+            udl_suffix = self._parse_udl_suffix()\n+            if udl_suffix is not None:\n+                return ASTUserDefinedLiteral(string, udl_suffix)\n             return ASTStringLiteral(string)\n \n+        # character-literal\n+\n         # character-literal\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n             try:\n-                return ASTCharLiteral(prefix, data)\n+                char_literal = ASTCharLiteral(prefix, data)\n+                # Check for user-defined literal suffix\n+                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                        if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                            self.pos = suffix_start  # Reset if invalid UDL suffix\n+                            return char_literal\n+                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                        self.pos += 1\n+                    if self.pos > suffix_start:\n+                        udl_suffix = self.definition[suffix_start:self.pos]\n+                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n+                return char_literal\n             except UnicodeDecodeError as e:\n                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n             except UnsupportedMultiCharacterCharLiteral:\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+\n+        # Parse user-defined literals\n+        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+            # Parse UDL suffix\n+            start_pos = self.pos\n+            if self.current_char == '_':\n+                self.pos += 1\n+                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                    self.pos = start_pos\n+                    return None\n+            \n+            # Parse the rest of the identifier\n+            while (self.current_char and \n+                   (self.current_char.isalnum() or self.current_char == '_')):\n+                self.pos += 1\n+            \n+            udl_suffix = self.definition[start_pos:self.pos]\n+            # For now, create a simple literal representation\n+            # This would need the ASTUserDefinedLiteral class from location 1\n+            return ASTNumberLiteral(udl_suffix)  # Temporary until ASTUserDefinedLiteral is available\n+        \n+        return None\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n",
    "variant_4": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..e4c40ff47 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -822,6 +822,7 @@ class ASTBooleanLiteral(ASTLiteral):\n         signode.append(nodes.Text(str(self)))\n \n \n+\n class ASTNumberLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -838,6 +839,22 @@ class ASTNumberLiteral(ASTLiteral):\n         signode.append(nodes.Text(txt, txt))\n \n \n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n+        self.literal_value = literal_value\n+        self.udl_suffix = udl_suffix\n+\n+    def _stringify(self, transform: StringifyTransform) -> str:\n+        return self.literal_value + self.udl_suffix\n+\n+    def get_id(self, version: int) -> str:\n+        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n+\n+    def describe_signature(self, signode: TextElement, mode: str,\n+                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n+        txt = str(self)\n+        signode.append(nodes.Text(txt, txt))\n+\n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -4662,27 +4679,97 @@ class DefinitionParser(BaseParser):\n                       integer_literal_re, octal_literal_re]:\n             pos = self.pos\n             if self.match(regex):\n+\n                 while self.current_char in 'uUlLfF':\n                     self.pos += 1\n+                # Check for User Defined Literal suffix after built-in suffixes\n+                udl_start = self.pos\n+                if (self.current_char == '_' or self.current_char.isalpha()) and self.current_char is not None:\n+                    # Parse UDL suffix: starts with _ or letter, followed by alphanumeric/underscore\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                    while (self.current_char is not None and \n+                           (self.current_char.isalnum() or self.current_char == '_')):\n+                        self.pos += 1\n+                    if self.pos > udl_start:\n+                        # Found UDL suffix\n+                        base_literal = self.definition[pos:udl_start]\n+                        udl_suffix = self.definition[udl_start:self.pos]\n+                        return ASTUserDefinedLiteral(base_literal, udl_suffix)\n                 return ASTNumberLiteral(self.definition[pos:self.pos])\n \n+\n         string = self._parse_string()\n         if string is not None:\n+            # Check for user-defined literal suffix after string\n+            pos = self.pos\n+            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                # Parse UDL suffix: _identifier or identifier\n+                suffix_start = self.pos\n+                if self.current_char == '_':\n+                    self.pos += 1\n+                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                        self.pos = pos  # Reset if invalid suffix\n+                        return ASTStringLiteral(string)\n+                \n+                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                    self.pos += 1\n+                \n+                if self.pos > suffix_start:\n+                    udl_suffix = self.definition[suffix_start:self.pos]\n+                    return ASTUserDefinedLiteral(string, udl_suffix)\n+            \n             return ASTStringLiteral(string)\n \n+        # character-literal\n+\n         # character-literal\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n             try:\n-                return ASTCharLiteral(prefix, data)\n+                char_literal = ASTCharLiteral(prefix, data)\n+                # Check for user-defined literal suffix after character literal\n+                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                    while self.pos < len(self.definition) and (self.definition[self.pos].isalnum() or self.definition[self.pos] == '_'):\n+                        self.pos += 1\n+                    if self.pos > suffix_start:\n+                        udl_suffix = self.definition[suffix_start:self.pos]\n+                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n+                return char_literal\n             except UnicodeDecodeError as e:\n                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n             except UnsupportedMultiCharacterCharLiteral:\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+\n+        # User-defined literals\n+        # Check if we're at a position where a UDL suffix might follow a literal\n+        if self.current_char and (self.current_char.isalpha() or self.current_char == '_'):\n+            # Look backwards to see if we just parsed a literal that could have a UDL suffix\n+            # This is a fallback for cases where literal parsing didn't handle UDL suffixes\n+            start_pos = self.pos\n+            if self.current_char == '_':\n+                self.pos += 1\n+                if not self.current_char or not (self.current_char.isalpha() or self.current_char == '_'):\n+                    self.pos = start_pos\n+                    return None\n+            \n+            # Parse UDL suffix: [a-zA-Z_][a-zA-Z0-9_]*\n+            while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                self.pos += 1\n+            \n+            if self.pos > start_pos:\n+                # We found a potential UDL suffix, but without the base literal\n+                # This shouldn't happen in normal parsing, so reset and return None\n+                self.pos = start_pos\n+                return None\n+        \n+        return None\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n",
    "variant_5": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..db7ab5981 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -822,6 +822,7 @@ class ASTBooleanLiteral(ASTLiteral):\n         signode.append(nodes.Text(str(self)))\n \n \n+\n class ASTNumberLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -838,6 +839,22 @@ class ASTNumberLiteral(ASTLiteral):\n         signode.append(nodes.Text(txt, txt))\n \n \n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n+        self.literal_value = literal_value\n+        self.udl_suffix = udl_suffix\n+\n+    def _stringify(self, transform: StringifyTransform) -> str:\n+        return self.literal_value + self.udl_suffix\n+\n+    def get_id(self, version: int) -> str:\n+        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n+\n+    def describe_signature(self, signode: TextElement, mode: str,\n+                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n+        txt = str(self)\n+        signode.append(nodes.Text(txt, txt))\n+\n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -4662,27 +4679,89 @@ class DefinitionParser(BaseParser):\n                       integer_literal_re, octal_literal_re]:\n             pos = self.pos\n             if self.match(regex):\n-                while self.current_char in 'uUlLfF':\n+\n+            if self.match(regex):\n+                # Check if this is a user-defined literal\n+                suffix_start = self.pos\n+                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n                     self.pos += 1\n-                return ASTNumberLiteral(self.definition[pos:self.pos])\n+                \n+                if suffix_start < self.pos:\n+                    # We have a suffix - check if it's built-in or UDL\n+                    suffix = self.definition[suffix_start:self.pos]\n+                    if re.match(r'^[uUlLfF]+$', suffix):\n+                        # Built-in suffix\n+                        return ASTNumberLiteral(self.definition[pos:self.pos])\n+                    else:\n+                        # User-defined literal suffix\n+                        base_literal = self.definition[pos:suffix_start]\n+                        return ASTUserDefinedLiteral(base_literal, suffix)\n+                else:\n+                    # No suffix\n+                    return ASTNumberLiteral(self.definition[pos:self.pos])\n+\n \n         string = self._parse_string()\n         if string is not None:\n+            # Check for user-defined literal suffix after string\n+            pos = self.pos\n+            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                # Parse UDL suffix: _identifier or identifier\n+                if self.current_char == '_':\n+                    self.pos += 1\n+                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                        self.pos = pos  # Reset if invalid suffix\n+                        return ASTStringLiteral(string)\n+                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                    self.pos += 1\n+                if self.pos > pos:\n+                    udl_suffix = self.definition[pos:self.pos]\n+                    return ASTUserDefinedLiteral(string, udl_suffix)\n             return ASTStringLiteral(string)\n \n+        # character-literal\n+\n         # character-literal\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n             try:\n-                return ASTCharLiteral(prefix, data)\n+                char_literal = ASTCharLiteral(prefix, data)\n+                # Check for user-defined literal suffix after character literal\n+                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                        if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                            self.pos = suffix_start  # backtrack\n+                            return char_literal\n+                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                        self.pos += 1\n+                    udl_suffix = self.definition[suffix_start:self.pos]\n+                    return ASTUserDefinedLiteral(char_literal, udl_suffix)\n+                return char_literal\n             except UnicodeDecodeError as e:\n                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n             except UnsupportedMultiCharacterCharLiteral:\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+\n+        # TODO: user-defined literals - check for UDL suffix pattern\n+        pos = self.pos\n+        if pos < len(self.definition) and (self.definition[pos] == '_' or self.definition[pos].isalpha()):\n+            # Parse UDL suffix: _identifier or identifier\n+            suffix_start = pos\n+            if self.definition[pos] == '_':\n+                pos += 1\n+            while pos < len(self.definition) and (self.definition[pos].isalnum() or self.definition[pos] == '_'):\n+                pos += 1\n+            if pos > suffix_start:\n+                udl_suffix = self.definition[suffix_start:pos]\n+                self.pos = pos\n+                # Need to determine what literal this suffix applies to\n+                # This is a fallback - most UDLs should be caught by specific literal parsers\n+                return ASTUserDefinedLiteral(\"\", udl_suffix)\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n",
    "variant_6": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..78d0c5f80 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -822,6 +822,7 @@ class ASTBooleanLiteral(ASTLiteral):\n         signode.append(nodes.Text(str(self)))\n \n \n+\n class ASTNumberLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -838,6 +839,22 @@ class ASTNumberLiteral(ASTLiteral):\n         signode.append(nodes.Text(txt, txt))\n \n \n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n+        self.literal_value = literal_value\n+        self.udl_suffix = udl_suffix\n+\n+    def _stringify(self, transform: StringifyTransform) -> str:\n+        return self.literal_value + self.udl_suffix\n+\n+    def get_id(self, version: int) -> str:\n+        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n+\n+    def describe_signature(self, signode: TextElement, mode: str,\n+                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n+        txt = str(self)\n+        signode.append(nodes.Text(txt, txt))\n+\n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -4662,27 +4679,99 @@ class DefinitionParser(BaseParser):\n                       integer_literal_re, octal_literal_re]:\n             pos = self.pos\n             if self.match(regex):\n+\n                 while self.current_char in 'uUlLfF':\n                     self.pos += 1\n+                \n+                # Check for user-defined literal suffix after built-in suffixes\n+                if (self.current_char == '_' or \n+                    (self.current_char and self.current_char.isalpha())):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                    while (self.current_char and \n+                           (self.current_char.isalnum() or self.current_char == '_')):\n+                        self.pos += 1\n+                    udl_suffix = self.definition[suffix_start:self.pos]\n+                    base_literal = self.definition[pos:suffix_start]\n+                    return ASTUserDefinedLiteral(base_literal, udl_suffix)\n+                \n                 return ASTNumberLiteral(self.definition[pos:self.pos])\n \n+\n         string = self._parse_string()\n         if string is not None:\n+            # Check for user-defined literal suffix\n+            pos = self.pos\n+            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                # Parse UDL suffix: _identifier or identifier\n+                if self.current_char == '_':\n+                    self.pos += 1\n+                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                        self.pos = pos  # Reset if invalid\n+                        return ASTStringLiteral(string)\n+                \n+                start_suffix = self.pos\n+                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                    self.pos += 1\n+                \n+                if self.pos > start_suffix:  # Valid suffix found\n+                    suffix = self.definition[pos:self.pos]\n+                    return ASTUserDefinedLiteral(string, suffix)\n+                else:\n+                    self.pos = pos  # Reset if no valid identifier after _\n+            \n             return ASTStringLiteral(string)\n \n+        # character-literal\n+\n         # character-literal\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n             try:\n-                return ASTCharLiteral(prefix, data)\n+                char_literal = ASTCharLiteral(prefix, data)\n+                # Check for user-defined literal suffix\n+                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                    while self.pos < self.end and (self.current_char.isalnum() or self.current_char == '_'):\n+                        self.pos += 1\n+                    if self.pos > suffix_start:\n+                        udl_suffix = self.definition[suffix_start:self.pos]\n+                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n+                return char_literal\n             except UnicodeDecodeError as e:\n                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n             except UnsupportedMultiCharacterCharLiteral:\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+\n+        # TODO: user-defined literals\n+        # Check if we're at a user-defined literal suffix\n+        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+            # Parse UDL suffix: _identifier or identifier\n+            suffix_start = self.pos\n+            if self.current_char == '_':\n+                self.pos += 1\n+                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                    self.pos = suffix_start  # Reset if invalid\n+                    return None\n+            \n+            # Continue parsing identifier characters\n+            while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                self.pos += 1\n+            \n+            if self.pos > suffix_start:\n+                udl_suffix = self.definition[suffix_start:self.pos]\n+                # This is a standalone UDL suffix, which shouldn't happen in valid C++\n+                # UDLs should be attached to literals, so this is likely an error\n+                self.pos = suffix_start  # Reset position\n+                return None\n+        \n+        return None\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n",
    "variant_7": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..18416e830 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -822,6 +822,7 @@ class ASTBooleanLiteral(ASTLiteral):\n         signode.append(nodes.Text(str(self)))\n \n \n+\n class ASTNumberLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -838,6 +839,22 @@ class ASTNumberLiteral(ASTLiteral):\n         signode.append(nodes.Text(txt, txt))\n \n \n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n+        self.literal_value = literal_value\n+        self.udl_suffix = udl_suffix\n+\n+    def _stringify(self, transform: StringifyTransform) -> str:\n+        return self.literal_value + self.udl_suffix\n+\n+    def get_id(self, version: int) -> str:\n+        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n+\n+    def describe_signature(self, signode: TextElement, mode: str,\n+                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n+        txt = str(self)\n+        signode.append(nodes.Text(txt, txt))\n+\n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -4662,27 +4679,89 @@ class DefinitionParser(BaseParser):\n                       integer_literal_re, octal_literal_re]:\n             pos = self.pos\n             if self.match(regex):\n-                while self.current_char in 'uUlLfF':\n+\n+            while self.current_char in 'uUlLfF':\n+                self.pos += 1\n+            \n+            # Check for User Defined Literal suffix after built-in suffixes\n+            if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                udl_start = self.pos\n+                if self.current_char == '_':\n                     self.pos += 1\n-                return ASTNumberLiteral(self.definition[pos:self.pos])\n+                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                        self.pos = udl_start  # Reset if invalid UDL\n+                        return ASTNumberLiteral(self.definition[pos:self.pos])\n+                \n+                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                    self.pos += 1\n+                \n+                base_literal = self.definition[pos:udl_start]\n+                udl_suffix = self.definition[udl_start:self.pos]\n+                return ASTUserDefinedLiteral(base_literal, udl_suffix)\n+            \n+            return ASTNumberLiteral(self.definition[pos:self.pos])\n+\n \n         string = self._parse_string()\n         if string is not None:\n+            # Check for user-defined literal suffix after string\n+            suffix_start = self.pos\n+            if self._parse_udl_suffix():\n+                udl_suffix = self.definition[suffix_start:self.pos]\n+                return ASTUserDefinedLiteral(string, udl_suffix)\n             return ASTStringLiteral(string)\n \n+        # character-literal\n+\n         # character-literal\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n             try:\n-                return ASTCharLiteral(prefix, data)\n+                char_literal = ASTCharLiteral(prefix, data)\n+                # Check for user-defined literal suffix after character literal\n+                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                        if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                            self.pos = suffix_start  # Reset if invalid UDL suffix\n+                            return char_literal\n+                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                        self.pos += 1\n+                    if self.pos > suffix_start:\n+                        udl_suffix = self.definition[suffix_start:self.pos]\n+                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n+                return char_literal\n             except UnicodeDecodeError as e:\n                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n             except UnsupportedMultiCharacterCharLiteral:\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+\n+        # TODO: user-defined literal suffix parsing\n+        # Check if we're at a user-defined literal suffix\n+        if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+            # Parse UDL suffix: _identifier or identifier\n+            suffix_start = self.pos\n+            if self.current_char == '_':\n+                self._advance()\n+                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                    self.pos = suffix_start  # backtrack\n+                    return None\n+            \n+            # Parse the rest of the identifier\n+            while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                self._advance()\n+            \n+            # If we consumed characters, we have a potential UDL suffix\n+            if self.pos > suffix_start:\n+                udl_suffix = self.definition[suffix_start:self.pos]\n+                # For now, we'll fail with a descriptive message since ASTUserDefinedLiteral doesn't exist yet\n+                self.fail(f\"User-defined literal suffix '{udl_suffix}' is not yet supported\")\n+        \n+        return None\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n",
    "variant_8": "diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py\nindex fe52d881d..447e4c1f1 100644\n--- a/sphinx/domains/cpp.py\n+++ b/sphinx/domains/cpp.py\n@@ -822,6 +822,24 @@ class ASTBooleanLiteral(ASTLiteral):\n         signode.append(nodes.Text(str(self)))\n \n \n+\n+class ASTUserDefinedLiteral(ASTLiteral):\n+    def __init__(self, literal_value: str, udl_suffix: str) -> None:\n+        self.literal_value = literal_value\n+        self.udl_suffix = udl_suffix\n+\n+    def _stringify(self, transform: StringifyTransform) -> str:\n+        return self.literal_value + self.udl_suffix\n+\n+    def get_id(self, version: int) -> str:\n+        return \"L%s%sE\" % (self.literal_value, self.udl_suffix)\n+\n+    def describe_signature(self, signode: TextElement, mode: str,\n+                           env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:\n+        txt = str(self)\n+        signode.append(nodes.Text(txt, txt))\n+\n+\n class ASTNumberLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -837,7 +855,6 @@ class ASTNumberLiteral(ASTLiteral):\n         txt = str(self)\n         signode.append(nodes.Text(txt, txt))\n \n-\n class ASTStringLiteral(ASTLiteral):\n     def __init__(self, data: str) -> None:\n         self.data = data\n@@ -4662,27 +4679,94 @@ class DefinitionParser(BaseParser):\n                       integer_literal_re, octal_literal_re]:\n             pos = self.pos\n             if self.match(regex):\n+\n                 while self.current_char in 'uUlLfF':\n                     self.pos += 1\n+                # Check for user-defined literal suffix after built-in suffixes\n+                if self.current_char == '_' or (self.current_char and self.current_char.isalpha()):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                        if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                            self.pos = suffix_start  # Invalid UDL, backtrack\n+                            return ASTNumberLiteral(self.definition[pos:self.pos])\n+                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                        self.pos += 1\n+                    udl_suffix = self.definition[suffix_start:self.pos]\n+                    base_literal = self.definition[pos:suffix_start]\n+                    return ASTUserDefinedLiteral(base_literal, udl_suffix)\n                 return ASTNumberLiteral(self.definition[pos:self.pos])\n \n+\n         string = self._parse_string()\n         if string is not None:\n+            # Check for user-defined literal suffix after string\n+            if self.current_char and (self.current_char.isalpha() or self.current_char == '_'):\n+                suffix_start = self.pos\n+                if self.current_char == '_':\n+                    self.pos += 1\n+                    if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                        self.pos = suffix_start  # Invalid UDL suffix, backtrack\n+                        return ASTStringLiteral(string)\n+                while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                    self.pos += 1\n+                if self.pos > suffix_start:\n+                    udl_suffix = self.definition[suffix_start:self.pos]\n+                    return ASTUserDefinedLiteral(string, udl_suffix)\n             return ASTStringLiteral(string)\n \n+        # character-literal\n+\n         # character-literal\n         if self.match(char_literal_re):\n             prefix = self.last_match.group(1)  # may be None when no prefix\n             data = self.last_match.group(2)\n             try:\n-                return ASTCharLiteral(prefix, data)\n+                char_literal = ASTCharLiteral(prefix, data)\n+                # Check for user-defined literal suffix after character literal\n+                if self.current_char and (self.current_char == '_' or self.current_char.isalpha()):\n+                    suffix_start = self.pos\n+                    if self.current_char == '_':\n+                        self.pos += 1\n+                        if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                            self.pos = suffix_start  # Reset if invalid UDL suffix\n+                            return char_literal\n+                    while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):\n+                        self.pos += 1\n+                    if self.pos > suffix_start:\n+                        udl_suffix = self.definition[suffix_start:self.pos]\n+                        return ASTUserDefinedLiteral(char_literal, udl_suffix)\n+                return char_literal\n             except UnicodeDecodeError as e:\n                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n             except UnsupportedMultiCharacterCharLiteral:\n                 self.fail(\"Can not handle character literal\"\n                           \" resulting in multiple decoded characters.\")\n \n-        # TODO: user-defined lit\n+\n+        # TODO: user-defined literals - check for UDL suffix pattern\n+        # UDL suffix must start with underscore or letter, followed by alphanumeric/underscore\n+        if (self.current_char and \n+            (self.current_char == '_' or self.current_char.isalpha())):\n+            # Look ahead to validate UDL suffix pattern\n+            pos = self.pos\n+            if self.current_char == '_':\n+                self.pos += 1\n+                if not (self.current_char and (self.current_char.isalpha() or self.current_char == '_')):\n+                    self.pos = pos  # Reset if invalid pattern\n+                    return None\n+            \n+            # Consume the UDL suffix\n+            suffix_start = self.pos\n+            while (self.current_char and \n+                   (self.current_char.isalnum() or self.current_char == '_')):\n+                self.pos += 1\n+            \n+            if self.pos > suffix_start:  # We found a valid suffix\n+                udl_suffix = self.definition[suffix_start:self.pos]\n+                # This is a standalone UDL (shouldn't happen in normal parsing)\n+                # but we'll handle it gracefully\n+                self.fail(\"Unexpected user-defined literal suffix without base literal\")\n         return None\n \n     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n"
  }
}