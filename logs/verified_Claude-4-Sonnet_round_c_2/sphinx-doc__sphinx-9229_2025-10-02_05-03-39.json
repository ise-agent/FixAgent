{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1799-1804)": "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isgenericalias(self.object):\n            # Only add alias text if no meaningful docstring exists\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n                more_content.append(_('alias of %s') % restify(self.object), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
    "Location 2 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1817-1823)": "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isNewType(self.object):\n            # Only add alias text if there's no meaningful docstring\n            existing_doc = self.get_doc()\n            if not existing_doc or not any(line.strip() for line in existing_doc):\n                supertype = restify(self.object.__supertype__)\n                more_content.append(_('alias of %s') % supertype, '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
    "Location 3 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1850-1865)": "\n    def update_content(self, more_content: StringList) -> None:\n        if isinstance(self.object, TypeVar):\n            # Only add alias text if there's no meaningful docstring\n            existing_doc = self.get_doc()\n            if not existing_doc:\n                attrs = [repr(self.object.__name__)]\n                for constraint in self.object.__constraints__:\n                    attrs.append(stringify_typehint(constraint))\n                if self.object.__bound__:\n                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n                if self.object.__covariant__:\n                    attrs.append(\"covariant=True\")\n                if self.object.__contravariant__:\n                    attrs.append(\"contravariant=True\")\n\n                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
    "Location 4 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1842-1848)": "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n\n        if isinstance(self.object, TypeVar):\n            if self.object.__doc__ != TypeVar.__doc__:\n                return super().get_doc()  # type: ignore\n            else:\n                return []\n        else:\n            return super().get_doc()  # type: ignore\n",
    "Location 5 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 552-567)": "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        \"\"\"Decode and return lines of the docstring(s) for the object.\n\n        When it returns None value, autodoc-process-docstring will not be called for this\n        object.\n        \"\"\"\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n                           self.parent, self.object_name)\n        if docstring:\n            tab_width = self.directive.state.document.settings.tab_width\n            return [prepare_docstring(docstring, ignore, tab_width)]\n        return []\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1799-1804)": [
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isgenericalias(self.object):\n            # Only add \"alias of\" text if no meaningful docstring exists\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n                more_content.append(_('alias of %s') % restify(self.object), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isgenericalias(self.object):\n            # Only add alias text if there's no meaningful docstring\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc[0]):\n                more_content.append(_('alias of %s') % restify(self.object), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isgenericalias(self.object):\n            # Only add \"alias of\" text if no meaningful docstring exists\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc):\n                more_content.append(_('alias of %s') % restify(self.object), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isgenericalias(self.object):\n            # Only add generic alias text if no meaningful docstring exists\n            docstring = self.get_doc()\n            if not docstring or not any(line.strip() for line in docstring):\n                more_content.append(_('alias of %s') % restify(self.object), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isgenericalias(self.object):\n            # Only add alias text if no meaningful docstring exists\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n                more_content.append(_('alias of %s') % restify(self.object), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isgenericalias(self.object):\n            # Only add \"alias of\" text if there's no meaningful docstring\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n                more_content.append(_('alias of %s') % restify(self.object), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isgenericalias(self.object):\n            # Only add generic \"alias of\" text if no meaningful docstring exists\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc):\n                more_content.append(_('alias of %s') % restify(self.object), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isgenericalias(self.object):\n            # Only add \"alias of\" text if there's no meaningful docstring\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc):\n                more_content.append(_('alias of %s') % restify(self.object), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n"
    ],
    "Location 2 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1817-1823)": [
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isNewType(self.object):\n            # Only add alias text if no meaningful docstring exists\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n                supertype = restify(self.object.__supertype__)\n                more_content.append(_('alias of %s') % supertype, '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isNewType(self.object):\n            # Check if the object has a meaningful docstring before adding generic alias text\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc):\n                supertype = restify(self.object.__supertype__)\n                more_content.append(_('alias of %s') % supertype, '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isNewType(self.object):\n            # Only add \"alias of\" text if there's no meaningful docstring\n            existing_doc = self.get_doc()\n            if not existing_doc or not any(line.strip() for line in existing_doc[0] if line.strip()):\n                supertype = restify(self.object.__supertype__)\n                more_content.append(_('alias of %s') % supertype, '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isNewType(self.object):\n            # Only add alias text if there's no meaningful docstring\n            existing_doc = self.get_doc()\n            if not existing_doc or not any(line.strip() for line in existing_doc[0]):\n                supertype = restify(self.object.__supertype__)\n                more_content.append(_('alias of %s') % supertype, '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isNewType(self.object):\n            # Only add alias text if there's no meaningful docstring\n            existing_doc = self.get_doc()\n            if not existing_doc or not any(line.strip() for line in existing_doc[0]):\n                supertype = restify(self.object.__supertype__)\n                more_content.append(_('alias of %s') % supertype, '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isNewType(self.object):\n            # Only add alias text if there's no meaningful docstring\n            existing_doc = self.get_doc()\n            if not existing_doc or not any(line.strip() for line in existing_doc[0]):\n                supertype = restify(self.object.__supertype__)\n                more_content.append(_('alias of %s') % supertype, '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isNewType(self.object):\n            # Only add \"alias of\" text if there's no meaningful docstring\n            doc = self.get_doc()\n            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n                supertype = restify(self.object.__supertype__)\n                more_content.append(_('alias of %s') % supertype, '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if inspect.isNewType(self.object):\n            # Only add alias text if there's no meaningful docstring\n            doc = self.get_doc()\n            if not doc or all(not line.strip() for line in doc[0]):\n                supertype = restify(self.object.__supertype__)\n                more_content.append(_('alias of %s') % supertype, '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n"
    ],
    "Location 3 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1850-1865)": [
      "\n    def update_content(self, more_content: StringList) -> None:\n        if isinstance(self.object, TypeVar):\n            # Only add alias text if there's no meaningful docstring\n            existing_doc = self.get_doc()\n            if not existing_doc or (len(existing_doc) == 1 and not existing_doc[0].strip()):\n                attrs = [repr(self.object.__name__)]\n                for constraint in self.object.__constraints__:\n                    attrs.append(stringify_typehint(constraint))\n                if self.object.__bound__:\n                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n                if self.object.__covariant__:\n                    attrs.append(\"covariant=True\")\n                if self.object.__contravariant__:\n                    attrs.append(\"contravariant=True\")\n\n                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if isinstance(self.object, TypeVar):\n            # Only add alias text if no meaningful docstring exists\n            existing_doc = self.get_doc()\n            if not existing_doc or (len(existing_doc) == 1 and not existing_doc[0].strip()):\n                attrs = [repr(self.object.__name__)]\n                for constraint in self.object.__constraints__:\n                    attrs.append(stringify_typehint(constraint))\n                if self.object.__bound__:\n                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n                if self.object.__covariant__:\n                    attrs.append(\"covariant=True\")\n                if self.object.__contravariant__:\n                    attrs.append(\"contravariant=True\")\n\n                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if isinstance(self.object, TypeVar):\n            # Only add alias text if there's no meaningful docstring\n            existing_doc = self.get_doc()\n            if not existing_doc:\n                attrs = [repr(self.object.__name__)]\n                for constraint in self.object.__constraints__:\n                    attrs.append(stringify_typehint(constraint))\n                if self.object.__bound__:\n                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n                if self.object.__covariant__:\n                    attrs.append(\"covariant=True\")\n                if self.object.__contravariant__:\n                    attrs.append(\"contravariant=True\")\n\n                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if isinstance(self.object, TypeVar):\n            # Only add alias information if there's no meaningful docstring\n            if not self.get_doc():\n                attrs = [repr(self.object.__name__)]\n                for constraint in self.object.__constraints__:\n                    attrs.append(stringify_typehint(constraint))\n                if self.object.__bound__:\n                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n                if self.object.__covariant__:\n                    attrs.append(\"covariant=True\")\n                if self.object.__contravariant__:\n                    attrs.append(\"contravariant=True\")\n\n                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if isinstance(self.object, TypeVar):\n            # Only add alias information if there's no meaningful docstring\n            existing_doc = self.get_doc()\n            if not existing_doc:\n                attrs = [repr(self.object.__name__)]\n                for constraint in self.object.__constraints__:\n                    attrs.append(stringify_typehint(constraint))\n                if self.object.__bound__:\n                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n                if self.object.__covariant__:\n                    attrs.append(\"covariant=True\")\n                if self.object.__contravariant__:\n                    attrs.append(\"contravariant=True\")\n\n                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if isinstance(self.object, TypeVar):\n            # Only add alias information if there's no meaningful docstring\n            existing_doc = self.get_doc()\n            if not existing_doc or not any(line.strip() for line in existing_doc[0] if line.strip()):\n                attrs = [repr(self.object.__name__)]\n                for constraint in self.object.__constraints__:\n                    attrs.append(stringify_typehint(constraint))\n                if self.object.__bound__:\n                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n                if self.object.__covariant__:\n                    attrs.append(\"covariant=True\")\n                if self.object.__contravariant__:\n                    attrs.append(\"contravariant=True\")\n\n                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if isinstance(self.object, TypeVar):\n            # Only add alias info if no meaningful docstring exists\n            existing_doc = self.get_doc()\n            if not existing_doc:\n                attrs = [repr(self.object.__name__)]\n                for constraint in self.object.__constraints__:\n                    attrs.append(stringify_typehint(constraint))\n                if self.object.__bound__:\n                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n                if self.object.__covariant__:\n                    attrs.append(\"covariant=True\")\n                if self.object.__contravariant__:\n                    attrs.append(\"contravariant=True\")\n\n                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n",
      "\n    def update_content(self, more_content: StringList) -> None:\n        if isinstance(self.object, TypeVar):\n            # Only add alias text if no meaningful docstring exists\n            existing_doc = self.get_doc()\n            if not existing_doc:\n                attrs = [repr(self.object.__name__)]\n                for constraint in self.object.__constraints__:\n                    attrs.append(stringify_typehint(constraint))\n                if self.object.__bound__:\n                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n                if self.object.__covariant__:\n                    attrs.append(\"covariant=True\")\n                if self.object.__contravariant__:\n                    attrs.append(\"contravariant=True\")\n\n                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n                more_content.append('', '')\n\n        super().update_content(more_content)\n"
    ],
    "Location 4 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 1842-1848)": [
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n\n        if isinstance(self.object, TypeVar):\n            if self.object.__doc__ != TypeVar.__doc__:\n                return super().get_doc()  # type: ignore\n            else:\n                return []\n        else:\n            return super().get_doc()  # type: ignore\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n\n        if isinstance(self.object, TypeVar):\n            if self.object.__doc__ != TypeVar.__doc__:\n                return super().get_doc()  # type: ignore\n            else:\n                return []\n        else:\n            return super().get_doc()  # type: ignore\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n\n        if isinstance(self.object, TypeVar):\n            if self.object.__doc__ and self.object.__doc__ != TypeVar.__doc__:\n                return super().get_doc()  # type: ignore\n            else:\n                return []\n        else:\n            return super().get_doc()  # type: ignore\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n\n        if isinstance(self.object, TypeVar):\n            if self.object.__doc__ != TypeVar.__doc__:\n                return super().get_doc()  # type: ignore\n            else:\n                return []\n        else:\n            return super().get_doc()  # type: ignore\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n\n        if isinstance(self.object, TypeVar):\n            if self.object.__doc__ != TypeVar.__doc__:\n                return super().get_doc()  # type: ignore\n            else:\n                return []\n        else:\n            return super().get_doc()  # type: ignore\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n\n        if isinstance(self.object, TypeVar):\n            if self.object.__doc__ != TypeVar.__doc__:\n                return super().get_doc()  # type: ignore\n            else:\n                return []\n        else:\n            return super().get_doc()  # type: ignore\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n\n        if isinstance(self.object, TypeVar):\n            if self.object.__doc__ != TypeVar.__doc__:\n                return super().get_doc()  # type: ignore\n            else:\n                return []\n        else:\n            return super().get_doc()  # type: ignore\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n\n        if isinstance(self.object, TypeVar):\n            if self.object.__doc__ != TypeVar.__doc__:\n                return super().get_doc()  # type: ignore\n            else:\n                return []\n        else:\n            return super().get_doc()  # type: ignore\n"
    ],
    "Location 5 (/root/hy/projects/sphinx/sphinx/ext/autodoc/__init__.py lines 552-567)": [
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        \"\"\"Decode and return lines of the docstring(s) for the object.\n\n        When it returns None value, autodoc-process-docstring will not be called for this\n        object.\n        \"\"\"\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n                           self.parent, self.object_name)\n        if docstring:\n            tab_width = self.directive.state.document.settings.tab_width\n            return [prepare_docstring(docstring, ignore, tab_width)]\n        return []\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        \"\"\"Decode and return lines of the docstring(s) for the object.\n\n        When it returns None value, autodoc-process-docstring will not be called for this\n        object.\n        \"\"\"\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n                           self.parent, self.object_name)\n        if docstring:\n            tab_width = self.directive.state.document.settings.tab_width\n            return [prepare_docstring(docstring, ignore, tab_width)]\n        return []\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        \"\"\"Decode and return lines of the docstring(s) for the object.\n\n        When it returns None value, autodoc-process-docstring will not be called for this\n        object.\n        \"\"\"\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n                           self.parent, self.object_name)\n        if docstring:\n            tab_width = self.directive.state.document.settings.tab_width\n            return [prepare_docstring(docstring, ignore, tab_width)]\n        return []\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        \"\"\"Decode and return lines of the docstring(s) for the object.\n\n        When it returns None value, autodoc-process-docstring will not be called for this\n        object.\n        \"\"\"\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n                           self.parent, self.object_name)\n        if docstring:\n            tab_width = self.directive.state.document.settings.tab_width\n            return [prepare_docstring(docstring, ignore, tab_width)]\n        return []\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        \"\"\"Decode and return lines of the docstring(s) for the object.\n\n        When it returns None value, autodoc-process-docstring will not be called for this\n        object.\n        \"\"\"\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n                           self.parent, self.object_name)\n        if docstring:\n            tab_width = self.directive.state.document.settings.tab_width\n            return [prepare_docstring(docstring, ignore, tab_width)]\n        return []\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        \"\"\"Decode and return lines of the docstring(s) for the object.\n\n        When it returns None value, autodoc-process-docstring will not be called for this\n        object.\n        \"\"\"\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n                           self.parent, self.object_name)\n        if docstring:\n            tab_width = self.directive.state.document.settings.tab_width\n            return [prepare_docstring(docstring, ignore, tab_width)]\n        return []\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        \"\"\"Decode and return lines of the docstring(s) for the object.\n\n        When it returns None value, autodoc-process-docstring will not be called for this\n        object.\n        \"\"\"\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n                           self.parent, self.object_name)\n        if docstring:\n            tab_width = self.directive.state.document.settings.tab_width\n            return [prepare_docstring(docstring, ignore, tab_width)]\n        return []\n",
      "\n    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n        \"\"\"Decode and return lines of the docstring(s) for the object.\n\n        When it returns None value, autodoc-process-docstring will not be called for this\n        object.\n        \"\"\"\n        if ignore is not None:\n            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n                          % self.__class__.__name__,\n                          RemovedInSphinx50Warning, stacklevel=2)\n        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n                           self.parent, self.object_name)\n        if docstring:\n            tab_width = self.directive.state.document.settings.tab_width\n            return [prepare_docstring(docstring, ignore, tab_width)]\n        return []\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..cb244b72f 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -549,6 +549,7 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\n \n@@ -1796,10 +1797,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n         return (inspect.isgenericalias(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Only add \"alias of ...\" text if there's no existing docstring\n+            docstrings = self.get_doc()\n+            if not docstrings:\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1814,11 +1819,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n         return (inspect.isNewType(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Only add \"alias of ...\" text if there's no existing docstring\n+            docstrings = self.get_doc()\n+            if not docstrings:\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1839,6 +1848,7 @@ class TypeVarMixin(DataDocumenterMixinBase):\n                           % self.__class__.__name__,\n                           RemovedInSphinx50Warning, stacklevel=2)\n \n+\n         if isinstance(self.object, TypeVar):\n             if self.object.__doc__ != TypeVar.__doc__:\n                 return super().get_doc()  # type: ignore\n@@ -1847,20 +1857,24 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         else:\n             return super().get_doc()  # type: ignore\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Only add \"alias of ...\" text if there's no existing docstring\n+            docstrings = self.get_doc()\n+            if not docstrings:\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..d6c538a2c 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -549,6 +549,7 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\n \n@@ -1796,10 +1797,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n         return (inspect.isgenericalias(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Only add alias text if no meaningful docstring exists\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1814,11 +1819,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n         return (inspect.isNewType(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Only add alias text if there's no meaningful docstring\n+            existing_doc = self.get_doc()\n+            if not existing_doc or not any(line.strip() for line in existing_doc):\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1833,6 +1842,13 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         return (isinstance(self.object, TypeVar) or\n                 super().should_suppress_directive_header())\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         if ignore is not None:\n             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n@@ -1847,20 +1863,24 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         else:\n             return super().get_doc()  # type: ignore\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Only add alias text if there's no meaningful docstring\n+            existing_doc = self.get_doc()\n+            if not existing_doc:\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..b5c111cd9 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -549,6 +549,7 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\n \n@@ -1796,10 +1797,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n         return (inspect.isgenericalias(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Only add \"alias of\" text if no meaningful docstring exists\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1814,11 +1819,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n         return (inspect.isNewType(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Only add alias text if no meaningful docstring exists\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1833,6 +1842,13 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         return (isinstance(self.object, TypeVar) or\n                 super().should_suppress_directive_header())\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         if ignore is not None:\n             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n@@ -1847,20 +1863,24 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         else:\n             return super().get_doc()  # type: ignore\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Only add alias text if there's no meaningful docstring\n+            existing_doc = self.get_doc()\n+            if not existing_doc or (len(existing_doc) == 1 and not existing_doc[0].strip()):\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..b399c8845 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -549,6 +549,7 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\n \n@@ -1796,10 +1797,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n         return (inspect.isgenericalias(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Only add alias text if there's no meaningful docstring\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc[0]):\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1814,11 +1819,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n         return (inspect.isNewType(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Check if the object has a meaningful docstring before adding generic alias text\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc):\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1833,6 +1842,13 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         return (isinstance(self.object, TypeVar) or\n                 super().should_suppress_directive_header())\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         if ignore is not None:\n             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n@@ -1847,20 +1863,24 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         else:\n             return super().get_doc()  # type: ignore\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Only add alias text if no meaningful docstring exists\n+            existing_doc = self.get_doc()\n+            if not existing_doc or (len(existing_doc) == 1 and not existing_doc[0].strip()):\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..a476a6ee3 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -549,6 +549,7 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\n \n@@ -1796,10 +1797,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n         return (inspect.isgenericalias(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Only add \"alias of\" text if no meaningful docstring exists\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc):\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1814,11 +1819,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n         return (inspect.isNewType(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Only add \"alias of\" text if there's no meaningful docstring\n+            existing_doc = self.get_doc()\n+            if not existing_doc or not any(line.strip() for line in existing_doc[0] if line.strip()):\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1833,6 +1842,13 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         return (isinstance(self.object, TypeVar) or\n                 super().should_suppress_directive_header())\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         if ignore is not None:\n             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n@@ -1840,27 +1856,31 @@ class TypeVarMixin(DataDocumenterMixinBase):\n                           RemovedInSphinx50Warning, stacklevel=2)\n \n         if isinstance(self.object, TypeVar):\n-            if self.object.__doc__ != TypeVar.__doc__:\n+            if self.object.__doc__ and self.object.__doc__ != TypeVar.__doc__:\n                 return super().get_doc()  # type: ignore\n             else:\n                 return []\n         else:\n             return super().get_doc()  # type: ignore\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Only add alias text if there's no meaningful docstring\n+            existing_doc = self.get_doc()\n+            if not existing_doc:\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..618aa7c10 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -549,6 +549,7 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\n \n@@ -1796,10 +1797,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n         return (inspect.isgenericalias(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Only add generic alias text if no meaningful docstring exists\n+            docstring = self.get_doc()\n+            if not docstring or not any(line.strip() for line in docstring):\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1814,11 +1819,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n         return (inspect.isNewType(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Only add alias text if there's no meaningful docstring\n+            existing_doc = self.get_doc()\n+            if not existing_doc or not any(line.strip() for line in existing_doc[0]):\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1833,6 +1842,13 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         return (isinstance(self.object, TypeVar) or\n                 super().should_suppress_directive_header())\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         if ignore is not None:\n             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n@@ -1847,20 +1863,23 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         else:\n             return super().get_doc()  # type: ignore\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Only add alias information if there's no meaningful docstring\n+            if not self.get_doc():\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..e3d4f0654 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -549,6 +549,7 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\n \n@@ -1796,10 +1797,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n         return (inspect.isgenericalias(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Only add alias text if no meaningful docstring exists\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1814,11 +1819,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n         return (inspect.isNewType(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Only add alias text if there's no meaningful docstring\n+            existing_doc = self.get_doc()\n+            if not existing_doc or not any(line.strip() for line in existing_doc[0]):\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1833,6 +1842,13 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         return (isinstance(self.object, TypeVar) or\n                 super().should_suppress_directive_header())\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         if ignore is not None:\n             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n@@ -1847,20 +1863,24 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         else:\n             return super().get_doc()  # type: ignore\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Only add alias information if there's no meaningful docstring\n+            existing_doc = self.get_doc()\n+            if not existing_doc:\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..1c93dd476 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -549,6 +549,7 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\n \n@@ -1796,10 +1797,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n         return (inspect.isgenericalias(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Only add \"alias of\" text if there's no meaningful docstring\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1814,11 +1819,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n         return (inspect.isNewType(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Only add alias text if there's no meaningful docstring\n+            existing_doc = self.get_doc()\n+            if not existing_doc or not any(line.strip() for line in existing_doc[0]):\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1833,6 +1842,13 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         return (isinstance(self.object, TypeVar) or\n                 super().should_suppress_directive_header())\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         if ignore is not None:\n             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n@@ -1847,20 +1863,24 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         else:\n             return super().get_doc()  # type: ignore\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Only add alias information if there's no meaningful docstring\n+            existing_doc = self.get_doc()\n+            if not existing_doc or not any(line.strip() for line in existing_doc[0] if line.strip()):\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..93617a7c9 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -549,6 +549,7 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\n \n@@ -1796,10 +1797,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n         return (inspect.isgenericalias(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Only add generic \"alias of\" text if no meaningful docstring exists\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc):\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1814,11 +1819,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n         return (inspect.isNewType(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Only add \"alias of\" text if there's no meaningful docstring\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc[0] if line.strip()):\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1833,6 +1842,13 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         return (isinstance(self.object, TypeVar) or\n                 super().should_suppress_directive_header())\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         if ignore is not None:\n             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n@@ -1847,20 +1863,24 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         else:\n             return super().get_doc()  # type: ignore\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Only add alias info if no meaningful docstring exists\n+            existing_doc = self.get_doc()\n+            if not existing_doc:\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..59c4521ee 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -549,6 +549,7 @@ class Documenter:\n             # etc. don't support a prepended module name\n             self.add_line('   :module: %s' % self.modname, sourcename)\n \n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         \"\"\"Decode and return lines of the docstring(s) for the object.\n \n@@ -1796,10 +1797,14 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n         return (inspect.isgenericalias(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Only add \"alias of\" text if there's no meaningful docstring\n+            doc = self.get_doc()\n+            if not doc or not any(line.strip() for line in doc):\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1814,11 +1819,15 @@ class NewTypeMixin(DataDocumenterMixinBase):\n         return (inspect.isNewType(self.object) or\n                 super().should_suppress_directive_header())\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Only add alias text if there's no meaningful docstring\n+            doc = self.get_doc()\n+            if not doc or all(not line.strip() for line in doc[0]):\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1833,6 +1842,13 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         return (isinstance(self.object, TypeVar) or\n                 super().should_suppress_directive_header())\n \n+    def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n+        if ignore is not None:\n+            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n+                          % self.__class__.__name__,\n+                          RemovedInSphinx50Warning, stacklevel=2)\n+\n+\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         if ignore is not None:\n             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n@@ -1847,20 +1863,24 @@ class TypeVarMixin(DataDocumenterMixinBase):\n         else:\n             return super().get_doc()  # type: ignore\n \n+\n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Only add alias text if no meaningful docstring exists\n+            existing_doc = self.get_doc()\n+            if not existing_doc:\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n"
  }
}