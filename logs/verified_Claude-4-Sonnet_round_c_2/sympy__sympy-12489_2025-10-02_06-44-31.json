{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/combinatorics/permutations.py lines 860-860)": "\n            return cls._af_new(list(range(size or 0)), cls)\n",
    "Location 2 (/root/hy/projects/sympy/sympy/combinatorics/permutations.py lines 862-862)": "\n        elif len(args) > 1:  # c\n            return cls._af_new(Cycle(*args).list(size), cls)\n",
    "Location 3 (/root/hy/projects/sympy/sympy/combinatorics/permutations.py lines 868-868)": "\n                return cls(a.array_form, size=size)\n",
    "Location 4 (/root/hy/projects/sympy/sympy/combinatorics/permutations.py lines 870-872)": "\n            if isinstance(a, Cycle):  # f\n                return cls._af_new(a.list(size), cls)\n            if not is_sequence(a):  # b\n                return cls._af_new(list(range(a + 1)), cls)\n",
    "Location 5 (/root/hy/projects/sympy/sympy/combinatorics/permutations.py lines 947-947)": "\n        p = Basic.__new__(cls, perm)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/combinatorics/permutations.py lines 860-860)": [
      "\n            return cls._af_new(list(range(size or 0)), cls)\n",
      "\n            return cls._af_new(list(range(size or 0)), cls)\n",
      "\n            return cls._af_new(list(range(size or 0)), cls)\n",
      "\n            return cls._af_new(list(range(size or 0)), cls)\n",
      "\n            return cls._af_new(list(range(size or 0)), cls)\n",
      "\n            return cls._af_new(list(range(size or 0)), cls)\n",
      "\n            return cls._af_new(list(range(size or 0)), cls)\n",
      "\n            return cls._af_new(list(range(size or 0)), cls)\n"
    ],
    "Location 2 (/root/hy/projects/sympy/sympy/combinatorics/permutations.py lines 862-862)": [
      "\n            return cls._af_new(Cycle(*args).list(size), cls)\n",
      "\n            return cls._af_new(Cycle(*args).list(size), cls)\n",
      "\n            return cls._af_new(Cycle(*args).list(size), cls)\n",
      "\n            return cls._af_new(Cycle(*args).list(size), cls)\n",
      "\n            return cls._af_new(Cycle(*args).list(size), cls)\n",
      "\n            return cls._af_new(Cycle(*args).list(size), cls)\n",
      "\n            return cls._af_new(Cycle(*args).list(size), cls)\n",
      "\n            return cls._af_new(Cycle(*args).list(size), cls)\n"
    ],
    "Location 3 (/root/hy/projects/sympy/sympy/combinatorics/permutations.py lines 868-868)": [
      "\n                return cls(a.array_form, size=size)\n",
      "\n                return cls(a.array_form, size=size)\n",
      "\n                return cls(a.array_form, size=size)\n",
      "\n                return cls(a.array_form, size=size)\n",
      "\n                return cls(a.array_form, size=size)\n",
      "\n                return cls(a.array_form, size=size)\n",
      "\n                return cls(a.array_form, size=size)\n",
      "\n                return cls(a.array_form, size=size)\n"
    ],
    "Location 4 (/root/hy/projects/sympy/sympy/combinatorics/permutations.py lines 870-872)": [
      "\n            if not is_sequence(a):  # b\n                return cls._af_new(list(range(a + 1)), cls)\n",
      "\n            if not is_sequence(a):  # b\n                return cls._af_new(list(range(a + 1)), cls)\n",
      "\n            if isinstance(a, Cycle):  # f\n                return cls._af_new(a.list(size), cls)\n            if not is_sequence(a):  # b\n                return cls._af_new(list(range(a + 1)), cls)\n",
      "\n            if isinstance(a, Cycle):  # f\n                return cls._af_new(a.list(size), cls)\n            if not is_sequence(a):  # b\n                return cls._af_new(list(range(a + 1)), cls)\n",
      "\n            if isinstance(a, Cycle):  # f\n                return cls._af_new(a.list(size), cls)\n            if not is_sequence(a):  # b\n                return cls._af_new(list(range(a + 1)), cls)\n",
      "\n            if size is None or size == a.size:\n                return a\n            return cls(a.array_form, size=size)\n        if isinstance(a, Cycle):  # f\n            return cls._af_new(a.list(size), cls)\n        if not is_sequence(a):  # b\n            return cls._af_new(list(range(a + 1)), cls)\n",
      "\n            if isinstance(a, Cycle):  # f\n                return cls._af_new(a.list(size), cls)\n            if not is_sequence(a):  # b\n                return cls._af_new(list(range(a + 1)), cls)\n",
      "\n            if not is_sequence(a):  # b\n                return cls._af_new(list(range(a + 1)), cls)\n"
    ],
    "Location 5 (/root/hy/projects/sympy/sympy/combinatorics/permutations.py lines 947-947)": [
      "\n        p = Basic.__new__(cls, perm)\n",
      "\n    @classmethod\n    def _af_new(cls, perm, target_cls=None):\n        \"\"\"A method to produce a Permutation object from a list;\n        the list is bound to the _array_form attribute, so it must\n        not be modified; this method is meant for internal use only;\n        the list ``a`` is supposed to be generated as a temporary value\n        in a method, so p = Perm._af_new(a) is the only use case;\n        otherwise, the array form should be passed to the constructor\n        as Perm(a).\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.permutations import Perm\n        >>> Perm.print_cyclic = False\n        >>> a = [2,1,3,0]\n        >>> p = Perm._af_new(a)\n        >>> p\n        Permutation([2, 1, 3, 0])\n\n        \"\"\"\n        if target_cls is None:\n            target_cls = cls\n        p = Basic.__new__(target_cls, perm)\n        p._array_form = perm\n        p._size = len(perm)\n        return p\n",
      "\n    @classmethod\n    def _af_new(cls, perm, target_cls=None):\n        \"\"\"A method to produce a Permutation object from a list;\n        the list is bound to the _array_form attribute, so it must\n        not be modified; this method is meant for internal use only;\n        the list ``a`` is supposed to be generated as a temporary value\n        in a method, so p = Perm._af_new(a) is the only allowed use.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.permutations import Perm\n        >>> Perm.print_cyclic = False\n        >>> a = [2,1,3,0]\n        >>> p = Perm._af_new(a)\n        >>> p\n        Permutation([2, 1, 3, 0])\n\n        \"\"\"\n        if target_cls is None:\n            target_cls = cls\n        p = Basic.__new__(target_cls, perm)\n        p._array_form = perm\n        p._size = len(perm)\n        return p\n",
      "\n        p = Basic.__new__(cls, perm)\n",
      "\n        p = Basic.__new__(cls, perm)\n",
      "\n        p = Basic.__new__(cls, perm)\n",
      "\n    @classmethod\n    def _af_new(cls, perm, target_cls=None):\n        \"\"\"A method to produce a Permutation object from a list;\n        the list is not checked for being a permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.permutations import Perm\n        >>> Perm.print_cyclic = False\n        >>> a = [2,1,3,0]\n        >>> p = Perm._af_new(a)\n        >>> p\n        Permutation([2, 1, 3, 0])\n\n        \"\"\"\n        if target_cls is None:\n            target_cls = cls\n        p = Basic.__new__(target_cls, perm)\n        p._array_form = perm\n        p._size = len(perm)\n        return p\n",
      "\n    @classmethod\n    def _af_new(cls, perm, target_cls=None):\n        \"\"\"A method to produce a Permutation object from a list;\n        the list is bound to the _array_form attribute, so it must\n        not be modified; this method is meant for internal use only;\n        the list ``a`` is supposed to be generated as a temporary value\n        in a method, so p = Perm._af_new(a) is the only, legal use\n        of this method; ``_af_new`` is not supposed to be used to generate\n        Permutation objects that hold references to existing lists.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.permutations import Perm\n        >>> Perm.print_cyclic = False\n        >>> a = [2,1,3,0]\n        >>> p = Perm._af_new(a)\n        >>> p\n        Permutation([2, 1, 3, 0])\n\n        \"\"\"\n        if target_cls is None:\n            target_cls = cls\n        p = Basic.__new__(target_cls, perm)\n        p._array_form = perm\n        p._size = len(perm)\n        return p\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4ac1c2ef3b..2addc79e90 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,23 @@ def __new__(cls, *args, **kwargs):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+\n+            return cls._af_new(list(range(size or 0)), cls)\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+\n+            return cls._af_new(Cycle(*args).list(size), cls)\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+\n+                return cls._af_new(a.list(size), cls)\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)), cls)\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -944,7 +948,29 @@ def _af_new(perm):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+\n+    @staticmethod\n+    def _af_new(perm, cls=None):\n+        \"\"\"A method to produce a Permutation object from a list;\n+        the list is not checked for being a permutation.\n+\n+        Examples\n+        ========\n+\n+        >>> from sympy.combinatorics.permutations import Perm\n+        >>> Perm.print_cyclic = False\n+        >>> a = [2,1,3,0]\n+        >>> p = Perm._af_new(a)\n+        >>> p\n+        Permutation([2, 1, 3, 0])\n+\n+        \"\"\"\n+        if cls is None:\n+            cls = Perm\n+        p = Basic.__new__(cls, perm)\n+        p._array_form = perm\n+        p._size = len(perm)\n+        return p\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n",
    "variant_0": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4ac1c2ef3b..6c29aa2307 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,25 @@ def __new__(cls, *args, **kwargs):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+\n+            return cls._af_new(list(range(size or 0)), cls)\n+        elif len(args) > 1:  # c\n+\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+            return cls._af_new(Cycle(*args).list(size), cls)\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+\n+            if isinstance(a, Cycle):  # f\n+                return cls._af_new(a.list(size), cls)\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)), cls)\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -944,7 +950,8 @@ def _af_new(perm):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n",
    "variant_1": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4ac1c2ef3b..a14b3bf9bf 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,22 @@ def __new__(cls, *args, **kwargs):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+\n+            return cls._af_new(list(range(size or 0)), cls)\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+\n+            return cls._af_new(Cycle(*args).list(size), cls)\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)), cls)\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -944,7 +947,8 @@ def _af_new(perm):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n",
    "variant_2": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4ac1c2ef3b..0bec4bd72d 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,22 @@ def __new__(cls, *args, **kwargs):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+\n+            return cls._af_new(list(range(size or 0)), cls)\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+\n+            return cls._af_new(Cycle(*args).list(size), cls)\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)), cls)\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -944,7 +947,34 @@ def _af_new(perm):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+\n+    @classmethod\n+    def _af_new(cls, perm, target_cls=None):\n+        \"\"\"A method to produce a Permutation object from a list;\n+        the list is bound to the _array_form attribute, so it must\n+        not be modified; this method is meant for internal use only;\n+        the list ``a`` is supposed to be generated as a temporary value\n+        in a method, so p = Perm._af_new(a) is the only use case;\n+        otherwise, the array form should be passed to the constructor\n+        as Perm(a).\n+\n+        Examples\n+        ========\n+\n+        >>> from sympy.combinatorics.permutations import Perm\n+        >>> Perm.print_cyclic = False\n+        >>> a = [2,1,3,0]\n+        >>> p = Perm._af_new(a)\n+        >>> p\n+        Permutation([2, 1, 3, 0])\n+\n+        \"\"\"\n+        if target_cls is None:\n+            target_cls = cls\n+        p = Basic.__new__(target_cls, perm)\n+        p._array_form = perm\n+        p._size = len(perm)\n+        return p\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n",
    "variant_3": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4ac1c2ef3b..37c3f5c0fc 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,24 @@ def __new__(cls, *args, **kwargs):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+\n+            return cls._af_new(list(range(size or 0)), cls)\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+\n+            return cls._af_new(Cycle(*args).list(size), cls)\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+\n+            if isinstance(a, Cycle):  # f\n+                return cls._af_new(a.list(size), cls)\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)), cls)\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -944,7 +949,32 @@ def _af_new(perm):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+\n+    @classmethod\n+    def _af_new(cls, perm, target_cls=None):\n+        \"\"\"A method to produce a Permutation object from a list;\n+        the list is bound to the _array_form attribute, so it must\n+        not be modified; this method is meant for internal use only;\n+        the list ``a`` is supposed to be generated as a temporary value\n+        in a method, so p = Perm._af_new(a) is the only allowed use.\n+\n+        Examples\n+        ========\n+\n+        >>> from sympy.combinatorics.permutations import Perm\n+        >>> Perm.print_cyclic = False\n+        >>> a = [2,1,3,0]\n+        >>> p = Perm._af_new(a)\n+        >>> p\n+        Permutation([2, 1, 3, 0])\n+\n+        \"\"\"\n+        if target_cls is None:\n+            target_cls = cls\n+        p = Basic.__new__(target_cls, perm)\n+        p._array_form = perm\n+        p._size = len(perm)\n+        return p\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n",
    "variant_4": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4ac1c2ef3b..c03fb6e91e 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,24 @@ def __new__(cls, *args, **kwargs):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+\n+            return cls._af_new(list(range(size or 0)), cls)\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+\n+            return cls._af_new(Cycle(*args).list(size), cls)\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+\n+            if isinstance(a, Cycle):  # f\n+                return cls._af_new(a.list(size), cls)\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)), cls)\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -944,7 +949,8 @@ def _af_new(perm):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n",
    "variant_5": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4ac1c2ef3b..c03fb6e91e 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,24 @@ def __new__(cls, *args, **kwargs):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+\n+            return cls._af_new(list(range(size or 0)), cls)\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+\n+            return cls._af_new(Cycle(*args).list(size), cls)\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+\n+            if isinstance(a, Cycle):  # f\n+                return cls._af_new(a.list(size), cls)\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)), cls)\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -944,7 +949,8 @@ def _af_new(perm):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n",
    "variant_6": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4ac1c2ef3b..a63294d34e 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,27 @@ def __new__(cls, *args, **kwargs):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+\n+            return cls._af_new(list(range(size or 0)), cls)\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+\n+            return cls._af_new(Cycle(*args).list(size), cls)\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n-            if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+\n+            if size is None or size == a.size:\n+                return a\n+            return cls(a.array_form, size=size)\n+        if isinstance(a, Cycle):  # f\n+            return cls._af_new(a.list(size), cls)\n+        if not is_sequence(a):  # b\n+            return cls._af_new(list(range(a + 1)), cls)\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -944,7 +952,8 @@ def _af_new(perm):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+\n+        p = Basic.__new__(cls, perm)\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n",
    "variant_7": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4ac1c2ef3b..f5d01e4343 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,24 @@ def __new__(cls, *args, **kwargs):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+\n+            return cls._af_new(list(range(size or 0)), cls)\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+\n+            return cls._af_new(Cycle(*args).list(size), cls)\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+\n+            if isinstance(a, Cycle):  # f\n+                return cls._af_new(a.list(size), cls)\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)), cls)\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -944,7 +949,29 @@ def _af_new(perm):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+\n+    @classmethod\n+    def _af_new(cls, perm, target_cls=None):\n+        \"\"\"A method to produce a Permutation object from a list;\n+        the list is not checked for being a permutation.\n+\n+        Examples\n+        ========\n+\n+        >>> from sympy.combinatorics.permutations import Perm\n+        >>> Perm.print_cyclic = False\n+        >>> a = [2,1,3,0]\n+        >>> p = Perm._af_new(a)\n+        >>> p\n+        Permutation([2, 1, 3, 0])\n+\n+        \"\"\"\n+        if target_cls is None:\n+            target_cls = cls\n+        p = Basic.__new__(target_cls, perm)\n+        p._array_form = perm\n+        p._size = len(perm)\n+        return p\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n",
    "variant_8": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 4ac1c2ef3b..fe078a6925 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -857,19 +857,22 @@ def __new__(cls, *args, **kwargs):\n         #g) (Permutation) = adjust size or return copy\n         ok = True\n         if not args:  # a\n-            return _af_new(list(range(size or 0)))\n+\n+            return cls._af_new(list(range(size or 0)), cls)\n         elif len(args) > 1:  # c\n-            return _af_new(Cycle(*args).list(size))\n+\n+            return cls._af_new(Cycle(*args).list(size), cls)\n         if len(args) == 1:\n             a = args[0]\n             if isinstance(a, Perm):  # g\n                 if size is None or size == a.size:\n                     return a\n-                return Perm(a.array_form, size=size)\n+\n+                return cls(a.array_form, size=size)\n             if isinstance(a, Cycle):  # f\n-                return _af_new(a.list(size))\n+\n             if not is_sequence(a):  # b\n-                return _af_new(list(range(a + 1)))\n+                return cls._af_new(list(range(a + 1)), cls)\n             if has_variety(is_sequence(ai) for ai in a):\n                 ok = False\n         else:\n@@ -944,7 +947,34 @@ def _af_new(perm):\n         Permutation([2, 1, 3, 0])\n \n         \"\"\"\n-        p = Basic.__new__(Perm, perm)\n+\n+    @classmethod\n+    def _af_new(cls, perm, target_cls=None):\n+        \"\"\"A method to produce a Permutation object from a list;\n+        the list is bound to the _array_form attribute, so it must\n+        not be modified; this method is meant for internal use only;\n+        the list ``a`` is supposed to be generated as a temporary value\n+        in a method, so p = Perm._af_new(a) is the only, legal use\n+        of this method; ``_af_new`` is not supposed to be used to generate\n+        Permutation objects that hold references to existing lists.\n+\n+        Examples\n+        ========\n+\n+        >>> from sympy.combinatorics.permutations import Perm\n+        >>> Perm.print_cyclic = False\n+        >>> a = [2,1,3,0]\n+        >>> p = Perm._af_new(a)\n+        >>> p\n+        Permutation([2, 1, 3, 0])\n+\n+        \"\"\"\n+        if target_cls is None:\n+            target_cls = cls\n+        p = Basic.__new__(target_cls, perm)\n+        p._array_form = perm\n+        p._size = len(perm)\n+        return p\n         p._array_form = perm\n         p._size = len(perm)\n         return p\n"
  }
}