{
  "zero_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/colors.py lines 1475-1477)": "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme values that may produce non-finite results\n            if not np.isfinite(t_vmin):\n                t_vmin = np.log(self.vmin) if self.vmin > 0 else -np.inf\n            if not np.isfinite(t_vmax):\n                t_vmax = np.log(self.vmax) if self.vmax > 0 else -np.inf\n            \n            # Clamp extreme logarithmic values to prevent overflow\n            t_vmin = max(t_vmin, -1000) if np.isfinite(t_vmin) else -1000\n            t_vmax = min(t_vmax, 1000) if np.isfinite(t_vmax) else 1000\n            \n            if t_vmin >= t_vmax:\n                raise ValueError(\"Invalid vmin or vmax\")\n",
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/colors.py lines 1488-1490)": "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme logarithmic values gracefully\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Clamp non-finite transformed values to reasonable bounds\n                if not np.isfinite(t_vmin):\n                    t_vmin = -1000.0 if t_vmin == -np.inf else 1000.0\n                if not np.isfinite(t_vmax):\n                    t_vmax = 1000.0 if t_vmax == np.inf else -1000.0\n                # Ensure proper ordering after clamping\n                if t_vmin > t_vmax:\n                    t_vmin, t_vmax = t_vmax, t_vmin\n",
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/scale.py lines 217-237)": "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n            # Handle extreme values that may cause overflow/non-finite results\n            # Clamp to reasonable finite bounds to prevent downstream failures\n            finite_mask = np.isfinite(out)\n            if not np.all(finite_mask):\n                # For positive overflow, clamp to a large but finite value\n                out[np.isposinf(out)] = 1000\n                # For negative overflow (should be rare with clipping), clamp appropriately\n                out[np.isneginf(out)] = -1000\n                # Handle NaN values\n                out[np.isnan(out)] = -1000 if self._clip else np.nan\n        return out\n",
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/colors.py lines 1542-1544)": "\n@_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\nclass LogNorm(Normalize):\n    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n",
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/tests/test_image.py lines 1237-1252)": "\n@check_figures_equal(extensions=['png'])\ndef test_huge_range_log(fig_test, fig_ref):\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1E20\n\n    ax = fig_test.subplots()\n    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap='viridis')\n\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1000\n\n    cmap = copy(plt.get_cmap('viridis'))\n    cmap.set_under('w')\n    ax = fig_ref.subplots()\n    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap=cmap)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/matplotlib/lib/matplotlib/colors.py lines 1475-1477)": [
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme logarithmic values that may produce non-finite results\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # For extreme values, clamp to reasonable finite bounds while preserving order\n                if not np.isfinite(t_vmin):\n                    t_vmin = -700.0 if self.vmin <= 0 else np.log(np.finfo(float).tiny)\n                if not np.isfinite(t_vmax):\n                    t_vmax = 700.0  # Reasonable upper bound for log transformation\n                # Ensure proper ordering is maintained\n                if t_vmin >= t_vmax:\n                    t_vmax = t_vmin + 1.0\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme logarithmic values that may produce non-finite results\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # For logarithmic transforms, clamp extreme values to reasonable finite bounds\n                # while preserving the relative scaling relationship\n                if not np.isfinite(t_vmin):\n                    t_vmin = np.log(np.finfo(float).tiny) if self.vmin > 0 else -700\n                if not np.isfinite(t_vmax):\n                    t_vmax = np.log(np.finfo(float).max) if self.vmax > 0 else 700\n                # Ensure we still have a valid range after clamping\n                if t_vmin >= t_vmax:\n                    t_vmax = t_vmin + 1\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme logarithmic values that may become non-finite\n            if not np.isfinite(t_vmin):\n                t_vmin = np.log10(np.finfo(float).tiny) if self.vmin > 0 else -np.inf\n            if not np.isfinite(t_vmax):\n                t_vmax = np.log10(np.finfo(float).max)\n            if not np.isfinite([t_vmin, t_vmax]).all() or t_vmin >= t_vmax:\n                raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme logarithmic values that may become non-finite\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # For logarithmic transforms, clamp extreme values to reasonable bounds\n                # while preserving the relative scaling\n                if not np.isfinite(t_vmin):\n                    t_vmin = np.log10(np.finfo(float).tiny) if hasattr(self._trf, 'base') else -700\n                if not np.isfinite(t_vmax):\n                    t_vmax = np.log10(np.finfo(float).max) if hasattr(self._trf, 'base') else 700\n                # Ensure vmin < vmax relationship is maintained\n                if t_vmin >= t_vmax:\n                    t_vmax = t_vmin + 1\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme logarithmic values that may produce non-finite results\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # For logarithmic scales, clamp extreme transformed values to prevent overflow\n                if not np.isfinite(t_vmin):\n                    t_vmin = np.log10(np.finfo(float).tiny) if self.vmin > 0 else -700\n                if not np.isfinite(t_vmax):\n                    t_vmax = np.log10(np.finfo(float).max) if self.vmax > 0 else 700\n                # Final sanity check - if still non-finite, fall back to safe defaults\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme values that may produce non-finite results\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Clamp extremely large or small transformed values to finite bounds\n                if not np.isfinite(t_vmin):\n                    t_vmin = -700.0 if t_vmin == -np.inf else 700.0\n                if not np.isfinite(t_vmax):\n                    t_vmax = -700.0 if t_vmax == -np.inf else 700.0\n                # Final safety check - if still invalid, raise error\n                if not np.isfinite([t_vmin, t_vmax]).all() or t_vmin >= t_vmax:\n                    raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Handle extreme values by clamping to finite ranges\n                if not np.isfinite(t_vmin):\n                    t_vmin = np.log(np.finfo(float).tiny) if self.vmin > 0 else -np.inf\n                if not np.isfinite(t_vmax):\n                    t_vmax = np.log(np.finfo(float).max) if self.vmax > 0 else np.inf\n                # If both are still non-finite or equal, fall back to safe defaults\n                if not np.isfinite([t_vmin, t_vmax]).all() or t_vmin == t_vmax:\n                    t_vmin, t_vmax = 0, 1\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme logarithmic values that may produce non-finite results\n            if not np.isfinite(t_vmin):\n                t_vmin = np.log10(np.finfo(float).tiny) if self.vmin > 0 else -np.inf\n            if not np.isfinite(t_vmax):\n                t_vmax = np.log10(np.finfo(float).max)\n            if not np.isfinite([t_vmin, t_vmax]).all() or t_vmin >= t_vmax:\n                raise ValueError(\"Invalid vmin or vmax\")\n"
    ],
    "Location 2 (/root/hy/projects/matplotlib/lib/matplotlib/colors.py lines 1488-1490)": [
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Handle extreme values by clamping to reasonable finite bounds\n                if not np.isfinite(t_vmin):\n                    t_vmin = -1000.0 if t_vmin == -np.inf else 1000.0\n                if not np.isfinite(t_vmax):\n                    t_vmax = 1000.0 if t_vmax == np.inf else -1000.0\n                # Ensure proper ordering after clamping\n                if t_vmin >= t_vmax:\n                    t_vmin, t_vmax = -1000.0, 1000.0\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.ma.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value)\n            t_value -= t_vmin\n            t_value /= (t_vmax - t_vmin)\n            t_value = np.ma.masked_invalid(t_value, copy=False)\n            return t_value[0] if is_scalar else t_value\n",
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme values that may produce non-finite results\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # For extreme ranges, clamp transformed values to reasonable bounds\n                if not np.isfinite(t_vmin):\n                    t_vmin = -700 if t_vmin == -np.inf else 700\n                if not np.isfinite(t_vmax):\n                    t_vmax = -700 if t_vmax == -np.inf else 700\n                # If both are still problematic after clamping, fall back to identity\n                if t_vmin == t_vmax:\n                    t_vmax = t_vmin + 1\n",
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme logarithmic values gracefully\n            if not np.isfinite(t_vmin):\n                t_vmin = np.log(np.finfo(float).tiny) if self.vmin > 0 else -700\n            if not np.isfinite(t_vmax):\n                t_vmax = np.log(np.finfo(float).max) if self.vmax > 0 else 700\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n        # Handle extreme logarithmic values that may produce non-finite results\n        if not np.isfinite(t_vmin):\n            t_vmin = np.log10(np.finfo(float).tiny) if self.vmin > 0 else -np.inf\n        if not np.isfinite(t_vmax):\n            t_vmax = np.log10(np.finfo(float).max)\n        if not np.isfinite([t_vmin, t_vmax]).any():\n            raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0.)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme values that may produce non-finite results\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # For log transforms, clamp extreme values to reasonable bounds\n                if hasattr(self._trf, '_base') or 'log' in str(type(self._trf)).lower():\n                    t_vmin = max(t_vmin, -700) if np.isfinite(t_vmin) else -700\n                    t_vmax = min(t_vmax, 700) if np.isfinite(t_vmax) else 700\n                else:\n                    raise ValueError(\"Invalid vmin or vmax\")\n            # Also handle non-finite values in the transformed data\n            t_value = np.where(np.isfinite(t_value), t_value, \n                              np.where(t_value > 0, t_vmax, t_vmin))\n            t_value -= t_vmin\n            t_value /= (t_vmax - t_vmin)\n            t_value = np.ma.masked_invalid(t_value, copy=False)\n            return t_value[0] if is_scalar else t_value\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme logarithmic values gracefully\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Clamp extreme transformed values to reasonable finite bounds\n                if not np.isfinite(t_vmin):\n                    t_vmin = -700 if t_vmin == -np.inf else 700\n                if not np.isfinite(t_vmax):\n                    t_vmax = -700 if t_vmax == -np.inf else 700\n                # Ensure vmin <= vmax relationship is maintained\n                if t_vmin > t_vmax:\n                    t_vmin, t_vmax = t_vmax, t_vmin\n",
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle non-finite transformed values gracefully\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Clamp extreme values to reasonable finite bounds\n                if not np.isfinite(t_vmin):\n                    t_vmin = -700 if t_vmin == -np.inf else 700\n                if not np.isfinite(t_vmax):\n                    t_vmax = -700 if t_vmax == -np.inf else 700\n                # Ensure proper ordering after clamping\n                if t_vmin > t_vmax:\n                    t_vmin, t_vmax = t_vmax, t_vmin\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # Handle extreme logarithmic values that may become non-finite\n            if not np.isfinite(t_vmin):\n                t_vmin = np.log10(np.finfo(float).tiny) if t_vmin == -np.inf else np.log10(np.finfo(float).max)\n            if not np.isfinite(t_vmax):\n                t_vmax = np.log10(np.finfo(float).max) if t_vmax == np.inf else np.log10(np.finfo(float).tiny)\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n"
    ],
    "Location 3 (/root/hy/projects/matplotlib/lib/matplotlib/scale.py lines 217-237)": [
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n                # Clamp extremely large logarithmic values to prevent overflow\n                # Use a reasonable upper bound that works with downstream processing\n                out = np.clip(out, -1000, 1000)\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n                # Clamp extremely large logarithmic values to prevent overflow\n                out = np.clip(out, -1000, 1000)\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n                # Also clip extremely large logarithmic values to prevent overflow\n                out[out > 1000] = 1000\n                out[~np.isfinite(out)] = 1000\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n                # Clamp extremely large logarithmic values to prevent overflow\n                out = np.clip(out, -1000, 1000)\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n                # Clamp extremely large finite values to prevent downstream overflow\n                out = np.clip(out, -1000, 1000)\n            else:\n                # For mask mode, ensure extreme finite values don't cause issues\n                finite_mask = np.isfinite(out)\n                out = np.where(finite_mask, np.clip(out, -1000, 1000), out)\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n                # Clamp extremely large logarithmic values to prevent overflow\n                out = np.clip(out, -1000, 1000)\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n                # Handle extremely large logarithmic values that could cause overflow\n                # Clamp to reasonable finite bounds to prevent non-finite results\n                out = np.clip(out, -1000, 1000)\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n                # Clamp extremely large logarithmic values to prevent overflow\n                # in downstream operations while maintaining finite values\n                out = np.clip(out, -1000, 1000)\n        return out\n"
    ],
    "Location 4 (/root/hy/projects/matplotlib/lib/matplotlib/colors.py lines 1542-1544)": [
      "\n@_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\nclass LogNorm(Normalize):\n    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n",
      "\n@_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\nclass LogNorm(Normalize):\n    \"\"\"\n    Normalize a given value to the 0-1 range on a log scale.\n    \n    Handles extreme value ranges gracefully by clamping non-finite\n    logarithmic transformations to reasonable bounds while preserving\n    the logarithmic relationship.\n    \"\"\"\n",
      "\n@_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\nclass LogNorm(Normalize):\n    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n",
      "\n@_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\nclass LogNorm(Normalize):\n    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n",
      "\n@_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\nclass LogNorm(Normalize):\n    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n",
      "\n@_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\nclass LogNorm(Normalize):\n    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n",
      "\n@_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\nclass LogNorm(Normalize):\n    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n",
      "\n@_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\nclass LogNorm(Normalize):\n    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n"
    ],
    "Location 5 (/root/hy/projects/matplotlib/lib/matplotlib/tests/test_image.py lines 1237-1252)": [
      "\n@check_figures_equal(extensions=['png'])\ndef test_huge_range_log(fig_test, fig_ref):\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1E20\n\n    ax = fig_test.subplots()\n    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap='viridis')\n\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1000\n\n    cmap = copy(plt.get_cmap('viridis'))\n    cmap.set_under('w')\n    ax = fig_ref.subplots()\n    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap=cmap)\n",
      "\n@check_figures_equal(extensions=['png'])\ndef test_huge_range_log(fig_test, fig_ref):\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1E20\n\n    ax = fig_test.subplots()\n    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap='viridis')\n\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1000\n\n    cmap = copy(plt.get_cmap('viridis'))\n    cmap.set_under('w')\n    ax = fig_ref.subplots()\n    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap=cmap)\n",
      "\n@check_figures_equal(extensions=['png'])\ndef test_huge_range_log(fig_test, fig_ref):\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1E20\n\n    ax = fig_test.subplots()\n    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap='viridis')\n\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1000\n\n    cmap = copy(plt.get_cmap('viridis'))\n    cmap.set_under('w')\n    ax = fig_ref.subplots()\n    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap=cmap)\n",
      "\n@check_figures_equal(extensions=['png'])\ndef test_huge_range_log(fig_test, fig_ref):\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1E20\n\n    ax = fig_test.subplots()\n    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap='viridis')\n\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1000\n\n    cmap = copy(plt.get_cmap('viridis'))\n    cmap.set_under('w')\n    ax = fig_ref.subplots()\n    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap=cmap)\n",
      "\n@check_figures_equal(extensions=['png'])\ndef test_huge_range_log(fig_test, fig_ref):\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1E20\n\n    ax = fig_test.subplots()\n    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap='viridis')\n\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1000\n\n    cmap = copy(plt.get_cmap('viridis'))\n    cmap.set_under('w')\n    ax = fig_ref.subplots()\n    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap=cmap)\n",
      "\n@check_figures_equal(extensions=['png'])\ndef test_huge_range_log(fig_test, fig_ref):\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1E20\n\n    ax = fig_test.subplots()\n    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap='viridis')\n\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1000\n\n    cmap = copy(plt.get_cmap('viridis'))\n    cmap.set_under('w')\n    ax = fig_ref.subplots()\n    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap=cmap)\n",
      "\n@check_figures_equal(extensions=['png'])\ndef test_huge_range_log(fig_test, fig_ref):\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1E20\n\n    ax = fig_test.subplots()\n    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap='viridis')\n\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1000\n\n    cmap = copy(plt.get_cmap('viridis'))\n    cmap.set_under('w')\n    ax = fig_ref.subplots()\n    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap=cmap)\n",
      "\ndef test_huge_range_log(fig_test, fig_ref):\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1E20\n\n    ax = fig_test.subplots()\n    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap='viridis')\n\n    data = np.full((5, 5), -1, dtype=np.float64)\n    data[0:2, :] = 1000\n\n    cmap = copy(plt.get_cmap('viridis'))\n    cmap.set_under('w')\n    ax = fig_ref.subplots()\n    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n                   interpolation='nearest', cmap=cmap)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..5495d1ebeb 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1472,7 +1472,13 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme values that may produce non-finite logarithmic transforms\n+            if not np.isfinite(t_vmin):\n+                t_vmin = -1000 if t_vmin == -np.inf else (1000 if t_vmin == np.inf else t_vmin)\n+            if not np.isfinite(t_vmax):\n+                t_vmax = -1000 if t_vmax == -np.inf else (1000 if t_vmax == np.inf else t_vmax)\n             if not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n@@ -1485,7 +1491,13 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme values that may produce non-finite logarithmic transforms\n+            if not np.isfinite(t_vmin):\n+                t_vmin = -1000 if t_vmin == -np.inf else (1000 if t_vmin == np.inf else t_vmin)\n+            if not np.isfinite(t_vmax):\n+                t_vmax = -1000 if t_vmax == -np.inf else (1000 if t_vmax == np.inf else t_vmax)\n             if not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n@@ -1539,6 +1551,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n     \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex 62dc5192a3..d147137e6e 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -214,6 +214,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -234,6 +235,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+                # Handle extremely large values that may cause overflow in logarithmic domain\n+                # Clamp to reasonable finite bounds similar to negative value handling\n+                out = np.clip(out, -1000, 1000)\n         return out\n \n     def inverted(self):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..8acf9d30ed 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1234,6 +1234,7 @@ def test_imshow_quantitynd():\n \n \n @check_figures_equal(extensions=['png'])\n+\n def test_huge_range_log(fig_test, fig_ref):\n     data = np.full((5, 5), -1, dtype=np.float64)\n     data[0:2, :] = 1E20\n",
    "variant_0": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..0e2ef36be8 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1472,22 +1472,47 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # Handle extreme values that may produce non-finite results\n+            if not np.isfinite(t_vmin):\n+                t_vmin = np.log(self.vmin) if self.vmin > 0 else -np.inf\n+            if not np.isfinite(t_vmax):\n+                t_vmax = np.log(self.vmax) if self.vmax > 0 else -np.inf\n+            \n+            # Clamp extreme logarithmic values to prevent overflow\n+            t_vmin = max(t_vmin, -1000) if np.isfinite(t_vmin) else -1000\n+            t_vmax = min(t_vmax, 1000) if np.isfinite(t_vmax) else 1000\n+            \n+            if t_vmin >= t_vmax:\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n             return t_value[0] if is_scalar else t_value\n \n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+\n         def inverse(self, value):\n             if not self.scaled():\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme logarithmic values gracefully\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Clamp non-finite transformed values to reasonable bounds\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = -1000.0 if t_vmin == -np.inf else 1000.0\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = 1000.0 if t_vmax == np.inf else -1000.0\n+                # Ensure proper ordering after clamping\n+                if t_vmin > t_vmax:\n+                    t_vmin, t_vmax = t_vmax, t_vmin\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1539,6 +1564,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n     \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex 62dc5192a3..5316e17b55 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -214,6 +214,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -234,6 +235,16 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+            # Handle extreme values that may cause overflow/non-finite results\n+            # Clamp to reasonable finite bounds to prevent downstream failures\n+            finite_mask = np.isfinite(out)\n+            if not np.all(finite_mask):\n+                # For positive overflow, clamp to a large but finite value\n+                out[np.isposinf(out)] = 1000\n+                # For negative overflow (should be rare with clipping), clamp appropriately\n+                out[np.isneginf(out)] = -1000\n+                # Handle NaN values\n+                out[np.isnan(out)] = -1000 if self._clip else np.nan\n         return out\n \n     def inverted(self):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..276a098afd 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1233,6 +1233,8 @@ def test_imshow_quantitynd():\n     fig.canvas.draw()\n \n \n+@check_figures_equal(extensions=['png'])\n+\n @check_figures_equal(extensions=['png'])\n def test_huge_range_log(fig_test, fig_ref):\n     data = np.full((5, 5), -1, dtype=np.float64)\n",
    "variant_1": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..670e31ad38 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1472,9 +1472,18 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme logarithmic values that may produce non-finite results\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # For extreme values, clamp to reasonable finite bounds while preserving order\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = -700.0 if self.vmin <= 0 else np.log(np.finfo(float).tiny)\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = 700.0  # Reasonable upper bound for log transformation\n+                # Ensure proper ordering is maintained\n+                if t_vmin >= t_vmax:\n+                    t_vmax = t_vmin + 1.0\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1485,9 +1494,31 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n+        def __call__(self, value, clip=None):\n+            value, is_scalar = self.process_value(value)\n+            self.autoscale_None(value)\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Handle extreme values by clamping to reasonable finite bounds\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = -1000.0 if t_vmin == -np.inf else 1000.0\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = 1000.0 if t_vmax == np.inf else -1000.0\n+                # Ensure proper ordering after clamping\n+                if t_vmin >= t_vmax:\n+                    t_vmin, t_vmax = -1000.0, 1000.0\n+            if clip is None:\n+                clip = self.clip\n+            if clip:\n+                value = np.ma.clip(value, self.vmin, self.vmax)\n+            t_value = self._trf.transform(value)\n+            t_value -= t_vmin\n+            t_value /= (t_vmax - t_vmin)\n+            t_value = np.ma.masked_invalid(t_value, copy=False)\n+            return t_value[0] if is_scalar else t_value\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1539,6 +1570,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n     \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex 62dc5192a3..2fac347ce2 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -214,6 +214,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -234,6 +235,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+                # Clamp extremely large logarithmic values to prevent overflow\n+                # Use a reasonable upper bound that works with downstream processing\n+                out = np.clip(out, -1000, 1000)\n         return out\n \n     def inverted(self):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..276a098afd 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1233,6 +1233,8 @@ def test_imshow_quantitynd():\n     fig.canvas.draw()\n \n \n+@check_figures_equal(extensions=['png'])\n+\n @check_figures_equal(extensions=['png'])\n def test_huge_range_log(fig_test, fig_ref):\n     data = np.full((5, 5), -1, dtype=np.float64)\n",
    "variant_2": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..1f81ba3362 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1472,22 +1472,46 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme logarithmic values that may produce non-finite results\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # For logarithmic transforms, clamp extreme values to reasonable finite bounds\n+                # while preserving the relative scaling relationship\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = np.log(np.finfo(float).tiny) if self.vmin > 0 else -700\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = np.log(np.finfo(float).max) if self.vmax > 0 else 700\n+                # Ensure we still have a valid range after clamping\n+                if t_vmin >= t_vmax:\n+                    t_vmax = t_vmin + 1\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n             return t_value[0] if is_scalar else t_value\n \n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+\n         def inverse(self, value):\n             if not self.scaled():\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme values that may produce non-finite results\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # For extreme ranges, clamp transformed values to reasonable bounds\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = -700 if t_vmin == -np.inf else 700\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = -700 if t_vmax == -np.inf else 700\n+                # If both are still problematic after clamping, fall back to identity\n+                if t_vmin == t_vmax:\n+                    t_vmax = t_vmin + 1\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1539,9 +1563,16 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n-    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n+    \"\"\"\n+    Normalize a given value to the 0-1 range on a log scale.\n+    \n+    Handles extreme value ranges gracefully by clamping non-finite\n+    logarithmic transformations to reasonable bounds while preserving\n+    the logarithmic relationship.\n+    \"\"\"\n \n     def autoscale(self, A):\n         # docstring inherited.\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex 62dc5192a3..db1feeb375 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -214,6 +214,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -234,6 +235,8 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+                # Clamp extremely large logarithmic values to prevent overflow\n+                out = np.clip(out, -1000, 1000)\n         return out\n \n     def inverted(self):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..276a098afd 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1233,6 +1233,8 @@ def test_imshow_quantitynd():\n     fig.canvas.draw()\n \n \n+@check_figures_equal(extensions=['png'])\n+\n @check_figures_equal(extensions=['png'])\n def test_huge_range_log(fig_test, fig_ref):\n     data = np.full((5, 5), -1, dtype=np.float64)\n",
    "variant_3": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..6312892c77 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1472,20 +1472,37 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # Handle extreme logarithmic values that may become non-finite\n+            if not np.isfinite(t_vmin):\n+                t_vmin = np.log10(np.finfo(float).tiny) if self.vmin > 0 else -np.inf\n+            if not np.isfinite(t_vmax):\n+                t_vmax = np.log10(np.finfo(float).max)\n+            if not np.isfinite([t_vmin, t_vmax]).all() or t_vmin >= t_vmax:\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n             return t_value[0] if is_scalar else t_value\n \n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+\n         def inverse(self, value):\n             if not self.scaled():\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme logarithmic values gracefully\n+            if not np.isfinite(t_vmin):\n+                t_vmin = np.log(np.finfo(float).tiny) if self.vmin > 0 else -700\n+            if not np.isfinite(t_vmax):\n+                t_vmax = np.log(np.finfo(float).max) if self.vmax > 0 else 700\n             if not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n@@ -1539,6 +1556,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n     \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex 62dc5192a3..c12c6cd4bc 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -214,6 +214,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -234,6 +235,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+                # Also clip extremely large logarithmic values to prevent overflow\n+                out[out > 1000] = 1000\n+                out[~np.isfinite(out)] = 1000\n         return out\n \n     def inverted(self):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..276a098afd 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1233,6 +1233,8 @@ def test_imshow_quantitynd():\n     fig.canvas.draw()\n \n \n+@check_figures_equal(extensions=['png'])\n+\n @check_figures_equal(extensions=['png'])\n def test_huge_range_log(fig_test, fig_ref):\n     data = np.full((5, 5), -1, dtype=np.float64)\n",
    "variant_4": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..6c5cc90111 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1472,9 +1472,19 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme logarithmic values that may become non-finite\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # For logarithmic transforms, clamp extreme values to reasonable bounds\n+                # while preserving the relative scaling\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = np.log10(np.finfo(float).tiny) if hasattr(self._trf, 'base') else -700\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = np.log10(np.finfo(float).max) if hasattr(self._trf, 'base') else 700\n+                # Ensure vmin < vmax relationship is maintained\n+                if t_vmin >= t_vmax:\n+                    t_vmax = t_vmin + 1\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1485,9 +1495,15 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+\n+        t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+        # Handle extreme logarithmic values that may produce non-finite results\n+        if not np.isfinite(t_vmin):\n+            t_vmin = np.log10(np.finfo(float).tiny) if self.vmin > 0 else -np.inf\n+        if not np.isfinite(t_vmax):\n+            t_vmax = np.log10(np.finfo(float).max)\n+        if not np.isfinite([t_vmin, t_vmax]).any():\n+            raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1539,6 +1555,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n     \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex 62dc5192a3..db1feeb375 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -214,6 +214,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -234,6 +235,8 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+                # Clamp extremely large logarithmic values to prevent overflow\n+                out = np.clip(out, -1000, 1000)\n         return out\n \n     def inverted(self):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..276a098afd 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1233,6 +1233,8 @@ def test_imshow_quantitynd():\n     fig.canvas.draw()\n \n \n+@check_figures_equal(extensions=['png'])\n+\n @check_figures_equal(extensions=['png'])\n def test_huge_range_log(fig_test, fig_ref):\n     data = np.full((5, 5), -1, dtype=np.float64)\n",
    "variant_5": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..75dfd17c67 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1472,9 +1472,18 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme logarithmic values that may produce non-finite results\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # For logarithmic scales, clamp extreme transformed values to prevent overflow\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = np.log10(np.finfo(float).tiny) if self.vmin > 0 else -700\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = np.log10(np.finfo(float).max) if self.vmax > 0 else 700\n+                # Final sanity check - if still non-finite, fall back to safe defaults\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1485,9 +1494,35 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n+        def __call__(self, value, clip=None):\n+            value, is_scalar = self.process_value(value)\n+            self.autoscale_None(value)\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+            if self.vmin == self.vmax:\n+                return np.full_like(value, 0.)\n+            if clip is None:\n+                clip = self.clip\n+            if clip:\n+                value = np.clip(value, self.vmin, self.vmax)\n+            t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme values that may produce non-finite results\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # For log transforms, clamp extreme values to reasonable bounds\n+                if hasattr(self._trf, '_base') or 'log' in str(type(self._trf)).lower():\n+                    t_vmin = max(t_vmin, -700) if np.isfinite(t_vmin) else -700\n+                    t_vmax = min(t_vmax, 700) if np.isfinite(t_vmax) else 700\n+                else:\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            # Also handle non-finite values in the transformed data\n+            t_value = np.where(np.isfinite(t_value), t_value, \n+                              np.where(t_value > 0, t_vmax, t_vmin))\n+            t_value -= t_vmin\n+            t_value /= (t_vmax - t_vmin)\n+            t_value = np.ma.masked_invalid(t_value, copy=False)\n+            return t_value[0] if is_scalar else t_value\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1539,6 +1574,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n     \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex 62dc5192a3..7fb00c65a6 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -214,6 +214,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -234,6 +235,12 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+                # Clamp extremely large finite values to prevent downstream overflow\n+                out = np.clip(out, -1000, 1000)\n+            else:\n+                # For mask mode, ensure extreme finite values don't cause issues\n+                finite_mask = np.isfinite(out)\n+                out = np.where(finite_mask, np.clip(out, -1000, 1000), out)\n         return out\n \n     def inverted(self):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..276a098afd 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1233,6 +1233,8 @@ def test_imshow_quantitynd():\n     fig.canvas.draw()\n \n \n+@check_figures_equal(extensions=['png'])\n+\n @check_figures_equal(extensions=['png'])\n def test_huge_range_log(fig_test, fig_ref):\n     data = np.full((5, 5), -1, dtype=np.float64)\n",
    "variant_6": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..bb05761e34 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1472,9 +1472,18 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme values that may produce non-finite results\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Clamp extremely large or small transformed values to finite bounds\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = -700.0 if t_vmin == -np.inf else 700.0\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = -700.0 if t_vmax == -np.inf else 700.0\n+                # Final safety check - if still invalid, raise error\n+                if not np.isfinite([t_vmin, t_vmax]).all() or t_vmin >= t_vmax:\n+                    raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1485,9 +1494,18 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme logarithmic values gracefully\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Clamp extreme transformed values to reasonable finite bounds\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = -700 if t_vmin == -np.inf else 700\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = -700 if t_vmax == -np.inf else 700\n+                # Ensure vmin <= vmax relationship is maintained\n+                if t_vmin > t_vmax:\n+                    t_vmin, t_vmax = t_vmax, t_vmin\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1539,6 +1557,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n     \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex 62dc5192a3..db1feeb375 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -214,6 +214,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -234,6 +235,8 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+                # Clamp extremely large logarithmic values to prevent overflow\n+                out = np.clip(out, -1000, 1000)\n         return out\n \n     def inverted(self):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..276a098afd 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1233,6 +1233,8 @@ def test_imshow_quantitynd():\n     fig.canvas.draw()\n \n \n+@check_figures_equal(extensions=['png'])\n+\n @check_figures_equal(extensions=['png'])\n def test_huge_range_log(fig_test, fig_ref):\n     data = np.full((5, 5), -1, dtype=np.float64)\n",
    "variant_7": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..603db4633a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1472,22 +1472,44 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Handle extreme values by clamping to finite ranges\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = np.log(np.finfo(float).tiny) if self.vmin > 0 else -np.inf\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = np.log(np.finfo(float).max) if self.vmax > 0 else np.inf\n+                # If both are still non-finite or equal, fall back to safe defaults\n+                if not np.isfinite([t_vmin, t_vmax]).all() or t_vmin == t_vmax:\n+                    t_vmin, t_vmax = 0, 1\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n             return t_value[0] if is_scalar else t_value\n \n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+\n         def inverse(self, value):\n             if not self.scaled():\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle non-finite transformed values gracefully\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Clamp extreme values to reasonable finite bounds\n+                if not np.isfinite(t_vmin):\n+                    t_vmin = -700 if t_vmin == -np.inf else 700\n+                if not np.isfinite(t_vmax):\n+                    t_vmax = -700 if t_vmax == -np.inf else 700\n+                # Ensure proper ordering after clamping\n+                if t_vmin > t_vmax:\n+                    t_vmin, t_vmax = t_vmax, t_vmin\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1539,6 +1561,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n     \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex 62dc5192a3..e77f0f134c 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -214,6 +214,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -234,6 +235,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+                # Handle extremely large logarithmic values that could cause overflow\n+                # Clamp to reasonable finite bounds to prevent non-finite results\n+                out = np.clip(out, -1000, 1000)\n         return out\n \n     def inverted(self):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..276a098afd 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1233,6 +1233,8 @@ def test_imshow_quantitynd():\n     fig.canvas.draw()\n \n \n+@check_figures_equal(extensions=['png'])\n+\n @check_figures_equal(extensions=['png'])\n def test_huge_range_log(fig_test, fig_ref):\n     data = np.full((5, 5), -1, dtype=np.float64)\n",
    "variant_8": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..301ef22782 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1472,8 +1472,14 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # Handle extreme logarithmic values that may produce non-finite results\n+            if not np.isfinite(t_vmin):\n+                t_vmin = np.log10(np.finfo(float).tiny) if self.vmin > 0 else -np.inf\n+            if not np.isfinite(t_vmax):\n+                t_vmax = np.log10(np.finfo(float).max)\n+            if not np.isfinite([t_vmin, t_vmax]).all() or t_vmin >= t_vmax:\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n@@ -1485,7 +1491,13 @@ def _make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            # Handle extreme logarithmic values that may become non-finite\n+            if not np.isfinite(t_vmin):\n+                t_vmin = np.log10(np.finfo(float).tiny) if t_vmin == -np.inf else np.log10(np.finfo(float).max)\n+            if not np.isfinite(t_vmax):\n+                t_vmax = np.log10(np.finfo(float).max) if t_vmax == np.inf else np.log10(np.finfo(float).tiny)\n             if not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n@@ -1539,6 +1551,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n     \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex 62dc5192a3..989b7710fd 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -214,6 +214,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -234,6 +235,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+                # Clamp extremely large logarithmic values to prevent overflow\n+                # in downstream operations while maintaining finite values\n+                out = np.clip(out, -1000, 1000)\n         return out\n \n     def inverted(self):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..8acf9d30ed 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1234,6 +1234,7 @@ def test_imshow_quantitynd():\n \n \n @check_figures_equal(extensions=['png'])\n+\n def test_huge_range_log(fig_test, fig_ref):\n     data = np.full((5, 5), -1, dtype=np.float64)\n     data[0:2, :] = 1E20\n"
  }
}