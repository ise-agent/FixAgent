{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/ntheory/residue_ntheory.py lines 778-780)": "\n    if not isprime(p):\n        raise NotImplementedError(\"Not implemented for composite p\")\n\n    # Handle the case where a ≡ 0 (mod p)\n    if a % p == 0:\n        if all_roots:\n            return [0]\n        else:\n            return 0\n\n    if (p - 1) % n == 0:\n        return _nthroot_mod1(a, n, p, all_roots)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/ntheory/residue_ntheory.py lines 778-780)": [
      "\n    if not isprime(p):\n        raise NotImplementedError(\"Not implemented for composite p\")\n\n    # Handle the case where a ≡ 0 (mod p)\n    if a % p == 0:\n        if all_roots:\n            return [0]\n        else:\n            return 0\n\n    if (p - 1) % n == 0:\n        return _nthroot_mod1(a, n, p, all_roots)\n",
      "\n\n    if (p - 1) % n == 0:\n        if a % p == 0:\n            # Zero is always a root when a ≡ 0 (mod p)\n            if all_roots:\n                other_roots = _nthroot_mod1(0, n, p, True) or []\n                return [0] if 0 not in other_roots else other_roots\n            else:\n                return 0\n        return _nthroot_mod1(a, n, p, all_roots)\n",
      "\n    if not isprime(p):\n        raise NotImplementedError(\"Not implemented for composite p\")\n\n    # Handle the case where a ≡ 0 (mod p)\n    if a % p == 0:\n        if all_roots:\n            return [0]\n        else:\n            return 0\n\n    if (p - 1) % n == 0:\n        return _nthroot_mod1(a, n, p, all_roots)\n",
      "\n    if not isprime(p):\n        raise NotImplementedError(\"Not implemented for composite p\")\n\n    # Handle the case when a ≡ 0 (mod p)\n    if a % p == 0:\n        if all_roots:\n            return [0]\n        else:\n            return 0\n\n    if (p - 1) % n == 0:\n        return _nthroot_mod1(a, n, p, all_roots)\n",
      "\n    if not isprime(p):\n        raise NotImplementedError(\"Not implemented for composite p\")\n\n    # Handle the case where a ≡ 0 (mod p)\n    if a % p == 0:\n        if all_roots:\n            return [0]\n        else:\n            return 0\n\n    if (p - 1) % n == 0:\n        return _nthroot_mod1(a, n, p, all_roots)\n",
      "\n    if not isprime(p):\n        raise NotImplementedError(\"Not implemented for composite p\")\n\n    # Handle the case where a ≡ 0 (mod p)\n    if a % p == 0:\n        if all_roots:\n            return [0]\n        else:\n            return 0\n\n    if (p - 1) % n == 0:\n        return _nthroot_mod1(a, n, p, all_roots)\n",
      "\n\n    if a % p == 0:\n        # When a ≡ 0 (mod p), x = 0 is always a root since 0^n ≡ 0 (mod p)\n        if all_roots:\n            # Find all other roots by solving x^n ≡ 0 (mod p)\n            # Since p is prime, x^n ≡ 0 (mod p) iff x ≡ 0 (mod p)\n            return [0]\n        else:\n            return 0\n\n    if (p - 1) % n == 0:\n        return _nthroot_mod1(a, n, p, all_roots)\n",
      "\n    if not isprime(p):\n        raise NotImplementedError(\"Not implemented for composite p\")\n\n    # Handle the case where a ≡ 0 (mod p)\n    if a % p == 0:\n        if all_roots:\n            return [0]\n        else:\n            return 0\n\n    if (p - 1) % n == 0:\n        return _nthroot_mod1(a, n, p, all_roots)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..5764744516 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -776,6 +776,30 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n \n+\n+    # Handle the case when a % p == 0, then x = 0 is always a root\n+    if a % p == 0:\n+        if all_roots:\n+            # Find other non-zero roots by continuing with existing algorithms\n+            other_roots = []\n+            if (p - 1) % n == 0:\n+                other_roots = _nthroot_mod1(a, n, p, all_roots) or []\n+            else:\n+                # Use the existing algorithm for the general case\n+                # The roots of ``x**n - a = 0 (mod p)`` are roots of\n+                # ``gcd(x**n - a, x**(p - 1) - 1) = 0 (mod p)``\n+                other_roots = _nthroot_mod2(a, n, p, all_roots) or []\n+            \n+            # Combine zero root with other roots, ensuring no duplicates\n+            if isinstance(other_roots, list):\n+                all_solutions = [0] + [r for r in other_roots if r != 0]\n+                return sorted(set(all_solutions))\n+            else:\n+                return [0]\n+        else:\n+            # When all_roots=False, return the smallest root, which is 0\n+            return 0\n+    \n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n",
    "variant_0": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..8be3419912 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -776,6 +776,16 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n \n+    if not isprime(p):\n+        raise NotImplementedError(\"Not implemented for composite p\")\n+\n+    # Handle the case where a ≡ 0 (mod p)\n+    if a % p == 0:\n+        if all_roots:\n+            return [0]\n+        else:\n+            return 0\n+\n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n",
    "variant_1": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..8be3419912 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -776,6 +776,16 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n \n+    if not isprime(p):\n+        raise NotImplementedError(\"Not implemented for composite p\")\n+\n+    # Handle the case where a ≡ 0 (mod p)\n+    if a % p == 0:\n+        if all_roots:\n+            return [0]\n+        else:\n+            return 0\n+\n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n",
    "variant_2": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..8d60dd4eeb 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -776,7 +776,15 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n \n+\n     if (p - 1) % n == 0:\n+        if a % p == 0:\n+            # Zero is always a root when a ≡ 0 (mod p)\n+            if all_roots:\n+                other_roots = _nthroot_mod1(0, n, p, True) or []\n+                return [0] if 0 not in other_roots else other_roots\n+            else:\n+                return 0\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n     # ``gcd(x**n - a, x**(p - 1) - 1) = 0 (mod p)``\n",
    "variant_3": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..8be3419912 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -776,6 +776,16 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n \n+    if not isprime(p):\n+        raise NotImplementedError(\"Not implemented for composite p\")\n+\n+    # Handle the case where a ≡ 0 (mod p)\n+    if a % p == 0:\n+        if all_roots:\n+            return [0]\n+        else:\n+            return 0\n+\n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n",
    "variant_4": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..17674a3cb1 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -776,6 +776,16 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n \n+    if not isprime(p):\n+        raise NotImplementedError(\"Not implemented for composite p\")\n+\n+    # Handle the case when a ≡ 0 (mod p)\n+    if a % p == 0:\n+        if all_roots:\n+            return [0]\n+        else:\n+            return 0\n+\n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n",
    "variant_5": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..8be3419912 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -776,6 +776,16 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n \n+    if not isprime(p):\n+        raise NotImplementedError(\"Not implemented for composite p\")\n+\n+    # Handle the case where a ≡ 0 (mod p)\n+    if a % p == 0:\n+        if all_roots:\n+            return [0]\n+        else:\n+            return 0\n+\n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n",
    "variant_6": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..8be3419912 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -776,6 +776,16 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n \n+    if not isprime(p):\n+        raise NotImplementedError(\"Not implemented for composite p\")\n+\n+    # Handle the case where a ≡ 0 (mod p)\n+    if a % p == 0:\n+        if all_roots:\n+            return [0]\n+        else:\n+            return 0\n+\n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n",
    "variant_7": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..fc32fc4819 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -776,6 +776,16 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n \n+\n+    if a % p == 0:\n+        # When a ≡ 0 (mod p), x = 0 is always a root since 0^n ≡ 0 (mod p)\n+        if all_roots:\n+            # Find all other roots by solving x^n ≡ 0 (mod p)\n+            # Since p is prime, x^n ≡ 0 (mod p) iff x ≡ 0 (mod p)\n+            return [0]\n+        else:\n+            return 0\n+\n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n",
    "variant_8": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..8be3419912 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -776,6 +776,16 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n \n+    if not isprime(p):\n+        raise NotImplementedError(\"Not implemented for composite p\")\n+\n+    # Handle the case where a ≡ 0 (mod p)\n+    if a % p == 0:\n+        if all_roots:\n+            return [0]\n+        else:\n+            return 0\n+\n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n"
  }
}