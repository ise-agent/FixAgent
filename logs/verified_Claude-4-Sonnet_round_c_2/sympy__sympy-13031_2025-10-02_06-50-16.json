{
  "zero_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/matrices/common.py lines 478-480)": "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n",
    "Location 2 (/root/hy/projects/sympy/sympy/matrices/common.py lines 482-484)": "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n",
    "Location 3 (/root/hy/projects/sympy/sympy/matrices/common.py lines 377-381)": "\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
    "Location 4 (/root/hy/projects/sympy/sympy/matrices/common.py lines 149-158)": "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/sympy/sympy/matrices/common.py lines 478-480)": [
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n"
    ],
    "Location 2 (/root/hy/projects/sympy/sympy/matrices/common.py lines 482-484)": [
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n",
      "\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n"
    ],
    "Location 3 (/root/hy/projects/sympy/sympy/matrices/common.py lines 377-381)": [
      "\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n    @classmethod\n    def hstack(cls, *args):\n        \"\"\"Return a matrix formed by joining matrices horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy.matrices import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        \"\"\"\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n"
    ],
    "Location 4 (/root/hy/projects/sympy/sympy/matrices/common.py lines 149-158)": [
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..d10aca1329 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -374,6 +375,7 @@ def hstack(cls, *args):\n         [1, 0, 2, 0],\n         [0, 1, 0, 2]])\n         \"\"\"\n+\n         if len(args) == 0:\n             return cls._new()\n \n@@ -475,10 +477,12 @@ def row_join(self, other):\n         row\n         col_join\n         \"\"\"\n+\n         # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n+        if self.cols == 0:\n             return self._new(other.rows, 0, []).row_join(other)\n \n+\n         if self.rows != other.rows:\n             raise ShapeError(\n                 \"`self` and `rhs` must have the same number of rows.\")\n",
    "variant_0": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..b9697044a5 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -374,6 +375,7 @@ def hstack(cls, *args):\n         [1, 0, 2, 0],\n         [0, 1, 0, 2]])\n         \"\"\"\n+\n         if len(args) == 0:\n             return cls._new()\n \n@@ -475,8 +477,14 @@ def row_join(self, other):\n         row\n         col_join\n         \"\"\"\n+\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.cols == 0:\n+            return self._new(other.rows, 0, []).row_join(other)\n+\n+\n         # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n+        if self.cols == 0:\n             return self._new(other.rows, 0, []).row_join(other)\n \n         if self.rows != other.rows:\n",
    "variant_1": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..b9697044a5 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -374,6 +375,7 @@ def hstack(cls, *args):\n         [1, 0, 2, 0],\n         [0, 1, 0, 2]])\n         \"\"\"\n+\n         if len(args) == 0:\n             return cls._new()\n \n@@ -475,8 +477,14 @@ def row_join(self, other):\n         row\n         col_join\n         \"\"\"\n+\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.cols == 0:\n+            return self._new(other.rows, 0, []).row_join(other)\n+\n+\n         # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n+        if self.cols == 0:\n             return self._new(other.rows, 0, []).row_join(other)\n \n         if self.rows != other.rows:\n",
    "variant_2": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..b9697044a5 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -374,6 +375,7 @@ def hstack(cls, *args):\n         [1, 0, 2, 0],\n         [0, 1, 0, 2]])\n         \"\"\"\n+\n         if len(args) == 0:\n             return cls._new()\n \n@@ -475,8 +477,14 @@ def row_join(self, other):\n         row\n         col_join\n         \"\"\"\n+\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.cols == 0:\n+            return self._new(other.rows, 0, []).row_join(other)\n+\n+\n         # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n+        if self.cols == 0:\n             return self._new(other.rows, 0, []).row_join(other)\n \n         if self.rows != other.rows:\n",
    "variant_3": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..b9697044a5 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -374,6 +375,7 @@ def hstack(cls, *args):\n         [1, 0, 2, 0],\n         [0, 1, 0, 2]])\n         \"\"\"\n+\n         if len(args) == 0:\n             return cls._new()\n \n@@ -475,8 +477,14 @@ def row_join(self, other):\n         row\n         col_join\n         \"\"\"\n+\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.cols == 0:\n+            return self._new(other.rows, 0, []).row_join(other)\n+\n+\n         # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n+        if self.cols == 0:\n             return self._new(other.rows, 0, []).row_join(other)\n \n         if self.rows != other.rows:\n",
    "variant_4": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..b9697044a5 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -374,6 +375,7 @@ def hstack(cls, *args):\n         [1, 0, 2, 0],\n         [0, 1, 0, 2]])\n         \"\"\"\n+\n         if len(args) == 0:\n             return cls._new()\n \n@@ -475,8 +477,14 @@ def row_join(self, other):\n         row\n         col_join\n         \"\"\"\n+\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.cols == 0:\n+            return self._new(other.rows, 0, []).row_join(other)\n+\n+\n         # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n+        if self.cols == 0:\n             return self._new(other.rows, 0, []).row_join(other)\n \n         if self.rows != other.rows:\n",
    "variant_5": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..b9697044a5 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -374,6 +375,7 @@ def hstack(cls, *args):\n         [1, 0, 2, 0],\n         [0, 1, 0, 2]])\n         \"\"\"\n+\n         if len(args) == 0:\n             return cls._new()\n \n@@ -475,8 +477,14 @@ def row_join(self, other):\n         row\n         col_join\n         \"\"\"\n+\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.cols == 0:\n+            return self._new(other.rows, 0, []).row_join(other)\n+\n+\n         # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n+        if self.cols == 0:\n             return self._new(other.rows, 0, []).row_join(other)\n \n         if self.rows != other.rows:\n",
    "variant_6": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..b9697044a5 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -374,6 +375,7 @@ def hstack(cls, *args):\n         [1, 0, 2, 0],\n         [0, 1, 0, 2]])\n         \"\"\"\n+\n         if len(args) == 0:\n             return cls._new()\n \n@@ -475,8 +477,14 @@ def row_join(self, other):\n         row\n         col_join\n         \"\"\"\n+\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.cols == 0:\n+            return self._new(other.rows, 0, []).row_join(other)\n+\n+\n         # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n+        if self.cols == 0:\n             return self._new(other.rows, 0, []).row_join(other)\n \n         if self.rows != other.rows:\n",
    "variant_7": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..fc838d5bc5 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -374,6 +375,21 @@ def hstack(cls, *args):\n         [1, 0, 2, 0],\n         [0, 1, 0, 2]])\n         \"\"\"\n+\n+    @classmethod\n+    def hstack(cls, *args):\n+        \"\"\"Return a matrix formed by joining matrices horizontally (i.e.\n+        by repeated application of row_join).\n+\n+        Examples\n+        ========\n+\n+        >>> from sympy.matrices import Matrix, eye\n+        >>> Matrix.hstack(eye(2), 2*eye(2))\n+        Matrix([\n+        [1, 0, 2, 0],\n+        [0, 1, 0, 2]])\n+        \"\"\"\n         if len(args) == 0:\n             return cls._new()\n \n@@ -475,8 +491,14 @@ def row_join(self, other):\n         row\n         col_join\n         \"\"\"\n+\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.cols == 0:\n+            return self._new(other.rows, 0, []).row_join(other)\n+\n+\n         # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n+        if self.cols == 0:\n             return self._new(other.rows, 0, []).row_join(other)\n \n         if self.rows != other.rows:\n",
    "variant_8": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..b9697044a5 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -374,6 +375,7 @@ def hstack(cls, *args):\n         [1, 0, 2, 0],\n         [0, 1, 0, 2]])\n         \"\"\"\n+\n         if len(args) == 0:\n             return cls._new()\n \n@@ -475,8 +477,14 @@ def row_join(self, other):\n         row\n         col_join\n         \"\"\"\n+\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.cols == 0:\n+            return self._new(other.rows, 0, []).row_join(other)\n+\n+\n         # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n+        if self.cols == 0:\n             return self._new(other.rows, 0, []).row_join(other)\n \n         if self.rows != other.rows:\n"
  }
}