{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/flask/src/flask/cli.py lines 1021-1021)": "\ndef _get_domain_part(rule, server_name):\n    \"\"\"Extract domain part from rule's host or use server_name default.\"\"\"\n    if rule.host:\n        return rule.host\n    elif hasattr(rule, 'subdomain') and rule.subdomain:\n        if server_name:\n            return f\"{rule.subdomain}.{server_name}\"\n        else:\n            return rule.subdomain\n    else:\n        return server_name or \"localhost\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n    default=\"endpoint\",\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        \"routes when dispatching a request.\"\n    ),\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URL matching order.\n\n    The table shows the rule, the endpoint name, and the HTTP methods allowed\n    for each route. Routes are shown in the order that Flask will match\n    them when dispatching a request, unless the '--sort' option is used.\n    \"\"\"\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    server_name = current_app.config.get('SERVER_NAME')\n    rule_domains = [_get_domain_part(rule, server_name) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
    "Location 2 (/root/hy/projects_1/flask/src/flask/cli.py lines 1022-1026)": "\ndef _format_domain(rule):\n    \"\"\"Format domain information from rule's subdomain and host.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return f\"{rule.subdomain}.<domain>\"\n    return \"<any>\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n    default=\"endpoint\",\n    help=\"Method to sort routes by.\",\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints, methods, rules and domains.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    rule_domains = [_format_domain(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
    "Location 3 (/root/hy/projects_1/flask/src/flask/cli.py lines 1028-1028)": "\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n",
    "Location 4 (/root/hy/projects_1/flask/src/flask/cli.py lines 1034-1034)": "\n        click.echo(row.format(get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n",
    "Location 5 (/root/hy/projects_1/flask/src/flask/cli.py lines 1000-1000)": "\ndef _get_domain(rule):\n    \"\"\"Get the domain from a URL rule.\"\"\"\n    if rule.subdomain:\n        return rule.subdomain\n    return \"*\"\n\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(_get_domain(rule)) for rule in rules),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(_get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/flask/src/flask/cli.py lines 1021-1021)": [
      "\ndef _get_domain_part(rule, url_map):\n    \"\"\"Extract domain part from rule, handling subdomains and server_name.\"\"\"\n    if rule.subdomain:\n        server_name = getattr(url_map, 'server_name', None) or 'localhost'\n        return f\"{rule.subdomain}.{server_name}\"\n    return \"\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\")),\n    default=\"endpoint\",\n    help=(\n        \"Method to sort routes by. 'endpoint' sorts by the route's endpoint. \"\n        \"'methods' sorts by the route's methods. 'domain' sorts by the route's domain. \"\n        \"'rule' sorts by the route's rule.\"\n    ),\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with their endpoints, methods, domains, and rules.\n\n    Routes are displayed in a table, by default sorted by endpoint. Routes\n    prefixed with an underscore are considered internal and hidden by default.\n    \"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n    elif sort == \"domain\":\n        rules = sorted(rules, key=lambda rule: _get_domain_part(rule, current_app.url_map))\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    rule_domains = [\n        _get_domain_part(rule, current_app.url_map)\n        for rule in rules\n    ]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule, server_name):\n    \"\"\"Extract domain information from a rule.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        if server_name:\n            return f\"{rule.subdomain}.{server_name}\"\n        else:\n            return f\"{rule.subdomain}.<server_name>\"\n    return server_name or \"*\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n    default=\"endpoint\",\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        \"routes when dispatching a request.\"\n    ),\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints, methods and rules.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n    server_name = current_app.config.get('SERVER_NAME')\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    rule_domains = [\n        _get_domain_part(rule, server_name)\n        for rule in rules\n    ]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain(rule):\n    \"\"\"Get the domain for a route rule, handling subdomain and server_name.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return rule.subdomain\n    return \"*\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n    default=\"endpoint\",\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        \"routes when dispatching a request.\"\n    ),\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URL rules.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    rule_domains = [_get_domain(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain(rule):\n    \"\"\"Get the domain for a URL rule, handling subdomains and server name.\"\"\"\n    if rule.subdomain:\n        return f\"{rule.subdomain}.<server_name>\"\n    return \"<server_name>\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n    default=\"endpoint\",\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        \"routes when dispatching a request.\"\n    ),\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints, methods, and rules.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    rule_domains = [_get_domain(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule):\n    \"\"\"Get domain part for display in routes table.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return rule.subdomain\n    return \"\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n    default=\"endpoint\",\n    help=\"Method to sort routes by.\",\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints, methods and rules.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    rule_domains = [_get_domain_part(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule, app):\n    \"\"\"Extract domain part from rule's host or subdomain.\"\"\"\n    if hasattr(rule, 'host') and rule.host:\n        return rule.host\n    elif hasattr(rule, 'subdomain') and rule.subdomain:\n        server_name = app.config.get('SERVER_NAME', '')\n        if server_name:\n            return f\"{rule.subdomain}.{server_name}\"\n        else:\n            return rule.subdomain\n    return \"\"\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    \n    # Build domain information for each rule\n    rule_domains = [_get_domain_part(rule, current_app) for rule in rules]\n    \n    widths = (\n        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule):\n    \"\"\"Extract domain information from a rule.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return rule.subdomain\n    return \"\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\")),\n    default=\"endpoint\",\n    help=(\n        'Method to sort routes by. \"endpoint\" sorts by the route\\'s endpoint. '\n        '\"methods\" sorts by the route\\'s allowed methods. \"domain\" sorts by the '\n        'route\\'s subdomain. \"rule\" sorts by the route\\'s rule string.'\n    ),\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints, methods, domains, and rules.\n\n    Routes are displayed in a table showing:\n    \\b\n    Domain: subdomain (if any)\n    Endpoint: route endpoint\n    Methods: allowed HTTP methods\n    Rule: route rule string\n    \"\"\"\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n    elif sort == \"domain\":\n        rules = sorted(rules, key=_get_domain_part)\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    rule_domains = [_get_domain_part(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain(rule):\n    \"\"\"Get the domain for a URL rule, combining host and subdomain.\"\"\"\n    domain_parts = []\n    if hasattr(rule, 'host') and rule.host:\n        domain_parts.append(rule.host)\n    elif hasattr(rule, 'subdomain') and rule.subdomain:\n        domain_parts.append(rule.subdomain)\n    return \".\".join(domain_parts) if domain_parts else \"\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\")),\n    default=\"endpoint\",\n    help=(\n        \"Method to sort routes by. 'endpoint' sorts by the route's\"\n        \" endpoint name, 'methods' sorts by allowed methods, 'domain'\"\n        \" sorts by domain, and 'rule' sorts by the URL rule string.\"\n    ),\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with commands, methods and rules.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n    elif sort == \"domain\":\n        rules = sorted(rules, key=_get_domain)\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    rule_domains = [_get_domain(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n"
    ],
    "Location 2 (/root/hy/projects_1/flask/src/flask/cli.py lines 1022-1026)": [
      "\ndef _get_rule_domain(rule):\n    \"\"\"Get domain information from rule, handling both subdomain and host.\"\"\"\n    domain_parts = []\n    \n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        domain_parts.append(rule.subdomain)\n    \n    if hasattr(rule, 'host') and rule.host:\n        domain_parts.append(rule.host)\n    \n    return '.'.join(domain_parts) if domain_parts else '*'\n\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n    default=\"endpoint\",\n    help=\"Method to sort routes by.\",\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URL matching rules.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    rule_domains = [_get_rule_domain(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule):\n    \"\"\"Extract domain information from a URL rule.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return rule.subdomain\n    return \"\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n    default=\"endpoint\",\n    help=\"Method to sort routes by.\",\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URL building rules, sorted by 'sort'.\n    Columns: Domain, Endpoint, Methods, Rule\n    \"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    rule_domains = [_get_domain_part(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule):\n    \"\"\"Extract domain part from rule for display.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return rule.subdomain\n    return \"\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n    default=\"endpoint\",\n    help=\"Method to sort routes by.\",\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URLs and endpoint names.\n\n    By default, the 'HEAD', 'OPTIONS' methods are hidden, and routes are\n    displayed in a compact table.\n    \"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    rule_domains = [_get_domain_part(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule):\n    \"\"\"Extract domain information from a URL rule.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return rule.subdomain\n    return ''\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n    default=\"endpoint\",\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        \"routes when dispatching a request.\"\n    ),\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URL matching order.\n\n    By default, routes are displayed in the order that Flask will match\n    them when dispatching requests. Within groups of the same generic\n    route, routes are sorted by endpoint name.\n    \"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    rule_domains = [_get_domain_part(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain(rule):\n    \"\"\"Get the domain for a rule, handling subdomain and server_name.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return rule.subdomain\n    return ''\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n    default=\"endpoint\",\n    help=\"Method to sort routes by.\",\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URL rules.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    rule_domains = [_get_domain(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule):\n    \"\"\"Helper function to get domain part from rule.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return rule.subdomain\n    return \"\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n    default=\"endpoint\",\n    help=(\n        \"Method to sort routes by. 'endpoint' sorts by endpoint name, \"\n        \"'methods' sorts by allowed methods, and 'rule' sorts by URL rule.\"\n    ),\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URL generation rules.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    rule_domains = [_get_domain_part(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule):\n    \"\"\"Extract domain information from a URL rule.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return rule.subdomain\n    return ''\n\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n    default=\"endpoint\",\n    help=\"Method to sort routes by.\",\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URL, endpoint, and methods.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    rule_domains = [_get_domain_part(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain(rule):\n    \"\"\"Get the domain for a rule, handling subdomain and server_name.\"\"\"\n    if rule.subdomain:\n        server_name = current_app.config.get('SERVER_NAME', '')\n        if server_name:\n            return f\"{rule.subdomain}.{server_name}\"\n        else:\n            return f\"{rule.subdomain}.<any>\"\n    return \"<any>\"\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\")),\n    default=\"endpoint\",\n    help=\"Method to sort routes by.\",\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URL rules.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n    elif sort == \"domain\":\n        rules = sorted(rules, key=_get_domain)\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n    \n    rule_domains = [_get_domain(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in rule_domains),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n"
    ],
    "Location 3 (/root/hy/projects_1/flask/src/flask/cli.py lines 1028-1028)": [
      "\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n",
      "\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n",
      "\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n",
      "\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n",
      "\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n",
      "\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n",
      "\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n",
      "\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n"
    ],
    "Location 4 (/root/hy/projects_1/flask/src/flask/cli.py lines 1034-1034)": [
      "\n        click.echo(row.format(get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n",
      "\n        click.echo(row.format(get_domain_part(rule), rule.endpoint, methods, rule.rule).rstrip())\n",
      "\n        click.echo(row.format(get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n",
      "\n        click.echo(row.format(rule.subdomain or \"any\", rule.endpoint, methods, rule.rule).rstrip())\n",
      "\n        click.echo(row.format(get_domain_part(rule), rule.endpoint, methods, rule.rule).rstrip())\n",
      "\n        click.echo(row.format(get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n",
      "\n        click.echo(row.format(get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain(rule):\n    \"\"\"Get the domain for a URL rule, handling subdomains and server names.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return f\"{rule.subdomain}.<domain>\"\n    return \"any\"\n\n\n@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n@click.option(\n    \"--sort\",\n    \"-s\",\n    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\")),\n    default=\"endpoint\",\n    help=\"Method to sort routes by.\",\n)\n@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with URL rules, including domain information.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n    \n    rule_domains = [_get_domain(rule) for rule in rules]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    sorts = {\n        \"domain\": rule_domains,\n        \"endpoint\": (rule.endpoint for rule in rules),\n        \"methods\": rule_methods,\n        \"rule\": (rule.rule for rule in rules),\n    }\n    rules = [rule for rule, _ in sorted(zip(rules, sorts[sort]), key=lambda x: x[1])]\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n    rule_domains = [_get_domain(rule) for rule in rules]\n\n    widths = (\n        max(len(domain) for domain in rule_domains),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n"
    ],
    "Location 5 (/root/hy/projects_1/flask/src/flask/cli.py lines 1000-1000)": [
      "\ndef _get_domain(rule):\n    \"\"\"Get the domain for a rule, handling subdomain and server_name.\"\"\"\n    if rule.subdomain:\n        server_name = current_app.config.get('SERVER_NAME', 'localhost')\n        if '.' in server_name:\n            return f\"{rule.subdomain}.{server_name}\"\n        else:\n            return f\"{rule.subdomain}.{server_name}\"\n    return current_app.config.get('SERVER_NAME', 'localhost')\n\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in [_get_domain(rule) for rule in rules] + [headers[0]]),\n        max(len(rule.endpoint) for rule in rules + [headers[1]]),\n        max(len(methods) for methods in rule_methods + [headers[2]]),\n        max(len(rule.rule) for rule in rules + [headers[3]]),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row_template = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n\n    click.echo(row_template.format(*headers).strip())\n    click.echo(row_template.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(\n            row_template.format(_get_domain(rule), rule.endpoint, methods, rule.rule).strip()\n        )\n",
      "\ndef _get_domain(rule):\n    \"\"\"Helper function to get domain from rule.\"\"\"\n    if rule.subdomain:\n        return f\"{rule.subdomain}.<domain>\"\n    return \"<any>\"\n\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(headers[0]), max(len(_get_domain(rule)) for rule in rules)),\n        max(len(headers[1]), max(len(rule.endpoint) for rule in rules)),\n        max(len(headers[2]), max(len(methods) for methods in rule_methods)),\n        max(len(headers[3]), max(len(rule.rule) for rule in rules)),\n    )\n    widths = {headers[i]: widths[i] for i in range(len(headers))}\n    template = \"  \".join(f\"{{%s:<%d}}\" % (key, width) for key, width in widths.items())\n\n    click.echo(template.format(**dict(zip(headers, headers))))\n    click.echo(template.format(**{key: \"-\" * width for key, width in widths.items()}))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(\n            template.format(\n                Domain=_get_domain(rule), Endpoint=rule.endpoint, Methods=methods, Rule=rule.rule\n            )\n        )\n",
      "\ndef _get_rule_domain(rule):\n    \"\"\"Get the domain for a URL rule, handling subdomain and server_name.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        server_name = current_app.config.get('SERVER_NAME', 'localhost')\n        if rule.subdomain == '<subdomain>':\n            return f\"<subdomain>.{server_name}\"\n        return f\"{rule.subdomain}.{server_name}\"\n    return current_app.config.get('SERVER_NAME', 'localhost')\n\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(domain) for domain in [_get_rule_domain(rule) for rule in rules] + [headers[0]]),\n        max(len(rule.endpoint) for rule in rules + [headers[1]]),\n        max(len(methods) for methods in rule_methods + [headers[2]]),\n        max(len(rule.rule) for rule in rules + [headers[3]]),\n    )\n    widths = tuple(max(width, len(header)) for width, header in zip(widths, headers))\n    row_template = \"  \".join(f\"{{:<{width}}}\" for width in widths)\n\n    click.echo(row_template.format(*headers).strip())\n    click.echo(row_template.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(\n            row_template.format(_get_rule_domain(rule), rule.endpoint, methods, rule.rule).rstrip()\n        )\n",
      "\ndef _get_domain_part(rule):\n    \"\"\"Extract domain information from a URL rule.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return rule.subdomain\n    return \"\"\n\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(_get_domain_part(rule)) for rule in rules),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(_get_domain_part(rule), rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain(rule):\n    \"\"\"Get domain information from a URL rule.\"\"\"\n    if rule.subdomain:\n        return rule.subdomain\n    return rule.host or \"\"\n\n@with_appcontext\n",
      "\ndef _get_domain(rule):\n    \"\"\"Get the domain for a rule, handling subdomain and server_name.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        server_name = current_app.config.get('SERVER_NAME', 'localhost')\n        if rule.subdomain == '<subdomain>':\n            return f\"<subdomain>.{server_name}\"\n        return f\"{rule.subdomain}.{server_name}\"\n    return current_app.config.get('SERVER_NAME', 'localhost')\n\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(_get_domain(rule)) for rule in rules),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(_get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule) -> str:\n    \"\"\"Get the domain part for a URL rule, handling subdomains.\"\"\"\n    if hasattr(rule, 'subdomain') and rule.subdomain:\n        return f\"{rule.subdomain}.<server_name>\"\n    return \"<server_name>\"\n\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(_get_domain_part(rule)) for rule in rules),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(_get_domain_part(rule), rule.endpoint, methods, rule.rule).rstrip())\n",
      "\ndef _get_domain_part(rule):\n    \"\"\"Get domain part for a rule, handling subdomain and server_name.\"\"\"\n    domain_parts = []\n    if rule.subdomain:\n        domain_parts.append(rule.subdomain)\n    # Add server_name if available from app config\n    server_name = current_app.config.get('SERVER_NAME')\n    if server_name:\n        domain_parts.append(server_name)\n    return '.'.join(domain_parts) if domain_parts else '*'\n\n@with_appcontext\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(rule.rule) for rule in rules),\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(_get_domain_part(rule)) for rule in rules),\n    )\n\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(_get_domain_part(rule), rule.endpoint, methods, rule.rule).strip())\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/flask/cli.py b/src/flask/cli.py\nindex 37a15ff2..56748911 100644\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -997,7 +997,9 @@ def shell_command() -> None:\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n-@with_appcontext\n+\n+        domain = _construct_domain(rule, server_name)\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n \n@@ -1018,20 +1020,35 @@ def routes_command(sort: str, all_methods: bool) -> None:\n         for rule in rules\n     ]\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n+\n+def _construct_domain(rule, server_name):\n+    \"\"\"Construct full domain from rule subdomain and server name.\"\"\"\n+    subdomain = getattr(rule, 'subdomain', None)\n+    if subdomain:\n+        return f\"{subdomain}.{server_name}\"\n+    return server_name or \"localhost\"\n+\n+\n+@with_appcontext\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+\n+    server_name = current_app.config.get(\"SERVER_NAME\", \"localhost\")\n+    domains = [_construct_domain(rule, server_name) for rule in rules]\n     widths = (\n+        max(len(domain) for domain in domains),\n         max(len(rule.endpoint) for rule in rules),\n         max(len(methods) for methods in rule_methods),\n         max(len(rule.rule) for rule in rules),\n     )\n-    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n \n     click.echo(row.format(*headers).strip())\n     click.echo(row.format(*(\"-\" * width for width in widths)))\n \n     for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n \n \n cli = FlaskGroup(\n",
    "variant_0": "diff --git a/src/flask/cli.py b/src/flask/cli.py\nindex 37a15ff2..b693f868 100644\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -997,6 +997,13 @@ def shell_command() -> None:\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+\n+def _get_domain(rule):\n+    \"\"\"Get the domain from a URL rule.\"\"\"\n+    if rule.subdomain:\n+        return rule.subdomain\n+    return \"*\"\n+\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n@@ -1018,20 +1025,173 @@ def routes_command(sort: str, all_methods: bool) -> None:\n         for rule in rules\n     ]\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(_get_domain(rule)) for rule in rules),\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods in zip(rules, rule_methods):\n+        click.echo(row.format(_get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n+\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+\n+def _get_domain_part(rule, server_name):\n+    \"\"\"Extract domain part from rule's host or use server_name default.\"\"\"\n+    if rule.host:\n+        return rule.host\n+    elif hasattr(rule, 'subdomain') and rule.subdomain:\n+        if server_name:\n+            return f\"{rule.subdomain}.{server_name}\"\n+        else:\n+            return rule.subdomain\n+    else:\n+        return server_name or \"localhost\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n+    default=\"endpoint\",\n+    help=(\n+        'Method to sort routes by. \"match\" is the order that Flask will match '\n+        \"routes when dispatching a request.\"\n+    ),\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URL matching order.\n+\n+    The table shows the rule, the endpoint name, and the HTTP methods allowed\n+    for each route. Routes are shown in the order that Flask will match\n+    them when dispatching a request, unless the '--sort' option is used.\n+    \"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+    \n+    server_name = current_app.config.get('SERVER_NAME')\n+    rule_domains = [_get_domain_part(rule, server_name) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n     widths = (\n+        max(len(domain) for domain in rule_domains),\n         max(len(rule.endpoint) for rule in rules),\n         max(len(methods) for methods in rule_methods),\n         max(len(rule.rule) for rule in rules),\n     )\n     widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+\n+def _format_domain(rule):\n+    \"\"\"Format domain information from rule's subdomain and host.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return f\"{rule.subdomain}.<domain>\"\n+    return \"<any>\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n+    default=\"endpoint\",\n+    help=\"Method to sort routes by.\",\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints, methods, rules and domains.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+    \n+    rule_domains = [_format_domain(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in rule_domains),\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n \n     click.echo(row.format(*headers).strip())\n     click.echo(row.format(*(\"-\" * width for width in widths)))\n \n     for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+\n+        click.echo(row.format(get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n \n \n cli = FlaskGroup(\n",
    "variant_1": "diff --git a/src/flask/cli.py b/src/flask/cli.py\nindex 37a15ff2..bbc0fac7 100644\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -997,6 +997,17 @@ def shell_command() -> None:\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+\n+def _get_domain(rule):\n+    \"\"\"Get the domain for a rule, handling subdomain and server_name.\"\"\"\n+    if rule.subdomain:\n+        server_name = current_app.config.get('SERVER_NAME', 'localhost')\n+        if '.' in server_name:\n+            return f\"{rule.subdomain}.{server_name}\"\n+        else:\n+            return f\"{rule.subdomain}.{server_name}\"\n+    return current_app.config.get('SERVER_NAME', 'localhost')\n+\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n@@ -1018,20 +1029,182 @@ def routes_command(sort: str, all_methods: bool) -> None:\n         for rule in rules\n     ]\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in [_get_domain(rule) for rule in rules] + [headers[0]]),\n+        max(len(rule.endpoint) for rule in rules + [headers[1]]),\n+        max(len(methods) for methods in rule_methods + [headers[2]]),\n+        max(len(rule.rule) for rule in rules + [headers[3]]),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row_template = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row_template.format(*headers).strip())\n+    click.echo(row_template.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods in zip(rules, rule_methods):\n+        click.echo(\n+            row_template.format(_get_domain(rule), rule.endpoint, methods, rule.rule).strip()\n+        )\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n+\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+\n+def _get_domain_part(rule, url_map):\n+    \"\"\"Extract domain part from rule, handling subdomains and server_name.\"\"\"\n+    if rule.subdomain:\n+        server_name = getattr(url_map, 'server_name', None) or 'localhost'\n+        return f\"{rule.subdomain}.{server_name}\"\n+    return \"\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\")),\n+    default=\"endpoint\",\n+    help=(\n+        \"Method to sort routes by. 'endpoint' sorts by the route's endpoint. \"\n+        \"'methods' sorts by the route's methods. 'domain' sorts by the route's domain. \"\n+        \"'rule' sorts by the route's rule.\"\n+    ),\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with their endpoints, methods, domains, and rules.\n+\n+    Routes are displayed in a table, by default sorted by endpoint. Routes\n+    prefixed with an underscore are considered internal and hidden by default.\n+    \"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+    elif sort == \"domain\":\n+        rules = sorted(rules, key=lambda rule: _get_domain_part(rule, current_app.url_map))\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+    \n+    rule_domains = [\n+        _get_domain_part(rule, current_app.url_map)\n+        for rule in rules\n+    ]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n     widths = (\n+        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n         max(len(rule.endpoint) for rule in rules),\n         max(len(methods) for methods in rule_methods),\n         max(len(rule.rule) for rule in rules),\n     )\n     widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+\n+def _get_rule_domain(rule):\n+    \"\"\"Get domain information from rule, handling both subdomain and host.\"\"\"\n+    domain_parts = []\n+    \n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        domain_parts.append(rule.subdomain)\n+    \n+    if hasattr(rule, 'host') and rule.host:\n+        domain_parts.append(rule.host)\n+    \n+    return '.'.join(domain_parts) if domain_parts else '*'\n+\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n+    default=\"endpoint\",\n+    help=\"Method to sort routes by.\",\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URL matching rules.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+    \n+    rule_domains = [_get_rule_domain(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in rule_domains),\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n \n     click.echo(row.format(*headers).strip())\n     click.echo(row.format(*(\"-\" * width for width in widths)))\n \n     for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+\n+        click.echo(row.format(get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n \n \n cli = FlaskGroup(\n",
    "variant_2": "diff --git a/src/flask/cli.py b/src/flask/cli.py\nindex 37a15ff2..ab31ffd3 100644\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -997,6 +997,13 @@ def shell_command() -> None:\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+\n+def _get_domain(rule):\n+    \"\"\"Helper function to get domain from rule.\"\"\"\n+    if rule.subdomain:\n+        return f\"{rule.subdomain}.<domain>\"\n+    return \"<any>\"\n+\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n@@ -1008,6 +1015,44 @@ def routes_command(sort: str, all_methods: bool) -> None:\n \n     ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n \n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods)) for rule in rules\n+    ]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(headers[0]), max(len(_get_domain(rule)) for rule in rules)),\n+        max(len(headers[1]), max(len(rule.endpoint) for rule in rules)),\n+        max(len(headers[2]), max(len(methods) for methods in rule_methods)),\n+        max(len(headers[3]), max(len(rule.rule) for rule in rules)),\n+    )\n+    widths = {headers[i]: widths[i] for i in range(len(headers))}\n+    template = \"  \".join(f\"{{%s:<%d}}\" % (key, width) for key, width in widths.items())\n+\n+    click.echo(template.format(**dict(zip(headers, headers))))\n+    click.echo(template.format(**{key: \"-\" * width for key, width in widths.items()}))\n+\n+    for rule, methods in zip(rules, rule_methods):\n+        click.echo(\n+            template.format(\n+                Domain=_get_domain(rule), Endpoint=rule.endpoint, Methods=methods, Rule=rule.rule\n+            )\n+        )\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n+\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+\n     if sort in (\"endpoint\", \"rule\"):\n         rules = sorted(rules, key=attrgetter(sort))\n     elif sort == \"methods\":\n@@ -1018,20 +1063,136 @@ def routes_command(sort: str, all_methods: bool) -> None:\n         for rule in rules\n     ]\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n+\n+def _get_domain_part(rule, server_name):\n+    \"\"\"Extract domain information from a rule.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        if server_name:\n+            return f\"{rule.subdomain}.{server_name}\"\n+        else:\n+            return f\"{rule.subdomain}.<server_name>\"\n+    return server_name or \"*\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n+    default=\"endpoint\",\n+    help=(\n+        'Method to sort routes by. \"match\" is the order that Flask will match '\n+        \"routes when dispatching a request.\"\n+    ),\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints, methods and rules.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+    server_name = current_app.config.get('SERVER_NAME')\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+    rule_domains = [\n+        _get_domain_part(rule, server_name)\n+        for rule in rules\n+    ]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in rule_domains),\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+\n+def _get_domain_part(rule):\n+    \"\"\"Extract domain information from a URL rule.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return rule.subdomain\n+    return \"\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n+    default=\"endpoint\",\n+    help=\"Method to sort routes by.\",\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URL building rules, sorted by 'sort'.\n+    Columns: Domain, Endpoint, Methods, Rule\n+    \"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+    \n+    rule_domains = [_get_domain_part(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n     widths = (\n+        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n         max(len(rule.endpoint) for rule in rules),\n         max(len(methods) for methods in rule_methods),\n         max(len(rule.rule) for rule in rules),\n     )\n     widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n \n     click.echo(row.format(*headers).strip())\n     click.echo(row.format(*(\"-\" * width for width in widths)))\n \n     for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+\n+        click.echo(row.format(get_domain_part(rule), rule.endpoint, methods, rule.rule).rstrip())\n \n \n cli = FlaskGroup(\n",
    "variant_3": "diff --git a/src/flask/cli.py b/src/flask/cli.py\nindex 37a15ff2..92086dd6 100644\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -997,6 +997,16 @@ def shell_command() -> None:\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+\n+def _get_rule_domain(rule):\n+    \"\"\"Get the domain for a URL rule, handling subdomain and server_name.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        server_name = current_app.config.get('SERVER_NAME', 'localhost')\n+        if rule.subdomain == '<subdomain>':\n+            return f\"<subdomain>.{server_name}\"\n+        return f\"{rule.subdomain}.{server_name}\"\n+    return current_app.config.get('SERVER_NAME', 'localhost')\n+\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n@@ -1018,20 +1028,168 @@ def routes_command(sort: str, all_methods: bool) -> None:\n         for rule in rules\n     ]\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in [_get_rule_domain(rule) for rule in rules] + [headers[0]]),\n+        max(len(rule.endpoint) for rule in rules + [headers[1]]),\n+        max(len(methods) for methods in rule_methods + [headers[2]]),\n+        max(len(rule.rule) for rule in rules + [headers[3]]),\n+    )\n+    widths = tuple(max(width, len(header)) for width, header in zip(widths, headers))\n+    row_template = \"  \".join(f\"{{:<{width}}}\" for width in widths)\n+\n+    click.echo(row_template.format(*headers).strip())\n+    click.echo(row_template.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods in zip(rules, rule_methods):\n+        click.echo(\n+            row_template.format(_get_rule_domain(rule), rule.endpoint, methods, rule.rule).rstrip()\n+        )\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n+\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+\n+def _get_domain(rule):\n+    \"\"\"Get the domain for a route rule, handling subdomain and server_name.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return rule.subdomain\n+    return \"*\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n+    default=\"endpoint\",\n+    help=(\n+        'Method to sort routes by. \"match\" is the order that Flask will match '\n+        \"routes when dispatching a request.\"\n+    ),\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URL rules.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+    rule_domains = [_get_domain(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n     widths = (\n+        max(len(domain) for domain in rule_domains),\n         max(len(rule.endpoint) for rule in rules),\n         max(len(methods) for methods in rule_methods),\n         max(len(rule.rule) for rule in rules),\n     )\n     widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+\n+def _get_domain_part(rule):\n+    \"\"\"Extract domain part from rule for display.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return rule.subdomain\n+    return \"\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n+    default=\"endpoint\",\n+    help=\"Method to sort routes by.\",\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URLs and endpoint names.\n+\n+    By default, the 'HEAD', 'OPTIONS' methods are hidden, and routes are\n+    displayed in a compact table.\n+    \"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+    rule_domains = [_get_domain_part(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n \n     click.echo(row.format(*headers).strip())\n     click.echo(row.format(*(\"-\" * width for width in widths)))\n \n     for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+\n+        click.echo(row.format(get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n \n \n cli = FlaskGroup(\n",
    "variant_4": "diff --git a/src/flask/cli.py b/src/flask/cli.py\nindex 37a15ff2..6073bd52 100644\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -997,6 +997,13 @@ def shell_command() -> None:\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+\n+def _get_domain_part(rule):\n+    \"\"\"Extract domain information from a URL rule.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return rule.subdomain\n+    return \"\"\n+\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n@@ -1008,6 +1015,142 @@ def routes_command(sort: str, all_methods: bool) -> None:\n \n     ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n \n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods)) for rule in rules\n+    ]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(_get_domain_part(rule)) for rule in rules),\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods in zip(rules, rule_methods):\n+        click.echo(row.format(_get_domain_part(rule), rule.endpoint, methods, rule.rule).rstrip())\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n+\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+\n+def _get_domain(rule):\n+    \"\"\"Get the domain for a URL rule, handling subdomains and server name.\"\"\"\n+    if rule.subdomain:\n+        return f\"{rule.subdomain}.<server_name>\"\n+    return \"<server_name>\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n+    default=\"endpoint\",\n+    help=(\n+        'Method to sort routes by. \"match\" is the order that Flask will match '\n+        \"routes when dispatching a request.\"\n+    ),\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints, methods, and rules.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+    \n+    rule_domains = [_get_domain(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in rule_domains),\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+\n+def _get_domain_part(rule):\n+    \"\"\"Extract domain information from a URL rule.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return rule.subdomain\n+    return ''\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n+    default=\"endpoint\",\n+    help=(\n+        'Method to sort routes by. \"match\" is the order that Flask will match '\n+        \"routes when dispatching a request.\"\n+    ),\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URL matching order.\n+\n+    By default, routes are displayed in the order that Flask will match\n+    them when dispatching requests. Within groups of the same generic\n+    route, routes are sorted by endpoint name.\n+    \"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n     if sort in (\"endpoint\", \"rule\"):\n         rules = sorted(rules, key=attrgetter(sort))\n     elif sort == \"methods\":\n@@ -1017,21 +1160,34 @@ def routes_command(sort: str, all_methods: bool) -> None:\n         \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n         for rule in rules\n     ]\n+    \n+    rule_domains = [_get_domain_part(rule) for rule in rules]\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n     widths = (\n+        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n         max(len(rule.endpoint) for rule in rules),\n         max(len(methods) for methods in rule_methods),\n         max(len(rule.rule) for rule in rules),\n     )\n     widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n \n     click.echo(row.format(*headers).strip())\n     click.echo(row.format(*(\"-\" * width for width in widths)))\n \n     for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+\n+        click.echo(row.format(rule.subdomain or \"any\", rule.endpoint, methods, rule.rule).rstrip())\n \n \n cli = FlaskGroup(\n",
    "variant_5": "diff --git a/src/flask/cli.py b/src/flask/cli.py\nindex 37a15ff2..d6ac68c1 100644\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -997,6 +997,13 @@ def shell_command() -> None:\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+\n+def _get_domain(rule):\n+    \"\"\"Get domain information from a URL rule.\"\"\"\n+    if rule.subdomain:\n+        return rule.subdomain\n+    return rule.host or \"\"\n+\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n@@ -1018,20 +1025,123 @@ def routes_command(sort: str, all_methods: bool) -> None:\n         for rule in rules\n     ]\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n+\n+def _get_domain_part(rule):\n+    \"\"\"Get domain part for display in routes table.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return rule.subdomain\n+    return \"\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\", \"match\")),\n+    default=\"endpoint\",\n+    help=\"Method to sort routes by.\",\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints, methods and rules.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+    rule_domains = [_get_domain_part(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n     widths = (\n+        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n         max(len(rule.endpoint) for rule in rules),\n         max(len(methods) for methods in rule_methods),\n         max(len(rule.rule) for rule in rules),\n     )\n     widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+\n+def _get_domain(rule):\n+    \"\"\"Get the domain for a rule, handling subdomain and server_name.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return rule.subdomain\n+    return ''\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n+    default=\"endpoint\",\n+    help=\"Method to sort routes by.\",\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URL rules.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+    rule_domains = [_get_domain(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n \n     click.echo(row.format(*headers).strip())\n     click.echo(row.format(*(\"-\" * width for width in widths)))\n \n     for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+\n+        click.echo(row.format(get_domain_part(rule), rule.endpoint, methods, rule.rule).rstrip())\n \n \n cli = FlaskGroup(\n",
    "variant_6": "diff --git a/src/flask/cli.py b/src/flask/cli.py\nindex 37a15ff2..7949b81e 100644\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -997,6 +997,16 @@ def shell_command() -> None:\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+\n+def _get_domain(rule):\n+    \"\"\"Get the domain for a rule, handling subdomain and server_name.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        server_name = current_app.config.get('SERVER_NAME', 'localhost')\n+        if rule.subdomain == '<subdomain>':\n+            return f\"<subdomain>.{server_name}\"\n+        return f\"{rule.subdomain}.{server_name}\"\n+    return current_app.config.get('SERVER_NAME', 'localhost')\n+\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n@@ -1018,20 +1028,139 @@ def routes_command(sort: str, all_methods: bool) -> None:\n         for rule in rules\n     ]\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n     widths = (\n+        max(len(_get_domain(rule)) for rule in rules),\n         max(len(rule.endpoint) for rule in rules),\n         max(len(methods) for methods in rule_methods),\n         max(len(rule.rule) for rule in rules),\n     )\n     widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+    row = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n \n     click.echo(row.format(*headers).strip())\n     click.echo(row.format(*(\"-\" * width for width in widths)))\n \n     for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+        click.echo(row.format(_get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n+\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+\n+def _get_domain_part(rule, app):\n+    \"\"\"Extract domain part from rule's host or subdomain.\"\"\"\n+    if hasattr(rule, 'host') and rule.host:\n+        return rule.host\n+    elif hasattr(rule, 'subdomain') and rule.subdomain:\n+        server_name = app.config.get('SERVER_NAME', '')\n+        if server_name:\n+            return f\"{rule.subdomain}.{server_name}\"\n+        else:\n+            return rule.subdomain\n+    return \"\"\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    \n+    # Build domain information for each rule\n+    rule_domains = [_get_domain_part(rule, current_app) for rule in rules]\n+    \n+    widths = (\n+        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+\n+def _get_domain_part(rule):\n+    \"\"\"Helper function to get domain part from rule.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return rule.subdomain\n+    return \"\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n+    default=\"endpoint\",\n+    help=(\n+        \"Method to sort routes by. 'endpoint' sorts by endpoint name, \"\n+        \"'methods' sorts by allowed methods, and 'rule' sorts by URL rule.\"\n+    ),\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URL generation rules.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+    \n+    rule_domains = [_get_domain_part(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods in zip(rules, rule_methods):\n+\n+        click.echo(row.format(get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n \n \n cli = FlaskGroup(\n",
    "variant_7": "diff --git a/src/flask/cli.py b/src/flask/cli.py\nindex 37a15ff2..462d0035 100644\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -997,6 +997,13 @@ def shell_command() -> None:\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+\n+def _get_domain_part(rule) -> str:\n+    \"\"\"Get the domain part for a URL rule, handling subdomains.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return f\"{rule.subdomain}.<server_name>\"\n+    return \"<server_name>\"\n+\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n@@ -1018,20 +1025,172 @@ def routes_command(sort: str, all_methods: bool) -> None:\n         for rule in rules\n     ]\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(_get_domain_part(rule)) for rule in rules),\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods in zip(rules, rule_methods):\n+        click.echo(row.format(_get_domain_part(rule), rule.endpoint, methods, rule.rule).rstrip())\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n+\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+\n+def _get_domain_part(rule):\n+    \"\"\"Extract domain information from a rule.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return rule.subdomain\n+    return \"\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\")),\n+    default=\"endpoint\",\n+    help=(\n+        'Method to sort routes by. \"endpoint\" sorts by the route\\'s endpoint. '\n+        '\"methods\" sorts by the route\\'s allowed methods. \"domain\" sorts by the '\n+        'route\\'s subdomain. \"rule\" sorts by the route\\'s rule string.'\n+    ),\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints, methods, domains, and rules.\n+\n+    Routes are displayed in a table showing:\n+    \\b\n+    Domain: subdomain (if any)\n+    Endpoint: route endpoint\n+    Methods: allowed HTTP methods\n+    Rule: route rule string\n+    \"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+    elif sort == \"domain\":\n+        rules = sorted(rules, key=_get_domain_part)\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+    \n+    rule_domains = [_get_domain_part(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+\n+def _get_domain_part(rule):\n+    \"\"\"Extract domain information from a URL rule.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return rule.subdomain\n+    return ''\n+\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"rule\")),\n+    default=\"endpoint\",\n+    help=\"Method to sort routes by.\",\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URL, endpoint, and methods.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+    \n+    rule_domains = [_get_domain_part(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n     widths = (\n+        max(len(domain) for domain in rule_domains) if rule_domains else 0,\n         max(len(rule.endpoint) for rule in rules),\n         max(len(methods) for methods in rule_methods),\n         max(len(rule.rule) for rule in rules),\n     )\n     widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n \n     click.echo(row.format(*headers).strip())\n     click.echo(row.format(*(\"-\" * width for width in widths)))\n \n     for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+\n+        click.echo(row.format(get_domain(rule), rule.endpoint, methods, rule.rule).rstrip())\n \n \n cli = FlaskGroup(\n",
    "variant_8": "diff --git a/src/flask/cli.py b/src/flask/cli.py\nindex 37a15ff2..7656f549 100644\n--- a/src/flask/cli.py\n+++ b/src/flask/cli.py\n@@ -997,6 +997,18 @@ def shell_command() -> None:\n     ),\n )\n @click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+\n+def _get_domain_part(rule):\n+    \"\"\"Get domain part for a rule, handling subdomain and server_name.\"\"\"\n+    domain_parts = []\n+    if rule.subdomain:\n+        domain_parts.append(rule.subdomain)\n+    # Add server_name if available from app config\n+    server_name = current_app.config.get('SERVER_NAME')\n+    if server_name:\n+        domain_parts.append(server_name)\n+    return '.'.join(domain_parts) if domain_parts else '*'\n+\n @with_appcontext\n def routes_command(sort: str, all_methods: bool) -> None:\n     \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n@@ -1008,6 +1020,41 @@ def routes_command(sort: str, all_methods: bool) -> None:\n \n     ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n \n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods)) for rule in rules\n+    ]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(rule.rule) for rule in rules),\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(_get_domain_part(rule)) for rule in rules),\n+    )\n+\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}} {{1:<{1}}} {{2:<{2}}} {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods in zip(rules, rule_methods):\n+        click.echo(row.format(_get_domain_part(rule), rule.endpoint, methods, rule.rule).strip())\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n+\n+    rules = list(current_app.url_map.iter_rules())\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+\n     if sort in (\"endpoint\", \"rule\"):\n         rules = sorted(rules, key=attrgetter(sort))\n     elif sort == \"methods\":\n@@ -1018,20 +1065,197 @@ def routes_command(sort: str, all_methods: bool) -> None:\n         for rule in rules\n     ]\n \n-    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n+\n+def _get_domain(rule):\n+    \"\"\"Get the domain for a URL rule, combining host and subdomain.\"\"\"\n+    domain_parts = []\n+    if hasattr(rule, 'host') and rule.host:\n+        domain_parts.append(rule.host)\n+    elif hasattr(rule, 'subdomain') and rule.subdomain:\n+        domain_parts.append(rule.subdomain)\n+    return \".\".join(domain_parts) if domain_parts else \"\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\")),\n+    default=\"endpoint\",\n+    help=(\n+        \"Method to sort routes by. 'endpoint' sorts by the route's\"\n+        \" endpoint name, 'methods' sorts by allowed methods, 'domain'\"\n+        \" sorts by domain, and 'rule' sorts by the URL rule string.\"\n+    ),\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with commands, methods and rules.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+    elif sort == \"domain\":\n+        rules = sorted(rules, key=_get_domain)\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+\n+    rule_domains = [_get_domain(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n     widths = (\n+        max(len(domain) for domain in rule_domains),\n         max(len(rule.endpoint) for rule in rules),\n         max(len(methods) for methods in rule_methods),\n         max(len(rule.rule) for rule in rules),\n     )\n     widths = [max(len(h), w) for h, w in zip(headers, widths)]\n-    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+\n+def _get_domain(rule):\n+    \"\"\"Get the domain for a rule, handling subdomain and server_name.\"\"\"\n+    if rule.subdomain:\n+        server_name = current_app.config.get('SERVER_NAME', '')\n+        if server_name:\n+            return f\"{rule.subdomain}.{server_name}\"\n+        else:\n+            return f\"{rule.subdomain}.<any>\"\n+    return \"<any>\"\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\")),\n+    default=\"endpoint\",\n+    help=\"Method to sort routes by.\",\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URL rules.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n+\n+    if sort in (\"endpoint\", \"rule\"):\n+        rules = sorted(rules, key=attrgetter(sort))\n+    elif sort == \"methods\":\n+        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n+    elif sort == \"domain\":\n+        rules = sorted(rules, key=_get_domain)\n+\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n+        for rule in rules\n+    ]\n+    \n+    rule_domains = [_get_domain(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    widths = (\n+        max(len(domain) for domain in rule_domains),\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n \n     click.echo(row.format(*headers).strip())\n     click.echo(row.format(*(\"-\" * width for width in widths)))\n \n     for rule, methods in zip(rules, rule_methods):\n-        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n+\n+def _get_domain(rule):\n+    \"\"\"Get the domain for a URL rule, handling subdomains and server names.\"\"\"\n+    if hasattr(rule, 'subdomain') and rule.subdomain:\n+        return f\"{rule.subdomain}.<domain>\"\n+    return \"any\"\n+\n+\n+@click.command(\"routes\", short_help=\"Show the routes for the app.\")\n+@click.option(\n+    \"--sort\",\n+    \"-s\",\n+    type=click.Choice((\"endpoint\", \"methods\", \"domain\", \"rule\")),\n+    default=\"endpoint\",\n+    help=\"Method to sort routes by.\",\n+)\n+@click.option(\"--all-methods\", is_flag=True, help=\"Show HEAD and OPTIONS methods.\")\n+@with_appcontext\n+def routes_command(sort: str, all_methods: bool) -> None:\n+    \"\"\"Show all registered routes with URL rules, including domain information.\"\"\"\n+    rules = list(current_app.url_map.iter_rules())\n+\n+    if not rules:\n+        click.echo(\"No routes were registered.\")\n+        return\n+\n+    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods)) for rule in rules\n+    ]\n+    \n+    rule_domains = [_get_domain(rule) for rule in rules]\n+\n+    headers = (\"Domain\", \"Endpoint\", \"Methods\", \"Rule\")\n+    sorts = {\n+        \"domain\": rule_domains,\n+        \"endpoint\": (rule.endpoint for rule in rules),\n+        \"methods\": rule_methods,\n+        \"rule\": (rule.rule for rule in rules),\n+    }\n+    rules = [rule for rule, _ in sorted(zip(rules, sorts[sort]), key=lambda x: x[1])]\n+    rule_methods = [\n+        \", \".join(sorted(rule.methods - ignored_methods)) for rule in rules\n+    ]\n+    rule_domains = [_get_domain(rule) for rule in rules]\n+\n+    widths = (\n+        max(len(domain) for domain in rule_domains),\n+        max(len(rule.endpoint) for rule in rules),\n+        max(len(methods) for methods in rule_methods),\n+        max(len(rule.rule) for rule in rules),\n+    )\n+    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n+    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}  {{3:<{3}}}\".format(*widths)\n+\n+    click.echo(row.format(*headers).strip())\n+    click.echo(row.format(*(\"-\" * width for width in widths)))\n+\n+    for rule, methods, domain in zip(rules, rule_methods, rule_domains):\n+        click.echo(row.format(domain, rule.endpoint, methods, rule.rule).rstrip())\n \n \n cli = FlaskGroup(\n"
  }
}