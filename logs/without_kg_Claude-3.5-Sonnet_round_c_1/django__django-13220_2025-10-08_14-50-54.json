{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/core/exceptions.py lines 183-184)": "\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare based on the form of ValidationError\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            # Both are dictionary forms - compare field by field\n            return self._compare_error_dicts(self.error_dict, other.error_dict)\n        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n            # One is dict form, one is not - normalize and compare messages\n            return set(self.messages) == set(other.messages)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            # Both are list forms - order-independent comparison\n            return self._compare_error_lists(self.error_list, other.error_list)\n        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n            # One is list form, one is single - normalize and compare\n            return set(self.messages) == set(other.messages)\n        else:\n            # Both are single error forms\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n    \n    def _compare_error_dicts(self, dict1, dict2):\n        \"\"\"Compare two error dictionaries in an order-independent manner.\"\"\"\n        if set(dict1.keys()) != set(dict2.keys()):\n            return False\n        \n        for field in dict1:\n            if not self._compare_error_lists(dict1[field], dict2[field]):\n                return False\n        return True\n    \n    def _compare_error_lists(self, list1, list2):\n        \"\"\"Compare two error lists in an order-independent manner.\"\"\"\n        if len(list1) != len(list2):\n            return False\n        \n        # Convert errors to comparable tuples (message, code, params)\n        def error_to_tuple(error):\n            if hasattr(error, 'message'):\n                return (error.message, getattr(error, 'code', None), getattr(error, 'params', None))\n            else:\n                return (str(error), None, None)\n        \n        list1_tuples = [error_to_tuple(error) for error in list1]\n        list2_tuples = [error_to_tuple(error) for error in list2]\n        \n        # Sort both lists for comparison\n        return sorted(list1_tuples) == sorted(list2_tuples)\n\n    def __hash__(self):\n        # ValidationError instances should not be hashable due to mutable content\n        raise TypeError(\"unhashable type: 'ValidationError'\")\n\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/core/exceptions.py lines 183-184)": [
      "\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare based on the form of ValidationError\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            # Both are dictionary forms - compare field by field\n            return self._compare_error_dicts(self.error_dict, other.error_dict)\n        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n            # One is dict form, one is not - normalize and compare messages\n            return set(self.messages) == set(other.messages)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            # Both are list forms - order-independent comparison\n            return self._compare_error_lists(self.error_list, other.error_list)\n        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n            # One is list form, one is single - normalize and compare\n            return set(self.messages) == set(other.messages)\n        else:\n            # Both are single error forms\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n\n    def _compare_error_dicts(self, dict1, dict2):\n        \"\"\"Compare two error dictionaries field by field, order-independent.\"\"\"\n        if set(dict1.keys()) != set(dict2.keys()):\n            return False\n        \n        for field in dict1:\n            if not self._compare_error_lists(dict1[field], dict2[field]):\n                return False\n        \n        return True\n\n    def _compare_error_lists(self, list1, list2):\n        \"\"\"Compare two error lists in an order-independent manner.\"\"\"\n        if len(list1) != len(list2):\n            return False\n        \n        # Convert ValidationError objects to comparable tuples\n        def error_to_tuple(error):\n            return (error.message, error.code, error.params)\n        \n        # Create multisets (count occurrences) for comparison\n        from collections import Counter\n        return Counter(error_to_tuple(e) for e in list1) == Counter(error_to_tuple(e) for e in list2)\n\n    def __hash__(self):\n        # ValidationError instances contain mutable data, so they shouldn't be hashable\n        raise TypeError(\"unhashable type: 'ValidationError'\")\n\n",
      "\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare based on the form of ValidationError\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            # Both are dictionary forms - compare field by field\n            return self._compare_error_dicts(self.error_dict, other.error_dict)\n        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n            # One is dict form, one is not - normalize and compare messages\n            return set(self.messages) == set(other.messages)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            # Both are list forms - order-independent comparison\n            return self._compare_error_lists(self.error_list, other.error_list)\n        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n            # One is list form, one is single - normalize and compare\n            return set(self.messages) == set(other.messages)\n        else:\n            # Both are single error forms\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n\n    def _compare_error_dicts(self, dict1, dict2):\n        \"\"\"Compare two error dictionaries field by field.\"\"\"\n        if set(dict1.keys()) != set(dict2.keys()):\n            return False\n        \n        for field in dict1.keys():\n            if not self._compare_error_lists(dict1[field], dict2[field]):\n                return False\n        return True\n\n    def _compare_error_lists(self, list1, list2):\n        \"\"\"Compare two error lists in an order-independent manner.\"\"\"\n        if len(list1) != len(list2):\n            return False\n        \n        # Convert errors to comparable tuples (message, code, params)\n        def error_to_tuple(error):\n            if hasattr(error, 'message'):\n                return (error.message, getattr(error, 'code', None), getattr(error, 'params', None))\n            else:\n                return (str(error), None, None)\n        \n        tuples1 = [error_to_tuple(error) for error in list1]\n        tuples2 = [error_to_tuple(error) for error in list2]\n        \n        # Sort both lists for comparison\n        return sorted(tuples1) == sorted(tuples2)\n\n    def __hash__(self):\n        # ValidationError instances contain mutable data, so they shouldn't be hashable\n        raise TypeError(\"unhashable type: 'ValidationError'\")\n\n",
      "\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare based on the form of ValidationError\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            # Both are dictionary forms - compare field by field\n            return self._compare_error_dicts(self.error_dict, other.error_dict)\n        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n            # One is dict form, one is not - normalize and compare messages\n            return set(self.messages) == set(other.messages)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            # Both are list forms - order-independent comparison\n            return self._compare_error_lists(self.error_list, other.error_list)\n        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n            # One is list form, one is single - normalize and compare\n            return set(self.messages) == set(other.messages)\n        else:\n            # Both are single error forms\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n    \n    def _compare_error_dicts(self, dict1, dict2):\n        if set(dict1.keys()) != set(dict2.keys()):\n            return False\n        for field in dict1:\n            if not self._compare_error_lists(dict1[field], dict2[field]):\n                return False\n        return True\n    \n    def _compare_error_lists(self, list1, list2):\n        if len(list1) != len(list2):\n            return False\n        \n        # Convert to comparable tuples (message, code, params)\n        def error_to_tuple(error):\n            if hasattr(error, 'message'):\n                return (error.message, getattr(error, 'code', None), getattr(error, 'params', None))\n            else:\n                return (str(error), None, None)\n        \n        tuples1 = [error_to_tuple(error) for error in list1]\n        tuples2 = [error_to_tuple(error) for error in list2]\n        \n        # Order-independent comparison\n        return sorted(tuples1) == sorted(tuples2)\n\n    def __hash__(self):\n        # ValidationError instances are unhashable due to mutable content\n        raise TypeError(\"unhashable type: 'ValidationError'\")\n\n",
      "\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare based on the form of ValidationError\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            # Both are dictionary forms - compare field by field\n            return self._compare_error_dicts(self.error_dict, other.error_dict)\n        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n            # One is dict form, one is not - normalize and compare messages\n            return set(self.messages) == set(other.messages)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            # Both are list forms - order-independent comparison\n            return self._compare_error_lists(self.error_list, other.error_list)\n        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n            # One is list form, one is single - normalize and compare\n            return set(self.messages) == set(other.messages)\n        else:\n            # Both are single error forms\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n    \n    def _compare_error_dicts(self, dict1, dict2):\n        \"\"\"Compare two error dictionaries field by field in order-independent manner.\"\"\"\n        if set(dict1.keys()) != set(dict2.keys()):\n            return False\n        \n        for field in dict1:\n            if not self._compare_error_lists(dict1[field], dict2[field]):\n                return False\n        return True\n    \n    def _compare_error_lists(self, list1, list2):\n        \"\"\"Compare two error lists in order-independent manner.\"\"\"\n        if len(list1) != len(list2):\n            return False\n        \n        # Convert to comparable format (message, code, params tuples)\n        errors1 = []\n        errors2 = []\n        \n        for error in list1:\n            if hasattr(error, 'message'):\n                errors1.append((error.message, getattr(error, 'code', None), getattr(error, 'params', None)))\n            else:\n                errors1.append((str(error), None, None))\n        \n        for error in list2:\n            if hasattr(error, 'message'):\n                errors2.append((error.message, getattr(error, 'code', None), getattr(error, 'params', None)))\n            else:\n                errors2.append((str(error), None, None))\n        \n        return sorted(errors1) == sorted(errors2)\n\n    def __hash__(self):\n        # ValidationError instances contain mutable data, so they should not be hashable\n        raise TypeError(\"unhashable type: 'ValidationError'\")\n",
      "\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare based on the form of ValidationError\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            # Both are dictionary forms - compare field by field\n            return self._compare_error_dicts(self.error_dict, other.error_dict)\n        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n            # One is dict form, one is not - normalize and compare messages\n            return set(self.messages) == set(other.messages)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            # Both are list forms - order-independent comparison\n            return self._compare_error_lists(self.error_list, other.error_list)\n        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n            # One is list form, one is single - normalize and compare\n            return set(self.messages) == set(other.messages)\n        else:\n            # Both are single error forms\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n\n    def _compare_error_dicts(self, dict1, dict2):\n        \"\"\"Compare two error dictionaries field by field, order-independent.\"\"\"\n        if set(dict1.keys()) != set(dict2.keys()):\n            return False\n        \n        for field in dict1:\n            if not self._compare_error_lists(dict1[field], dict2[field]):\n                return False\n        return True\n\n    def _compare_error_lists(self, list1, list2):\n        \"\"\"Compare two error lists in an order-independent manner.\"\"\"\n        if len(list1) != len(list2):\n            return False\n        \n        # Create comparable representations of errors\n        def error_key(error):\n            if hasattr(error, 'message'):\n                return (error.message, error.code, tuple(sorted(error.params.items())) if error.params else None)\n            return str(error)\n        \n        sorted_list1 = sorted(list1, key=error_key)\n        sorted_list2 = sorted(list2, key=error_key)\n        \n        for err1, err2 in zip(sorted_list1, sorted_list2):\n            if hasattr(err1, 'message') and hasattr(err2, 'message'):\n                if (err1.message != err2.message or \n                    err1.code != err2.code or \n                    err1.params != err2.params):\n                    return False\n            elif str(err1) != str(err2):\n                return False\n        \n        return True\n\n    def __hash__(self):\n        # ValidationError instances contain mutable data, so they shouldn't be hashable\n        raise TypeError(\"unhashable type: 'ValidationError'\")\n",
      "\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare based on the form of ValidationError\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            # Both are dictionary forms - compare field by field\n            return self._compare_error_dicts(self.error_dict, other.error_dict)\n        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n            # One is dict form, one is not - normalize and compare messages\n            return set(self.messages) == set(other.messages)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            # Both are list forms - order-independent comparison\n            return self._compare_error_lists(self.error_list, other.error_list)\n        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n            # One is list form, one is single - normalize and compare\n            return set(self.messages) == set(other.messages)\n        else:\n            # Both are single error forms\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n    \n    def _compare_error_dicts(self, dict1, dict2):\n        \"\"\"Compare two error dictionaries in an order-independent way.\"\"\"\n        if set(dict1.keys()) != set(dict2.keys()):\n            return False\n        \n        for field in dict1:\n            if not self._compare_error_lists(dict1[field], dict2[field]):\n                return False\n        return True\n    \n    def _compare_error_lists(self, list1, list2):\n        \"\"\"Compare two error lists in an order-independent way.\"\"\"\n        if len(list1) != len(list2):\n            return False\n        \n        # Convert ValidationErrors to comparable tuples\n        def error_to_tuple(error):\n            if hasattr(error, 'message'):\n                return (error.message, error.code, error.params)\n            else:\n                return (str(error), None, None)\n        \n        tuple_list1 = [error_to_tuple(error) for error in list1]\n        tuple_list2 = [error_to_tuple(error) for error in list2]\n        \n        # Sort both lists and compare\n        return sorted(tuple_list1) == sorted(tuple_list2)\n\n    def __hash__(self):\n        # ValidationError instances contain mutable data, so they should not be hashable\n        raise TypeError(\"unhashable type: 'ValidationError'\")\n\n",
      "\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare based on the form of ValidationError\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            # Both are dictionary forms - compare field by field\n            return self._compare_error_dicts(self.error_dict, other.error_dict)\n        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n            # One is dict form, one is not - normalize and compare messages\n            return set(self.messages) == set(other.messages)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            # Both are list forms - order-independent comparison\n            return self._compare_error_lists(self.error_list, other.error_list)\n        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n            # One is list form, one is single - normalize and compare\n            return set(self.messages) == set(other.messages)\n        else:\n            # Both are single error forms\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n\n    def _compare_error_dicts(self, dict1, dict2):\n        if set(dict1.keys()) != set(dict2.keys()):\n            return False\n        \n        for field in dict1:\n            if not self._compare_error_lists(dict1[field], dict2[field]):\n                return False\n        return True\n\n    def _compare_error_lists(self, list1, list2):\n        if len(list1) != len(list2):\n            return False\n        \n        # Convert errors to comparable tuples (message, code, params)\n        errors1 = []\n        errors2 = []\n        \n        for error in list1:\n            if hasattr(error, 'message'):\n                errors1.append((str(error.message), error.code, error.params))\n            else:\n                errors1.append((str(error), None, None))\n        \n        for error in list2:\n            if hasattr(error, 'message'):\n                errors2.append((str(error.message), error.code, error.params))\n            else:\n                errors2.append((str(error), None, None))\n        \n        return sorted(errors1) == sorted(errors2)\n\n    def __hash__(self):\n        # ValidationError instances should not be hashable due to mutable content\n        raise TypeError(\"unhashable type: 'ValidationError'\")\n\n",
      "\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare based on the form of ValidationError\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            # Both are dictionary forms - compare field by field\n            return self._compare_error_dicts(self.error_dict, other.error_dict)\n        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n            # One is dict form, one is not - normalize and compare messages\n            return set(self.messages) == set(other.messages)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            # Both are list forms - order-independent comparison\n            return self._compare_error_lists(self.error_list, other.error_list)\n        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n            # One is list form, one is single - normalize and compare\n            return set(self.messages) == set(other.messages)\n        else:\n            # Both are single error forms\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n\n    def _compare_error_dicts(self, dict1, dict2):\n        \"\"\"Compare two error dictionaries field by field in order-independent manner.\"\"\"\n        if set(dict1.keys()) != set(dict2.keys()):\n            return False\n        \n        for field in dict1:\n            if not self._compare_error_lists(dict1[field], dict2[field]):\n                return False\n        return True\n\n    def _compare_error_lists(self, list1, list2):\n        \"\"\"Compare two error lists in order-independent manner.\"\"\"\n        if len(list1) != len(list2):\n            return False\n        \n        # Convert errors to comparable tuples (message, code, params)\n        def error_to_tuple(error):\n            if hasattr(error, 'message'):\n                return (error.message, getattr(error, 'code', None), getattr(error, 'params', None))\n            else:\n                return (str(error), None, None)\n        \n        list1_tuples = [error_to_tuple(error) for error in list1]\n        list2_tuples = [error_to_tuple(error) for error in list2]\n        \n        # Sort both lists for comparison\n        return sorted(list1_tuples) == sorted(list2_tuples)\n\n    def __hash__(self):\n        # ValidationError instances are unhashable due to mutable content\n        raise TypeError(\"unhashable type: 'ValidationError'\")\n\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..d0a1989584 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -180,8 +180,62 @@ class ValidationError(Exception):\n         return repr(list(self))\n \n     def __repr__(self):\n+\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare based on the form of ValidationError\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both are dictionary forms - compare field by field\n+            return self._compare_error_dicts(self.error_dict, other.error_dict)\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One is dict form, one is not - normalize and compare messages\n+            return set(self.messages) == set(other.messages)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Both are list forms - order-independent comparison\n+            return self._compare_error_lists(self.error_list, other.error_list)\n+        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n+            # One is list form, one is single - normalize and compare\n+            return set(self.messages) == set(other.messages)\n+        else:\n+            # Both are single error forms\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+\n+    def _compare_error_dicts(self, dict1, dict2):\n+        \"\"\"Compare two error dictionaries in an order-independent manner.\"\"\"\n+        if set(dict1.keys()) != set(dict2.keys()):\n+            return False\n+        \n+        for key in dict1:\n+            if not self._compare_error_lists(dict1[key], dict2[key]):\n+                return False\n+        return True\n+\n+    def _compare_error_lists(self, list1, list2):\n+        \"\"\"Compare two error lists in an order-independent manner.\"\"\"\n+        if len(list1) != len(list2):\n+            return False\n+        \n+        # Convert errors to comparable tuples for order-independent comparison\n+        def error_to_tuple(error):\n+            if hasattr(error, 'message'):\n+                return (error.message, error.code, error.params)\n+            else:\n+                return (str(error), None, None)\n+        \n+        set1 = set(error_to_tuple(error) for error in list1)\n+        set2 = set(error_to_tuple(error) for error in list2)\n+        return set1 == set2\n+\n+    def __hash__(self):\n+        \"\"\"Make ValidationError unhashable since it contains mutable data.\"\"\"\n+        raise TypeError(\"unhashable type: 'ValidationError'\")\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_0": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..ea370c7fcf 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -179,9 +179,66 @@ class ValidationError(Exception):\n             return repr(dict(self))\n         return repr(list(self))\n \n+    def __repr__(self):\n+\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare based on the form of ValidationError\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both are dictionary forms - compare field by field\n+            return self._compare_error_dicts(self.error_dict, other.error_dict)\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One is dict form, one is not - normalize and compare messages\n+            return set(self.messages) == set(other.messages)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Both are list forms - order-independent comparison\n+            return self._compare_error_lists(self.error_list, other.error_list)\n+        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n+            # One is list form, one is single - normalize and compare\n+            return set(self.messages) == set(other.messages)\n+        else:\n+            # Both are single error forms\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+    \n+    def _compare_error_dicts(self, dict1, dict2):\n+        \"\"\"Compare two error dictionaries in an order-independent manner.\"\"\"\n+        if set(dict1.keys()) != set(dict2.keys()):\n+            return False\n+        \n+        for field in dict1:\n+            if not self._compare_error_lists(dict1[field], dict2[field]):\n+                return False\n+        return True\n+    \n+    def _compare_error_lists(self, list1, list2):\n+        \"\"\"Compare two error lists in an order-independent manner.\"\"\"\n+        if len(list1) != len(list2):\n+            return False\n+        \n+        # Convert errors to comparable tuples (message, code, params)\n+        def error_to_tuple(error):\n+            if hasattr(error, 'message'):\n+                return (error.message, getattr(error, 'code', None), getattr(error, 'params', None))\n+            else:\n+                return (str(error), None, None)\n+        \n+        list1_tuples = [error_to_tuple(error) for error in list1]\n+        list2_tuples = [error_to_tuple(error) for error in list2]\n+        \n+        # Sort both lists for comparison\n+        return sorted(list1_tuples) == sorted(list2_tuples)\n+\n+    def __hash__(self):\n+        # ValidationError instances should not be hashable due to mutable content\n+        raise TypeError(\"unhashable type: 'ValidationError'\")\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_1": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..4e289be3f9 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -179,9 +179,62 @@ class ValidationError(Exception):\n             return repr(dict(self))\n         return repr(list(self))\n \n+    def __repr__(self):\n+\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare based on the form of ValidationError\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both are dictionary forms - compare field by field\n+            return self._compare_error_dicts(self.error_dict, other.error_dict)\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One is dict form, one is not - normalize and compare messages\n+            return set(self.messages) == set(other.messages)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Both are list forms - order-independent comparison\n+            return self._compare_error_lists(self.error_list, other.error_list)\n+        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n+            # One is list form, one is single - normalize and compare\n+            return set(self.messages) == set(other.messages)\n+        else:\n+            # Both are single error forms\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+\n+    def _compare_error_dicts(self, dict1, dict2):\n+        \"\"\"Compare two error dictionaries field by field, order-independent.\"\"\"\n+        if set(dict1.keys()) != set(dict2.keys()):\n+            return False\n+        \n+        for field in dict1:\n+            if not self._compare_error_lists(dict1[field], dict2[field]):\n+                return False\n+        \n+        return True\n+\n+    def _compare_error_lists(self, list1, list2):\n+        \"\"\"Compare two error lists in an order-independent manner.\"\"\"\n+        if len(list1) != len(list2):\n+            return False\n+        \n+        # Convert ValidationError objects to comparable tuples\n+        def error_to_tuple(error):\n+            return (error.message, error.code, error.params)\n+        \n+        # Create multisets (count occurrences) for comparison\n+        from collections import Counter\n+        return Counter(error_to_tuple(e) for e in list1) == Counter(error_to_tuple(e) for e in list2)\n+\n+    def __hash__(self):\n+        # ValidationError instances contain mutable data, so they shouldn't be hashable\n+        raise TypeError(\"unhashable type: 'ValidationError'\")\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_2": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..f285de7514 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -179,9 +179,66 @@ class ValidationError(Exception):\n             return repr(dict(self))\n         return repr(list(self))\n \n+    def __repr__(self):\n+\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare based on the form of ValidationError\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both are dictionary forms - compare field by field\n+            return self._compare_error_dicts(self.error_dict, other.error_dict)\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One is dict form, one is not - normalize and compare messages\n+            return set(self.messages) == set(other.messages)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Both are list forms - order-independent comparison\n+            return self._compare_error_lists(self.error_list, other.error_list)\n+        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n+            # One is list form, one is single - normalize and compare\n+            return set(self.messages) == set(other.messages)\n+        else:\n+            # Both are single error forms\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+\n+    def _compare_error_dicts(self, dict1, dict2):\n+        \"\"\"Compare two error dictionaries field by field.\"\"\"\n+        if set(dict1.keys()) != set(dict2.keys()):\n+            return False\n+        \n+        for field in dict1.keys():\n+            if not self._compare_error_lists(dict1[field], dict2[field]):\n+                return False\n+        return True\n+\n+    def _compare_error_lists(self, list1, list2):\n+        \"\"\"Compare two error lists in an order-independent manner.\"\"\"\n+        if len(list1) != len(list2):\n+            return False\n+        \n+        # Convert errors to comparable tuples (message, code, params)\n+        def error_to_tuple(error):\n+            if hasattr(error, 'message'):\n+                return (error.message, getattr(error, 'code', None), getattr(error, 'params', None))\n+            else:\n+                return (str(error), None, None)\n+        \n+        tuples1 = [error_to_tuple(error) for error in list1]\n+        tuples2 = [error_to_tuple(error) for error in list2]\n+        \n+        # Sort both lists for comparison\n+        return sorted(tuples1) == sorted(tuples2)\n+\n+    def __hash__(self):\n+        # ValidationError instances contain mutable data, so they shouldn't be hashable\n+        raise TypeError(\"unhashable type: 'ValidationError'\")\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_3": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..1471a629ea 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -179,9 +179,63 @@ class ValidationError(Exception):\n             return repr(dict(self))\n         return repr(list(self))\n \n+    def __repr__(self):\n+\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare based on the form of ValidationError\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both are dictionary forms - compare field by field\n+            return self._compare_error_dicts(self.error_dict, other.error_dict)\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One is dict form, one is not - normalize and compare messages\n+            return set(self.messages) == set(other.messages)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Both are list forms - order-independent comparison\n+            return self._compare_error_lists(self.error_list, other.error_list)\n+        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n+            # One is list form, one is single - normalize and compare\n+            return set(self.messages) == set(other.messages)\n+        else:\n+            # Both are single error forms\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+    \n+    def _compare_error_dicts(self, dict1, dict2):\n+        if set(dict1.keys()) != set(dict2.keys()):\n+            return False\n+        for field in dict1:\n+            if not self._compare_error_lists(dict1[field], dict2[field]):\n+                return False\n+        return True\n+    \n+    def _compare_error_lists(self, list1, list2):\n+        if len(list1) != len(list2):\n+            return False\n+        \n+        # Convert to comparable tuples (message, code, params)\n+        def error_to_tuple(error):\n+            if hasattr(error, 'message'):\n+                return (error.message, getattr(error, 'code', None), getattr(error, 'params', None))\n+            else:\n+                return (str(error), None, None)\n+        \n+        tuples1 = [error_to_tuple(error) for error in list1]\n+        tuples2 = [error_to_tuple(error) for error in list2]\n+        \n+        # Order-independent comparison\n+        return sorted(tuples1) == sorted(tuples2)\n+\n+    def __hash__(self):\n+        # ValidationError instances are unhashable due to mutable content\n+        raise TypeError(\"unhashable type: 'ValidationError'\")\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_4": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..93d894a0f0 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -179,9 +179,70 @@ class ValidationError(Exception):\n             return repr(dict(self))\n         return repr(list(self))\n \n+    def __repr__(self):\n+\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare based on the form of ValidationError\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both are dictionary forms - compare field by field\n+            return self._compare_error_dicts(self.error_dict, other.error_dict)\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One is dict form, one is not - normalize and compare messages\n+            return set(self.messages) == set(other.messages)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Both are list forms - order-independent comparison\n+            return self._compare_error_lists(self.error_list, other.error_list)\n+        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n+            # One is list form, one is single - normalize and compare\n+            return set(self.messages) == set(other.messages)\n+        else:\n+            # Both are single error forms\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+    \n+    def _compare_error_dicts(self, dict1, dict2):\n+        \"\"\"Compare two error dictionaries field by field in order-independent manner.\"\"\"\n+        if set(dict1.keys()) != set(dict2.keys()):\n+            return False\n+        \n+        for field in dict1:\n+            if not self._compare_error_lists(dict1[field], dict2[field]):\n+                return False\n+        return True\n+    \n+    def _compare_error_lists(self, list1, list2):\n+        \"\"\"Compare two error lists in order-independent manner.\"\"\"\n+        if len(list1) != len(list2):\n+            return False\n+        \n+        # Convert to comparable format (message, code, params tuples)\n+        errors1 = []\n+        errors2 = []\n+        \n+        for error in list1:\n+            if hasattr(error, 'message'):\n+                errors1.append((error.message, getattr(error, 'code', None), getattr(error, 'params', None)))\n+            else:\n+                errors1.append((str(error), None, None))\n+        \n+        for error in list2:\n+            if hasattr(error, 'message'):\n+                errors2.append((error.message, getattr(error, 'code', None), getattr(error, 'params', None)))\n+            else:\n+                errors2.append((str(error), None, None))\n+        \n+        return sorted(errors1) == sorted(errors2)\n+\n+    def __hash__(self):\n+        # ValidationError instances contain mutable data, so they should not be hashable\n+        raise TypeError(\"unhashable type: 'ValidationError'\")\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_5": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..6fd27059b4 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -179,9 +179,72 @@ class ValidationError(Exception):\n             return repr(dict(self))\n         return repr(list(self))\n \n+    def __repr__(self):\n+\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare based on the form of ValidationError\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both are dictionary forms - compare field by field\n+            return self._compare_error_dicts(self.error_dict, other.error_dict)\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One is dict form, one is not - normalize and compare messages\n+            return set(self.messages) == set(other.messages)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Both are list forms - order-independent comparison\n+            return self._compare_error_lists(self.error_list, other.error_list)\n+        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n+            # One is list form, one is single - normalize and compare\n+            return set(self.messages) == set(other.messages)\n+        else:\n+            # Both are single error forms\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+\n+    def _compare_error_dicts(self, dict1, dict2):\n+        \"\"\"Compare two error dictionaries field by field, order-independent.\"\"\"\n+        if set(dict1.keys()) != set(dict2.keys()):\n+            return False\n+        \n+        for field in dict1:\n+            if not self._compare_error_lists(dict1[field], dict2[field]):\n+                return False\n+        return True\n+\n+    def _compare_error_lists(self, list1, list2):\n+        \"\"\"Compare two error lists in an order-independent manner.\"\"\"\n+        if len(list1) != len(list2):\n+            return False\n+        \n+        # Create comparable representations of errors\n+        def error_key(error):\n+            if hasattr(error, 'message'):\n+                return (error.message, error.code, tuple(sorted(error.params.items())) if error.params else None)\n+            return str(error)\n+        \n+        sorted_list1 = sorted(list1, key=error_key)\n+        sorted_list2 = sorted(list2, key=error_key)\n+        \n+        for err1, err2 in zip(sorted_list1, sorted_list2):\n+            if hasattr(err1, 'message') and hasattr(err2, 'message'):\n+                if (err1.message != err2.message or \n+                    err1.code != err2.code or \n+                    err1.params != err2.params):\n+                    return False\n+            elif str(err1) != str(err2):\n+                return False\n+        \n+        return True\n+\n+    def __hash__(self):\n+        # ValidationError instances contain mutable data, so they shouldn't be hashable\n+        raise TypeError(\"unhashable type: 'ValidationError'\")\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_6": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..d922c44cc2 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -179,9 +179,66 @@ class ValidationError(Exception):\n             return repr(dict(self))\n         return repr(list(self))\n \n+    def __repr__(self):\n+\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare based on the form of ValidationError\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both are dictionary forms - compare field by field\n+            return self._compare_error_dicts(self.error_dict, other.error_dict)\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One is dict form, one is not - normalize and compare messages\n+            return set(self.messages) == set(other.messages)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Both are list forms - order-independent comparison\n+            return self._compare_error_lists(self.error_list, other.error_list)\n+        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n+            # One is list form, one is single - normalize and compare\n+            return set(self.messages) == set(other.messages)\n+        else:\n+            # Both are single error forms\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+    \n+    def _compare_error_dicts(self, dict1, dict2):\n+        \"\"\"Compare two error dictionaries in an order-independent way.\"\"\"\n+        if set(dict1.keys()) != set(dict2.keys()):\n+            return False\n+        \n+        for field in dict1:\n+            if not self._compare_error_lists(dict1[field], dict2[field]):\n+                return False\n+        return True\n+    \n+    def _compare_error_lists(self, list1, list2):\n+        \"\"\"Compare two error lists in an order-independent way.\"\"\"\n+        if len(list1) != len(list2):\n+            return False\n+        \n+        # Convert ValidationErrors to comparable tuples\n+        def error_to_tuple(error):\n+            if hasattr(error, 'message'):\n+                return (error.message, error.code, error.params)\n+            else:\n+                return (str(error), None, None)\n+        \n+        tuple_list1 = [error_to_tuple(error) for error in list1]\n+        tuple_list2 = [error_to_tuple(error) for error in list2]\n+        \n+        # Sort both lists and compare\n+        return sorted(tuple_list1) == sorted(tuple_list2)\n+\n+    def __hash__(self):\n+        # ValidationError instances contain mutable data, so they should not be hashable\n+        raise TypeError(\"unhashable type: 'ValidationError'\")\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_7": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..61800337da 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -179,9 +179,69 @@ class ValidationError(Exception):\n             return repr(dict(self))\n         return repr(list(self))\n \n+    def __repr__(self):\n+\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare based on the form of ValidationError\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both are dictionary forms - compare field by field\n+            return self._compare_error_dicts(self.error_dict, other.error_dict)\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One is dict form, one is not - normalize and compare messages\n+            return set(self.messages) == set(other.messages)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Both are list forms - order-independent comparison\n+            return self._compare_error_lists(self.error_list, other.error_list)\n+        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n+            # One is list form, one is single - normalize and compare\n+            return set(self.messages) == set(other.messages)\n+        else:\n+            # Both are single error forms\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+\n+    def _compare_error_dicts(self, dict1, dict2):\n+        if set(dict1.keys()) != set(dict2.keys()):\n+            return False\n+        \n+        for field in dict1:\n+            if not self._compare_error_lists(dict1[field], dict2[field]):\n+                return False\n+        return True\n+\n+    def _compare_error_lists(self, list1, list2):\n+        if len(list1) != len(list2):\n+            return False\n+        \n+        # Convert errors to comparable tuples (message, code, params)\n+        errors1 = []\n+        errors2 = []\n+        \n+        for error in list1:\n+            if hasattr(error, 'message'):\n+                errors1.append((str(error.message), error.code, error.params))\n+            else:\n+                errors1.append((str(error), None, None))\n+        \n+        for error in list2:\n+            if hasattr(error, 'message'):\n+                errors2.append((str(error.message), error.code, error.params))\n+            else:\n+                errors2.append((str(error), None, None))\n+        \n+        return sorted(errors1) == sorted(errors2)\n+\n+    def __hash__(self):\n+        # ValidationError instances should not be hashable due to mutable content\n+        raise TypeError(\"unhashable type: 'ValidationError'\")\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_8": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..126b38ff80 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -179,9 +179,66 @@ class ValidationError(Exception):\n             return repr(dict(self))\n         return repr(list(self))\n \n+    def __repr__(self):\n+\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare based on the form of ValidationError\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both are dictionary forms - compare field by field\n+            return self._compare_error_dicts(self.error_dict, other.error_dict)\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One is dict form, one is not - normalize and compare messages\n+            return set(self.messages) == set(other.messages)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Both are list forms - order-independent comparison\n+            return self._compare_error_lists(self.error_list, other.error_list)\n+        elif hasattr(self, 'error_list') or hasattr(other, 'error_list'):\n+            # One is list form, one is single - normalize and compare\n+            return set(self.messages) == set(other.messages)\n+        else:\n+            # Both are single error forms\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+\n+    def _compare_error_dicts(self, dict1, dict2):\n+        \"\"\"Compare two error dictionaries field by field in order-independent manner.\"\"\"\n+        if set(dict1.keys()) != set(dict2.keys()):\n+            return False\n+        \n+        for field in dict1:\n+            if not self._compare_error_lists(dict1[field], dict2[field]):\n+                return False\n+        return True\n+\n+    def _compare_error_lists(self, list1, list2):\n+        \"\"\"Compare two error lists in order-independent manner.\"\"\"\n+        if len(list1) != len(list2):\n+            return False\n+        \n+        # Convert errors to comparable tuples (message, code, params)\n+        def error_to_tuple(error):\n+            if hasattr(error, 'message'):\n+                return (error.message, getattr(error, 'code', None), getattr(error, 'params', None))\n+            else:\n+                return (str(error), None, None)\n+        \n+        list1_tuples = [error_to_tuple(error) for error in list1]\n+        list2_tuples = [error_to_tuple(error) for error in list2]\n+        \n+        # Sort both lists for comparison\n+        return sorted(list1_tuples) == sorted(list2_tuples)\n+\n+    def __hash__(self):\n+        # ValidationError instances are unhashable due to mutable content\n+        raise TypeError(\"unhashable type: 'ValidationError'\")\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n"
  }
}