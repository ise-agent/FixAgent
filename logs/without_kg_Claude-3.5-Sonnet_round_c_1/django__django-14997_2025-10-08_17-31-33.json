{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/backends/ddl_references.py lines 233-236)": "\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        params = map(self.quote_value, params)\n        # For SQLite unique index creation, strip table qualifiers from column references\n        if (hasattr(self.compiler, 'connection') and \n            self.compiler.connection.vendor == 'sqlite' and\n            hasattr(self, '_for_unique_index') and self._for_unique_index):\n            # Remove table qualifiers like \"table_name\".\"column\" -> \"column\"\n            import re\n            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n        return sql % tuple(params)\n",
    "Location 2 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 1276-1280)": "\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # For SQLite, pass context to avoid table-qualified column names in unique indexes\n            sqlite_unique_index = (\n                hasattr(self, 'connection') and \n                self.connection.vendor == 'sqlite' and \n                sql == self.sql_create_unique_index\n            )\n            columns = Expressions(table, expressions, compiler, self.quote_value, sqlite_unique_index=sqlite_unique_index)\n        return Statement(\n            sql,\n",
    "Location 3 (/root/hy/projects_1/django/django/db/backends/sqlite3/schema.py lines 300-305)": "\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            self.execute(sql)\n        self.deferred_sql = []\n",
    "Location 4 (/root/hy/projects_1/django/django/db/backends/ddl_references.py lines 204-211)": "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_unique=False):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        self.for_sqlite_unique = for_sqlite_unique\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n",
    "Location 5 (/root/hy/projects_1/django/django/db/backends/sqlite3/schema.py lines 15-20)": "\n    sql_delete_table = \"DROP TABLE %(table)s\"\n    sql_create_fk = None\n    sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n    sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n    sql_delete_unique = \"DROP INDEX %(name)s\"\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/backends/ddl_references.py lines 233-236)": [
      "\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        params = map(self.quote_value, params)\n        \n        # For SQLite unique index creation, remove table qualifiers from column references\n        if (hasattr(self.compiler.connection, 'vendor') and \n            self.compiler.connection.vendor == 'sqlite' and\n            hasattr(self, '_for_unique_index') and self._for_unique_index):\n            # Remove table qualifiers like \"table_name\".\"column_name\" -> \"column_name\"\n            import re\n            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n        \n        return sql % tuple(params)\n",
      "\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        params = map(self.quote_value, params)\n        \n        # Special handling for SQLite unique indexes - remove table qualifiers\n        if (hasattr(self.compiler, 'connection') and \n            self.compiler.connection.vendor == 'sqlite' and\n            hasattr(self, '_for_unique_index') and self._for_unique_index):\n            # Remove table qualifiers from column references for SQLite unique indexes\n            import re\n            # Pattern to match table-qualified column names like \"table\".\"column\"\n            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n        \n        return sql % tuple(params)\n",
      "\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        params = map(self.quote_value, params)\n        # For SQLite unique indexes, we need unqualified column names\n        # Check if this is SQLite and we're in a unique index context\n        if (hasattr(self.compiler, 'connection') and \n            self.compiler.connection.vendor == 'sqlite' and\n            hasattr(self, '_for_unique_index') and self._for_unique_index):\n            # Remove table qualifiers from column references in the SQL\n            # This handles patterns like \"table\".\"column\" -> \"column\"\n            import re\n            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n        return sql % tuple(params)\n",
      "\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        params = map(self.quote_value, params)\n        # For SQLite unique index creation, remove table qualifiers from column references\n        if (hasattr(self.compiler.connection, 'vendor') and \n            self.compiler.connection.vendor == 'sqlite' and\n            hasattr(self, '_for_unique_index') and self._for_unique_index):\n            # Remove table qualifiers like \"table_name\".\"column\" -> \"column\"\n            import re\n            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n        return sql % tuple(params)\n",
      "\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        params = map(self.quote_value, params)\n        \n        # For SQLite unique indexes, remove table qualifiers from column references\n        if (hasattr(self.compiler, 'connection') and \n            self.compiler.connection.vendor == 'sqlite' and\n            hasattr(self, '_for_unique_index') and self._for_unique_index):\n            # Remove table qualifiers like \"table_name\".\"column_name\" -> \"column_name\"\n            import re\n            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n        \n        return sql % tuple(params)\n",
      "\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        params = map(self.quote_value, params)\n        # For SQLite unique index creation, remove table qualifiers from column references\n        if (hasattr(self.compiler.connection, 'vendor') and \n            self.compiler.connection.vendor == 'sqlite' and\n            hasattr(self, '_for_unique_index') and self._for_unique_index):\n            # Remove table qualifiers like \"table_name\".\"column\" -> \"column\"\n            import re\n            sql = re.sub(r'\"[^\"]*\"\\.\"([^\"]*)\"', r'\"\\1\"', sql)\n        return sql % tuple(params)\n",
      "\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        params = map(self.quote_value, params)\n        # Check if this is for SQLite unique index creation\n        if (hasattr(self.compiler.connection, 'vendor') and \n            self.compiler.connection.vendor == 'sqlite' and\n            hasattr(self, '_for_unique_index') and self._for_unique_index):\n            # For SQLite unique indexes, remove table qualifiers from column names\n            # Replace \"table_name\".\"column_name\" with just \"column_name\"\n            import re\n            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n        return sql % tuple(params)\n",
      "\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        params = map(self.quote_value, params)\n        \n        # For SQLite unique index creation, remove table qualifiers from column names\n        # to avoid \".\" operator prohibition in index expressions\n        if (hasattr(self.compiler.connection, 'vendor') and \n            self.compiler.connection.vendor == 'sqlite' and\n            hasattr(self, '_for_unique_index') and self._for_unique_index):\n            # Remove table qualifiers like \"table_name\".\"column\" -> \"column\"\n            import re\n            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n        \n        return sql % tuple(params)\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 1276-1280)": [
      "\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # For SQLite unique indexes, we need unqualified column names\n            if hasattr(self, 'connection') and 'sqlite' in self.connection.vendor:\n                columns = Expressions(table, expressions, compiler, self.quote_value, qualify_columns=False)\n            else:\n                columns = Expressions(table, expressions, compiler, self.quote_value)\n        return Statement(\n            sql,\n",
      "\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # For SQLite unique indexes with expressions, we need unqualified column names\n            # to avoid the \".\" operator which is prohibited in index expressions\n            use_table_name = not (hasattr(self, 'connection') and \n                                self.connection.vendor == 'sqlite' and \n                                sql == self.sql_create_unique_index)\n            columns = Expressions(table, expressions, compiler, self.quote_value, use_table_name=use_table_name)\n        return Statement(\n            sql,\n",
      "\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # For SQLite unique indexes with expressions, we need unqualified column names\n            # to avoid the \".\" operator which is prohibited in index expressions\n            use_qualified_names = not (\n                hasattr(self, 'connection') and \n                self.connection.vendor == 'sqlite' and \n                sql == self.sql_create_unique_index\n            )\n            columns = Expressions(table, expressions, compiler, self.quote_value, use_qualified_names=use_qualified_names)\n        return Statement(\n            sql,\n",
      "\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # For SQLite unique indexes with expressions, we need unqualified column names\n            # to avoid the \".\" operator which is prohibited in index expressions\n            use_unqualified = (\n                hasattr(self, 'connection') and \n                self.connection.vendor == 'sqlite' and\n                sql == self.sql_create_unique_index\n            )\n            columns = Expressions(table, expressions, compiler, self.quote_value, use_unqualified_names=use_unqualified)\n        return Statement(\n            sql,\n",
      "\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # For SQLite, pass a flag to indicate this is for unique index creation\n            # to avoid table-qualified column names which are not allowed\n            is_sqlite_unique_index = (\n                hasattr(self, 'connection') and \n                self.connection.vendor == 'sqlite' and \n                sql == self.sql_create_unique_index\n            )\n            columns = Expressions(table, expressions, compiler, self.quote_value, \n                                sqlite_unique_index=is_sqlite_unique_index)\n        return Statement(\n            sql,\n",
      "\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # For SQLite, pass context to avoid table-qualified column names in unique indexes\n            sqlite_unique_index = (\n                hasattr(self, 'connection') and \n                self.connection.vendor == 'sqlite' and \n                sql == self.sql_create_unique_index\n            )\n            columns = Expressions(table, expressions, compiler, self.quote_value, sqlite_unique_index=sqlite_unique_index)\n        return Statement(\n            sql,\n",
      "\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # For SQLite unique indexes with expressions, we need unqualified column names\n            is_sqlite_unique_index = (\n                hasattr(self, 'connection') and \n                self.connection.vendor == 'sqlite' and\n                sql == self.sql_create_unique_index\n            )\n            columns = Expressions(table, expressions, compiler, self.quote_value, \n                                sqlite_unique_index=is_sqlite_unique_index)\n        return Statement(\n            sql,\n",
      "\n        columns = [field.column for field in fields]\n        if name is None:\n            name = IndexName(table, columns, '_uniq', create_unique_name)\n        else:\n            name = self.quote_name(name)\n        if condition or include or opclasses or expressions:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # Pass context to Expressions to indicate this is for a unique index\n            columns = Expressions(table, expressions, compiler, self.quote_value, for_unique_index=True)\n        return Statement(\n            sql,\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/backends/sqlite3/schema.py lines 300-305)": [
      "\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            # For SQLite unique constraints with F expressions, we need to handle\n            # table-qualified column references that cause syntax errors\n            if isinstance(sql, Statement) and hasattr(sql, 'template') and 'CREATE UNIQUE INDEX' in sql.template:\n                # Check if this is a unique constraint with F expressions that has table-qualified columns\n                sql_str = str(sql)\n                if '.' in sql_str and model._meta.db_table in sql_str:\n                    # Replace table-qualified column references with unqualified ones\n                    # This handles cases like \"myapp_tag\".\"name\" -> \"name\"\n                    import re\n                    # Pattern to match quoted table name followed by dot and quoted column\n                    pattern = rf'\"{re.escape(model._meta.db_table)}\"\\.\"([^\"]+)\"'\n                    sql_str = re.sub(pattern, r'\"\\1\"', sql_str)\n                    # Execute the modified SQL string directly\n                    self.execute(sql_str)\n                else:\n                    self.execute(sql)\n            else:\n                self.execute(sql)\n        self.deferred_sql = []\n",
      "\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            self.execute(sql)\n        self.deferred_sql = []\n",
      "\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            self.execute(sql)\n        self.deferred_sql = []\n",
      "\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            self.execute(sql)\n        self.deferred_sql = []\n",
      "\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            # Special handling for SQLite unique index creation with F expressions\n            if isinstance(sql, Statement) and hasattr(sql, 'template') and 'CREATE UNIQUE INDEX' in str(sql.template):\n                # For SQLite unique indexes, we need to strip table qualifiers from column names\n                # to avoid \".\" operator in index expressions which SQLite prohibits\n                sql_str = str(sql)\n                # Replace table-qualified column references with unqualified ones\n                # Pattern: \"table_name\".\"column_name\" -> \"column_name\"\n                import re\n                sql_str = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql_str)\n                self.execute(sql_str)\n            else:\n                self.execute(sql)\n        self.deferred_sql = []\n",
      "\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            self.execute(sql)\n        self.deferred_sql = []\n",
      "\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            # Handle SQLite unique constraint issues with F expressions\n            if hasattr(sql, 'template') and 'CREATE UNIQUE INDEX' in str(sql.template):\n                # For SQLite unique indexes, we need to strip table qualifiers from column names\n                # to avoid \".\" operator issues in index expressions\n                sql_str = str(sql)\n                # Replace table-qualified column references with unqualified ones\n                # Pattern: \"table_name\".\"column_name\" -> \"column_name\"\n                import re\n                sql_str = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql_str)\n                self.execute(sql_str)\n            else:\n                self.execute(sql)\n        self.deferred_sql = []\n",
      "\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            # Special handling for SQLite unique constraint creation\n            # Replace table-qualified column names with unqualified ones\n            if isinstance(sql, Statement) and \"CREATE UNIQUE INDEX\" in str(sql):\n                sql_str = str(sql)\n                # Remove table qualifications from column names in CREATE UNIQUE INDEX statements\n                # Pattern: \"table_name\".\"column_name\" -> \"column_name\"\n                import re\n                pattern = r'\"[^\"]+\"\\.\"([^\"]+)\"'\n                sql_str = re.sub(pattern, r'\"\\1\"', sql_str)\n                self.execute(sql_str)\n            else:\n                self.execute(sql)\n        self.deferred_sql = []\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/backends/ddl_references.py lines 204-211)": [
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        self.for_sqlite_index = for_sqlite_index\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        self.for_sqlite_index = for_sqlite_index\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        self.for_sqlite_index = for_sqlite_index\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        self.for_sqlite_index = for_sqlite_index\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        self.for_sqlite_index = for_sqlite_index\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        self.for_sqlite_index = for_sqlite_index\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        self.for_sqlite_index = for_sqlite_index\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/backends/sqlite3/schema.py lines 15-20)": [
      "\n    sql_delete_table = \"DROP TABLE %(table)s\"\n    sql_create_fk = None\n    sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n    sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n    sql_delete_unique = \"DROP INDEX %(name)s\"\n",
      "\n    sql_delete_table = \"DROP TABLE %(table)s\"\n    sql_create_fk = None\n    sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n    sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n    sql_delete_unique = \"DROP INDEX %(name)s\"\n",
      "\n    sql_delete_table = \"DROP TABLE %(table)s\"\n    sql_create_fk = None\n    sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n    sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n    sql_delete_unique = \"DROP INDEX %(name)s\"\n",
      "\n    sql_delete_table = \"DROP TABLE %(table)s\"\n    sql_create_fk = None\n    sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n    sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n    sql_delete_unique = \"DROP INDEX %(name)s\"\n",
      "\n    sql_delete_table = \"DROP TABLE %(table)s\"\n    sql_create_fk = None\n    sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n    sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n    sql_delete_unique = \"DROP INDEX %(name)s\"\n",
      "\n    sql_delete_table = \"DROP TABLE %(table)s\"\n    sql_create_fk = None\n    sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n    sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n    sql_delete_unique = \"DROP INDEX %(name)s\"\n\n    def _create_unique_sql(self, model, columns, name=None, suffix=\"\", condition=None, deferrable=None, include=None, opclasses=None):\n        \"\"\"\n        Return the SQL statement to create a unique constraint.\n        Override for SQLite to handle F expressions without table qualification.\n        \"\"\"\n        # Handle F expressions by creating unqualified column references\n        processed_columns = []\n        for column in columns:\n            if hasattr(column, 'resolve_expression'):\n                # This is an F expression - compile it without table qualification\n                compiler = self.connection.ops.compiler('SQLCompiler')(\n                    self.connection, self.connection\n                )\n                # Create a fake query with no table aliases to avoid qualification\n                from django.db.models.sql.query import Query\n                query = Query(model)\n                query.clear_select_clause()\n                resolved = column.resolve_expression(query)\n                sql, params = resolved.as_sql(compiler, self.connection)\n                # Remove any table qualification that might remain\n                sql = sql.replace(f'\"{model._meta.db_table}\".', '')\n                processed_columns.append(sql)\n            else:\n                processed_columns.append(column)\n        \n        return super()._create_unique_sql(\n            model, processed_columns, name, suffix, condition, deferrable, include, opclasses\n        )\n",
      "\n    sql_delete_table = \"DROP TABLE %(table)s\"\n    sql_create_fk = None\n    sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n    sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n    sql_delete_unique = \"DROP INDEX %(name)s\"\n",
      "\n    sql_delete_table = \"DROP TABLE %(table)s\"\n    sql_create_fk = None\n    sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n    sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n    sql_delete_unique = \"DROP INDEX %(name)s\"\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..cfd92c97cc 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1273,9 +1273,16 @@ class BaseDatabaseSchemaEditor:\n         else:\n             sql = self.sql_create_unique\n         if columns:\n+\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # Check if this is SQLite and we're creating a unique constraint\n+            is_sqlite_unique = (\n+                hasattr(self, 'connection') and \n+                self.connection.vendor == 'sqlite' and \n+                sql == self.sql_create_unique\n+            )\n+            columns = Expressions(table, expressions, compiler, self.quote_value, for_sqlite_unique=is_sqlite_unique)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..bf346ad1a2 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,14 +201,16 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n-class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n-        self.compiler = compiler\n-        self.expressions = expressions\n-        self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n-        super().__init__(table, columns)\n \n+    def __str__(self):\n+        if self.for_sqlite_unique:\n+            # For SQLite unique indexes, generate unqualified column names\n+            return ', '.join(self.quote_name(col) for col in self.columns)\n+        else:\n+            # Default behavior: use table-qualified column references\n+            sql, params = self.compiler.compile(self.expressions)\n+            params = map(self.quote_value, params)\n+            return sql % tuple(params)\n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -230,7 +232,12 @@ class Expressions(TableColumns):\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n \n-    def __str__(self):\n-        sql, params = self.compiler.compile(self.expressions)\n-        params = map(self.quote_value, params)\n-        return sql % tuple(params)\n+\n+class Expressions(TableColumns):\n+    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_unique=False):\n+        self.compiler = compiler\n+        self.expressions = expressions\n+        self.quote_value = quote_value\n+        self.for_sqlite_unique = for_sqlite_unique\n+        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        super().__init__(table, columns)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..6b9f99a72d 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -12,12 +12,12 @@ from django.db.transaction import atomic\n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n+\n     sql_delete_table = \"DROP TABLE %(table)s\"\n     sql_create_fk = None\n     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n     sql_delete_unique = \"DROP INDEX %(name)s\"\n-\n     def __enter__(self):\n         # Some SQLite schema alterations need foreign key constraints to be\n         # disabled. Enforce it here for the duration of the schema edition.\n@@ -298,6 +298,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n+\n         # Run deferred SQL on correct table\n         for sql in self.deferred_sql:\n             self.execute(sql)\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..34226487f0 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1272,10 +1272,18 @@ class BaseDatabaseSchemaEditor:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\n+        if columns:\n+\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # For SQLite, pass context to avoid table-qualified column names in unique indexes\n+            sqlite_unique_index = (\n+                hasattr(self, 'connection') and \n+                self.connection.vendor == 'sqlite' and \n+                sql == self.sql_create_unique_index\n+            )\n+            columns = Expressions(table, expressions, compiler, self.quote_value, sqlite_unique_index=sqlite_unique_index)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..76e098e3aa 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,14 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n+    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_unique=False):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n+        self.for_sqlite_unique = for_sqlite_unique\n         columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n         super().__init__(table, columns)\n-\n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -230,7 +231,15 @@ class Expressions(TableColumns):\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n \n+\n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\n         params = map(self.quote_value, params)\n+        # For SQLite unique index creation, strip table qualifiers from column references\n+        if (hasattr(self.compiler, 'connection') and \n+            self.compiler.connection.vendor == 'sqlite' and\n+            hasattr(self, '_for_unique_index') and self._for_unique_index):\n+            # Remove table qualifiers like \"table_name\".\"column\" -> \"column\"\n+            import re\n+            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n         return sql % tuple(params)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..d78bb7c25d 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -12,12 +12,12 @@ from django.db.transaction import atomic\n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n+\n     sql_delete_table = \"DROP TABLE %(table)s\"\n     sql_create_fk = None\n     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n     sql_delete_unique = \"DROP INDEX %(name)s\"\n-\n     def __enter__(self):\n         # Some SQLite schema alterations need foreign key constraints to be\n         # disabled. Enforce it here for the duration of the schema edition.\n@@ -302,7 +302,6 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         for sql in self.deferred_sql:\n             self.execute(sql)\n         self.deferred_sql = []\n-        # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n \n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..21e9e53ce0 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1272,10 +1272,16 @@ class BaseDatabaseSchemaEditor:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\n+        if columns:\n+\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # For SQLite unique indexes, we need unqualified column names\n+            if hasattr(self, 'connection') and 'sqlite' in self.connection.vendor:\n+                columns = Expressions(table, expressions, compiler, self.quote_value, qualify_columns=False)\n+            else:\n+                columns = Expressions(table, expressions, compiler, self.quote_value)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..b302d7034e 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,6 +201,7 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n@@ -208,7 +209,6 @@ class Expressions(TableColumns):\n         self.quote_value = quote_value\n         columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n         super().__init__(table, columns)\n-\n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -230,7 +230,17 @@ class Expressions(TableColumns):\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n \n+\n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\n         params = map(self.quote_value, params)\n+        \n+        # For SQLite unique index creation, remove table qualifiers from column references\n+        if (hasattr(self.compiler.connection, 'vendor') and \n+            self.compiler.connection.vendor == 'sqlite' and\n+            hasattr(self, '_for_unique_index') and self._for_unique_index):\n+            # Remove table qualifiers like \"table_name\".\"column_name\" -> \"column_name\"\n+            import re\n+            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n+        \n         return sql % tuple(params)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..af2c0beb08 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -12,12 +12,12 @@ from django.db.transaction import atomic\n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n+\n     sql_delete_table = \"DROP TABLE %(table)s\"\n     sql_create_fk = None\n     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n     sql_delete_unique = \"DROP INDEX %(name)s\"\n-\n     def __enter__(self):\n         # Some SQLite schema alterations need foreign key constraints to be\n         # disabled. Enforce it here for the duration of the schema edition.\n@@ -300,9 +300,25 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n         # Run deferred SQL on correct table\n         for sql in self.deferred_sql:\n-            self.execute(sql)\n+            # For SQLite unique constraints with F expressions, we need to handle\n+            # table-qualified column references that cause syntax errors\n+            if isinstance(sql, Statement) and hasattr(sql, 'template') and 'CREATE UNIQUE INDEX' in sql.template:\n+                # Check if this is a unique constraint with F expressions that has table-qualified columns\n+                sql_str = str(sql)\n+                if '.' in sql_str and model._meta.db_table in sql_str:\n+                    # Replace table-qualified column references with unqualified ones\n+                    # This handles cases like \"myapp_tag\".\"name\" -> \"name\"\n+                    import re\n+                    # Pattern to match quoted table name followed by dot and quoted column\n+                    pattern = rf'\"{re.escape(model._meta.db_table)}\"\\.\"([^\"]+)\"'\n+                    sql_str = re.sub(pattern, r'\"\\1\"', sql_str)\n+                    # Execute the modified SQL string directly\n+                    self.execute(sql_str)\n+                else:\n+                    self.execute(sql)\n+            else:\n+                self.execute(sql)\n         self.deferred_sql = []\n-        # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n \n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..7c359ac383 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1272,10 +1272,17 @@ class BaseDatabaseSchemaEditor:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\n+        if columns:\n+\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # For SQLite unique indexes with expressions, we need unqualified column names\n+            # to avoid the \".\" operator which is prohibited in index expressions\n+            use_table_name = not (hasattr(self, 'connection') and \n+                                self.connection.vendor == 'sqlite' and \n+                                sql == self.sql_create_unique_index)\n+            columns = Expressions(table, expressions, compiler, self.quote_value, use_table_name=use_table_name)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..d00d39a14b 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,14 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n+    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n+        self.for_sqlite_index = for_sqlite_index\n         columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n         super().__init__(table, columns)\n-\n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -230,7 +231,18 @@ class Expressions(TableColumns):\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n \n+\n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\n         params = map(self.quote_value, params)\n+        \n+        # Special handling for SQLite unique indexes - remove table qualifiers\n+        if (hasattr(self.compiler, 'connection') and \n+            self.compiler.connection.vendor == 'sqlite' and\n+            hasattr(self, '_for_unique_index') and self._for_unique_index):\n+            # Remove table qualifiers from column references for SQLite unique indexes\n+            import re\n+            # Pattern to match table-qualified column names like \"table\".\"column\"\n+            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n+        \n         return sql % tuple(params)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..d78bb7c25d 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -12,12 +12,12 @@ from django.db.transaction import atomic\n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n+\n     sql_delete_table = \"DROP TABLE %(table)s\"\n     sql_create_fk = None\n     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n     sql_delete_unique = \"DROP INDEX %(name)s\"\n-\n     def __enter__(self):\n         # Some SQLite schema alterations need foreign key constraints to be\n         # disabled. Enforce it here for the duration of the schema edition.\n@@ -302,7 +302,6 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         for sql in self.deferred_sql:\n             self.execute(sql)\n         self.deferred_sql = []\n-        # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n \n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..99b998563f 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1272,10 +1272,19 @@ class BaseDatabaseSchemaEditor:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\n+        if columns:\n+\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # For SQLite unique indexes with expressions, we need unqualified column names\n+            # to avoid the \".\" operator which is prohibited in index expressions\n+            use_qualified_names = not (\n+                hasattr(self, 'connection') and \n+                self.connection.vendor == 'sqlite' and \n+                sql == self.sql_create_unique_index\n+            )\n+            columns = Expressions(table, expressions, compiler, self.quote_value, use_qualified_names=use_qualified_names)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..0678a6aa87 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,14 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n+    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n+        self.for_sqlite_index = for_sqlite_index\n         columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n         super().__init__(table, columns)\n-\n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -230,7 +231,17 @@ class Expressions(TableColumns):\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n \n+\n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\n         params = map(self.quote_value, params)\n+        # For SQLite unique indexes, we need unqualified column names\n+        # Check if this is SQLite and we're in a unique index context\n+        if (hasattr(self.compiler, 'connection') and \n+            self.compiler.connection.vendor == 'sqlite' and\n+            hasattr(self, '_for_unique_index') and self._for_unique_index):\n+            # Remove table qualifiers from column references in the SQL\n+            # This handles patterns like \"table\".\"column\" -> \"column\"\n+            import re\n+            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n         return sql % tuple(params)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..d78bb7c25d 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -12,12 +12,12 @@ from django.db.transaction import atomic\n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n+\n     sql_delete_table = \"DROP TABLE %(table)s\"\n     sql_create_fk = None\n     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n     sql_delete_unique = \"DROP INDEX %(name)s\"\n-\n     def __enter__(self):\n         # Some SQLite schema alterations need foreign key constraints to be\n         # disabled. Enforce it here for the duration of the schema edition.\n@@ -302,7 +302,6 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         for sql in self.deferred_sql:\n             self.execute(sql)\n         self.deferred_sql = []\n-        # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n \n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..1146973dca 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1272,10 +1272,19 @@ class BaseDatabaseSchemaEditor:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\n+        if columns:\n+\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # For SQLite unique indexes with expressions, we need unqualified column names\n+            # to avoid the \".\" operator which is prohibited in index expressions\n+            use_unqualified = (\n+                hasattr(self, 'connection') and \n+                self.connection.vendor == 'sqlite' and\n+                sql == self.sql_create_unique_index\n+            )\n+            columns = Expressions(table, expressions, compiler, self.quote_value, use_unqualified_names=use_unqualified)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..705eedf93d 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,14 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n+    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n+        self.for_sqlite_index = for_sqlite_index\n         columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n         super().__init__(table, columns)\n-\n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -230,7 +231,15 @@ class Expressions(TableColumns):\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n \n+\n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\n         params = map(self.quote_value, params)\n+        # For SQLite unique index creation, remove table qualifiers from column references\n+        if (hasattr(self.compiler.connection, 'vendor') and \n+            self.compiler.connection.vendor == 'sqlite' and\n+            hasattr(self, '_for_unique_index') and self._for_unique_index):\n+            # Remove table qualifiers like \"table_name\".\"column\" -> \"column\"\n+            import re\n+            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n         return sql % tuple(params)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..d78bb7c25d 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -12,12 +12,12 @@ from django.db.transaction import atomic\n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n+\n     sql_delete_table = \"DROP TABLE %(table)s\"\n     sql_create_fk = None\n     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n     sql_delete_unique = \"DROP INDEX %(name)s\"\n-\n     def __enter__(self):\n         # Some SQLite schema alterations need foreign key constraints to be\n         # disabled. Enforce it here for the duration of the schema edition.\n@@ -302,7 +302,6 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         for sql in self.deferred_sql:\n             self.execute(sql)\n         self.deferred_sql = []\n-        # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n \n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..35aceba192 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1272,10 +1272,20 @@ class BaseDatabaseSchemaEditor:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\n+        if columns:\n+\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # For SQLite, pass a flag to indicate this is for unique index creation\n+            # to avoid table-qualified column names which are not allowed\n+            is_sqlite_unique_index = (\n+                hasattr(self, 'connection') and \n+                self.connection.vendor == 'sqlite' and \n+                sql == self.sql_create_unique_index\n+            )\n+            columns = Expressions(table, expressions, compiler, self.quote_value, \n+                                sqlite_unique_index=is_sqlite_unique_index)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..65ba797a32 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,14 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n+    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n+        self.for_sqlite_index = for_sqlite_index\n         columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n         super().__init__(table, columns)\n-\n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -230,7 +231,17 @@ class Expressions(TableColumns):\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n \n+\n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\n         params = map(self.quote_value, params)\n+        \n+        # For SQLite unique indexes, remove table qualifiers from column references\n+        if (hasattr(self.compiler, 'connection') and \n+            self.compiler.connection.vendor == 'sqlite' and\n+            hasattr(self, '_for_unique_index') and self._for_unique_index):\n+            # Remove table qualifiers like \"table_name\".\"column_name\" -> \"column_name\"\n+            import re\n+            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n+        \n         return sql % tuple(params)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..2e06dd1928 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -12,12 +12,12 @@ from django.db.transaction import atomic\n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n+\n     sql_delete_table = \"DROP TABLE %(table)s\"\n     sql_create_fk = None\n     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n     sql_delete_unique = \"DROP INDEX %(name)s\"\n-\n     def __enter__(self):\n         # Some SQLite schema alterations need foreign key constraints to be\n         # disabled. Enforce it here for the duration of the schema edition.\n@@ -300,9 +300,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n         # Run deferred SQL on correct table\n         for sql in self.deferred_sql:\n-            self.execute(sql)\n+            # Special handling for SQLite unique index creation with F expressions\n+            if isinstance(sql, Statement) and hasattr(sql, 'template') and 'CREATE UNIQUE INDEX' in str(sql.template):\n+                # For SQLite unique indexes, we need to strip table qualifiers from column names\n+                # to avoid \".\" operator in index expressions which SQLite prohibits\n+                sql_str = str(sql)\n+                # Replace table-qualified column references with unqualified ones\n+                # Pattern: \"table_name\".\"column_name\" -> \"column_name\"\n+                import re\n+                sql_str = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql_str)\n+                self.execute(sql_str)\n+            else:\n+                self.execute(sql)\n         self.deferred_sql = []\n-        # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n \n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..34226487f0 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1272,10 +1272,18 @@ class BaseDatabaseSchemaEditor:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\n+        if columns:\n+\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # For SQLite, pass context to avoid table-qualified column names in unique indexes\n+            sqlite_unique_index = (\n+                hasattr(self, 'connection') and \n+                self.connection.vendor == 'sqlite' and \n+                sql == self.sql_create_unique_index\n+            )\n+            columns = Expressions(table, expressions, compiler, self.quote_value, sqlite_unique_index=sqlite_unique_index)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..9b8719c09e 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,14 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n+    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n+        self.for_sqlite_index = for_sqlite_index\n         columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n         super().__init__(table, columns)\n-\n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -230,7 +231,15 @@ class Expressions(TableColumns):\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n \n+\n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\n         params = map(self.quote_value, params)\n+        # For SQLite unique index creation, remove table qualifiers from column references\n+        if (hasattr(self.compiler.connection, 'vendor') and \n+            self.compiler.connection.vendor == 'sqlite' and\n+            hasattr(self, '_for_unique_index') and self._for_unique_index):\n+            # Remove table qualifiers like \"table_name\".\"column\" -> \"column\"\n+            import re\n+            sql = re.sub(r'\"[^\"]*\"\\.\"([^\"]*)\"', r'\"\\1\"', sql)\n         return sql % tuple(params)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..2f90fa5902 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -12,12 +12,41 @@ from django.db.transaction import atomic\n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n+\n     sql_delete_table = \"DROP TABLE %(table)s\"\n     sql_create_fk = None\n     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n     sql_delete_unique = \"DROP INDEX %(name)s\"\n \n+    def _create_unique_sql(self, model, columns, name=None, suffix=\"\", condition=None, deferrable=None, include=None, opclasses=None):\n+        \"\"\"\n+        Return the SQL statement to create a unique constraint.\n+        Override for SQLite to handle F expressions without table qualification.\n+        \"\"\"\n+        # Handle F expressions by creating unqualified column references\n+        processed_columns = []\n+        for column in columns:\n+            if hasattr(column, 'resolve_expression'):\n+                # This is an F expression - compile it without table qualification\n+                compiler = self.connection.ops.compiler('SQLCompiler')(\n+                    self.connection, self.connection\n+                )\n+                # Create a fake query with no table aliases to avoid qualification\n+                from django.db.models.sql.query import Query\n+                query = Query(model)\n+                query.clear_select_clause()\n+                resolved = column.resolve_expression(query)\n+                sql, params = resolved.as_sql(compiler, self.connection)\n+                # Remove any table qualification that might remain\n+                sql = sql.replace(f'\"{model._meta.db_table}\".', '')\n+                processed_columns.append(sql)\n+            else:\n+                processed_columns.append(column)\n+        \n+        return super()._create_unique_sql(\n+            model, processed_columns, name, suffix, condition, deferrable, include, opclasses\n+        )\n     def __enter__(self):\n         # Some SQLite schema alterations need foreign key constraints to be\n         # disabled. Enforce it here for the duration of the schema edition.\n@@ -302,7 +331,6 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         for sql in self.deferred_sql:\n             self.execute(sql)\n         self.deferred_sql = []\n-        # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n \n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..13a036a581 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1272,10 +1272,19 @@ class BaseDatabaseSchemaEditor:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\n+        if columns:\n+\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # For SQLite unique indexes with expressions, we need unqualified column names\n+            is_sqlite_unique_index = (\n+                hasattr(self, 'connection') and \n+                self.connection.vendor == 'sqlite' and\n+                sql == self.sql_create_unique_index\n+            )\n+            columns = Expressions(table, expressions, compiler, self.quote_value, \n+                                sqlite_unique_index=is_sqlite_unique_index)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..e841f1b1f6 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,14 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n+    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n+        self.for_sqlite_index = for_sqlite_index\n         columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n         super().__init__(table, columns)\n-\n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -230,7 +231,16 @@ class Expressions(TableColumns):\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n \n+\n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\n         params = map(self.quote_value, params)\n+        # Check if this is for SQLite unique index creation\n+        if (hasattr(self.compiler.connection, 'vendor') and \n+            self.compiler.connection.vendor == 'sqlite' and\n+            hasattr(self, '_for_unique_index') and self._for_unique_index):\n+            # For SQLite unique indexes, remove table qualifiers from column names\n+            # Replace \"table_name\".\"column_name\" with just \"column_name\"\n+            import re\n+            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n         return sql % tuple(params)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..5fa51808a1 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -12,12 +12,12 @@ from django.db.transaction import atomic\n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n+\n     sql_delete_table = \"DROP TABLE %(table)s\"\n     sql_create_fk = None\n     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n     sql_delete_unique = \"DROP INDEX %(name)s\"\n-\n     def __enter__(self):\n         # Some SQLite schema alterations need foreign key constraints to be\n         # disabled. Enforce it here for the duration of the schema edition.\n@@ -300,9 +300,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n         # Run deferred SQL on correct table\n         for sql in self.deferred_sql:\n-            self.execute(sql)\n+            # Handle SQLite unique constraint issues with F expressions\n+            if hasattr(sql, 'template') and 'CREATE UNIQUE INDEX' in str(sql.template):\n+                # For SQLite unique indexes, we need to strip table qualifiers from column names\n+                # to avoid \".\" operator issues in index expressions\n+                sql_str = str(sql)\n+                # Replace table-qualified column references with unqualified ones\n+                # Pattern: \"table_name\".\"column_name\" -> \"column_name\"\n+                import re\n+                sql_str = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql_str)\n+                self.execute(sql_str)\n+            else:\n+                self.execute(sql)\n         self.deferred_sql = []\n-        # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n \n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..9e3adc054d 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1263,6 +1263,17 @@ class BaseDatabaseSchemaEditor:\n \n         compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n         table = model._meta.db_table\n+        columns = [field.column for field in fields]\n+        if name is None:\n+            name = IndexName(table, columns, '_uniq', create_unique_name)\n+        else:\n+            name = self.quote_name(name)\n+        if condition or include or opclasses or expressions:\n+            sql = self.sql_create_unique_index\n+        else:\n+            sql = self.sql_create_unique\n+        if columns:\n+\n         columns = [field.column for field in fields]\n         if name is None:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n@@ -1275,7 +1286,8 @@ class BaseDatabaseSchemaEditor:\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # Pass context to Expressions to indicate this is for a unique index\n+            columns = Expressions(table, expressions, compiler, self.quote_value, for_unique_index=True)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..c98f1b5477 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,14 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n+    def __init__(self, table, expressions, compiler, quote_value, for_sqlite_index=False):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n+        self.for_sqlite_index = for_sqlite_index\n         columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n         super().__init__(table, columns)\n-\n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -230,7 +231,18 @@ class Expressions(TableColumns):\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n \n+\n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\n         params = map(self.quote_value, params)\n+        \n+        # For SQLite unique index creation, remove table qualifiers from column names\n+        # to avoid \".\" operator prohibition in index expressions\n+        if (hasattr(self.compiler.connection, 'vendor') and \n+            self.compiler.connection.vendor == 'sqlite' and\n+            hasattr(self, '_for_unique_index') and self._for_unique_index):\n+            # Remove table qualifiers like \"table_name\".\"column\" -> \"column\"\n+            import re\n+            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n+        \n         return sql % tuple(params)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..86a66893ef 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -12,12 +12,12 @@ from django.db.transaction import atomic\n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n+\n     sql_delete_table = \"DROP TABLE %(table)s\"\n     sql_create_fk = None\n     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n     sql_delete_unique = \"DROP INDEX %(name)s\"\n-\n     def __enter__(self):\n         # Some SQLite schema alterations need foreign key constraints to be\n         # disabled. Enforce it here for the duration of the schema edition.\n@@ -300,9 +300,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n         # Run deferred SQL on correct table\n         for sql in self.deferred_sql:\n-            self.execute(sql)\n+            # Special handling for SQLite unique constraint creation\n+            # Replace table-qualified column names with unqualified ones\n+            if isinstance(sql, Statement) and \"CREATE UNIQUE INDEX\" in str(sql):\n+                sql_str = str(sql)\n+                # Remove table qualifications from column names in CREATE UNIQUE INDEX statements\n+                # Pattern: \"table_name\".\"column_name\" -> \"column_name\"\n+                import re\n+                pattern = r'\"[^\"]+\"\\.\"([^\"]+)\"'\n+                sql_str = re.sub(pattern, r'\"\\1\"', sql_str)\n+                self.execute(sql_str)\n+            else:\n+                self.execute(sql)\n         self.deferred_sql = []\n-        # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n \n"
  }
}