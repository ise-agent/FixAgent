{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/artist.py lines 1305-1313)": "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 1910-1915)": "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n",
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/colorbar.py lines 1167-1169)": "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/tests/test_image.py lines 1074-1086)": "\ndef test_image_cursor_formatting():\n    fig, ax = plt.subplots()\n    # Create a dummy image to be able to call format_cursor_data\n    im = ax.imshow(np.zeros((4, 4)))\n\n    data = np.ma.masked_array([0], mask=[True])\n    assert im.format_cursor_data(data) == '[]'\n\n    data = np.ma.masked_array([0], mask=[False])\n    assert im.format_cursor_data(data) == '[0]'\n\n    data = np.nan\n    assert im.format_cursor_data(data) == '[nan]'\n\n\ndef test_format_cursor_data_with_boundary_norm():\n    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n    fig, ax = plt.subplots()\n    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n    X = np.random.randn(4, 4)\n    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n    \n    # This should not raise a ValueError\n    result = im.format_cursor_data(1.5)\n    assert isinstance(result, str)\n    assert result.startswith('[') and result.endswith(']')\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/artist.py lines 1305-1313)": [
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                else:\n                    # BoundaryNorm is not invertible, use default precision\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                from . import colors\n                if not isinstance(self.norm, colors.BoundaryNorm):\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                else:\n                    # BoundaryNorm is not invertible, use default precision\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n"
    ],
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 1910-1915)": [
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colormap, in which case scalar\n        values are formatted using scalar formatters.\n\n        See Also\n        --------\n        ScalarMappable.format_cursor_data\n        \"\"\"\n        # Import here to avoid circular import.\n        from matplotlib import colors\n        if np.iterable(data):\n            data_str = '[' + ', '.join(cbook._auto_format_str(v)\n                                       for v in data.flat) + ']'\n        else:\n            try:\n                cmap = self.get_cmap()\n                norm = self.norm\n                if cmap is not None:\n                    normed = norm(data)\n                    if np.isfinite(normed):\n                        # Midpoints of neighboring color intervals.\n                        if not isinstance(norm, colors.BoundaryNorm):\n                            neighbors = norm.inverse(\n                                (int(normed * cmap.N) + np.array([0, 1])) / cmap.N)\n                            delta = abs(neighbors - data).max()\n                            g_sig_digits = cbook._g_sig_digits(data, delta)\n                        else:\n                            # BoundaryNorm is not invertible, use default precision\n                            g_sig_digits = 3\n                    else:\n                        g_sig_digits = 3  # Consistent with default below.\n                    data_str = '[{:-#.{}g}]'.format(data, g_sig_digits)\n                else:\n                    data_str = cbook._auto_format_str(data)\n            except (TypeError, IndexError):\n                data_str = cbook._auto_format_str(data)\n        return data_str\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n",
      "\ndef inverse(self, value):\n    \"\"\"\n    Raises\n    ------\n    ValueError\n        BoundaryNorm is not invertible, so calling this method will always\n        raise an error\n    \"\"\"\n    raise ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n\n\nclass NoNorm(Normalize):\n"
    ],
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/colorbar.py lines 1167-1169)": [
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            if not isinstance(self.norm, colors.BoundaryNorm):\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                # BoundaryNorm is not invertible, use default precision\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n"
    ],
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/tests/test_image.py lines 1074-1086)": [
      "\ndef test_image_cursor_formatting():\n    fig, ax = plt.subplots()\n    # Create a dummy image to be able to call format_cursor_data\n    im = ax.imshow(np.zeros((4, 4)))\n\n    data = np.ma.masked_array([0], mask=[True])\n    assert im.format_cursor_data(data) == '[]'\n\n    data = np.ma.masked_array([0], mask=[False])\n    assert im.format_cursor_data(data) == '[0]'\n\n    data = np.nan\n    assert im.format_cursor_data(data) == '[nan]'\n\n\ndef test_format_cursor_data_with_boundary_norm():\n    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n    fig, ax = plt.subplots()\n    norm = mcolors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n    X = np.random.randn(4, 4)\n    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n    \n    # This should not raise a ValueError\n    result = im.format_cursor_data(1.5)\n    assert isinstance(result, str)\n    assert result.startswith('[') and result.endswith(']')\n",
      "\ndef test_image_cursor_formatting():\n    fig, ax = plt.subplots()\n    # Create a dummy image to be able to call format_cursor_data\n    im = ax.imshow(np.zeros((4, 4)))\n\n    data = np.ma.masked_array([0], mask=[True])\n    assert im.format_cursor_data(data) == '[]'\n\n    data = np.ma.masked_array([0], mask=[False])\n    assert im.format_cursor_data(data) == '[0]'\n\n    data = np.nan\n    assert im.format_cursor_data(data) == '[nan]'\n\n\ndef test_format_cursor_data_with_boundary_norm():\n    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n    fig, ax = plt.subplots()\n    norm = mcolors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n    X = np.random.randn(4, 4)\n    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n    \n    # This should not raise a ValueError\n    result = im.format_cursor_data(1.5)\n    assert isinstance(result, str)\n    assert result.startswith('[') and result.endswith(']')\n",
      "\ndef test_image_cursor_formatting():\n    fig, ax = plt.subplots()\n    # Create a dummy image to be able to call format_cursor_data\n    im = ax.imshow(np.zeros((4, 4)))\n\n    data = np.ma.masked_array([0], mask=[True])\n    assert im.format_cursor_data(data) == '[]'\n\n    data = np.ma.masked_array([0], mask=[False])\n    assert im.format_cursor_data(data) == '[0]'\n\n    data = np.nan\n    assert im.format_cursor_data(data) == '[nan]'\n\n\ndef test_format_cursor_data_with_boundary_norm():\n    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n    fig, ax = plt.subplots()\n    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n    X = np.random.randn(4, 4)\n    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n    \n    # This should not raise a ValueError\n    result = im.format_cursor_data(1.5)\n    assert isinstance(result, str)\n    assert result.startswith('[') and result.endswith(']')\n",
      "\ndef test_image_cursor_formatting():\n    fig, ax = plt.subplots()\n    # Create a dummy image to be able to call format_cursor_data\n    im = ax.imshow(np.zeros((4, 4)))\n\n    data = np.ma.masked_array([0], mask=[True])\n    assert im.format_cursor_data(data) == '[]'\n\n    data = np.ma.masked_array([0], mask=[False])\n    assert im.format_cursor_data(data) == '[0]'\n\n    data = np.nan\n    assert im.format_cursor_data(data) == '[nan]'\n\n\ndef test_format_cursor_data_with_boundary_norm():\n    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n    fig, ax = plt.subplots()\n    norm = mcolors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n    X = np.random.randn(4, 4)\n    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n    \n    # This should not raise a ValueError\n    result = im.format_cursor_data(1.5)\n    assert isinstance(result, str)\n    assert result.startswith('[') and result.endswith(']')\n",
      "\ndef test_image_cursor_formatting():\n    fig, ax = plt.subplots()\n    # Create a dummy image to be able to call format_cursor_data\n    im = ax.imshow(np.zeros((4, 4)))\n\n    data = np.ma.masked_array([0], mask=[True])\n    assert im.format_cursor_data(data) == '[]'\n\n    data = np.ma.masked_array([0], mask=[False])\n    assert im.format_cursor_data(data) == '[0]'\n\n    data = np.nan\n    assert im.format_cursor_data(data) == '[nan]'\n\n\ndef test_format_cursor_data_with_boundary_norm():\n    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n    fig, ax = plt.subplots()\n    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n    X = np.random.randn(4, 4)\n    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n    \n    # This should not raise a ValueError\n    result = im.format_cursor_data(1.5)\n    assert isinstance(result, str)\n    assert result.startswith('[') and result.endswith(']')\n",
      "\ndef test_image_cursor_formatting():\n    fig, ax = plt.subplots()\n    # Create a dummy image to be able to call format_cursor_data\n    im = ax.imshow(np.zeros((4, 4)))\n\n    data = np.ma.masked_array([0], mask=[True])\n    assert im.format_cursor_data(data) == '[]'\n\n    data = np.ma.masked_array([0], mask=[False])\n    assert im.format_cursor_data(data) == '[0]'\n\n    data = np.nan\n    assert im.format_cursor_data(data) == '[nan]'\n\n\ndef test_format_cursor_data_with_boundary_norm():\n    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n    fig, ax = plt.subplots()\n    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n    X = np.random.randn(4, 4)\n    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n    \n    # This should not raise a ValueError\n    result = im.format_cursor_data(1.5)\n    assert isinstance(result, str)\n    assert result.startswith('[') and result.endswith(']')\n",
      "\ndef test_image_cursor_formatting():\n    fig, ax = plt.subplots()\n    # Create a dummy image to be able to call format_cursor_data\n    im = ax.imshow(np.zeros((4, 4)))\n\n    data = np.ma.masked_array([0], mask=[True])\n    assert im.format_cursor_data(data) == '[]'\n\n    data = np.ma.masked_array([0], mask=[False])\n    assert im.format_cursor_data(data) == '[0]'\n\n    data = np.nan\n    assert im.format_cursor_data(data) == '[nan]'\n\n\ndef test_format_cursor_data_with_boundary_norm():\n    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n    fig, ax = plt.subplots()\n    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n    X = np.random.randn(4, 4)\n    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n    \n    # This should not raise a ValueError\n    result = im.format_cursor_data(1.5)\n    assert isinstance(result, str)\n    assert result.startswith('[') and result.endswith(']')\n",
      "\ndef test_image_cursor_formatting():\n    fig, ax = plt.subplots()\n    # Create a dummy image to be able to call format_cursor_data\n    im = ax.imshow(np.zeros((4, 4)))\n\n    data = np.ma.masked_array([0], mask=[True])\n    assert im.format_cursor_data(data) == '[]'\n\n    data = np.ma.masked_array([0], mask=[False])\n    assert im.format_cursor_data(data) == '[0]'\n\n    data = np.nan\n    assert im.format_cursor_data(data) == '[nan]'\n\n\ndef test_format_cursor_data_with_boundary_norm():\n    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n    fig, ax = plt.subplots()\n    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n    X = np.random.randn(4, 4)\n    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n    \n    # This should not raise a ValueError\n    result = im.format_cursor_data(1.5)\n    assert isinstance(result, str)\n    assert result.startswith('[') and result.endswith(']')\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..a4abe22620 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,12 +1302,17 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n+\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+                if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                else:\n+                    # BoundaryNorm is not invertible, use default precision\n+                    g_sig_digits = 3\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..61235f3665 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1164,6 +1164,7 @@ class Colorbar:\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n+\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..ff96b8f014 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1907,7 +1907,7 @@ class BoundaryNorm(Normalize):\n         ------\n         ValueError\n             BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+\n         \"\"\"\n         raise ValueError(\"BoundaryNorm is not invertible\")\n \ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..6841a9a8b4 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1071,6 +1071,7 @@ def test_respects_bbox():\n     assert buf_before.getvalue() != buf_after.getvalue()  # Not all white.\n \n \n+\n def test_image_cursor_formatting():\n     fig, ax = plt.subplots()\n     # Create a dummy image to be able to call format_cursor_data\n@@ -1086,6 +1087,19 @@ def test_image_cursor_formatting():\n     assert im.format_cursor_data(data) == '[nan]'\n \n \n+def test_format_cursor_data_with_boundary_norm():\n+    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(4, 4)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # This should not raise a ValueError\n+    result = im.format_cursor_data(1.5)\n+    assert isinstance(result, str)\n+    assert result.startswith('[') and result.endswith(']')\n+\n+\n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n     \"\"\"Per-pixel alpha channel test.\"\"\"\n",
    "variant_0": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..67f5a8a034 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,15 +1302,19 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n-                g_sig_digits = 3  # Consistent with default below.\n-            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n         else:\n             try:\n                 data[0]\ndiff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..98c69cfe95 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1164,9 +1164,19 @@ class Colorbar:\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n-        if (not isinstance(self.norm, colors.BoundaryNorm) and\n-                (self.boundaries is None)):\n-            b = self.norm.inverse(b)\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, colors.BoundaryNorm):\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            else:\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..35c8d096df 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,13 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+    def inverse(self, value):\n+        \"\"\"\n+        Raises\n+        ------\n+        ValueError\n+            BoundaryNorm is not invertible, so calling this method will always\n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..6841a9a8b4 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1071,6 +1071,7 @@ def test_respects_bbox():\n     assert buf_before.getvalue() != buf_after.getvalue()  # Not all white.\n \n \n+\n def test_image_cursor_formatting():\n     fig, ax = plt.subplots()\n     # Create a dummy image to be able to call format_cursor_data\n@@ -1086,6 +1087,19 @@ def test_image_cursor_formatting():\n     assert im.format_cursor_data(data) == '[nan]'\n \n \n+def test_format_cursor_data_with_boundary_norm():\n+    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(4, 4)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # This should not raise a ValueError\n+    result = im.format_cursor_data(1.5)\n+    assert isinstance(result, str)\n+    assert result.startswith('[') and result.endswith(']')\n+\n+\n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n     \"\"\"Per-pixel alpha channel test.\"\"\"\n",
    "variant_1": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..f33dc6fbdc 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1292,6 +1292,17 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,10 +1315,14 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+                if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                else:\n+                    # BoundaryNorm is not invertible, use default precision\n+                    g_sig_digits = 3\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..98c69cfe95 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1164,9 +1164,19 @@ class Colorbar:\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n-        if (not isinstance(self.norm, colors.BoundaryNorm) and\n-                (self.boundaries is None)):\n-            b = self.norm.inverse(b)\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, colors.BoundaryNorm):\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            else:\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..35c8d096df 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,13 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+    def inverse(self, value):\n+        \"\"\"\n+        Raises\n+        ------\n+        ValueError\n+            BoundaryNorm is not invertible, so calling this method will always\n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..24c8a3c573 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1071,6 +1071,7 @@ def test_respects_bbox():\n     assert buf_before.getvalue() != buf_after.getvalue()  # Not all white.\n \n \n+\n def test_image_cursor_formatting():\n     fig, ax = plt.subplots()\n     # Create a dummy image to be able to call format_cursor_data\n@@ -1086,6 +1087,19 @@ def test_image_cursor_formatting():\n     assert im.format_cursor_data(data) == '[nan]'\n \n \n+def test_format_cursor_data_with_boundary_norm():\n+    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = mcolors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(4, 4)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # This should not raise a ValueError\n+    result = im.format_cursor_data(1.5)\n+    assert isinstance(result, str)\n+    assert result.startswith('[') and result.endswith(']')\n+\n+\n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n     \"\"\"Per-pixel alpha channel test.\"\"\"\n",
    "variant_2": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..67f5a8a034 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,15 +1302,19 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n-                g_sig_digits = 3  # Consistent with default below.\n-            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n         else:\n             try:\n                 data[0]\ndiff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..98c69cfe95 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1164,9 +1164,19 @@ class Colorbar:\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n-        if (not isinstance(self.norm, colors.BoundaryNorm) and\n-                (self.boundaries is None)):\n-            b = self.norm.inverse(b)\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, colors.BoundaryNorm):\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            else:\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..a74cb29d2f 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1907,12 +1907,54 @@ class BoundaryNorm(Normalize):\n         ------\n         ValueError\n             BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n \n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colormap, in which case scalar\n+        values are formatted using scalar formatters.\n \n-class NoNorm(Normalize):\n+        See Also\n+        --------\n+        ScalarMappable.format_cursor_data\n+        \"\"\"\n+        # Import here to avoid circular import.\n+        from matplotlib import colors\n+        if np.iterable(data):\n+            data_str = '[' + ', '.join(cbook._auto_format_str(v)\n+                                       for v in data.flat) + ']'\n+        else:\n+            try:\n+                cmap = self.get_cmap()\n+                norm = self.norm\n+                if cmap is not None:\n+                    normed = norm(data)\n+                    if np.isfinite(normed):\n+                        # Midpoints of neighboring color intervals.\n+                        if not isinstance(norm, colors.BoundaryNorm):\n+                            neighbors = norm.inverse(\n+                                (int(normed * cmap.N) + np.array([0, 1])) / cmap.N)\n+                            delta = abs(neighbors - data).max()\n+                            g_sig_digits = cbook._g_sig_digits(data, delta)\n+                        else:\n+                            # BoundaryNorm is not invertible, use default precision\n+                            g_sig_digits = 3\n+                    else:\n+                        g_sig_digits = 3  # Consistent with default below.\n+                    data_str = '[{:-#.{}g}]'.format(data, g_sig_digits)\n+                else:\n+                    data_str = cbook._auto_format_str(data)\n+            except (TypeError, IndexError):\n+                data_str = cbook._auto_format_str(data)\n+        return data_str\n     \"\"\"\n     Dummy replacement for `Normalize`, for the case where we want to use\n     indices directly in a `~matplotlib.cm.ScalarMappable`.\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..24c8a3c573 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1071,6 +1071,7 @@ def test_respects_bbox():\n     assert buf_before.getvalue() != buf_after.getvalue()  # Not all white.\n \n \n+\n def test_image_cursor_formatting():\n     fig, ax = plt.subplots()\n     # Create a dummy image to be able to call format_cursor_data\n@@ -1086,6 +1087,19 @@ def test_image_cursor_formatting():\n     assert im.format_cursor_data(data) == '[nan]'\n \n \n+def test_format_cursor_data_with_boundary_norm():\n+    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = mcolors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(4, 4)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # This should not raise a ValueError\n+    result = im.format_cursor_data(1.5)\n+    assert isinstance(result, str)\n+    assert result.startswith('[') and result.endswith(']')\n+\n+\n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n     \"\"\"Per-pixel alpha channel test.\"\"\"\n",
    "variant_3": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..67f5a8a034 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,15 +1302,19 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n-                g_sig_digits = 3  # Consistent with default below.\n-            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n         else:\n             try:\n                 data[0]\ndiff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..98c69cfe95 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1164,9 +1164,19 @@ class Colorbar:\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n-        if (not isinstance(self.norm, colors.BoundaryNorm) and\n-                (self.boundaries is None)):\n-            b = self.norm.inverse(b)\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, colors.BoundaryNorm):\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            else:\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..35c8d096df 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,13 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+    def inverse(self, value):\n+        \"\"\"\n+        Raises\n+        ------\n+        ValueError\n+            BoundaryNorm is not invertible, so calling this method will always\n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..6841a9a8b4 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1071,6 +1071,7 @@ def test_respects_bbox():\n     assert buf_before.getvalue() != buf_after.getvalue()  # Not all white.\n \n \n+\n def test_image_cursor_formatting():\n     fig, ax = plt.subplots()\n     # Create a dummy image to be able to call format_cursor_data\n@@ -1086,6 +1087,19 @@ def test_image_cursor_formatting():\n     assert im.format_cursor_data(data) == '[nan]'\n \n \n+def test_format_cursor_data_with_boundary_norm():\n+    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(4, 4)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # This should not raise a ValueError\n+    result = im.format_cursor_data(1.5)\n+    assert isinstance(result, str)\n+    assert result.startswith('[') and result.endswith(']')\n+\n+\n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n     \"\"\"Per-pixel alpha channel test.\"\"\"\n",
    "variant_4": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..67f5a8a034 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,15 +1302,19 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n-                g_sig_digits = 3  # Consistent with default below.\n-            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n         else:\n             try:\n                 data[0]\ndiff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..98c69cfe95 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1164,9 +1164,19 @@ class Colorbar:\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n-        if (not isinstance(self.norm, colors.BoundaryNorm) and\n-                (self.boundaries is None)):\n-            b = self.norm.inverse(b)\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, colors.BoundaryNorm):\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            else:\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..35c8d096df 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,13 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+    def inverse(self, value):\n+        \"\"\"\n+        Raises\n+        ------\n+        ValueError\n+            BoundaryNorm is not invertible, so calling this method will always\n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..24c8a3c573 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1071,6 +1071,7 @@ def test_respects_bbox():\n     assert buf_before.getvalue() != buf_after.getvalue()  # Not all white.\n \n \n+\n def test_image_cursor_formatting():\n     fig, ax = plt.subplots()\n     # Create a dummy image to be able to call format_cursor_data\n@@ -1086,6 +1087,19 @@ def test_image_cursor_formatting():\n     assert im.format_cursor_data(data) == '[nan]'\n \n \n+def test_format_cursor_data_with_boundary_norm():\n+    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = mcolors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(4, 4)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # This should not raise a ValueError\n+    result = im.format_cursor_data(1.5)\n+    assert isinstance(result, str)\n+    assert result.startswith('[') and result.endswith(']')\n+\n+\n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n     \"\"\"Per-pixel alpha channel test.\"\"\"\n",
    "variant_5": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..de651743e8 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1292,6 +1292,17 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,10 +1315,15 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+                from . import colors\n+                if not isinstance(self.norm, colors.BoundaryNorm):\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                else:\n+                    # BoundaryNorm is not invertible, use default precision\n+                    g_sig_digits = 3\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..98c69cfe95 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1164,9 +1164,19 @@ class Colorbar:\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n-        if (not isinstance(self.norm, colors.BoundaryNorm) and\n-                (self.boundaries is None)):\n-            b = self.norm.inverse(b)\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, colors.BoundaryNorm):\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            else:\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..35c8d096df 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,13 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+    def inverse(self, value):\n+        \"\"\"\n+        Raises\n+        ------\n+        ValueError\n+            BoundaryNorm is not invertible, so calling this method will always\n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..6841a9a8b4 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1071,6 +1071,7 @@ def test_respects_bbox():\n     assert buf_before.getvalue() != buf_after.getvalue()  # Not all white.\n \n \n+\n def test_image_cursor_formatting():\n     fig, ax = plt.subplots()\n     # Create a dummy image to be able to call format_cursor_data\n@@ -1086,6 +1087,19 @@ def test_image_cursor_formatting():\n     assert im.format_cursor_data(data) == '[nan]'\n \n \n+def test_format_cursor_data_with_boundary_norm():\n+    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(4, 4)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # This should not raise a ValueError\n+    result = im.format_cursor_data(1.5)\n+    assert isinstance(result, str)\n+    assert result.startswith('[') and result.endswith(']')\n+\n+\n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n     \"\"\"Per-pixel alpha channel test.\"\"\"\n",
    "variant_6": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..67f5a8a034 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,15 +1302,19 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n-                g_sig_digits = 3  # Consistent with default below.\n-            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n         else:\n             try:\n                 data[0]\ndiff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..98c69cfe95 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1164,9 +1164,19 @@ class Colorbar:\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n-        if (not isinstance(self.norm, colors.BoundaryNorm) and\n-                (self.boundaries is None)):\n-            b = self.norm.inverse(b)\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, colors.BoundaryNorm):\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            else:\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..35c8d096df 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,13 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+    def inverse(self, value):\n+        \"\"\"\n+        Raises\n+        ------\n+        ValueError\n+            BoundaryNorm is not invertible, so calling this method will always\n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..6841a9a8b4 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1071,6 +1071,7 @@ def test_respects_bbox():\n     assert buf_before.getvalue() != buf_after.getvalue()  # Not all white.\n \n \n+\n def test_image_cursor_formatting():\n     fig, ax = plt.subplots()\n     # Create a dummy image to be able to call format_cursor_data\n@@ -1086,6 +1087,19 @@ def test_image_cursor_formatting():\n     assert im.format_cursor_data(data) == '[nan]'\n \n \n+def test_format_cursor_data_with_boundary_norm():\n+    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(4, 4)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # This should not raise a ValueError\n+    result = im.format_cursor_data(1.5)\n+    assert isinstance(result, str)\n+    assert result.startswith('[') and result.endswith(']')\n+\n+\n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n     \"\"\"Per-pixel alpha channel test.\"\"\"\n",
    "variant_7": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..67f5a8a034 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,15 +1302,19 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n-                g_sig_digits = 3  # Consistent with default below.\n-            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n         else:\n             try:\n                 data[0]\ndiff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..98c69cfe95 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1164,9 +1164,19 @@ class Colorbar:\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n-        if (not isinstance(self.norm, colors.BoundaryNorm) and\n-                (self.boundaries is None)):\n-            b = self.norm.inverse(b)\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, colors.BoundaryNorm):\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            else:\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..2a2a6dfa5c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1907,9 +1907,16 @@ class BoundaryNorm(Normalize):\n         ------\n         ValueError\n             BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n-        \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+\n+def inverse(self, value):\n+    \"\"\"\n+    Raises\n+    ------\n+    ValueError\n+        BoundaryNorm is not invertible, so calling this method will always\n+        raise an error\n+    \"\"\"\n+    raise ValueError(\"BoundaryNorm is not invertible\")\n \n \n class NoNorm(Normalize):\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..6841a9a8b4 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1071,6 +1071,7 @@ def test_respects_bbox():\n     assert buf_before.getvalue() != buf_after.getvalue()  # Not all white.\n \n \n+\n def test_image_cursor_formatting():\n     fig, ax = plt.subplots()\n     # Create a dummy image to be able to call format_cursor_data\n@@ -1086,6 +1087,19 @@ def test_image_cursor_formatting():\n     assert im.format_cursor_data(data) == '[nan]'\n \n \n+def test_format_cursor_data_with_boundary_norm():\n+    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(4, 4)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # This should not raise a ValueError\n+    result = im.format_cursor_data(1.5)\n+    assert isinstance(result, str)\n+    assert result.startswith('[') and result.endswith(']')\n+\n+\n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n     \"\"\"Per-pixel alpha channel test.\"\"\"\n",
    "variant_8": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..67f5a8a034 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,15 +1302,19 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, mpl.colors.BoundaryNorm):\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n-                g_sig_digits = 3  # Consistent with default below.\n-            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n         else:\n             try:\n                 data[0]\ndiff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex c59b0ac815..98c69cfe95 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -1164,9 +1164,19 @@ class Colorbar:\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n-        if (not isinstance(self.norm, colors.BoundaryNorm) and\n-                (self.boundaries is None)):\n-            b = self.norm.inverse(b)\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            if not isinstance(self.norm, colors.BoundaryNorm):\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            else:\n+                # BoundaryNorm is not invertible, use default precision\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..35c8d096df 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,13 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+    def inverse(self, value):\n+        \"\"\"\n+        Raises\n+        ------\n+        ValueError\n+            BoundaryNorm is not invertible, so calling this method will always\n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex e8e90b7680..6841a9a8b4 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1071,6 +1071,7 @@ def test_respects_bbox():\n     assert buf_before.getvalue() != buf_after.getvalue()  # Not all white.\n \n \n+\n def test_image_cursor_formatting():\n     fig, ax = plt.subplots()\n     # Create a dummy image to be able to call format_cursor_data\n@@ -1086,6 +1087,19 @@ def test_image_cursor_formatting():\n     assert im.format_cursor_data(data) == '[nan]'\n \n \n+def test_format_cursor_data_with_boundary_norm():\n+    \"\"\"Test that format_cursor_data works with BoundaryNorm without crashing.\"\"\"\n+    fig, ax = plt.subplots()\n+    norm = mpl.colors.BoundaryNorm(np.linspace(-4, 4, 5), 256)\n+    X = np.random.randn(4, 4)\n+    im = ax.imshow(X, cmap='RdBu_r', norm=norm)\n+    \n+    # This should not raise a ValueError\n+    result = im.format_cursor_data(1.5)\n+    assert isinstance(result, str)\n+    assert result.startswith('[') and result.endswith(']')\n+\n+\n @check_figures_equal()\n def test_image_array_alpha(fig_test, fig_ref):\n     \"\"\"Per-pixel alpha channel test.\"\"\"\n"
  }
}