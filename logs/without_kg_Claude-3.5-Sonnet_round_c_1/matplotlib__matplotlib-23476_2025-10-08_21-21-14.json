{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/figure.py lines 3015-3033)": "\n    def __getstate__(self):\n        state = super().__getstate__()\n\n        # The canvas cannot currently be pickled, but this has the benefit\n        # of meaning that a figure can be detached from one canvas, and\n        # re-attached to another.\n        state.pop(\"canvas\")\n\n        # Set cached renderer to None -- it can't be pickled.\n        state[\"_cachedRenderer\"] = None\n\n        # Preserve _original_dpi if it exists to prevent DPI doubling on unpickle\n        if hasattr(self, '_original_dpi'):\n            state['_original_dpi'] = self._original_dpi\n\n        # add version information to the state\n        state['__mpl_version__'] = mpl.__version__\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n        return state\n",
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/figure.py lines 3035-3060)": "\n    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n        # Preserve _original_dpi if it exists in the state\n        original_dpi = state.pop('_original_dpi', None)\n\n        if version != mpl.__version__:\n            _api.warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"is unlikely to function correctly.\")\n\n        self.__dict__ = state\n\n        # Restore _original_dpi before canvas creation to prevent DPI doubling\n        if original_dpi is not None:\n            self._original_dpi = original_dpi\n\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n\n        self.stale = True\n",
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/backend_bases.py lines 1655-1658)": "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/backends/backend_macosx.py lines 32-39)": "\nclass FigureCanvasMac(FigureCanvasAgg, FigureCanvasBase):\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        # Ensure original DPI is preserved before any canvas initialization\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        super().__init__(figure=figure)\n",
    "Location 5 (/root/hy/projects_1/matplotlib/lib/matplotlib/backends/backend_agg.py lines 414-419)": "\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/figure.py lines 3015-3033)": [
      "\n    def __getstate__(self):\n        state = super().__getstate__()\n\n        # The canvas cannot currently be pickled, but this has the benefit\n        # of meaning that a figure can be detached from one canvas, and\n        # re-attached to another.\n        state.pop(\"canvas\")\n\n        # Set cached renderer to None -- it can't be pickled.\n        state[\"_cachedRenderer\"] = None\n\n        # Preserve the original DPI to prevent double-scaling on unpickle\n        if hasattr(self, '_original_dpi'):\n            state['_original_dpi'] = self._original_dpi\n\n        # add version information to the state\n        state['__mpl_version__'] = mpl.__version__\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n        return state\n",
      "\n    def __getstate__(self):\n        state = super().__getstate__()\n\n        # The canvas cannot currently be pickled, but this has the benefit\n        # of meaning that a figure can be detached from one canvas, and\n        # re-attached to another.\n        state.pop(\"canvas\")\n\n        # Set cached renderer to None -- it can't be pickled.\n        state[\"_cachedRenderer\"] = None\n\n        # Preserve _original_dpi if it exists to prevent DPI doubling on unpickle\n        if hasattr(self, '_original_dpi'):\n            state['_original_dpi'] = self._original_dpi\n\n        # add version information to the state\n        state['__mpl_version__'] = mpl.__version__\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n        return state\n",
      "\n    def __getstate__(self):\n        state = super().__getstate__()\n\n        # The canvas cannot currently be pickled, but this has the benefit\n        # of meaning that a figure can be detached from one canvas, and\n        # re-attached to another.\n        state.pop(\"canvas\")\n\n        # Set cached renderer to None -- it can't be pickled.\n        state[\"_cachedRenderer\"] = None\n\n        # Preserve original DPI to prevent double-scaling on unpickling\n        if hasattr(self, '_original_dpi'):\n            state['_original_dpi'] = self._original_dpi\n\n        # add version information to the state\n        state['__mpl_version__'] = mpl.__version__\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n        return state\n",
      "\n    def __getstate__(self):\n        state = super().__getstate__()\n\n        # The canvas cannot currently be pickled, but this has the benefit\n        # of meaning that a figure can be detached from one canvas, and\n        # re-attached to another.\n        state.pop(\"canvas\")\n\n        # Set cached renderer to None -- it can't be pickled.\n        state[\"_cachedRenderer\"] = None\n\n        # Preserve _original_dpi if it exists to prevent DPI doubling on unpickle\n        if hasattr(self, '_original_dpi'):\n            state['_original_dpi'] = self._original_dpi\n\n        # add version information to the state\n        state['__mpl_version__'] = mpl.__version__\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n        return state\n",
      "\n    def __getstate__(self):\n        state = super().__getstate__()\n\n        # The canvas cannot currently be pickled, but this has the benefit\n        # of meaning that a figure can be detached from one canvas, and\n        # re-attached to another.\n        state.pop(\"canvas\")\n\n        # Set cached renderer to None -- it can't be pickled.\n        state[\"_cachedRenderer\"] = None\n\n        # Preserve the original DPI to prevent double-scaling on unpickle\n        if hasattr(self, '_original_dpi'):\n            state['_original_dpi'] = self._original_dpi\n\n        # add version information to the state\n        state['__mpl_version__'] = mpl.__version__\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n        return state\n",
      "\n    def __getstate__(self):\n        state = super().__getstate__()\n\n        # The canvas cannot currently be pickled, but this has the benefit\n        # of meaning that a figure can be detached from one canvas, and\n        # re-attached to another.\n        state.pop(\"canvas\")\n\n        # Set cached renderer to None -- it can't be pickled.\n        state[\"_cachedRenderer\"] = None\n\n        # Preserve the original DPI to prevent DPI doubling on unpickling\n        if hasattr(self, '_original_dpi'):\n            state['_original_dpi'] = self._original_dpi\n\n        # add version information to the state\n        state['__mpl_version__'] = mpl.__version__\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n        return state\n",
      "\n    def __getstate__(self):\n        state = super().__getstate__()\n\n        # The canvas cannot currently be pickled, but this has the benefit\n        # of meaning that a figure can be detached from one canvas, and\n        # re-attached to another.\n        state.pop(\"canvas\")\n\n        # Set cached renderer to None -- it can't be pickled.\n        state[\"_cachedRenderer\"] = None\n\n        # Preserve the original DPI to prevent double scaling on unpickle\n        if hasattr(self, '_original_dpi'):\n            state['_original_dpi'] = self._original_dpi\n\n        # add version information to the state\n        state['__mpl_version__'] = mpl.__version__\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n        return state\n",
      "\n    def __getstate__(self):\n        state = super().__getstate__()\n\n        # The canvas cannot currently be pickled, but this has the benefit\n        # of meaning that a figure can be detached from one canvas, and\n        # re-attached to another.\n        state.pop(\"canvas\")\n\n        # Set cached renderer to None -- it can't be pickled.\n        state[\"_cachedRenderer\"] = None\n\n        # Preserve the original DPI to prevent double-scaling on unpickle\n        if hasattr(self, '_original_dpi'):\n            state['_original_dpi'] = self._original_dpi\n\n        # add version information to the state\n        state['__mpl_version__'] = mpl.__version__\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n        return state\n"
    ],
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/figure.py lines 3035-3060)": [
      "\n    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n\n        if version != mpl.__version__:\n            _api.warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"is unlikely to function correctly.\")\n\n        # Restore _original_dpi before setting state to preserve it\n        original_dpi = state.pop('_original_dpi', None)\n        \n        self.__dict__ = state\n        \n        # Set _original_dpi if it was saved in the state\n        if original_dpi is not None:\n            self._original_dpi = original_dpi\n\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n\n        self.stale = True\n",
      "\n    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n        \n        # Preserve _original_dpi if it was saved in the state\n        original_dpi = state.pop('_original_dpi', None)\n\n        if version != mpl.__version__:\n            _api.warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"is unlikely to function correctly.\")\n\n        self.__dict__ = state\n        \n        # Set _original_dpi before canvas creation if it was preserved\n        if original_dpi is not None:\n            self._original_dpi = original_dpi\n\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n\n        self.stale = True\n",
      "\n    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n        \n        # Preserve _original_dpi if it exists in the saved state\n        original_dpi = state.pop('_original_dpi', None)\n\n        if version != mpl.__version__:\n            _api.warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"is unlikely to function correctly.\")\n\n        self.__dict__ = state\n        \n        # Restore _original_dpi before canvas creation to prevent DPI doubling\n        if original_dpi is not None:\n            self._original_dpi = original_dpi\n\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n\n        self.stale = True\n",
      "\n    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n        # Preserve _original_dpi if it was saved in the pickle\n        original_dpi = state.pop('_original_dpi', None)\n\n        if version != mpl.__version__:\n            _api.warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"is unlikely to function correctly.\")\n\n        self.__dict__ = state\n\n        # Restore _original_dpi before canvas creation to prevent DPI doubling\n        if original_dpi is not None:\n            self._original_dpi = original_dpi\n\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n\n        self.stale = True\n",
      "\n    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n        # Preserve _original_dpi if it was saved in the state\n        original_dpi = state.pop('_original_dpi', None)\n\n        if version != mpl.__version__:\n            _api.warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"is unlikely to function correctly.\")\n\n        self.__dict__ = state\n        \n        # Restore _original_dpi before creating the canvas to prevent DPI doubling\n        if original_dpi is not None:\n            self._original_dpi = original_dpi\n\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n\n        self.stale = True\n",
      "\n    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n        # Extract and preserve _original_dpi if it exists in the state\n        original_dpi = state.pop('_original_dpi', None)\n\n        if version != mpl.__version__:\n            _api.warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"is unlikely to function correctly.\")\n\n        self.__dict__ = state\n\n        # Restore _original_dpi before canvas creation to prevent double-scaling\n        if original_dpi is not None:\n            self._original_dpi = original_dpi\n\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n\n        self.stale = True\n",
      "\n    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n        \n        # Preserve _original_dpi if it exists in the state\n        original_dpi = state.pop('_original_dpi', None)\n\n        if version != mpl.__version__:\n            _api.warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"is unlikely to function correctly.\")\n\n        self.__dict__ = state\n        \n        # Restore _original_dpi before canvas creation to prevent double-scaling\n        if original_dpi is not None:\n            self._original_dpi = original_dpi\n\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n\n        self.stale = True\n",
      "\ndef __setstate__(self, state):\n    version = state.pop('__mpl_version__')\n    restore_to_pylab = state.pop('_restore_to_pylab', False)\n    \n    # Preserve _original_dpi if it exists in the state\n    original_dpi = state.pop('_original_dpi', None)\n\n    if version != mpl.__version__:\n        _api.warn_external(\n            f\"This figure was saved with matplotlib version {version} and \"\n            f\"is unlikely to function correctly.\")\n\n    self.__dict__ = state\n    \n    # Restore _original_dpi before canvas creation to prevent DPI doubling\n    if original_dpi is not None:\n        self._original_dpi = original_dpi\n\n    # re-initialise some of the unstored state information\n    FigureCanvasBase(self)  # Set self.canvas.\n\n    if restore_to_pylab:\n        # lazy import to avoid circularity\n        import matplotlib.pyplot as plt\n        import matplotlib._pylab_helpers as pylab_helpers\n        allnums = plt.get_fignums()\n        num = max(allnums) + 1 if allnums else 1\n        mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n        pylab_helpers.Gcf._set_new_active_manager(mgr)\n        plt.draw_if_interactive()\n\n    self.stale = True\n"
    ],
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/backend_bases.py lines 1655-1658)": [
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n    def __init__(self, figure=None):\n        # Initialize the superclass before setting up the canvas\n        super().__init__()\n        \n        # If no figure is provided, create a new one\n        if figure is None:\n            figure = Figure()\n        \n        # Set up the figure-canvas relationship\n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        # Only set _original_dpi if it doesn't already exist (e.g., from unpickling)\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n"
    ],
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/backends/backend_macosx.py lines 32-39)": [
      "\nclass FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        # Ensure _original_dpi is preserved during unpickling to prevent DPI doubling\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        super().__init__(figure=figure)\n",
      "\nclass FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n    # docstring inherited\n\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        # Ensure we use the original DPI for macOS canvas creation to prevent\n        # double scaling on high-DPI displays\n        if hasattr(figure, '_original_dpi'):\n            original_dpi = figure.dpi\n            figure.dpi = figure._original_dpi\n            try:\n                super().__init__(figure=figure)\n            finally:\n                figure.dpi = original_dpi\n        else:\n            super().__init__(figure=figure)\n",
      "\nclass FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        # Ensure we use the original DPI for macOS canvas creation to prevent\n        # double-scaling when unpickling figures that already have scaled DPI\n        original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n        temp_dpi = figure.dpi\n        figure.dpi = original_dpi\n        try:\n            super().__init__(figure=figure)\n        finally:\n            figure.dpi = temp_dpi\n",
      "\nclass FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        # Ensure we use the original DPI for device pixel ratio calculations\n        # to prevent double-scaling on retina displays\n        if hasattr(figure, '_original_dpi'):\n            effective_dpi = figure._original_dpi\n        else:\n            effective_dpi = figure.dpi\n        \n        # Temporarily set figure DPI to original for proper C-level canvas creation\n        original_figure_dpi = figure.dpi\n        figure.dpi = effective_dpi\n        \n        try:\n            super().__init__(figure=figure)\n        finally:\n            # Restore the figure's DPI after canvas creation\n            figure.dpi = original_figure_dpi\n",
      "\nclass FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        # Ensure _original_dpi is set before parent initialization\n        # to prevent DPI doubling on MacOSX backend\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        super().__init__(figure=figure)\n",
      "\nclass FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        # Ensure we use the original DPI for MacOSX canvas creation to prevent\n        # double-scaling on high-DPI displays like M1 Macs\n        if hasattr(figure, '_original_dpi') and figure._original_dpi is not None:\n            original_dpi = figure.dpi\n            figure.dpi = figure._original_dpi\n            try:\n                super().__init__(figure=figure)\n            finally:\n                figure.dpi = original_dpi\n        else:\n            super().__init__(figure=figure)\n",
      "\nclass FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        # Ensure we use the original DPI for canvas creation to prevent\n        # double-scaling on M1 Macs during pickle/unpickle cycles\n        original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n        temp_dpi = figure.dpi\n        figure.dpi = original_dpi\n        try:\n            super().__init__(figure=figure)\n        finally:\n            figure.dpi = temp_dpi\n",
      "\nclass FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n    # docstring inherited\n\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        # Ensure original DPI is preserved before potential scaling\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        super().__init__(figure=figure)\n"
    ],
    "Location 5 (/root/hy/projects_1/matplotlib/lib/matplotlib/backends/backend_agg.py lines 414-419)": [
      "\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            # Ensure we use the correct DPI value, not a double-scaled one\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n            self.renderer = RendererAgg(w, h, dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n",
      "\n    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n",
      "\n    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        # Use _original_dpi if available to prevent DPI doubling issues\n        dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n        key = w, h, dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n",
      "\n    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n",
      "\n    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n",
      "\ndef get_renderer(self, cleared=False):\n    w, h = self.figure.bbox.size\n    key = w, h, self.figure.dpi\n    reuse_renderer = (self._lastKey == key)\n    if not reuse_renderer:\n        self.renderer = RendererAgg(w, h, self.figure.dpi)\n        self._lastKey = key\n    elif cleared:\n        self.renderer.clear()\n    return self.renderer\n",
      "\n    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n",
      "\n    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        # Use original DPI if available to prevent DPI doubling issues\n        dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n        key = w, h, dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5e499119cb 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \ndiff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 644961db11..a6a6aac9bd 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -411,6 +411,7 @@ class FigureCanvasAgg(FigureCanvasBase):\n             super().draw()\n \n     @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n+\n     def get_renderer(self, cleared=False):\n         w, h = self.figure.bbox.size\n         key = w, h, self.figure.dpi\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..eb77f4fa9d 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -29,6 +29,7 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     # the end* to have the right method resolution order.\n \n     # Events such as button presses, mouse movements, and key presses are\n+\n     # handled in C and events (MouseEvent, etc.) are triggered from there.\n \n     required_interactive_framework = \"macosx\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..6580953761 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3012,6 +3012,7 @@ class Figure(FigureBase):\n                                  \"initial draw which caches the renderer\")\n         a.draw(self._cachedRenderer)\n \n+\n     def __getstate__(self):\n         state = super().__getstate__()\n \n@@ -3026,12 +3027,17 @@ class Figure(FigureBase):\n         # add version information to the state\n         state['__mpl_version__'] = mpl.__version__\n \n+        # Preserve the original DPI to prevent DPI doubling on unpickling\n+        if hasattr(self, '_original_dpi'):\n+            state['_original_dpi'] = self._original_dpi\n+\n         # check whether the figure manager (if any) is registered with pyplot\n         from matplotlib import _pylab_helpers\n         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n             state['_restore_to_pylab'] = True\n         return state\n \n+\n     def __setstate__(self, state):\n         version = state.pop('__mpl_version__')\n         restore_to_pylab = state.pop('_restore_to_pylab', False)\n@@ -3041,8 +3047,15 @@ class Figure(FigureBase):\n                 f\"This figure was saved with matplotlib version {version} and \"\n                 f\"is unlikely to function correctly.\")\n \n+        # Restore the original DPI before restoring the rest of the state\n+        original_dpi = state.pop('_original_dpi', None)\n+\n         self.__dict__ = state\n \n+        # Set the original DPI if it was preserved in the pickled state\n+        if original_dpi is not None:\n+            self._original_dpi = original_dpi\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n@@ -3057,7 +3070,6 @@ class Figure(FigureBase):\n             plt.draw_if_interactive()\n \n         self.stale = True\n-\n     def add_axobserver(self, func):\n         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n         # Connect a wrapper lambda and not func itself, to avoid it being\n",
    "variant_0": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5e499119cb 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \ndiff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 644961db11..d54e77a3f7 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -411,6 +411,7 @@ class FigureCanvasAgg(FigureCanvasBase):\n             super().draw()\n \n     @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n+\n     def get_renderer(self, cleared=False):\n         w, h = self.figure.bbox.size\n         key = w, h, self.figure.dpi\n@@ -421,6 +422,10 @@ class FigureCanvasAgg(FigureCanvasBase):\n         elif cleared:\n             self.renderer.clear()\n         return self.renderer\n+            self._lastKey = key\n+        elif cleared:\n+            self.renderer.clear()\n+        return self.renderer\n \n     def tostring_rgb(self):\n         \"\"\"\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..018a9f4724 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -29,6 +29,17 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     # the end* to have the right method resolution order.\n \n     # Events such as button presses, mouse movements, and key presses are\n+\n+class FigureCanvasMac(FigureCanvasAgg, FigureCanvasBase):\n+    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n+    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n+    # class also inheriting from FCBase (this is the approach with other GUI\n+    # toolkits).  However, writing an extension type inheriting from a Python\n+    # base class is slightly tricky (the extension type must be a heap type),\n+    # and we can just as well lift the FCBase base up one level, keeping it *at\n+    # the end* to have the right method resolution order.\n+\n+    # Events such as button presses, mouse movements, and key presses are\n     # handled in C and events (MouseEvent, etc.) are triggered from there.\n \n     required_interactive_framework = \"macosx\"\n@@ -36,6 +47,9 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n     def __init__(self, figure):\n+        # Ensure original DPI is preserved before any canvas initialization\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..5da7041745 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3012,6 +3012,7 @@ class Figure(FigureBase):\n                                  \"initial draw which caches the renderer\")\n         a.draw(self._cachedRenderer)\n \n+\n     def __getstate__(self):\n         state = super().__getstate__()\n \n@@ -3023,6 +3024,10 @@ class Figure(FigureBase):\n         # Set cached renderer to None -- it can't be pickled.\n         state[\"_cachedRenderer\"] = None\n \n+        # Preserve _original_dpi if it exists to prevent DPI doubling on unpickle\n+        if hasattr(self, '_original_dpi'):\n+            state['_original_dpi'] = self._original_dpi\n+\n         # add version information to the state\n         state['__mpl_version__'] = mpl.__version__\n \n@@ -3032,9 +3037,12 @@ class Figure(FigureBase):\n             state['_restore_to_pylab'] = True\n         return state\n \n+\n     def __setstate__(self, state):\n         version = state.pop('__mpl_version__')\n         restore_to_pylab = state.pop('_restore_to_pylab', False)\n+        # Preserve _original_dpi if it exists in the state\n+        original_dpi = state.pop('_original_dpi', None)\n \n         if version != mpl.__version__:\n             _api.warn_external(\n@@ -3043,6 +3051,10 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # Restore _original_dpi before canvas creation to prevent DPI doubling\n+        if original_dpi is not None:\n+            self._original_dpi = original_dpi\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n@@ -3057,7 +3069,6 @@ class Figure(FigureBase):\n             plt.draw_if_interactive()\n \n         self.stale = True\n-\n     def add_axobserver(self, func):\n         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n         # Connect a wrapper lambda and not func itself, to avoid it being\n",
    "variant_1": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5e499119cb 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \ndiff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 644961db11..664efd44e9 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -411,12 +411,19 @@ class FigureCanvasAgg(FigureCanvasBase):\n             super().draw()\n \n     @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n+\n     def get_renderer(self, cleared=False):\n         w, h = self.figure.bbox.size\n         key = w, h, self.figure.dpi\n         reuse_renderer = (self._lastKey == key)\n         if not reuse_renderer:\n-            self.renderer = RendererAgg(w, h, self.figure.dpi)\n+            # Ensure we use the correct DPI value, not a double-scaled one\n+            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+            self.renderer = RendererAgg(w, h, dpi)\n+            self._lastKey = key\n+        elif cleared:\n+            self.renderer.clear()\n+        return self.renderer\n             self._lastKey = key\n         elif cleared:\n             self.renderer.clear()\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..edfe0d2a3d 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -29,6 +29,17 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     # the end* to have the right method resolution order.\n \n     # Events such as button presses, mouse movements, and key presses are\n+\n+class FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n+    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n+    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n+    # class also inheriting from FCBase (this is the approach with other GUI\n+    # toolkits).  However, writing an extension type inheriting from a Python\n+    # base class is slightly tricky (the extension type must be a heap type),\n+    # and we can just as well lift the FCBase base up one level, keeping it *at\n+    # the end* to have the right method resolution order.\n+\n+    # Events such as button presses, mouse movements, and key presses are\n     # handled in C and events (MouseEvent, etc.) are triggered from there.\n \n     required_interactive_framework = \"macosx\"\n@@ -36,6 +47,9 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n     def __init__(self, figure):\n+        # Ensure _original_dpi is preserved during unpickling to prevent DPI doubling\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..1defe23a74 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3012,6 +3012,7 @@ class Figure(FigureBase):\n                                  \"initial draw which caches the renderer\")\n         a.draw(self._cachedRenderer)\n \n+\n     def __getstate__(self):\n         state = super().__getstate__()\n \n@@ -3023,6 +3024,10 @@ class Figure(FigureBase):\n         # Set cached renderer to None -- it can't be pickled.\n         state[\"_cachedRenderer\"] = None\n \n+        # Preserve the original DPI to prevent double-scaling on unpickle\n+        if hasattr(self, '_original_dpi'):\n+            state['_original_dpi'] = self._original_dpi\n+\n         # add version information to the state\n         state['__mpl_version__'] = mpl.__version__\n \n@@ -3032,6 +3037,7 @@ class Figure(FigureBase):\n             state['_restore_to_pylab'] = True\n         return state\n \n+\n     def __setstate__(self, state):\n         version = state.pop('__mpl_version__')\n         restore_to_pylab = state.pop('_restore_to_pylab', False)\n@@ -3041,7 +3047,14 @@ class Figure(FigureBase):\n                 f\"This figure was saved with matplotlib version {version} and \"\n                 f\"is unlikely to function correctly.\")\n \n+        # Restore _original_dpi before setting state to preserve it\n+        original_dpi = state.pop('_original_dpi', None)\n+        \n         self.__dict__ = state\n+        \n+        # Set _original_dpi if it was saved in the state\n+        if original_dpi is not None:\n+            self._original_dpi = original_dpi\n \n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n@@ -3057,7 +3070,6 @@ class Figure(FigureBase):\n             plt.draw_if_interactive()\n \n         self.stale = True\n-\n     def add_axobserver(self, func):\n         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n         # Connect a wrapper lambda and not func itself, to avoid it being\n",
    "variant_2": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5e499119cb 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \ndiff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 644961db11..4b27940b03 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -410,6 +410,8 @@ class FigureCanvasAgg(FigureCanvasBase):\n             # don't forget to call the superclass.\n             super().draw()\n \n+    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n+\n     @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n     def get_renderer(self, cleared=False):\n         w, h = self.figure.bbox.size\n@@ -421,6 +423,10 @@ class FigureCanvasAgg(FigureCanvasBase):\n         elif cleared:\n             self.renderer.clear()\n         return self.renderer\n+            self._lastKey = key\n+        elif cleared:\n+            self.renderer.clear()\n+        return self.renderer\n \n     def tostring_rgb(self):\n         \"\"\"\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..a8e5da2333 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -29,6 +29,19 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     # the end* to have the right method resolution order.\n \n     # Events such as button presses, mouse movements, and key presses are\n+\n+class FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n+    # docstring inherited\n+\n+    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n+    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n+    # class also inheriting from FCBase (this is the approach with other GUI\n+    # toolkits).  However, writing an extension type inheriting from a Python\n+    # base class is slightly tricky (the extension type must be a heap type),\n+    # and we can just as well lift the FCBase base up one level, keeping it *at\n+    # the end* to have the right method resolution order.\n+\n+    # Events such as button presses, mouse movements, and key presses are\n     # handled in C and events (MouseEvent, etc.) are triggered from there.\n \n     required_interactive_framework = \"macosx\"\n@@ -36,7 +49,17 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n     def __init__(self, figure):\n-        super().__init__(figure=figure)\n+        # Ensure we use the original DPI for macOS canvas creation to prevent\n+        # double scaling on high-DPI displays\n+        if hasattr(figure, '_original_dpi'):\n+            original_dpi = figure.dpi\n+            figure.dpi = figure._original_dpi\n+            try:\n+                super().__init__(figure=figure)\n+            finally:\n+                figure.dpi = original_dpi\n+        else:\n+            super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\n \ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..695a4fc95b 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3012,6 +3012,7 @@ class Figure(FigureBase):\n                                  \"initial draw which caches the renderer\")\n         a.draw(self._cachedRenderer)\n \n+\n     def __getstate__(self):\n         state = super().__getstate__()\n \n@@ -3023,6 +3024,10 @@ class Figure(FigureBase):\n         # Set cached renderer to None -- it can't be pickled.\n         state[\"_cachedRenderer\"] = None\n \n+        # Preserve _original_dpi if it exists to prevent DPI doubling on unpickle\n+        if hasattr(self, '_original_dpi'):\n+            state['_original_dpi'] = self._original_dpi\n+\n         # add version information to the state\n         state['__mpl_version__'] = mpl.__version__\n \n@@ -3032,9 +3037,13 @@ class Figure(FigureBase):\n             state['_restore_to_pylab'] = True\n         return state\n \n+\n     def __setstate__(self, state):\n         version = state.pop('__mpl_version__')\n         restore_to_pylab = state.pop('_restore_to_pylab', False)\n+        \n+        # Preserve _original_dpi if it was saved in the state\n+        original_dpi = state.pop('_original_dpi', None)\n \n         if version != mpl.__version__:\n             _api.warn_external(\n@@ -3042,6 +3051,10 @@ class Figure(FigureBase):\n                 f\"is unlikely to function correctly.\")\n \n         self.__dict__ = state\n+        \n+        # Set _original_dpi before canvas creation if it was preserved\n+        if original_dpi is not None:\n+            self._original_dpi = original_dpi\n \n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n@@ -3057,7 +3070,6 @@ class Figure(FigureBase):\n             plt.draw_if_interactive()\n \n         self.stale = True\n-\n     def add_axobserver(self, func):\n         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n         # Connect a wrapper lambda and not func itself, to avoid it being\n",
    "variant_3": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5e499119cb 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \ndiff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 644961db11..5f8f107a38 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -410,13 +410,21 @@ class FigureCanvasAgg(FigureCanvasBase):\n             # don't forget to call the superclass.\n             super().draw()\n \n+    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n+\n     @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n     def get_renderer(self, cleared=False):\n         w, h = self.figure.bbox.size\n-        key = w, h, self.figure.dpi\n+        # Use _original_dpi if available to prevent DPI doubling issues\n+        dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+        key = w, h, dpi\n         reuse_renderer = (self._lastKey == key)\n         if not reuse_renderer:\n-            self.renderer = RendererAgg(w, h, self.figure.dpi)\n+            self.renderer = RendererAgg(w, h, dpi)\n+            self._lastKey = key\n+        elif cleared:\n+            self.renderer.clear()\n+        return self.renderer\n             self._lastKey = key\n         elif cleared:\n             self.renderer.clear()\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..a850078141 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -29,6 +29,17 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     # the end* to have the right method resolution order.\n \n     # Events such as button presses, mouse movements, and key presses are\n+\n+class FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n+    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n+    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n+    # class also inheriting from FCBase (this is the approach with other GUI\n+    # toolkits).  However, writing an extension type inheriting from a Python\n+    # base class is slightly tricky (the extension type must be a heap type),\n+    # and we can just as well lift the FCBase base up one level, keeping it *at\n+    # the end* to have the right method resolution order.\n+\n+    # Events such as button presses, mouse movements, and key presses are\n     # handled in C and events (MouseEvent, etc.) are triggered from there.\n \n     required_interactive_framework = \"macosx\"\n@@ -36,7 +47,15 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n     def __init__(self, figure):\n-        super().__init__(figure=figure)\n+        # Ensure we use the original DPI for macOS canvas creation to prevent\n+        # double-scaling when unpickling figures that already have scaled DPI\n+        original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n+        temp_dpi = figure.dpi\n+        figure.dpi = original_dpi\n+        try:\n+            super().__init__(figure=figure)\n+        finally:\n+            figure.dpi = temp_dpi\n         self._draw_pending = False\n         self._is_drawing = False\n \ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..610154981f 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3012,6 +3012,7 @@ class Figure(FigureBase):\n                                  \"initial draw which caches the renderer\")\n         a.draw(self._cachedRenderer)\n \n+\n     def __getstate__(self):\n         state = super().__getstate__()\n \n@@ -3023,6 +3024,10 @@ class Figure(FigureBase):\n         # Set cached renderer to None -- it can't be pickled.\n         state[\"_cachedRenderer\"] = None\n \n+        # Preserve original DPI to prevent double-scaling on unpickling\n+        if hasattr(self, '_original_dpi'):\n+            state['_original_dpi'] = self._original_dpi\n+\n         # add version information to the state\n         state['__mpl_version__'] = mpl.__version__\n \n@@ -3032,9 +3037,13 @@ class Figure(FigureBase):\n             state['_restore_to_pylab'] = True\n         return state\n \n+\n     def __setstate__(self, state):\n         version = state.pop('__mpl_version__')\n         restore_to_pylab = state.pop('_restore_to_pylab', False)\n+        \n+        # Preserve _original_dpi if it exists in the saved state\n+        original_dpi = state.pop('_original_dpi', None)\n \n         if version != mpl.__version__:\n             _api.warn_external(\n@@ -3042,6 +3051,10 @@ class Figure(FigureBase):\n                 f\"is unlikely to function correctly.\")\n \n         self.__dict__ = state\n+        \n+        # Restore _original_dpi before canvas creation to prevent DPI doubling\n+        if original_dpi is not None:\n+            self._original_dpi = original_dpi\n \n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n@@ -3057,7 +3070,6 @@ class Figure(FigureBase):\n             plt.draw_if_interactive()\n \n         self.stale = True\n-\n     def add_axobserver(self, func):\n         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n         # Connect a wrapper lambda and not func itself, to avoid it being\n",
    "variant_4": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..9757702b24 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,10 +1652,31 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n+    def __init__(self, figure=None):\n+        # Initialize the superclass before setting up the canvas\n+        super().__init__()\n+        \n+        # If no figure is provided, create a new one\n+        if figure is None:\n+            figure = Figure()\n+        \n+        # Set up the figure-canvas relationship\n+        figure.set_canvas(self)\n+        self.figure = figure\n+        self.manager = None\n+        self.widgetlock = widgets.LockDraw()\n+        self._button = None  # the button pressed\n+        self._key = None  # the key pressed\n+        self._lastx, self._lasty = None, None\n+        self.mouse_grabber = None  # the Axes currently grabbing mouse\n+        self.toolbar = None  # NavigationToolbar2 will set me\n+        self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        # Only set _original_dpi if it doesn't already exist (e.g., from unpickling)\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n-        super().__init__()  # Typically the GUI widget init (if any).\n \n     callbacks = property(lambda self: self.figure._canvas_callbacks)\n     button_pick_id = property(lambda self: self.figure._button_pick_id)\ndiff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 644961db11..4b27940b03 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -410,6 +410,8 @@ class FigureCanvasAgg(FigureCanvasBase):\n             # don't forget to call the superclass.\n             super().draw()\n \n+    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n+\n     @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n     def get_renderer(self, cleared=False):\n         w, h = self.figure.bbox.size\n@@ -421,6 +423,10 @@ class FigureCanvasAgg(FigureCanvasBase):\n         elif cleared:\n             self.renderer.clear()\n         return self.renderer\n+            self._lastKey = key\n+        elif cleared:\n+            self.renderer.clear()\n+        return self.renderer\n \n     def tostring_rgb(self):\n         \"\"\"\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..5c7ed3245c 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -29,6 +29,17 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     # the end* to have the right method resolution order.\n \n     # Events such as button presses, mouse movements, and key presses are\n+\n+class FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n+    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n+    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n+    # class also inheriting from FCBase (this is the approach with other GUI\n+    # toolkits).  However, writing an extension type inheriting from a Python\n+    # base class is slightly tricky (the extension type must be a heap type),\n+    # and we can just as well lift the FCBase base up one level, keeping it *at\n+    # the end* to have the right method resolution order.\n+\n+    # Events such as button presses, mouse movements, and key presses are\n     # handled in C and events (MouseEvent, etc.) are triggered from there.\n \n     required_interactive_framework = \"macosx\"\n@@ -36,7 +47,22 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n     def __init__(self, figure):\n-        super().__init__(figure=figure)\n+        # Ensure we use the original DPI for device pixel ratio calculations\n+        # to prevent double-scaling on retina displays\n+        if hasattr(figure, '_original_dpi'):\n+            effective_dpi = figure._original_dpi\n+        else:\n+            effective_dpi = figure.dpi\n+        \n+        # Temporarily set figure DPI to original for proper C-level canvas creation\n+        original_figure_dpi = figure.dpi\n+        figure.dpi = effective_dpi\n+        \n+        try:\n+            super().__init__(figure=figure)\n+        finally:\n+            # Restore the figure's DPI after canvas creation\n+            figure.dpi = original_figure_dpi\n         self._draw_pending = False\n         self._is_drawing = False\n \ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..48133012e8 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3012,6 +3012,7 @@ class Figure(FigureBase):\n                                  \"initial draw which caches the renderer\")\n         a.draw(self._cachedRenderer)\n \n+\n     def __getstate__(self):\n         state = super().__getstate__()\n \n@@ -3023,6 +3024,10 @@ class Figure(FigureBase):\n         # Set cached renderer to None -- it can't be pickled.\n         state[\"_cachedRenderer\"] = None\n \n+        # Preserve _original_dpi if it exists to prevent DPI doubling on unpickle\n+        if hasattr(self, '_original_dpi'):\n+            state['_original_dpi'] = self._original_dpi\n+\n         # add version information to the state\n         state['__mpl_version__'] = mpl.__version__\n \n@@ -3032,9 +3037,12 @@ class Figure(FigureBase):\n             state['_restore_to_pylab'] = True\n         return state\n \n+\n     def __setstate__(self, state):\n         version = state.pop('__mpl_version__')\n         restore_to_pylab = state.pop('_restore_to_pylab', False)\n+        # Preserve _original_dpi if it was saved in the pickle\n+        original_dpi = state.pop('_original_dpi', None)\n \n         if version != mpl.__version__:\n             _api.warn_external(\n@@ -3043,6 +3051,10 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # Restore _original_dpi before canvas creation to prevent DPI doubling\n+        if original_dpi is not None:\n+            self._original_dpi = original_dpi\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n@@ -3057,7 +3069,6 @@ class Figure(FigureBase):\n             plt.draw_if_interactive()\n \n         self.stale = True\n-\n     def add_axobserver(self, func):\n         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n         # Connect a wrapper lambda and not func itself, to avoid it being\n",
    "variant_5": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5e499119cb 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \ndiff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 644961db11..4b27940b03 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -410,6 +410,8 @@ class FigureCanvasAgg(FigureCanvasBase):\n             # don't forget to call the superclass.\n             super().draw()\n \n+    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n+\n     @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n     def get_renderer(self, cleared=False):\n         w, h = self.figure.bbox.size\n@@ -421,6 +423,10 @@ class FigureCanvasAgg(FigureCanvasBase):\n         elif cleared:\n             self.renderer.clear()\n         return self.renderer\n+            self._lastKey = key\n+        elif cleared:\n+            self.renderer.clear()\n+        return self.renderer\n \n     def tostring_rgb(self):\n         \"\"\"\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..913bb3bacf 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -29,6 +29,17 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     # the end* to have the right method resolution order.\n \n     # Events such as button presses, mouse movements, and key presses are\n+\n+class FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n+    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n+    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n+    # class also inheriting from FCBase (this is the approach with other GUI\n+    # toolkits).  However, writing an extension type inheriting from a Python\n+    # base class is slightly tricky (the extension type must be a heap type),\n+    # and we can just as well lift the FCBase base up one level, keeping it *at\n+    # the end* to have the right method resolution order.\n+\n+    # Events such as button presses, mouse movements, and key presses are\n     # handled in C and events (MouseEvent, etc.) are triggered from there.\n \n     required_interactive_framework = \"macosx\"\n@@ -36,6 +47,10 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n     def __init__(self, figure):\n+        # Ensure _original_dpi is set before parent initialization\n+        # to prevent DPI doubling on MacOSX backend\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..13d9f1a88b 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3012,6 +3012,7 @@ class Figure(FigureBase):\n                                  \"initial draw which caches the renderer\")\n         a.draw(self._cachedRenderer)\n \n+\n     def __getstate__(self):\n         state = super().__getstate__()\n \n@@ -3023,6 +3024,10 @@ class Figure(FigureBase):\n         # Set cached renderer to None -- it can't be pickled.\n         state[\"_cachedRenderer\"] = None\n \n+        # Preserve the original DPI to prevent double-scaling on unpickle\n+        if hasattr(self, '_original_dpi'):\n+            state['_original_dpi'] = self._original_dpi\n+\n         # add version information to the state\n         state['__mpl_version__'] = mpl.__version__\n \n@@ -3032,9 +3037,12 @@ class Figure(FigureBase):\n             state['_restore_to_pylab'] = True\n         return state\n \n+\n     def __setstate__(self, state):\n         version = state.pop('__mpl_version__')\n         restore_to_pylab = state.pop('_restore_to_pylab', False)\n+        # Preserve _original_dpi if it was saved in the state\n+        original_dpi = state.pop('_original_dpi', None)\n \n         if version != mpl.__version__:\n             _api.warn_external(\n@@ -3042,6 +3050,10 @@ class Figure(FigureBase):\n                 f\"is unlikely to function correctly.\")\n \n         self.__dict__ = state\n+        \n+        # Restore _original_dpi before creating the canvas to prevent DPI doubling\n+        if original_dpi is not None:\n+            self._original_dpi = original_dpi\n \n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n@@ -3057,7 +3069,6 @@ class Figure(FigureBase):\n             plt.draw_if_interactive()\n \n         self.stale = True\n-\n     def add_axobserver(self, func):\n         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n         # Connect a wrapper lambda and not func itself, to avoid it being\n",
    "variant_6": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5e499119cb 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \ndiff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 644961db11..e98ac4caf9 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -411,12 +411,17 @@ class FigureCanvasAgg(FigureCanvasBase):\n             super().draw()\n \n     @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n-    def get_renderer(self, cleared=False):\n-        w, h = self.figure.bbox.size\n-        key = w, h, self.figure.dpi\n-        reuse_renderer = (self._lastKey == key)\n-        if not reuse_renderer:\n-            self.renderer = RendererAgg(w, h, self.figure.dpi)\n+\n+def get_renderer(self, cleared=False):\n+    w, h = self.figure.bbox.size\n+    key = w, h, self.figure.dpi\n+    reuse_renderer = (self._lastKey == key)\n+    if not reuse_renderer:\n+        self.renderer = RendererAgg(w, h, self.figure.dpi)\n+        self._lastKey = key\n+    elif cleared:\n+        self.renderer.clear()\n+    return self.renderer\n             self._lastKey = key\n         elif cleared:\n             self.renderer.clear()\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..5f1176c072 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -29,6 +29,17 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     # the end* to have the right method resolution order.\n \n     # Events such as button presses, mouse movements, and key presses are\n+\n+class FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n+    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n+    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n+    # class also inheriting from FCBase (this is the approach with other GUI\n+    # toolkits).  However, writing an extension type inheriting from a Python\n+    # base class is slightly tricky (the extension type must be a heap type),\n+    # and we can just as well lift the FCBase base up one level, keeping it *at\n+    # the end* to have the right method resolution order.\n+\n+    # Events such as button presses, mouse movements, and key presses are\n     # handled in C and events (MouseEvent, etc.) are triggered from there.\n \n     required_interactive_framework = \"macosx\"\n@@ -36,7 +47,17 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n     def __init__(self, figure):\n-        super().__init__(figure=figure)\n+        # Ensure we use the original DPI for MacOSX canvas creation to prevent\n+        # double-scaling on high-DPI displays like M1 Macs\n+        if hasattr(figure, '_original_dpi') and figure._original_dpi is not None:\n+            original_dpi = figure.dpi\n+            figure.dpi = figure._original_dpi\n+            try:\n+                super().__init__(figure=figure)\n+            finally:\n+                figure.dpi = original_dpi\n+        else:\n+            super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\n \ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..80cef28509 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3012,6 +3012,7 @@ class Figure(FigureBase):\n                                  \"initial draw which caches the renderer\")\n         a.draw(self._cachedRenderer)\n \n+\n     def __getstate__(self):\n         state = super().__getstate__()\n \n@@ -3023,6 +3024,10 @@ class Figure(FigureBase):\n         # Set cached renderer to None -- it can't be pickled.\n         state[\"_cachedRenderer\"] = None\n \n+        # Preserve the original DPI to prevent DPI doubling on unpickling\n+        if hasattr(self, '_original_dpi'):\n+            state['_original_dpi'] = self._original_dpi\n+\n         # add version information to the state\n         state['__mpl_version__'] = mpl.__version__\n \n@@ -3032,9 +3037,12 @@ class Figure(FigureBase):\n             state['_restore_to_pylab'] = True\n         return state\n \n+\n     def __setstate__(self, state):\n         version = state.pop('__mpl_version__')\n         restore_to_pylab = state.pop('_restore_to_pylab', False)\n+        # Extract and preserve _original_dpi if it exists in the state\n+        original_dpi = state.pop('_original_dpi', None)\n \n         if version != mpl.__version__:\n             _api.warn_external(\n@@ -3043,6 +3051,10 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # Restore _original_dpi before canvas creation to prevent double-scaling\n+        if original_dpi is not None:\n+            self._original_dpi = original_dpi\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n@@ -3057,7 +3069,6 @@ class Figure(FigureBase):\n             plt.draw_if_interactive()\n \n         self.stale = True\n-\n     def add_axobserver(self, func):\n         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n         # Connect a wrapper lambda and not func itself, to avoid it being\n",
    "variant_7": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5e499119cb 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \ndiff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 644961db11..4b27940b03 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -410,6 +410,8 @@ class FigureCanvasAgg(FigureCanvasBase):\n             # don't forget to call the superclass.\n             super().draw()\n \n+    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n+\n     @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n     def get_renderer(self, cleared=False):\n         w, h = self.figure.bbox.size\n@@ -421,6 +423,10 @@ class FigureCanvasAgg(FigureCanvasBase):\n         elif cleared:\n             self.renderer.clear()\n         return self.renderer\n+            self._lastKey = key\n+        elif cleared:\n+            self.renderer.clear()\n+        return self.renderer\n \n     def tostring_rgb(self):\n         \"\"\"\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..a037a84c34 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -29,6 +29,17 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     # the end* to have the right method resolution order.\n \n     # Events such as button presses, mouse movements, and key presses are\n+\n+class FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n+    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n+    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n+    # class also inheriting from FCBase (this is the approach with other GUI\n+    # toolkits).  However, writing an extension type inheriting from a Python\n+    # base class is slightly tricky (the extension type must be a heap type),\n+    # and we can just as well lift the FCBase base up one level, keeping it *at\n+    # the end* to have the right method resolution order.\n+\n+    # Events such as button presses, mouse movements, and key presses are\n     # handled in C and events (MouseEvent, etc.) are triggered from there.\n \n     required_interactive_framework = \"macosx\"\n@@ -36,7 +47,15 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n     def __init__(self, figure):\n-        super().__init__(figure=figure)\n+        # Ensure we use the original DPI for canvas creation to prevent\n+        # double-scaling on M1 Macs during pickle/unpickle cycles\n+        original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n+        temp_dpi = figure.dpi\n+        figure.dpi = original_dpi\n+        try:\n+            super().__init__(figure=figure)\n+        finally:\n+            figure.dpi = temp_dpi\n         self._draw_pending = False\n         self._is_drawing = False\n \ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..b86cd18384 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3012,6 +3012,7 @@ class Figure(FigureBase):\n                                  \"initial draw which caches the renderer\")\n         a.draw(self._cachedRenderer)\n \n+\n     def __getstate__(self):\n         state = super().__getstate__()\n \n@@ -3023,6 +3024,10 @@ class Figure(FigureBase):\n         # Set cached renderer to None -- it can't be pickled.\n         state[\"_cachedRenderer\"] = None\n \n+        # Preserve the original DPI to prevent double scaling on unpickle\n+        if hasattr(self, '_original_dpi'):\n+            state['_original_dpi'] = self._original_dpi\n+\n         # add version information to the state\n         state['__mpl_version__'] = mpl.__version__\n \n@@ -3032,9 +3037,13 @@ class Figure(FigureBase):\n             state['_restore_to_pylab'] = True\n         return state\n \n+\n     def __setstate__(self, state):\n         version = state.pop('__mpl_version__')\n         restore_to_pylab = state.pop('_restore_to_pylab', False)\n+        \n+        # Preserve _original_dpi if it exists in the state\n+        original_dpi = state.pop('_original_dpi', None)\n \n         if version != mpl.__version__:\n             _api.warn_external(\n@@ -3042,6 +3051,10 @@ class Figure(FigureBase):\n                 f\"is unlikely to function correctly.\")\n \n         self.__dict__ = state\n+        \n+        # Restore _original_dpi before canvas creation to prevent double-scaling\n+        if original_dpi is not None:\n+            self._original_dpi = original_dpi\n \n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n@@ -3057,7 +3070,6 @@ class Figure(FigureBase):\n             plt.draw_if_interactive()\n \n         self.stale = True\n-\n     def add_axobserver(self, func):\n         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n         # Connect a wrapper lambda and not func itself, to avoid it being\n",
    "variant_8": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5e499119cb 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \ndiff --git a/lib/matplotlib/backends/backend_agg.py b/lib/matplotlib/backends/backend_agg.py\nindex 644961db11..311e855679 100644\n--- a/lib/matplotlib/backends/backend_agg.py\n+++ b/lib/matplotlib/backends/backend_agg.py\n@@ -410,13 +410,21 @@ class FigureCanvasAgg(FigureCanvasBase):\n             # don't forget to call the superclass.\n             super().draw()\n \n+    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n+\n     @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n     def get_renderer(self, cleared=False):\n         w, h = self.figure.bbox.size\n-        key = w, h, self.figure.dpi\n+        # Use original DPI if available to prevent DPI doubling issues\n+        dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+        key = w, h, dpi\n         reuse_renderer = (self._lastKey == key)\n         if not reuse_renderer:\n-            self.renderer = RendererAgg(w, h, self.figure.dpi)\n+            self.renderer = RendererAgg(w, h, dpi)\n+            self._lastKey = key\n+        elif cleared:\n+            self.renderer.clear()\n+        return self.renderer\n             self._lastKey = key\n         elif cleared:\n             self.renderer.clear()\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..55507530e2 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -29,6 +29,19 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     # the end* to have the right method resolution order.\n \n     # Events such as button presses, mouse movements, and key presses are\n+\n+class FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n+    # docstring inherited\n+\n+    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n+    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n+    # class also inheriting from FCBase (this is the approach with other GUI\n+    # toolkits).  However, writing an extension type inheriting from a Python\n+    # base class is slightly tricky (the extension type must be a heap type),\n+    # and we can just as well lift the FCBase base up one level, keeping it *at\n+    # the end* to have the right method resolution order.\n+\n+    # Events such as button presses, mouse movements, and key presses are\n     # handled in C and events (MouseEvent, etc.) are triggered from there.\n \n     required_interactive_framework = \"macosx\"\n@@ -36,6 +49,9 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n     def __init__(self, figure):\n+        # Ensure original DPI is preserved before potential scaling\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..37ddac346e 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3012,6 +3012,7 @@ class Figure(FigureBase):\n                                  \"initial draw which caches the renderer\")\n         a.draw(self._cachedRenderer)\n \n+\n     def __getstate__(self):\n         state = super().__getstate__()\n \n@@ -3023,6 +3024,10 @@ class Figure(FigureBase):\n         # Set cached renderer to None -- it can't be pickled.\n         state[\"_cachedRenderer\"] = None\n \n+        # Preserve the original DPI to prevent double-scaling on unpickle\n+        if hasattr(self, '_original_dpi'):\n+            state['_original_dpi'] = self._original_dpi\n+\n         # add version information to the state\n         state['__mpl_version__'] = mpl.__version__\n \n@@ -3032,32 +3037,39 @@ class Figure(FigureBase):\n             state['_restore_to_pylab'] = True\n         return state\n \n-    def __setstate__(self, state):\n-        version = state.pop('__mpl_version__')\n-        restore_to_pylab = state.pop('_restore_to_pylab', False)\n-\n-        if version != mpl.__version__:\n-            _api.warn_external(\n-                f\"This figure was saved with matplotlib version {version} and \"\n-                f\"is unlikely to function correctly.\")\n-\n-        self.__dict__ = state\n-\n-        # re-initialise some of the unstored state information\n-        FigureCanvasBase(self)  # Set self.canvas.\n-\n-        if restore_to_pylab:\n-            # lazy import to avoid circularity\n-            import matplotlib.pyplot as plt\n-            import matplotlib._pylab_helpers as pylab_helpers\n-            allnums = plt.get_fignums()\n-            num = max(allnums) + 1 if allnums else 1\n-            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n-            pylab_helpers.Gcf._set_new_active_manager(mgr)\n-            plt.draw_if_interactive()\n-\n-        self.stale = True\n \n+def __setstate__(self, state):\n+    version = state.pop('__mpl_version__')\n+    restore_to_pylab = state.pop('_restore_to_pylab', False)\n+    \n+    # Preserve _original_dpi if it exists in the state\n+    original_dpi = state.pop('_original_dpi', None)\n+\n+    if version != mpl.__version__:\n+        _api.warn_external(\n+            f\"This figure was saved with matplotlib version {version} and \"\n+            f\"is unlikely to function correctly.\")\n+\n+    self.__dict__ = state\n+    \n+    # Restore _original_dpi before canvas creation to prevent DPI doubling\n+    if original_dpi is not None:\n+        self._original_dpi = original_dpi\n+\n+    # re-initialise some of the unstored state information\n+    FigureCanvasBase(self)  # Set self.canvas.\n+\n+    if restore_to_pylab:\n+        # lazy import to avoid circularity\n+        import matplotlib.pyplot as plt\n+        import matplotlib._pylab_helpers as pylab_helpers\n+        allnums = plt.get_fignums()\n+        num = max(allnums) + 1 if allnums else 1\n+        mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n+        pylab_helpers.Gcf._set_new_active_manager(mgr)\n+        plt.draw_if_interactive()\n+\n+    self.stale = True\n     def add_axobserver(self, func):\n         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n         # Connect a wrapper lambda and not func itself, to avoid it being\n"
  }
}