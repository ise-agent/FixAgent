{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/offsetbox.py lines 1583-1583)": "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/offsetbox.py lines 1508-1508)": "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/offsetbox.py lines 1510-1515)": "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/offsetbox.py lines 1563-1572)": "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n",
    "Location 5 (/root/hy/projects_1/matplotlib/lib/matplotlib/offsetbox.py lines 1543-1544)": "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/offsetbox.py lines 1583-1583)": [
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\ndef __getstate__(self):\n    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n    state = self.__dict__.copy()\n    # Remove unpicklable canvas and callback references\n    state.pop('canvas', None)\n    state.pop('cids', None) \n    state.pop('_c1', None)\n    state.pop('background', None)\n    return state\n\ndef __setstate__(self, state):\n    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n    self.__dict__.update(state)\n    # Restore canvas reference\n    self.canvas = self.ref_artist.figure.canvas\n    self._use_blit = self._use_blit and self.canvas.supports_blit\n    # Reconnect event handlers\n    self.cids = [\n        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n    ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n",
      "\ndef __getstate__(self):\n    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n    state = self.__dict__.copy()\n    # Remove unpicklable canvas and callback references\n    state.pop('canvas', None)\n    state.pop('cids', None) \n    state.pop('_c1', None)\n    state.pop('background', None)\n    return state\n\ndef __setstate__(self, state):\n    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n    self.__dict__.update(state)\n    # Restore canvas reference\n    self.canvas = self.ref_artist.figure.canvas\n    self._use_blit = self._use_blit and self.canvas.supports_blit\n    # Reconnect event handlers\n    self.cids = [\n        self.canvas.mpl_connect('pick_event', self.on_pick),\n        self.canvas.mpl_connect('button_release_event', self.on_release),\n    ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n"
    ],
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/offsetbox.py lines 1508-1508)": [
      "\ndef __getstate__(self):\n    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n    state = self.__dict__.copy()\n    # Remove unpicklable canvas and callback references\n    state.pop('canvas', None)\n    state.pop('cids', None) \n    state.pop('_c1', None)\n    state.pop('background', None)\n    return state\n\ndef __setstate__(self, state):\n    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n    self.__dict__.update(state)\n    # Restore canvas reference\n    self.canvas = self.ref_artist.figure.canvas\n    self._use_blit = self._use_blit and self.canvas.supports_blit\n    # Reconnect event handlers\n    self.cids = [\n        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n    ]\n",
      "\ndef __getstate__(self):\n    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n    state = self.__dict__.copy()\n    # Remove unpicklable canvas and callback references\n    state.pop('canvas', None)\n    state.pop('cids', None) \n    state.pop('_c1', None)\n    state.pop('background', None)\n    return state\n\ndef __setstate__(self, state):\n    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n    self.__dict__.update(state)\n    # Restore canvas reference\n    self.canvas = self.ref_artist.figure.canvas\n    self._use_blit = self._use_blit and self.canvas.supports_blit\n    # Reconnect event handlers\n    self.cids = [\n        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n    ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\ndef __getstate__(self):\n    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n    state = self.__dict__.copy()\n    # Remove unpicklable canvas and callback references\n    state.pop('canvas', None)\n    state.pop('cids', None) \n    state.pop('_c1', None)\n    state.pop('background', None)\n    return state\n\ndef __setstate__(self, state):\n    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n    self.__dict__.update(state)\n    # Restore canvas reference\n    self.canvas = self.ref_artist.figure.canvas\n    self._use_blit = self._use_blit and self.canvas.supports_blit\n    # Reconnect event handlers\n    self.cids = [\n        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n    ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n"
    ],
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/offsetbox.py lines 1510-1515)": [
      "\ndef __getstate__(self):\n    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n    state = self.__dict__.copy()\n    # Remove unpicklable canvas and callback references\n    state.pop('canvas', None)\n    state.pop('cids', None) \n    state.pop('_c1', None)\n    state.pop('background', None)\n    return state\n\ndef __setstate__(self, state):\n    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n    self.__dict__.update(state)\n    # Restore canvas reference\n    self.canvas = self.ref_artist.figure.canvas\n    self._use_blit = self._use_blit and self.canvas.supports_blit\n    # Reconnect event handlers\n    self.cids = [\n        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n    ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\ndef __getstate__(self):\n    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n    state = self.__dict__.copy()\n    # Remove unpicklable canvas and callback references\n    state.pop('canvas', None)\n    state.pop('cids', None) \n    state.pop('_c1', None)\n    state.pop('background', None)\n    return state\n\ndef __setstate__(self, state):\n    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n    self.__dict__.update(state)\n    # Restore canvas reference\n    self.canvas = self.ref_artist.figure.canvas\n    self._use_blit = self._use_blit and self.canvas.supports_blit\n    # Reconnect event handlers\n    self.cids = [\n        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n    ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n"
    ],
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/offsetbox.py lines 1563-1572)": [
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.mpl_connect('pick_event', self.on_pick),\n            self.canvas.mpl_connect('button_release_event', self.on_release),\n        ]\n"
    ],
    "Location 5 (/root/hy/projects_1/matplotlib/lib/matplotlib/offsetbox.py lines 1543-1544)": [
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference from figure\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n        self.__dict__.update(state)\n        # Restore canvas reference\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = self._use_blit and self.canvas.supports_blit\n        # Reconnect event handlers\n        self.cids = [\n            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n        ]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..2e6083ded4 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,8 +1505,10 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n+\n         self.canvas = self.ref_artist.figure.canvas\n         self._use_blit = use_blit and self.canvas.supports_blit\n+\n         self.cids = [\n             self.canvas.callbacks._connect_picklable(\n                 'pick_event', self.on_pick),\n@@ -1540,6 +1542,7 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n+\n             self._c1 = self.canvas.callbacks._connect_picklable(\n                 \"motion_notify_event\", self.on_motion)\n             self.save_offset()\n@@ -1560,6 +1563,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1581,6 +1585,28 @@ class DraggableBase:\n         pass\n \n \n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n",
    "variant_0": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..4b5afbd979 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,13 +1505,50 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n         self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n         self._use_blit = use_blit and self.canvas.supports_blit\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n         self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n         ]\n \n     def on_motion(self, evt):\n@@ -1540,8 +1577,28 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1617,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1629,28 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n+\n     def save_offset(self):\n         pass\n \n@@ -1581,6 +1661,27 @@ class DraggableBase:\n         pass\n \n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n",
    "variant_1": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..8b897cfced 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,14 +1505,51 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n-        self.canvas = self.ref_artist.figure.canvas\n+\n+def __getstate__(self):\n+    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+    state = self.__dict__.copy()\n+    # Remove unpicklable canvas and callback references\n+    state.pop('canvas', None)\n+    state.pop('cids', None) \n+    state.pop('_c1', None)\n+    state.pop('background', None)\n+    return state\n+\n+def __setstate__(self, state):\n+    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+    self.__dict__.update(state)\n+    # Restore canvas reference\n+    self.canvas = self.ref_artist.figure.canvas\n+    self._use_blit = self._use_blit and self.canvas.supports_blit\n+    # Reconnect event handlers\n+    self.cids = [\n+        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+    ]\n         self._use_blit = use_blit and self.canvas.supports_blit\n-        self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n-        ]\n+\n+def __getstate__(self):\n+    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+    state = self.__dict__.copy()\n+    # Remove unpicklable canvas and callback references\n+    state.pop('canvas', None)\n+    state.pop('cids', None) \n+    state.pop('_c1', None)\n+    state.pop('background', None)\n+    return state\n+\n+def __setstate__(self, state):\n+    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+    self.__dict__.update(state)\n+    # Restore canvas reference\n+    self.canvas = self.ref_artist.figure.canvas\n+    self._use_blit = self._use_blit and self.canvas.supports_blit\n+    # Reconnect event handlers\n+    self.cids = [\n+        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+    ]\n \n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n@@ -1540,8 +1577,28 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1617,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1629,28 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n+\n     def save_offset(self):\n         pass\n \n@@ -1581,6 +1661,27 @@ class DraggableBase:\n         pass\n \n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n",
    "variant_2": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..ee947730b8 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,13 +1505,50 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n-        self.canvas = self.ref_artist.figure.canvas\n+\n+def __getstate__(self):\n+    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+    state = self.__dict__.copy()\n+    # Remove unpicklable canvas and callback references\n+    state.pop('canvas', None)\n+    state.pop('cids', None) \n+    state.pop('_c1', None)\n+    state.pop('background', None)\n+    return state\n+\n+def __setstate__(self, state):\n+    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+    self.__dict__.update(state)\n+    # Restore canvas reference\n+    self.canvas = self.ref_artist.figure.canvas\n+    self._use_blit = self._use_blit and self.canvas.supports_blit\n+    # Reconnect event handlers\n+    self.cids = [\n+        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+    ]\n         self._use_blit = use_blit and self.canvas.supports_blit\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n         self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n         ]\n \n     def on_motion(self, evt):\n@@ -1540,8 +1577,28 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1617,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1629,28 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n+\n     def save_offset(self):\n         pass\n \n@@ -1581,6 +1661,27 @@ class DraggableBase:\n         pass\n \n \n+def __getstate__(self):\n+    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+    state = self.__dict__.copy()\n+    # Remove unpicklable canvas and callback references\n+    state.pop('canvas', None)\n+    state.pop('cids', None) \n+    state.pop('_c1', None)\n+    state.pop('background', None)\n+    return state\n+\n+def __setstate__(self, state):\n+    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+    self.__dict__.update(state)\n+    # Restore canvas reference\n+    self.canvas = self.ref_artist.figure.canvas\n+    self._use_blit = self._use_blit and self.canvas.supports_blit\n+    # Reconnect event handlers\n+    self.cids = [\n+        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+    ]\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n",
    "variant_3": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..efc0a5803b 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,14 +1505,51 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n         self.canvas = self.ref_artist.figure.canvas\n-        self._use_blit = use_blit and self.canvas.supports_blit\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n         self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n         ]\n+        self._use_blit = use_blit and self.canvas.supports_blit\n+\n+def __getstate__(self):\n+    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+    state = self.__dict__.copy()\n+    # Remove unpicklable canvas and callback references\n+    state.pop('canvas', None)\n+    state.pop('cids', None) \n+    state.pop('_c1', None)\n+    state.pop('background', None)\n+    return state\n+\n+def __setstate__(self, state):\n+    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+    self.__dict__.update(state)\n+    # Restore canvas reference\n+    self.canvas = self.ref_artist.figure.canvas\n+    self._use_blit = self._use_blit and self.canvas.supports_blit\n+    # Reconnect event handlers\n+    self.cids = [\n+        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+    ]\n \n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n@@ -1540,8 +1577,28 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1617,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1629,28 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n+\n     def save_offset(self):\n         pass\n \n@@ -1581,6 +1661,27 @@ class DraggableBase:\n         pass\n \n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n",
    "variant_4": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..81cdc18fff 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,13 +1505,50 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n-        self.canvas = self.ref_artist.figure.canvas\n+\n+def __getstate__(self):\n+    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+    state = self.__dict__.copy()\n+    # Remove unpicklable canvas and callback references\n+    state.pop('canvas', None)\n+    state.pop('cids', None) \n+    state.pop('_c1', None)\n+    state.pop('background', None)\n+    return state\n+\n+def __setstate__(self, state):\n+    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+    self.__dict__.update(state)\n+    # Restore canvas reference\n+    self.canvas = self.ref_artist.figure.canvas\n+    self._use_blit = self._use_blit and self.canvas.supports_blit\n+    # Reconnect event handlers\n+    self.cids = [\n+        self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+        self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+    ]\n         self._use_blit = use_blit and self.canvas.supports_blit\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n         self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n         ]\n \n     def on_motion(self, evt):\n@@ -1540,8 +1577,28 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1617,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1629,28 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n+\n     def save_offset(self):\n         pass\n \n@@ -1581,6 +1661,27 @@ class DraggableBase:\n         pass\n \n \n+def __getstate__(self):\n+    \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+    state = self.__dict__.copy()\n+    # Remove unpicklable canvas and callback references\n+    state.pop('canvas', None)\n+    state.pop('cids', None) \n+    state.pop('_c1', None)\n+    state.pop('background', None)\n+    return state\n+\n+def __setstate__(self, state):\n+    \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+    self.__dict__.update(state)\n+    # Restore canvas reference\n+    self.canvas = self.ref_artist.figure.canvas\n+    self._use_blit = self._use_blit and self.canvas.supports_blit\n+    # Reconnect event handlers\n+    self.cids = [\n+        self.canvas.mpl_connect('pick_event', self.on_pick),\n+        self.canvas.mpl_connect('button_release_event', self.on_release),\n+    ]\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n",
    "variant_5": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..d523ab9487 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,13 +1505,50 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n         self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n         self._use_blit = use_blit and self.canvas.supports_blit\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n         self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n         ]\n \n     def on_motion(self, evt):\n@@ -1540,8 +1577,28 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference from figure\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1617,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1629,28 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n+\n     def save_offset(self):\n         pass\n \n@@ -1581,6 +1661,27 @@ class DraggableBase:\n         pass\n \n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n",
    "variant_6": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..f1766c4e97 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,13 +1505,50 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n         self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n         self._use_blit = use_blit and self.canvas.supports_blit\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n         self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n         ]\n \n     def on_motion(self, evt):\n@@ -1540,8 +1577,28 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1617,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1629,28 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n+\n     def save_offset(self):\n         pass\n \n@@ -1581,6 +1661,27 @@ class DraggableBase:\n         pass\n \n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n",
    "variant_7": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..2de586d623 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,13 +1505,50 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n         self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n         self._use_blit = use_blit and self.canvas.supports_blit\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n         self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n         ]\n \n     def on_motion(self, evt):\n@@ -1540,8 +1577,28 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,16 +1617,28 @@ class DraggableBase:\n         else:\n             return True\n \n-    def disconnect(self):\n-        \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n-        try:\n-            c1 = self._c1\n-        except AttributeError:\n-            pass\n-        else:\n-            self.canvas.mpl_disconnect(c1)\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n \n     def save_offset(self):\n         pass\n@@ -1581,6 +1650,27 @@ class DraggableBase:\n         pass\n \n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n",
    "variant_8": "diff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..f1766c4e97 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1505,13 +1505,50 @@ class DraggableBase:\n         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n         self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n         self._use_blit = use_blit and self.canvas.supports_blit\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n         self.cids = [\n-            self.canvas.callbacks._connect_picklable(\n-                'pick_event', self.on_pick),\n-            self.canvas.callbacks._connect_picklable(\n-                'button_release_event', self.on_release),\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n         ]\n \n     def on_motion(self, evt):\n@@ -1540,8 +1577,28 @@ class DraggableBase:\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable('pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable('button_release_event', self.on_release),\n+        ]\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1617,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1629,28 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n+\n     def save_offset(self):\n         pass\n \n@@ -1581,6 +1661,27 @@ class DraggableBase:\n         pass\n \n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable GUI objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling by reconnecting to canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Restore canvas reference\n+        self.canvas = self.ref_artist.figure.canvas\n+        self._use_blit = self._use_blit and self.canvas.supports_blit\n+        # Reconnect event handlers\n+        self.cids = [\n+            self.canvas.mpl_connect('pick_event', self.on_pick),\n+            self.canvas.mpl_connect('button_release_event', self.on_release),\n+        ]\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n"
  }
}