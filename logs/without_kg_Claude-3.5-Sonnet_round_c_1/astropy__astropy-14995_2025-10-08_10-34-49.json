{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/astropy/astropy/nddata/mixins/ndarithmetic.py lines 515-527)": "\n    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n        \"\"\"\n        Calculate the resulting mask.\n\n        This is implemented as the piecewise approach:\n        If only one mask is present we need not bother about any type checks\n\n        Parameters\n        ----------\n        operation : callable\n            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n            By default, the ``operation`` will be ignored.\n\n        operand : same type as self\n            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n\n        handle_mask : callable\n            see :meth:`NDArithmeticMixin.add`\n\n        kwds :\n            Additional parameters given to ``handle_mask``.\n\n        Returns\n        -------\n        result_mask : any type\n            If only one mask was present this mask is returned.\n            If neither had a mask ``None`` is returned. Otherwise\n            ``handle_mask`` must create (and copy) the returned mask.\n        \"\"\"\n        # If only one mask is present we need not bother about any type checks\n        if (\n            self.mask is None and operand is not None and operand.mask is None\n        ) or handle_mask is None:\n            return None\n        elif self.mask is None and operand is not None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(operand.mask)\n        elif operand is None:\n            return deepcopy(self.mask)\n        elif self.mask is not None and operand is not None and operand.mask is None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(self.mask)\n        else:\n            # Now lets calculate the resulting mask (operation enforces copy)\n            return handle_mask(self.mask, operand.mask, **kwds)\n",
    "Location 2 (/root/hy/projects_1/astropy/astropy/nddata/mixins/ndarithmetic.py lines 170-172)": "\n    def _arithmetic(\n        self,\n        operation,\n        operand,\n        propagate_uncertainties=True,\n        handle_mask=np.logical_or,\n        handle_meta=None,\n        uncertainty_correlation=0,\n        compare_wcs=\"first_found\",\n        operation_ignores_mask=False,\n        axis=None,\n        **kwds,\n    ):\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/astropy/astropy/nddata/mixins/ndarithmetic.py lines 515-527)": [
      "\n    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n        \"\"\"\n        Calculate the resulting mask.\n\n        This is implemented as the piecewise application of \"handle_mask\" to\n        the masks of the operands, where the operands are \"self\" and \"operand\".\n\n        Parameters\n        ----------\n        operation : callable\n            see `NDArithmeticMixin._arithmetic` parameter description.\n            By default, the ``operation`` will be ignored.\n\n        operand : same type (class) as self\n            see `NDArithmeticMixin._arithmetic` parameter description.\n\n        handle_mask : callable\n            see `NDArithmeticMixin._arithmetic` parameter description.\n\n        kwds :\n            Additional parameters given to ``handle_mask``.\n\n        Returns\n        -------\n        result_mask : any type\n            If only one mask was present this mask is returned.\n            If neither had a mask ``None`` is returned. Otherwise\n            ``handle_mask`` must create (and copy) the returned mask.\n        \"\"\"\n        # If only one mask is present we need not bother about any type checks\n        if (\n            self.mask is None and operand is not None and operand.mask is None\n        ) or handle_mask is None:\n            return None\n        elif self.mask is None and operand is not None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(operand.mask)\n        elif operand is None:\n            return deepcopy(self.mask)\n        elif self.mask is not None and operand is not None and operand.mask is None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(self.mask)\n        else:\n            # Now lets calculate the resulting mask (operation enforces copy)\n            return handle_mask(self.mask, operand.mask, **kwds)\n",
      "\n    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n        \"\"\"\n        Calculate the resulting mask.\n\n        This is implemented as the piecewise conjunction of the mask of the\n        primary operand and the mask of the other operand. If only one of the\n        operands has a mask the result will have a copy of this mask.\n\n        Parameters\n        ----------\n        operation : callable\n            see `NDArithmeticMixin._arithmetic` parameter description.\n            By \"data\" the ``.data`` attribute of the involved objects are meant.\n\n        operand : `NDData`-like instance\n            The second operand wrapped in an instance of the same class as\n            self.\n\n        handle_mask : callable\n            see `NDArithmeticMixin.add`\n\n        kwds :\n            Additional parameters given to ``handle_mask``.\n\n        Returns\n        -------\n        result_mask : any type\n            If only one mask was present this mask is returned.\n            If neither had a mask ``None`` is returned. Otherwise\n            ``handle_mask`` must create (and copy) the returned mask.\n        \"\"\"\n        # If only one mask is present we need not bother about any type checks\n        if (\n            self.mask is None and operand is not None and operand.mask is None\n        ) or handle_mask is None:\n            return None\n        elif self.mask is None and operand is not None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(operand.mask)\n        elif operand is None:\n            return deepcopy(self.mask)\n        elif self.mask is not None and operand is not None and operand.mask is None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(self.mask)\n        else:\n            # Now lets calculate the resulting mask (operation enforces copy)\n            return handle_mask(self.mask, operand.mask, **kwds)\n",
      "\n    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n        \"\"\"\n        Calculate the resulting mask.\n\n        This is implemented as the piecewise application of \"handle_mask\" to\n        the mask (if given) of \"self\" and \"operand\". If \"handle_mask\" is None\n        the result will have no mask.\n\n        Parameters\n        ----------\n        operation : callable\n            see `NDArithmeticMixin._arithmetic` parameter description.\n            By default, the operation will be ignored.\n\n        operand : `NDData`-like instance\n            The second operand wrapped in an instance of the same class as\n            self.\n\n        handle_mask : callable\n            see `NDArithmeticMixin._arithmetic` parameter description.\n\n        kwds :\n            Additional parameters given to ``handle_mask``.\n\n        Returns\n        -------\n        result_mask : any type\n            If only one mask was present this mask is returned.\n            If neither had a mask ``None`` is returned. Otherwise\n            ``handle_mask`` must create (and copy) the returned mask.\n        \"\"\"\n        # If only one mask is present we need not bother about any type checks\n        if (\n            self.mask is None and operand is not None and operand.mask is None\n        ) or handle_mask is None:\n            return None\n        elif self.mask is None and operand is not None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(operand.mask)\n        elif operand is None:\n            return deepcopy(self.mask)\n        elif self.mask is not None and operand is not None and operand.mask is None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(self.mask)\n        else:\n            # Now lets calculate the resulting mask (operation enforces copy)\n            return handle_mask(self.mask, operand.mask, **kwds)\n",
      "\n        # If only one mask is present we need not bother about any type checks\n        if (\n            self.mask is None and operand is not None and operand.mask is None\n        ) or handle_mask is None:\n            return None\n        elif self.mask is None and operand is not None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(operand.mask)\n        elif operand is None:\n            return deepcopy(self.mask)\n        elif self.mask is not None and operand is not None and operand.mask is None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(self.mask)\n        else:\n            # Now lets calculate the resulting mask (operation enforces copy)\n            return handle_mask(self.mask, operand.mask, **kwds)\n",
      "\n    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n        \"\"\"\n        Calculate the resulting mask.\n\n        This is implemented as the piecewise application of \"handle_mask\" to\n        the masks of the operands, where the operands are \"self\" and \"operand\".\n\n        Parameters\n        ----------\n        operation : callable\n            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n            By passing the operation, the mask-handling can be operation-specific.\n\n        operand : same type (class) as self\n            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n\n        handle_mask : callable\n            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n\n        kwds :\n            Additional parameters given to ``handle_mask``.\n\n        Returns\n        -------\n        result_mask : any type\n            If only one mask was present this mask is returned.\n            If neither had a mask ``None`` is returned. Otherwise\n            ``handle_mask`` must create (and copy) the returned mask.\n        \"\"\"\n        # If only one mask is present we need not bother about any type checks\n        if (\n            self.mask is None and operand is not None and operand.mask is None\n        ) or handle_mask is None:\n            return None\n        elif self.mask is None and operand is not None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(operand.mask)\n        elif operand is None:\n            return deepcopy(self.mask)\n        elif self.mask is not None and operand is not None and operand.mask is None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(self.mask)\n        else:\n            # Now lets calculate the resulting mask (operation enforces copy)\n            return handle_mask(self.mask, operand.mask, **kwds)\n",
      "\n    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n        \"\"\"\n        Calculate the resulting mask.\n\n        This is implemented as the piecewise-constant arithmetic operation on\n        masks.\n\n        Parameters\n        ----------\n        operation : callable\n            see `NDArithmeticMixin._arithmetic` parameter description.\n            By design the operation should only applicable to the\n            ``data`` attribute. The ``operation`` will be ignored in the\n            mask.\n\n        operand : same type as self or None\n            see `NDArithmeticMixin._arithmetic` parameter description\n\n        handle_mask : callable\n            see `NDArithmeticMixin._arithmetic` parameter description.\n            Should give the result's mask type.\n\n        kwds :\n            Additional parameters given to ``handle_mask``.\n\n        Returns\n        -------\n        result_mask : any type\n            If only one mask was present this mask is returned.\n            If neither had a mask ``None`` is returned. Otherwise\n            ``handle_mask`` must create (and copy) the returned mask.\n        \"\"\"\n        # If only one mask is present we need not bother about any type checks\n        if (\n            self.mask is None and operand is not None and operand.mask is None\n        ) or handle_mask is None:\n            return None\n        elif self.mask is None and operand is not None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(operand.mask)\n        elif operand is None:\n            return deepcopy(self.mask)\n        elif self.mask is not None and operand is not None and operand.mask is None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(self.mask)\n        else:\n            # Now lets calculate the resulting mask (operation enforces copy)\n            return handle_mask(self.mask, operand.mask, **kwds)\n",
      "\n        # If only one mask is present we need not bother about any type checks\n        if (\n            self.mask is None and operand is not None and operand.mask is None\n        ) or handle_mask is None:\n            return None\n        elif self.mask is None and operand is not None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(operand.mask)\n        elif operand is None:\n            return deepcopy(self.mask)\n        elif self.mask is not None and operand is not None and operand.mask is None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(self.mask)\n        else:\n            # Now lets calculate the resulting mask (operation enforces copy)\n            return handle_mask(self.mask, operand.mask, **kwds)\n",
      "\n    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n        \"\"\"\n        Calculate the resulting mask.\n\n        This is implemented as the piecewise combination of the ``mask`` of the\n        operands. If only one operand has a ``mask`` the ``handle_mask`` must\n        be ignored.\n\n        Parameters\n        ----------\n        operation : callable\n            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n            By default, the ``operation`` will be ignored.\n\n        operand : `NDData`-like instance\n            The second operand in the arithmetic operation.\n\n        handle_mask : callable\n            see :meth:`NDArithmeticMixin.add`\n\n        kwds :\n            Additional parameters given to ``handle_mask``.\n\n        Returns\n        -------\n        result_mask : any type\n            If only one mask was present this mask is returned.\n            If neither had a mask ``None`` is returned. Otherwise\n            ``handle_mask`` must create (and copy) the returned mask.\n        \"\"\"\n        # If only one mask is present we need not bother about any type checks\n        if (\n            self.mask is None and operand is not None and operand.mask is None\n        ) or handle_mask is None:\n            return None\n        elif self.mask is None and operand is not None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(operand.mask)\n        elif operand is None:\n            return deepcopy(self.mask)\n        elif self.mask is not None and operand is not None and operand.mask is None:\n            # Make a copy so there is no reference in the result.\n            return deepcopy(self.mask)\n        else:\n            # Now lets calculate the resulting mask (operation enforces copy)\n            return handle_mask(self.mask, operand.mask, **kwds)\n"
    ],
    "Location 2 (/root/hy/projects_1/astropy/astropy/nddata/mixins/ndarithmetic.py lines 170-172)": [
      "\n    def _arithmetic(\n        self,\n        operation,\n        operand,\n        propagate_uncertainties=True,\n        handle_mask=np.logical_or,\n        handle_meta=None,\n        uncertainty_correlation=0,\n        compare_wcs=\"first_found\",\n        operation_ignores_mask=False,\n        axis=None,\n        **kwds,\n    ):\n        \"\"\"\n        Base method which calculates the result of the arithmetic operation.\n\n        This method determines the result of the arithmetic operation on the\n",
      "\ndef _arithmetic(\n    self,\n    operation,\n    operand,\n    propagate_uncertainties=True,\n    handle_mask=np.logical_or,\n    handle_meta=None,\n    uncertainty_correlation=0,\n    compare_wcs=\"first_found\",\n    operation_ignores_mask=False,\n    axis=None,\n    **kwds,\n):\n    \"\"\"\n    Base method which calculates the result of the arithmetic operation.\n\n    This method determines the result of the arithmetic operation on the\n    ``data`` including their uncertainties and updates the mask and meta\n    data. This method should not be used directly but as foundation for the\n    methods like :meth:`add`.\n\n    Parameters\n    ----------\n    operation : callable\n        The operation that is performed on the `NDData`. Supported are\n        `numpy.add`, `numpy.subtract`, `numpy.multiply` and\n        `numpy.true_divide`.\n\n    operand : same type (class) as self, `numbers.Number` or `numpy.ndarray`\n        see :meth:`add`\n\n    propagate_uncertainties : `bool` or ``None``, optional\n        see :meth:`add`\n\n    handle_mask : callable, ``'first_found'`` or ``None``, optional\n        see :meth:`add`\n\n    handle_meta : callable, ``'first_found'`` or ``None``, optional\n        see :meth:`add`\n\n    uncertainty_correlation : `number` or `~numpy.ndarray`, optional\n        see :meth:`add`\n\n    compare_wcs : callable, ``'first_found'`` or ``None``, optional\n        see :meth:`add`\n\n    operation_ignores_mask : bool, optional\n        When `True`, masked values will be excluded from operations;\n        otherwise the operation will be performed on all values,\n        including masked ones. Default is `False`.\n\n        .. versionadded:: 4.2\n\n    axis : None, int, or tuple of ints, optional\n        The axis over which the operation should be performed.\n        Important for operations like sum, mean, min, max, etc.\n        Default is `None`.\n\n        .. versionadded:: 4.2\n\n    kwds :\n        Any other parameter that should be passed to the\n        different :meth:`_arithmetic_mask` (and similar) methods.\n\n    Returns\n    -------\n    result : ndarray or `~astropy.units.Quantity`\n        The resulting data as array (in case both operands were without\n        unit) or as quantity if at least one had a unit.\n\n    kwargs : `dict`\n        The kwargs should contain all the other attributes (besides data\n        and unit) needed to create a new instance for the result. Creating\n        the new instance is NOT part of this method.\n    \"\"\"\n    # Find the appropriate keywords for the result and do the arithmetic.\n    # This needs to be done first so we can determine the unit of the\n    # result.\n    kwargs = {}\n\n    if isinstance(operand, self.__class__):\n        # Check that the WCS allows the arithmetic operation\n        if compare_wcs is None:\n            kwargs[\"wcs\"] = None\n        elif compare_wcs in (\"first_found\", \"ff\"):\n            if self.wcs is None and operand.wcs is not None:\n                kwargs[\"wcs\"] = operand.wcs\n            else:\n                kwargs[\"wcs\"] = self.wcs\n        else:\n            kwargs[\"wcs\"] = compare_wcs(self.wcs, operand.wcs, operand, operation)\n\n        # Check that the units are compatible\n        if operand.unit is not None:\n            # If the operand has a unit then check that self is compatible\n            if self.unit is not None:\n                kwargs[\"unit\"] = operation(1 * self.unit, 1 * operand.unit).unit\n            else:\n                # If only the operand has a unit and the other one is\n                # dimensionless -> Just use the unit of the operand\n                kwargs[\"unit\"] = operand.unit\n        elif self.unit is not None:\n            kwargs[\"unit\"] = self.unit\n        else:\n            kwargs[\"unit\"] = None\n\n        # Using \"1 *\" to get a quantity for units because operating with\n        # unit and 1 returns a quantity while operating with\n        # dimensionless_unscaled and 1 returns a dimensionless_unscaled\n        if kwargs[\"unit\"] is None:\n            # Replace None with dimensionless_unscaled because downstream\n            # functions don't expect None\n            kwargs[\"unit\"] = dimensionless_unscaled\n\n    elif isinstance(operand, np.ndarray):\n        # Right side is ndarray. Keep the unit of self\n        kwargs[\"unit\"] = self.unit\n        # WCS is meaningless for a simple ndarray.\n        kwargs[\"wcs\"] = None\n    else:\n        # Right side is a scalar.\n        kwargs[\"unit\"] = self.unit\n        # WCS *could* be meaningful but probably is not so don't use it.\n        kwargs[\"wcs\"] = None\n\n    # Replace None with dimensionless_unscaled because downstream functions\n    # don't expect None\n    if kwargs[\"unit\"] is None:\n        kwargs[\"unit\"] = dimensionless_unscaled\n\n    # Determine the other properties\n    if isinstance(operand, self.__class__):\n        # Do the arithmetic on the data\n        # If uncertainties are not to be propagated then just use \"None\".\n        if propagate_uncertainties:\n            result, kwargs[\"uncertainty\"] = self._arithmetic_uncertainty(\n                operation, operand, result, kwargs\n            )\n        else:\n            kwargs[\"uncertainty\"] = None\n\n        # Set the mask\n        kwargs[\"mask\"] = self._arithmetic_mask(\n            operation,\n            operand,\n            handle_mask,\n            axis=axis,\n            operation_ignores_mask=operation_ignores_mask,\n            **kwds,\n        )\n\n        # Determine the meta\n        if handle_meta is None:\n            kwargs[\"meta\"] = {}\n        elif handle_meta in (\"ff\", \"first_found\"):\n            if self.meta:\n                kwargs[\"meta\"] = self.meta\n            elif operand.meta:\n                kwargs[\"meta\"] = operand.meta\n            else:\n                kwargs[\"meta\"] = {}\n        else:\n            kwargs[\"meta\"] = handle_meta(self.meta, operand.meta, **kwds)\n\n    else:\n        # Right side is not an NDData instance.\n\n        # Do the arithmetic on the data\n        if propagate_uncertainties:\n            result, kwargs[\"uncertainty\"] = self._arithmetic_uncertainty(\n                operation, operand, result, kwargs\n            )\n        else:\n            kwargs[\"uncertainty\"] = None\n\n        # Set the mask\n        kwargs[\"mask\"] = deepcopy(self.mask)\n\n        # Determine the meta\n        kwargs[\"meta\"] = deepcopy(self.meta)\n\n    return result, kwargs\n\ndef _arithmetic_mask(self, operation, operand, handle_mask, axis=None, **kwds):\n    \"\"\"\n    Calculate the resulting mask.\n\n    This is implemented as the piecewise ``or`` operation if both have a\n    mask.\n\n    Parameters\n    ----------\n    operation : callable\n        see `_arithmetic` parameter description.\n        By default, the ``operation`` will be ignored.\n\n    operand : `NDData`-like instance\n        The second operand in the arithmetic operation.\n\n    handle_mask : callable, ``'first_found'`` or ``None``\n        see :meth:`add`\n\n    kwds :\n        Additional parameters given to ``handle_mask``.\n\n    Returns\n    -------\n    result_mask : any type\n        If only one mask was present this mask is returned.\n        If neither had a mask ``None`` is returned. Otherwise\n        ``handle_mask`` is called with the masks as parameters.\n    \"\"\"\n    # If only one mask is present we need not bother about any type checks\n    if (\n        self.mask is None and operand is not None and operand.mask is None\n    ) or handle_mask is None:\n        return None\n    elif self.mask is None and operand is not None:\n        # Make a copy so there is no reference in the result.\n        return deepcopy(operand.mask)\n    elif operand is None:\n        return deepcopy(self.mask)\n    elif self.mask is not None and operand is not None and operand.mask is None:\n        # Make a copy so there is no reference in the result.\n        return deepcopy(self.mask)\n    else:\n        # Now lets calculate the resulting mask (operation enforces copy)\n        return handle_mask(self.mask, operand.mask, **kwds)\n",
      "\n    def _arithmetic(\n        self,\n        operation,\n        operand,\n        propagate_uncertainties=True,\n        handle_mask=np.logical_or,\n        handle_meta=None,\n        uncertainty_correlation=0,\n        compare_wcs=\"first_found\",\n        operation_ignores_mask=False,\n        axis=None,\n        **kwds,\n    ):\n",
      "\n    def _arithmetic(\n        self,\n        operation,\n        operand,\n        propagate_uncertainties=True,\n        handle_mask=np.logical_or,\n        handle_meta=None,\n        uncertainty_correlation=0,\n        compare_wcs=\"first_found\",\n        operation_ignores_mask=False,\n        axis=None,\n        **kwds,\n    ):\n",
      "\n    def _arithmetic(\n        self,\n        operation,\n        operand,\n        propagate_uncertainties=True,\n        handle_mask=np.logical_or,\n        handle_meta=None,\n        uncertainty_correlation=0,\n        compare_wcs=\"first_found\",\n        operation_ignores_mask=False,\n        axis=None,\n        **kwds,\n    ):\n        \"\"\"\n        Base method which calculates the result of the arithmetic operation.\n\n        This method determines the result of the arithmetic operation on the\n",
      "\n    def _arithmetic(\n        self,\n        operation,\n        operand,\n        propagate_uncertainties=True,\n        handle_mask=np.logical_or,\n        handle_meta=None,\n        uncertainty_correlation=0,\n        compare_wcs=\"first_found\",\n        operation_ignores_mask=False,\n        axis=None,\n        **kwds,\n    ):\n",
      "\n    def _arithmetic(\n        self,\n        operation,\n        operand,\n        propagate_uncertainties=True,\n        handle_mask=np.logical_or,\n        handle_meta=None,\n        uncertainty_correlation=0,\n        compare_wcs=\"first_found\",\n        operation_ignores_mask=False,\n        axis=None,\n        **kwds,\n    ):\n",
      "\n    def _arithmetic(\n        self,\n        operation,\n        operand,\n        propagate_uncertainties=True,\n        handle_mask=np.logical_or,\n        handle_meta=None,\n        uncertainty_correlation=0,\n        compare_wcs=\"first_found\",\n        operation_ignores_mask=False,\n        axis=None,\n        **kwds,\n    ):\n        \"\"\"\n        Base method which calculates the result of the arithmetic operation.\n\n        This method determines the result of the arithmetic operation on the\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..fb743fb2bf 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -167,6 +167,7 @@ class NDArithmeticMixin:\n         self,\n         operation,\n         operand,\n+\n         propagate_uncertainties=True,\n         handle_mask=np.logical_or,\n         handle_meta=None,\n@@ -512,6 +513,7 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n+\n         # If only one mask is present we need not bother about any type checks\n         if (\n             self.mask is None and operand is not None and operand.mask is None\n@@ -522,6 +524,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif self.mask is not None and operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n",
    "variant_0": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..4917957a73 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -163,6 +163,11 @@ class NDArithmeticMixin:\n \n     \"\"\"\n \n+    def _arithmetic(\n+        self,\n+        operation,\n+        operand,\n+\n     def _arithmetic(\n         self,\n         operation,\n@@ -175,6 +180,12 @@ class NDArithmeticMixin:\n         operation_ignores_mask=False,\n         axis=None,\n         **kwds,\n+    ):\n+        uncertainty_correlation=0,\n+        compare_wcs=\"first_found\",\n+        operation_ignores_mask=False,\n+        axis=None,\n+        **kwds,\n     ):\n         \"\"\"\n         Base method which calculates the result of the arithmetic operation.\n@@ -512,6 +523,36 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n+\n+    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n+        \"\"\"\n+        Calculate the resulting mask.\n+\n+        This is implemented as the piecewise approach:\n+        If only one mask is present we need not bother about any type checks\n+\n+        Parameters\n+        ----------\n+        operation : callable\n+            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n+            By default, the ``operation`` will be ignored.\n+\n+        operand : same type as self\n+            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n+\n+        handle_mask : callable\n+            see :meth:`NDArithmeticMixin.add`\n+\n+        kwds :\n+            Additional parameters given to ``handle_mask``.\n+\n+        Returns\n+        -------\n+        result_mask : any type\n+            If only one mask was present this mask is returned.\n+            If neither had a mask ``None`` is returned. Otherwise\n+            ``handle_mask`` must create (and copy) the returned mask.\n+        \"\"\"\n         # If only one mask is present we need not bother about any type checks\n         if (\n             self.mask is None and operand is not None and operand.mask is None\n@@ -522,6 +563,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif self.mask is not None and operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n",
    "variant_1": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..022968af8c 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -163,6 +163,11 @@ class NDArithmeticMixin:\n \n     \"\"\"\n \n+    def _arithmetic(\n+        self,\n+        operation,\n+        operand,\n+\n     def _arithmetic(\n         self,\n         operation,\n@@ -179,6 +184,16 @@ class NDArithmeticMixin:\n         \"\"\"\n         Base method which calculates the result of the arithmetic operation.\n \n+        This method determines the result of the arithmetic operation on the\n+        uncertainty_correlation=0,\n+        compare_wcs=\"first_found\",\n+        operation_ignores_mask=False,\n+        axis=None,\n+        **kwds,\n+    ):\n+        \"\"\"\n+        Base method which calculates the result of the arithmetic operation.\n+\n         This method determines the result of the arithmetic operation on the\n         ``data`` including their units and then forwards to other methods\n         to calculate the other properties for the result (like uncertainty).\n@@ -512,6 +527,36 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n+\n+    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n+        \"\"\"\n+        Calculate the resulting mask.\n+\n+        This is implemented as the piecewise application of \"handle_mask\" to\n+        the masks of the operands, where the operands are \"self\" and \"operand\".\n+\n+        Parameters\n+        ----------\n+        operation : callable\n+            see `NDArithmeticMixin._arithmetic` parameter description.\n+            By default, the ``operation`` will be ignored.\n+\n+        operand : same type (class) as self\n+            see `NDArithmeticMixin._arithmetic` parameter description.\n+\n+        handle_mask : callable\n+            see `NDArithmeticMixin._arithmetic` parameter description.\n+\n+        kwds :\n+            Additional parameters given to ``handle_mask``.\n+\n+        Returns\n+        -------\n+        result_mask : any type\n+            If only one mask was present this mask is returned.\n+            If neither had a mask ``None`` is returned. Otherwise\n+            ``handle_mask`` must create (and copy) the returned mask.\n+        \"\"\"\n         # If only one mask is present we need not bother about any type checks\n         if (\n             self.mask is None and operand is not None and operand.mask is None\n@@ -522,6 +567,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif self.mask is not None and operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n",
    "variant_2": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..32121e8bf4 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -167,9 +167,235 @@ class NDArithmeticMixin:\n         self,\n         operation,\n         operand,\n-        propagate_uncertainties=True,\n-        handle_mask=np.logical_or,\n-        handle_meta=None,\n+\n+def _arithmetic(\n+    self,\n+    operation,\n+    operand,\n+    propagate_uncertainties=True,\n+    handle_mask=np.logical_or,\n+    handle_meta=None,\n+    uncertainty_correlation=0,\n+    compare_wcs=\"first_found\",\n+    operation_ignores_mask=False,\n+    axis=None,\n+    **kwds,\n+):\n+    \"\"\"\n+    Base method which calculates the result of the arithmetic operation.\n+\n+    This method determines the result of the arithmetic operation on the\n+    ``data`` including their uncertainties and updates the mask and meta\n+    data. This method should not be used directly but as foundation for the\n+    methods like :meth:`add`.\n+\n+    Parameters\n+    ----------\n+    operation : callable\n+        The operation that is performed on the `NDData`. Supported are\n+        `numpy.add`, `numpy.subtract`, `numpy.multiply` and\n+        `numpy.true_divide`.\n+\n+    operand : same type (class) as self, `numbers.Number` or `numpy.ndarray`\n+        see :meth:`add`\n+\n+    propagate_uncertainties : `bool` or ``None``, optional\n+        see :meth:`add`\n+\n+    handle_mask : callable, ``'first_found'`` or ``None``, optional\n+        see :meth:`add`\n+\n+    handle_meta : callable, ``'first_found'`` or ``None``, optional\n+        see :meth:`add`\n+\n+    uncertainty_correlation : `number` or `~numpy.ndarray`, optional\n+        see :meth:`add`\n+\n+    compare_wcs : callable, ``'first_found'`` or ``None``, optional\n+        see :meth:`add`\n+\n+    operation_ignores_mask : bool, optional\n+        When `True`, masked values will be excluded from operations;\n+        otherwise the operation will be performed on all values,\n+        including masked ones. Default is `False`.\n+\n+        .. versionadded:: 4.2\n+\n+    axis : None, int, or tuple of ints, optional\n+        The axis over which the operation should be performed.\n+        Important for operations like sum, mean, min, max, etc.\n+        Default is `None`.\n+\n+        .. versionadded:: 4.2\n+\n+    kwds :\n+        Any other parameter that should be passed to the\n+        different :meth:`_arithmetic_mask` (and similar) methods.\n+\n+    Returns\n+    -------\n+    result : ndarray or `~astropy.units.Quantity`\n+        The resulting data as array (in case both operands were without\n+        unit) or as quantity if at least one had a unit.\n+\n+    kwargs : `dict`\n+        The kwargs should contain all the other attributes (besides data\n+        and unit) needed to create a new instance for the result. Creating\n+        the new instance is NOT part of this method.\n+    \"\"\"\n+    # Find the appropriate keywords for the result and do the arithmetic.\n+    # This needs to be done first so we can determine the unit of the\n+    # result.\n+    kwargs = {}\n+\n+    if isinstance(operand, self.__class__):\n+        # Check that the WCS allows the arithmetic operation\n+        if compare_wcs is None:\n+            kwargs[\"wcs\"] = None\n+        elif compare_wcs in (\"first_found\", \"ff\"):\n+            if self.wcs is None and operand.wcs is not None:\n+                kwargs[\"wcs\"] = operand.wcs\n+            else:\n+                kwargs[\"wcs\"] = self.wcs\n+        else:\n+            kwargs[\"wcs\"] = compare_wcs(self.wcs, operand.wcs, operand, operation)\n+\n+        # Check that the units are compatible\n+        if operand.unit is not None:\n+            # If the operand has a unit then check that self is compatible\n+            if self.unit is not None:\n+                kwargs[\"unit\"] = operation(1 * self.unit, 1 * operand.unit).unit\n+            else:\n+                # If only the operand has a unit and the other one is\n+                # dimensionless -> Just use the unit of the operand\n+                kwargs[\"unit\"] = operand.unit\n+        elif self.unit is not None:\n+            kwargs[\"unit\"] = self.unit\n+        else:\n+            kwargs[\"unit\"] = None\n+\n+        # Using \"1 *\" to get a quantity for units because operating with\n+        # unit and 1 returns a quantity while operating with\n+        # dimensionless_unscaled and 1 returns a dimensionless_unscaled\n+        if kwargs[\"unit\"] is None:\n+            # Replace None with dimensionless_unscaled because downstream\n+            # functions don't expect None\n+            kwargs[\"unit\"] = dimensionless_unscaled\n+\n+    elif isinstance(operand, np.ndarray):\n+        # Right side is ndarray. Keep the unit of self\n+        kwargs[\"unit\"] = self.unit\n+        # WCS is meaningless for a simple ndarray.\n+        kwargs[\"wcs\"] = None\n+    else:\n+        # Right side is a scalar.\n+        kwargs[\"unit\"] = self.unit\n+        # WCS *could* be meaningful but probably is not so don't use it.\n+        kwargs[\"wcs\"] = None\n+\n+    # Replace None with dimensionless_unscaled because downstream functions\n+    # don't expect None\n+    if kwargs[\"unit\"] is None:\n+        kwargs[\"unit\"] = dimensionless_unscaled\n+\n+    # Determine the other properties\n+    if isinstance(operand, self.__class__):\n+        # Do the arithmetic on the data\n+        # If uncertainties are not to be propagated then just use \"None\".\n+        if propagate_uncertainties:\n+            result, kwargs[\"uncertainty\"] = self._arithmetic_uncertainty(\n+                operation, operand, result, kwargs\n+            )\n+        else:\n+            kwargs[\"uncertainty\"] = None\n+\n+        # Set the mask\n+        kwargs[\"mask\"] = self._arithmetic_mask(\n+            operation,\n+            operand,\n+            handle_mask,\n+            axis=axis,\n+            operation_ignores_mask=operation_ignores_mask,\n+            **kwds,\n+        )\n+\n+        # Determine the meta\n+        if handle_meta is None:\n+            kwargs[\"meta\"] = {}\n+        elif handle_meta in (\"ff\", \"first_found\"):\n+            if self.meta:\n+                kwargs[\"meta\"] = self.meta\n+            elif operand.meta:\n+                kwargs[\"meta\"] = operand.meta\n+            else:\n+                kwargs[\"meta\"] = {}\n+        else:\n+            kwargs[\"meta\"] = handle_meta(self.meta, operand.meta, **kwds)\n+\n+    else:\n+        # Right side is not an NDData instance.\n+\n+        # Do the arithmetic on the data\n+        if propagate_uncertainties:\n+            result, kwargs[\"uncertainty\"] = self._arithmetic_uncertainty(\n+                operation, operand, result, kwargs\n+            )\n+        else:\n+            kwargs[\"uncertainty\"] = None\n+\n+        # Set the mask\n+        kwargs[\"mask\"] = deepcopy(self.mask)\n+\n+        # Determine the meta\n+        kwargs[\"meta\"] = deepcopy(self.meta)\n+\n+    return result, kwargs\n+\n+def _arithmetic_mask(self, operation, operand, handle_mask, axis=None, **kwds):\n+    \"\"\"\n+    Calculate the resulting mask.\n+\n+    This is implemented as the piecewise ``or`` operation if both have a\n+    mask.\n+\n+    Parameters\n+    ----------\n+    operation : callable\n+        see `_arithmetic` parameter description.\n+        By default, the ``operation`` will be ignored.\n+\n+    operand : `NDData`-like instance\n+        The second operand in the arithmetic operation.\n+\n+    handle_mask : callable, ``'first_found'`` or ``None``\n+        see :meth:`add`\n+\n+    kwds :\n+        Additional parameters given to ``handle_mask``.\n+\n+    Returns\n+    -------\n+    result_mask : any type\n+        If only one mask was present this mask is returned.\n+        If neither had a mask ``None`` is returned. Otherwise\n+        ``handle_mask`` is called with the masks as parameters.\n+    \"\"\"\n+    # If only one mask is present we need not bother about any type checks\n+    if (\n+        self.mask is None and operand is not None and operand.mask is None\n+    ) or handle_mask is None:\n+        return None\n+    elif self.mask is None and operand is not None:\n+        # Make a copy so there is no reference in the result.\n+        return deepcopy(operand.mask)\n+    elif operand is None:\n+        return deepcopy(self.mask)\n+    elif self.mask is not None and operand is not None and operand.mask is None:\n+        # Make a copy so there is no reference in the result.\n+        return deepcopy(self.mask)\n+    else:\n+        # Now lets calculate the resulting mask (operation enforces copy)\n+        return handle_mask(self.mask, operand.mask, **kwds)\n         uncertainty_correlation=0,\n         compare_wcs=\"first_found\",\n         operation_ignores_mask=False,\n@@ -512,6 +738,38 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n+\n+    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n+        \"\"\"\n+        Calculate the resulting mask.\n+\n+        This is implemented as the piecewise conjunction of the mask of the\n+        primary operand and the mask of the other operand. If only one of the\n+        operands has a mask the result will have a copy of this mask.\n+\n+        Parameters\n+        ----------\n+        operation : callable\n+            see `NDArithmeticMixin._arithmetic` parameter description.\n+            By \"data\" the ``.data`` attribute of the involved objects are meant.\n+\n+        operand : `NDData`-like instance\n+            The second operand wrapped in an instance of the same class as\n+            self.\n+\n+        handle_mask : callable\n+            see `NDArithmeticMixin.add`\n+\n+        kwds :\n+            Additional parameters given to ``handle_mask``.\n+\n+        Returns\n+        -------\n+        result_mask : any type\n+            If only one mask was present this mask is returned.\n+            If neither had a mask ``None`` is returned. Otherwise\n+            ``handle_mask`` must create (and copy) the returned mask.\n+        \"\"\"\n         # If only one mask is present we need not bother about any type checks\n         if (\n             self.mask is None and operand is not None and operand.mask is None\n@@ -522,6 +780,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif self.mask is not None and operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n",
    "variant_3": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..740ff73774 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -163,6 +163,11 @@ class NDArithmeticMixin:\n \n     \"\"\"\n \n+    def _arithmetic(\n+        self,\n+        operation,\n+        operand,\n+\n     def _arithmetic(\n         self,\n         operation,\n@@ -175,6 +180,12 @@ class NDArithmeticMixin:\n         operation_ignores_mask=False,\n         axis=None,\n         **kwds,\n+    ):\n+        uncertainty_correlation=0,\n+        compare_wcs=\"first_found\",\n+        operation_ignores_mask=False,\n+        axis=None,\n+        **kwds,\n     ):\n         \"\"\"\n         Base method which calculates the result of the arithmetic operation.\n@@ -512,6 +523,38 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n+\n+    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n+        \"\"\"\n+        Calculate the resulting mask.\n+\n+        This is implemented as the piecewise application of \"handle_mask\" to\n+        the mask (if given) of \"self\" and \"operand\". If \"handle_mask\" is None\n+        the result will have no mask.\n+\n+        Parameters\n+        ----------\n+        operation : callable\n+            see `NDArithmeticMixin._arithmetic` parameter description.\n+            By default, the operation will be ignored.\n+\n+        operand : `NDData`-like instance\n+            The second operand wrapped in an instance of the same class as\n+            self.\n+\n+        handle_mask : callable\n+            see `NDArithmeticMixin._arithmetic` parameter description.\n+\n+        kwds :\n+            Additional parameters given to ``handle_mask``.\n+\n+        Returns\n+        -------\n+        result_mask : any type\n+            If only one mask was present this mask is returned.\n+            If neither had a mask ``None`` is returned. Otherwise\n+            ``handle_mask`` must create (and copy) the returned mask.\n+        \"\"\"\n         # If only one mask is present we need not bother about any type checks\n         if (\n             self.mask is None and operand is not None and operand.mask is None\n@@ -522,6 +565,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif self.mask is not None and operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n",
    "variant_4": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..9490fc234e 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -163,6 +163,11 @@ class NDArithmeticMixin:\n \n     \"\"\"\n \n+    def _arithmetic(\n+        self,\n+        operation,\n+        operand,\n+\n     def _arithmetic(\n         self,\n         operation,\n@@ -175,6 +180,12 @@ class NDArithmeticMixin:\n         operation_ignores_mask=False,\n         axis=None,\n         **kwds,\n+    ):\n+        uncertainty_correlation=0,\n+        compare_wcs=\"first_found\",\n+        operation_ignores_mask=False,\n+        axis=None,\n+        **kwds,\n     ):\n         \"\"\"\n         Base method which calculates the result of the arithmetic operation.\n@@ -512,6 +523,7 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n+\n         # If only one mask is present we need not bother about any type checks\n         if (\n             self.mask is None and operand is not None and operand.mask is None\n@@ -522,6 +534,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif self.mask is not None and operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n",
    "variant_5": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..5fc572689e 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -163,6 +163,11 @@ class NDArithmeticMixin:\n \n     \"\"\"\n \n+    def _arithmetic(\n+        self,\n+        operation,\n+        operand,\n+\n     def _arithmetic(\n         self,\n         operation,\n@@ -179,6 +184,16 @@ class NDArithmeticMixin:\n         \"\"\"\n         Base method which calculates the result of the arithmetic operation.\n \n+        This method determines the result of the arithmetic operation on the\n+        uncertainty_correlation=0,\n+        compare_wcs=\"first_found\",\n+        operation_ignores_mask=False,\n+        axis=None,\n+        **kwds,\n+    ):\n+        \"\"\"\n+        Base method which calculates the result of the arithmetic operation.\n+\n         This method determines the result of the arithmetic operation on the\n         ``data`` including their units and then forwards to other methods\n         to calculate the other properties for the result (like uncertainty).\n@@ -512,6 +527,36 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n+\n+    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n+        \"\"\"\n+        Calculate the resulting mask.\n+\n+        This is implemented as the piecewise application of \"handle_mask\" to\n+        the masks of the operands, where the operands are \"self\" and \"operand\".\n+\n+        Parameters\n+        ----------\n+        operation : callable\n+            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n+            By passing the operation, the mask-handling can be operation-specific.\n+\n+        operand : same type (class) as self\n+            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n+\n+        handle_mask : callable\n+            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n+\n+        kwds :\n+            Additional parameters given to ``handle_mask``.\n+\n+        Returns\n+        -------\n+        result_mask : any type\n+            If only one mask was present this mask is returned.\n+            If neither had a mask ``None`` is returned. Otherwise\n+            ``handle_mask`` must create (and copy) the returned mask.\n+        \"\"\"\n         # If only one mask is present we need not bother about any type checks\n         if (\n             self.mask is None and operand is not None and operand.mask is None\n@@ -522,6 +567,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif self.mask is not None and operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n",
    "variant_6": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..02ab3c2685 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -163,6 +163,11 @@ class NDArithmeticMixin:\n \n     \"\"\"\n \n+    def _arithmetic(\n+        self,\n+        operation,\n+        operand,\n+\n     def _arithmetic(\n         self,\n         operation,\n@@ -175,6 +180,12 @@ class NDArithmeticMixin:\n         operation_ignores_mask=False,\n         axis=None,\n         **kwds,\n+    ):\n+        uncertainty_correlation=0,\n+        compare_wcs=\"first_found\",\n+        operation_ignores_mask=False,\n+        axis=None,\n+        **kwds,\n     ):\n         \"\"\"\n         Base method which calculates the result of the arithmetic operation.\n@@ -512,6 +523,39 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n+\n+    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n+        \"\"\"\n+        Calculate the resulting mask.\n+\n+        This is implemented as the piecewise-constant arithmetic operation on\n+        masks.\n+\n+        Parameters\n+        ----------\n+        operation : callable\n+            see `NDArithmeticMixin._arithmetic` parameter description.\n+            By design the operation should only applicable to the\n+            ``data`` attribute. The ``operation`` will be ignored in the\n+            mask.\n+\n+        operand : same type as self or None\n+            see `NDArithmeticMixin._arithmetic` parameter description\n+\n+        handle_mask : callable\n+            see `NDArithmeticMixin._arithmetic` parameter description.\n+            Should give the result's mask type.\n+\n+        kwds :\n+            Additional parameters given to ``handle_mask``.\n+\n+        Returns\n+        -------\n+        result_mask : any type\n+            If only one mask was present this mask is returned.\n+            If neither had a mask ``None`` is returned. Otherwise\n+            ``handle_mask`` must create (and copy) the returned mask.\n+        \"\"\"\n         # If only one mask is present we need not bother about any type checks\n         if (\n             self.mask is None and operand is not None and operand.mask is None\n@@ -522,6 +566,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif self.mask is not None and operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n",
    "variant_7": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..9490fc234e 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -163,6 +163,11 @@ class NDArithmeticMixin:\n \n     \"\"\"\n \n+    def _arithmetic(\n+        self,\n+        operation,\n+        operand,\n+\n     def _arithmetic(\n         self,\n         operation,\n@@ -175,6 +180,12 @@ class NDArithmeticMixin:\n         operation_ignores_mask=False,\n         axis=None,\n         **kwds,\n+    ):\n+        uncertainty_correlation=0,\n+        compare_wcs=\"first_found\",\n+        operation_ignores_mask=False,\n+        axis=None,\n+        **kwds,\n     ):\n         \"\"\"\n         Base method which calculates the result of the arithmetic operation.\n@@ -512,6 +523,7 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n+\n         # If only one mask is present we need not bother about any type checks\n         if (\n             self.mask is None and operand is not None and operand.mask is None\n@@ -522,6 +534,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif self.mask is not None and operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n",
    "variant_8": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..58d7b541d0 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -163,6 +163,11 @@ class NDArithmeticMixin:\n \n     \"\"\"\n \n+    def _arithmetic(\n+        self,\n+        operation,\n+        operand,\n+\n     def _arithmetic(\n         self,\n         operation,\n@@ -179,6 +184,16 @@ class NDArithmeticMixin:\n         \"\"\"\n         Base method which calculates the result of the arithmetic operation.\n \n+        This method determines the result of the arithmetic operation on the\n+        uncertainty_correlation=0,\n+        compare_wcs=\"first_found\",\n+        operation_ignores_mask=False,\n+        axis=None,\n+        **kwds,\n+    ):\n+        \"\"\"\n+        Base method which calculates the result of the arithmetic operation.\n+\n         This method determines the result of the arithmetic operation on the\n         ``data`` including their units and then forwards to other methods\n         to calculate the other properties for the result (like uncertainty).\n@@ -512,6 +527,37 @@ class NDArithmeticMixin:\n             If neither had a mask ``None`` is returned. Otherwise\n             ``handle_mask`` must create (and copy) the returned mask.\n         \"\"\"\n+\n+    def _arithmetic_mask(self, operation, operand, handle_mask, **kwds):\n+        \"\"\"\n+        Calculate the resulting mask.\n+\n+        This is implemented as the piecewise combination of the ``mask`` of the\n+        operands. If only one operand has a ``mask`` the ``handle_mask`` must\n+        be ignored.\n+\n+        Parameters\n+        ----------\n+        operation : callable\n+            see :meth:`NDArithmeticMixin._arithmetic` parameter description.\n+            By default, the ``operation`` will be ignored.\n+\n+        operand : `NDData`-like instance\n+            The second operand in the arithmetic operation.\n+\n+        handle_mask : callable\n+            see :meth:`NDArithmeticMixin.add`\n+\n+        kwds :\n+            Additional parameters given to ``handle_mask``.\n+\n+        Returns\n+        -------\n+        result_mask : any type\n+            If only one mask was present this mask is returned.\n+            If neither had a mask ``None`` is returned. Otherwise\n+            ``handle_mask`` must create (and copy) the returned mask.\n+        \"\"\"\n         # If only one mask is present we need not bother about any type checks\n         if (\n             self.mask is None and operand is not None and operand.mask is None\n@@ -522,6 +568,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif self.mask is not None and operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n"
  }
}