{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/query_utils.py lines 114-151)": "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum objects to their underlying primitive types.\n        This ensures consistency between direct assignment and database retrieval.\n        \"\"\"\n        # Convert the value using the field's to_python method\n        converted_value = self.field.to_python(value)\n        instance.__dict__[self.field.attname] = converted_value\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 1010-1013)": "\n    def to_python(self, value):\n        # Handle enum objects by converting to their underlying value\n        if hasattr(value, 'value'):\n            value = value.value\n        if isinstance(value, str) or value is None:\n            return value\n        return str(value)\n",
    "Location 3 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 119-125)": "\n    # Field flags\n    hidden = False\n\n    many_to_many = None\n    many_to_one = None\n    one_to_many = None\n    one_to_one = None\n    related_model = None\n\n    descriptor_class = DeferredAttribute\n\n    # Generic field type description, usually overridden by subclasses\n    def _description(self):\n",
    "Location 4 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 761-767)": "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            setattr(cls, 'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self))\n",
    "Location 5 (/root/hy/projects_1/django/django/db/models/enums.py lines 66-71)": "\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n    \n    def __new__(cls, value):\n        obj = int.__new__(cls, value)\n        obj._value_ = value\n        return obj\n\n\nclass TextChoices(str, Choices):\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/query_utils.py lines 114-151)": [
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum objects to their underlying primitive types.\n        This ensures consistency between direct assignment and database retrieval.\n        \"\"\"\n        # Convert the value using the field's to_python method\n        converted_value = self.field.to_python(value)\n        instance.__dict__[self.field.attname] = converted_value\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum objects to their underlying primitive types.\n        This ensures consistency between direct assignment and database retrieval.\n        \"\"\"\n        # Convert the value using the field's to_python method\n        converted_value = self.field.to_python(value)\n        instance.__dict__[self.field.attname] = converted_value\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum objects to their underlying primitive types.\n        This ensures consistency between direct assignment and database retrieval.\n        \"\"\"\n        # Convert the value using the field's to_python method\n        converted_value = self.field.to_python(value)\n        instance.__dict__[self.field.attname] = converted_value\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum objects to their underlying primitive types.\n        This ensures consistency between direct assignment and database retrieval.\n        \"\"\"\n        # Convert the value using the field's to_python method\n        converted_value = self.field.to_python(value)\n        instance.__dict__[self.field.attname] = converted_value\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum objects to their underlying primitive types.\n        This ensures consistency between direct assignment and database retrieval.\n        \"\"\"\n        # Convert the value using the field's to_python method\n        converted_value = self.field.to_python(value)\n        instance.__dict__[self.field.attname] = converted_value\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum objects to their underlying primitive types.\n        This ensures consistency between direct assignment and database retrieval.\n        \"\"\"\n        # Convert the value using the field's to_python method\n        converted_value = self.field.to_python(value)\n        instance.__dict__[self.field.attname] = converted_value\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum objects to their underlying primitive types.\n        This ensures consistency between direct assignment and database retrieval.\n        \"\"\"\n        # Convert the value using the field's to_python method\n        converted_value = self.field.to_python(value)\n        instance.__dict__[self.field.attname] = converted_value\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum objects to their underlying primitive types.\n        This ensures consistency between direct assignment and database retrieval.\n        \"\"\"\n        # Convert the value using the field's to_python method\n        converted_value = self.field.to_python(value)\n        instance.__dict__[self.field.attname] = converted_value\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 1010-1013)": [
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        # Convert enum objects to their string representation\n        if hasattr(value, 'value'):\n            return str(value.value)\n        return str(value)\n",
      "\ndef to_python(self, value):\n    if isinstance(value, str) or value is None:\n        return value\n    # Handle enum objects by converting them to their underlying value\n    if hasattr(value, 'value'):\n        return str(value.value)\n    return str(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        return str(value)\n",
      "\ndef to_python(self, value):\n    if isinstance(value, str) or value is None:\n        return value\n    # Convert enum objects to their string representation\n    if hasattr(value, 'value'):\n        return str(value.value)\n    return str(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        return str(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        return str(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        return str(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        return str(value)\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 119-125)": [
      "\n    # Field flags\n    hidden = False\n\n    many_to_many = None\n    many_to_one = None\n    one_to_many = None\n    one_to_one = None\n    related_model = None\n\n    descriptor_class = DeferredAttribute\n\n    # Generic field type description, usually overridden by subclasses\n    def _description(self):\n",
      "\n    }\n    system_check_deprecated_details = None\n    system_check_removed_details = None\n\n    # Field flags\n    hidden = False\n\n    many_to_many = None\n    many_to_one = None\n    one_to_many = None\n    one_to_one = None\n    related_model = None\n\n    descriptor_class = DeferredAttribute\n\n    # Generic field type description, usually overridden by subclasses\n    def _description(self):\n",
      "\n    # Field flags\n    hidden = False\n\n    many_to_many = None\n    many_to_one = None\n    one_to_many = None\n    one_to_one = None\n    related_model = None\n\n    descriptor_class = DeferredAttribute\n\n    # Generic field type description, usually overridden by subclasses\n    def _description(self):\n",
      "\n    }\n    system_check_deprecated_details = None\n    system_check_removed_details = None\n\n    # Field flags\n    hidden = False\n\n    many_to_many = None\n    many_to_one = None\n    one_to_many = None\n    one_to_one = None\n    related_model = None\n\n    descriptor_class = DeferredAttribute\n\n    # Generic field type description, usually overridden by subclasses\n    def _description(self):\n",
      "\n    # Field flags\n    hidden = False\n\n    many_to_many = None\n    many_to_one = None\n    one_to_many = None\n    one_to_one = None\n    related_model = None\n\n    descriptor_class = DeferredAttribute\n\n    # Generic field type description, usually overridden by subclasses\n    def _description(self):\n",
      "\n    # Field flags\n    hidden = False\n\n    many_to_many = None\n    many_to_one = None\n    one_to_many = None\n    one_to_one = None\n    related_model = None\n\n    descriptor_class = DeferredAttribute\n\n    # Generic field type description, usually overridden by subclasses\n    def _description(self):\n",
      "\n    }\n    system_check_deprecated_details = None\n    system_check_removed_details = None\n\n    # Field flags\n    hidden = False\n\n    many_to_many = None\n    many_to_one = None\n    one_to_many = None\n    one_to_one = None\n    related_model = None\n\n    descriptor_class = DeferredAttribute\n\n    # Generic field type description, usually overridden by subclasses\n    def _description(self):\n        return _('Field of type: %(field_type)s') % {\n            'field_type': self.__class__.__name__\n        }\n    description = property(_description)\n\n    def __init__(self, verbose_name=None, name=None, primary_key=False,\n                 max_length=None, unique=False, blank=False, null=False,\n                 db_index=False, rel=None, default=NOT_PROVIDED, editable=True,\n                 serialize=True, unique_for_date=None, unique_for_month=None,\n                 unique_for_year=None, choices=None, help_text='', db_column=None,\n",
      "\n    # Field flags\n    hidden = False\n\n    many_to_many = None\n    many_to_one = None\n    one_to_many = None\n    one_to_one = None\n    related_model = None\n\n    descriptor_class = DeferredAttribute\n\n    # Generic field type description, usually overridden by subclasses\n    def _description(self):\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 761-767)": [
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            setattr(cls, 'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self))\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            setattr(cls, 'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self))\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            setattr(cls, 'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self))\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            setattr(cls, 'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self))\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            setattr(cls, 'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self))\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            setattr(cls, 'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self))\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            setattr(cls, 'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self))\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            setattr(cls, 'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self))\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/models/enums.py lines 66-71)": [
      "\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n    pass\n\n\nclass TextChoices(str, Choices):\n",
      "\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n    \n    def __str__(self):\n        return str(self.value)\n\n\nclass TextChoices(str, Choices):\n    \"\"\"Class for creating enumerated string choices.\"\"\"\n    \n    def __str__(self):\n        return str(self.value)\n\n    def _generate_next_value_(name, start, count, last_values):\n        return name\n",
      "\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n    pass\n\n\nclass TextChoices(str, Choices):\n",
      "\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n    \n    def __new__(cls, value):\n        obj = int.__new__(cls, value)\n        obj._value_ = value\n        return obj\n\n\nclass TextChoices(str, Choices):\n    \"\"\"Class for creating enumerated string choices.\"\"\"\n    \n    def __new__(cls, value):\n        obj = str.__new__(cls, value)\n        obj._value_ = value\n        return obj\n",
      "\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n    pass\n\n\nclass TextChoices(str, Choices):\n",
      "\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n    \n    def __new__(cls, value):\n        obj = int.__new__(cls, value)\n        obj._value_ = value\n        return obj\n\n\nclass TextChoices(str, Choices):\n",
      "\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n    \n    def __str__(self):\n        return str(self.value)\n\n\nclass TextChoices(str, Choices):\n",
      "\nclass IntegerChoices(int, Choices):\n    \"\"\"Class for creating enumerated integer choices.\"\"\"\n    \n    def __str__(self):\n        return str(self.value)\n\n\nclass TextChoices(str, Choices):\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..0e63c4d1a7 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -63,6 +63,7 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n     pass\n \n \n+\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n     pass\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..850a5f185b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -116,6 +116,7 @@ class Field(RegisterLookupMixin):\n     many_to_many = None\n     many_to_one = None\n     one_to_many = None\n+\n     one_to_one = None\n     related_model = None\n \n@@ -758,6 +759,7 @@ class Field(RegisterLookupMixin):\n         cls._meta.add_field(self, private=private_only)\n         if self.column:\n             # Don't override classmethods with the descriptor. This means that\n+\n             # if you have a classmethod and a field with the same name, then\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n@@ -1007,6 +1009,7 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1d29969d70 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,7 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +139,15 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying primitive types.\n+        This ensures consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Convert the value using the field's to_python method\n+        converted_value = self.field.to_python(value)\n+        instance.__dict__[self.field.attname] = converted_value\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n",
    "variant_0": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..34f3b88eb9 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -63,9 +63,14 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n     pass\n \n \n+\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n-    pass\n+    \n+    def __new__(cls, value):\n+        obj = int.__new__(cls, value)\n+        obj._value_ = value\n+        return obj\n \n \n class TextChoices(str, Choices):\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..984f59ee82 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -113,6 +113,13 @@ class Field(RegisterLookupMixin):\n     # Field flags\n     hidden = False\n \n+    many_to_many = None\n+    many_to_one = None\n+    one_to_many = None\n+\n+    # Field flags\n+    hidden = False\n+\n     many_to_many = None\n     many_to_one = None\n     one_to_many = None\n@@ -746,6 +753,19 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -1007,7 +1027,11 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n+        # Handle enum objects by converting to their underlying value\n+        if hasattr(value, 'value'):\n+            value = value.value\n         if isinstance(value, str) or value is None:\n             return value\n         return str(value)\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1d29969d70 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,7 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +139,15 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying primitive types.\n+        This ensures consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Convert the value using the field's to_python method\n+        converted_value = self.field.to_python(value)\n+        instance.__dict__[self.field.attname] = converted_value\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n",
    "variant_1": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..0e63c4d1a7 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -63,6 +63,7 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n     pass\n \n \n+\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n     pass\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..1e9cfd9fc1 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -113,6 +113,13 @@ class Field(RegisterLookupMixin):\n     # Field flags\n     hidden = False\n \n+    many_to_many = None\n+    many_to_one = None\n+    one_to_many = None\n+\n+    # Field flags\n+    hidden = False\n+\n     many_to_many = None\n     many_to_one = None\n     one_to_many = None\n@@ -746,6 +753,19 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -1007,9 +1027,13 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Convert enum objects to their string representation\n+        if hasattr(value, 'value'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1d29969d70 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,7 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +139,15 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying primitive types.\n+        This ensures consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Convert the value using the field's to_python method\n+        converted_value = self.field.to_python(value)\n+        instance.__dict__[self.field.attname] = converted_value\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n",
    "variant_2": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..e7bc0c9c6f 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -63,13 +63,23 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n     pass\n \n \n+\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n-    pass\n+    \n+    def __str__(self):\n+        return str(self.value)\n \n \n class TextChoices(str, Choices):\n     \"\"\"Class for creating enumerated string choices.\"\"\"\n+    \n+    def __str__(self):\n+        return str(self.value)\n+\n+    def _generate_next_value_(name, start, count, last_values):\n+        return name\n+    \"\"\"Class for creating enumerated string choices.\"\"\"\n \n     def _generate_next_value_(name, start, count, last_values):\n         return name\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..bd0f597ba1 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -113,6 +113,17 @@ class Field(RegisterLookupMixin):\n     # Field flags\n     hidden = False\n \n+    many_to_many = None\n+    many_to_one = None\n+    one_to_many = None\n+\n+    }\n+    system_check_deprecated_details = None\n+    system_check_removed_details = None\n+\n+    # Field flags\n+    hidden = False\n+\n     many_to_many = None\n     many_to_one = None\n     one_to_many = None\n@@ -746,6 +757,19 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -1007,10 +1031,14 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n-    def to_python(self, value):\n-        if isinstance(value, str) or value is None:\n-            return value\n-        return str(value)\n+\n+def to_python(self, value):\n+    if isinstance(value, str) or value is None:\n+        return value\n+    # Handle enum objects by converting them to their underlying value\n+    if hasattr(value, 'value'):\n+        return str(value.value)\n+    return str(value)\n \n     def get_prep_value(self, value):\n         value = super().get_prep_value(value)\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1d29969d70 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,7 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +139,15 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying primitive types.\n+        This ensures consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Convert the value using the field's to_python method\n+        converted_value = self.field.to_python(value)\n+        instance.__dict__[self.field.attname] = converted_value\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n",
    "variant_3": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..0e63c4d1a7 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -63,6 +63,7 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n     pass\n \n \n+\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n     pass\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..d1ff50129c 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -113,6 +113,13 @@ class Field(RegisterLookupMixin):\n     # Field flags\n     hidden = False\n \n+    many_to_many = None\n+    many_to_one = None\n+    one_to_many = None\n+\n+    # Field flags\n+    hidden = False\n+\n     many_to_many = None\n     many_to_one = None\n     one_to_many = None\n@@ -746,6 +753,19 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -1007,6 +1027,7 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1d29969d70 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,7 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +139,15 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying primitive types.\n+        This ensures consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Convert the value using the field's to_python method\n+        converted_value = self.field.to_python(value)\n+        instance.__dict__[self.field.attname] = converted_value\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n",
    "variant_4": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..37fb2ae2a4 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -63,13 +63,24 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n     pass\n \n \n+\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n-    pass\n+    \n+    def __new__(cls, value):\n+        obj = int.__new__(cls, value)\n+        obj._value_ = value\n+        return obj\n \n \n class TextChoices(str, Choices):\n     \"\"\"Class for creating enumerated string choices.\"\"\"\n+    \n+    def __new__(cls, value):\n+        obj = str.__new__(cls, value)\n+        obj._value_ = value\n+        return obj\n+    \"\"\"Class for creating enumerated string choices.\"\"\"\n \n     def _generate_next_value_(name, start, count, last_values):\n         return name\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..26a8be7119 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -113,6 +113,17 @@ class Field(RegisterLookupMixin):\n     # Field flags\n     hidden = False\n \n+    many_to_many = None\n+    many_to_one = None\n+    one_to_many = None\n+\n+    }\n+    system_check_deprecated_details = None\n+    system_check_removed_details = None\n+\n+    # Field flags\n+    hidden = False\n+\n     many_to_many = None\n     many_to_one = None\n     one_to_many = None\n@@ -746,6 +757,19 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -1007,10 +1031,14 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n-    def to_python(self, value):\n-        if isinstance(value, str) or value is None:\n-            return value\n-        return str(value)\n+\n+def to_python(self, value):\n+    if isinstance(value, str) or value is None:\n+        return value\n+    # Convert enum objects to their string representation\n+    if hasattr(value, 'value'):\n+        return str(value.value)\n+    return str(value)\n \n     def get_prep_value(self, value):\n         value = super().get_prep_value(value)\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1d29969d70 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,7 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +139,15 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying primitive types.\n+        This ensures consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Convert the value using the field's to_python method\n+        converted_value = self.field.to_python(value)\n+        instance.__dict__[self.field.attname] = converted_value\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n",
    "variant_5": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..0e63c4d1a7 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -63,6 +63,7 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n     pass\n \n \n+\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n     pass\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..d1ff50129c 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -113,6 +113,13 @@ class Field(RegisterLookupMixin):\n     # Field flags\n     hidden = False\n \n+    many_to_many = None\n+    many_to_one = None\n+    one_to_many = None\n+\n+    # Field flags\n+    hidden = False\n+\n     many_to_many = None\n     many_to_one = None\n     one_to_many = None\n@@ -746,6 +753,19 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -1007,6 +1027,7 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1d29969d70 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,7 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +139,15 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying primitive types.\n+        This ensures consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Convert the value using the field's to_python method\n+        converted_value = self.field.to_python(value)\n+        instance.__dict__[self.field.attname] = converted_value\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n",
    "variant_6": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..34f3b88eb9 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -63,9 +63,14 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n     pass\n \n \n+\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n-    pass\n+    \n+    def __new__(cls, value):\n+        obj = int.__new__(cls, value)\n+        obj._value_ = value\n+        return obj\n \n \n class TextChoices(str, Choices):\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..d1ff50129c 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -113,6 +113,13 @@ class Field(RegisterLookupMixin):\n     # Field flags\n     hidden = False\n \n+    many_to_many = None\n+    many_to_one = None\n+    one_to_many = None\n+\n+    # Field flags\n+    hidden = False\n+\n     many_to_many = None\n     many_to_one = None\n     one_to_many = None\n@@ -746,6 +753,19 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -1007,6 +1027,7 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1d29969d70 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,7 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +139,15 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying primitive types.\n+        This ensures consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Convert the value using the field's to_python method\n+        converted_value = self.field.to_python(value)\n+        instance.__dict__[self.field.attname] = converted_value\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n",
    "variant_7": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..e979423b04 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -63,9 +63,12 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n     pass\n \n \n+\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n-    pass\n+    \n+    def __str__(self):\n+        return str(self.value)\n \n \n class TextChoices(str, Choices):\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..c6eea1f5d3 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -113,6 +113,17 @@ class Field(RegisterLookupMixin):\n     # Field flags\n     hidden = False\n \n+    many_to_many = None\n+    many_to_one = None\n+    one_to_many = None\n+\n+    }\n+    system_check_deprecated_details = None\n+    system_check_removed_details = None\n+\n+    # Field flags\n+    hidden = False\n+\n     many_to_many = None\n     many_to_one = None\n     one_to_many = None\n@@ -128,6 +139,16 @@ class Field(RegisterLookupMixin):\n         }\n     description = property(_description)\n \n+    def __init__(self, verbose_name=None, name=None, primary_key=False,\n+                 max_length=None, unique=False, blank=False, null=False,\n+                 db_index=False, rel=None, default=NOT_PROVIDED, editable=True,\n+                 serialize=True, unique_for_date=None, unique_for_month=None,\n+                 unique_for_year=None, choices=None, help_text='', db_column=None,\n+        return _('Field of type: %(field_type)s') % {\n+            'field_type': self.__class__.__name__\n+        }\n+    description = property(_description)\n+\n     def __init__(self, verbose_name=None, name=None, primary_key=False,\n                  max_length=None, unique=False, blank=False, null=False,\n                  db_index=False, rel=None, default=NOT_PROVIDED, editable=True,\n@@ -746,6 +767,19 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -1007,6 +1041,7 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1d29969d70 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,7 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +139,15 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying primitive types.\n+        This ensures consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Convert the value using the field's to_python method\n+        converted_value = self.field.to_python(value)\n+        instance.__dict__[self.field.attname] = converted_value\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n",
    "variant_8": "diff --git a/django/db/models/enums.py b/django/db/models/enums.py\nindex bbe362a6ab..e979423b04 100644\n--- a/django/db/models/enums.py\n+++ b/django/db/models/enums.py\n@@ -63,9 +63,12 @@ class Choices(enum.Enum, metaclass=ChoicesMeta):\n     pass\n \n \n+\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n-    pass\n+    \n+    def __str__(self):\n+        return str(self.value)\n \n \n class TextChoices(str, Choices):\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..d1ff50129c 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -113,6 +113,13 @@ class Field(RegisterLookupMixin):\n     # Field flags\n     hidden = False\n \n+    many_to_many = None\n+    many_to_one = None\n+    one_to_many = None\n+\n+    # Field flags\n+    hidden = False\n+\n     many_to_many = None\n     many_to_one = None\n     one_to_many = None\n@@ -746,6 +753,19 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -1007,6 +1027,7 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1d29969d70 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,7 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +139,15 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying primitive types.\n+        This ensures consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Convert the value using the field's to_python method\n+        converted_value = self.field.to_python(value)\n+        instance.__dict__[self.field.attname] = converted_value\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n"
  }
}