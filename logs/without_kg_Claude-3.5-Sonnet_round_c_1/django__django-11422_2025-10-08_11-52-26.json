{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/utils/autoreload.py lines 99-106)": "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in the extra files to watch\n    extra_files = frozenset(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files = extra_files | {main_script}\n    \n    return iter_modules_and_files(modules, extra_files)\n",
    "Location 2 (/root/hy/projects_1/django/django/utils/autoreload.py lines 110-136)": "\n@functools.lru_cache(maxsize=1)\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in addition to error_files\n    extra_files = set(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = pathlib.Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files.add(str(main_script.resolve()))\n    \n    return iter_modules_and_files(modules, frozenset(extra_files))\n",
    "Location 3 (/root/hy/projects_1/django/django/utils/autoreload.py lines 240-249)": "\ndef iter_all_python_module_files():\n    # Yield main script file first if it exists and is a Python file\n    main_script = sys.argv[0] if sys.argv else None\n    if main_script:\n        main_path = Path(main_script).resolve()\n        if main_path.exists() and main_path.suffix == '.py':\n            yield main_path\n    \n    # Yield all module files\n    return itertools.chain(\n        iter_modules_and_files(iter_modules(), frozenset(_error_files)),\n        iter_modules_and_files(sys.modules.values(), frozenset(_error_files)),\n    )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/utils/autoreload.py lines 99-106)": [
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in the watched files\n    extra_files = frozenset(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = pathlib.Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files = extra_files | {str(main_script)}\n    \n    return iter_modules_and_files(modules, extra_files)\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in the watched files\n    extra_files = frozenset(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = pathlib.Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files = extra_files | {str(main_script)}\n    \n    return iter_modules_and_files(modules, extra_files)\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in the extra files to watch\n    extra_files = frozenset(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files = extra_files | {main_script}\n    \n    return iter_modules_and_files(modules, extra_files)\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (like manage.py) in the extra files to watch\n    extra_files = frozenset(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files = extra_files | {main_script}\n    \n    return iter_modules_and_files(modules, extra_files)\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in extra_files\n    extra_files = set(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files.add(main_script)\n    \n    return iter_modules_and_files(modules, frozenset(extra_files))\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in the extra files to watch\n    extra_files = frozenset(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files = extra_files | {str(main_script)}\n    \n    return iter_modules_and_files(modules, extra_files)\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in the extra files to watch\n    extra_files = frozenset(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files = extra_files | {main_script}\n    \n    return iter_modules_and_files(modules, extra_files)\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in the extra_files\n    extra_files = set(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files.add(main_script)\n    \n    return iter_modules_and_files(modules, frozenset(extra_files))\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/utils/autoreload.py lines 110-136)": [
      "\n@functools.lru_cache(maxsize=1)\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in the watched files\n    extra_files = set(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = pathlib.Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files.add(str(main_script.resolve()))\n    \n    return iter_modules_and_files(modules, frozenset(extra_files))\n",
      "\n@functools.lru_cache(maxsize=1)\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in addition to error files\n    extra_files = set(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = pathlib.Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files.add(str(main_script.resolve()))\n    \n    return iter_modules_and_files(modules, frozenset(extra_files))\n",
      "\n@functools.lru_cache(maxsize=1)\ndef iter_modules_and_files(modules, extra_files):\n    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n    sys_file_paths = []\n    for module in modules:\n        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n        # are added to sys.modules, however they are types not modules and so\n        # cause issues here.\n        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\n            continue\n        spec = module.__spec__\n        # Modules could be loaded from places without a concrete location. If\n        # this is the case, skip them.\n        if spec.has_location:\n            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n            sys_file_paths.append(origin)\n\n    # Include the main script file (e.g., manage.py) if it exists\n    if sys.argv and sys.argv[0]:\n        sys_file_paths.append(sys.argv[0])\n\n    results = set()\n    for filename in itertools.chain(sys_file_paths, extra_files):\n        if not filename:\n            continue\n        path = pathlib.Path(filename)\n        if not path.exists():\n            # The module could have been removed, don't fail loudly if this\n            # is the case.\n            continue\n        results.add(path.resolve().absolute())\n    return frozenset(results)\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (like manage.py) in the watched files\n    extra_files = set(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = os.path.abspath(sys.argv[0])\n        if main_script.endswith('.py'):\n            extra_files.add(main_script)\n    \n    return iter_modules_and_files(modules, frozenset(extra_files))\n",
      "\n@functools.lru_cache(maxsize=1)\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in addition to error files\n    extra_files = set(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = os.path.abspath(sys.argv[0])\n        if main_script.endswith('.py'):\n            extra_files.add(main_script)\n    \n    return iter_modules_and_files(modules, frozenset(extra_files))\n",
      "\n@functools.lru_cache(maxsize=1)\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in watched files\n    extra_files = set(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = pathlib.Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files.add(str(main_script.resolve().absolute()))\n    \n    return iter_modules_and_files(modules, frozenset(extra_files))\n",
      "\n@functools.lru_cache(maxsize=1)\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in addition to module files\n    extra_files = set(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = pathlib.Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            extra_files.add(str(main_script.resolve()))\n    \n    return iter_modules_and_files(modules, frozenset(extra_files))\n",
      "\n@functools.lru_cache(maxsize=1)\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) in the watched files\n    main_script_files = set()\n    if sys.argv and sys.argv[0]:\n        main_script_files.add(sys.argv[0])\n    \n    return iter_modules_and_files(modules, frozenset(_error_files) | main_script_files)\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/utils/autoreload.py lines 240-249)": [
      "\ndef iter_all_python_module_files():\n    # Yield the main script file first (e.g., manage.py)\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            yield main_script.resolve()\n    \n    # Yield all module files\n    return iter_modules_and_files(modules, frozenset(_error_files))\n",
      "\ndef iter_all_python_module_files():\n    # Yield main script file if it exists\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            yield main_script.resolve()\n    \n    # Yield all module files\n    return iter_modules_and_files(modules, frozenset(_error_files))\n",
      "\ndef iter_all_python_module_files():\n    # Yield the main script file (e.g., manage.py) if it exists\n    if sys.argv and sys.argv[0]:\n        main_script_path = Path(sys.argv[0]).resolve()\n        if main_script_path.exists() and main_script_path.suffix == '.py':\n            yield main_script_path\n    \n    # Yield Python files from all currently imported modules\n    return iter_modules_and_files(list(sys.modules.values()), frozenset())\n",
      "\ndef iter_all_python_module_files():\n    # Yield the main script file if it exists and is a Python file\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            yield main_script\n    \n    # Yield module files from sys.modules\n    return itertools.chain(\n        iter_modules_and_files(tuple(sys.modules.values()), frozenset(_error_files)),\n    )\n",
      "\ndef iter_all_python_module_files():\n    # Yield the main script file if it exists and is a Python file\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            yield main_script\n    \n    # Yield all module files from sys.modules\n    return iter_modules_and_files(modules, frozenset(_error_files))\n",
      "\ndef iter_all_python_module_files():\n    # Yield the main script file if it exists and is a Python file\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            yield main_script\n    \n    # Yield module files from sys.modules\n    return iter_modules_and_files(modules, frozenset(_error_files))\n",
      "\ndef iter_all_python_module_files():\n    # Include the main script file (e.g., manage.py)\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            yield main_script.resolve()\n    \n    # Iterate over all loaded modules\n    for module in list(sys.modules.values()):\n        if module is None:\n            continue\n        filename = getattr(module, '__file__', None)\n        if filename:\n            yield Path(filename)\n",
      "\ndef iter_all_python_module_files():\n    # Yield the main script file if it exists and is a Python file\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            yield main_script\n    \n    # Yield all module files\n    return iter_modules_and_files(modules, frozenset(_error_files))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..4aab81b614 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,8 +104,15 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n+    # Include the main script file (e.g., manage.py) in the watched files\n+    # since it's executed as a script and not imported as a module\n+    main_script_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script_files.add(sys.argv[0])\n+    return iter_modules_and_files(modules, frozenset(main_script_files))\n+\n \n+@functools.lru_cache(maxsize=1)\n \n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n@@ -236,6 +244,8 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+    def watched_files(self, include_globs=True):\n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n",
    "variant_0": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..be4bde850e 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,37 +104,36 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Include the main script file (e.g., manage.py) in the extra files to watch\n+    extra_files = frozenset(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files = extra_files | {main_script}\n+    \n+    return iter_modules_and_files(modules, extra_files)\n \n \n @functools.lru_cache(maxsize=1)\n-def iter_modules_and_files(modules, extra_files):\n-    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n-    sys_file_paths = []\n-    for module in modules:\n-        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n-        # are added to sys.modules, however they are types not modules and so\n-        # cause issues here.\n-        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\n-            continue\n-        spec = module.__spec__\n-        # Modules could be loaded from places without a concrete location. If\n-        # this is the case, skip them.\n-        if spec.has_location:\n-            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n-            sys_file_paths.append(origin)\n-\n-    results = set()\n-    for filename in itertools.chain(sys_file_paths, extra_files):\n-        if not filename:\n-            continue\n-        path = pathlib.Path(filename)\n-        if not path.exists():\n-            # The module could have been removed, don't fail loudly if this\n-            # is the case.\n-            continue\n-        results.add(path.resolve().absolute())\n-    return frozenset(results)\n+\n+@functools.lru_cache(maxsize=1)\n+def iter_all_python_module_files():\n+    # This is a hot path during reloading. Create a stable sorted list of\n+    # modules based on the module name and pass it to iter_modules_and_files().\n+    # This ensures cached results are returned in the usual case that modules\n+    # aren't loaded on the fly.\n+    keys = sorted(sys.modules)\n+    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n+    \n+    # Include the main script file (e.g., manage.py) in addition to error_files\n+    extra_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = pathlib.Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files.add(str(main_script.resolve()))\n+    \n+    return iter_modules_and_files(modules, frozenset(extra_files))\n \n \n @functools.lru_cache(maxsize=1)\n@@ -237,16 +237,20 @@ class BaseReloader:\n         self.extra_files.add(path)\n \n     def watched_files(self, include_globs=True):\n-        \"\"\"\n-        Yield all files that need to be watched, including module files and\n-        files within globs.\n-        \"\"\"\n-        yield from iter_all_python_module_files()\n-        yield from self.extra_files\n-        if include_globs:\n-            for directory, patterns in self.directory_globs.items():\n-                for pattern in patterns:\n-                    yield from directory.glob(pattern)\n+\n+def iter_all_python_module_files():\n+    # Yield main script file first if it exists and is a Python file\n+    main_script = sys.argv[0] if sys.argv else None\n+    if main_script:\n+        main_path = Path(main_script).resolve()\n+        if main_path.exists() and main_path.suffix == '.py':\n+            yield main_path\n+    \n+    # Yield all module files\n+    return itertools.chain(\n+        iter_modules_and_files(iter_modules(), frozenset(_error_files)),\n+        iter_modules_and_files(sys.modules.values(), frozenset(_error_files)),\n+    )\n \n     def wait_for_apps_ready(self, app_reg, django_main_thread):\n         \"\"\"\n",
    "variant_1": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..fe46c226af 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,37 +104,36 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Include the main script file (e.g., manage.py) in the watched files\n+    extra_files = frozenset(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = pathlib.Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files = extra_files | {str(main_script)}\n+    \n+    return iter_modules_and_files(modules, extra_files)\n \n \n @functools.lru_cache(maxsize=1)\n-def iter_modules_and_files(modules, extra_files):\n-    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n-    sys_file_paths = []\n-    for module in modules:\n-        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n-        # are added to sys.modules, however they are types not modules and so\n-        # cause issues here.\n-        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\n-            continue\n-        spec = module.__spec__\n-        # Modules could be loaded from places without a concrete location. If\n-        # this is the case, skip them.\n-        if spec.has_location:\n-            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n-            sys_file_paths.append(origin)\n-\n-    results = set()\n-    for filename in itertools.chain(sys_file_paths, extra_files):\n-        if not filename:\n-            continue\n-        path = pathlib.Path(filename)\n-        if not path.exists():\n-            # The module could have been removed, don't fail loudly if this\n-            # is the case.\n-            continue\n-        results.add(path.resolve().absolute())\n-    return frozenset(results)\n+\n+@functools.lru_cache(maxsize=1)\n+def iter_all_python_module_files():\n+    # This is a hot path during reloading. Create a stable sorted list of\n+    # modules based on the module name and pass it to iter_modules_and_files().\n+    # This ensures cached results are returned in the usual case that modules\n+    # aren't loaded on the fly.\n+    keys = sorted(sys.modules)\n+    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n+    \n+    # Include the main script file (e.g., manage.py) in the watched files\n+    extra_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = pathlib.Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files.add(str(main_script.resolve()))\n+    \n+    return iter_modules_and_files(modules, frozenset(extra_files))\n \n \n @functools.lru_cache(maxsize=1)\n@@ -237,16 +237,16 @@ class BaseReloader:\n         self.extra_files.add(path)\n \n     def watched_files(self, include_globs=True):\n-        \"\"\"\n-        Yield all files that need to be watched, including module files and\n-        files within globs.\n-        \"\"\"\n-        yield from iter_all_python_module_files()\n-        yield from self.extra_files\n-        if include_globs:\n-            for directory, patterns in self.directory_globs.items():\n-                for pattern in patterns:\n-                    yield from directory.glob(pattern)\n+\n+def iter_all_python_module_files():\n+    # Yield the main script file first (e.g., manage.py)\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            yield main_script.resolve()\n+    \n+    # Yield all module files\n+    return iter_modules_and_files(modules, frozenset(_error_files))\n \n     def wait_for_apps_ready(self, app_reg, django_main_thread):\n         \"\"\"\n",
    "variant_2": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..ff77df6010 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,37 +104,36 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Include the main script file (e.g., manage.py) in the watched files\n+    extra_files = frozenset(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = pathlib.Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files = extra_files | {str(main_script)}\n+    \n+    return iter_modules_and_files(modules, extra_files)\n \n \n @functools.lru_cache(maxsize=1)\n-def iter_modules_and_files(modules, extra_files):\n-    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n-    sys_file_paths = []\n-    for module in modules:\n-        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n-        # are added to sys.modules, however they are types not modules and so\n-        # cause issues here.\n-        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\n-            continue\n-        spec = module.__spec__\n-        # Modules could be loaded from places without a concrete location. If\n-        # this is the case, skip them.\n-        if spec.has_location:\n-            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n-            sys_file_paths.append(origin)\n-\n-    results = set()\n-    for filename in itertools.chain(sys_file_paths, extra_files):\n-        if not filename:\n-            continue\n-        path = pathlib.Path(filename)\n-        if not path.exists():\n-            # The module could have been removed, don't fail loudly if this\n-            # is the case.\n-            continue\n-        results.add(path.resolve().absolute())\n-    return frozenset(results)\n+\n+@functools.lru_cache(maxsize=1)\n+def iter_all_python_module_files():\n+    # This is a hot path during reloading. Create a stable sorted list of\n+    # modules based on the module name and pass it to iter_modules_and_files().\n+    # This ensures cached results are returned in the usual case that modules\n+    # aren't loaded on the fly.\n+    keys = sorted(sys.modules)\n+    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n+    \n+    # Include the main script file (e.g., manage.py) in addition to error files\n+    extra_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = pathlib.Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files.add(str(main_script.resolve()))\n+    \n+    return iter_modules_and_files(modules, frozenset(extra_files))\n \n \n @functools.lru_cache(maxsize=1)\n@@ -237,16 +237,16 @@ class BaseReloader:\n         self.extra_files.add(path)\n \n     def watched_files(self, include_globs=True):\n-        \"\"\"\n-        Yield all files that need to be watched, including module files and\n-        files within globs.\n-        \"\"\"\n-        yield from iter_all_python_module_files()\n-        yield from self.extra_files\n-        if include_globs:\n-            for directory, patterns in self.directory_globs.items():\n-                for pattern in patterns:\n-                    yield from directory.glob(pattern)\n+\n+def iter_all_python_module_files():\n+    # Yield main script file if it exists\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            yield main_script.resolve()\n+    \n+    # Yield all module files\n+    return iter_modules_and_files(modules, frozenset(_error_files))\n \n     def wait_for_apps_ready(self, app_reg, django_main_thread):\n         \"\"\"\n",
    "variant_3": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..6b07fd1139 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,8 +104,18 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Include the main script file (e.g., manage.py) in the extra files to watch\n+    extra_files = frozenset(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files = extra_files | {main_script}\n+    \n+    return iter_modules_and_files(modules, extra_files)\n+\n \n+@functools.lru_cache(maxsize=1)\n \n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n@@ -123,6 +134,10 @@ def iter_modules_and_files(modules, extra_files):\n             origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n             sys_file_paths.append(origin)\n \n+    # Include the main script file (e.g., manage.py) if it exists\n+    if sys.argv and sys.argv[0]:\n+        sys_file_paths.append(sys.argv[0])\n+\n     results = set()\n     for filename in itertools.chain(sys_file_paths, extra_files):\n         if not filename:\n@@ -237,16 +252,16 @@ class BaseReloader:\n         self.extra_files.add(path)\n \n     def watched_files(self, include_globs=True):\n-        \"\"\"\n-        Yield all files that need to be watched, including module files and\n-        files within globs.\n-        \"\"\"\n-        yield from iter_all_python_module_files()\n-        yield from self.extra_files\n-        if include_globs:\n-            for directory, patterns in self.directory_globs.items():\n-                for pattern in patterns:\n-                    yield from directory.glob(pattern)\n+\n+def iter_all_python_module_files():\n+    # Yield the main script file (e.g., manage.py) if it exists\n+    if sys.argv and sys.argv[0]:\n+        main_script_path = Path(sys.argv[0]).resolve()\n+        if main_script_path.exists() and main_script_path.suffix == '.py':\n+            yield main_script_path\n+    \n+    # Yield Python files from all currently imported modules\n+    return iter_modules_and_files(list(sys.modules.values()), frozenset())\n \n     def wait_for_apps_ready(self, app_reg, django_main_thread):\n         \"\"\"\n",
    "variant_4": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..3973061aaf 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,37 +104,35 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Include the main script file (like manage.py) in the extra files to watch\n+    extra_files = frozenset(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files = extra_files | {main_script}\n+    \n+    return iter_modules_and_files(modules, extra_files)\n \n \n @functools.lru_cache(maxsize=1)\n-def iter_modules_and_files(modules, extra_files):\n-    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n-    sys_file_paths = []\n-    for module in modules:\n-        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n-        # are added to sys.modules, however they are types not modules and so\n-        # cause issues here.\n-        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\n-            continue\n-        spec = module.__spec__\n-        # Modules could be loaded from places without a concrete location. If\n-        # this is the case, skip them.\n-        if spec.has_location:\n-            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n-            sys_file_paths.append(origin)\n-\n-    results = set()\n-    for filename in itertools.chain(sys_file_paths, extra_files):\n-        if not filename:\n-            continue\n-        path = pathlib.Path(filename)\n-        if not path.exists():\n-            # The module could have been removed, don't fail loudly if this\n-            # is the case.\n-            continue\n-        results.add(path.resolve().absolute())\n-    return frozenset(results)\n+\n+def iter_all_python_module_files():\n+    # This is a hot path during reloading. Create a stable sorted list of\n+    # modules based on the module name and pass it to iter_modules_and_files().\n+    # This ensures cached results are returned in the usual case that modules\n+    # aren't loaded on the fly.\n+    keys = sorted(sys.modules)\n+    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n+    \n+    # Include the main script file (like manage.py) in the watched files\n+    extra_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = os.path.abspath(sys.argv[0])\n+        if main_script.endswith('.py'):\n+            extra_files.add(main_script)\n+    \n+    return iter_modules_and_files(modules, frozenset(extra_files))\n \n \n @functools.lru_cache(maxsize=1)\n@@ -237,16 +236,18 @@ class BaseReloader:\n         self.extra_files.add(path)\n \n     def watched_files(self, include_globs=True):\n-        \"\"\"\n-        Yield all files that need to be watched, including module files and\n-        files within globs.\n-        \"\"\"\n-        yield from iter_all_python_module_files()\n-        yield from self.extra_files\n-        if include_globs:\n-            for directory, patterns in self.directory_globs.items():\n-                for pattern in patterns:\n-                    yield from directory.glob(pattern)\n+\n+def iter_all_python_module_files():\n+    # Yield the main script file if it exists and is a Python file\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            yield main_script\n+    \n+    # Yield module files from sys.modules\n+    return itertools.chain(\n+        iter_modules_and_files(tuple(sys.modules.values()), frozenset(_error_files)),\n+    )\n \n     def wait_for_apps_ready(self, app_reg, django_main_thread):\n         \"\"\"\n",
    "variant_5": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..5522f69d3f 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,37 +104,36 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Include the main script file (e.g., manage.py) in extra_files\n+    extra_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files.add(main_script)\n+    \n+    return iter_modules_and_files(modules, frozenset(extra_files))\n \n \n @functools.lru_cache(maxsize=1)\n-def iter_modules_and_files(modules, extra_files):\n-    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n-    sys_file_paths = []\n-    for module in modules:\n-        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n-        # are added to sys.modules, however they are types not modules and so\n-        # cause issues here.\n-        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\n-            continue\n-        spec = module.__spec__\n-        # Modules could be loaded from places without a concrete location. If\n-        # this is the case, skip them.\n-        if spec.has_location:\n-            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n-            sys_file_paths.append(origin)\n-\n-    results = set()\n-    for filename in itertools.chain(sys_file_paths, extra_files):\n-        if not filename:\n-            continue\n-        path = pathlib.Path(filename)\n-        if not path.exists():\n-            # The module could have been removed, don't fail loudly if this\n-            # is the case.\n-            continue\n-        results.add(path.resolve().absolute())\n-    return frozenset(results)\n+\n+@functools.lru_cache(maxsize=1)\n+def iter_all_python_module_files():\n+    # This is a hot path during reloading. Create a stable sorted list of\n+    # modules based on the module name and pass it to iter_modules_and_files().\n+    # This ensures cached results are returned in the usual case that modules\n+    # aren't loaded on the fly.\n+    keys = sorted(sys.modules)\n+    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n+    \n+    # Include the main script file (e.g., manage.py) in addition to error files\n+    extra_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = os.path.abspath(sys.argv[0])\n+        if main_script.endswith('.py'):\n+            extra_files.add(main_script)\n+    \n+    return iter_modules_and_files(modules, frozenset(extra_files))\n \n \n @functools.lru_cache(maxsize=1)\n@@ -237,16 +237,16 @@ class BaseReloader:\n         self.extra_files.add(path)\n \n     def watched_files(self, include_globs=True):\n-        \"\"\"\n-        Yield all files that need to be watched, including module files and\n-        files within globs.\n-        \"\"\"\n-        yield from iter_all_python_module_files()\n-        yield from self.extra_files\n-        if include_globs:\n-            for directory, patterns in self.directory_globs.items():\n-                for pattern in patterns:\n-                    yield from directory.glob(pattern)\n+\n+def iter_all_python_module_files():\n+    # Yield the main script file if it exists and is a Python file\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            yield main_script\n+    \n+    # Yield all module files from sys.modules\n+    return iter_modules_and_files(modules, frozenset(_error_files))\n \n     def wait_for_apps_ready(self, app_reg, django_main_thread):\n         \"\"\"\n",
    "variant_6": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..ff03431550 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,37 +104,36 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Include the main script file (e.g., manage.py) in the extra files to watch\n+    extra_files = frozenset(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files = extra_files | {str(main_script)}\n+    \n+    return iter_modules_and_files(modules, extra_files)\n \n \n @functools.lru_cache(maxsize=1)\n-def iter_modules_and_files(modules, extra_files):\n-    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n-    sys_file_paths = []\n-    for module in modules:\n-        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n-        # are added to sys.modules, however they are types not modules and so\n-        # cause issues here.\n-        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\n-            continue\n-        spec = module.__spec__\n-        # Modules could be loaded from places without a concrete location. If\n-        # this is the case, skip them.\n-        if spec.has_location:\n-            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n-            sys_file_paths.append(origin)\n-\n-    results = set()\n-    for filename in itertools.chain(sys_file_paths, extra_files):\n-        if not filename:\n-            continue\n-        path = pathlib.Path(filename)\n-        if not path.exists():\n-            # The module could have been removed, don't fail loudly if this\n-            # is the case.\n-            continue\n-        results.add(path.resolve().absolute())\n-    return frozenset(results)\n+\n+@functools.lru_cache(maxsize=1)\n+def iter_all_python_module_files():\n+    # This is a hot path during reloading. Create a stable sorted list of\n+    # modules based on the module name and pass it to iter_modules_and_files().\n+    # This ensures cached results are returned in the usual case that modules\n+    # aren't loaded on the fly.\n+    keys = sorted(sys.modules)\n+    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n+    \n+    # Include the main script file (e.g., manage.py) in watched files\n+    extra_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = pathlib.Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files.add(str(main_script.resolve().absolute()))\n+    \n+    return iter_modules_and_files(modules, frozenset(extra_files))\n \n \n @functools.lru_cache(maxsize=1)\n@@ -237,16 +237,16 @@ class BaseReloader:\n         self.extra_files.add(path)\n \n     def watched_files(self, include_globs=True):\n-        \"\"\"\n-        Yield all files that need to be watched, including module files and\n-        files within globs.\n-        \"\"\"\n-        yield from iter_all_python_module_files()\n-        yield from self.extra_files\n-        if include_globs:\n-            for directory, patterns in self.directory_globs.items():\n-                for pattern in patterns:\n-                    yield from directory.glob(pattern)\n+\n+def iter_all_python_module_files():\n+    # Yield the main script file if it exists and is a Python file\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            yield main_script\n+    \n+    # Yield module files from sys.modules\n+    return iter_modules_and_files(modules, frozenset(_error_files))\n \n     def wait_for_apps_ready(self, app_reg, django_main_thread):\n         \"\"\"\n",
    "variant_7": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..12197ec742 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,37 +104,36 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Include the main script file (e.g., manage.py) in the extra files to watch\n+    extra_files = frozenset(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files = extra_files | {main_script}\n+    \n+    return iter_modules_and_files(modules, extra_files)\n \n \n @functools.lru_cache(maxsize=1)\n-def iter_modules_and_files(modules, extra_files):\n-    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n-    sys_file_paths = []\n-    for module in modules:\n-        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n-        # are added to sys.modules, however they are types not modules and so\n-        # cause issues here.\n-        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\n-            continue\n-        spec = module.__spec__\n-        # Modules could be loaded from places without a concrete location. If\n-        # this is the case, skip them.\n-        if spec.has_location:\n-            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n-            sys_file_paths.append(origin)\n-\n-    results = set()\n-    for filename in itertools.chain(sys_file_paths, extra_files):\n-        if not filename:\n-            continue\n-        path = pathlib.Path(filename)\n-        if not path.exists():\n-            # The module could have been removed, don't fail loudly if this\n-            # is the case.\n-            continue\n-        results.add(path.resolve().absolute())\n-    return frozenset(results)\n+\n+@functools.lru_cache(maxsize=1)\n+def iter_all_python_module_files():\n+    # This is a hot path during reloading. Create a stable sorted list of\n+    # modules based on the module name and pass it to iter_modules_and_files().\n+    # This ensures cached results are returned in the usual case that modules\n+    # aren't loaded on the fly.\n+    keys = sorted(sys.modules)\n+    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n+    \n+    # Include the main script file (e.g., manage.py) in addition to module files\n+    extra_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = pathlib.Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files.add(str(main_script.resolve()))\n+    \n+    return iter_modules_and_files(modules, frozenset(extra_files))\n \n \n @functools.lru_cache(maxsize=1)\n@@ -237,16 +237,21 @@ class BaseReloader:\n         self.extra_files.add(path)\n \n     def watched_files(self, include_globs=True):\n-        \"\"\"\n-        Yield all files that need to be watched, including module files and\n-        files within globs.\n-        \"\"\"\n-        yield from iter_all_python_module_files()\n-        yield from self.extra_files\n-        if include_globs:\n-            for directory, patterns in self.directory_globs.items():\n-                for pattern in patterns:\n-                    yield from directory.glob(pattern)\n+\n+def iter_all_python_module_files():\n+    # Include the main script file (e.g., manage.py)\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            yield main_script.resolve()\n+    \n+    # Iterate over all loaded modules\n+    for module in list(sys.modules.values()):\n+        if module is None:\n+            continue\n+        filename = getattr(module, '__file__', None)\n+        if filename:\n+            yield Path(filename)\n \n     def wait_for_apps_ready(self, app_reg, django_main_thread):\n         \"\"\"\n",
    "variant_8": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..7fe9721b13 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,37 +104,34 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Include the main script file (e.g., manage.py) in the extra_files\n+    extra_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            extra_files.add(main_script)\n+    \n+    return iter_modules_and_files(modules, frozenset(extra_files))\n \n \n @functools.lru_cache(maxsize=1)\n-def iter_modules_and_files(modules, extra_files):\n-    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n-    sys_file_paths = []\n-    for module in modules:\n-        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n-        # are added to sys.modules, however they are types not modules and so\n-        # cause issues here.\n-        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\n-            continue\n-        spec = module.__spec__\n-        # Modules could be loaded from places without a concrete location. If\n-        # this is the case, skip them.\n-        if spec.has_location:\n-            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n-            sys_file_paths.append(origin)\n-\n-    results = set()\n-    for filename in itertools.chain(sys_file_paths, extra_files):\n-        if not filename:\n-            continue\n-        path = pathlib.Path(filename)\n-        if not path.exists():\n-            # The module could have been removed, don't fail loudly if this\n-            # is the case.\n-            continue\n-        results.add(path.resolve().absolute())\n-    return frozenset(results)\n+\n+@functools.lru_cache(maxsize=1)\n+def iter_all_python_module_files():\n+    # This is a hot path during reloading. Create a stable sorted list of\n+    # modules based on the module name and pass it to iter_modules_and_files().\n+    # This ensures cached results are returned in the usual case that modules\n+    # aren't loaded on the fly.\n+    keys = sorted(sys.modules)\n+    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n+    \n+    # Include the main script file (e.g., manage.py) in the watched files\n+    main_script_files = set()\n+    if sys.argv and sys.argv[0]:\n+        main_script_files.add(sys.argv[0])\n+    \n+    return iter_modules_and_files(modules, frozenset(_error_files) | main_script_files)\n \n \n @functools.lru_cache(maxsize=1)\n@@ -237,16 +235,16 @@ class BaseReloader:\n         self.extra_files.add(path)\n \n     def watched_files(self, include_globs=True):\n-        \"\"\"\n-        Yield all files that need to be watched, including module files and\n-        files within globs.\n-        \"\"\"\n-        yield from iter_all_python_module_files()\n-        yield from self.extra_files\n-        if include_globs:\n-            for directory, patterns in self.directory_globs.items():\n-                for pattern in patterns:\n-                    yield from directory.glob(pattern)\n+\n+def iter_all_python_module_files():\n+    # Yield the main script file if it exists and is a Python file\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            yield main_script\n+    \n+    # Yield all module files\n+    return iter_modules_and_files(modules, frozenset(_error_files))\n \n     def wait_for_apps_ready(self, app_reg, django_main_thread):\n         \"\"\"\n"
  }
}