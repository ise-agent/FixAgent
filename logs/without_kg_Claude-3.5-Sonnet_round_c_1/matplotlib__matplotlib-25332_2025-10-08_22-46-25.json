{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/cbook.py lines 754-849)": "\nclass Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]\n\n    def __getstate__(self):\n        \"\"\"Support for pickle: convert weakrefs to strong references.\"\"\"\n        self.clean()\n        # Convert weakref-based mapping to strong reference based\n        groups = []\n        seen_groups = set()\n        for group in self._mapping.values():\n            group_id = id(group)\n            if group_id not in seen_groups:\n                seen_groups.add(group_id)\n                # Extract objects from weakrefs, filtering out None (dead refs)\n                objects = [ref() for ref in group if ref() is not None]\n                if objects:  # Only include non-empty groups\n                    groups.append(objects)\n        return {'groups': groups}\n\n    def __setstate__(self, state):\n        \"\"\"Support for pickle: recreate weakref-based mapping from strong references.\"\"\"\n        self._mapping = {}\n        for group in state['groups']:\n            if group:  # Skip empty groups\n                # Create weakrefs for all objects in the group\n                weak_refs = [weakref.ref(obj) for obj in group]\n                # Map each weakref to the same list of weakrefs\n                for weak_ref in weak_refs:\n                    self._mapping[weak_ref] = weak_refs\n",
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/cbook.py lines 788-789)": "\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __getstate__(self):\n        \"\"\"Support for pickle serialization.\"\"\"\n        # Convert weakrefs to strong references for pickling\n        state = {}\n        for key_ref, group_refs in self._mapping.items():\n            key_obj = key_ref()\n            if key_obj is not None:  # Only include live references\n                group_objs = [ref() for ref in group_refs if ref() is not None]\n                if group_objs:  # Only include non-empty groups\n                    state[key_obj] = group_objs\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Support for pickle deserialization.\"\"\"\n        # Recreate weakref-based mapping from strong references\n        self._mapping = {}\n        for key_obj, group_objs in state.items():\n            key_ref = weakref.ref(key_obj)\n            group_refs = [weakref.ref(obj) for obj in group_objs]\n            self._mapping[key_ref] = group_refs\n",
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/cbook.py lines 802-818)": "\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling by converting weakrefs to strong references.\"\"\"\n        # Convert weakref-based mapping to strong references for pickling\n        strong_mapping = {}\n        for weak_key, weak_list in self._mapping.items():\n            strong_key = weak_key()\n            if strong_key is not None:  # Only include live references\n                strong_list = []\n                for weak_elem in weak_list:\n                    strong_elem = weak_elem()\n                    if strong_elem is not None:\n                        strong_list.append(strong_elem)\n                if strong_list:  # Only include non-empty lists\n                    strong_mapping[strong_key] = strong_list\n        return {'mapping': strong_mapping}\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling by converting strong references back to weakrefs.\"\"\"\n        # Reconstruct weakref-based mapping from strong references\n        self._mapping = {}\n        strong_mapping = state['mapping']\n        \n        # First pass: create weakref lists for each object\n        for strong_key, strong_list in strong_mapping.items():\n            weak_list = [weakref.ref(obj) for obj in strong_list]\n            self._mapping[weakref.ref(strong_key)] = weak_list\n        \n        # Second pass: ensure all weakrefs in the same group point to the same list\n        for weak_key, weak_list in list(self._mapping.items()):\n            for weak_elem in weak_list:\n                if weak_elem in self._mapping and self._mapping[weak_elem] is not weak_list:\n                    self._mapping[weak_elem] = weak_list\n",
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/figure.py lines 189-189)": "\n        # groupers to keep track of x and y labels we want to align.\n        # see self.align_xlabels and self.align_ylabels and\n        # axis._get_tick_boxes_siblings\n        self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n",
    "Location 5 (/root/hy/projects_1/matplotlib/lib/matplotlib/figure.py lines 1394-1454)": "\n    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on Axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on Axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all Axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n        \"\"\"\n        if axs is None:\n            axs = self.axes\n        axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            colspan = ax.get_subplotspec().colspan\n            pos = ax.yaxis.get_label_position()  # left or right\n            # Search through other axes for label positions that are same as\n            # this one and that share the appropriate column number.\n            # Add to a list associated with each axes of siblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.yaxis.get_label_position() == pos:\n                    colspanc = axc.get_subplotspec().colspan\n                    if (pos == 'left' and colspan.start == colspanc.start or\n                            pos == 'right' and colspan.stop == colspanc.stop):\n                        # grouper for groups of ylabels to align\n                        self._align_label_groups['y'].join(ax, axc)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/cbook.py lines 754-849)": [
      "\nclass Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]\n\n    def __getstate__(self):\n        \"\"\"Support for pickle.\"\"\"\n        # Convert weakref mapping to strong references for pickling\n        self.clean()  # Clean up dead references first\n        state = {}\n        # Create mapping from objects to their group representatives\n        obj_to_group = {}\n        for group in self._mapping.values():\n            group_objects = [ref() for ref in group if ref() is not None]\n            if group_objects:\n                # Use first object as group representative\n                representative = group_objects[0]\n                for obj in group_objects:\n                    obj_to_group[obj] = representative\n        state['obj_to_group'] = obj_to_group\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Support for unpickling.\"\"\"\n        # Reconstruct weakref mapping from strong references\n        self._mapping = {}\n        obj_to_group = state['obj_to_group']\n        \n        # Group objects by their representatives\n        groups = {}\n        for obj, representative in obj_to_group.items():\n            if representative not in groups:\n                groups[representative] = []\n            groups[representative].append(obj)\n        \n        # Recreate weakref mapping\n        for group_objects in groups.values():\n            group_refs = [weakref.ref(obj) for obj in group_objects]\n            for ref in group_refs:\n                self._mapping[ref] = group_refs\n",
      "\nclass Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]\n\n    def __getstate__(self):\n        \"\"\"Convert weakref-based mapping to strong references for pickling.\"\"\"\n        self.clean()\n        # Convert the weakref-based mapping to strong references\n        state = {}\n        for key, value_list in self._mapping.items():\n            key_obj = key()\n            if key_obj is not None:\n                # Convert list of weakrefs to list of strong references\n                value_objs = [ref() for ref in value_list if ref() is not None]\n                if value_objs:\n                    state[key_obj] = value_objs\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Reconstruct weakref-based mapping from strong references.\"\"\"\n        self._mapping = {}\n        # Group objects by their sets (values in the state dict)\n        obj_to_group = {}\n        for key_obj, value_list in state.items():\n            group_id = id(value_list)\n            for obj in value_list:\n                obj_to_group[obj] = group_id\n        \n        # Rebuild the weakref-based mapping\n        group_lists = {}\n        for obj, group_id in obj_to_group.items():\n            if group_id not in group_lists:\n                group_lists[group_id] = []\n            group_lists[group_id].append(weakref.ref(obj))\n        \n        # Set up the mapping so all weakrefs in the same group point to the same list\n        for group_list in group_lists.values():\n            for ref in group_list:\n                self._mapping[ref] = group_list\n",
      "\nclass Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling, converting weakrefs to strong references.\"\"\"\n        self.clean()\n        # Convert weakref-based mapping to strong references for pickling\n        strong_mapping = {}\n        for weak_key, weak_list in self._mapping.items():\n            strong_key = weak_key()\n            if strong_key is not None:\n                strong_list = []\n                for weak_ref in weak_list:\n                    strong_obj = weak_ref()\n                    if strong_obj is not None:\n                        strong_list.append(strong_obj)\n                if strong_list:\n                    strong_mapping[strong_key] = strong_list\n        return {'mapping': strong_mapping}\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling, converting strong references back to weakrefs.\"\"\"\n        strong_mapping = state['mapping']\n        self._mapping = {}\n        \n        # First pass: create weakref keys and lists\n        weak_lists = {}\n        for strong_key, strong_list in strong_mapping.items():\n            weak_key = weakref.ref(strong_key)\n            weak_list = [weakref.ref(obj) for obj in strong_list]\n            weak_lists[weak_key] = weak_list\n            self._mapping[weak_key] = weak_list\n        \n        # Second pass: ensure all weakrefs in each list point to the same list object\n        for weak_key, weak_list in weak_lists.items():\n            for weak_ref in weak_list:\n                self._mapping[weak_ref] = weak_list\n",
      "\nclass Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]\n\n    def __getstate__(self):\n        \"\"\"Get state for pickling, converting weakrefs to strong references.\"\"\"\n        self.clean()\n        # Convert weakref-based mapping to strong references for pickling\n        strong_mapping = {}\n        for key_ref, group_refs in self._mapping.items():\n            key_obj = key_ref()\n            if key_obj is not None:\n                group_objs = [ref() for ref in group_refs if ref() is not None]\n                if group_objs:  # Only include if we have valid objects\n                    strong_mapping[key_obj] = group_objs\n        return {'strong_mapping': strong_mapping}\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling, recreating weakref-based mapping.\"\"\"\n        strong_mapping = state['strong_mapping']\n        self._mapping = {}\n        \n        # First pass: create weakrefs for all objects\n        obj_to_ref = {}\n        for key_obj, group_objs in strong_mapping.items():\n            for obj in [key_obj] + group_objs:\n                if obj not in obj_to_ref:\n                    obj_to_ref[obj] = weakref.ref(obj)\n        \n        # Second pass: rebuild the mapping structure\n        for key_obj, group_objs in strong_mapping.items():\n            key_ref = obj_to_ref[key_obj]\n            group_refs = [obj_to_ref[obj] for obj in group_objs]\n            self._mapping[key_ref] = group_refs\n            \n            # Ensure all group members point to the same list\n            for ref in group_refs:\n                self._mapping[ref] = group_refs\n",
      "\nclass Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]\n\n    def __getstate__(self):\n        \"\"\"Prepare the object for pickling by converting weakrefs to strong refs.\"\"\"\n        self.clean()\n        # Convert weakref-based mapping to strong reference mapping for pickling\n        strong_mapping = {}\n        for key_ref, value_refs in self._mapping.items():\n            key_obj = key_ref()\n            if key_obj is not None:\n                value_objs = [ref() for ref in value_refs if ref() is not None]\n                if value_objs:  # Only include non-empty groups\n                    strong_mapping[key_obj] = value_objs\n        return {'mapping': strong_mapping}\n\n    def __setstate__(self, state):\n        \"\"\"Restore the object from pickle by recreating weakref mapping.\"\"\"\n        strong_mapping = state['mapping']\n        self._mapping = {}\n        \n        # Rebuild the weakref-based mapping structure\n        for key_obj, value_objs in strong_mapping.items():\n            # Create weakref list for this group\n            value_refs = [weakref.ref(obj) for obj in value_objs]\n            # Map each object's weakref to the same list\n            for obj in value_objs:\n                self._mapping[weakref.ref(obj)] = value_refs\n",
      "\nclass Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]\n\n    def __getstate__(self):\n        \"\"\"Convert weakrefs to strong references for pickling.\"\"\"\n        # Clean dead references before pickling\n        self.clean()\n        \n        # Convert the weakref-based mapping to strong references\n        # Store as list of groups where each group is a list of objects\n        groups = []\n        seen_ids = set()\n        \n        for group in self._mapping.values():\n            group_id = id(group)\n            if group_id not in seen_ids:\n                seen_ids.add(group_id)\n                # Convert weakrefs to strong references, filtering out None\n                objects = [ref() for ref in group if ref() is not None]\n                if objects:  # Only include non-empty groups\n                    groups.append(objects)\n        \n        return {'groups': groups}\n\n    def __setstate__(self, state):\n        \"\"\"Recreate weakref-based mapping from strong references.\"\"\"\n        self._mapping = {}\n        \n        # Recreate the mapping from the groups\n        for group_objects in state['groups']:\n            if not group_objects:\n                continue\n                \n            # Create weakrefs for all objects in this group\n            group_refs = [weakref.ref(obj) for obj in group_objects]\n            \n            # All weakrefs in the group point to the same list\n            for ref in group_refs:\n                self._mapping[ref] = group_refs\n",
      "\nclass Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]\n\n    def __getstate__(self):\n        \"\"\"Support for pickle serialization.\"\"\"\n        # Convert weakref-based mapping to strong references\n        self.clean()  # Clean up dead references first\n        state = {}\n        \n        # Track which groups we've already processed to avoid duplicates\n        processed_groups = set()\n        \n        for key, group in self._mapping.items():\n            group_id = id(group)\n            if group_id not in processed_groups:\n                # Convert all weakrefs in this group to strong references\n                strong_refs = []\n                for ref in group:\n                    obj = ref()\n                    if obj is not None:  # Only include live objects\n                        strong_refs.append(obj)\n                \n                if strong_refs:  # Only include non-empty groups\n                    # Use the first object as the representative key\n                    state[strong_refs[0]] = strong_refs\n                    processed_groups.add(group_id)\n        \n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Support for pickle deserialization.\"\"\"\n        # Reconstruct the weakref-based mapping from strong references\n        self._mapping = {}\n        \n        for representative, group_objects in state.items():\n            # Create weakref list for this group\n            weakref_group = [weakref.ref(obj) for obj in group_objects]\n            \n            # Map each object's weakref to the same group list\n            for obj in group_objects:\n                self._mapping[weakref.ref(obj)] = weakref_group\n",
      "\nclass Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]\n\n    def __getstate__(self):\n        \"\"\"Support for pickling by converting weakrefs to strong references.\"\"\"\n        # Clean up dead references before pickling\n        self.clean()\n        \n        # Convert weakref-based mapping to strong references\n        strong_mapping = {}\n        for key_ref, value_list in self._mapping.items():\n            key_obj = key_ref()\n            if key_obj is not None:\n                # Convert list of weakrefs to list of strong references\n                strong_list = []\n                for ref in value_list:\n                    obj = ref()\n                    if obj is not None:\n                        strong_list.append(obj)\n                if strong_list:\n                    strong_mapping[key_obj] = strong_list\n        \n        return {'_strong_mapping': strong_mapping}\n\n    def __setstate__(self, state):\n        \"\"\"Support for unpickling by converting strong references back to weakrefs.\"\"\"\n        strong_mapping = state['_strong_mapping']\n        \n        # Rebuild the weakref-based mapping\n        self._mapping = {}\n        \n        # Track which groups we've already processed to maintain sharing\n        processed_groups = {}\n        \n        for key_obj, strong_list in strong_mapping.items():\n            # Create weakref list for this group\n            weak_list = [weakref.ref(obj) for obj in strong_list]\n            \n            # Check if we've already created a list for this group\n            # (groups are identified by having the same set of objects)\n            group_id = tuple(id(obj) for obj in strong_list)\n            \n            if group_id in processed_groups:\n                # Reuse existing list to maintain reference sharing\n                weak_list = processed_groups[group_id]\n            else:\n                # Store this as a new group\n                processed_groups[group_id] = weak_list\n            \n            # Map the key's weakref to this list\n            self._mapping[weakref.ref(key_obj)] = weak_list\n"
    ],
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/cbook.py lines 788-789)": [
      "\ndef __init__(self, init=()):\n    self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\ndef __getstate__(self):\n    \"\"\"Convert weakrefs to strong references for pickling.\"\"\"\n    state = {}\n    for key_ref, val_refs in self._mapping.items():\n        key_obj = key_ref()\n        if key_obj is not None:\n            val_objs = [ref() for ref in val_refs if ref() is not None]\n            if val_objs:  # Only include if we have valid objects\n                state[key_obj] = val_objs\n    return state\n\ndef __setstate__(self, state):\n    \"\"\"Recreate weakrefs from strong references after unpickling.\"\"\"\n    self._mapping = {}\n    for key_obj, val_objs in state.items():\n        key_ref = weakref.ref(key_obj)\n        val_refs = [weakref.ref(obj) for obj in val_objs]\n        self._mapping[key_ref] = val_refs\n",
      "\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __getstate__(self):\n        \"\"\"Convert weakrefs to strong references for pickling.\"\"\"\n        state = {}\n        for key, value_list in self._mapping.items():\n            key_obj = key()\n            if key_obj is not None:  # Only include live objects\n                value_objs = [ref() for ref in value_list if ref() is not None]\n                if value_objs:  # Only include if we have live objects\n                    state[id(key_obj)] = (key_obj, value_objs)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Recreate weakrefs from strong references after unpickling.\"\"\"\n        self._mapping = {}\n        # Group objects by their equivalence classes\n        obj_to_group = {}\n        for key_id, (key_obj, value_objs) in state.items():\n            # Find or create the representative for this group\n            representative = None\n            for obj in value_objs:\n                if obj in obj_to_group:\n                    representative = obj_to_group[obj]\n                    break\n            \n            if representative is None:\n                representative = key_obj\n            \n            # Add all objects to the same group\n            for obj in value_objs:\n                obj_to_group[obj] = representative\n        \n        # Build the mapping with the representative as key\n        groups = {}\n        for obj, rep in obj_to_group.items():\n            if rep not in groups:\n                groups[rep] = []\n            groups[rep].append(obj)\n        \n        # Create weakref mapping\n        for rep, group_objs in groups.items():\n            rep_ref = weakref.ref(rep)\n            self._mapping[rep_ref] = [weakref.ref(obj) for obj in group_objs]\n",
      "\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __getstate__(self):\n        \"\"\"Support for pickle serialization.\"\"\"\n        # Convert weakrefs to strong references for pickling\n        state = {}\n        for key_ref, group_refs in self._mapping.items():\n            key_obj = key_ref()\n            if key_obj is not None:  # Only include live references\n                group_objs = [ref() for ref in group_refs if ref() is not None]\n                if group_objs:  # Only include non-empty groups\n                    state[id(key_obj)] = (key_obj, group_objs)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Support for pickle deserialization.\"\"\"\n        # Recreate weakref-based mapping from strong references\n        self._mapping = {}\n        obj_to_ref = {}  # Map objects to their weakrefs to avoid duplicates\n        \n        for key_obj, group_objs in state.values():\n            # Get or create weakref for key object\n            if key_obj not in obj_to_ref:\n                obj_to_ref[key_obj] = weakref.ref(key_obj)\n            key_ref = obj_to_ref[key_obj]\n            \n            # Create weakrefs for group objects\n            group_refs = []\n            for obj in group_objs:\n                if obj not in obj_to_ref:\n                    obj_to_ref[obj] = weakref.ref(obj)\n                group_refs.append(obj_to_ref[obj])\n            \n            self._mapping[key_ref] = group_refs\n",
      "\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __getstate__(self):\n        \"\"\"Convert weakrefs to strong references for pickling.\"\"\"\n        # Extract live objects from weakrefs\n        groups = []\n        for key, group in self._mapping.items():\n            live_objects = [ref() for ref in group if ref() is not None]\n            if live_objects:  # Only include groups with live objects\n                groups.append(live_objects)\n        return {'groups': groups}\n\n    def __setstate__(self, state):\n        \"\"\"Recreate weakref mapping from strong references after unpickling.\"\"\"\n        self._mapping = {}\n        for group in state['groups']:\n            if group:  # Skip empty groups\n                # Create weakrefs for all objects in this group\n                weakrefs = [weakref.ref(obj) for obj in group]\n                # Map each weakref to the complete group\n                for ref in weakrefs:\n                    self._mapping[ref] = weakrefs\n",
      "\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __getstate__(self):\n        \"\"\"Prepare the object for pickling by converting weakrefs to strong references.\"\"\"\n        # Convert weakref-based mapping to regular objects for pickling\n        state = {}\n        for key_ref, group_refs in self._mapping.items():\n            key_obj = key_ref()\n            if key_obj is not None:  # Only include live objects\n                group_objs = []\n                for ref in group_refs:\n                    obj = ref()\n                    if obj is not None:\n                        group_objs.append(obj)\n                if group_objs:  # Only include non-empty groups\n                    state[key_obj] = group_objs\n        return {'groups': state}\n\n    def __setstate__(self, state):\n        \"\"\"Restore the object after unpickling by recreating weakref mapping.\"\"\"\n        # Recreate weakref-based mapping from regular objects\n        self._mapping = {}\n        groups = state.get('groups', {})\n        for key_obj, group_objs in groups.items():\n            key_ref = weakref.ref(key_obj)\n            group_refs = [weakref.ref(obj) for obj in group_objs]\n            self._mapping[key_ref] = group_refs\n",
      "\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __getstate__(self):\n        \"\"\"Prepare state for pickling by converting weakrefs to strong references.\"\"\"\n        state = {}\n        # Convert weakref keys and values to actual objects for pickling\n        groups = []\n        for key_ref, group_refs in self._mapping.items():\n            key_obj = key_ref()\n            if key_obj is not None:\n                group_objs = [ref() for ref in group_refs if ref() is not None]\n                if group_objs:  # Only include non-empty groups\n                    groups.append(group_objs)\n        state['groups'] = groups\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickle by recreating weakref mapping.\"\"\"\n        self._mapping = {}\n        # Rebuild the weakref-based mapping from the groups\n        for group in state['groups']:\n            if group:\n                # Create weakrefs for all objects in this group\n                group_refs = [weakref.ref(obj) for obj in group]\n                # Map each object's weakref to the complete group\n                for obj_ref in group_refs:\n                    self._mapping[obj_ref] = group_refs\n",
      "\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __getstate__(self):\n        \"\"\"Prepare the object for pickling by converting weakrefs to strong references.\"\"\"\n        # Convert weakref keys and values to actual objects for pickling\n        state = {}\n        for key_ref, value_refs in self._mapping.items():\n            key_obj = key_ref()\n            if key_obj is not None:  # Only include live references\n                value_objs = [ref() for ref in value_refs if ref() is not None]\n                if value_objs:  # Only include if we have live values\n                    state[id(key_obj)] = (key_obj, value_objs)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore the object from pickled state by recreating weakrefs.\"\"\"\n        # Recreate the weakref-based mapping from the pickled objects\n        self._mapping = {}\n        for key_obj, value_objs in state.values():\n            key_ref = weakref.ref(key_obj)\n            value_refs = [weakref.ref(obj) for obj in value_objs]\n            self._mapping[key_ref] = value_refs\n",
      "\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __getstate__(self):\n        # Convert weakrefs to strong references for pickling\n        state = {}\n        for key_ref, value_refs in self._mapping.items():\n            key_obj = key_ref()\n            if key_obj is not None:\n                value_objs = [ref() for ref in value_refs if ref() is not None]\n                if value_objs:  # Only include if we have valid objects\n                    state[id(key_obj)] = (key_obj, value_objs)\n        return state\n\n    def __setstate__(self, state):\n        # Recreate weakref mapping from strong references\n        self._mapping = {}\n        # Group objects by their equivalence classes\n        obj_to_group = {}\n        for key_id, (key_obj, value_objs) in state.items():\n            # All objects in value_objs should be in the same group\n            group_objs = set(value_objs)\n            group_objs.add(key_obj)\n            \n            # Find if any of these objects are already assigned to a group\n            existing_group = None\n            for obj in group_objs:\n                if obj in obj_to_group:\n                    existing_group = obj_to_group[obj]\n                    break\n            \n            if existing_group is None:\n                # Create new group\n                group_refs = [weakref.ref(obj) for obj in group_objs]\n                for obj in group_objs:\n                    obj_to_group[obj] = group_refs\n                    self._mapping[weakref.ref(obj)] = group_refs\n            else:\n                # Merge with existing group\n                for obj in group_objs:\n                    if obj not in obj_to_group:\n                        obj_ref = weakref.ref(obj)\n                        existing_group.append(obj_ref)\n                        obj_to_group[obj] = existing_group\n                        self._mapping[obj_ref] = existing_group\n"
    ],
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/cbook.py lines 802-818)": [
      "\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def __getstate__(self):\n        \"\"\"\n        Custom pickle method to handle weakref objects.\n        Converts weakrefs to strong references for serialization.\n        \"\"\"\n        # Extract actual objects from weakrefs, grouping them by their sets\n        groups = []\n        processed_sets = set()\n        \n        for ref, ref_set in self._mapping.items():\n            if id(ref_set) in processed_sets:\n                continue\n            processed_sets.add(id(ref_set))\n            \n            # Extract all objects from this set that are still alive\n            group = []\n            for elem_ref in ref_set:\n                obj = elem_ref()\n                if obj is not None:\n                    group.append(obj)\n            \n            if group:  # Only save non-empty groups\n                groups.append(group)\n        \n        return {'groups': groups}\n\n    def __setstate__(self, state):\n        \"\"\"\n        Custom unpickle method to reconstruct weakref-based mapping.\n        Converts strong references back to weakrefs.\n        \"\"\"\n        self._mapping = {}\n        \n        # Reconstruct the mapping from the saved groups\n        for group in state['groups']:\n            if not group:\n                continue\n                \n            # Create weakrefs for all objects in this group\n            ref_set = [weakref.ref(obj) for obj in group]\n            \n            # Map each weakref to the same set\n            for ref in ref_set:\n                self._mapping[ref] = ref_set\n",
      "\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling, converting weakrefs to strong references.\"\"\"\n        # Convert weakref-based mapping to strong references for pickling\n        strong_mapping = {}\n        for weak_key, weak_list in self._mapping.items():\n            key_obj = weak_key()\n            if key_obj is not None:  # Only include live references\n                # Convert weakref list to strong reference list\n                strong_list = []\n                for weak_ref in weak_list:\n                    ref_obj = weak_ref()\n                    if ref_obj is not None:\n                        strong_list.append(ref_obj)\n                if strong_list:  # Only include non-empty sets\n                    strong_mapping[key_obj] = strong_list\n        return {'strong_mapping': strong_mapping}\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling, converting strong references back to weakrefs.\"\"\"\n        # Reconstruct weakref-based mapping from strong references\n        self._mapping = {}\n        strong_mapping = state['strong_mapping']\n        \n        # First pass: create weakref lists for each group\n        group_lists = {}\n        for key_obj, strong_list in strong_mapping.items():\n            weak_list = [weakref.ref(obj) for obj in strong_list]\n            group_lists[id(strong_list)] = weak_list\n        \n        # Second pass: map each weakref to its group's list\n        for key_obj, strong_list in strong_mapping.items():\n            group_id = id(strong_list)\n            weak_list = group_lists[group_id]\n            for obj in strong_list:\n                self._mapping[weakref.ref(obj)] = weak_list\n",
      "\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n",
      "\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            ref_arg = weakref.ref(arg)\n            set_b = mapping.get(ref_arg, [ref_arg])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n",
      "\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def __getstate__(self):\n        \"\"\"Prepare state for pickling by converting weakrefs to strong references.\"\"\"\n        # Convert weakref-based mapping to object-based mapping for pickling\n        state = {}\n        for ref_key, ref_list in self._mapping.items():\n            # Get the actual object from the weakref key\n            key_obj = ref_key()\n            if key_obj is not None:  # Only include live references\n                # Convert weakref list to object list\n                obj_list = []\n                for ref in ref_list:\n                    obj = ref()\n                    if obj is not None:\n                        obj_list.append(obj)\n                if obj_list:  # Only include non-empty lists\n                    state[key_obj] = obj_list\n        return {'mapping': state}\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickle by recreating weakref-based mapping.\"\"\"\n        self._mapping = {}\n        obj_mapping = state['mapping']\n        \n        # First pass: create weakref keys and lists\n        ref_sets = {}\n        for key_obj, obj_list in obj_mapping.items():\n            ref_list = [weakref.ref(obj) for obj in obj_list]\n            ref_sets[weakref.ref(key_obj)] = ref_list\n        \n        # Second pass: ensure all weakrefs in the same set point to the same list\n        for ref_key, ref_list in ref_sets.items():\n            self._mapping[ref_key] = ref_list\n            for ref in ref_list:\n                self._mapping[ref] = ref_list\n",
      "\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def __getstate__(self):\n        \"\"\"\n        Support for pickle serialization by converting weakrefs to strong references.\n        \"\"\"\n        # Convert weakref-based mapping to strong references for pickling\n        strong_mapping = {}\n        for weak_key, weak_set in self._mapping.items():\n            strong_key = weak_key()\n            if strong_key is not None:\n                strong_set = []\n                for weak_elem in weak_set:\n                    strong_elem = weak_elem()\n                    if strong_elem is not None:\n                        strong_set.append(strong_elem)\n                if strong_set:\n                    strong_mapping[strong_key] = strong_set\n        return {'mapping': strong_mapping}\n\n    def __setstate__(self, state):\n        \"\"\"\n        Support for pickle deserialization by recreating weakref-based mapping.\n        \"\"\"\n        # Recreate weakref-based mapping from strong references\n        self._mapping = {}\n        strong_mapping = state['mapping']\n        \n        for strong_key, strong_set in strong_mapping.items():\n            # Create weakref set for this group\n            weak_set = [weakref.ref(elem) for elem in strong_set]\n            # Map each element's weakref to the same set\n            for elem in strong_set:\n                self._mapping[weakref.ref(elem)] = weak_set\n",
      "\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling by converting weakrefs to strong references.\"\"\"\n        state = {}\n        # Convert weakref-based mapping to strong references for pickling\n        strong_mapping = {}\n        for weak_key, weak_set in self._mapping.items():\n            key_obj = weak_key()\n            if key_obj is not None:  # Only include live references\n                # Convert the set of weakrefs to a set of strong references\n                strong_set = []\n                for weak_elem in weak_set:\n                    elem_obj = weak_elem()\n                    if elem_obj is not None:\n                        strong_set.append(elem_obj)\n                if strong_set:  # Only include non-empty sets\n                    strong_mapping[key_obj] = strong_set\n        state['strong_mapping'] = strong_mapping\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling by converting strong references back to weakrefs.\"\"\"\n        self._mapping = {}\n        strong_mapping = state['strong_mapping']\n        \n        # Rebuild weakref-based mapping from strong references\n        for key_obj, strong_set in strong_mapping.items():\n            # Create weakref set for this group\n            weak_set = [weakref.ref(elem) for elem in strong_set]\n            # Map each element's weakref to the same set\n            for elem in strong_set:\n                self._mapping[weakref.ref(elem)] = weak_set\n",
      "\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            ref_arg = weakref.ref(arg)\n            set_b = mapping.get(ref_arg, [ref_arg])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n"
    ],
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/figure.py lines 189-189)": [
      "\n    def __getstate__(self):\n        \"\"\"\n        Support for pickling. Convert weakref mapping to strong references.\n        \"\"\"\n        state = self.__dict__.copy()\n        # Convert weakref mapping to regular mapping for pickling\n        mapping = {}\n        for key_ref, value_ref in self._mapping.items():\n            key = key_ref()\n            value = value_ref()\n            if key is not None and value is not None:\n                mapping[key] = value\n        state['_mapping'] = mapping\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"\n        Support for unpickling. Recreate weakref mapping from strong references.\n        \"\"\"\n        import weakref\n        # Restore the mapping with weakrefs\n        mapping = {}\n        for key, value in state['_mapping'].items():\n            mapping[weakref.ref(key)] = weakref.ref(value)\n        state['_mapping'] = mapping\n        self.__dict__.update(state)\n",
      "\n    def __getstate__(self):\n        \"\"\"\n        Support for pickle serialization.\n        \n        Convert weakref objects to strong references for pickling.\n        \"\"\"\n        # Convert weakref-based _mapping to regular dict with strong references\n        strong_mapping = {}\n        for key_ref, value_ref in self._mapping.items():\n            key_obj = key_ref()\n            value_obj = value_ref()\n            if key_obj is not None and value_obj is not None:\n                strong_mapping[key_obj] = value_obj\n        \n        return {'_mapping': strong_mapping}\n    \n    def __setstate__(self, state):\n        \"\"\"\n        Support for pickle deserialization.\n        \n        Recreate weakref-based _mapping from strong references.\n        \"\"\"\n        import weakref\n        \n        # Recreate weakref-based _mapping\n        self._mapping = {}\n        for key_obj, value_obj in state['_mapping'].items():\n            key_ref = weakref.ref(key_obj)\n            value_ref = weakref.ref(value_obj)\n            self._mapping[key_ref] = value_ref\n",
      "\n    def __getstate__(self):\n        \"\"\"\n        Support for pickle serialization.\n        Convert weakref objects to strong references for pickling.\n        \"\"\"\n        # Extract actual objects from weakrefs, filtering out dead references\n        strong_refs = {}\n        for obj_ref, group_ref in self._mapping.items():\n            obj = obj_ref()  # Get object from weakref\n            group = group_ref()  # Get group from weakref\n            if obj is not None and group is not None:\n                strong_refs[obj] = group\n        \n        return {'strong_refs': strong_refs}\n    \n    def __setstate__(self, state):\n        \"\"\"\n        Support for pickle deserialization.\n        Recreate weakref-based _mapping from strong references.\n        \"\"\"\n        import weakref\n        \n        self._mapping = {}\n        strong_refs = state['strong_refs']\n        \n        # Rebuild groups structure first\n        groups = {}\n        for obj, group in strong_refs.items():\n            if id(group) not in groups:\n                groups[id(group)] = group\n        \n        # Recreate weakref mapping\n        for obj, group in strong_refs.items():\n            obj_ref = weakref.ref(obj)\n            group_ref = weakref.ref(groups[id(group)])\n            self._mapping[obj_ref] = group_ref\n",
      "\n    def __getstate__(self):\n        \"\"\"\n        Support for pickling. Convert weakref mapping to strong references.\n        \"\"\"\n        # Convert weakref mapping to regular dict with strong references\n        strong_mapping = {}\n        for key_ref, value_ref in self._mapping.items():\n            key = key_ref()\n            value = value_ref()\n            if key is not None and value is not None:\n                strong_mapping[key] = value\n        return strong_mapping\n\n    def __setstate__(self, state):\n        \"\"\"\n        Support for unpickling. Recreate weakref mapping from strong references.\n        \"\"\"\n        import weakref\n        self._mapping = {}\n        for key, value in state.items():\n            self._mapping[weakref.ref(key)] = weakref.ref(value)\n",
      "\n        self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n",
      "\n        self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n",
      "\n        self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n",
      "\n        self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n"
    ],
    "Location 5 (/root/hy/projects_1/matplotlib/lib/matplotlib/figure.py lines 1394-1454)": [
      "\n    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on Axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on Axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all Axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n        \"\"\"\n        if axs is None:\n            axs = self.axes\n        axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            colspan = ax.get_subplotspec().colspan\n            pos = ax.yaxis.get_label_position()  # left or right\n            # Search through other axes for label positions that are same as\n            # this one and that share the appropriate column number.\n            # Add to a list associated with each axes of siblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.yaxis.get_label_position() == pos:\n                    colspanc = axc.get_subplotspec().colspan\n                    if (pos == 'left' and colspan.start == colspanc.start or\n                            pos == 'right' and colspan.stop == colspanc.stop):\n                        # grouper for groups of ylabels to align\n                        self._align_label_groups['y'].join(ax, axc)\n",
      "\n    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on Axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on Axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all Axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n        \"\"\"\n        if axs is None:\n            axs = self.axes\n        axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            colspan = ax.get_subplotspec().colspan\n            pos = ax.yaxis.get_label_position()  # left or right\n            # Search through other axes for label positions that are same as\n            # this one and that share the appropriate column number.\n            # Add to a list associated with each axes of siblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.yaxis.get_label_position() == pos:\n                    colspanc = axc.get_subplotspec().colspan\n                    if (pos == 'left' and colspan.start == colspanc.start or\n                            pos == 'right' and colspan.stop == colspanc.stop):\n                        # grouper for groups of ylabels to align\n                        self._align_label_groups['y'].join(ax, axc)\n",
      "\n    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on Axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on Axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all Axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n        \"\"\"\n        if axs is None:\n            axs = self.axes\n        axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            colspan = ax.get_subplotspec().colspan\n            pos = ax.yaxis.get_label_position()  # left or right\n            # Search through other axes for label positions that are same as\n            # this one and that share the appropriate column number.\n            # Add to a list associated with each axes of siblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.yaxis.get_label_position() == pos:\n                    colspanc = axc.get_subplotspec().colspan\n                    if (pos == 'left' and colspan.start == colspanc.start or\n                            pos == 'right' and colspan.stop == colspanc.stop):\n                        # grouper for groups of ylabels to align\n                        self._align_label_groups['y'].join(ax, axc)\n",
      "\n    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on Axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on Axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all Axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n        \"\"\"\n        if axs is None:\n            axs = self.axes\n        axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            colspan = ax.get_subplotspec().colspan\n            pos = ax.yaxis.get_label_position()  # left or right\n            # Search through other axes for label positions that are same as\n            # this one and that share the appropriate column number.\n            # Add to a list associated with each axes of siblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.yaxis.get_label_position() == pos:\n                    colspanc = axc.get_subplotspec().colspan\n                    if (pos == 'left' and colspan.start == colspanc.start or\n                            pos == 'right' and colspan.stop == colspanc.stop):\n                        # grouper for groups of ylabels to align\n                        self._align_label_groups['y'].join(ax, axc)\n",
      "\n    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on Axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on Axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all Axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n        \"\"\"\n        if axs is None:\n            axs = self.axes\n        axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            colspan = ax.get_subplotspec().colspan\n            pos = ax.yaxis.get_label_position()  # left or right\n            # Search through other axes for label positions that are same as\n            # this one and that share the appropriate column number.\n            # Add to a list associated with each axes of siblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.yaxis.get_label_position() == pos:\n                    colspanc = axc.get_subplotspec().colspan\n                    if (pos == 'left' and colspan.start == colspanc.start or\n                            pos == 'right' and colspan.stop == colspanc.stop):\n                        # grouper for groups of ylabels to align\n                        self._align_label_groups['y'].join(ax, axc)\n",
      "\n    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on Axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on Axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all Axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n        \"\"\"\n        if axs is None:\n            axs = self.axes\n        axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            colspan = ax.get_subplotspec().colspan\n            pos = ax.yaxis.get_label_position()  # left or right\n            # Search through other axes for label positions that are same as\n            # this one and that share the appropriate column number.\n            # Add to a list associated with each axes of siblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.yaxis.get_label_position() == pos:\n                    colspanc = axc.get_subplotspec().colspan\n                    if (pos == 'left' and colspan.start == colspanc.start or\n                            pos == 'right' and colspan.stop == colspanc.stop):\n                        # grouper for groups of ylabels to align\n                        self._align_label_groups['y'].join(ax, axc)\n",
      "\n    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on Axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on Axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all Axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n        \"\"\"\n        if axs is None:\n            axs = self.axes\n        axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            colspan = ax.get_subplotspec().colspan\n            pos = ax.yaxis.get_label_position()  # left or right\n            # Search through other axes for label positions that are same as\n            # this one and that share the appropriate column number.\n            # Add to a list associated with each axes of siblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.yaxis.get_label_position() == pos:\n                    colspanc = axc.get_subplotspec().colspan\n                    if (pos == 'left' and colspan.start == colspanc.start or\n                            pos == 'right' and colspan.stop == colspanc.stop):\n                        # grouper for groups of ylabels to align\n                        self._align_label_groups['y'].join(ax, axc)\n",
      "\n    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on Axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on Axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all Axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n        \"\"\"\n        if axs is None:\n            axs = self.axes\n        axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            colspan = ax.get_subplotspec().colspan\n            pos = ax.yaxis.get_label_position()  # left or right\n            # Search through other axes for label positions that are same as\n            # this one and that share the appropriate column number.\n            # Add to a list associated with each axes of siblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.yaxis.get_label_position() == pos:\n                    colspanc = axc.get_subplotspec().colspan\n                    if (pos == 'left' and colspan.start == colspanc.start or\n                            pos == 'right' and colspan.stop == colspanc.stop):\n                        # grouper for groups of ylabels to align\n                        self._align_label_groups['y'].join(ax, axc)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..e32927eca4 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -751,6 +751,7 @@ def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n         recurse(obj, obj, {}, [])\n \n \n+\n class Grouper:\n     \"\"\"\n     A disjoint-set data structure.\n@@ -846,6 +847,45 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"\n+        Prepare the object for pickling by converting weakrefs to strong references.\n+        \"\"\"\n+        # Clean up dead references before pickling\n+        self.clean()\n+        \n+        # Convert the weakref-based mapping to a picklable format\n+        # We need to preserve the disjoint-set structure\n+        picklable_groups = []\n+        processed_objects = set()\n+        \n+        for group in self._mapping.values():\n+            # Get the actual objects from weakrefs\n+            objects = [ref() for ref in group if ref() is not None]\n+            if objects and id(objects[0]) not in processed_objects:\n+                # Mark all objects in this group as processed\n+                for obj in objects:\n+                    processed_objects.add(id(obj))\n+                picklable_groups.append(objects)\n+        \n+        return {'groups': picklable_groups}\n+\n+    def __setstate__(self, state):\n+        \"\"\"\n+        Restore the object from pickled state by recreating weakrefs.\n+        \"\"\"\n+        # Initialize empty mapping\n+        self._mapping = {}\n+        \n+        # Recreate the weakref-based structure from the groups\n+        for group in state['groups']:\n+            if group:  # Skip empty groups\n+                # Create weakrefs for all objects in the group\n+                weak_refs = [weakref.ref(obj) for obj in group]\n+                # Set up the mapping so all weakrefs point to the same list\n+                for weak_ref in weak_refs:\n+                    self._mapping[weak_ref] = weak_refs\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex b4c38368bf..ba6299da9b 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -186,6 +186,7 @@ class FigureBase(Artist):\n         # groupers to keep track of x and y labels we want to align.\n         # see self.align_xlabels and self.align_ylabels and\n         # axis._get_tick_boxes_siblings\n+\n         self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n \n         self.figure = self\n@@ -1391,6 +1392,7 @@ default: %(va)s\n                     if (pos == 'top' and rowspan.start == rowspanc.start or\n                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n                         # grouper for groups of xlabels to align\n+\n                         self._align_label_groups['x'].join(ax, axc)\n \n     def align_ylabels(self, axs=None):\n",
    "variant_0": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..ceda8b6fdb 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -751,6 +751,7 @@ def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n         recurse(obj, obj, {}, [])\n \n \n+\n class Grouper:\n     \"\"\"\n     A disjoint-set data structure.\n@@ -846,6 +847,87 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"Support for pickle: convert weakrefs to strong references.\"\"\"\n+        self.clean()\n+        # Convert weakref-based mapping to strong reference based\n+        groups = []\n+        seen_groups = set()\n+        for group in self._mapping.values():\n+            group_id = id(group)\n+            if group_id not in seen_groups:\n+                seen_groups.add(group_id)\n+                # Extract objects from weakrefs, filtering out None (dead refs)\n+                objects = [ref() for ref in group if ref() is not None]\n+                if objects:  # Only include non-empty groups\n+                    groups.append(objects)\n+        return {'groups': groups}\n+\n+    def __setstate__(self, state):\n+        \"\"\"Support for pickle: recreate weakref-based mapping from strong references.\"\"\"\n+        self._mapping = {}\n+        for group in state['groups']:\n+            if group:  # Skip empty groups\n+                # Create weakrefs for all objects in the group\n+                weak_refs = [weakref.ref(obj) for obj in group]\n+                # Map each weakref to the same list of weakrefs\n+                for weak_ref in weak_refs:\n+                    self._mapping[weak_ref] = weak_refs\n+                strong_list = []\n+                for weak_elem in weak_list:\n+                    strong_elem = weak_elem()\n+                    if strong_elem is not None:\n+                        strong_list.append(strong_elem)\n+                if strong_list:  # Only include non-empty lists\n+                    strong_mapping[strong_key] = strong_list\n+        return {'mapping': strong_mapping}\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling by converting strong references back to weakrefs.\"\"\"\n+        # Reconstruct weakref-based mapping from strong references\n+        self._mapping = {}\n+        strong_mapping = state['mapping']\n+        \n+        # First pass: create weakref lists for each object\n+        for strong_key, strong_list in strong_mapping.items():\n+            weak_list = [weakref.ref(obj) for obj in strong_list]\n+            self._mapping[weakref.ref(strong_key)] = weak_list\n+        \n+        # Second pass: ensure all weakrefs in the same group point to the same list\n+        for weak_key, weak_list in list(self._mapping.items()):\n+            for weak_elem in weak_list:\n+                if weak_elem in self._mapping and self._mapping[weak_elem] is not weak_list:\n+                    self._mapping[weak_elem] = weak_list\n+\n+    def joined(self, a, b):\n+        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n+        self.clean()\n+        return (self._mapping.get(weakref.ref(a), object())\n+                is self._mapping.get(weakref.ref(b)))\n+\n+    def remove(self, a):\n+        self.clean()\n+        set_a = self._mapping.pop(weakref.ref(a), None)\n+        if set_a:\n+            set_a.remove(weakref.ref(a))\n+\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over each of the disjoint sets as a list.\n+\n+        The iterator is invalid if interleaved with calls to join().\n+        \"\"\"\n+        self.clean()\n+        unique_groups = {id(group): group for group in self._mapping.values()}\n+        for group in unique_groups.values():\n+            yield [x() for x in group]\n+\n+    def get_siblings(self, a):\n+        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n+        self.clean()\n+        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n+        return [x() for x in siblings]\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex b4c38368bf..29d2a24951 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -183,6 +183,10 @@ class FigureBase(Artist):\n         self._supxlabel = None\n         self._supylabel = None\n \n+        # groupers to keep track of x and y labels we want to align.\n+        # see self.align_xlabels and self.align_ylabels and\n+        # axis._get_tick_boxes_siblings\n+\n         # groupers to keep track of x and y labels we want to align.\n         # see self.align_xlabels and self.align_ylabels and\n         # axis._get_tick_boxes_siblings\n@@ -1391,7 +1395,6 @@ default: %(va)s\n                     if (pos == 'top' and rowspan.start == rowspanc.start or\n                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n                         # grouper for groups of xlabels to align\n-                        self._align_label_groups['x'].join(ax, axc)\n \n     def align_ylabels(self, axs=None):\n         \"\"\"\n",
    "variant_1": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..40ca1e3b6f 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -751,6 +751,7 @@ def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n         recurse(obj, obj, {}, [])\n \n \n+\n class Grouper:\n     \"\"\"\n     A disjoint-set data structure.\n@@ -846,6 +847,106 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"Support for pickle.\"\"\"\n+        # Convert weakref mapping to strong references for pickling\n+        self.clean()  # Clean up dead references first\n+        state = {}\n+        # Create mapping from objects to their group representatives\n+        obj_to_group = {}\n+        for group in self._mapping.values():\n+            group_objects = [ref() for ref in group if ref() is not None]\n+            if group_objects:\n+                # Use first object as group representative\n+                representative = group_objects[0]\n+                for obj in group_objects:\n+                    obj_to_group[obj] = representative\n+        state['obj_to_group'] = obj_to_group\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Support for unpickling.\"\"\"\n+        # Reconstruct weakref mapping from strong references\n+        self._mapping = {}\n+        obj_to_group = state['obj_to_group']\n+        \n+        # Group objects by their representatives\n+        groups = {}\n+        for obj, representative in obj_to_group.items():\n+            if representative not in groups:\n+                groups[representative] = []\n+            groups[representative].append(obj)\n+        \n+        # Recreate weakref mapping\n+        for group_objects in groups.values():\n+            group_refs = [weakref.ref(obj) for obj in group_objects]\n+            for ref in group_refs:\n+                self._mapping[ref] = group_refs\n+        for ref, ref_set in self._mapping.items():\n+            if id(ref_set) in processed_sets:\n+                continue\n+            processed_sets.add(id(ref_set))\n+            \n+            # Extract all objects from this set that are still alive\n+            group = []\n+            for elem_ref in ref_set:\n+                obj = elem_ref()\n+                if obj is not None:\n+                    group.append(obj)\n+            \n+            if group:  # Only save non-empty groups\n+                groups.append(group)\n+        \n+        return {'groups': groups}\n+\n+    def __setstate__(self, state):\n+        \"\"\"\n+        Custom unpickle method to reconstruct weakref-based mapping.\n+        Converts strong references back to weakrefs.\n+        \"\"\"\n+        self._mapping = {}\n+        \n+        # Reconstruct the mapping from the saved groups\n+        for group in state['groups']:\n+            if not group:\n+                continue\n+                \n+            # Create weakrefs for all objects in this group\n+            ref_set = [weakref.ref(obj) for obj in group]\n+            \n+            # Map each weakref to the same set\n+            for ref in ref_set:\n+                self._mapping[ref] = ref_set\n+\n+    def joined(self, a, b):\n+        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n+        self.clean()\n+        return (self._mapping.get(weakref.ref(a), object())\n+                is self._mapping.get(weakref.ref(b)))\n+\n+    def remove(self, a):\n+        self.clean()\n+        set_a = self._mapping.pop(weakref.ref(a), None)\n+        if set_a:\n+            set_a.remove(weakref.ref(a))\n+\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over each of the disjoint sets as a list.\n+\n+        The iterator is invalid if interleaved with calls to join().\n+        \"\"\"\n+        self.clean()\n+        unique_groups = {id(group): group for group in self._mapping.values()}\n+        for group in unique_groups.values():\n+            yield [x() for x in group]\n+\n+    def get_siblings(self, a):\n+        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n+        self.clean()\n+        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n+        return [x() for x in siblings]\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex b4c38368bf..2d3692f1ca 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -186,7 +186,33 @@ class FigureBase(Artist):\n         # groupers to keep track of x and y labels we want to align.\n         # see self.align_xlabels and self.align_ylabels and\n         # axis._get_tick_boxes_siblings\n-        self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n+\n+    def __getstate__(self):\n+        \"\"\"\n+        Support for pickling. Convert weakref mapping to strong references.\n+        \"\"\"\n+        state = self.__dict__.copy()\n+        # Convert weakref mapping to regular mapping for pickling\n+        mapping = {}\n+        for key_ref, value_ref in self._mapping.items():\n+            key = key_ref()\n+            value = value_ref()\n+            if key is not None and value is not None:\n+                mapping[key] = value\n+        state['_mapping'] = mapping\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"\n+        Support for unpickling. Recreate weakref mapping from strong references.\n+        \"\"\"\n+        import weakref\n+        # Restore the mapping with weakrefs\n+        mapping = {}\n+        for key, value in state['_mapping'].items():\n+            mapping[weakref.ref(key)] = weakref.ref(value)\n+        state['_mapping'] = mapping\n+        self.__dict__.update(state)\n \n         self.figure = self\n         self._localaxes = []  # track all axes\n@@ -1391,7 +1417,6 @@ default: %(va)s\n                     if (pos == 'top' and rowspan.start == rowspanc.start or\n                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n                         # grouper for groups of xlabels to align\n-                        self._align_label_groups['x'].join(ax, axc)\n \n     def align_ylabels(self, axs=None):\n         \"\"\"\n",
    "variant_2": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..9b3e3538b7 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -751,6 +751,7 @@ def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n         recurse(obj, obj, {}, [])\n \n \n+\n class Grouper:\n     \"\"\"\n     A disjoint-set data structure.\n@@ -846,6 +847,121 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"Convert weakref-based mapping to strong references for pickling.\"\"\"\n+        self.clean()\n+        # Convert the weakref-based mapping to strong references\n+        state = {}\n+        for key, value_list in self._mapping.items():\n+            key_obj = key()\n+            if key_obj is not None:\n+                # Convert list of weakrefs to list of strong references\n+                value_objs = [ref() for ref in value_list if ref() is not None]\n+                if value_objs:\n+                    state[key_obj] = value_objs\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Reconstruct weakref-based mapping from strong references.\"\"\"\n+        self._mapping = {}\n+        # Group objects by their sets (values in the state dict)\n+        obj_to_group = {}\n+        for key_obj, value_list in state.items():\n+            group_id = id(value_list)\n+            for obj in value_list:\n+                obj_to_group[obj] = group_id\n+        \n+        # Rebuild the weakref-based mapping\n+        group_lists = {}\n+        for obj, group_id in obj_to_group.items():\n+            if group_id not in group_lists:\n+                group_lists[group_id] = []\n+            group_lists[group_id].append(weakref.ref(obj))\n+        \n+        # Set up the mapping so all weakrefs in the same group point to the same list\n+        for group_list in group_lists.values():\n+            for ref in group_list:\n+                self._mapping[ref] = group_list\n+        \"\"\"\n+        mapping = self._mapping\n+        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n+\n+        for arg in args:\n+            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n+            if set_b is not set_a:\n+                if len(set_b) > len(set_a):\n+                    set_a, set_b = set_b, set_a\n+                set_a.extend(set_b)\n+                for elem in set_b:\n+                    mapping[elem] = set_a\n+\n+        self.clean()\n+\n+    def __getstate__(self):\n+        \"\"\"Return state for pickling, converting weakrefs to strong references.\"\"\"\n+        # Convert weakref-based mapping to strong references for pickling\n+        strong_mapping = {}\n+        for weak_key, weak_list in self._mapping.items():\n+            key_obj = weak_key()\n+            if key_obj is not None:  # Only include live references\n+                # Convert weakref list to strong reference list\n+                strong_list = []\n+                for weak_ref in weak_list:\n+                    ref_obj = weak_ref()\n+                    if ref_obj is not None:\n+                        strong_list.append(ref_obj)\n+                if strong_list:  # Only include non-empty sets\n+                    strong_mapping[key_obj] = strong_list\n+        return {'strong_mapping': strong_mapping}\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling, converting strong references back to weakrefs.\"\"\"\n+        # Reconstruct weakref-based mapping from strong references\n+        self._mapping = {}\n+        strong_mapping = state['strong_mapping']\n+        \n+        # First pass: create weakref lists for each group\n+        group_lists = {}\n+        for key_obj, strong_list in strong_mapping.items():\n+            weak_list = [weakref.ref(obj) for obj in strong_list]\n+            group_lists[id(strong_list)] = weak_list\n+        \n+        # Second pass: map each weakref to its group's list\n+        for key_obj, strong_list in strong_mapping.items():\n+            group_id = id(strong_list)\n+            weak_list = group_lists[group_id]\n+            for obj in strong_list:\n+                self._mapping[weakref.ref(obj)] = weak_list\n+\n+    def joined(self, a, b):\n+        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n+        self.clean()\n+        return (self._mapping.get(weakref.ref(a), object())\n+                is self._mapping.get(weakref.ref(b)))\n+\n+    def remove(self, a):\n+        self.clean()\n+        set_a = self._mapping.pop(weakref.ref(a), None)\n+        if set_a:\n+            set_a.remove(weakref.ref(a))\n+\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over each of the disjoint sets as a list.\n+\n+        The iterator is invalid if interleaved with calls to join().\n+        \"\"\"\n+        self.clean()\n+        unique_groups = {id(group): group for group in self._mapping.values()}\n+        for group in unique_groups.values():\n+            yield [x() for x in group]\n+\n+    def get_siblings(self, a):\n+        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n+        self.clean()\n+        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n+        return [x() for x in siblings]\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex b4c38368bf..8d4217a0e1 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -186,7 +186,37 @@ class FigureBase(Artist):\n         # groupers to keep track of x and y labels we want to align.\n         # see self.align_xlabels and self.align_ylabels and\n         # axis._get_tick_boxes_siblings\n-        self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n+\n+    def __getstate__(self):\n+        \"\"\"\n+        Support for pickle serialization.\n+        \n+        Convert weakref objects to strong references for pickling.\n+        \"\"\"\n+        # Convert weakref-based _mapping to regular dict with strong references\n+        strong_mapping = {}\n+        for key_ref, value_ref in self._mapping.items():\n+            key_obj = key_ref()\n+            value_obj = value_ref()\n+            if key_obj is not None and value_obj is not None:\n+                strong_mapping[key_obj] = value_obj\n+        \n+        return {'_mapping': strong_mapping}\n+    \n+    def __setstate__(self, state):\n+        \"\"\"\n+        Support for pickle deserialization.\n+        \n+        Recreate weakref-based _mapping from strong references.\n+        \"\"\"\n+        import weakref\n+        \n+        # Recreate weakref-based _mapping\n+        self._mapping = {}\n+        for key_obj, value_obj in state['_mapping'].items():\n+            key_ref = weakref.ref(key_obj)\n+            value_ref = weakref.ref(value_obj)\n+            self._mapping[key_ref] = value_ref\n \n         self.figure = self\n         self._localaxes = []  # track all axes\n@@ -1391,7 +1421,6 @@ default: %(va)s\n                     if (pos == 'top' and rowspan.start == rowspanc.start or\n                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n                         # grouper for groups of xlabels to align\n-                        self._align_label_groups['x'].join(ax, axc)\n \n     def align_ylabels(self, axs=None):\n         \"\"\"\n",
    "variant_3": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..b115147cee 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -751,6 +751,7 @@ def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n         recurse(obj, obj, {}, [])\n \n \n+\n class Grouper:\n     \"\"\"\n     A disjoint-set data structure.\n@@ -846,6 +847,74 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"Return state for pickling, converting weakrefs to strong references.\"\"\"\n+        self.clean()\n+        # Convert weakref-based mapping to strong references for pickling\n+        strong_mapping = {}\n+        for weak_key, weak_list in self._mapping.items():\n+            strong_key = weak_key()\n+            if strong_key is not None:\n+                strong_list = []\n+                for weak_ref in weak_list:\n+                    strong_obj = weak_ref()\n+                    if strong_obj is not None:\n+                        strong_list.append(strong_obj)\n+                if strong_list:\n+                    strong_mapping[strong_key] = strong_list\n+        return {'mapping': strong_mapping}\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling, converting strong references back to weakrefs.\"\"\"\n+        strong_mapping = state['mapping']\n+        self._mapping = {}\n+        \n+        # First pass: create weakref keys and lists\n+        weak_lists = {}\n+        for strong_key, strong_list in strong_mapping.items():\n+            weak_key = weakref.ref(strong_key)\n+            weak_list = [weakref.ref(obj) for obj in strong_list]\n+            weak_lists[weak_key] = weak_list\n+            self._mapping[weak_key] = weak_list\n+        \n+        # Second pass: ensure all weakrefs in each list point to the same list object\n+        for weak_key, weak_list in weak_lists.items():\n+            for weak_ref in weak_list:\n+                self._mapping[weak_ref] = weak_list\n+                for elem in set_b:\n+                    mapping[elem] = set_a\n+\n+        self.clean()\n+\n+    def joined(self, a, b):\n+        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n+        self.clean()\n+        return (self._mapping.get(weakref.ref(a), object())\n+                is self._mapping.get(weakref.ref(b)))\n+\n+    def remove(self, a):\n+        self.clean()\n+        set_a = self._mapping.pop(weakref.ref(a), None)\n+        if set_a:\n+            set_a.remove(weakref.ref(a))\n+\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over each of the disjoint sets as a list.\n+\n+        The iterator is invalid if interleaved with calls to join().\n+        \"\"\"\n+        self.clean()\n+        unique_groups = {id(group): group for group in self._mapping.values()}\n+        for group in unique_groups.values():\n+            yield [x() for x in group]\n+\n+    def get_siblings(self, a):\n+        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n+        self.clean()\n+        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n+        return [x() for x in siblings]\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex b4c38368bf..75750bf2cc 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -186,7 +186,43 @@ class FigureBase(Artist):\n         # groupers to keep track of x and y labels we want to align.\n         # see self.align_xlabels and self.align_ylabels and\n         # axis._get_tick_boxes_siblings\n-        self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n+\n+    def __getstate__(self):\n+        \"\"\"\n+        Support for pickle serialization.\n+        Convert weakref objects to strong references for pickling.\n+        \"\"\"\n+        # Extract actual objects from weakrefs, filtering out dead references\n+        strong_refs = {}\n+        for obj_ref, group_ref in self._mapping.items():\n+            obj = obj_ref()  # Get object from weakref\n+            group = group_ref()  # Get group from weakref\n+            if obj is not None and group is not None:\n+                strong_refs[obj] = group\n+        \n+        return {'strong_refs': strong_refs}\n+    \n+    def __setstate__(self, state):\n+        \"\"\"\n+        Support for pickle deserialization.\n+        Recreate weakref-based _mapping from strong references.\n+        \"\"\"\n+        import weakref\n+        \n+        self._mapping = {}\n+        strong_refs = state['strong_refs']\n+        \n+        # Rebuild groups structure first\n+        groups = {}\n+        for obj, group in strong_refs.items():\n+            if id(group) not in groups:\n+                groups[id(group)] = group\n+        \n+        # Recreate weakref mapping\n+        for obj, group in strong_refs.items():\n+            obj_ref = weakref.ref(obj)\n+            group_ref = weakref.ref(groups[id(group)])\n+            self._mapping[obj_ref] = group_ref\n \n         self.figure = self\n         self._localaxes = []  # track all axes\n@@ -1391,7 +1427,6 @@ default: %(va)s\n                     if (pos == 'top' and rowspan.start == rowspanc.start or\n                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n                         # grouper for groups of xlabels to align\n-                        self._align_label_groups['x'].join(ax, axc)\n \n     def align_ylabels(self, axs=None):\n         \"\"\"\n",
    "variant_4": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..81a95de77b 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -751,6 +751,7 @@ def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n         recurse(obj, obj, {}, [])\n \n \n+\n class Grouper:\n     \"\"\"\n     A disjoint-set data structure.\n@@ -846,6 +847,63 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"Get state for pickling, converting weakrefs to strong references.\"\"\"\n+        self.clean()\n+        # Convert weakref-based mapping to strong references for pickling\n+        strong_mapping = {}\n+        for key_ref, group_refs in self._mapping.items():\n+            key_obj = key_ref()\n+            if key_obj is not None:\n+                group_objs = [ref() for ref in group_refs if ref() is not None]\n+                if group_objs:  # Only include if we have valid objects\n+                    strong_mapping[key_obj] = group_objs\n+        return {'strong_mapping': strong_mapping}\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling, recreating weakref-based mapping.\"\"\"\n+        strong_mapping = state['strong_mapping']\n+        self._mapping = {}\n+        \n+        # First pass: create weakrefs for all objects\n+        obj_to_ref = {}\n+        for key_obj, group_objs in strong_mapping.items():\n+            for obj in [key_obj] + group_objs:\n+                if obj not in obj_to_ref:\n+                    obj_to_ref[obj] = weakref.ref(obj)\n+        \n+        # Second pass: rebuild the mapping structure\n+        for key_obj, group_objs in strong_mapping.items():\n+            key_ref = obj_to_ref[key_obj]\n+            group_refs = [obj_to_ref[obj] for obj in group_objs]\n+            self._mapping[key_ref] = group_refs\n+            \n+            # Ensure all group members point to the same list\n+            for ref in group_refs:\n+                self._mapping[ref] = group_refs\n+    def remove(self, a):\n+        self.clean()\n+        set_a = self._mapping.pop(weakref.ref(a), None)\n+        if set_a:\n+            set_a.remove(weakref.ref(a))\n+\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over each of the disjoint sets as a list.\n+\n+        The iterator is invalid if interleaved with calls to join().\n+        \"\"\"\n+        self.clean()\n+        unique_groups = {id(group): group for group in self._mapping.values()}\n+        for group in unique_groups.values():\n+            yield [x() for x in group]\n+\n+    def get_siblings(self, a):\n+        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n+        self.clean()\n+        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n+        return [x() for x in siblings]\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex b4c38368bf..34c05ca6ea 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -186,7 +186,28 @@ class FigureBase(Artist):\n         # groupers to keep track of x and y labels we want to align.\n         # see self.align_xlabels and self.align_ylabels and\n         # axis._get_tick_boxes_siblings\n-        self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n+\n+    def __getstate__(self):\n+        \"\"\"\n+        Support for pickling. Convert weakref mapping to strong references.\n+        \"\"\"\n+        # Convert weakref mapping to regular dict with strong references\n+        strong_mapping = {}\n+        for key_ref, value_ref in self._mapping.items():\n+            key = key_ref()\n+            value = value_ref()\n+            if key is not None and value is not None:\n+                strong_mapping[key] = value\n+        return strong_mapping\n+\n+    def __setstate__(self, state):\n+        \"\"\"\n+        Support for unpickling. Recreate weakref mapping from strong references.\n+        \"\"\"\n+        import weakref\n+        self._mapping = {}\n+        for key, value in state.items():\n+            self._mapping[weakref.ref(key)] = weakref.ref(value)\n \n         self.figure = self\n         self._localaxes = []  # track all axes\n@@ -1391,7 +1412,6 @@ default: %(va)s\n                     if (pos == 'top' and rowspan.start == rowspanc.start or\n                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n                         # grouper for groups of xlabels to align\n-                        self._align_label_groups['x'].join(ax, axc)\n \n     def align_ylabels(self, axs=None):\n         \"\"\"\n",
    "variant_5": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..52ad04b735 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -751,6 +751,7 @@ def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n         recurse(obj, obj, {}, [])\n \n \n+\n class Grouper:\n     \"\"\"\n     A disjoint-set data structure.\n@@ -846,6 +847,93 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"Prepare the object for pickling by converting weakrefs to strong refs.\"\"\"\n+        self.clean()\n+        # Convert weakref-based mapping to strong reference mapping for pickling\n+        strong_mapping = {}\n+        for key_ref, value_refs in self._mapping.items():\n+            key_obj = key_ref()\n+            if key_obj is not None:\n+                value_objs = [ref() for ref in value_refs if ref() is not None]\n+                if value_objs:  # Only include non-empty groups\n+                    strong_mapping[key_obj] = value_objs\n+        return {'mapping': strong_mapping}\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore the object from pickle by recreating weakref mapping.\"\"\"\n+        strong_mapping = state['mapping']\n+        self._mapping = {}\n+        \n+        # Rebuild the weakref-based mapping structure\n+        for key_obj, value_objs in strong_mapping.items():\n+            # Create weakref list for this group\n+            value_refs = [weakref.ref(obj) for obj in value_objs]\n+            # Map each object's weakref to the same list\n+            for obj in value_objs:\n+                self._mapping[weakref.ref(obj)] = value_refs\n+        # Convert weakref-based mapping to object-based mapping for pickling\n+        state = {}\n+        for ref_key, ref_list in self._mapping.items():\n+            # Get the actual object from the weakref key\n+            key_obj = ref_key()\n+            if key_obj is not None:  # Only include live references\n+                # Convert weakref list to object list\n+                obj_list = []\n+                for ref in ref_list:\n+                    obj = ref()\n+                    if obj is not None:\n+                        obj_list.append(obj)\n+                if obj_list:  # Only include non-empty lists\n+                    state[key_obj] = obj_list\n+        return {'mapping': state}\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickle by recreating weakref-based mapping.\"\"\"\n+        self._mapping = {}\n+        obj_mapping = state['mapping']\n+        \n+        # First pass: create weakref keys and lists\n+        ref_sets = {}\n+        for key_obj, obj_list in obj_mapping.items():\n+            ref_list = [weakref.ref(obj) for obj in obj_list]\n+            ref_sets[weakref.ref(key_obj)] = ref_list\n+        \n+        # Second pass: ensure all weakrefs in the same set point to the same list\n+        for ref_key, ref_list in ref_sets.items():\n+            self._mapping[ref_key] = ref_list\n+            for ref in ref_list:\n+                self._mapping[ref] = ref_list\n+\n+    def joined(self, a, b):\n+        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n+        self.clean()\n+        return (self._mapping.get(weakref.ref(a), object())\n+                is self._mapping.get(weakref.ref(b)))\n+\n+    def remove(self, a):\n+        self.clean()\n+        set_a = self._mapping.pop(weakref.ref(a), None)\n+        if set_a:\n+            set_a.remove(weakref.ref(a))\n+\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over each of the disjoint sets as a list.\n+\n+        The iterator is invalid if interleaved with calls to join().\n+        \"\"\"\n+        self.clean()\n+        unique_groups = {id(group): group for group in self._mapping.values()}\n+        for group in unique_groups.values():\n+            yield [x() for x in group]\n+\n+    def get_siblings(self, a):\n+        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n+        self.clean()\n+        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n+        return [x() for x in siblings]\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex b4c38368bf..d07ad1bac8 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -186,6 +186,7 @@ class FigureBase(Artist):\n         # groupers to keep track of x and y labels we want to align.\n         # see self.align_xlabels and self.align_ylabels and\n         # axis._get_tick_boxes_siblings\n+\n         self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n \n         self.figure = self\n@@ -1391,7 +1392,6 @@ default: %(va)s\n                     if (pos == 'top' and rowspan.start == rowspanc.start or\n                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n                         # grouper for groups of xlabels to align\n-                        self._align_label_groups['x'].join(ax, axc)\n \n     def align_ylabels(self, axs=None):\n         \"\"\"\n",
    "variant_6": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..42f47c1fd1 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -751,6 +751,7 @@ def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n         recurse(obj, obj, {}, [])\n \n \n+\n class Grouper:\n     \"\"\"\n     A disjoint-set data structure.\n@@ -846,6 +847,102 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"Convert weakrefs to strong references for pickling.\"\"\"\n+        # Clean dead references before pickling\n+        self.clean()\n+        \n+        # Convert the weakref-based mapping to strong references\n+        # Store as list of groups where each group is a list of objects\n+        groups = []\n+        seen_ids = set()\n+        \n+        for group in self._mapping.values():\n+            group_id = id(group)\n+            if group_id not in seen_ids:\n+                seen_ids.add(group_id)\n+                # Convert weakrefs to strong references, filtering out None\n+                objects = [ref() for ref in group if ref() is not None]\n+                if objects:  # Only include non-empty groups\n+                    groups.append(objects)\n+        \n+        return {'groups': groups}\n+\n+    def __setstate__(self, state):\n+        \"\"\"Recreate weakref-based mapping from strong references.\"\"\"\n+        self._mapping = {}\n+        \n+        # Recreate the mapping from the groups\n+        for group_objects in state['groups']:\n+            if not group_objects:\n+                continue\n+                \n+            # Create weakrefs for all objects in this group\n+            group_refs = [weakref.ref(obj) for obj in group_objects]\n+            \n+            # All weakrefs in the group point to the same list\n+            for ref in group_refs:\n+                self._mapping[ref] = group_refs\n+        Support for pickle serialization by converting weakrefs to strong references.\n+        \"\"\"\n+        # Convert weakref-based mapping to strong references for pickling\n+        strong_mapping = {}\n+        for weak_key, weak_set in self._mapping.items():\n+            strong_key = weak_key()\n+            if strong_key is not None:\n+                strong_set = []\n+                for weak_elem in weak_set:\n+                    strong_elem = weak_elem()\n+                    if strong_elem is not None:\n+                        strong_set.append(strong_elem)\n+                if strong_set:\n+                    strong_mapping[strong_key] = strong_set\n+        return {'mapping': strong_mapping}\n+\n+    def __setstate__(self, state):\n+        \"\"\"\n+        Support for pickle deserialization by recreating weakref-based mapping.\n+        \"\"\"\n+        # Recreate weakref-based mapping from strong references\n+        self._mapping = {}\n+        strong_mapping = state['mapping']\n+        \n+        for strong_key, strong_set in strong_mapping.items():\n+            # Create weakref set for this group\n+            weak_set = [weakref.ref(elem) for elem in strong_set]\n+            # Map each element's weakref to the same set\n+            for elem in strong_set:\n+                self._mapping[weakref.ref(elem)] = weak_set\n+\n+    def joined(self, a, b):\n+        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n+        self.clean()\n+        return (self._mapping.get(weakref.ref(a), object())\n+                is self._mapping.get(weakref.ref(b)))\n+\n+    def remove(self, a):\n+        self.clean()\n+        set_a = self._mapping.pop(weakref.ref(a), None)\n+        if set_a:\n+            set_a.remove(weakref.ref(a))\n+\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over each of the disjoint sets as a list.\n+\n+        The iterator is invalid if interleaved with calls to join().\n+        \"\"\"\n+        self.clean()\n+        unique_groups = {id(group): group for group in self._mapping.values()}\n+        for group in unique_groups.values():\n+            yield [x() for x in group]\n+\n+    def get_siblings(self, a):\n+        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n+        self.clean()\n+        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n+        return [x() for x in siblings]\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex b4c38368bf..d07ad1bac8 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -186,6 +186,7 @@ class FigureBase(Artist):\n         # groupers to keep track of x and y labels we want to align.\n         # see self.align_xlabels and self.align_ylabels and\n         # axis._get_tick_boxes_siblings\n+\n         self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n \n         self.figure = self\n@@ -1391,7 +1392,6 @@ default: %(va)s\n                     if (pos == 'top' and rowspan.start == rowspanc.start or\n                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n                         # grouper for groups of xlabels to align\n-                        self._align_label_groups['x'].join(ax, axc)\n \n     def align_ylabels(self, axs=None):\n         \"\"\"\n",
    "variant_7": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..8c5898f493 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -751,6 +751,7 @@ def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n         recurse(obj, obj, {}, [])\n \n \n+\n class Grouper:\n     \"\"\"\n     A disjoint-set data structure.\n@@ -846,6 +847,98 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"Support for pickle serialization.\"\"\"\n+        # Convert weakref-based mapping to strong references\n+        self.clean()  # Clean up dead references first\n+        state = {}\n+        \n+        # Track which groups we've already processed to avoid duplicates\n+        processed_groups = set()\n+        \n+        for key, group in self._mapping.items():\n+            group_id = id(group)\n+            if group_id not in processed_groups:\n+                # Convert all weakrefs in this group to strong references\n+                strong_refs = []\n+                for ref in group:\n+                    obj = ref()\n+                    if obj is not None:  # Only include live objects\n+                        strong_refs.append(obj)\n+                \n+                if strong_refs:  # Only include non-empty groups\n+                    # Use the first object as the representative key\n+                    state[strong_refs[0]] = strong_refs\n+                    processed_groups.add(group_id)\n+        \n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Support for pickle deserialization.\"\"\"\n+        # Reconstruct the weakref-based mapping from strong references\n+        self._mapping = {}\n+        \n+        for representative, group_objects in state.items():\n+            # Create weakref list for this group\n+            weakref_group = [weakref.ref(obj) for obj in group_objects]\n+            \n+            # Map each object's weakref to the same group list\n+            for obj in group_objects:\n+                self._mapping[weakref.ref(obj)] = weakref_group\n+            if key_obj is not None:  # Only include live references\n+                # Convert the set of weakrefs to a set of strong references\n+                strong_set = []\n+                for weak_elem in weak_set:\n+                    elem_obj = weak_elem()\n+                    if elem_obj is not None:\n+                        strong_set.append(elem_obj)\n+                if strong_set:  # Only include non-empty sets\n+                    strong_mapping[key_obj] = strong_set\n+        state['strong_mapping'] = strong_mapping\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling by converting strong references back to weakrefs.\"\"\"\n+        self._mapping = {}\n+        strong_mapping = state['strong_mapping']\n+        \n+        # Rebuild weakref-based mapping from strong references\n+        for key_obj, strong_set in strong_mapping.items():\n+            # Create weakref set for this group\n+            weak_set = [weakref.ref(elem) for elem in strong_set]\n+            # Map each element's weakref to the same set\n+            for elem in strong_set:\n+                self._mapping[weakref.ref(elem)] = weak_set\n+\n+    def joined(self, a, b):\n+        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n+        self.clean()\n+        return (self._mapping.get(weakref.ref(a), object())\n+                is self._mapping.get(weakref.ref(b)))\n+\n+    def remove(self, a):\n+        self.clean()\n+        set_a = self._mapping.pop(weakref.ref(a), None)\n+        if set_a:\n+            set_a.remove(weakref.ref(a))\n+\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over each of the disjoint sets as a list.\n+\n+        The iterator is invalid if interleaved with calls to join().\n+        \"\"\"\n+        self.clean()\n+        unique_groups = {id(group): group for group in self._mapping.values()}\n+        for group in unique_groups.values():\n+            yield [x() for x in group]\n+\n+    def get_siblings(self, a):\n+        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n+        self.clean()\n+        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n+        return [x() for x in siblings]\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex b4c38368bf..d07ad1bac8 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -186,6 +186,7 @@ class FigureBase(Artist):\n         # groupers to keep track of x and y labels we want to align.\n         # see self.align_xlabels and self.align_ylabels and\n         # axis._get_tick_boxes_siblings\n+\n         self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n \n         self.figure = self\n@@ -1391,7 +1392,6 @@ default: %(va)s\n                     if (pos == 'top' and rowspan.start == rowspanc.start or\n                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n                         # grouper for groups of xlabels to align\n-                        self._align_label_groups['x'].join(ax, axc)\n \n     def align_ylabels(self, axs=None):\n         \"\"\"\n",
    "variant_8": "diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py\nindex c9699b2e21..8e5c071fff 100644\n--- a/lib/matplotlib/cbook.py\n+++ b/lib/matplotlib/cbook.py\n@@ -751,6 +751,7 @@ def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n         recurse(obj, obj, {}, [])\n \n \n+\n class Grouper:\n     \"\"\"\n     A disjoint-set data structure.\n@@ -846,6 +847,99 @@ class Grouper:\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \n+    def __getstate__(self):\n+        \"\"\"Support for pickling by converting weakrefs to strong references.\"\"\"\n+        # Clean up dead references before pickling\n+        self.clean()\n+        \n+        # Convert weakref-based mapping to strong references\n+        strong_mapping = {}\n+        for key_ref, value_list in self._mapping.items():\n+            key_obj = key_ref()\n+            if key_obj is not None:\n+                # Convert list of weakrefs to list of strong references\n+                strong_list = []\n+                for ref in value_list:\n+                    obj = ref()\n+                    if obj is not None:\n+                        strong_list.append(obj)\n+                if strong_list:\n+                    strong_mapping[key_obj] = strong_list\n+        \n+        return {'_strong_mapping': strong_mapping}\n+\n+    def __setstate__(self, state):\n+        \"\"\"Support for unpickling by converting strong references back to weakrefs.\"\"\"\n+        strong_mapping = state['_strong_mapping']\n+        \n+        # Rebuild the weakref-based mapping\n+        self._mapping = {}\n+        \n+        # Track which groups we've already processed to maintain sharing\n+        processed_groups = {}\n+        \n+        for key_obj, strong_list in strong_mapping.items():\n+            # Create weakref list for this group\n+            weak_list = [weakref.ref(obj) for obj in strong_list]\n+            \n+            # Check if we've already created a list for this group\n+            # (groups are identified by having the same set of objects)\n+            group_id = tuple(id(obj) for obj in strong_list)\n+            \n+            if group_id in processed_groups:\n+                # Reuse existing list to maintain reference sharing\n+                weak_list = processed_groups[group_id]\n+            else:\n+                # Store this as a new group\n+                processed_groups[group_id] = weak_list\n+            \n+            # Map the key's weakref to this list\n+            self._mapping[weakref.ref(key_obj)] = weak_list\n+        \"\"\"\n+        mapping = self._mapping\n+        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n+\n+        for arg in args:\n+            ref_arg = weakref.ref(arg)\n+            set_b = mapping.get(ref_arg, [ref_arg])\n+            if set_b is not set_a:\n+                if len(set_b) > len(set_a):\n+                    set_a, set_b = set_b, set_a\n+                set_a.extend(set_b)\n+                for elem in set_b:\n+                    mapping[elem] = set_a\n+\n+        self.clean()\n+\n+    def joined(self, a, b):\n+        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n+        self.clean()\n+        return (self._mapping.get(weakref.ref(a), object())\n+                is self._mapping.get(weakref.ref(b)))\n+\n+    def remove(self, a):\n+        self.clean()\n+        set_a = self._mapping.pop(weakref.ref(a), None)\n+        if set_a:\n+            set_a.remove(weakref.ref(a))\n+\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over each of the disjoint sets as a list.\n+\n+        The iterator is invalid if interleaved with calls to join().\n+        \"\"\"\n+        self.clean()\n+        unique_groups = {id(group): group for group in self._mapping.values()}\n+        for group in unique_groups.values():\n+            yield [x() for x in group]\n+\n+    def get_siblings(self, a):\n+        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n+        self.clean()\n+        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n+        return [x() for x in siblings]\n+\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex b4c38368bf..d07ad1bac8 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -186,6 +186,7 @@ class FigureBase(Artist):\n         # groupers to keep track of x and y labels we want to align.\n         # see self.align_xlabels and self.align_ylabels and\n         # axis._get_tick_boxes_siblings\n+\n         self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n \n         self.figure = self\n@@ -1391,7 +1392,6 @@ default: %(va)s\n                     if (pos == 'top' and rowspan.start == rowspanc.start or\n                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n                         # grouper for groups of xlabels to align\n-                        self._align_label_groups['x'].join(ax, axc)\n \n     def align_ylabels(self, axs=None):\n         \"\"\"\n"
  }
}