{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/test/utils.py lines 179-184)": "\n        for alias in aliases:\n            connection = connections[alias]\n            old_names.append((connection, db_name, first_alias is None))\n\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                with time_keeper.timed(\"  Creating '%s'\" % alias):\n                    # Disable serialization if migrations are disabled\n                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n                    serialize_default = True if migrate_setting else False\n                    serialize = connection.settings_dict['TEST'].get('SERIALIZE', serialize_default)\n                    \n                    connection.creation.create_test_db(\n                        verbosity=verbosity,\n                        autoclobber=not interactive,\n                        keepdb=keepdb,\n                        serialize=serialize,\n                    )\n",
    "Location 2 (/root/hy/projects_1/django/django/db/backends/base/creation.py lines 61-61)": "\n        if self.connection.settings_dict['TEST']['MIGRATE']:\n            # We report migrate messages at one level lower than that\n            # requested. This ensures we don't get flooded with messages during\n            # testing (unless you really ask to be flooded).\n            call_command(\n                'migrate',\n                verbosity=max(verbosity - 1, 0),\n                interactive=False,\n                database=self.connection.alias,\n                run_syncdb=True,\n            )\n        else:\n            # If migrations are disabled, also disable serialization to prevent\n            # attempting to serialize from non-existent tables\n            if serialize:\n                serialize = False\n",
    "Location 3 (/root/hy/projects_1/django/django/db/backends/base/creation.py lines 78-78)": "\n        if serialize:\n            # Only serialize if migrations were run, otherwise the database is empty\n            if self.connection.settings_dict['TEST'].get('MIGRATE', True):\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                self.connection._test_serialized_contents = None\n",
    "Location 4 (/root/hy/projects_1/django/django/db/backends/base/creation.py lines 115-118)": "\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n                                continue\n",
    "Location 5 (/root/hy/projects_1/django/django/db/backends/base/creation.py lines 121-121)": "\n        # Serialize to a string\n        out = StringIO()\n        try:\n            serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        except Exception:\n            # If serialization fails (e.g., due to missing tables when MIGRATE=False),\n            # return empty string to avoid breaking test setup\n            return \"\"\n        return out.getvalue()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/test/utils.py lines 179-184)": [
      "\n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=(\n                        connection.settings_dict['TEST'].get('SERIALIZE', True) and\n                        connection.settings_dict['TEST'].get('MIGRATE', True)\n                    ),\n                )\n",
      "\n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=(\n                        connection.settings_dict['TEST'].get('SERIALIZE', True) and\n                        connection.settings_dict['TEST'].get('MIGRATE', True)\n                    ),\n                )\n",
      "\n        for db_name, aliases in test_databases.values():\n            first_alias = None\n            for alias in aliases:\n                connection = connections[alias]\n                old_names.append((connection, db_name, first_alias is None))\n\n                # Actually create the database for the first connection\n                if first_alias is None:\n                    first_alias = alias\n                    with time_keeper.timed(\"  Creating '%s'\" % alias):\n                        # Check if migrations are disabled and adjust serialization accordingly\n                        test_settings = connection.settings_dict['TEST']\n                        migrate_enabled = test_settings.get('MIGRATE', True)\n                        # If migrations are disabled, default serialization to False unless explicitly set to True\n                        if not migrate_enabled:\n                            serialize = test_settings.get('SERIALIZE', False)\n                        else:\n                            serialize = test_settings.get('SERIALIZE', True)\n                        \n                        connection.creation.create_test_db(\n                            verbosity=verbosity,\n                            autoclobber=not interactive,\n                            keepdb=keepdb,\n                            serialize=serialize,\n                        )\n",
      "\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                with time_keeper.timed(\"  Creating '%s'\" % alias):\n                    # Disable serialization when migrations are disabled\n                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n                    serialize_default = True if migrate_setting else False\n                    serialize_setting = connection.settings_dict['TEST'].get('SERIALIZE', serialize_default)\n                    \n                    connection.creation.create_test_db(\n                        verbosity=verbosity,\n                        autoclobber=not interactive,\n                        keepdb=keepdb,\n                        serialize=serialize_setting,\n                    )\n",
      "\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                with time_keeper.timed(\"  Creating '%s'\" % alias):\n                    # Disable serialization if migrations are disabled\n                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n                    serialize_default = True if migrate_setting else False\n                    connection.creation.create_test_db(\n                        verbosity=verbosity,\n                        autoclobber=not interactive,\n                        keepdb=keepdb,\n                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', serialize_default),\n                    )\n",
      "\n        for db_name, aliases in test_databases.values():\n            first_alias = None\n            for alias in aliases:\n                connection = connections[alias]\n                old_names.append((connection, db_name, first_alias is None))\n\n                # Actually create the database for the first connection\n                if first_alias is None:\n                    first_alias = alias\n                    with time_keeper.timed(\"  Creating '%s'\" % alias):\n                        # Don't serialize if migrations are disabled, as tables won't exist\n                        migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n                        serialize_setting = connection.settings_dict['TEST'].get('SERIALIZE', True)\n                        # Only serialize if both migrations are enabled and serialization is requested\n                        should_serialize = migrate_setting and serialize_setting\n                        \n                        connection.creation.create_test_db(\n                            verbosity=verbosity,\n                            autoclobber=not interactive,\n                            keepdb=keepdb,\n                            serialize=should_serialize,\n                        )\n",
      "\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                with time_keeper.timed(\"  Creating '%s'\" % alias):\n                    # Check if migrations are disabled - if so, disable serialization by default\n                    # since there won't be any tables to serialize\n                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n                    serialize_default = True if migrate_setting else False\n                    connection.creation.create_test_db(\n                        verbosity=verbosity,\n                        autoclobber=not interactive,\n                        keepdb=keepdb,\n                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', serialize_default),\n                    )\n",
      "\n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict['TEST'].get('SERIALIZE', \n                        connection.settings_dict['TEST'].get('MIGRATE', True)),\n                )\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/backends/base/creation.py lines 61-61)": [
      "\n        if self.connection.settings_dict['TEST']['MIGRATE']:\n            # We report migrate messages at one level lower than that\n            # requested. This ensures we don't get flooded with messages during\n            # testing (unless you really ask to be flooded).\n            call_command(\n                'migrate',\n                verbosity=max(verbosity - 1, 0),\n                interactive=False,\n                database=self.connection.alias,\n                run_syncdb=True,\n            )\n        else:\n            # If migrations are disabled, also disable serialization to prevent\n            # attempting to serialize an empty database with no tables\n            if serialize and 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n                serialize = False\n",
      "\n        if self.connection.settings_dict['TEST']['MIGRATE']:\n            # We report migrate messages at one level lower than that\n            # requested. This ensures we don't get flooded with messages during\n            # testing (unless you really ask to be flooded).\n            call_command(\n                'migrate',\n                verbosity=max(verbosity - 1, 0),\n                interactive=False,\n                database=self.connection.alias,\n                run_syncdb=True,\n            )\n        else:\n            # If migrations are disabled, also disable serialization by default\n            # since there won't be any tables to serialize\n            if 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n                self.connection.settings_dict['TEST']['SERIALIZE'] = False\n",
      "\n        if self.connection.settings_dict['TEST']['MIGRATE']:\n            # We report migrate messages at one level lower than that\n            # requested. This ensures we don't get flooded with messages during\n            # testing (unless you really ask to be flooded).\n            call_command(\n                'migrate',\n                verbosity=max(verbosity - 1, 0),\n                interactive=False,\n                database=self.connection.alias,\n                run_syncdb=True,\n            )\n        else:\n            # If migrations are disabled, also disable serialization to prevent\n            # attempting to serialize from non-existent tables\n            if serialize and self.connection.settings_dict['TEST'].get('SERIALIZE', True):\n                if verbosity >= 2:\n                    print(\"Disabling serialization because migrations are disabled.\")\n                serialize = False\n",
      "\n        if self.connection.settings_dict['TEST']['MIGRATE']:\n            # We report migrate messages at one level lower than that\n            # requested. This ensures we don't get flooded with messages during\n            # testing (unless you really ask to be flooded).\n            call_command(\n                'migrate',\n                verbosity=max(verbosity - 1, 0),\n                interactive=False,\n                database=self.connection.alias,\n                run_syncdb=True,\n            )\n        else:\n            # If migrations are disabled, also disable serialization by default\n            # to prevent attempting to serialize an empty database\n            if 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n                self.connection.settings_dict['TEST']['SERIALIZE'] = False\n",
      "\n        if self.connection.settings_dict['TEST']['MIGRATE']:\n            # We report migrate messages at one level lower than that\n            # requested. This ensures we don't get flooded with messages during\n            # testing (unless you really ask to be flooded).\n            call_command(\n                'migrate',\n                verbosity=max(verbosity - 1, 0),\n                interactive=False,\n                database=self.connection.alias,\n                run_syncdb=True,\n            )\n        else:\n            # When migrations are disabled, also disable serialization by default\n            # to prevent attempting to serialize an empty database\n            if 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n                self.connection.settings_dict['TEST']['SERIALIZE'] = False\n",
      "\n        if self.connection.settings_dict['TEST']['MIGRATE']:\n            # We report migrate messages at one level lower than that\n            # requested. This ensures we don't get flooded with messages during\n            # testing (unless you really ask to be flooded).\n            call_command(\n                'migrate',\n                verbosity=max(verbosity - 1, 0),\n                interactive=False,\n                database=self.connection.alias,\n                run_syncdb=True,\n            )\n        else:\n            # If migrations are disabled, also disable serialization by default\n            # to prevent attempting to serialize an empty database\n            if 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n                self.connection.settings_dict['TEST']['SERIALIZE'] = False\n",
      "\n        if self.connection.settings_dict['TEST']['MIGRATE']:\n            # We report migrate messages at one level lower than that\n            # requested. This ensures we don't get flooded with messages during\n            # testing (unless you really ask to be flooded).\n            call_command(\n                'migrate',\n                verbosity=max(verbosity - 1, 0),\n                interactive=False,\n                database=self.connection.alias,\n                run_syncdb=True,\n            )\n        else:\n            # If migrations are disabled, also disable serialization to prevent\n            # attempting to serialize an empty database with no tables\n            if serialize:\n                serialize = False\n",
      "\n        if self.connection.settings_dict['TEST']['MIGRATE']:\n            # We report migrate messages at one level lower than that\n            # requested. This ensures we don't get flooded with messages during\n            # testing (unless you really ask to be flooded).\n            call_command(\n                'migrate',\n                verbosity=max(verbosity - 1, 0),\n                interactive=False,\n                database=self.connection.alias,\n                run_syncdb=True,\n            )\n        else:\n            # If migrations are disabled, also disable serialization by default\n            # to prevent attempting to serialize an empty database\n            if 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n                self.connection.settings_dict['TEST']['SERIALIZE'] = False\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/backends/base/creation.py lines 78-78)": [
      "\n        if serialize:\n            # Only serialize if migrations have been run or tables exist\n            # When MIGRATE is False, the database is empty and serialization will fail\n            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                self.connection._test_serialized_contents = None\n",
      "\n        if serialize:\n            # Only serialize if migrations have been run, as serialization requires database tables to exist\n            if self.connection.settings_dict['TEST'].get('MIGRATE', True):\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                # Skip serialization when migrations are disabled to avoid querying non-existent tables\n                self.connection._test_serialized_contents = None\n",
      "\n        # We then serialize the current state of the database into a string\n        # and store it on the connection. This slightly horrific process is so people\n        # who are testing on databases without transactions or who are using\n        # a TransactionTestCase still get a clean database on every test run.\n        if serialize:\n            # Only serialize if migrations were run, otherwise tables may not exist\n            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                self.connection._test_serialized_contents = None\n",
      "\n        if serialize:\n            # Only serialize if we have actual database content to serialize\n            # When MIGRATE is False, tables may not exist, making serialization pointless\n            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                self.connection._test_serialized_contents = None\n",
      "\n        if serialize:\n            # Only serialize if we have a proper database structure\n            # Skip serialization when migrations are disabled to avoid querying non-existent tables\n            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                self.connection._test_serialized_contents = None\n",
      "\n        if serialize:\n            # Only serialize if migrations have been run, otherwise tables may not exist\n            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                self.connection._test_serialized_contents = None\n",
      "\n        if serialize:\n            # Only serialize if migrations were run, otherwise tables may not exist\n            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                self.connection._test_serialized_contents = None\n",
      "\n        if serialize:\n            # Only serialize if migrations have been run, otherwise tables may not exist\n            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                self.connection._test_serialized_contents = None\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/backends/base/creation.py lines 115-118)": [
      "\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n                                continue\n",
      "\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n                                continue\n",
      "\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n                                continue\n",
      "\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n                                continue\n",
      "\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n                                continue\n",
      "\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n                                continue\n",
      "\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n                                continue\n",
      "\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n                                continue\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/backends/base/creation.py lines 121-121)": [
      "\n        # Serialize to a string\n        out = StringIO()\n        try:\n            serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        except Exception:\n            # If serialization fails (e.g., due to missing tables when MIGRATE=False),\n            # return empty serialization rather than crashing\n            return \"\"\n        return out.getvalue()\n",
      "\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n",
      "\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n",
      "\n        # Serialize to a string\n        out = StringIO()\n        try:\n            serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        except Exception:\n            # If serialization fails (e.g., due to missing tables when MIGRATE=False),\n            # return empty string to avoid breaking test setup\n            return \"\"\n        return out.getvalue()\n",
      "\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n",
      "\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n",
      "\n        # Serialize to a string\n        out = StringIO()\n        try:\n            serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        except Exception:\n            # If serialization fails (e.g., tables don't exist when MIGRATE=False),\n            # return empty string instead of crashing\n            return \"\"\n        return out.getvalue()\n",
      "\n        # Check if serialization should proceed - don't serialize empty databases\n        migrate_enabled = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n        if not migrate_enabled:\n            # Skip serialization when migrations are disabled since tables won't exist\n            return ''\n        \n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..8c9bcaa682 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -75,6 +76,7 @@ class BaseDatabaseCreation:\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n+\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n@@ -112,12 +114,14 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n+\n                             queryset = model._default_manager.using(\n                                 self.connection.alias,\n                             ).order_by(model._meta.pk.name)\n                             yield from queryset.iterator()\n         # Serialize to a string\n         out = StringIO()\n+\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n \ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..c49c34005e 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,15 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n+                    # When MIGRATE is False, there are no tables to serialize, so default serialize to False\n+                    migrate_enabled = connection.settings_dict['TEST'].get('MIGRATE', True)\n+                    serialize_default = True if migrate_enabled else False\n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', serialize_default),\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_0": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..425b6d5f15 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -69,13 +70,34 @@ class BaseDatabaseCreation:\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # If migrations are disabled, also disable serialization to prevent\n+            # attempting to serialize from non-existent tables\n+            if serialize:\n+                serialize = False\n+            # We report migrate messages at one level lower than that\n+            # requested. This ensures we don't get flooded with messages during\n+            # testing (unless you really ask to be flooded).\n+            call_command(\n+                'migrate',\n+                verbosity=max(verbosity - 1, 0),\n+                interactive=False,\n+                database=self.connection.alias,\n+                run_syncdb=True,\n+            )\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        if serialize:\n+            # Only serialize if migrations were run, otherwise the database is empty\n+            if self.connection.settings_dict['TEST'].get('MIGRATE', True):\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -112,13 +134,37 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+\n+                if (\n+                    app_config.models_module is not None and\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n-        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+\n+        # Serialize to a string\n+        out = StringIO()\n+        try:\n+            serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        except Exception:\n+            # If serialization fails (e.g., due to missing tables when MIGRATE=False),\n+            # return empty string to avoid breaking test setup\n+            return \"\"\n+        return out.getvalue()\n         return out.getvalue()\n \n     def deserialize_db_from_string(self, data):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..3fd60957df 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,25 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n+        for alias in aliases:\n+            connection = connections[alias]\n+            old_names.append((connection, db_name, first_alias is None))\n+\n+            # Actually create the database for the first connection\n+            if first_alias is None:\n+                first_alias = alias\n+                with time_keeper.timed(\"  Creating '%s'\" % alias):\n+                    # Disable serialization if migrations are disabled\n+                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n+                    serialize_default = True if migrate_setting else False\n+                    serialize = connection.settings_dict['TEST'].get('SERIALIZE', serialize_default)\n+                    \n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=serialize,\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_1": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..68c6e138b2 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -69,13 +70,36 @@ class BaseDatabaseCreation:\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # If migrations are disabled, also disable serialization to prevent\n+            # attempting to serialize an empty database with no tables\n+            if serialize and 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n+                serialize = False\n+            # We report migrate messages at one level lower than that\n+            # requested. This ensures we don't get flooded with messages during\n+            # testing (unless you really ask to be flooded).\n+            call_command(\n+                'migrate',\n+                verbosity=max(verbosity - 1, 0),\n+                interactive=False,\n+                database=self.connection.alias,\n+                run_syncdb=True,\n+            )\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        if serialize:\n+            # Only serialize if migrations have been run or tables exist\n+            # When MIGRATE is False, the database is empty and serialization will fail\n+            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -112,13 +136,37 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+\n+                if (\n+                    app_config.models_module is not None and\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n-        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+\n+        # Serialize to a string\n+        out = StringIO()\n+        try:\n+            serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        except Exception:\n+            # If serialization fails (e.g., due to missing tables when MIGRATE=False),\n+            # return empty serialization rather than crashing\n+            return \"\"\n+        return out.getvalue()\n         return out.getvalue()\n \n     def deserialize_db_from_string(self, data):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..dbae272f0d 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,12 +176,16 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n-                    connection.creation.create_test_db(\n-                        verbosity=verbosity,\n-                        autoclobber=not interactive,\n-                        keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n-                    )\n+\n+                connection.creation.create_test_db(\n+                    verbosity=verbosity,\n+                    autoclobber=not interactive,\n+                    keepdb=keepdb,\n+                    serialize=(\n+                        connection.settings_dict['TEST'].get('SERIALIZE', True) and\n+                        connection.settings_dict['TEST'].get('MIGRATE', True)\n+                    ),\n+                )\n                 if parallel > 1:\n                     for index in range(parallel):\n                         with time_keeper.timed(\"  Cloning '%s'\" % alias):\n",
    "variant_2": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..3314ee3f31 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -69,13 +70,35 @@ class BaseDatabaseCreation:\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # If migrations are disabled, also disable serialization by default\n+            # since there won't be any tables to serialize\n+            if 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n+                self.connection.settings_dict['TEST']['SERIALIZE'] = False\n+            # We report migrate messages at one level lower than that\n+            # requested. This ensures we don't get flooded with messages during\n+            # testing (unless you really ask to be flooded).\n+            call_command(\n+                'migrate',\n+                verbosity=max(verbosity - 1, 0),\n+                interactive=False,\n+                database=self.connection.alias,\n+                run_syncdb=True,\n+            )\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        if serialize:\n+            # Only serialize if migrations have been run, as serialization requires database tables to exist\n+            if self.connection.settings_dict['TEST'].get('MIGRATE', True):\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                # Skip serialization when migrations are disabled to avoid querying non-existent tables\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -112,12 +135,28 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+\n+                if (\n+                    app_config.models_module is not None and\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n+\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n \ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..dbae272f0d 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,12 +176,16 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n-                    connection.creation.create_test_db(\n-                        verbosity=verbosity,\n-                        autoclobber=not interactive,\n-                        keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n-                    )\n+\n+                connection.creation.create_test_db(\n+                    verbosity=verbosity,\n+                    autoclobber=not interactive,\n+                    keepdb=keepdb,\n+                    serialize=(\n+                        connection.settings_dict['TEST'].get('SERIALIZE', True) and\n+                        connection.settings_dict['TEST'].get('MIGRATE', True)\n+                    ),\n+                )\n                 if parallel > 1:\n                     for index in range(parallel):\n                         with time_keeper.timed(\"  Cloning '%s'\" % alias):\n",
    "variant_3": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..f0432867cd 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -69,13 +70,41 @@ class BaseDatabaseCreation:\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # If migrations are disabled, also disable serialization to prevent\n+            # attempting to serialize from non-existent tables\n+            if serialize and self.connection.settings_dict['TEST'].get('SERIALIZE', True):\n+                if verbosity >= 2:\n+                    print(\"Disabling serialization because migrations are disabled.\")\n+                serialize = False\n+            # We report migrate messages at one level lower than that\n+            # requested. This ensures we don't get flooded with messages during\n+            # testing (unless you really ask to be flooded).\n+            call_command(\n+                'migrate',\n+                verbosity=max(verbosity - 1, 0),\n+                interactive=False,\n+                database=self.connection.alias,\n+                run_syncdb=True,\n+            )\n+\n+        # We then serialize the current state of the database into a string\n+        # and store it on the connection. This slightly horrific process is so people\n+        # who are testing on databases without transactions or who are using\n+        # a TransactionTestCase still get a clean database on every test run.\n+        if serialize:\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            # Only serialize if migrations were run, otherwise tables may not exist\n+            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -112,12 +141,28 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+\n+                if (\n+                    app_config.models_module is not None and\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n+\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n \ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..984ed27f12 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,12 +176,32 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n-                    connection.creation.create_test_db(\n-                        verbosity=verbosity,\n-                        autoclobber=not interactive,\n-                        keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n-                    )\n+\n+        for db_name, aliases in test_databases.values():\n+            first_alias = None\n+            for alias in aliases:\n+                connection = connections[alias]\n+                old_names.append((connection, db_name, first_alias is None))\n+\n+                # Actually create the database for the first connection\n+                if first_alias is None:\n+                    first_alias = alias\n+                    with time_keeper.timed(\"  Creating '%s'\" % alias):\n+                        # Check if migrations are disabled and adjust serialization accordingly\n+                        test_settings = connection.settings_dict['TEST']\n+                        migrate_enabled = test_settings.get('MIGRATE', True)\n+                        # If migrations are disabled, default serialization to False unless explicitly set to True\n+                        if not migrate_enabled:\n+                            serialize = test_settings.get('SERIALIZE', False)\n+                        else:\n+                            serialize = test_settings.get('SERIALIZE', True)\n+                        \n+                        connection.creation.create_test_db(\n+                            verbosity=verbosity,\n+                            autoclobber=not interactive,\n+                            keepdb=keepdb,\n+                            serialize=serialize,\n+                        )\n                 if parallel > 1:\n                     for index in range(parallel):\n                         with time_keeper.timed(\"  Cloning '%s'\" % alias):\n",
    "variant_4": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..a904b7b243 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -69,13 +70,36 @@ class BaseDatabaseCreation:\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # If migrations are disabled, also disable serialization by default\n+            # to prevent attempting to serialize an empty database\n+            if 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n+                self.connection.settings_dict['TEST']['SERIALIZE'] = False\n+            # We report migrate messages at one level lower than that\n+            # requested. This ensures we don't get flooded with messages during\n+            # testing (unless you really ask to be flooded).\n+            call_command(\n+                'migrate',\n+                verbosity=max(verbosity - 1, 0),\n+                interactive=False,\n+                database=self.connection.alias,\n+                run_syncdb=True,\n+            )\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        if serialize:\n+            # Only serialize if we have actual database content to serialize\n+            # When MIGRATE is False, tables may not exist, making serialization pointless\n+            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -112,13 +136,37 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+\n+                if (\n+                    app_config.models_module is not None and\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n-        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+\n+        # Serialize to a string\n+        out = StringIO()\n+        try:\n+            serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        except Exception:\n+            # If serialization fails (e.g., due to missing tables when MIGRATE=False),\n+            # return empty string to avoid breaking test setup\n+            return \"\"\n+        return out.getvalue()\n         return out.getvalue()\n \n     def deserialize_db_from_string(self, data):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..ab10ebe3e0 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,21 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n+            # Actually create the database for the first connection\n+            if first_alias is None:\n+                first_alias = alias\n+                with time_keeper.timed(\"  Creating '%s'\" % alias):\n+                    # Disable serialization when migrations are disabled\n+                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n+                    serialize_default = True if migrate_setting else False\n+                    serialize_setting = connection.settings_dict['TEST'].get('SERIALIZE', serialize_default)\n+                    \n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=serialize_setting,\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_5": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..c6c4dfe391 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -69,13 +70,36 @@ class BaseDatabaseCreation:\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # When migrations are disabled, also disable serialization by default\n+            # to prevent attempting to serialize an empty database\n+            if 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n+                self.connection.settings_dict['TEST']['SERIALIZE'] = False\n+            # We report migrate messages at one level lower than that\n+            # requested. This ensures we don't get flooded with messages during\n+            # testing (unless you really ask to be flooded).\n+            call_command(\n+                'migrate',\n+                verbosity=max(verbosity - 1, 0),\n+                interactive=False,\n+                database=self.connection.alias,\n+                run_syncdb=True,\n+            )\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        if serialize:\n+            # Only serialize if we have a proper database structure\n+            # Skip serialization when migrations are disabled to avoid querying non-existent tables\n+            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -112,12 +136,28 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+\n+                if (\n+                    app_config.models_module is not None and\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n+\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n \ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..8efbb146c9 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,19 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n+            # Actually create the database for the first connection\n+            if first_alias is None:\n+                first_alias = alias\n+                with time_keeper.timed(\"  Creating '%s'\" % alias):\n+                    # Disable serialization if migrations are disabled\n+                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n+                    serialize_default = True if migrate_setting else False\n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', serialize_default),\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_6": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..634c42f254 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -69,13 +70,35 @@ class BaseDatabaseCreation:\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # If migrations are disabled, also disable serialization by default\n+            # to prevent attempting to serialize an empty database\n+            if 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n+                self.connection.settings_dict['TEST']['SERIALIZE'] = False\n+            # We report migrate messages at one level lower than that\n+            # requested. This ensures we don't get flooded with messages during\n+            # testing (unless you really ask to be flooded).\n+            call_command(\n+                'migrate',\n+                verbosity=max(verbosity - 1, 0),\n+                interactive=False,\n+                database=self.connection.alias,\n+                run_syncdb=True,\n+            )\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        if serialize:\n+            # Only serialize if migrations have been run, otherwise tables may not exist\n+            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -112,12 +135,28 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+\n+                if (\n+                    app_config.models_module is not None and\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n+\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n \ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..a9f3e0935b 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,12 +176,29 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n-                    connection.creation.create_test_db(\n-                        verbosity=verbosity,\n-                        autoclobber=not interactive,\n-                        keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n-                    )\n+\n+        for db_name, aliases in test_databases.values():\n+            first_alias = None\n+            for alias in aliases:\n+                connection = connections[alias]\n+                old_names.append((connection, db_name, first_alias is None))\n+\n+                # Actually create the database for the first connection\n+                if first_alias is None:\n+                    first_alias = alias\n+                    with time_keeper.timed(\"  Creating '%s'\" % alias):\n+                        # Don't serialize if migrations are disabled, as tables won't exist\n+                        migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n+                        serialize_setting = connection.settings_dict['TEST'].get('SERIALIZE', True)\n+                        # Only serialize if both migrations are enabled and serialization is requested\n+                        should_serialize = migrate_setting and serialize_setting\n+                        \n+                        connection.creation.create_test_db(\n+                            verbosity=verbosity,\n+                            autoclobber=not interactive,\n+                            keepdb=keepdb,\n+                            serialize=should_serialize,\n+                        )\n                 if parallel > 1:\n                     for index in range(parallel):\n                         with time_keeper.timed(\"  Cloning '%s'\" % alias):\n",
    "variant_7": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..5873625385 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -69,13 +70,35 @@ class BaseDatabaseCreation:\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # If migrations are disabled, also disable serialization to prevent\n+            # attempting to serialize an empty database with no tables\n+            if serialize:\n+                serialize = False\n+            # We report migrate messages at one level lower than that\n+            # requested. This ensures we don't get flooded with messages during\n+            # testing (unless you really ask to be flooded).\n+            call_command(\n+                'migrate',\n+                verbosity=max(verbosity - 1, 0),\n+                interactive=False,\n+                database=self.connection.alias,\n+                run_syncdb=True,\n+            )\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        if serialize:\n+            # Only serialize if migrations were run, otherwise tables may not exist\n+            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -112,13 +135,37 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+\n+                if (\n+                    app_config.models_module is not None and\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n-        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+\n+        # Serialize to a string\n+        out = StringIO()\n+        try:\n+            serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        except Exception:\n+            # If serialization fails (e.g., tables don't exist when MIGRATE=False),\n+            # return empty string instead of crashing\n+            return \"\"\n+        return out.getvalue()\n         return out.getvalue()\n \n     def deserialize_db_from_string(self, data):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..5ccab7137c 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,20 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n+            # Actually create the database for the first connection\n+            if first_alias is None:\n+                first_alias = alias\n+                with time_keeper.timed(\"  Creating '%s'\" % alias):\n+                    # Check if migrations are disabled - if so, disable serialization by default\n+                    # since there won't be any tables to serialize\n+                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n+                    serialize_default = True if migrate_setting else False\n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', serialize_default),\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_8": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..d78ac54c10 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -69,13 +70,35 @@ class BaseDatabaseCreation:\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        else:\n+            # If migrations are disabled, also disable serialization by default\n+            # to prevent attempting to serialize an empty database\n+            if 'SERIALIZE' not in self.connection.settings_dict['TEST']:\n+                self.connection.settings_dict['TEST']['SERIALIZE'] = False\n+            # We report migrate messages at one level lower than that\n+            # requested. This ensures we don't get flooded with messages during\n+            # testing (unless you really ask to be flooded).\n+            call_command(\n+                'migrate',\n+                verbosity=max(verbosity - 1, 0),\n+                interactive=False,\n+                database=self.connection.alias,\n+                run_syncdb=True,\n+            )\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        if serialize:\n+            # Only serialize if migrations have been run, otherwise tables may not exist\n+            migrate_setting = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -112,12 +135,34 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+\n+                if (\n+                    app_config.models_module is not None and\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when migrations are disabled)\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n+\n+        # Check if serialization should proceed - don't serialize empty databases\n+        migrate_enabled = self.connection.settings_dict['TEST'].get('MIGRATE', True)\n+        if not migrate_enabled:\n+            # Skip serialization when migrations are disabled since tables won't exist\n+            return ''\n+        \n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n \ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..baa8404164 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,12 +176,14 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n-                    connection.creation.create_test_db(\n-                        verbosity=verbosity,\n-                        autoclobber=not interactive,\n-                        keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n-                    )\n+\n+                connection.creation.create_test_db(\n+                    verbosity=verbosity,\n+                    autoclobber=not interactive,\n+                    keepdb=keepdb,\n+                    serialize=connection.settings_dict['TEST'].get('SERIALIZE', \n+                        connection.settings_dict['TEST'].get('MIGRATE', True)),\n+                )\n                 if parallel > 1:\n                     for index in range(parallel):\n                         with time_keeper.timed(\"  Cloning '%s'\" % alias):\n"
  }
}