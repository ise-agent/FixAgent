{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 1720-1725)": "\n        def autoscale_None(self, A):\n            # i.e. A[np.isfinite(...)], but also for non-array A's\n            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n            if in_trf_domain.size == 0:\n                # Instead of passing masked data, handle the edge case properly\n                # If vmin/vmax are already set and valid, don't override them\n                if self.vmin is not None and self.vmax is not None:\n                    return  # Don't autoscale if both bounds are already set\n                # Otherwise, provide reasonable defaults for log scale\n                if self.vmin is None:\n                    self.vmin = 1e-10  # Small positive value for log scale\n                if self.vmax is None:\n                    self.vmax = 1.0\n                return\n            return super().autoscale_None(in_trf_domain)\n",
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 1694-1697)": "\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n                               f\"For LogNorm, both values must be positive.\")\n",
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 1682-1690)": "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 1720-1725)": [
      "\n        def autoscale_None(self, A):\n            # i.e. A[np.isfinite(...)], but also for non-array A's\n            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n            if in_trf_domain.size == 0:\n                # Instead of passing masked data, handle the edge case properly\n                # If vmin/vmax are already set and valid, don't override them\n                if self.vmin is not None and self.vmax is not None:\n                    return  # Don't autoscale if both bounds are already set\n                # Otherwise, provide reasonable defaults for log scale\n                if self.vmin is None:\n                    self.vmin = 1e-10  # Small positive value for log scale\n                if self.vmax is None:\n                    self.vmax = 1.0\n                return\n            return super().autoscale_None(in_trf_domain)\n",
      "\n        def autoscale_None(self, A):\n            # i.e. A[np.isfinite(...)], but also for non-array A's\n            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n            if in_trf_domain.size == 0:\n                # Instead of passing masked data, handle the edge case properly\n                # If vmin/vmax are already set and valid, don't override them\n                if self.vmin is not None and self.vmax is not None:\n                    return  # Don't autoscale if both bounds are already set\n                # Otherwise, provide reasonable defaults for log scale\n                if self.vmin is None:\n                    self.vmin = 1e-10  # Small positive value for log scale\n                if self.vmax is None:\n                    self.vmax = 1.0\n                return\n            return super().autoscale_None(in_trf_domain)\n",
      "\n        def autoscale_None(self, A):\n            # i.e. A[np.isfinite(...)], but also for non-array A's\n            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n            if in_trf_domain.size == 0:\n                # Instead of passing masked data, handle the edge case properly\n                # If vmin/vmax are already set and valid, don't override them\n                if self.vmin is not None and self.vmax is not None:\n                    return  # Don't autoscale if both bounds are already set\n                # Otherwise, provide reasonable defaults for log scale\n                if self.vmin is None:\n                    self.vmin = 1e-10  # Small positive value for log scale\n                if self.vmax is None:\n                    self.vmax = 1.0\n                return\n            return super().autoscale_None(in_trf_domain)\n",
      "\n        def autoscale_None(self, A):\n            # i.e. A[np.isfinite(...)], but also for non-array A's\n            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n            if in_trf_domain.size == 0:\n                # Instead of passing masked data, handle the edge case properly\n                # If vmin/vmax are already set and valid, don't override them\n                if self.vmin is not None and self.vmax is not None:\n                    return  # Don't autoscale if both bounds are already set\n                # Otherwise, provide reasonable defaults for log scale\n                if self.vmin is None:\n                    self.vmin = 1e-10  # Small positive value for log scale\n                if self.vmax is None:\n                    self.vmax = 1.0\n                return\n            return super().autoscale_None(in_trf_domain)\n",
      "\n        def autoscale_None(self, A):\n            # i.e. A[np.isfinite(...)], but also for non-array A's\n            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n            if in_trf_domain.size == 0:\n                # Instead of passing masked data, handle the edge case properly\n                # If vmin/vmax are already set and valid, don't override them\n                if self.vmin is not None and self.vmax is not None:\n                    return  # Don't autoscale if both bounds are already set\n                # Otherwise, provide reasonable defaults for log scale\n                if self.vmin is None:\n                    self.vmin = 1e-10  # Small positive value for log scale\n                if self.vmax is None:\n                    self.vmax = 1.0\n                return\n            return super().autoscale_None(in_trf_domain)\n",
      "\n        def autoscale_None(self, A):\n            # i.e. A[np.isfinite(...)], but also for non-array A's\n            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n            if in_trf_domain.size == 0:\n                # Instead of passing masked data, handle the edge case properly\n                # If vmin/vmax are already set and valid, don't override them\n                if self.vmin is not None and self.vmax is not None:\n                    return  # Don't autoscale if both bounds are already set\n                # Otherwise, provide reasonable defaults for log scale\n                if self.vmin is None:\n                    self.vmin = 1e-10  # Small positive value for log scale\n                if self.vmax is None:\n                    self.vmax = 1.0\n                return\n            return super().autoscale_None(in_trf_domain)\n",
      "\n        def autoscale_None(self, A):\n            # i.e. A[np.isfinite(...)], but also for non-array A's\n            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n            if in_trf_domain.size == 0:\n                # Instead of passing masked data, handle the edge case properly\n                # If vmin/vmax are already set and valid, don't override them\n                if self.vmin is not None and self.vmax is not None:\n                    return  # Don't autoscale if both bounds are already set\n                # Otherwise, provide reasonable defaults for log scale\n                if self.vmin is None:\n                    self.vmin = 1e-10  # Small positive value for log scale\n                if self.vmax is None:\n                    self.vmax = 1.0\n                return\n            return super().autoscale_None(in_trf_domain)\n",
      "\n        def autoscale_None(self, A):\n            # i.e. A[np.isfinite(...)], but also for non-array A's\n            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n            if in_trf_domain.size == 0:\n                # Instead of passing masked data, handle the edge case properly\n                # If vmin/vmax are already set and valid, don't override them\n                if self.vmin is not None and self.vmax is not None:\n                    return  # Don't autoscale if both bounds are already set\n                # Otherwise, provide reasonable defaults for log scale\n                if self.vmin is None:\n                    self.vmin = 1e-10  # Small positive value for log scale\n                if self.vmax is None:\n                    self.vmax = 1.0\n                return\n            return super().autoscale_None(in_trf_domain)\n"
    ],
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 1694-1697)": [
      "\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n                                f\"vmin={self.vmin}, vmax={self.vmax}. \"\n                                f\"For LogNorm, both values must be positive.\")\n",
      "\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n                               f\"For LogNorm, both values must be positive.\")\n",
      "\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n                               f\"For LogNorm, both values must be positive.\")\n",
      "\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n                               f\"For LogNorm, both values must be positive.\")\n",
      "\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n                               f\"For LogNorm, both values must be positive.\")\n",
      "\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n                               f\"For LogNorm, both values must be positive.\")\n",
      "\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n                               f\"For LogNorm, both values must be positive.\")\n",
      "\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n                               f\"For LogNorm, both values must be positive.\")\n"
    ],
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 1682-1690)": [
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..7954b41bd1 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1679,6 +1679,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1691,10 +1692,13 @@ def _make_norm_from_scale(\n                 clip = self.clip\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n+\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n+                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n+                               f\"For LogNorm, both values must be positive.\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1717,11 +1721,21 @@ def _make_norm_from_scale(\n                      .reshape(np.shape(value)))\n             return value[0] if is_scalar else value\n \n+\n         def autoscale_None(self, A):\n             # i.e. A[np.isfinite(...)], but also for non-array A's\n             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n             if in_trf_domain.size == 0:\n-                in_trf_domain = np.ma.masked\n+                # Instead of passing masked data, handle the edge case properly\n+                # If vmin/vmax are already set and valid, don't override them\n+                if self.vmin is not None and self.vmax is not None:\n+                    return  # Don't autoscale if both bounds are already set\n+                # Otherwise, provide reasonable defaults for log scale\n+                if self.vmin is None:\n+                    self.vmin = 1e-10  # Small positive value for log scale\n+                if self.vmax is None:\n+                    self.vmax = 1.0\n+                return\n             return super().autoscale_None(in_trf_domain)\n \n     if base_norm_cls is Normalize:\n",
    "variant_0": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..5f2133bf13 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1679,22 +1679,26 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n+            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n             if self.vmin is None or self.vmax is None:\n                 self.autoscale_None(value)\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n             if self.vmin == self.vmax:\n                 return np.full_like(value, 0)\n-            if clip is None:\n                 clip = self.clip\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n+\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n+                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n+                               f\"For LogNorm, both values must be positive.\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1717,11 +1721,21 @@ def _make_norm_from_scale(\n                      .reshape(np.shape(value)))\n             return value[0] if is_scalar else value\n \n+\n         def autoscale_None(self, A):\n             # i.e. A[np.isfinite(...)], but also for non-array A's\n             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n             if in_trf_domain.size == 0:\n-                in_trf_domain = np.ma.masked\n+                # Instead of passing masked data, handle the edge case properly\n+                # If vmin/vmax are already set and valid, don't override them\n+                if self.vmin is not None and self.vmax is not None:\n+                    return  # Don't autoscale if both bounds are already set\n+                # Otherwise, provide reasonable defaults for log scale\n+                if self.vmin is None:\n+                    self.vmin = 1e-10  # Small positive value for log scale\n+                if self.vmax is None:\n+                    self.vmax = 1.0\n+                return\n             return super().autoscale_None(in_trf_domain)\n \n     if base_norm_cls is Normalize:\n",
    "variant_1": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..3e5d760d2a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1679,8 +1679,10 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n+            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n             if self.vmin is None or self.vmax is None:\n                 self.autoscale_None(value)\n             if self.vmin > self.vmax:\n@@ -1691,10 +1693,13 @@ def _make_norm_from_scale(\n                 clip = self.clip\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n+\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n+                                f\"vmin={self.vmin}, vmax={self.vmax}. \"\n+                                f\"For LogNorm, both values must be positive.\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1717,11 +1722,21 @@ def _make_norm_from_scale(\n                      .reshape(np.shape(value)))\n             return value[0] if is_scalar else value\n \n+\n         def autoscale_None(self, A):\n             # i.e. A[np.isfinite(...)], but also for non-array A's\n             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n             if in_trf_domain.size == 0:\n-                in_trf_domain = np.ma.masked\n+                # Instead of passing masked data, handle the edge case properly\n+                # If vmin/vmax are already set and valid, don't override them\n+                if self.vmin is not None and self.vmax is not None:\n+                    return  # Don't autoscale if both bounds are already set\n+                # Otherwise, provide reasonable defaults for log scale\n+                if self.vmin is None:\n+                    self.vmin = 1e-10  # Small positive value for log scale\n+                if self.vmax is None:\n+                    self.vmax = 1.0\n+                return\n             return super().autoscale_None(in_trf_domain)\n \n     if base_norm_cls is Normalize:\n",
    "variant_2": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..14203ee4e7 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1679,8 +1679,10 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n+            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n             if self.vmin is None or self.vmax is None:\n                 self.autoscale_None(value)\n             if self.vmin > self.vmax:\n@@ -1691,10 +1693,13 @@ def _make_norm_from_scale(\n                 clip = self.clip\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n+\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n+                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n+                               f\"For LogNorm, both values must be positive.\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1717,11 +1722,21 @@ def _make_norm_from_scale(\n                      .reshape(np.shape(value)))\n             return value[0] if is_scalar else value\n \n+\n         def autoscale_None(self, A):\n             # i.e. A[np.isfinite(...)], but also for non-array A's\n             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n             if in_trf_domain.size == 0:\n-                in_trf_domain = np.ma.masked\n+                # Instead of passing masked data, handle the edge case properly\n+                # If vmin/vmax are already set and valid, don't override them\n+                if self.vmin is not None and self.vmax is not None:\n+                    return  # Don't autoscale if both bounds are already set\n+                # Otherwise, provide reasonable defaults for log scale\n+                if self.vmin is None:\n+                    self.vmin = 1e-10  # Small positive value for log scale\n+                if self.vmax is None:\n+                    self.vmax = 1.0\n+                return\n             return super().autoscale_None(in_trf_domain)\n \n     if base_norm_cls is Normalize:\n",
    "variant_3": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..5f2133bf13 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1679,22 +1679,26 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n+            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n             if self.vmin is None or self.vmax is None:\n                 self.autoscale_None(value)\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n             if self.vmin == self.vmax:\n                 return np.full_like(value, 0)\n-            if clip is None:\n                 clip = self.clip\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n+\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n+                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n+                               f\"For LogNorm, both values must be positive.\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1717,11 +1721,21 @@ def _make_norm_from_scale(\n                      .reshape(np.shape(value)))\n             return value[0] if is_scalar else value\n \n+\n         def autoscale_None(self, A):\n             # i.e. A[np.isfinite(...)], but also for non-array A's\n             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n             if in_trf_domain.size == 0:\n-                in_trf_domain = np.ma.masked\n+                # Instead of passing masked data, handle the edge case properly\n+                # If vmin/vmax are already set and valid, don't override them\n+                if self.vmin is not None and self.vmax is not None:\n+                    return  # Don't autoscale if both bounds are already set\n+                # Otherwise, provide reasonable defaults for log scale\n+                if self.vmin is None:\n+                    self.vmin = 1e-10  # Small positive value for log scale\n+                if self.vmax is None:\n+                    self.vmax = 1.0\n+                return\n             return super().autoscale_None(in_trf_domain)\n \n     if base_norm_cls is Normalize:\n",
    "variant_4": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..5f2133bf13 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1679,22 +1679,26 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n+            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n             if self.vmin is None or self.vmax is None:\n                 self.autoscale_None(value)\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n             if self.vmin == self.vmax:\n                 return np.full_like(value, 0)\n-            if clip is None:\n                 clip = self.clip\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n+\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n+                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n+                               f\"For LogNorm, both values must be positive.\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1717,11 +1721,21 @@ def _make_norm_from_scale(\n                      .reshape(np.shape(value)))\n             return value[0] if is_scalar else value\n \n+\n         def autoscale_None(self, A):\n             # i.e. A[np.isfinite(...)], but also for non-array A's\n             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n             if in_trf_domain.size == 0:\n-                in_trf_domain = np.ma.masked\n+                # Instead of passing masked data, handle the edge case properly\n+                # If vmin/vmax are already set and valid, don't override them\n+                if self.vmin is not None and self.vmax is not None:\n+                    return  # Don't autoscale if both bounds are already set\n+                # Otherwise, provide reasonable defaults for log scale\n+                if self.vmin is None:\n+                    self.vmin = 1e-10  # Small positive value for log scale\n+                if self.vmax is None:\n+                    self.vmax = 1.0\n+                return\n             return super().autoscale_None(in_trf_domain)\n \n     if base_norm_cls is Normalize:\n",
    "variant_5": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..5f2133bf13 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1679,22 +1679,26 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n+            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n             if self.vmin is None or self.vmax is None:\n                 self.autoscale_None(value)\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n             if self.vmin == self.vmax:\n                 return np.full_like(value, 0)\n-            if clip is None:\n                 clip = self.clip\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n+\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n+                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n+                               f\"For LogNorm, both values must be positive.\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1717,11 +1721,21 @@ def _make_norm_from_scale(\n                      .reshape(np.shape(value)))\n             return value[0] if is_scalar else value\n \n+\n         def autoscale_None(self, A):\n             # i.e. A[np.isfinite(...)], but also for non-array A's\n             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n             if in_trf_domain.size == 0:\n-                in_trf_domain = np.ma.masked\n+                # Instead of passing masked data, handle the edge case properly\n+                # If vmin/vmax are already set and valid, don't override them\n+                if self.vmin is not None and self.vmax is not None:\n+                    return  # Don't autoscale if both bounds are already set\n+                # Otherwise, provide reasonable defaults for log scale\n+                if self.vmin is None:\n+                    self.vmin = 1e-10  # Small positive value for log scale\n+                if self.vmax is None:\n+                    self.vmax = 1.0\n+                return\n             return super().autoscale_None(in_trf_domain)\n \n     if base_norm_cls is Normalize:\n",
    "variant_6": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..14203ee4e7 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1679,8 +1679,10 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n+            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n             if self.vmin is None or self.vmax is None:\n                 self.autoscale_None(value)\n             if self.vmin > self.vmax:\n@@ -1691,10 +1693,13 @@ def _make_norm_from_scale(\n                 clip = self.clip\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n+\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n+                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n+                               f\"For LogNorm, both values must be positive.\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1717,11 +1722,21 @@ def _make_norm_from_scale(\n                      .reshape(np.shape(value)))\n             return value[0] if is_scalar else value\n \n+\n         def autoscale_None(self, A):\n             # i.e. A[np.isfinite(...)], but also for non-array A's\n             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n             if in_trf_domain.size == 0:\n-                in_trf_domain = np.ma.masked\n+                # Instead of passing masked data, handle the edge case properly\n+                # If vmin/vmax are already set and valid, don't override them\n+                if self.vmin is not None and self.vmax is not None:\n+                    return  # Don't autoscale if both bounds are already set\n+                # Otherwise, provide reasonable defaults for log scale\n+                if self.vmin is None:\n+                    self.vmin = 1e-10  # Small positive value for log scale\n+                if self.vmax is None:\n+                    self.vmax = 1.0\n+                return\n             return super().autoscale_None(in_trf_domain)\n \n     if base_norm_cls is Normalize:\n",
    "variant_7": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..5f2133bf13 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1679,22 +1679,26 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n+            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n             if self.vmin is None or self.vmax is None:\n                 self.autoscale_None(value)\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n             if self.vmin == self.vmax:\n                 return np.full_like(value, 0)\n-            if clip is None:\n                 clip = self.clip\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n+\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n+                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n+                               f\"For LogNorm, both values must be positive.\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1717,11 +1721,21 @@ def _make_norm_from_scale(\n                      .reshape(np.shape(value)))\n             return value[0] if is_scalar else value\n \n+\n         def autoscale_None(self, A):\n             # i.e. A[np.isfinite(...)], but also for non-array A's\n             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n             if in_trf_domain.size == 0:\n-                in_trf_domain = np.ma.masked\n+                # Instead of passing masked data, handle the edge case properly\n+                # If vmin/vmax are already set and valid, don't override them\n+                if self.vmin is not None and self.vmax is not None:\n+                    return  # Don't autoscale if both bounds are already set\n+                # Otherwise, provide reasonable defaults for log scale\n+                if self.vmin is None:\n+                    self.vmin = 1e-10  # Small positive value for log scale\n+                if self.vmax is None:\n+                    self.vmax = 1.0\n+                return\n             return super().autoscale_None(in_trf_domain)\n \n     if base_norm_cls is Normalize:\n",
    "variant_8": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..14203ee4e7 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1679,8 +1679,10 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n+            # Only autoscale if vmin/vmax are truly unset, not just when they might need adjustment\n             if self.vmin is None or self.vmax is None:\n                 self.autoscale_None(value)\n             if self.vmin > self.vmax:\n@@ -1691,10 +1693,13 @@ def _make_norm_from_scale(\n                 clip = self.clip\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n+\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                raise ValueError(f\"Invalid vmin or vmax for {self.__class__.__name__}: \"\n+                               f\"vmin={self.vmin}, vmax={self.vmax}. \"\n+                               f\"For LogNorm, both values must be positive.\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1717,11 +1722,21 @@ def _make_norm_from_scale(\n                      .reshape(np.shape(value)))\n             return value[0] if is_scalar else value\n \n+\n         def autoscale_None(self, A):\n             # i.e. A[np.isfinite(...)], but also for non-array A's\n             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n             if in_trf_domain.size == 0:\n-                in_trf_domain = np.ma.masked\n+                # Instead of passing masked data, handle the edge case properly\n+                # If vmin/vmax are already set and valid, don't override them\n+                if self.vmin is not None and self.vmax is not None:\n+                    return  # Don't autoscale if both bounds are already set\n+                # Otherwise, provide reasonable defaults for log scale\n+                if self.vmin is None:\n+                    self.vmin = 1e-10  # Small positive value for log scale\n+                if self.vmax is None:\n+                    self.vmax = 1.0\n+                return\n             return super().autoscale_None(in_trf_domain)\n \n     if base_norm_cls is Normalize:\n"
  }
}