{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/sympy/sympy/simplify/trigsimp.py lines 560-588)": "\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n            elif k.is_Mul and len(k.args) == 2:\n                # Check for complex exponential patterns: c*(-I*exp(I*x) + I*exp(-I*x))\n                # which should simplify to 2*c*sin(x)\n                c, expr = k.args\n                if (expr.is_Add and len(expr.args) == 2 and \n                    all(isinstance(arg, Mul) and len(arg.args) == 2 for arg in expr.args)):\n                    \n                    # Extract the two terms\n                    term1, term2 = expr.args\n                    coeff1, exp1 = term1.args\n                    coeff2, exp2 = term2.args\n                    \n                    # Check if we have -I*exp(I*x) + I*exp(-I*x) pattern\n                    if (isinstance(exp1, exp) and isinstance(exp2, exp) and\n                        coeff1 == -I and coeff2 == I and\n                        exp1.args[0] == -exp2.args[0] and\n                        (exp1.args[0]/I).is_real):\n                        \n                        x = exp1.args[0]/I  # Extract x from I*x\n                        m = rvd[k]\n                        newd[k] -= m\n                        newd[2*c*sin(x)] += m\n                    \n                    # Check if we have exp(I*x) + exp(-I*x) pattern  \n                    elif (isinstance(exp1, exp) and isinstance(exp2, exp) and\n                          coeff1 == 1 and coeff2 == 1 and\n                          exp1.args[0] == -exp2.args[0] and\n                          (exp1.args[0]/I).is_real):\n                        \n                        x = exp1.args[0]/I  # Extract x from I*x\n                        m = rvd[k]\n                        newd[k] -= m\n                        newd[2*c*cos(x)] += m\n",
    "Location 2 (/root/hy/projects_1/sympy/sympy/simplify/trigsimp.py lines 534-541)": "\ndef exp_trig(e):\n    # select the better of e, and e rewritten in terms of exp or trig\n    # functions\n    choices = [e]\n    if e.has(*_trigs):\n        choices.append(e.rewrite(exp))\n    choices.append(e.rewrite(cos))\n    \n    # Check for complex exponential patterns that can be converted to trig functions\n    # Pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n    # Pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n    if e.is_Mul and e.has(exp):\n        from sympy import I, Wild, collect, simplify\n        x = Wild('x')\n        \n        # Try to match sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n        sin_pattern = -I/2 * (exp(I*x) - exp(-I*x))\n        sin_match = e.match(sin_pattern)\n        if sin_match:\n            choices.append(sin(sin_match[x]))\n        \n        # Try to match cos pattern: 1/2*(exp(I*x) + exp(-I*x))  \n        cos_pattern = S.Half * (exp(I*x) + exp(-I*x))\n        cos_match = e.match(cos_pattern)\n        if cos_match:\n            choices.append(cos(cos_match[x]))\n            \n        # Also try expanded forms with different coefficient arrangements\n        expanded = expand_mul(e)\n        if expanded != e:\n            sin_match = expanded.match(sin_pattern)\n            if sin_match:\n                choices.append(sin(sin_match[x]))\n            cos_match = expanded.match(cos_pattern)\n            if cos_match:\n                choices.append(cos(cos_match[x]))\n    \n    return min(*choices, key=count_ops)\n",
    "Location 3 (/root/hy/projects_1/sympy/sympy/simplify/trigsimp.py lines 593-602)": "\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # Handle complex exponential patterns for trigonometric functions\n    def convert_complex_exp_to_trig(expr):\n        \"\"\"Convert complex exponential patterns to trigonometric functions\"\"\"\n        if not expr.has(exp):\n            return expr\n            \n        # Look for patterns like exp(I*x) Â± exp(-I*x)\n        from sympy import Wild, collect, expand\n        x = Wild('x')\n        a = Wild('a', exclude=[I])\n        \n        # Pattern for sin: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n        # Pattern for cos: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n        \n        expanded = expand(expr)\n        if expanded.has(exp):\n            # Try to collect terms with exp(I*something) and exp(-I*something)\n            from sympy import collect, Add\n            if isinstance(expanded, Add):\n                terms = expanded.args\n                exp_terms = {}\n                other_terms = []\n                \n                for term in terms:\n                    if term.has(exp):\n                        # Look for exp(I*arg) or exp(-I*arg) patterns\n                        from sympy import factor_terms\n                        factored = factor_terms(term)\n                        \n                        # Extract coefficient and exponential part\n                        if factored.has(exp):\n                            from sympy import collect\n                            exp_part = None\n                            coeff = S.One\n                            \n                            if factored.is_Mul:\n                                exp_factors = []\n                                other_factors = []\n                                for f in factored.args:\n                                    if f.has(exp):\n                                        exp_factors.append(f)\n                                    else:\n                                        other_factors.append(f)\n                                if len(exp_factors) == 1:\n                                    exp_part = exp_factors[0]\n                                    coeff = Mul(*other_factors) if other_factors else S.One\n                            elif factored.func == exp:\n                                exp_part = factored\n                                coeff = S.One\n                                \n                            if exp_part and exp_part.func == exp:\n                                arg = exp_part.args[0]\n                                if arg.has(I):\n                                    # Check if it's I*something or -I*something\n                                    if arg.is_Mul and I in arg.args:\n                                        i_coeff = S.One\n                                        real_part = S.One\n                                        for factor in arg.args:\n                                            if factor == I:\n                                                continue\n                                            elif factor == -I:\n                                                i_coeff = -S.One\n                                                continue\n                                            else:\n                                                real_part *= factor\n                                        \n                                        key = real_part\n                                        if key not in exp_terms:\n                                            exp_terms[key] = {}\n                                        if i_coeff == S.One:\n                                            exp_terms[key]['pos'] = coeff\n                                        else:\n                                            exp_terms[key]['neg'] = coeff\n                                    elif arg == I*arg.args[0] if arg.is_Mul else False:\n                                        # Handle I*x case\n                                        real_arg = arg/I\n                                        if real_arg not in exp_terms:\n                                            exp_terms[real_arg] = {}\n                                        exp_terms[real_arg]['pos'] = coeff\n                                    elif arg == -I*arg.args[0] if arg.is_Mul else False:\n                                        # Handle -I*x case  \n                                        real_arg = -arg/I\n                                        if real_arg not in exp_terms:\n                                            exp_terms[real_arg] = {}\n                                        exp_terms[real_arg]['neg'] = coeff\n                        \n                        if not exp_part:\n                            other_terms.append(term)\n                    else:\n                        other_terms.append(term)\n                \n                # Now check for trigonometric patterns\n                new_terms = list(other_terms)\n                for arg, coeffs in exp_terms.items():\n                    if 'pos' in coeffs and 'neg' in coeffs:\n                        pos_coeff = coeffs['pos']\n                        neg_coeff = coeffs['neg']\n                        \n                        # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n                        if pos_coeff == -neg_coeff and pos_coeff == -I/2:\n                            new_terms.append(sin(arg))\n                            continue\n                        elif pos_coeff == -neg_coeff and neg_coeff == -I/2:\n                            new_terms.append(-sin(arg))\n                            continue\n                        # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x))\n                        elif pos_coeff == neg_coeff and pos_coeff == S.Half:\n                            new_terms.append(cos(arg))\n                            continue\n                        # Check for more general patterns\n                        elif pos_coeff == neg_coeff:\n                            # cos-like pattern with different coefficient\n                            new_terms.append(2*pos_coeff*cos(arg))\n                            continue\n                        elif pos_coeff == -neg_coeff:\n                            # sin-like pattern with different coefficient  \n                            new_terms.append(2*pos_coeff*sin(arg)/(-I))\n                            continue\n                    \n                    # If no pattern matched, keep original terms\n                    if 'pos' in coeffs:\n                        new_terms.append(coeffs['pos']*exp(I*arg))\n                    if 'neg' in coeffs:\n                        new_terms.append(coeffs['neg']*exp(-I*arg))\n                \n                if len(new_terms) != len(terms):\n                    return Add(*new_terms)\n        \n        return expr\n    \n    newexpr = convert_complex_exp_to_trig(newexpr)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n",
    "Location 4 (/root/hy/projects_1/sympy/sympy/simplify/trigsimp.py lines 516-533)": "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    >>> exptrigsimp(-I/2*(exp(I*z) - exp(-I*z)))\n    sin(z)\n    >>> exptrigsimp(1/2*(exp(I*z) + exp(-I*z)))\n    cos(z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        \n        # Try to convert complex exponential patterns to trigonometric functions\n        from sympy import Add, Mul, exp, I, sin, cos\n        if isinstance(e, (Add, Mul)):\n            # Check for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n            # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n            try:\n                expanded = e.expand()\n                if expanded.has(exp) and expanded.has(I):\n                    trig_form = expanded.rewrite(sin)\n                    if trig_form != expanded:\n                        choices.append(trig_form)\n            except:\n                pass\n        \n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
    "Location 5 (/root/hy/projects_1/sympy/sympy/simplify/trigsimp.py lines 428-450)": "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). 'old' runs the original SymPy trigsimp.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` result.\n\n    deep:\n    - Apply trigonometric simplifications inside all objects with arguments\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/sympy/sympy/simplify/trigsimp.py lines 560-588)": [
      "\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n            elif k.is_Mul and len(k.args) == 2:\n                # Check for complex exponential patterns: c*I*exp(I*x) or c*I*exp(-I*x)\n                c_factor = k.args[0]\n                exp_factor = k.args[1]\n                if (isinstance(exp_factor, exp) and exp_factor.args[0].has(I) and\n                    c_factor.has(I)):\n                    # Extract the argument of the exponential\n                    exp_arg = exp_factor.args[0]\n                    # Check if we have a pattern like I*x or -I*x\n                    if exp_arg.as_coeff_Mul()[0] == I:\n                        x = exp_arg.as_coeff_Mul()[1]\n                        # Look for the conjugate term\n                        conjugate_key = c_factor.conjugate() * exp(-I*x)\n                        if conjugate_key in rvd and rvd[conjugate_key] == rvd[k]:\n                            m = rvd[k]\n                            # Remove both terms\n                            newd[k] -= m\n                            newd[conjugate_key] -= m\n                            # Convert to trigonometric function\n                            if c_factor == -I/2:\n                                # sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n                                newd[sin(x)] += m\n                            elif c_factor == S.Half:\n                                # cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n                                newd[cos(x)] += m\n                    elif exp_arg.as_coeff_Mul()[0] == -I:\n                        x = exp_arg.as_coeff_Mul()[1]\n                        # Look for the conjugate term\n                        conjugate_key = c_factor.conjugate() * exp(I*x)\n                        if conjugate_key in rvd and rvd[conjugate_key] == rvd[k]:\n                            m = rvd[k]\n                            # Remove both terms\n                            newd[k] -= m\n                            newd[conjugate_key] -= m\n                            # Convert to trigonometric function\n                            if c_factor == I/2:\n                                # sin pattern: I/2*(exp(-I*x) - exp(I*x)) = -sin(x)\n                                newd[-sin(x)] += m\n                            elif c_factor == S.Half:\n                                # cos pattern: 1/2*(exp(-I*x) + exp(I*x)) = cos(x)\n                                newd[cos(x)] += m\n",
      "\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n            elif k.is_Mul and len(k.args) == 2:\n                # Handle complex exponential patterns for trigonometric functions\n                # Look for patterns like I*exp(I*x) or -I*exp(-I*x)\n                coeff, exp_part = k.args\n                if isinstance(exp_part, exp) and exp_part.args[0].has(I):\n                    # Check if we have a matching pair for sin/cos patterns\n                    x_arg = exp_part.args[0]\n                    if x_arg.is_Mul and x_arg.args[0] == I:\n                        # exp(I*x) case\n                        x = x_arg.args[1]\n                        neg_exp_key = None\n                        pos_exp_key = k\n                        \n                        # Look for the corresponding exp(-I*x) term\n                        for other_k in rvd:\n                            if (other_k.is_Mul and len(other_k.args) == 2 and\n                                isinstance(other_k.args[1], exp)):\n                                other_coeff, other_exp = other_k.args\n                                if (other_exp.args[0] == -I*x and \n                                    rvd[other_k] == rvd[k]):\n                                    neg_exp_key = other_k\n                                    break\n                        \n                        if neg_exp_key:\n                            m = rvd[k]\n                            # Remove both exponential terms\n                            newd[pos_exp_key] -= m\n                            newd[neg_exp_key] -= m\n                            \n                            pos_coeff = coeff\n                            neg_coeff = neg_exp_key.args[0]\n                            \n                            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n                            if pos_coeff == -I/2 and neg_coeff == I/2:\n                                newd[sin(x)] += m\n                            elif pos_coeff == I/2 and neg_coeff == -I/2:\n                                newd[-sin(x)] += m\n                            # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x))\n                            elif pos_coeff == S.Half and neg_coeff == S.Half:\n                                newd[cos(x)] += m\n                            elif pos_coeff == -S.Half and neg_coeff == -S.Half:\n                                newd[-cos(x)] += m\n                            # Handle scaled versions (like sinc pattern)\n                            elif (pos_coeff/(-I/2)).is_real and (neg_coeff/(I/2)).is_real:\n                                scale = pos_coeff/(-I/2)\n                                if scale == neg_coeff/(I/2):\n                                    newd[scale*sin(x)] += m\n                            elif (pos_coeff/(S.Half)).is_real and (neg_coeff/(S.Half)).is_real:\n                                scale = pos_coeff/(S.Half)\n                                if scale == neg_coeff/(S.Half):\n                                    newd[scale*cos(x)] += m\n                            else:\n                                # Restore if no pattern matched\n                                newd[pos_exp_key] += m\n                                newd[neg_exp_key] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n",
      "\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x) for hyperbolic functions\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n            elif k.is_Mul and len(k.args) == 2:\n                # Check for complex exponential patterns: c*exp(I*x) or c*exp(-I*x)\n                coeff, exp_part = k.args\n                if isinstance(exp_part, exp) and exp_part.args[0].has(I):\n                    arg = exp_part.args[0]\n                    # Check if we have a pair exp(I*x) and exp(-I*x) with appropriate coefficients\n                    if arg.is_Mul and arg.args[0] == I:\n                        x = arg.args[1]\n                        # Look for the conjugate term\n                        conj_key = coeff * exp(-I*x)\n                        if conj_key in rvd:\n                            m1 = rvd[k]\n                            m2 = rvd[conj_key]\n                            if m1 == m2:  # Same multiplicity\n                                newd[k] -= m1\n                                newd[conj_key] -= m2\n                                # Apply Euler's formulas\n                                if coeff == I/2:\n                                    # I/2 * (exp(I*x) - exp(-I*x)) = sin(x)\n                                    newd[sin(x)] += m1\n                                elif coeff == -I/2:\n                                    # -I/2 * (exp(I*x) - exp(-I*x)) = -sin(x)\n                                    newd[-sin(x)] += m1\n                                elif coeff == S.Half:\n                                    # 1/2 * (exp(I*x) + exp(-I*x)) = cos(x)\n                                    newd[cos(x)] += m1\n                                elif coeff == -S.Half:\n                                    # -1/2 * (exp(I*x) + exp(-I*x)) = -cos(x)\n                                    newd[-cos(x)] += m1\n                    elif arg.is_Mul and len(arg.args) == 2 and arg.args[0] == -I:\n                        x = arg.args[1]\n                        # Look for the conjugate term\n                        conj_key = coeff * exp(I*x)\n                        if conj_key in rvd:\n                            m1 = rvd[k]\n                            m2 = rvd[conj_key]\n                            if m1 == m2:  # Same multiplicity\n                                newd[k] -= m1\n                                newd[conj_key] -= m2\n                                # Apply Euler's formulas\n                                if coeff == -I/2:\n                                    # -I/2 * (exp(-I*x) - exp(I*x)) = sin(x)\n                                    newd[sin(x)] += m1\n                                elif coeff == I/2:\n                                    # I/2 * (exp(-I*x) - exp(I*x)) = -sin(x)\n                                    newd[-sin(x)] += m1\n                                elif coeff == S.Half:\n                                    # 1/2 * (exp(-I*x) + exp(I*x)) = cos(x)\n                                    newd[cos(x)] += m1\n                                elif coeff == -S.Half:\n                                    # -1/2 * (exp(-I*x) + exp(I*x)) = -cos(x)\n                                    newd[-cos(x)] += m1\n",
      "\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n            elif k.is_Mul and len(k.args) == 2:\n                # Check for complex exponential patterns: c*I*exp(I*x) terms\n                coeff = k.args[0]\n                exp_part = k.args[1]\n                if (isinstance(exp_part, exp) and exp_part.args[0].is_Mul and \n                    len(exp_part.args[0].args) == 2 and exp_part.args[0].args[0] == I):\n                    x = exp_part.args[0].args[1]\n                    m = rvd[k]\n                    # Look for the conjugate term -c*I*exp(-I*x)\n                    conjugate_key = -coeff*I*exp(-I*x)\n                    if conjugate_key in rvd and rvd[conjugate_key] == m:\n                        # Found sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n                        if coeff == -I/2:\n                            newd[k] -= m\n                            newd[conjugate_key] -= m\n                            newd[sin(x)] += m\n                        # Found cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n                        elif coeff == S.Half:\n                            # Check if we have the positive conjugate\n                            pos_conjugate_key = coeff*exp(-I*x)\n                            if pos_conjugate_key in rvd and rvd[pos_conjugate_key] == m:\n                                newd[k] -= m\n                                newd[pos_conjugate_key] -= m\n                                newd[cos(x)] += m\n",
      "\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n            elif k.is_Mul and len(k.args) == 2:\n                # Check for complex exponential patterns: c*I*exp(I*x) terms\n                c_factor = k.args[0]\n                exp_factor = k.args[1]\n                if (isinstance(exp_factor, exp) and exp_factor.args[0].has(I) and\n                    c_factor.has(I)):\n                    # Look for the corresponding -c*I*exp(-I*x) term\n                    x_arg = exp_factor.args[0]\n                    if x_arg.is_Mul and x_arg.args[0] == I:\n                        x = x_arg.args[1]\n                        # Look for the conjugate term\n                        conj_key = -c_factor * exp(-I*x)\n                        if conj_key in rvd and rvd[conj_key] == rvd[k]:\n                            m = rvd[k]\n                            # Remove both terms\n                            newd[k] -= m\n                            newd[conj_key] -= m\n                            # Check if this matches sin or cos pattern\n                            if c_factor == -I/2:\n                                # sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n                                newd[sin(x)] += m\n                            elif c_factor == I/2:\n                                # -sin pattern: I/2*(exp(I*x) - exp(-I*x)) = -sin(x)\n                                newd[-sin(x)] += m\n                    elif x_arg.is_Mul and x_arg.args[0] == -I:\n                        x = x_arg.args[1]\n                        # Look for the conjugate term\n                        conj_key = -c_factor * exp(I*x)\n                        if conj_key in rvd and rvd[conj_key] == rvd[k]:\n                            m = rvd[k]\n                            # Remove both terms\n                            newd[k] -= m\n                            newd[conj_key] -= m\n                            # Check if this matches cos pattern\n                            if c_factor == S.Half:\n                                # cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n                                newd[cos(x)] += m\n                elif (isinstance(exp_factor, exp) and exp_factor.args[0].has(I) and\n                      not c_factor.has(I)):\n                    # Look for real coefficient with complex exponential\n                    x_arg = exp_factor.args[0]\n                    if x_arg.is_Mul and x_arg.args[0] == I:\n                        x = x_arg.args[1]\n                        # Look for the conjugate term with same real coefficient\n                        conj_key = c_factor * exp(-I*x)\n                        if conj_key in rvd and rvd[conj_key] == rvd[k]:\n                            m = rvd[k]\n                            # Remove both terms\n                            newd[k] -= m\n                            newd[conj_key] -= m\n                            # This is cos pattern: c*(exp(I*x) + exp(-I*x)) = 2*c*cos(x)\n                            newd[2*c_factor*cos(x)] += m\n                    elif x_arg.is_Mul and x_arg.args[0] == -I:\n                        x = x_arg.args[1]\n                        # Look for the conjugate term with opposite coefficient\n                        conj_key = -c_factor * exp(I*x)\n                        if conj_key in rvd and rvd[conj_key] == rvd[k]:\n                            m = rvd[k]\n                            # Remove both terms\n                            newd[k] -= m\n                            newd[conj_key] -= m\n                            # This is sin pattern: c*(exp(-I*x) - exp(I*x)) = -2*I*c*sin(x)\n                            newd[-2*I*c_factor*sin(x)] += m\n",
      "\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n            elif k.is_Mul and len(k.args) == 2:\n                # Check for complex exponential patterns: c*exp(I*x) or c*exp(-I*x)\n                coeff, exp_part = k.args\n                if isinstance(exp_part, exp) and exp_part.args[0].has(I):\n                    # Extract argument from exp(I*x) or exp(-I*x)\n                    arg = exp_part.args[0]\n                    if arg.is_Mul and len(arg.args) == 2 and arg.args[0] == I:\n                        # exp(I*x) case\n                        x = arg.args[1]\n                        m = rvd[k]\n                        # Look for corresponding exp(-I*x) term\n                        conj_key = coeff * exp(-I*x)\n                        if conj_key in rvd and rvd[conj_key] == m:\n                            # We have c*exp(I*x) and c*exp(-I*x) with same multiplicity\n                            newd[k] -= m\n                            newd[conj_key] -= m\n                            if coeff == I/2:\n                                # I/2*(exp(I*x) - exp(-I*x)) = I*sin(x)\n                                # -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n                                newd[sin(x)] += m\n                            elif coeff == -I/2:\n                                # -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n                                newd[sin(x)] += m\n                            elif coeff == S.Half:\n                                # 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n                                newd[cos(x)] += m\n                    elif arg.is_Mul and len(arg.args) == 2 and arg.args[0] == -I:\n                        # exp(-I*x) case - handled by the exp(I*x) case above\n                        pass\n",
      "\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n            elif k.is_Add and len(k.args) == 2:\n                # Check for trigonometric patterns: c*(-I*exp(I*x) + I*exp(-I*x)) = 2*c*sin(x)\n                # and c*(exp(I*x) + exp(-I*x)) = 2*c*cos(x)\n                arg1, arg2 = k.args\n                if (isinstance(arg1, Mul) and isinstance(arg2, Mul) and \n                    len(arg1.args) == 2 and len(arg2.args) == 2):\n                    \n                    # Extract coefficient and exponential parts\n                    c1, exp1 = arg1.args if isinstance(arg1.args[1], exp) else (arg1.args[1], arg1.args[0])\n                    c2, exp2 = arg2.args if isinstance(arg2.args[1], exp) else (arg2.args[1], arg2.args[0])\n                    \n                    if (isinstance(exp1, exp) and isinstance(exp2, exp) and\n                        exp1.args[0] == -exp2.args[0] and exp1.args[0].has(I)):\n                        \n                        x_arg = exp1.args[0]\n                        if x_arg.has(I):\n                            # Remove I from the argument\n                            x_val = x_arg / I\n                            m = rvd[k]\n                            newd[k] -= m\n                            \n                            # sin pattern: -I*exp(I*x) + I*exp(-I*x) = 2*sin(x)\n                            if c1 == -I and c2 == I:\n                                newd[2*sin(x_val)] += m\n                            # cos pattern: exp(I*x) + exp(-I*x) = 2*cos(x)  \n                            elif c1 == 1 and c2 == 1:\n                                newd[2*cos(x_val)] += m\n                            else:\n                                # Restore original if pattern doesn't match exactly\n                                newd[k] += m\n",
      "\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n            elif k.is_Mul and len(k.args) == 2:\n                # Check for complex exponential patterns: c*I*exp(I*x) patterns\n                if k.args[0] == I and isinstance(k.args[1], exp):\n                    exp_arg = k.args[1].args[0]\n                    if exp_arg.is_Mul and len(exp_arg.args) == 2 and exp_arg.args[0] == I:\n                        # Found I*exp(I*x), look for corresponding -I*exp(-I*x)\n                        x = exp_arg.args[1]\n                        neg_k = -I*exp(-I*x)\n                        if neg_k in rvd and rvd[k] == rvd[neg_k]:\n                            # Found matching pair: I*exp(I*x) and -I*exp(-I*x)\n                            m = rvd[k]\n                            newd[k] -= m\n                            newd[neg_k] -= m\n                            # Convert to sin: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n                            # So I*exp(I*x) - I*exp(-I*x) = 2*sin(x)\n                            newd[2*sin(x)] += m\n                elif k.args[0] == -I and isinstance(k.args[1], exp):\n                    exp_arg = k.args[1].args[0]\n                    if exp_arg.is_Mul and len(exp_arg.args) == 2 and exp_arg.args[0] == -I:\n                        # Found -I*exp(-I*x), check if I*exp(I*x) already processed\n                        x = -exp_arg.args[1]\n                        pos_k = I*exp(I*x)\n                        # Skip if already processed above\n                        continue\n            elif isinstance(k, exp):\n                # Check for direct exp(I*x) + exp(-I*x) patterns for cos\n                exp_arg = k.args[0]\n                if exp_arg.is_Mul and len(exp_arg.args) == 2 and exp_arg.args[0] == I:\n                    x = exp_arg.args[1]\n                    neg_exp = exp(-I*x)\n                    if neg_exp in rvd and rvd[k] == rvd[neg_exp]:\n                        # Found exp(I*x) + exp(-I*x) = 2*cos(x)\n                        m = rvd[k]\n                        newd[k] -= m\n                        newd[neg_exp] -= m\n                        newd[2*cos(x)] += m\n"
    ],
    "Location 2 (/root/hy/projects_1/sympy/sympy/simplify/trigsimp.py lines 534-541)": [
      "\ndef exp_trig(e):\n    # select the better of e, and e rewritten in terms of exp or trig\n    # functions\n    choices = [e]\n    if e.has(*_trigs):\n        choices.append(e.rewrite(exp))\n    choices.append(e.rewrite(cos))\n    \n    # Check for complex exponential patterns that can be converted to trig functions\n    if e.has(exp):\n        # Try to convert complex exponential expressions to trigonometric form\n        from sympy import re, im, simplify\n        try:\n            # Convert complex exponentials to trig functions using Euler's formula\n            trig_form = e.rewrite(sin).rewrite(cos)\n            if trig_form != e and not trig_form.has(exp):\n                choices.append(trig_form)\n        except:\n            pass\n    \n    return min(*choices, key=count_ops)\n",
      "\ndef exp_trig(e):\n    # select the better of e, and e rewritten in terms of exp or trig\n    # functions\n    choices = [e]\n    if e.has(*_trigs):\n        choices.append(e.rewrite(exp))\n    \n    # Check for complex exponential patterns that can be converted to trig functions\n    if e.has(exp):\n        # Try to recognize and convert exp(I*x) patterns to trig functions\n        from sympy import I, Wild, collect, expand\n        x = Wild('x')\n        \n        # Look for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n        # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n        expanded = expand(e)\n        \n        # Try rewriting in terms of sin/cos if we have complex exponentials\n        if expanded.has(I) and expanded.has(exp):\n            trig_form = expanded.rewrite(sin).rewrite(cos)\n            if trig_form != expanded:\n                choices.append(trig_form)\n    \n    choices.append(e.rewrite(cos))\n    return min(*choices, key=count_ops)\n",
      "\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        \n        # Try to recognize exponential patterns that can be converted to trig functions\n        # Handle complex exponential patterns for sin/cos conversion\n        if e.has(exp):\n            from sympy import I, re, im, simplify\n            try:\n                # Try to convert complex exponential expressions to trigonometric form\n                exp_to_trig = e.rewrite(sin).rewrite(cos)\n                if exp_to_trig != e and not exp_to_trig.has(exp):\n                    choices.append(exp_to_trig)\n                \n                # Also try hyperbolic to trigonometric conversion for complex args\n                if e.has(I):\n                    hyp_form = e.rewrite(cosh).rewrite(sinh)\n                    if hyp_form != e:\n                        trig_form = hyper_as_trig(hyp_form)\n                        if trig_form != hyp_form:\n                            choices.append(trig_form)\n            except:\n                pass\n        \n        return min(*choices, key=count_ops)\n",
      "\ndef exp_trig(e):\n    # select the better of e, and e rewritten in terms of exp or trig\n    # functions\n    choices = [e]\n    if e.has(*_trigs):\n        choices.append(e.rewrite(exp))\n    choices.append(e.rewrite(cos))\n    \n    # Try to recognize exponential patterns that can be converted to trig functions\n    # Look for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n    # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n    from sympy import I, exp, sin, cos, Add, Mul\n    if e.is_Mul and e.has(exp):\n        # Check if this looks like a trig function in exponential form\n        args = e.args\n        if len(args) >= 2:\n            coeff = S.One\n            exp_part = S.One\n            for arg in args:\n                if arg.has(exp):\n                    exp_part *= arg\n                else:\n                    coeff *= arg\n            \n            if exp_part.is_Add and len(exp_part.args) == 2:\n                exp1, exp2 = exp_part.args\n                if (exp1.is_Pow and exp1.base == exp and \n                    exp2.is_Pow and exp2.base == exp):\n                    arg1 = exp1.exp\n                    arg2 = exp2.exp\n                    # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n                    if (coeff == -I/2 and arg1 == -arg2 and \n                        arg1.has(I) and arg1/I == -arg2/I):\n                        x = arg1/I\n                        choices.append(sin(x))\n                    # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x))\n                    elif (coeff == S.Half and arg1 == -arg2 and \n                          arg1.has(I) and arg1/I == -arg2/I):\n                        x = arg1/I\n                        choices.append(cos(x))\n    \n    return min(*choices, key=count_ops)\n",
      "\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        \n        # Try to recognize exponential patterns that can be converted to trig functions\n        # Look for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n        # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n        from sympy import collect, Wild, exp, I, sin, cos\n        \n        # Check if expression can be written as combination of exp(I*x) terms\n        if e.has(exp) and e.has(I):\n            # Try to collect exponential terms and see if they match trig patterns\n            try:\n                # Look for expressions of the form a*exp(I*x) + b*exp(-I*x)\n                x = Wild('x', exclude=[I])\n                a = Wild('a')\n                b = Wild('b')\n                pattern = a*exp(I*x) + b*exp(-I*x)\n                matches = e.match(pattern)\n                \n                if matches:\n                    x_val = matches[x]\n                    a_val = matches[a]\n                    b_val = matches[b]\n                    \n                    # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n                    if a_val == -I/2 and b_val == I/2:\n                        choices.append(sin(x_val))\n                    # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n                    elif a_val == S.Half and b_val == S.Half:\n                        choices.append(cos(x_val))\n                    # Check for scaled versions\n                    elif a_val == -b_val and a_val != 0:\n                        # This is a sin pattern: a*(exp(I*x) - exp(-I*x)) where a = -I*c/2\n                        if (a_val / (-I)).is_real:\n                            coeff = a_val / (-I/2)\n                            choices.append(coeff * sin(x_val))\n                    elif a_val == b_val and a_val != 0:\n                        # This is a cos pattern: a*(exp(I*x) + exp(-I*x)) where a = c/2\n                        if a_val.is_real:\n                            coeff = a_val / (S.Half)\n                            choices.append(coeff * cos(x_val))\n            except:\n                pass  # If pattern matching fails, just use original choices\n        \n        return min(*choices, key=count_ops)\n",
      "\ndef exp_trig(e):\n    # select the better of e, and e rewritten in terms of exp or trig\n    # functions\n    choices = [e]\n    if e.has(*_trigs):\n        choices.append(e.rewrite(exp))\n    choices.append(e.rewrite(cos))\n    \n    # Check for complex exponential patterns that can be converted to trig functions\n    if e.has(exp, I):\n        from sympy import re, im, collect\n        # Try to convert complex exponential expressions to trigonometric forms\n        # Look for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n        # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n        try:\n            # Expand and collect terms to identify exponential patterns\n            expanded = expand_mul(e)\n            if expanded.has(exp):\n                # Try rewriting using trigonometric identities\n                trig_form = expanded.rewrite(sin).rewrite(cos)\n                if trig_form != expanded and not trig_form.has(exp):\n                    choices.append(trig_form)\n        except:\n            pass\n    \n    return min(*choices, key=count_ops)\n",
      "\ndef exp_trig(e):\n    # select the better of e, and e rewritten in terms of exp or trig\n    # functions\n    choices = [e]\n    if e.has(*_trigs):\n        choices.append(e.rewrite(exp))\n    \n    # Check for complex exponential patterns that can be converted to trig functions\n    if e.has(exp) and e.has(I):\n        # Try to convert complex exponential expressions to trigonometric form\n        from sympy import collect, expand\n        expanded = expand(e)\n        # Look for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n        # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n        trig_form = expanded\n        for atom in expanded.atoms(exp):\n            if atom.exp.has(I):\n                arg = atom.exp\n                if arg.is_Mul and I in arg.args:\n                    # Extract the real argument\n                    real_arg = arg / I\n                    if real_arg.is_real or real_arg.is_symbol:\n                        # Replace exp(I*x) with cos(x) + I*sin(x)\n                        trig_form = trig_form.subs(atom, cos(real_arg) + I*sin(real_arg))\n        if trig_form != expanded:\n            from sympy import simplify\n            trig_simplified = simplify(trig_form)\n            choices.append(trig_simplified)\n    \n    choices.append(e.rewrite(cos))\n    return min(*choices, key=count_ops)\n",
      "\ndef exp_trig(e):\n    # select the better of e, and e rewritten in terms of exp or trig\n    # functions\n    choices = [e]\n    if e.has(*_trigs):\n        choices.append(e.rewrite(exp))\n    choices.append(e.rewrite(cos))\n    \n    # Check for complex exponential patterns that can be converted to trig functions\n    from sympy import re, im, I\n    if e.has(exp) and e.has(I):\n        # Try to convert complex exponential expressions to trigonometric form\n        try:\n            # Look for patterns like I*exp(I*x) - I*exp(-I*x) = 2*sin(x)\n            # or exp(I*x) + exp(-I*x) = 2*cos(x)\n            trig_form = e.rewrite(sin)\n            if trig_form != e and not trig_form.has(exp):\n                choices.append(trig_form)\n        except:\n            pass\n    \n    return min(*choices, key=count_ops)\n"
    ],
    "Location 3 (/root/hy/projects_1/sympy/sympy/simplify/trigsimp.py lines 593-602)": [
      "\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # Handle complex exponential patterns for trigonometric functions\n    def convert_complex_exp_to_trig(expr):\n        \"\"\"Convert complex exponential patterns to trigonometric functions.\"\"\"\n        if not expr.has(exp):\n            return expr\n        \n        # Look for patterns like I*exp(I*x) - I*exp(-I*x) = 2*sin(x)\n        # and exp(I*x) + exp(-I*x) = 2*cos(x)\n        from sympy import Wild, collect\n        from sympy.functions import sin, cos\n        \n        x = Wild('x')\n        c = Wild('c')\n        \n        # Pattern for sin: -I/2*(exp(I*x) - exp(-I*x)) or I/2*(exp(-I*x) - exp(I*x))\n        # More generally: c*I*exp(I*x) - c*I*exp(-I*x) = 2*c*I*sin(x)\n        expr_expanded = expand_mul(expr)\n        \n        # Collect terms with exp\n        terms = expr_expanded.as_ordered_terms()\n        exp_terms = {}\n        \n        for term in terms:\n            if term.has(exp):\n                # Extract coefficient and exponential part\n                coeff = S.One\n                exp_part = None\n                for factor in term.as_ordered_factors():\n                    if factor.has(exp):\n                        exp_part = factor\n                    else:\n                        coeff *= factor\n                \n                if exp_part:\n                    # Check if it's of the form exp(I*something) or exp(-I*something)\n                    arg = exp_part.args[0]\n                    if arg.has(I):\n                        # Separate I and the rest\n                        if arg == I*arg/I:  # arg is purely imaginary\n                            real_arg = arg/I\n                            if real_arg not in exp_terms:\n                                exp_terms[real_arg] = {'pos': S.Zero, 'neg': S.Zero}\n                            exp_terms[real_arg]['pos'] += coeff\n                        elif arg == -I*(-arg/I):  # arg is negative imaginary\n                            real_arg = -arg/I\n                            if real_arg not in exp_terms:\n                                exp_terms[real_arg] = {'pos': S.Zero, 'neg': S.Zero}\n                            exp_terms[real_arg]['neg'] += coeff\n        \n        # Convert matching patterns to trigonometric functions\n        new_terms = list(terms)\n        for real_arg, coeffs in exp_terms.items():\n            pos_coeff = coeffs['pos']\n            neg_coeff = coeffs['neg']\n            \n            if pos_coeff != S.Zero and neg_coeff != S.Zero:\n                # Check for sin pattern: I*c*exp(I*x) - I*c*exp(-I*x)\n                if pos_coeff == -neg_coeff and pos_coeff.has(I):\n                    # This is a sin pattern\n                    sin_coeff = pos_coeff / I / 2  # Since sin(x) = (exp(I*x) - exp(-I*x))/(2*I)\n                    sin_term = 2 * sin_coeff * sin(real_arg)\n                    \n                    # Remove the original exponential terms\n                    new_terms = [t for t in new_terms if not (\n                        t.has(exp(I*real_arg)) or t.has(exp(-I*real_arg))\n                    )]\n                    new_terms.append(sin_term)\n                \n                # Check for cos pattern: c*exp(I*x) + c*exp(-I*x)\n                elif pos_coeff == neg_coeff and not pos_coeff.has(I):\n                    # This is a cos pattern\n                    cos_coeff = pos_coeff / 2  # Since cos(x) = (exp(I*x) + exp(-I*x))/2\n                    cos_term = 2 * cos_coeff * cos(real_arg)\n                    \n                    # Remove the original exponential terms\n                    new_terms = [t for t in new_terms if not (\n                        t.has(exp(I*real_arg)) or t.has(exp(-I*real_arg))\n                    )]\n                    new_terms.append(cos_term)\n        \n        return Add(*new_terms) if new_terms else expr\n    \n    newexpr = convert_complex_exp_to_trig(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n",
      "\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # Handle complex exponential patterns for trigonometric functions\n    def convert_complex_exp_to_trig(expr):\n        \"\"\"Convert complex exponential patterns to trigonometric functions.\"\"\"\n        if expr.is_Mul:\n            args = expr.args\n            # Look for patterns like c * (exp(I*x) Â± exp(-I*x))\n            for i, arg in enumerate(args):\n                if arg.is_Add and len(arg.args) == 2:\n                    a, b = arg.args\n                    # Check for exp(I*x) - exp(-I*x) pattern (sin)\n                    if (a.is_Pow and a.base == S.Exp1 and \n                        b.is_Pow and b.base == S.Exp1 and\n                        a.exp.has(I) and b.exp.has(I)):\n                        \n                        # Extract the argument\n                        if a.exp == I*b.exp.args[1] and b.exp.args[0] == -I:\n                            x = a.exp.args[1]\n                            coeff = Mul(*[args[j] for j in range(len(args)) if j != i])\n                            \n                            # Check for sin pattern: -I/2 * (exp(I*x) - exp(-I*x))\n                            if coeff == -I/2:\n                                return sin(x)\n                            # Check for cos pattern: 1/2 * (exp(I*x) + exp(-I*x))\n                            elif coeff == S.Half and a.exp == b.exp.replace(I, -I):\n                                return cos(x)\n        \n        return expr\n\n    newexpr = bottom_up(newexpr, convert_complex_exp_to_trig)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n",
      "\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # Handle complex exponential patterns for trigonometric functions\n    def handle_complex_exp(expr):\n        \"\"\"Convert complex exponential patterns to trigonometric functions\"\"\"\n        if not expr.has(exp):\n            return expr\n            \n        from sympy import collect, I, exp, sin, cos\n        \n        # Look for patterns like c1*exp(I*x) + c2*exp(-I*x)\n        def find_trig_patterns(e):\n            if e.is_Add:\n                args = e.args\n                exp_terms = {}\n                other_terms = []\n                \n                for arg in args:\n                    if arg.has(exp):\n                        # Extract coefficient and exponential part\n                        coeff = S.One\n                        exp_part = arg\n                        if arg.is_Mul:\n                            exp_part = None\n                            for factor in arg.args:\n                                if factor.has(exp):\n                                    exp_part = factor\n                                    coeff = arg / factor\n                                    break\n                        \n                        if exp_part and exp_part.func == exp:\n                            exp_arg = exp_part.args[0]\n                            # Check for I*x pattern\n                            if exp_arg.has(I):\n                                # Extract the real part (x) from I*x\n                                if exp_arg.is_Mul and I in exp_arg.args:\n                                    real_part = exp_arg / I\n                                    if real_part not in exp_terms:\n                                        exp_terms[real_part] = {}\n                                    exp_terms[real_part]['pos'] = exp_terms[real_part].get('pos', 0) + coeff\n                                elif (-exp_arg).is_Mul and I in (-exp_arg).args:\n                                    real_part = (-exp_arg) / I\n                                    if real_part not in exp_terms:\n                                        exp_terms[real_part] = {}\n                                    exp_terms[real_part]['neg'] = exp_terms[real_part].get('neg', 0) + coeff\n                            else:\n                                other_terms.append(arg)\n                        else:\n                            other_terms.append(arg)\n                    else:\n                        other_terms.append(arg)\n                \n                # Convert matching exponential pairs to trig functions\n                trig_terms = []\n                for x, coeffs in exp_terms.items():\n                    pos_coeff = coeffs.get('pos', 0)\n                    neg_coeff = coeffs.get('neg', 0)\n                    \n                    # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n                    if pos_coeff == -neg_coeff and pos_coeff != 0:\n                        if pos_coeff == -I/2:\n                            trig_terms.append(sin(x))\n                        elif pos_coeff == I/2:\n                            trig_terms.append(-sin(x))\n                        else:\n                            # General case: c*(-I/2)*(exp(I*x) - exp(-I*x)) = c*sin(x)\n                            c = pos_coeff / (-I/2)\n                            trig_terms.append(c * sin(x))\n                    \n                    # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x))\n                    elif pos_coeff == neg_coeff and pos_coeff != 0:\n                        if pos_coeff == S.Half:\n                            trig_terms.append(cos(x))\n                        else:\n                            # General case: c*(1/2)*(exp(I*x) + exp(-I*x)) = c*cos(x)\n                            c = pos_coeff / S.Half\n                            trig_terms.append(c * cos(x))\n                    \n                    # If no pattern matches, keep original terms\n                    else:\n                        if pos_coeff != 0:\n                            other_terms.append(pos_coeff * exp(I*x))\n                        if neg_coeff != 0:\n                            other_terms.append(neg_coeff * exp(-I*x))\n                \n                if trig_terms:\n                    return Add(*(trig_terms + other_terms))\n            \n            return e\n        \n        return bottom_up(expr, find_trig_patterns)\n    \n    newexpr = handle_complex_exp(newexpr)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n",
      "\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # Convert complex exponential patterns to trigonometric functions\n    # Handle patterns like exp(I*x) Â± exp(-I*x) -> trigonometric functions\n    from sympy.functions import sin, cos\n    from sympy.core.numbers import I\n    \n    def convert_exp_to_trig(expr):\n        \"\"\"Convert exponential patterns to trigonometric functions using Euler's formula\"\"\"\n        if expr.is_Mul:\n            # Look for patterns like coefficient * (exp(I*x) Â± exp(-I*x))\n            args = expr.args\n            coeff = S.One\n            exp_terms = []\n            \n            for arg in args:\n                if arg.is_Pow and arg.base == S.Exp1:\n                    exp_terms.append(arg)\n                elif not arg.has(exp):\n                    coeff *= arg\n                else:\n                    return expr\n            \n            if len(exp_terms) == 2:\n                exp1, exp2 = exp_terms\n                arg1, arg2 = exp1.exp, exp2.exp\n                \n                # Check for exp(I*x) and exp(-I*x) pattern\n                if (arg1.is_Mul and arg2.is_Mul and \n                    len(arg1.args) == 2 and len(arg2.args) == 2):\n                    \n                    if (arg1.args[0] == I and arg2.args[0] == -I and \n                        arg1.args[1] == arg2.args[1]):\n                        x = arg1.args[1]\n                        # exp(I*x) + exp(-I*x) = 2*cos(x)\n                        if coeff == S.Half:\n                            return cos(x)\n                        # exp(I*x) - exp(-I*x) = 2*I*sin(x)\n                    elif (arg1.args[0] == I and arg2.args[0] == -I and \n                          arg1.args[1] == arg2.args[1]):\n                        x = arg1.args[1]\n                        # -I/2 * (exp(I*x) - exp(-I*x)) = sin(x)\n                        if coeff == -I/2:\n                            return sin(x)\n                        # I/2 * (exp(-I*x) - exp(I*x)) = sin(x)\n                        elif coeff == I/2:\n                            return sin(x)\n        \n        elif expr.is_Add:\n            # Handle addition patterns\n            terms = expr.args\n            if len(terms) == 2:\n                term1, term2 = terms\n                \n                # Look for patterns in multiplication terms\n                if term1.is_Mul and term2.is_Mul:\n                    # Extract coefficients and exponential parts\n                    coeff1, exp1 = S.One, None\n                    coeff2, exp2 = S.One, None\n                    \n                    for arg in term1.args:\n                        if arg.is_Pow and arg.base == S.Exp1:\n                            exp1 = arg\n                        else:\n                            coeff1 *= arg\n                    \n                    for arg in term2.args:\n                        if arg.is_Pow and arg.base == S.Exp1:\n                            exp2 = arg\n                        else:\n                            coeff2 *= arg\n                    \n                    if exp1 and exp2:\n                        arg1, arg2 = exp1.exp, exp2.exp\n                        \n                        # Check for exp(I*x) Â± exp(-I*x) patterns\n                        if (arg1.is_Mul and arg2.is_Mul and \n                            len(arg1.args) == 2 and len(arg2.args) == 2):\n                            \n                            if (arg1.args[0] == I and arg2.args[0] == -I and \n                                arg1.args[1] == arg2.args[1]):\n                                x = arg1.args[1]\n                                \n                                # -I/2*exp(I*x) + I/2*exp(-I*x) = sin(x)\n                                if coeff1 == -I/2 and coeff2 == I/2:\n                                    return sin(x)\n                                # 1/2*exp(I*x) + 1/2*exp(-I*x) = cos(x)\n                                elif coeff1 == S.Half and coeff2 == S.Half:\n                                    return cos(x)\n        \n        return expr\n    \n    newexpr = bottom_up(newexpr, convert_exp_to_trig)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n",
      "\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # Handle complex exponential patterns that should become trigonometric functions\n    # Check for patterns like exp(I*x) Â± exp(-I*x) that represent sin/cos via Euler's formula\n    from sympy.functions import sin, cos, exp\n    from sympy.core.numbers import I\n    \n    def convert_complex_exp_to_trig(expr):\n        \"\"\"Convert complex exponential patterns to trigonometric functions\"\"\"\n        if not expr.has(exp) or not expr.has(I):\n            return expr\n            \n        # Look for patterns: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n        #                    1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n        \n        def _replace_exp_patterns(e):\n            if e.is_Mul:\n                args = e.args\n                # Check for sin pattern: -I/2 * (exp(I*x) - exp(-I*x))\n                if len(args) >= 2:\n                    coeff = S.One\n                    exp_part = S.One\n                    for arg in args:\n                        if arg.is_number:\n                            coeff *= arg\n                        else:\n                            exp_part *= arg\n                    \n                    # Check if coefficient matches -I/2\n                    if coeff == -I/2 and exp_part.is_Add and len(exp_part.args) == 2:\n                        term1, term2 = exp_part.args\n                        # Look for exp(I*x) - exp(-I*x) pattern\n                        if (term1.func == exp and term2.func == exp and \n                            term2.args[0] == -term1.args[0] and \n                            term1.args[0].has(I)):\n                            x_arg = term1.args[0] / I\n                            if x_arg.is_real or not x_arg.has(I):\n                                return sin(x_arg)\n                    \n                    # Check if coefficient matches 1/2\n                    elif coeff == S.Half and exp_part.is_Add and len(exp_part.args) == 2:\n                        term1, term2 = exp_part.args\n                        # Look for exp(I*x) + exp(-I*x) pattern\n                        if (term1.func == exp and term2.func == exp and \n                            term2.args[0] == -term1.args[0] and \n                            term1.args[0].has(I)):\n                            x_arg = term1.args[0] / I\n                            if x_arg.is_real or not x_arg.has(I):\n                                return cos(x_arg)\n            \n            return e\n        \n        return bottom_up(expr, _replace_exp_patterns)\n    \n    # Apply complex exponential to trigonometric conversion\n    newexpr = convert_complex_exp_to_trig(newexpr)\n    \n    # Apply trigonometric simplification if we now have trig functions\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n",
      "\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # Handle complex exponential patterns for trigonometric functions\n    def convert_exp_to_trig(expr):\n        \"\"\"Convert complex exponential patterns to trigonometric functions\"\"\"\n        from sympy import Wild, collect, simplify\n        from sympy.functions import sin, cos\n        \n        if not expr.has(exp):\n            return expr\n            \n        # Look for patterns like I*exp(I*x) - I*exp(-I*x) = 2*sin(x)\n        # and exp(I*x) + exp(-I*x) = 2*cos(x)\n        def trig_replacer(e):\n            if e.is_Add:\n                terms = e.as_ordered_terms()\n                # Group terms by their argument structure\n                exp_terms = {}\n                other_terms = []\n                \n                for term in terms:\n                    if term.has(exp):\n                        # Extract coefficient and exponential part\n                        coeff, rest = term.as_coeff_mul()\n                        exp_part = None\n                        for factor in rest:\n                            if factor.has(exp) and factor.func == exp:\n                                exp_part = factor\n                                break\n                        \n                        if exp_part and exp_part.args[0].has(I):\n                            arg = exp_part.args[0]\n                            # Check if arg is of form I*x or -I*x\n                            if arg.as_coeff_mul(I)[0] != 0:\n                                base_arg = (arg/I).simplify()\n                                if base_arg not in exp_terms:\n                                    exp_terms[base_arg] = {}\n                                exp_terms[base_arg][arg] = exp_terms[base_arg].get(arg, 0) + coeff\n                            else:\n                                other_terms.append(term)\n                        else:\n                            other_terms.append(term)\n                    else:\n                        other_terms.append(term)\n                \n                # Convert exponential patterns to trigonometric\n                new_terms = other_terms[:]\n                for base_arg, patterns in exp_terms.items():\n                    pos_key = I * base_arg\n                    neg_key = -I * base_arg\n                    \n                    pos_coeff = patterns.get(pos_key, 0)\n                    neg_coeff = patterns.get(neg_key, 0)\n                    \n                    # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n                    if pos_coeff != 0 and neg_coeff != 0:\n                        if pos_coeff == -neg_coeff:\n                            # This is a sin or cos pattern\n                            if pos_coeff == -I/2:\n                                new_terms.append(sin(base_arg))\n                                continue\n                            elif pos_coeff == I/2:\n                                new_terms.append(-sin(base_arg))\n                                continue\n                            elif pos_coeff == S.Half:\n                                new_terms.append(cos(base_arg))\n                                continue\n                            elif pos_coeff == -S.Half:\n                                new_terms.append(-cos(base_arg))\n                                continue\n                        \n                        # Scale factor case: c*(-I/2)*(exp(I*x) - exp(-I*x)) = c*sin(x)\n                        if pos_coeff == -neg_coeff and pos_coeff != 0:\n                            scale = pos_coeff / (-I/2)\n                            if scale.is_real:\n                                new_terms.append(scale * sin(base_arg))\n                                continue\n                            scale = pos_coeff / (S.Half)\n                            if scale.is_real:\n                                new_terms.append(scale * cos(base_arg))\n                                continue\n                    \n                    # Add back any unmatched exponential terms\n                    for arg, coeff in patterns.items():\n                        if coeff != 0:\n                            new_terms.append(coeff * exp(arg))\n                \n                return Add(*new_terms) if new_terms else S.Zero\n            \n            return e\n        \n        return bottom_up(expr, trig_replacer)\n    \n    newexpr = convert_exp_to_trig(newexpr)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n",
      "\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # Additional check for complex exponential patterns that should become trig functions\n    from sympy.functions import sin, cos\n    if newexpr.has(exp) and newexpr.has(I):\n        # Try to convert complex exponential patterns to trigonometric functions\n        # This handles cases like -I/2*(exp(I*x) - exp(-I*x)) -> sin(x)\n        temp_expr = newexpr.rewrite(sin).rewrite(cos)\n        if temp_expr != newexpr and not temp_expr.has(exp):\n            newexpr = temp_expr\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n",
      "\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # Apply exponential to trigonometric conversions\n    def exp_to_trig(expr):\n        \"\"\"Convert exponential expressions to trigonometric functions using Euler's formula\"\"\"\n        from sympy import exp, I, sin, cos, collect, Add, Mul\n        \n        if not expr.has(exp):\n            return expr\n            \n        # Look for patterns like exp(I*x) Â± exp(-I*x)\n        def find_exp_pairs(expr):\n            if isinstance(expr, Add):\n                terms = expr.args\n                exp_terms = {}\n                other_terms = []\n                \n                for term in terms:\n                    if isinstance(term, Mul):\n                        coeff = S.One\n                        exp_part = None\n                        for factor in term.args:\n                            if isinstance(factor, exp):\n                                exp_part = factor\n                            else:\n                                coeff *= factor\n                        if exp_part is not None:\n                            arg = exp_part.args[0]\n                            exp_terms[arg] = exp_terms.get(arg, 0) + coeff\n                        else:\n                            other_terms.append(term)\n                    elif isinstance(term, exp):\n                        arg = term.args[0]\n                        exp_terms[arg] = exp_terms.get(arg, 0) + 1\n                    else:\n                        other_terms.append(term)\n                \n                # Look for pairs of the form I*x and -I*x\n                converted_terms = []\n                used_args = set()\n                \n                for arg in exp_terms:\n                    if arg in used_args:\n                        continue\n                    neg_arg = -arg\n                    if neg_arg in exp_terms and arg != neg_arg:\n                        coeff1 = exp_terms[arg]\n                        coeff2 = exp_terms[neg_arg]\n                        \n                        # Check if this is a complex exponential pattern\n                        if arg.has(I):\n                            # Extract the real part from I*x\n                            if arg == I*arg/I:  # arg is of the form I*something\n                                real_arg = arg/I\n                                # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n                                if coeff1 == -I/2 and coeff2 == I/2:\n                                    converted_terms.append(sin(real_arg))\n                                    used_args.update([arg, neg_arg])\n                                # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n                                elif coeff1 == S.Half and coeff2 == S.Half:\n                                    converted_terms.append(cos(real_arg))\n                                    used_args.update([arg, neg_arg])\n                \n                # Add back unused exponential terms\n                for arg in exp_terms:\n                    if arg not in used_args:\n                        coeff = exp_terms[arg]\n                        if coeff == 1:\n                            converted_terms.append(exp(arg))\n                        else:\n                            converted_terms.append(coeff * exp(arg))\n                \n                converted_terms.extend(other_terms)\n                return Add(*converted_terms) if converted_terms else S.Zero\n            \n            return expr\n        \n        return find_exp_pairs(expr)\n    \n    newexpr = exp_to_trig(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n"
    ],
    "Location 4 (/root/hy/projects_1/sympy/sympy/simplify/trigsimp.py lines 516-533)": [
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        \n        # Try to convert complex exponential patterns to trigonometric functions\n        if e.has(exp):\n            # Check for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n            # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n            try:\n                from sympy import collect, expand\n                expanded = expand(e)\n                # Try rewriting in terms of sin/cos if it contains complex exponentials\n                sin_cos_form = expanded.rewrite(sin)\n                if sin_cos_form != expanded:\n                    choices.append(sin_cos_form)\n                cos_form = expanded.rewrite(cos)\n                if cos_form != expanded:\n                    choices.append(cos_form)\n            except:\n                pass\n        \n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n    sin(z)\n    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n    cos(z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        \n        # Try to convert complex exponential patterns to trigonometric functions\n        from sympy import Add, Mul, exp, sin, cos, I\n        if isinstance(e, (Add, Mul)) and e.has(exp):\n            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n            # or cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n            trig_form = e.rewrite(sin)\n            if trig_form != e:\n                choices.append(trig_form)\n        \n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n    sin(z)\n    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n    cos(z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        \n        # Try to convert complex exponential patterns to trigonometric functions\n        from sympy import Add, Mul, exp, sin, cos, I\n        if isinstance(e, Add):\n            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n            # or I/2*(exp(-I*x) - exp(I*x)) = sin(x)\n            terms = e.as_ordered_terms()\n            if len(terms) == 2:\n                t1, t2 = terms\n                # Extract coefficients and exponential parts\n                from sympy import collect\n                from sympy.core.mul import _keep_coeff\n                \n                # Check if we have the form a*exp(I*x) + b*exp(-I*x)\n                exp_terms = {}\n                for term in [t1, t2]:\n                    if term.has(exp):\n                        for arg in term.find(exp):\n                            exp_arg = arg.args[0]\n                            coeff = term.coeff(arg)\n                            if coeff is not None:\n                                exp_terms[exp_arg] = exp_terms.get(exp_arg, 0) + coeff\n                \n                # Look for patterns like I*x and -I*x\n                for arg1 in exp_terms:\n                    arg2 = -arg1\n                    if arg2 in exp_terms:\n                        c1, c2 = exp_terms[arg1], exp_terms[arg2]\n                        # Check for sin pattern: coefficient of exp(I*x) is -I*c, exp(-I*x) is I*c\n                        if c1 == -I*c2 and c1.is_real is False:\n                            # Extract the real argument\n                            if arg1.has(I):\n                                real_arg = (arg1/I).simplify()\n                                if real_arg.is_real is not False:\n                                    sin_form = sin(real_arg) * (-2*I*c2)\n                                    choices.append(sin_form)\n                        # Check for cos pattern: coefficient of exp(I*x) equals coefficient of exp(-I*x)\n                        elif c1 == c2:\n                            if arg1.has(I):\n                                real_arg = (arg1/I).simplify()\n                                if real_arg.is_real is not False:\n                                    cos_form = cos(real_arg) * (2*c1)\n                                    choices.append(cos_form)\n        \n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    >>> exptrigsimp(-I/2*(exp(I*z) - exp(-I*z)))\n    sin(z)\n    >>> exptrigsimp(1/2*(exp(I*z) + exp(-I*z)))\n    cos(z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        \n        # Try to convert complex exponential patterns to trigonometric functions\n        from sympy import Add, Mul, exp, I, sin, cos\n        if isinstance(e, (Add, Mul)) and e.has(exp):\n            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n            # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x))\n            try:\n                expanded = e.expand()\n                choices.append(expanded.rewrite(sin))\n                choices.append(expanded.rewrite(cos))\n            except:\n                pass\n        \n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n    sin(z)\n    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n    cos(z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        \n        # Try to convert complex exponential patterns to trigonometric functions\n        from sympy import Add, Mul, exp, sin, cos, I\n        if isinstance(e, (Add, Mul)):\n            # Check for patterns like -I/2*exp(I*x) + I/2*exp(-I*x) = sin(x)\n            # and 1/2*exp(I*x) + 1/2*exp(-I*x) = cos(x)\n            expanded = expand_mul(e)\n            if expanded != e:\n                choices.append(expanded)\n        \n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n    sin(z)\n    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n    cos(z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        \n        # Try to convert complex exponential patterns to trigonometric functions\n        from sympy import Add, Mul, exp, sin, cos, I\n        if isinstance(e, (Add, Mul)) and e.has(exp):\n            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n            # or cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n            trig_form = e.rewrite(sin).rewrite(cos)\n            if trig_form != e:\n                choices.append(trig_form)\n        \n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n    sin(z)\n    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n    cos(z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        \n        # Try to convert complex exponential patterns to trigonometric functions\n        from sympy import Add, Mul, exp, sin, cos, I\n        if isinstance(e, Add):\n            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n            # or cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n            args = e.args\n            if len(args) == 2:\n                arg1, arg2 = args\n                # Look for exponential terms with I in the exponent\n                if (isinstance(arg1, Mul) and isinstance(arg2, Mul) and\n                    any(isinstance(term, exp) and term.exp.has(I) for term in arg1.args if hasattr(term, 'args')) and\n                    any(isinstance(term, exp) and term.exp.has(I) for term in arg2.args if hasattr(term, 'args'))):\n                    # Try rewriting as trigonometric functions\n                    trig_form = e.rewrite(sin).rewrite(cos)\n                    if trig_form != e and trig_form.has(sin, cos):\n                        choices.append(trig_form)\n        \n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n    sin(z)\n    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n    cos(z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        # Try to convert exponential expressions to trigonometric functions\n        if e.has(exp):\n            # Check for complex exponential patterns that can become trig functions\n            from sympy import Wild, collect, simplify\n            x = Wild('x')\n            \n            # Pattern for sin: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n            sin_pattern = -I/2*(exp(I*x) - exp(-I*x))\n            # Pattern for cos: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)  \n            cos_pattern = S.Half*(exp(I*x) + exp(-I*x))\n            \n            # Try to match and replace exponential patterns with trig functions\n            try:\n                # Expand and collect terms to match patterns\n                expanded = expand_mul(e)\n                \n                # Check if expression matches trigonometric patterns\n                from sympy import sin, cos\n                for atom in expanded.atoms(exp):\n                    if atom.exp.has(I):\n                        arg = atom.exp\n                        if arg.match(I*x):\n                            # Found exp(I*something), look for corresponding exp(-I*something)\n                            var = arg.match(I*x)[x]\n                            conjugate_exp = exp(-I*var)\n                            \n                            if conjugate_exp in expanded.atoms(exp):\n                                # Found both exp(I*var) and exp(-I*var)\n                                # Try to extract coefficients and convert to trig\n                                from sympy import collect\n                                collected = collect(expanded, [atom, conjugate_exp], evaluate=False)\n                                \n                                if atom in collected and conjugate_exp in collected:\n                                    coeff1 = collected.get(atom, 0)\n                                    coeff2 = collected.get(conjugate_exp, 0)\n                                    \n                                    # Check for sin pattern: coeff of exp(I*x) = -I/2, coeff of exp(-I*x) = I/2\n                                    if coeff1 == -I/2 and coeff2 == I/2:\n                                        trig_form = sin(var)\n                                        choices.append(trig_form)\n                                    # Check for cos pattern: coeff of exp(I*x) = 1/2, coeff of exp(-I*x) = 1/2  \n                                    elif coeff1 == S.Half and coeff2 == S.Half:\n                                        trig_form = cos(var)\n                                        choices.append(trig_form)\n            except:\n                pass\n                \n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n"
    ],
    "Location 5 (/root/hy/projects_1/sympy/sympy/simplify/trigsimp.py lines 428-450)": [
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). 'old' runs the 'matching' algorithm followed\n    by experimental exponential-to-trigonometric simplification.\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). 'old' runs the original trigsimp.\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n    deep:\n    - Apply simplification to all levels of the expression tree.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old `trigsimp` routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n\n        if recursive:\n            w, g = cse(expr)\n            g = trigsimp_groebner(g[0], **opts)\n\n            for sub in reversed(w):\n                g = g.subs(sub[0], sub[1])\n                g = trigsimp_groebner(g, **opts)\n            result = g\n        elif method == 'matching':\n            result = futrig(expr)\n        elif method == 'groebner':\n            result = trigsimp_groebner(expr, **opts)\n        elif method == 'combined':\n            result = trigsimp_groebner(expr, polynomial=True, hints=[2, tan])\n            if result is not None:\n                result = futrig(result)\n            else:\n                result = futrig(expr)\n        elif method == 'fu':\n            result = fu(expr, **opts)\n        else:\n            raise ValueError(\n                \"Unknown method %s. Should be one of 'matching', \"\n                \"'groebner', 'combined', 'fu' or 'old'.\" % method)\n    else:\n        result = trigsimp_old(expr, **opts)\n\n    return result\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). 'old' runs the old trigsimp routine.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` result.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). 'old' uses the pre-existing algorithm.\n\n    compare:\n    - show input and output from `trigsimp` and `fu` when different,\n    but returns the `trigsimp` result.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). 'old' uses the legacy trigsimp algorithm.\n\n    compare:\n    - show input and output from `trigsimp` and `fu` when different,\n    but returns the `trigsimp` result.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). 'old' runs the original SymPy trigsimp.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` result.\n\n    deep:\n    - Apply trigsimp recursively to all arguments of functions.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..f90d77b203 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -425,6 +425,7 @@ def analyse_gens(gens, hints):\n _trigs = (TrigonometricFunction, HyperbolicFunction)\n \n \n+\n def trigsimp(expr, **opts):\n     \"\"\"\n     reduces expression by using known trig identities\n@@ -513,20 +514,30 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n+    \n+    This function recognizes patterns in exponential expressions and converts\n+    them to their trigonometric or hyperbolic equivalents when beneficial.\n+    It handles both real exponentials (for hyperbolic functions) and complex\n+    exponentials (for trigonometric functions using Euler's formula).\n \n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n     >>> from sympy.abc import z\n \n     >>> exptrigsimp(exp(z) + exp(-z))\n     2*cosh(z)\n     >>> exptrigsimp(cosh(z) - sinh(z))\n     exp(-z)\n+    >>> exptrigsimp(-I/2*(exp(I*z) - exp(-I*z)))\n+    sin(z)\n+    >>> exptrigsimp(1/2*(exp(I*z) + exp(-I*z)))\n+    cos(z)\n     \"\"\"\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n@@ -538,6 +549,7 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        choices.append(e.rewrite(sin))\n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n@@ -557,6 +569,7 @@ def signlog(expr, sign=1):\n             else:\n                 return None, None\n \n+\n         ee = rvd[S.Exp1]\n         for k in rvd:\n             if k.is_Add and len(k.args) == 2:\n@@ -585,11 +598,58 @@ def signlog(expr, sign=1):\n                 else:\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n-\n+            \n+            # Handle complex exponentials for trigonometric functions\n+            # Look for patterns like exp(I*x) and exp(-I*x)\n+            elif isinstance(k, exp) and k.args[0].has(I):\n+                arg = k.args[0]\n+                m = rvd[k]\n+                \n+                # Check if we have both exp(I*x) and exp(-I*x) terms\n+                if arg.is_Mul and len(arg.args) == 2 and arg.args[0] == I:\n+                    # arg = I*x, so we have exp(I*x)\n+                    x = arg.args[1]\n+                    neg_exp = exp(-I*x)\n+                    \n+                    if neg_exp in rvd:\n+                        m_neg = rvd[neg_exp]\n+                        \n+                        # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+                        # This means we need coefficients that give us the sin pattern\n+                        if m == -m_neg:  # exp(I*x) and exp(-I*x) have opposite coefficients\n+                            # Remove both exponential terms\n+                            newd[k] -= m\n+                            newd[neg_exp] -= m_neg\n+                            \n+                            # Add the trigonometric equivalent\n+                            # sin(x) = -I/2*(exp(I*x) - exp(-I*x))\n+                            # So if we have a*exp(I*x) - a*exp(-I*x), this equals -2*I*a*sin(x)\n+                            newd[-2*I*m*sin(x)] += 1\n+                            \n+                        # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+                        elif m == m_neg:  # exp(I*x) and exp(-I*x) have same coefficients\n+                            # Remove both exponential terms\n+                            newd[k] -= m\n+                            newd[neg_exp] -= m_neg\n+                            \n+                            # Add the trigonometric equivalent\n+                            # cos(x) = 1/2*(exp(I*x) + exp(-I*x))\n+                            # So if we have a*exp(I*x) + a*exp(-I*x), this equals 2*a*cos(x)\n+                            newd[2*m*cos(x)] += 1\n+                \n+                elif arg.is_Mul and len(arg.args) == 2 and arg.args[0] == -I:\n+                    # arg = -I*x, so we have exp(-I*x)\n+                    x = arg.args[1]\n+                    pos_exp = exp(I*x)\n+                    \n+                    # Only process if we haven't already handled this pair\n+                    if pos_exp in rvd and pos_exp not in newd:\n+                        continue  # Will be handled when we process the positive exponential\n         return Mul(*[k**newd[k] for k in newd])\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n         newexpr = f(TR2i(e))\n",
    "variant_0": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..72f25f88c5 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -425,6 +425,7 @@ def analyse_gens(gens, hints):\n _trigs = (TrigonometricFunction, HyperbolicFunction)\n \n \n+\n def trigsimp(expr, **opts):\n     \"\"\"\n     reduces expression by using known trig identities\n@@ -434,15 +435,21 @@ def trigsimp(expr, **opts):\n \n     method:\n     - Determine the method to use. Valid choices are 'matching' (default),\n-    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n+    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n     expression recursively by targeting common patterns. If 'groebner', apply\n     an experimental groebner basis algorithm. In this case further options\n     are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n     If 'combined', first run the groebner basis algorithm with small\n     default parameters, then run the 'matching' algorithm. 'fu' runs the\n     collection of trigonometric transformations described by Fu, et al.\n-    (see the `fu` docstring).\n+    (see the `fu` docstring). 'old' runs the original SymPy trigsimp.\n \n+    compare:\n+    - show input and output from `trigsimp` and `futrig` when different,\n+    but returns the `trigsimp` result.\n+\n+    deep:\n+    - Apply trigonometric simplifications inside all objects with arguments\n \n     Examples\n     ========\n@@ -513,6 +520,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -520,13 +528,17 @@ def exptrigsimp(expr):\n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n     >>> from sympy.abc import z\n \n     >>> exptrigsimp(exp(z) + exp(-z))\n     2*cosh(z)\n     >>> exptrigsimp(cosh(z) - sinh(z))\n     exp(-z)\n+    >>> exptrigsimp(-I/2*(exp(I*z) - exp(-I*z)))\n+    sin(z)\n+    >>> exptrigsimp(1/2*(exp(I*z) + exp(-I*z)))\n+    cos(z)\n     \"\"\"\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n@@ -538,15 +550,81 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        \n+        # Try to convert complex exponential patterns to trigonometric functions\n+        from sympy import Add, Mul, exp, I, sin, cos\n+        if isinstance(e, (Add, Mul)):\n+            # Check for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+            # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+            try:\n+                expanded = e.expand()\n+                if expanded.has(exp) and expanded.has(I):\n+                    trig_form = expanded.rewrite(sin)\n+                    if trig_form != expanded:\n+                        choices.append(trig_form)\n+            except:\n+                pass\n+        \n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n+def exp_trig(e):\n+    # select the better of e, and e rewritten in terms of exp or trig\n+    # functions\n+    choices = [e]\n+    if e.has(*_trigs):\n+        choices.append(e.rewrite(exp))\n+    choices.append(e.rewrite(cos))\n+    \n+    # Check for complex exponential patterns that can be converted to trig functions\n+    # Pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+    # Pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+    if e.is_Mul and e.has(exp):\n+        from sympy import I, Wild, collect, simplify\n+        x = Wild('x')\n+        \n+        # Try to match sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n+        sin_pattern = -I/2 * (exp(I*x) - exp(-I*x))\n+        sin_match = e.match(sin_pattern)\n+        if sin_match:\n+            choices.append(sin(sin_match[x]))\n+        \n+        # Try to match cos pattern: 1/2*(exp(I*x) + exp(-I*x))  \n+        cos_pattern = S.Half * (exp(I*x) + exp(-I*x))\n+        cos_match = e.match(cos_pattern)\n+        if cos_match:\n+            choices.append(cos(cos_match[x]))\n+            \n+        # Also try expanded forms with different coefficient arrangements\n+        expanded = expand_mul(e)\n+        if expanded != e:\n+            sin_match = expanded.match(sin_pattern)\n+            if sin_match:\n+                choices.append(sin(sin_match[x]))\n+            cos_match = expanded.match(cos_pattern)\n+            if cos_match:\n+                choices.append(cos(cos_match[x]))\n+    \n+    return min(*choices, key=count_ops)\n+    newexpr = bottom_up(expr, exp_trig)\n+\n     def f(rv):\n         if not rv.is_Mul:\n             return rv\n         rvd = rv.as_powers_dict()\n         newd = rvd.copy()\n \n+        def signlog(expr, sign=1):\n+            if expr is S.Exp1:\n+                return sign, 1\n+            elif isinstance(expr, exp):\n+                return sign, expr.args[0]\n+            elif sign == 1:\n+                return signlog(-expr, sign=-1)\n+            else:\n+                return None, None\n+\n+\n         def signlog(expr, sign=1):\n             if expr is S.Exp1:\n                 return sign, 1\n@@ -585,10 +663,185 @@ def signlog(expr, sign=1):\n                 else:\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n+            elif k.is_Mul and len(k.args) == 2:\n+                # Check for complex exponential patterns: c*(-I*exp(I*x) + I*exp(-I*x))\n+                # which should simplify to 2*c*sin(x)\n+                c, expr = k.args\n+                if (expr.is_Add and len(expr.args) == 2 and \n+                    all(isinstance(arg, Mul) and len(arg.args) == 2 for arg in expr.args)):\n+                    \n+                    # Extract the two terms\n+                    term1, term2 = expr.args\n+                    coeff1, exp1 = term1.args\n+                    coeff2, exp2 = term2.args\n+                    \n+                    # Check if we have -I*exp(I*x) + I*exp(-I*x) pattern\n+                    if (isinstance(exp1, exp) and isinstance(exp2, exp) and\n+                        coeff1 == -I and coeff2 == I and\n+                        exp1.args[0] == -exp2.args[0] and\n+                        (exp1.args[0]/I).is_real):\n+                        \n+                        x = exp1.args[0]/I  # Extract x from I*x\n+                        m = rvd[k]\n+                        newd[k] -= m\n+                        newd[2*c*sin(x)] += m\n+                    \n+                    # Check if we have exp(I*x) + exp(-I*x) pattern  \n+                    elif (isinstance(exp1, exp) and isinstance(exp2, exp) and\n+                          coeff1 == 1 and coeff2 == 1 and\n+                          exp1.args[0] == -exp2.args[0] and\n+                          (exp1.args[0]/I).is_real):\n+                        \n+                        x = exp1.args[0]/I  # Extract x from I*x\n+                        m = rvd[k]\n+                        newd[k] -= m\n+                        newd[2*c*cos(x)] += m\n+        return Mul(*[k**newd[k] for k in newd])\n+    newexpr = bottom_up(newexpr, f)\n+\n+    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n+                    else:\n+                        newd[-c*tanh(x/2)] += m\n+                else:\n+                    newd[1 + sign*S.Exp1**x] += m\n+                    newd[c] += m\n \n         return Mul(*[k**newd[k] for k in newd])\n     newexpr = bottom_up(newexpr, f)\n \n+    # Handle complex exponential patterns for trigonometric functions\n+    def convert_complex_exp_to_trig(expr):\n+        \"\"\"Convert complex exponential patterns to trigonometric functions\"\"\"\n+        if not expr.has(exp):\n+            return expr\n+            \n+        # Look for patterns like exp(I*x) Â± exp(-I*x)\n+        from sympy import Wild, collect, expand\n+        x = Wild('x')\n+        a = Wild('a', exclude=[I])\n+        \n+        # Pattern for sin: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+        # Pattern for cos: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+        \n+        expanded = expand(expr)\n+        if expanded.has(exp):\n+            # Try to collect terms with exp(I*something) and exp(-I*something)\n+            from sympy import collect, Add\n+            if isinstance(expanded, Add):\n+                terms = expanded.args\n+                exp_terms = {}\n+                other_terms = []\n+                \n+                for term in terms:\n+                    if term.has(exp):\n+                        # Look for exp(I*arg) or exp(-I*arg) patterns\n+                        from sympy import factor_terms\n+                        factored = factor_terms(term)\n+                        \n+                        # Extract coefficient and exponential part\n+                        if factored.has(exp):\n+                            from sympy import collect\n+                            exp_part = None\n+                            coeff = S.One\n+                            \n+                            if factored.is_Mul:\n+                                exp_factors = []\n+                                other_factors = []\n+                                for f in factored.args:\n+                                    if f.has(exp):\n+                                        exp_factors.append(f)\n+                                    else:\n+                                        other_factors.append(f)\n+                                if len(exp_factors) == 1:\n+                                    exp_part = exp_factors[0]\n+                                    coeff = Mul(*other_factors) if other_factors else S.One\n+                            elif factored.func == exp:\n+                                exp_part = factored\n+                                coeff = S.One\n+                                \n+                            if exp_part and exp_part.func == exp:\n+                                arg = exp_part.args[0]\n+                                if arg.has(I):\n+                                    # Check if it's I*something or -I*something\n+                                    if arg.is_Mul and I in arg.args:\n+                                        i_coeff = S.One\n+                                        real_part = S.One\n+                                        for factor in arg.args:\n+                                            if factor == I:\n+                                                continue\n+                                            elif factor == -I:\n+                                                i_coeff = -S.One\n+                                                continue\n+                                            else:\n+                                                real_part *= factor\n+                                        \n+                                        key = real_part\n+                                        if key not in exp_terms:\n+                                            exp_terms[key] = {}\n+                                        if i_coeff == S.One:\n+                                            exp_terms[key]['pos'] = coeff\n+                                        else:\n+                                            exp_terms[key]['neg'] = coeff\n+                                    elif arg == I*arg.args[0] if arg.is_Mul else False:\n+                                        # Handle I*x case\n+                                        real_arg = arg/I\n+                                        if real_arg not in exp_terms:\n+                                            exp_terms[real_arg] = {}\n+                                        exp_terms[real_arg]['pos'] = coeff\n+                                    elif arg == -I*arg.args[0] if arg.is_Mul else False:\n+                                        # Handle -I*x case  \n+                                        real_arg = -arg/I\n+                                        if real_arg not in exp_terms:\n+                                            exp_terms[real_arg] = {}\n+                                        exp_terms[real_arg]['neg'] = coeff\n+                        \n+                        if not exp_part:\n+                            other_terms.append(term)\n+                    else:\n+                        other_terms.append(term)\n+                \n+                # Now check for trigonometric patterns\n+                new_terms = list(other_terms)\n+                for arg, coeffs in exp_terms.items():\n+                    if 'pos' in coeffs and 'neg' in coeffs:\n+                        pos_coeff = coeffs['pos']\n+                        neg_coeff = coeffs['neg']\n+                        \n+                        # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n+                        if pos_coeff == -neg_coeff and pos_coeff == -I/2:\n+                            new_terms.append(sin(arg))\n+                            continue\n+                        elif pos_coeff == -neg_coeff and neg_coeff == -I/2:\n+                            new_terms.append(-sin(arg))\n+                            continue\n+                        # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x))\n+                        elif pos_coeff == neg_coeff and pos_coeff == S.Half:\n+                            new_terms.append(cos(arg))\n+                            continue\n+                        # Check for more general patterns\n+                        elif pos_coeff == neg_coeff:\n+                            # cos-like pattern with different coefficient\n+                            new_terms.append(2*pos_coeff*cos(arg))\n+                            continue\n+                        elif pos_coeff == -neg_coeff:\n+                            # sin-like pattern with different coefficient  \n+                            new_terms.append(2*pos_coeff*sin(arg)/(-I))\n+                            continue\n+                    \n+                    # If no pattern matched, keep original terms\n+                    if 'pos' in coeffs:\n+                        new_terms.append(coeffs['pos']*exp(I*arg))\n+                    if 'neg' in coeffs:\n+                        new_terms.append(coeffs['neg']*exp(-I*arg))\n+                \n+                if len(new_terms) != len(terms):\n+                    return Add(*new_terms)\n+        \n+        return expr\n+    \n+    newexpr = convert_complex_exp_to_trig(newexpr)\n+\n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n",
    "variant_1": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..64c28b5b91 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -425,6 +425,7 @@ def analyse_gens(gens, hints):\n _trigs = (TrigonometricFunction, HyperbolicFunction)\n \n \n+\n def trigsimp(expr, **opts):\n     \"\"\"\n     reduces expression by using known trig identities\n@@ -434,14 +435,15 @@ def trigsimp(expr, **opts):\n \n     method:\n     - Determine the method to use. Valid choices are 'matching' (default),\n-    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n+    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n     expression recursively by targeting common patterns. If 'groebner', apply\n     an experimental groebner basis algorithm. In this case further options\n     are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n     If 'combined', first run the groebner basis algorithm with small\n     default parameters, then run the 'matching' algorithm. 'fu' runs the\n     collection of trigonometric transformations described by Fu, et al.\n-    (see the `fu` docstring).\n+    (see the `fu` docstring). 'old' runs the 'matching' algorithm followed\n+    by experimental exponential-to-trigonometric simplification.\n \n \n     Examples\n@@ -513,6 +515,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -538,15 +541,67 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        \n+        # Try to convert complex exponential patterns to trigonometric functions\n+        if e.has(exp):\n+            # Check for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+            # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+            try:\n+                from sympy import collect, expand\n+                expanded = expand(e)\n+                # Try rewriting in terms of sin/cos if it contains complex exponentials\n+                sin_cos_form = expanded.rewrite(sin)\n+                if sin_cos_form != expanded:\n+                    choices.append(sin_cos_form)\n+                cos_form = expanded.rewrite(cos)\n+                if cos_form != expanded:\n+                    choices.append(cos_form)\n+            except:\n+                pass\n+        \n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n+def exp_trig(e):\n+    # select the better of e, and e rewritten in terms of exp or trig\n+    # functions\n+    choices = [e]\n+    if e.has(*_trigs):\n+        choices.append(e.rewrite(exp))\n+    choices.append(e.rewrite(cos))\n+    \n+    # Check for complex exponential patterns that can be converted to trig functions\n+    if e.has(exp):\n+        # Try to convert complex exponential expressions to trigonometric form\n+        from sympy import re, im, simplify\n+        try:\n+            # Convert complex exponentials to trig functions using Euler's formula\n+            trig_form = e.rewrite(sin).rewrite(cos)\n+            if trig_form != e and not trig_form.has(exp):\n+                choices.append(trig_form)\n+        except:\n+            pass\n+    \n+    return min(*choices, key=count_ops)\n+    newexpr = bottom_up(expr, exp_trig)\n+\n     def f(rv):\n         if not rv.is_Mul:\n             return rv\n         rvd = rv.as_powers_dict()\n         newd = rvd.copy()\n \n+        def signlog(expr, sign=1):\n+            if expr is S.Exp1:\n+                return sign, 1\n+            elif isinstance(expr, exp):\n+                return sign, expr.args[0]\n+            elif sign == 1:\n+                return signlog(-expr, sign=-1)\n+            else:\n+                return None, None\n+\n+\n         def signlog(expr, sign=1):\n             if expr is S.Exp1:\n                 return sign, 1\n@@ -585,6 +640,57 @@ def signlog(expr, sign=1):\n                 else:\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n+            elif k.is_Mul and len(k.args) == 2:\n+                # Check for complex exponential patterns: c*I*exp(I*x) or c*I*exp(-I*x)\n+                c_factor = k.args[0]\n+                exp_factor = k.args[1]\n+                if (isinstance(exp_factor, exp) and exp_factor.args[0].has(I) and\n+                    c_factor.has(I)):\n+                    # Extract the argument of the exponential\n+                    exp_arg = exp_factor.args[0]\n+                    # Check if we have a pattern like I*x or -I*x\n+                    if exp_arg.as_coeff_Mul()[0] == I:\n+                        x = exp_arg.as_coeff_Mul()[1]\n+                        # Look for the conjugate term\n+                        conjugate_key = c_factor.conjugate() * exp(-I*x)\n+                        if conjugate_key in rvd and rvd[conjugate_key] == rvd[k]:\n+                            m = rvd[k]\n+                            # Remove both terms\n+                            newd[k] -= m\n+                            newd[conjugate_key] -= m\n+                            # Convert to trigonometric function\n+                            if c_factor == -I/2:\n+                                # sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+                                newd[sin(x)] += m\n+                            elif c_factor == S.Half:\n+                                # cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+                                newd[cos(x)] += m\n+                    elif exp_arg.as_coeff_Mul()[0] == -I:\n+                        x = exp_arg.as_coeff_Mul()[1]\n+                        # Look for the conjugate term\n+                        conjugate_key = c_factor.conjugate() * exp(I*x)\n+                        if conjugate_key in rvd and rvd[conjugate_key] == rvd[k]:\n+                            m = rvd[k]\n+                            # Remove both terms\n+                            newd[k] -= m\n+                            newd[conjugate_key] -= m\n+                            # Convert to trigonometric function\n+                            if c_factor == I/2:\n+                                # sin pattern: I/2*(exp(-I*x) - exp(I*x)) = -sin(x)\n+                                newd[-sin(x)] += m\n+                            elif c_factor == S.Half:\n+                                # cos pattern: 1/2*(exp(-I*x) + exp(I*x)) = cos(x)\n+                                newd[cos(x)] += m\n+        return Mul(*[k**newd[k] for k in newd])\n+    newexpr = bottom_up(newexpr, f)\n+\n+    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n+                    else:\n+                        newd[-c*tanh(x/2)] += m\n+                else:\n+                    newd[1 + sign*S.Exp1**x] += m\n+                    newd[c] += m\n \n         return Mul(*[k**newd[k] for k in newd])\n     newexpr = bottom_up(newexpr, f)\n@@ -596,6 +702,90 @@ def signlog(expr, sign=1):\n     if newexpr.has(TrigonometricFunction):\n         newexpr = TR2i(newexpr)\n \n+    # Handle complex exponential patterns for trigonometric functions\n+    def convert_complex_exp_to_trig(expr):\n+        \"\"\"Convert complex exponential patterns to trigonometric functions.\"\"\"\n+        if not expr.has(exp):\n+            return expr\n+        \n+        # Look for patterns like I*exp(I*x) - I*exp(-I*x) = 2*sin(x)\n+        # and exp(I*x) + exp(-I*x) = 2*cos(x)\n+        from sympy import Wild, collect\n+        from sympy.functions import sin, cos\n+        \n+        x = Wild('x')\n+        c = Wild('c')\n+        \n+        # Pattern for sin: -I/2*(exp(I*x) - exp(-I*x)) or I/2*(exp(-I*x) - exp(I*x))\n+        # More generally: c*I*exp(I*x) - c*I*exp(-I*x) = 2*c*I*sin(x)\n+        expr_expanded = expand_mul(expr)\n+        \n+        # Collect terms with exp\n+        terms = expr_expanded.as_ordered_terms()\n+        exp_terms = {}\n+        \n+        for term in terms:\n+            if term.has(exp):\n+                # Extract coefficient and exponential part\n+                coeff = S.One\n+                exp_part = None\n+                for factor in term.as_ordered_factors():\n+                    if factor.has(exp):\n+                        exp_part = factor\n+                    else:\n+                        coeff *= factor\n+                \n+                if exp_part:\n+                    # Check if it's of the form exp(I*something) or exp(-I*something)\n+                    arg = exp_part.args[0]\n+                    if arg.has(I):\n+                        # Separate I and the rest\n+                        if arg == I*arg/I:  # arg is purely imaginary\n+                            real_arg = arg/I\n+                            if real_arg not in exp_terms:\n+                                exp_terms[real_arg] = {'pos': S.Zero, 'neg': S.Zero}\n+                            exp_terms[real_arg]['pos'] += coeff\n+                        elif arg == -I*(-arg/I):  # arg is negative imaginary\n+                            real_arg = -arg/I\n+                            if real_arg not in exp_terms:\n+                                exp_terms[real_arg] = {'pos': S.Zero, 'neg': S.Zero}\n+                            exp_terms[real_arg]['neg'] += coeff\n+        \n+        # Convert matching patterns to trigonometric functions\n+        new_terms = list(terms)\n+        for real_arg, coeffs in exp_terms.items():\n+            pos_coeff = coeffs['pos']\n+            neg_coeff = coeffs['neg']\n+            \n+            if pos_coeff != S.Zero and neg_coeff != S.Zero:\n+                # Check for sin pattern: I*c*exp(I*x) - I*c*exp(-I*x)\n+                if pos_coeff == -neg_coeff and pos_coeff.has(I):\n+                    # This is a sin pattern\n+                    sin_coeff = pos_coeff / I / 2  # Since sin(x) = (exp(I*x) - exp(-I*x))/(2*I)\n+                    sin_term = 2 * sin_coeff * sin(real_arg)\n+                    \n+                    # Remove the original exponential terms\n+                    new_terms = [t for t in new_terms if not (\n+                        t.has(exp(I*real_arg)) or t.has(exp(-I*real_arg))\n+                    )]\n+                    new_terms.append(sin_term)\n+                \n+                # Check for cos pattern: c*exp(I*x) + c*exp(-I*x)\n+                elif pos_coeff == neg_coeff and not pos_coeff.has(I):\n+                    # This is a cos pattern\n+                    cos_coeff = pos_coeff / 2  # Since cos(x) = (exp(I*x) + exp(-I*x))/2\n+                    cos_term = 2 * cos_coeff * cos(real_arg)\n+                    \n+                    # Remove the original exponential terms\n+                    new_terms = [t for t in new_terms if not (\n+                        t.has(exp(I*real_arg)) or t.has(exp(-I*real_arg))\n+                    )]\n+                    new_terms.append(cos_term)\n+        \n+        return Add(*new_terms) if new_terms else expr\n+    \n+    newexpr = convert_complex_exp_to_trig(newexpr)\n+\n     # can we ever generate an I where there was none previously?\n     if not (newexpr.has(I) and not expr.has(I)):\n         expr = newexpr\n",
    "variant_2": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..cec9c3abbf 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -425,6 +425,7 @@ def analyse_gens(gens, hints):\n _trigs = (TrigonometricFunction, HyperbolicFunction)\n \n \n+\n def trigsimp(expr, **opts):\n     \"\"\"\n     reduces expression by using known trig identities\n@@ -434,14 +435,14 @@ def trigsimp(expr, **opts):\n \n     method:\n     - Determine the method to use. Valid choices are 'matching' (default),\n-    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n+    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n     expression recursively by targeting common patterns. If 'groebner', apply\n     an experimental groebner basis algorithm. In this case further options\n     are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n     If 'combined', first run the groebner basis algorithm with small\n     default parameters, then run the 'matching' algorithm. 'fu' runs the\n     collection of trigonometric transformations described by Fu, et al.\n-    (see the `fu` docstring).\n+    (see the `fu` docstring). 'old' runs the original trigsimp.\n \n \n     Examples\n@@ -513,6 +514,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -520,13 +522,17 @@ def exptrigsimp(expr):\n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n     >>> from sympy.abc import z\n \n     >>> exptrigsimp(exp(z) + exp(-z))\n     2*cosh(z)\n     >>> exptrigsimp(cosh(z) - sinh(z))\n     exp(-z)\n+    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n+    sin(z)\n+    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n+    cos(z)\n     \"\"\"\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n@@ -538,15 +544,63 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        \n+        # Try to convert complex exponential patterns to trigonometric functions\n+        from sympy import Add, Mul, exp, sin, cos, I\n+        if isinstance(e, (Add, Mul)) and e.has(exp):\n+            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+            # or cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+            trig_form = e.rewrite(sin)\n+            if trig_form != e:\n+                choices.append(trig_form)\n+        \n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n+def exp_trig(e):\n+    # select the better of e, and e rewritten in terms of exp or trig\n+    # functions\n+    choices = [e]\n+    if e.has(*_trigs):\n+        choices.append(e.rewrite(exp))\n+    \n+    # Check for complex exponential patterns that can be converted to trig functions\n+    if e.has(exp):\n+        # Try to recognize and convert exp(I*x) patterns to trig functions\n+        from sympy import I, Wild, collect, expand\n+        x = Wild('x')\n+        \n+        # Look for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+        # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+        expanded = expand(e)\n+        \n+        # Try rewriting in terms of sin/cos if we have complex exponentials\n+        if expanded.has(I) and expanded.has(exp):\n+            trig_form = expanded.rewrite(sin).rewrite(cos)\n+            if trig_form != expanded:\n+                choices.append(trig_form)\n+    \n+    choices.append(e.rewrite(cos))\n+    return min(*choices, key=count_ops)\n+    newexpr = bottom_up(expr, exp_trig)\n+\n     def f(rv):\n         if not rv.is_Mul:\n             return rv\n         rvd = rv.as_powers_dict()\n         newd = rvd.copy()\n \n+        def signlog(expr, sign=1):\n+            if expr is S.Exp1:\n+                return sign, 1\n+            elif isinstance(expr, exp):\n+                return sign, expr.args[0]\n+            elif sign == 1:\n+                return signlog(-expr, sign=-1)\n+            else:\n+                return None, None\n+\n+\n         def signlog(expr, sign=1):\n             if expr is S.Exp1:\n                 return sign, 1\n@@ -585,10 +639,107 @@ def signlog(expr, sign=1):\n                 else:\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n+            elif k.is_Mul and len(k.args) == 2:\n+                # Handle complex exponential patterns for trigonometric functions\n+                # Look for patterns like I*exp(I*x) or -I*exp(-I*x)\n+                coeff, exp_part = k.args\n+                if isinstance(exp_part, exp) and exp_part.args[0].has(I):\n+                    # Check if we have a matching pair for sin/cos patterns\n+                    x_arg = exp_part.args[0]\n+                    if x_arg.is_Mul and x_arg.args[0] == I:\n+                        # exp(I*x) case\n+                        x = x_arg.args[1]\n+                        neg_exp_key = None\n+                        pos_exp_key = k\n+                        \n+                        # Look for the corresponding exp(-I*x) term\n+                        for other_k in rvd:\n+                            if (other_k.is_Mul and len(other_k.args) == 2 and\n+                                isinstance(other_k.args[1], exp)):\n+                                other_coeff, other_exp = other_k.args\n+                                if (other_exp.args[0] == -I*x and \n+                                    rvd[other_k] == rvd[k]):\n+                                    neg_exp_key = other_k\n+                                    break\n+                        \n+                        if neg_exp_key:\n+                            m = rvd[k]\n+                            # Remove both exponential terms\n+                            newd[pos_exp_key] -= m\n+                            newd[neg_exp_key] -= m\n+                            \n+                            pos_coeff = coeff\n+                            neg_coeff = neg_exp_key.args[0]\n+                            \n+                            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n+                            if pos_coeff == -I/2 and neg_coeff == I/2:\n+                                newd[sin(x)] += m\n+                            elif pos_coeff == I/2 and neg_coeff == -I/2:\n+                                newd[-sin(x)] += m\n+                            # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x))\n+                            elif pos_coeff == S.Half and neg_coeff == S.Half:\n+                                newd[cos(x)] += m\n+                            elif pos_coeff == -S.Half and neg_coeff == -S.Half:\n+                                newd[-cos(x)] += m\n+                            # Handle scaled versions (like sinc pattern)\n+                            elif (pos_coeff/(-I/2)).is_real and (neg_coeff/(I/2)).is_real:\n+                                scale = pos_coeff/(-I/2)\n+                                if scale == neg_coeff/(I/2):\n+                                    newd[scale*sin(x)] += m\n+                            elif (pos_coeff/(S.Half)).is_real and (neg_coeff/(S.Half)).is_real:\n+                                scale = pos_coeff/(S.Half)\n+                                if scale == neg_coeff/(S.Half):\n+                                    newd[scale*cos(x)] += m\n+                            else:\n+                                # Restore if no pattern matched\n+                                newd[pos_exp_key] += m\n+                                newd[neg_exp_key] += m\n \n         return Mul(*[k**newd[k] for k in newd])\n+        return Mul(*[k**newd[k] for k in newd])\n     newexpr = bottom_up(newexpr, f)\n \n+    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n+                    else:\n+                        newd[-c*tanh(x/2)] += m\n+                else:\n+                    newd[1 + sign*S.Exp1**x] += m\n+                    newd[c] += m\n+\n+        return Mul(*[k**newd[k] for k in newd])\n+    newexpr = bottom_up(newexpr, f)\n+\n+    # Handle complex exponential patterns for trigonometric functions\n+    def convert_complex_exp_to_trig(expr):\n+        \"\"\"Convert complex exponential patterns to trigonometric functions.\"\"\"\n+        if expr.is_Mul:\n+            args = expr.args\n+            # Look for patterns like c * (exp(I*x) Â± exp(-I*x))\n+            for i, arg in enumerate(args):\n+                if arg.is_Add and len(arg.args) == 2:\n+                    a, b = arg.args\n+                    # Check for exp(I*x) - exp(-I*x) pattern (sin)\n+                    if (a.is_Pow and a.base == S.Exp1 and \n+                        b.is_Pow and b.base == S.Exp1 and\n+                        a.exp.has(I) and b.exp.has(I)):\n+                        \n+                        # Extract the argument\n+                        if a.exp == I*b.exp.args[1] and b.exp.args[0] == -I:\n+                            x = a.exp.args[1]\n+                            coeff = Mul(*[args[j] for j in range(len(args)) if j != i])\n+                            \n+                            # Check for sin pattern: -I/2 * (exp(I*x) - exp(-I*x))\n+                            if coeff == -I/2:\n+                                return sin(x)\n+                            # Check for cos pattern: 1/2 * (exp(I*x) + exp(-I*x))\n+                            elif coeff == S.Half and a.exp == b.exp.replace(I, -I):\n+                                return cos(x)\n+        \n+        return expr\n+\n+    newexpr = bottom_up(newexpr, convert_complex_exp_to_trig)\n+\n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n",
    "variant_3": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..9c421867ba 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -425,6 +425,7 @@ def analyse_gens(gens, hints):\n _trigs = (TrigonometricFunction, HyperbolicFunction)\n \n \n+\n def trigsimp(expr, **opts):\n     \"\"\"\n     reduces expression by using known trig identities\n@@ -443,6 +444,8 @@ def trigsimp(expr, **opts):\n     collection of trigonometric transformations described by Fu, et al.\n     (see the `fu` docstring).\n \n+    deep:\n+    - Apply simplification to all levels of the expression tree.\n \n     Examples\n     ========\n@@ -461,6 +464,71 @@ def trigsimp(expr, **opts):\n     Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n     simplification.\n \n+    The old `trigsimp` routine can be accessed as with method 'old'.\n+\n+    >>> from sympy import coth, tanh\n+    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n+    >>> trigsimp(t, method='old') == t\n+    True\n+    >>> trigsimp(t)\n+    tanh(x)**7\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+\n+        if recursive:\n+            w, g = cse(expr)\n+            g = trigsimp_groebner(g[0], **opts)\n+\n+            for sub in reversed(w):\n+                g = g.subs(sub[0], sub[1])\n+                g = trigsimp_groebner(g, **opts)\n+            result = g\n+        elif method == 'matching':\n+            result = futrig(expr)\n+        elif method == 'groebner':\n+            result = trigsimp_groebner(expr, **opts)\n+        elif method == 'combined':\n+            result = trigsimp_groebner(expr, polynomial=True, hints=[2, tan])\n+            if result is not None:\n+                result = futrig(result)\n+            else:\n+                result = futrig(expr)\n+        elif method == 'fu':\n+            result = fu(expr, **opts)\n+        else:\n+            raise ValueError(\n+                \"Unknown method %s. Should be one of 'matching', \"\n+                \"'groebner', 'combined', 'fu' or 'old'.\" % method)\n+    else:\n+        result = trigsimp_old(expr, **opts)\n+\n+    return result\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+\n+    Simplification occurs wherever trigonometric functions are located.\n+\n+    >>> trigsimp(log(e))\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n     The old trigsimp routine can be accessed as with method 'old'.\n \n     >>> from sympy import coth, tanh\n@@ -513,6 +581,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -520,13 +589,17 @@ def exptrigsimp(expr):\n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n     >>> from sympy.abc import z\n \n     >>> exptrigsimp(exp(z) + exp(-z))\n     2*cosh(z)\n     >>> exptrigsimp(cosh(z) - sinh(z))\n     exp(-z)\n+    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n+    sin(z)\n+    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n+    cos(z)\n     \"\"\"\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n@@ -538,6 +611,81 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        \n+        # Try to convert complex exponential patterns to trigonometric functions\n+        from sympy import Add, Mul, exp, sin, cos, I\n+        if isinstance(e, Add):\n+            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+            # or I/2*(exp(-I*x) - exp(I*x)) = sin(x)\n+            terms = e.as_ordered_terms()\n+            if len(terms) == 2:\n+                t1, t2 = terms\n+                # Extract coefficients and exponential parts\n+                from sympy import collect\n+                from sympy.core.mul import _keep_coeff\n+                \n+                # Check if we have the form a*exp(I*x) + b*exp(-I*x)\n+                exp_terms = {}\n+                for term in [t1, t2]:\n+                    if term.has(exp):\n+                        for arg in term.find(exp):\n+                            exp_arg = arg.args[0]\n+                            coeff = term.coeff(arg)\n+                            if coeff is not None:\n+                                exp_terms[exp_arg] = exp_terms.get(exp_arg, 0) + coeff\n+                \n+                # Look for patterns like I*x and -I*x\n+                for arg1 in exp_terms:\n+                    arg2 = -arg1\n+                    if arg2 in exp_terms:\n+                        c1, c2 = exp_terms[arg1], exp_terms[arg2]\n+                        # Check for sin pattern: coefficient of exp(I*x) is -I*c, exp(-I*x) is I*c\n+                        if c1 == -I*c2 and c1.is_real is False:\n+                            # Extract the real argument\n+                            if arg1.has(I):\n+                                real_arg = (arg1/I).simplify()\n+                                if real_arg.is_real is not False:\n+                                    sin_form = sin(real_arg) * (-2*I*c2)\n+                                    choices.append(sin_form)\n+                        # Check for cos pattern: coefficient of exp(I*x) equals coefficient of exp(-I*x)\n+                        elif c1 == c2:\n+                            if arg1.has(I):\n+                                real_arg = (arg1/I).simplify()\n+                                if real_arg.is_real is not False:\n+                                    cos_form = cos(real_arg) * (2*c1)\n+                                    choices.append(cos_form)\n+        \n+        return min(*choices, key=count_ops)\n+    newexpr = bottom_up(expr, exp_trig)\n+\n+    def exp_trig(e):\n+        # select the better of e, and e rewritten in terms of exp or trig\n+        # functions\n+        choices = [e]\n+        if e.has(*_trigs):\n+            choices.append(e.rewrite(exp))\n+        choices.append(e.rewrite(cos))\n+        \n+        # Try to recognize exponential patterns that can be converted to trig functions\n+        # Handle complex exponential patterns for sin/cos conversion\n+        if e.has(exp):\n+            from sympy import I, re, im, simplify\n+            try:\n+                # Try to convert complex exponential expressions to trigonometric form\n+                exp_to_trig = e.rewrite(sin).rewrite(cos)\n+                if exp_to_trig != e and not exp_to_trig.has(exp):\n+                    choices.append(exp_to_trig)\n+                \n+                # Also try hyperbolic to trigonometric conversion for complex args\n+                if e.has(I):\n+                    hyp_form = e.rewrite(cosh).rewrite(sinh)\n+                    if hyp_form != e:\n+                        trig_form = hyper_as_trig(hyp_form)\n+                        if trig_form != hyp_form:\n+                            choices.append(trig_form)\n+            except:\n+                pass\n+        \n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n@@ -557,10 +705,11 @@ def signlog(expr, sign=1):\n             else:\n                 return None, None\n \n+\n         ee = rvd[S.Exp1]\n         for k in rvd:\n             if k.is_Add and len(k.args) == 2:\n-                # k == c*(1 + sign*E**x)\n+                # k == c*(1 + sign*E**x) for hyperbolic functions\n                 c = k.args[0]\n                 sign, x = signlog(k.args[1]/c)\n                 if not x:\n@@ -585,10 +734,164 @@ def signlog(expr, sign=1):\n                 else:\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n+            elif k.is_Mul and len(k.args) == 2:\n+                # Check for complex exponential patterns: c*exp(I*x) or c*exp(-I*x)\n+                coeff, exp_part = k.args\n+                if isinstance(exp_part, exp) and exp_part.args[0].has(I):\n+                    arg = exp_part.args[0]\n+                    # Check if we have a pair exp(I*x) and exp(-I*x) with appropriate coefficients\n+                    if arg.is_Mul and arg.args[0] == I:\n+                        x = arg.args[1]\n+                        # Look for the conjugate term\n+                        conj_key = coeff * exp(-I*x)\n+                        if conj_key in rvd:\n+                            m1 = rvd[k]\n+                            m2 = rvd[conj_key]\n+                            if m1 == m2:  # Same multiplicity\n+                                newd[k] -= m1\n+                                newd[conj_key] -= m2\n+                                # Apply Euler's formulas\n+                                if coeff == I/2:\n+                                    # I/2 * (exp(I*x) - exp(-I*x)) = sin(x)\n+                                    newd[sin(x)] += m1\n+                                elif coeff == -I/2:\n+                                    # -I/2 * (exp(I*x) - exp(-I*x)) = -sin(x)\n+                                    newd[-sin(x)] += m1\n+                                elif coeff == S.Half:\n+                                    # 1/2 * (exp(I*x) + exp(-I*x)) = cos(x)\n+                                    newd[cos(x)] += m1\n+                                elif coeff == -S.Half:\n+                                    # -1/2 * (exp(I*x) + exp(-I*x)) = -cos(x)\n+                                    newd[-cos(x)] += m1\n+                    elif arg.is_Mul and len(arg.args) == 2 and arg.args[0] == -I:\n+                        x = arg.args[1]\n+                        # Look for the conjugate term\n+                        conj_key = coeff * exp(I*x)\n+                        if conj_key in rvd:\n+                            m1 = rvd[k]\n+                            m2 = rvd[conj_key]\n+                            if m1 == m2:  # Same multiplicity\n+                                newd[k] -= m1\n+                                newd[conj_key] -= m2\n+                                # Apply Euler's formulas\n+                                if coeff == -I/2:\n+                                    # -I/2 * (exp(-I*x) - exp(I*x)) = sin(x)\n+                                    newd[sin(x)] += m1\n+                                elif coeff == I/2:\n+                                    # I/2 * (exp(-I*x) - exp(I*x)) = -sin(x)\n+                                    newd[-sin(x)] += m1\n+                                elif coeff == S.Half:\n+                                    # 1/2 * (exp(-I*x) + exp(I*x)) = cos(x)\n+                                    newd[cos(x)] += m1\n+                                elif coeff == -S.Half:\n+                                    # -1/2 * (exp(-I*x) + exp(I*x)) = -cos(x)\n+                                    newd[-cos(x)] += m1\n+        return Mul(*[k**newd[k] for k in newd])\n+    newexpr = bottom_up(newexpr, f)\n+\n+    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n+                    else:\n+                        newd[-c*tanh(x/2)] += m\n+                else:\n+                    newd[1 + sign*S.Exp1**x] += m\n+                    newd[c] += m\n \n         return Mul(*[k**newd[k] for k in newd])\n     newexpr = bottom_up(newexpr, f)\n \n+    # Handle complex exponential patterns for trigonometric functions\n+    def handle_complex_exp(expr):\n+        \"\"\"Convert complex exponential patterns to trigonometric functions\"\"\"\n+        if not expr.has(exp):\n+            return expr\n+            \n+        from sympy import collect, I, exp, sin, cos\n+        \n+        # Look for patterns like c1*exp(I*x) + c2*exp(-I*x)\n+        def find_trig_patterns(e):\n+            if e.is_Add:\n+                args = e.args\n+                exp_terms = {}\n+                other_terms = []\n+                \n+                for arg in args:\n+                    if arg.has(exp):\n+                        # Extract coefficient and exponential part\n+                        coeff = S.One\n+                        exp_part = arg\n+                        if arg.is_Mul:\n+                            exp_part = None\n+                            for factor in arg.args:\n+                                if factor.has(exp):\n+                                    exp_part = factor\n+                                    coeff = arg / factor\n+                                    break\n+                        \n+                        if exp_part and exp_part.func == exp:\n+                            exp_arg = exp_part.args[0]\n+                            # Check for I*x pattern\n+                            if exp_arg.has(I):\n+                                # Extract the real part (x) from I*x\n+                                if exp_arg.is_Mul and I in exp_arg.args:\n+                                    real_part = exp_arg / I\n+                                    if real_part not in exp_terms:\n+                                        exp_terms[real_part] = {}\n+                                    exp_terms[real_part]['pos'] = exp_terms[real_part].get('pos', 0) + coeff\n+                                elif (-exp_arg).is_Mul and I in (-exp_arg).args:\n+                                    real_part = (-exp_arg) / I\n+                                    if real_part not in exp_terms:\n+                                        exp_terms[real_part] = {}\n+                                    exp_terms[real_part]['neg'] = exp_terms[real_part].get('neg', 0) + coeff\n+                            else:\n+                                other_terms.append(arg)\n+                        else:\n+                            other_terms.append(arg)\n+                    else:\n+                        other_terms.append(arg)\n+                \n+                # Convert matching exponential pairs to trig functions\n+                trig_terms = []\n+                for x, coeffs in exp_terms.items():\n+                    pos_coeff = coeffs.get('pos', 0)\n+                    neg_coeff = coeffs.get('neg', 0)\n+                    \n+                    # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n+                    if pos_coeff == -neg_coeff and pos_coeff != 0:\n+                        if pos_coeff == -I/2:\n+                            trig_terms.append(sin(x))\n+                        elif pos_coeff == I/2:\n+                            trig_terms.append(-sin(x))\n+                        else:\n+                            # General case: c*(-I/2)*(exp(I*x) - exp(-I*x)) = c*sin(x)\n+                            c = pos_coeff / (-I/2)\n+                            trig_terms.append(c * sin(x))\n+                    \n+                    # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x))\n+                    elif pos_coeff == neg_coeff and pos_coeff != 0:\n+                        if pos_coeff == S.Half:\n+                            trig_terms.append(cos(x))\n+                        else:\n+                            # General case: c*(1/2)*(exp(I*x) + exp(-I*x)) = c*cos(x)\n+                            c = pos_coeff / S.Half\n+                            trig_terms.append(c * cos(x))\n+                    \n+                    # If no pattern matches, keep original terms\n+                    else:\n+                        if pos_coeff != 0:\n+                            other_terms.append(pos_coeff * exp(I*x))\n+                        if neg_coeff != 0:\n+                            other_terms.append(neg_coeff * exp(-I*x))\n+                \n+                if trig_terms:\n+                    return Add(*(trig_terms + other_terms))\n+            \n+            return e\n+        \n+        return bottom_up(expr, find_trig_patterns)\n+    \n+    newexpr = handle_complex_exp(newexpr)\n+\n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n",
    "variant_4": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..03d2b2a0b7 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -425,6 +425,7 @@ def analyse_gens(gens, hints):\n _trigs = (TrigonometricFunction, HyperbolicFunction)\n \n \n+\n def trigsimp(expr, **opts):\n     \"\"\"\n     reduces expression by using known trig identities\n@@ -434,15 +435,18 @@ def trigsimp(expr, **opts):\n \n     method:\n     - Determine the method to use. Valid choices are 'matching' (default),\n-    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n+    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n     expression recursively by targeting common patterns. If 'groebner', apply\n     an experimental groebner basis algorithm. In this case further options\n     are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n     If 'combined', first run the groebner basis algorithm with small\n     default parameters, then run the 'matching' algorithm. 'fu' runs the\n     collection of trigonometric transformations described by Fu, et al.\n-    (see the `fu` docstring).\n+    (see the `fu` docstring). 'old' runs the old trigsimp routine.\n \n+    compare:\n+    - show input and output from `trigsimp` and `futrig` when different,\n+    but returns the `trigsimp` result.\n \n     Examples\n     ========\n@@ -513,6 +517,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -520,13 +525,17 @@ def exptrigsimp(expr):\n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n     >>> from sympy.abc import z\n \n     >>> exptrigsimp(exp(z) + exp(-z))\n     2*cosh(z)\n     >>> exptrigsimp(cosh(z) - sinh(z))\n     exp(-z)\n+    >>> exptrigsimp(-I/2*(exp(I*z) - exp(-I*z)))\n+    sin(z)\n+    >>> exptrigsimp(1/2*(exp(I*z) + exp(-I*z)))\n+    cos(z)\n     \"\"\"\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n@@ -538,15 +547,83 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        \n+        # Try to convert complex exponential patterns to trigonometric functions\n+        from sympy import Add, Mul, exp, I, sin, cos\n+        if isinstance(e, (Add, Mul)) and e.has(exp):\n+            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n+            # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x))\n+            try:\n+                expanded = e.expand()\n+                choices.append(expanded.rewrite(sin))\n+                choices.append(expanded.rewrite(cos))\n+            except:\n+                pass\n+        \n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n+def exp_trig(e):\n+    # select the better of e, and e rewritten in terms of exp or trig\n+    # functions\n+    choices = [e]\n+    if e.has(*_trigs):\n+        choices.append(e.rewrite(exp))\n+    choices.append(e.rewrite(cos))\n+    \n+    # Try to recognize exponential patterns that can be converted to trig functions\n+    # Look for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+    # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+    from sympy import I, exp, sin, cos, Add, Mul\n+    if e.is_Mul and e.has(exp):\n+        # Check if this looks like a trig function in exponential form\n+        args = e.args\n+        if len(args) >= 2:\n+            coeff = S.One\n+            exp_part = S.One\n+            for arg in args:\n+                if arg.has(exp):\n+                    exp_part *= arg\n+                else:\n+                    coeff *= arg\n+            \n+            if exp_part.is_Add and len(exp_part.args) == 2:\n+                exp1, exp2 = exp_part.args\n+                if (exp1.is_Pow and exp1.base == exp and \n+                    exp2.is_Pow and exp2.base == exp):\n+                    arg1 = exp1.exp\n+                    arg2 = exp2.exp\n+                    # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x))\n+                    if (coeff == -I/2 and arg1 == -arg2 and \n+                        arg1.has(I) and arg1/I == -arg2/I):\n+                        x = arg1/I\n+                        choices.append(sin(x))\n+                    # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x))\n+                    elif (coeff == S.Half and arg1 == -arg2 and \n+                          arg1.has(I) and arg1/I == -arg2/I):\n+                        x = arg1/I\n+                        choices.append(cos(x))\n+    \n+    return min(*choices, key=count_ops)\n+    newexpr = bottom_up(expr, exp_trig)\n+\n     def f(rv):\n         if not rv.is_Mul:\n             return rv\n         rvd = rv.as_powers_dict()\n         newd = rvd.copy()\n \n+        def signlog(expr, sign=1):\n+            if expr is S.Exp1:\n+                return sign, 1\n+            elif isinstance(expr, exp):\n+                return sign, expr.args[0]\n+            elif sign == 1:\n+                return signlog(-expr, sign=-1)\n+            else:\n+                return None, None\n+\n+\n         def signlog(expr, sign=1):\n             if expr is S.Exp1:\n                 return sign, 1\n@@ -585,10 +662,35 @@ def signlog(expr, sign=1):\n                 else:\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n-\n+            elif k.is_Mul and len(k.args) == 2:\n+                # Check for complex exponential patterns: c*I*exp(I*x) terms\n+                coeff = k.args[0]\n+                exp_part = k.args[1]\n+                if (isinstance(exp_part, exp) and exp_part.args[0].is_Mul and \n+                    len(exp_part.args[0].args) == 2 and exp_part.args[0].args[0] == I):\n+                    x = exp_part.args[0].args[1]\n+                    m = rvd[k]\n+                    # Look for the conjugate term -c*I*exp(-I*x)\n+                    conjugate_key = -coeff*I*exp(-I*x)\n+                    if conjugate_key in rvd and rvd[conjugate_key] == m:\n+                        # Found sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+                        if coeff == -I/2:\n+                            newd[k] -= m\n+                            newd[conjugate_key] -= m\n+                            newd[sin(x)] += m\n+                        # Found cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+                        elif coeff == S.Half:\n+                            # Check if we have the positive conjugate\n+                            pos_conjugate_key = coeff*exp(-I*x)\n+                            if pos_conjugate_key in rvd and rvd[pos_conjugate_key] == m:\n+                                newd[k] -= m\n+                                newd[pos_conjugate_key] -= m\n+                                newd[cos(x)] += m\n         return Mul(*[k**newd[k] for k in newd])\n     newexpr = bottom_up(newexpr, f)\n \n+    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n@@ -596,6 +698,98 @@ def signlog(expr, sign=1):\n     if newexpr.has(TrigonometricFunction):\n         newexpr = TR2i(newexpr)\n \n+    # Convert complex exponential patterns to trigonometric functions\n+    # Handle patterns like exp(I*x) Â± exp(-I*x) -> trigonometric functions\n+    from sympy.functions import sin, cos\n+    from sympy.core.numbers import I\n+    \n+    def convert_exp_to_trig(expr):\n+        \"\"\"Convert exponential patterns to trigonometric functions using Euler's formula\"\"\"\n+        if expr.is_Mul:\n+            # Look for patterns like coefficient * (exp(I*x) Â± exp(-I*x))\n+            args = expr.args\n+            coeff = S.One\n+            exp_terms = []\n+            \n+            for arg in args:\n+                if arg.is_Pow and arg.base == S.Exp1:\n+                    exp_terms.append(arg)\n+                elif not arg.has(exp):\n+                    coeff *= arg\n+                else:\n+                    return expr\n+            \n+            if len(exp_terms) == 2:\n+                exp1, exp2 = exp_terms\n+                arg1, arg2 = exp1.exp, exp2.exp\n+                \n+                # Check for exp(I*x) and exp(-I*x) pattern\n+                if (arg1.is_Mul and arg2.is_Mul and \n+                    len(arg1.args) == 2 and len(arg2.args) == 2):\n+                    \n+                    if (arg1.args[0] == I and arg2.args[0] == -I and \n+                        arg1.args[1] == arg2.args[1]):\n+                        x = arg1.args[1]\n+                        # exp(I*x) + exp(-I*x) = 2*cos(x)\n+                        if coeff == S.Half:\n+                            return cos(x)\n+                        # exp(I*x) - exp(-I*x) = 2*I*sin(x)\n+                    elif (arg1.args[0] == I and arg2.args[0] == -I and \n+                          arg1.args[1] == arg2.args[1]):\n+                        x = arg1.args[1]\n+                        # -I/2 * (exp(I*x) - exp(-I*x)) = sin(x)\n+                        if coeff == -I/2:\n+                            return sin(x)\n+                        # I/2 * (exp(-I*x) - exp(I*x)) = sin(x)\n+                        elif coeff == I/2:\n+                            return sin(x)\n+        \n+        elif expr.is_Add:\n+            # Handle addition patterns\n+            terms = expr.args\n+            if len(terms) == 2:\n+                term1, term2 = terms\n+                \n+                # Look for patterns in multiplication terms\n+                if term1.is_Mul and term2.is_Mul:\n+                    # Extract coefficients and exponential parts\n+                    coeff1, exp1 = S.One, None\n+                    coeff2, exp2 = S.One, None\n+                    \n+                    for arg in term1.args:\n+                        if arg.is_Pow and arg.base == S.Exp1:\n+                            exp1 = arg\n+                        else:\n+                            coeff1 *= arg\n+                    \n+                    for arg in term2.args:\n+                        if arg.is_Pow and arg.base == S.Exp1:\n+                            exp2 = arg\n+                        else:\n+                            coeff2 *= arg\n+                    \n+                    if exp1 and exp2:\n+                        arg1, arg2 = exp1.exp, exp2.exp\n+                        \n+                        # Check for exp(I*x) Â± exp(-I*x) patterns\n+                        if (arg1.is_Mul and arg2.is_Mul and \n+                            len(arg1.args) == 2 and len(arg2.args) == 2):\n+                            \n+                            if (arg1.args[0] == I and arg2.args[0] == -I and \n+                                arg1.args[1] == arg2.args[1]):\n+                                x = arg1.args[1]\n+                                \n+                                # -I/2*exp(I*x) + I/2*exp(-I*x) = sin(x)\n+                                if coeff1 == -I/2 and coeff2 == I/2:\n+                                    return sin(x)\n+                                # 1/2*exp(I*x) + 1/2*exp(-I*x) = cos(x)\n+                                elif coeff1 == S.Half and coeff2 == S.Half:\n+                                    return cos(x)\n+        \n+        return expr\n+    \n+    newexpr = bottom_up(newexpr, convert_exp_to_trig)\n+\n     # can we ever generate an I where there was none previously?\n     if not (newexpr.has(I) and not expr.has(I)):\n         expr = newexpr\n",
    "variant_5": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..002c1c7aa6 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -425,6 +425,7 @@ def analyse_gens(gens, hints):\n _trigs = (TrigonometricFunction, HyperbolicFunction)\n \n \n+\n def trigsimp(expr, **opts):\n     \"\"\"\n     reduces expression by using known trig identities\n@@ -434,15 +435,18 @@ def trigsimp(expr, **opts):\n \n     method:\n     - Determine the method to use. Valid choices are 'matching' (default),\n-    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n+    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n     expression recursively by targeting common patterns. If 'groebner', apply\n     an experimental groebner basis algorithm. In this case further options\n     are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n     If 'combined', first run the groebner basis algorithm with small\n     default parameters, then run the 'matching' algorithm. 'fu' runs the\n     collection of trigonometric transformations described by Fu, et al.\n-    (see the `fu` docstring).\n+    (see the `fu` docstring). 'old' uses the pre-existing algorithm.\n \n+    compare:\n+    - show input and output from `trigsimp` and `fu` when different,\n+    but returns the `trigsimp` result.\n \n     Examples\n     ========\n@@ -513,6 +517,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -520,13 +525,17 @@ def exptrigsimp(expr):\n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n     >>> from sympy.abc import z\n \n     >>> exptrigsimp(exp(z) + exp(-z))\n     2*cosh(z)\n     >>> exptrigsimp(cosh(z) - sinh(z))\n     exp(-z)\n+    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n+    sin(z)\n+    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n+    cos(z)\n     \"\"\"\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n@@ -538,6 +547,68 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        \n+        # Try to convert complex exponential patterns to trigonometric functions\n+        from sympy import Add, Mul, exp, sin, cos, I\n+        if isinstance(e, (Add, Mul)):\n+            # Check for patterns like -I/2*exp(I*x) + I/2*exp(-I*x) = sin(x)\n+            # and 1/2*exp(I*x) + 1/2*exp(-I*x) = cos(x)\n+            expanded = expand_mul(e)\n+            if expanded != e:\n+                choices.append(expanded)\n+        \n+        return min(*choices, key=count_ops)\n+    newexpr = bottom_up(expr, exp_trig)\n+\n+    def exp_trig(e):\n+        # select the better of e, and e rewritten in terms of exp or trig\n+        # functions\n+        choices = [e]\n+        if e.has(*_trigs):\n+            choices.append(e.rewrite(exp))\n+        choices.append(e.rewrite(cos))\n+        \n+        # Try to recognize exponential patterns that can be converted to trig functions\n+        # Look for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+        # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+        from sympy import collect, Wild, exp, I, sin, cos\n+        \n+        # Check if expression can be written as combination of exp(I*x) terms\n+        if e.has(exp) and e.has(I):\n+            # Try to collect exponential terms and see if they match trig patterns\n+            try:\n+                # Look for expressions of the form a*exp(I*x) + b*exp(-I*x)\n+                x = Wild('x', exclude=[I])\n+                a = Wild('a')\n+                b = Wild('b')\n+                pattern = a*exp(I*x) + b*exp(-I*x)\n+                matches = e.match(pattern)\n+                \n+                if matches:\n+                    x_val = matches[x]\n+                    a_val = matches[a]\n+                    b_val = matches[b]\n+                    \n+                    # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+                    if a_val == -I/2 and b_val == I/2:\n+                        choices.append(sin(x_val))\n+                    # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+                    elif a_val == S.Half and b_val == S.Half:\n+                        choices.append(cos(x_val))\n+                    # Check for scaled versions\n+                    elif a_val == -b_val and a_val != 0:\n+                        # This is a sin pattern: a*(exp(I*x) - exp(-I*x)) where a = -I*c/2\n+                        if (a_val / (-I)).is_real:\n+                            coeff = a_val / (-I/2)\n+                            choices.append(coeff * sin(x_val))\n+                    elif a_val == b_val and a_val != 0:\n+                        # This is a cos pattern: a*(exp(I*x) + exp(-I*x)) where a = c/2\n+                        if a_val.is_real:\n+                            coeff = a_val / (S.Half)\n+                            choices.append(coeff * cos(x_val))\n+            except:\n+                pass  # If pattern matching fails, just use original choices\n+        \n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n@@ -547,6 +618,17 @@ def f(rv):\n         rvd = rv.as_powers_dict()\n         newd = rvd.copy()\n \n+        def signlog(expr, sign=1):\n+            if expr is S.Exp1:\n+                return sign, 1\n+            elif isinstance(expr, exp):\n+                return sign, expr.args[0]\n+            elif sign == 1:\n+                return signlog(-expr, sign=-1)\n+            else:\n+                return None, None\n+\n+\n         def signlog(expr, sign=1):\n             if expr is S.Exp1:\n                 return sign, 1\n@@ -585,10 +667,74 @@ def signlog(expr, sign=1):\n                 else:\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n-\n+            elif k.is_Mul and len(k.args) == 2:\n+                # Check for complex exponential patterns: c*I*exp(I*x) terms\n+                c_factor = k.args[0]\n+                exp_factor = k.args[1]\n+                if (isinstance(exp_factor, exp) and exp_factor.args[0].has(I) and\n+                    c_factor.has(I)):\n+                    # Look for the corresponding -c*I*exp(-I*x) term\n+                    x_arg = exp_factor.args[0]\n+                    if x_arg.is_Mul and x_arg.args[0] == I:\n+                        x = x_arg.args[1]\n+                        # Look for the conjugate term\n+                        conj_key = -c_factor * exp(-I*x)\n+                        if conj_key in rvd and rvd[conj_key] == rvd[k]:\n+                            m = rvd[k]\n+                            # Remove both terms\n+                            newd[k] -= m\n+                            newd[conj_key] -= m\n+                            # Check if this matches sin or cos pattern\n+                            if c_factor == -I/2:\n+                                # sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+                                newd[sin(x)] += m\n+                            elif c_factor == I/2:\n+                                # -sin pattern: I/2*(exp(I*x) - exp(-I*x)) = -sin(x)\n+                                newd[-sin(x)] += m\n+                    elif x_arg.is_Mul and x_arg.args[0] == -I:\n+                        x = x_arg.args[1]\n+                        # Look for the conjugate term\n+                        conj_key = -c_factor * exp(I*x)\n+                        if conj_key in rvd and rvd[conj_key] == rvd[k]:\n+                            m = rvd[k]\n+                            # Remove both terms\n+                            newd[k] -= m\n+                            newd[conj_key] -= m\n+                            # Check if this matches cos pattern\n+                            if c_factor == S.Half:\n+                                # cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+                                newd[cos(x)] += m\n+                elif (isinstance(exp_factor, exp) and exp_factor.args[0].has(I) and\n+                      not c_factor.has(I)):\n+                    # Look for real coefficient with complex exponential\n+                    x_arg = exp_factor.args[0]\n+                    if x_arg.is_Mul and x_arg.args[0] == I:\n+                        x = x_arg.args[1]\n+                        # Look for the conjugate term with same real coefficient\n+                        conj_key = c_factor * exp(-I*x)\n+                        if conj_key in rvd and rvd[conj_key] == rvd[k]:\n+                            m = rvd[k]\n+                            # Remove both terms\n+                            newd[k] -= m\n+                            newd[conj_key] -= m\n+                            # This is cos pattern: c*(exp(I*x) + exp(-I*x)) = 2*c*cos(x)\n+                            newd[2*c_factor*cos(x)] += m\n+                    elif x_arg.is_Mul and x_arg.args[0] == -I:\n+                        x = x_arg.args[1]\n+                        # Look for the conjugate term with opposite coefficient\n+                        conj_key = -c_factor * exp(I*x)\n+                        if conj_key in rvd and rvd[conj_key] == rvd[k]:\n+                            m = rvd[k]\n+                            # Remove both terms\n+                            newd[k] -= m\n+                            newd[conj_key] -= m\n+                            # This is sin pattern: c*(exp(-I*x) - exp(I*x)) = -2*I*c*sin(x)\n+                            newd[-2*I*c_factor*sin(x)] += m\n         return Mul(*[k**newd[k] for k in newd])\n     newexpr = bottom_up(newexpr, f)\n \n+    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n@@ -596,6 +742,65 @@ def signlog(expr, sign=1):\n     if newexpr.has(TrigonometricFunction):\n         newexpr = TR2i(newexpr)\n \n+    # Handle complex exponential patterns that should become trigonometric functions\n+    # Check for patterns like exp(I*x) Â± exp(-I*x) that represent sin/cos via Euler's formula\n+    from sympy.functions import sin, cos, exp\n+    from sympy.core.numbers import I\n+    \n+    def convert_complex_exp_to_trig(expr):\n+        \"\"\"Convert complex exponential patterns to trigonometric functions\"\"\"\n+        if not expr.has(exp) or not expr.has(I):\n+            return expr\n+            \n+        # Look for patterns: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+        #                    1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+        \n+        def _replace_exp_patterns(e):\n+            if e.is_Mul:\n+                args = e.args\n+                # Check for sin pattern: -I/2 * (exp(I*x) - exp(-I*x))\n+                if len(args) >= 2:\n+                    coeff = S.One\n+                    exp_part = S.One\n+                    for arg in args:\n+                        if arg.is_number:\n+                            coeff *= arg\n+                        else:\n+                            exp_part *= arg\n+                    \n+                    # Check if coefficient matches -I/2\n+                    if coeff == -I/2 and exp_part.is_Add and len(exp_part.args) == 2:\n+                        term1, term2 = exp_part.args\n+                        # Look for exp(I*x) - exp(-I*x) pattern\n+                        if (term1.func == exp and term2.func == exp and \n+                            term2.args[0] == -term1.args[0] and \n+                            term1.args[0].has(I)):\n+                            x_arg = term1.args[0] / I\n+                            if x_arg.is_real or not x_arg.has(I):\n+                                return sin(x_arg)\n+                    \n+                    # Check if coefficient matches 1/2\n+                    elif coeff == S.Half and exp_part.is_Add and len(exp_part.args) == 2:\n+                        term1, term2 = exp_part.args\n+                        # Look for exp(I*x) + exp(-I*x) pattern\n+                        if (term1.func == exp and term2.func == exp and \n+                            term2.args[0] == -term1.args[0] and \n+                            term1.args[0].has(I)):\n+                            x_arg = term1.args[0] / I\n+                            if x_arg.is_real or not x_arg.has(I):\n+                                return cos(x_arg)\n+            \n+            return e\n+        \n+        return bottom_up(expr, _replace_exp_patterns)\n+    \n+    # Apply complex exponential to trigonometric conversion\n+    newexpr = convert_complex_exp_to_trig(newexpr)\n+    \n+    # Apply trigonometric simplification if we now have trig functions\n+    if newexpr.has(TrigonometricFunction):\n+        newexpr = TR2i(newexpr)\n+\n     # can we ever generate an I where there was none previously?\n     if not (newexpr.has(I) and not expr.has(I)):\n         expr = newexpr\n",
    "variant_6": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..9273684dc5 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -425,6 +425,7 @@ def analyse_gens(gens, hints):\n _trigs = (TrigonometricFunction, HyperbolicFunction)\n \n \n+\n def trigsimp(expr, **opts):\n     \"\"\"\n     reduces expression by using known trig identities\n@@ -434,15 +435,18 @@ def trigsimp(expr, **opts):\n \n     method:\n     - Determine the method to use. Valid choices are 'matching' (default),\n-    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n+    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n     expression recursively by targeting common patterns. If 'groebner', apply\n     an experimental groebner basis algorithm. In this case further options\n     are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n     If 'combined', first run the groebner basis algorithm with small\n     default parameters, then run the 'matching' algorithm. 'fu' runs the\n     collection of trigonometric transformations described by Fu, et al.\n-    (see the `fu` docstring).\n+    (see the `fu` docstring). 'old' uses the legacy trigsimp algorithm.\n \n+    compare:\n+    - show input and output from `trigsimp` and `fu` when different,\n+    but returns the `trigsimp` result.\n \n     Examples\n     ========\n@@ -513,6 +517,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -520,13 +525,17 @@ def exptrigsimp(expr):\n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n     >>> from sympy.abc import z\n \n     >>> exptrigsimp(exp(z) + exp(-z))\n     2*cosh(z)\n     >>> exptrigsimp(cosh(z) - sinh(z))\n     exp(-z)\n+    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n+    sin(z)\n+    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n+    cos(z)\n     \"\"\"\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n@@ -538,15 +547,64 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        \n+        # Try to convert complex exponential patterns to trigonometric functions\n+        from sympy import Add, Mul, exp, sin, cos, I\n+        if isinstance(e, (Add, Mul)) and e.has(exp):\n+            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+            # or cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+            trig_form = e.rewrite(sin).rewrite(cos)\n+            if trig_form != e:\n+                choices.append(trig_form)\n+        \n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n+def exp_trig(e):\n+    # select the better of e, and e rewritten in terms of exp or trig\n+    # functions\n+    choices = [e]\n+    if e.has(*_trigs):\n+        choices.append(e.rewrite(exp))\n+    choices.append(e.rewrite(cos))\n+    \n+    # Check for complex exponential patterns that can be converted to trig functions\n+    if e.has(exp, I):\n+        from sympy import re, im, collect\n+        # Try to convert complex exponential expressions to trigonometric forms\n+        # Look for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+        # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+        try:\n+            # Expand and collect terms to identify exponential patterns\n+            expanded = expand_mul(e)\n+            if expanded.has(exp):\n+                # Try rewriting using trigonometric identities\n+                trig_form = expanded.rewrite(sin).rewrite(cos)\n+                if trig_form != expanded and not trig_form.has(exp):\n+                    choices.append(trig_form)\n+        except:\n+            pass\n+    \n+    return min(*choices, key=count_ops)\n+    newexpr = bottom_up(expr, exp_trig)\n+\n     def f(rv):\n         if not rv.is_Mul:\n             return rv\n         rvd = rv.as_powers_dict()\n         newd = rvd.copy()\n \n+        def signlog(expr, sign=1):\n+            if expr is S.Exp1:\n+                return sign, 1\n+            elif isinstance(expr, exp):\n+                return sign, expr.args[0]\n+            elif sign == 1:\n+                return signlog(-expr, sign=-1)\n+            else:\n+                return None, None\n+\n+\n         def signlog(expr, sign=1):\n             if expr is S.Exp1:\n                 return sign, 1\n@@ -585,10 +643,142 @@ def signlog(expr, sign=1):\n                 else:\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n+            elif k.is_Mul and len(k.args) == 2:\n+                # Check for complex exponential patterns: c*exp(I*x) or c*exp(-I*x)\n+                coeff, exp_part = k.args\n+                if isinstance(exp_part, exp) and exp_part.args[0].has(I):\n+                    # Extract argument from exp(I*x) or exp(-I*x)\n+                    arg = exp_part.args[0]\n+                    if arg.is_Mul and len(arg.args) == 2 and arg.args[0] == I:\n+                        # exp(I*x) case\n+                        x = arg.args[1]\n+                        m = rvd[k]\n+                        # Look for corresponding exp(-I*x) term\n+                        conj_key = coeff * exp(-I*x)\n+                        if conj_key in rvd and rvd[conj_key] == m:\n+                            # We have c*exp(I*x) and c*exp(-I*x) with same multiplicity\n+                            newd[k] -= m\n+                            newd[conj_key] -= m\n+                            if coeff == I/2:\n+                                # I/2*(exp(I*x) - exp(-I*x)) = I*sin(x)\n+                                # -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+                                newd[sin(x)] += m\n+                            elif coeff == -I/2:\n+                                # -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+                                newd[sin(x)] += m\n+                            elif coeff == S.Half:\n+                                # 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+                                newd[cos(x)] += m\n+                    elif arg.is_Mul and len(arg.args) == 2 and arg.args[0] == -I:\n+                        # exp(-I*x) case - handled by the exp(I*x) case above\n+                        pass\n+        return Mul(*[k**newd[k] for k in newd])\n+    newexpr = bottom_up(newexpr, f)\n+\n+    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n+                    else:\n+                        newd[-c*tanh(x/2)] += m\n+                else:\n+                    newd[1 + sign*S.Exp1**x] += m\n+                    newd[c] += m\n \n         return Mul(*[k**newd[k] for k in newd])\n     newexpr = bottom_up(newexpr, f)\n \n+    # Handle complex exponential patterns for trigonometric functions\n+    def convert_exp_to_trig(expr):\n+        \"\"\"Convert complex exponential patterns to trigonometric functions\"\"\"\n+        from sympy import Wild, collect, simplify\n+        from sympy.functions import sin, cos\n+        \n+        if not expr.has(exp):\n+            return expr\n+            \n+        # Look for patterns like I*exp(I*x) - I*exp(-I*x) = 2*sin(x)\n+        # and exp(I*x) + exp(-I*x) = 2*cos(x)\n+        def trig_replacer(e):\n+            if e.is_Add:\n+                terms = e.as_ordered_terms()\n+                # Group terms by their argument structure\n+                exp_terms = {}\n+                other_terms = []\n+                \n+                for term in terms:\n+                    if term.has(exp):\n+                        # Extract coefficient and exponential part\n+                        coeff, rest = term.as_coeff_mul()\n+                        exp_part = None\n+                        for factor in rest:\n+                            if factor.has(exp) and factor.func == exp:\n+                                exp_part = factor\n+                                break\n+                        \n+                        if exp_part and exp_part.args[0].has(I):\n+                            arg = exp_part.args[0]\n+                            # Check if arg is of form I*x or -I*x\n+                            if arg.as_coeff_mul(I)[0] != 0:\n+                                base_arg = (arg/I).simplify()\n+                                if base_arg not in exp_terms:\n+                                    exp_terms[base_arg] = {}\n+                                exp_terms[base_arg][arg] = exp_terms[base_arg].get(arg, 0) + coeff\n+                            else:\n+                                other_terms.append(term)\n+                        else:\n+                            other_terms.append(term)\n+                    else:\n+                        other_terms.append(term)\n+                \n+                # Convert exponential patterns to trigonometric\n+                new_terms = other_terms[:]\n+                for base_arg, patterns in exp_terms.items():\n+                    pos_key = I * base_arg\n+                    neg_key = -I * base_arg\n+                    \n+                    pos_coeff = patterns.get(pos_key, 0)\n+                    neg_coeff = patterns.get(neg_key, 0)\n+                    \n+                    # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+                    if pos_coeff != 0 and neg_coeff != 0:\n+                        if pos_coeff == -neg_coeff:\n+                            # This is a sin or cos pattern\n+                            if pos_coeff == -I/2:\n+                                new_terms.append(sin(base_arg))\n+                                continue\n+                            elif pos_coeff == I/2:\n+                                new_terms.append(-sin(base_arg))\n+                                continue\n+                            elif pos_coeff == S.Half:\n+                                new_terms.append(cos(base_arg))\n+                                continue\n+                            elif pos_coeff == -S.Half:\n+                                new_terms.append(-cos(base_arg))\n+                                continue\n+                        \n+                        # Scale factor case: c*(-I/2)*(exp(I*x) - exp(-I*x)) = c*sin(x)\n+                        if pos_coeff == -neg_coeff and pos_coeff != 0:\n+                            scale = pos_coeff / (-I/2)\n+                            if scale.is_real:\n+                                new_terms.append(scale * sin(base_arg))\n+                                continue\n+                            scale = pos_coeff / (S.Half)\n+                            if scale.is_real:\n+                                new_terms.append(scale * cos(base_arg))\n+                                continue\n+                    \n+                    # Add back any unmatched exponential terms\n+                    for arg, coeff in patterns.items():\n+                        if coeff != 0:\n+                            new_terms.append(coeff * exp(arg))\n+                \n+                return Add(*new_terms) if new_terms else S.Zero\n+            \n+            return e\n+        \n+        return bottom_up(expr, trig_replacer)\n+    \n+    newexpr = convert_exp_to_trig(newexpr)\n+\n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n",
    "variant_7": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..683e75ca8d 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -425,6 +425,7 @@ def analyse_gens(gens, hints):\n _trigs = (TrigonometricFunction, HyperbolicFunction)\n \n \n+\n def trigsimp(expr, **opts):\n     \"\"\"\n     reduces expression by using known trig identities\n@@ -434,15 +435,21 @@ def trigsimp(expr, **opts):\n \n     method:\n     - Determine the method to use. Valid choices are 'matching' (default),\n-    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n+    'groebner', 'combined', 'fu', and 'old'. If 'matching', simplify the\n     expression recursively by targeting common patterns. If 'groebner', apply\n     an experimental groebner basis algorithm. In this case further options\n     are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n     If 'combined', first run the groebner basis algorithm with small\n     default parameters, then run the 'matching' algorithm. 'fu' runs the\n     collection of trigonometric transformations described by Fu, et al.\n-    (see the `fu` docstring).\n+    (see the `fu` docstring). 'old' runs the original SymPy trigsimp.\n \n+    compare:\n+    - show input and output from `trigsimp` and `futrig` when different,\n+    but returns the `trigsimp` result.\n+\n+    deep:\n+    - Apply trigsimp recursively to all arguments of functions.\n \n     Examples\n     ========\n@@ -513,6 +520,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -520,13 +528,17 @@ def exptrigsimp(expr):\n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n     >>> from sympy.abc import z\n \n     >>> exptrigsimp(exp(z) + exp(-z))\n     2*cosh(z)\n     >>> exptrigsimp(cosh(z) - sinh(z))\n     exp(-z)\n+    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n+    sin(z)\n+    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n+    cos(z)\n     \"\"\"\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n@@ -538,9 +550,60 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        \n+        # Try to convert complex exponential patterns to trigonometric functions\n+        from sympy import Add, Mul, exp, sin, cos, I\n+        if isinstance(e, Add):\n+            # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+            # or cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+            args = e.args\n+            if len(args) == 2:\n+                arg1, arg2 = args\n+                # Look for exponential terms with I in the exponent\n+                if (isinstance(arg1, Mul) and isinstance(arg2, Mul) and\n+                    any(isinstance(term, exp) and term.exp.has(I) for term in arg1.args if hasattr(term, 'args')) and\n+                    any(isinstance(term, exp) and term.exp.has(I) for term in arg2.args if hasattr(term, 'args'))):\n+                    # Try rewriting as trigonometric functions\n+                    trig_form = e.rewrite(sin).rewrite(cos)\n+                    if trig_form != e and trig_form.has(sin, cos):\n+                        choices.append(trig_form)\n+        \n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n+def exp_trig(e):\n+    # select the better of e, and e rewritten in terms of exp or trig\n+    # functions\n+    choices = [e]\n+    if e.has(*_trigs):\n+        choices.append(e.rewrite(exp))\n+    \n+    # Check for complex exponential patterns that can be converted to trig functions\n+    if e.has(exp) and e.has(I):\n+        # Try to convert complex exponential expressions to trigonometric form\n+        from sympy import collect, expand\n+        expanded = expand(e)\n+        # Look for patterns like -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+        # and 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+        trig_form = expanded\n+        for atom in expanded.atoms(exp):\n+            if atom.exp.has(I):\n+                arg = atom.exp\n+                if arg.is_Mul and I in arg.args:\n+                    # Extract the real argument\n+                    real_arg = arg / I\n+                    if real_arg.is_real or real_arg.is_symbol:\n+                        # Replace exp(I*x) with cos(x) + I*sin(x)\n+                        trig_form = trig_form.subs(atom, cos(real_arg) + I*sin(real_arg))\n+        if trig_form != expanded:\n+            from sympy import simplify\n+            trig_simplified = simplify(trig_form)\n+            choices.append(trig_simplified)\n+    \n+    choices.append(e.rewrite(cos))\n+    return min(*choices, key=count_ops)\n+    newexpr = bottom_up(expr, exp_trig)\n+\n     def f(rv):\n         if not rv.is_Mul:\n             return rv\n@@ -557,6 +620,7 @@ def signlog(expr, sign=1):\n             else:\n                 return None, None\n \n+\n         ee = rvd[S.Exp1]\n         for k in rvd:\n             if k.is_Add and len(k.args) == 2:\n@@ -585,10 +649,41 @@ def signlog(expr, sign=1):\n                 else:\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n-\n+            elif k.is_Add and len(k.args) == 2:\n+                # Check for trigonometric patterns: c*(-I*exp(I*x) + I*exp(-I*x)) = 2*c*sin(x)\n+                # and c*(exp(I*x) + exp(-I*x)) = 2*c*cos(x)\n+                arg1, arg2 = k.args\n+                if (isinstance(arg1, Mul) and isinstance(arg2, Mul) and \n+                    len(arg1.args) == 2 and len(arg2.args) == 2):\n+                    \n+                    # Extract coefficient and exponential parts\n+                    c1, exp1 = arg1.args if isinstance(arg1.args[1], exp) else (arg1.args[1], arg1.args[0])\n+                    c2, exp2 = arg2.args if isinstance(arg2.args[1], exp) else (arg2.args[1], arg2.args[0])\n+                    \n+                    if (isinstance(exp1, exp) and isinstance(exp2, exp) and\n+                        exp1.args[0] == -exp2.args[0] and exp1.args[0].has(I)):\n+                        \n+                        x_arg = exp1.args[0]\n+                        if x_arg.has(I):\n+                            # Remove I from the argument\n+                            x_val = x_arg / I\n+                            m = rvd[k]\n+                            newd[k] -= m\n+                            \n+                            # sin pattern: -I*exp(I*x) + I*exp(-I*x) = 2*sin(x)\n+                            if c1 == -I and c2 == I:\n+                                newd[2*sin(x_val)] += m\n+                            # cos pattern: exp(I*x) + exp(-I*x) = 2*cos(x)  \n+                            elif c1 == 1 and c2 == 1:\n+                                newd[2*cos(x_val)] += m\n+                            else:\n+                                # Restore original if pattern doesn't match exactly\n+                                newd[k] += m\n         return Mul(*[k**newd[k] for k in newd])\n     newexpr = bottom_up(newexpr, f)\n \n+    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n@@ -596,6 +691,15 @@ def signlog(expr, sign=1):\n     if newexpr.has(TrigonometricFunction):\n         newexpr = TR2i(newexpr)\n \n+    # Additional check for complex exponential patterns that should become trig functions\n+    from sympy.functions import sin, cos\n+    if newexpr.has(exp) and newexpr.has(I):\n+        # Try to convert complex exponential patterns to trigonometric functions\n+        # This handles cases like -I/2*(exp(I*x) - exp(-I*x)) -> sin(x)\n+        temp_expr = newexpr.rewrite(sin).rewrite(cos)\n+        if temp_expr != newexpr and not temp_expr.has(exp):\n+            newexpr = temp_expr\n+\n     # can we ever generate an I where there was none previously?\n     if not (newexpr.has(I) and not expr.has(I)):\n         expr = newexpr\n",
    "variant_8": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..1a8f494db0 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -425,6 +425,7 @@ def analyse_gens(gens, hints):\n _trigs = (TrigonometricFunction, HyperbolicFunction)\n \n \n+\n def trigsimp(expr, **opts):\n     \"\"\"\n     reduces expression by using known trig identities\n@@ -513,6 +514,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -520,13 +522,17 @@ def exptrigsimp(expr):\n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh, sin, cos, I\n     >>> from sympy.abc import z\n \n     >>> exptrigsimp(exp(z) + exp(-z))\n     2*cosh(z)\n     >>> exptrigsimp(cosh(z) - sinh(z))\n     exp(-z)\n+    >>> exptrigsimp(-I/2*exp(I*z) + I/2*exp(-I*z))\n+    sin(z)\n+    >>> exptrigsimp(exp(I*z)/2 + exp(-I*z)/2)\n+    cos(z)\n     \"\"\"\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n@@ -538,15 +544,97 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        # Try to convert exponential expressions to trigonometric functions\n+        if e.has(exp):\n+            # Check for complex exponential patterns that can become trig functions\n+            from sympy import Wild, collect, simplify\n+            x = Wild('x')\n+            \n+            # Pattern for sin: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+            sin_pattern = -I/2*(exp(I*x) - exp(-I*x))\n+            # Pattern for cos: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)  \n+            cos_pattern = S.Half*(exp(I*x) + exp(-I*x))\n+            \n+            # Try to match and replace exponential patterns with trig functions\n+            try:\n+                # Expand and collect terms to match patterns\n+                expanded = expand_mul(e)\n+                \n+                # Check if expression matches trigonometric patterns\n+                from sympy import sin, cos\n+                for atom in expanded.atoms(exp):\n+                    if atom.exp.has(I):\n+                        arg = atom.exp\n+                        if arg.match(I*x):\n+                            # Found exp(I*something), look for corresponding exp(-I*something)\n+                            var = arg.match(I*x)[x]\n+                            conjugate_exp = exp(-I*var)\n+                            \n+                            if conjugate_exp in expanded.atoms(exp):\n+                                # Found both exp(I*var) and exp(-I*var)\n+                                # Try to extract coefficients and convert to trig\n+                                from sympy import collect\n+                                collected = collect(expanded, [atom, conjugate_exp], evaluate=False)\n+                                \n+                                if atom in collected and conjugate_exp in collected:\n+                                    coeff1 = collected.get(atom, 0)\n+                                    coeff2 = collected.get(conjugate_exp, 0)\n+                                    \n+                                    # Check for sin pattern: coeff of exp(I*x) = -I/2, coeff of exp(-I*x) = I/2\n+                                    if coeff1 == -I/2 and coeff2 == I/2:\n+                                        trig_form = sin(var)\n+                                        choices.append(trig_form)\n+                                    # Check for cos pattern: coeff of exp(I*x) = 1/2, coeff of exp(-I*x) = 1/2  \n+                                    elif coeff1 == S.Half and coeff2 == S.Half:\n+                                        trig_form = cos(var)\n+                                        choices.append(trig_form)\n+            except:\n+                pass\n+                \n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n+def exp_trig(e):\n+    # select the better of e, and e rewritten in terms of exp or trig\n+    # functions\n+    choices = [e]\n+    if e.has(*_trigs):\n+        choices.append(e.rewrite(exp))\n+    choices.append(e.rewrite(cos))\n+    \n+    # Check for complex exponential patterns that can be converted to trig functions\n+    from sympy import re, im, I\n+    if e.has(exp) and e.has(I):\n+        # Try to convert complex exponential expressions to trigonometric form\n+        try:\n+            # Look for patterns like I*exp(I*x) - I*exp(-I*x) = 2*sin(x)\n+            # or exp(I*x) + exp(-I*x) = 2*cos(x)\n+            trig_form = e.rewrite(sin)\n+            if trig_form != e and not trig_form.has(exp):\n+                choices.append(trig_form)\n+        except:\n+            pass\n+    \n+    return min(*choices, key=count_ops)\n+    newexpr = bottom_up(expr, exp_trig)\n+\n     def f(rv):\n         if not rv.is_Mul:\n             return rv\n         rvd = rv.as_powers_dict()\n         newd = rvd.copy()\n \n+        def signlog(expr, sign=1):\n+            if expr is S.Exp1:\n+                return sign, 1\n+            elif isinstance(expr, exp):\n+                return sign, expr.args[0]\n+            elif sign == 1:\n+                return signlog(-expr, sign=-1)\n+            else:\n+                return None, None\n+\n+\n         def signlog(expr, sign=1):\n             if expr is S.Exp1:\n                 return sign, 1\n@@ -585,10 +673,47 @@ def signlog(expr, sign=1):\n                 else:\n                     newd[1 + sign*S.Exp1**x] += m\n                     newd[c] += m\n-\n+            elif k.is_Mul and len(k.args) == 2:\n+                # Check for complex exponential patterns: c*I*exp(I*x) patterns\n+                if k.args[0] == I and isinstance(k.args[1], exp):\n+                    exp_arg = k.args[1].args[0]\n+                    if exp_arg.is_Mul and len(exp_arg.args) == 2 and exp_arg.args[0] == I:\n+                        # Found I*exp(I*x), look for corresponding -I*exp(-I*x)\n+                        x = exp_arg.args[1]\n+                        neg_k = -I*exp(-I*x)\n+                        if neg_k in rvd and rvd[k] == rvd[neg_k]:\n+                            # Found matching pair: I*exp(I*x) and -I*exp(-I*x)\n+                            m = rvd[k]\n+                            newd[k] -= m\n+                            newd[neg_k] -= m\n+                            # Convert to sin: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+                            # So I*exp(I*x) - I*exp(-I*x) = 2*sin(x)\n+                            newd[2*sin(x)] += m\n+                elif k.args[0] == -I and isinstance(k.args[1], exp):\n+                    exp_arg = k.args[1].args[0]\n+                    if exp_arg.is_Mul and len(exp_arg.args) == 2 and exp_arg.args[0] == -I:\n+                        # Found -I*exp(-I*x), check if I*exp(I*x) already processed\n+                        x = -exp_arg.args[1]\n+                        pos_k = I*exp(I*x)\n+                        # Skip if already processed above\n+                        continue\n+            elif isinstance(k, exp):\n+                # Check for direct exp(I*x) + exp(-I*x) patterns for cos\n+                exp_arg = k.args[0]\n+                if exp_arg.is_Mul and len(exp_arg.args) == 2 and exp_arg.args[0] == I:\n+                    x = exp_arg.args[1]\n+                    neg_exp = exp(-I*x)\n+                    if neg_exp in rvd and rvd[k] == rvd[neg_exp]:\n+                        # Found exp(I*x) + exp(-I*x) = 2*cos(x)\n+                        m = rvd[k]\n+                        newd[k] -= m\n+                        newd[neg_exp] -= m\n+                        newd[2*cos(x)] += m\n         return Mul(*[k**newd[k] for k in newd])\n     newexpr = bottom_up(newexpr, f)\n \n+    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n@@ -596,6 +721,85 @@ def signlog(expr, sign=1):\n     if newexpr.has(TrigonometricFunction):\n         newexpr = TR2i(newexpr)\n \n+    # Apply exponential to trigonometric conversions\n+    def exp_to_trig(expr):\n+        \"\"\"Convert exponential expressions to trigonometric functions using Euler's formula\"\"\"\n+        from sympy import exp, I, sin, cos, collect, Add, Mul\n+        \n+        if not expr.has(exp):\n+            return expr\n+            \n+        # Look for patterns like exp(I*x) Â± exp(-I*x)\n+        def find_exp_pairs(expr):\n+            if isinstance(expr, Add):\n+                terms = expr.args\n+                exp_terms = {}\n+                other_terms = []\n+                \n+                for term in terms:\n+                    if isinstance(term, Mul):\n+                        coeff = S.One\n+                        exp_part = None\n+                        for factor in term.args:\n+                            if isinstance(factor, exp):\n+                                exp_part = factor\n+                            else:\n+                                coeff *= factor\n+                        if exp_part is not None:\n+                            arg = exp_part.args[0]\n+                            exp_terms[arg] = exp_terms.get(arg, 0) + coeff\n+                        else:\n+                            other_terms.append(term)\n+                    elif isinstance(term, exp):\n+                        arg = term.args[0]\n+                        exp_terms[arg] = exp_terms.get(arg, 0) + 1\n+                    else:\n+                        other_terms.append(term)\n+                \n+                # Look for pairs of the form I*x and -I*x\n+                converted_terms = []\n+                used_args = set()\n+                \n+                for arg in exp_terms:\n+                    if arg in used_args:\n+                        continue\n+                    neg_arg = -arg\n+                    if neg_arg in exp_terms and arg != neg_arg:\n+                        coeff1 = exp_terms[arg]\n+                        coeff2 = exp_terms[neg_arg]\n+                        \n+                        # Check if this is a complex exponential pattern\n+                        if arg.has(I):\n+                            # Extract the real part from I*x\n+                            if arg == I*arg/I:  # arg is of the form I*something\n+                                real_arg = arg/I\n+                                # Check for sin pattern: -I/2*(exp(I*x) - exp(-I*x)) = sin(x)\n+                                if coeff1 == -I/2 and coeff2 == I/2:\n+                                    converted_terms.append(sin(real_arg))\n+                                    used_args.update([arg, neg_arg])\n+                                # Check for cos pattern: 1/2*(exp(I*x) + exp(-I*x)) = cos(x)\n+                                elif coeff1 == S.Half and coeff2 == S.Half:\n+                                    converted_terms.append(cos(real_arg))\n+                                    used_args.update([arg, neg_arg])\n+                \n+                # Add back unused exponential terms\n+                for arg in exp_terms:\n+                    if arg not in used_args:\n+                        coeff = exp_terms[arg]\n+                        if coeff == 1:\n+                            converted_terms.append(exp(arg))\n+                        else:\n+                            converted_terms.append(coeff * exp(arg))\n+                \n+                converted_terms.extend(other_terms)\n+                return Add(*converted_terms) if converted_terms else S.Zero\n+            \n+            return expr\n+        \n+        return find_exp_pairs(expr)\n+    \n+    newexpr = exp_to_trig(newexpr)\n+\n     # can we ever generate an I where there was none previously?\n     if not (newexpr.has(I) and not expr.has(I)):\n         expr = newexpr\n"
  }
}