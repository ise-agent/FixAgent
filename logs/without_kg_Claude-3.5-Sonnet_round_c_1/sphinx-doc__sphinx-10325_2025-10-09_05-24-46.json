{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 112-117)": "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
    "Location 2 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 682-695)": "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ in self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n",
    "Location 3 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 661-662)": "\n        elif self.options.inherited_members:\n            return False, [(m.name, m.value) for m in members.values()]\n",
    "Location 4 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 831-833)": "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
    "Location 5 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 1712-1713)": "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 112-117)": [
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n"
    ],
    "Location 2 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 682-695)": [
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ in self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n",
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ in self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n",
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ in self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n",
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ in self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n",
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ in self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n",
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ in self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n",
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ in self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n",
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ in self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n"
    ],
    "Location 3 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 661-662)": [
      "\n        elif self.options.inherited_members:\n            return False, [(m.name, m.value) for m in members.values()]\n",
      "\nelif self.options.inherited_members:\n    return False, [(m.name, m.value) for m in members.values()]\n",
      "\n        elif self.options.inherited_members:\n            return False, [(m.name, m.value) for m in members.values()]\n",
      "\nelif self.options.inherited_members:\n    return False, [(m.name, m.value) for m in members.values()]\n",
      "\n        elif self.options.inherited_members:\n            return False, [(m.name, m.value) for m in members.values()]\n",
      "\n        elif self.options.inherited_members:\n            return False, [(m.name, m.value) for m in members.values()]\n",
      "\n        elif self.options.inherited_members:\n            return False, [(m.name, m.value) for m in members.values()]\n",
      "\nelif self.options.inherited_members:\n    return False, [(m.name, m.value) for m in members.values()]\n"
    ],
    "Location 4 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 831-833)": [
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n"
    ],
    "Location 5 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 1712-1713)": [
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n",
      "\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n    if arg in (None, True):\n        return {'object'}\n    elif arg is False:\n        return set()\n    else:\n        return {x.strip() for x in arg.split(',') if x.strip()}\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..60ffa97f4 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,15 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n+\n def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -658,6 +661,7 @@ class Documenter:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n+\n         elif self.options.inherited_members:\n             return False, [(m.name, m.value) for m in members.values()]\n         else:\n@@ -679,10 +683,11 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n+                    if cls.__name__ in self.options.inherited_members and cls != self.object:\n                         # given member is a member of specified *super class*\n                         return True\n                     elif name in cls.__dict__:\n@@ -828,6 +833,7 @@ class Documenter:\n         if self.objpath:\n             self.env.temp_data['autodoc:class'] = self.objpath[0]\n \n+\n         want_all = (all_members or\n                     self.options.inherited_members or\n                     self.options.members is ALL)\n@@ -1709,6 +1715,7 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n+\n         elif self.options.inherited_members:\n             return False, list(members.values())\n         else:\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..f6f4844ae 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,15 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n+\n def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -658,6 +661,7 @@ class Documenter:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n+\n         elif self.options.inherited_members:\n             return False, [(m.name, m.value) for m in members.values()]\n         else:\n@@ -679,20 +683,21 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ in self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n \n         ret = []\n \n@@ -828,9 +833,15 @@ class Documenter:\n         if self.objpath:\n             self.env.temp_data['autodoc:class'] = self.objpath[0]\n \n-        want_all = (all_members or\n-                    self.options.inherited_members or\n-                    self.options.members is ALL)\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         # find out which members are documentable\n         members_check_module, members = self.get_object_members(want_all)\n \n@@ -1709,8 +1720,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, list(members.values())\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         else:\n             return False, [m for m in members.values() if m.class_ == self.object]\n \n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..f6f4844ae 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,15 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n+\n def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -658,6 +661,7 @@ class Documenter:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n+\n         elif self.options.inherited_members:\n             return False, [(m.name, m.value) for m in members.values()]\n         else:\n@@ -679,20 +683,21 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ in self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n \n         ret = []\n \n@@ -828,9 +833,15 @@ class Documenter:\n         if self.objpath:\n             self.env.temp_data['autodoc:class'] = self.objpath[0]\n \n-        want_all = (all_members or\n-                    self.options.inherited_members or\n-                    self.options.members is ALL)\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         # find out which members are documentable\n         members_check_module, members = self.get_object_members(want_all)\n \n@@ -1709,8 +1720,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, list(members.values())\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         else:\n             return False, [m for m in members.values() if m.class_ == self.object]\n \n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..118ecaad2 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,15 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n+\n def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -658,8 +661,9 @@ class Documenter:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, [(m.name, m.value) for m in members.values()]\n+\n+elif self.options.inherited_members:\n+    return False, [(m.name, m.value) for m in members.values()]\n         else:\n             return False, [(m.name, m.value) for m in members.values()\n                            if m.directly_defined]\n@@ -679,20 +683,21 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ in self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n \n         ret = []\n \n@@ -828,9 +833,15 @@ class Documenter:\n         if self.objpath:\n             self.env.temp_data['autodoc:class'] = self.objpath[0]\n \n-        want_all = (all_members or\n-                    self.options.inherited_members or\n-                    self.options.members is ALL)\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         # find out which members are documentable\n         members_check_module, members = self.get_object_members(want_all)\n \n@@ -1709,8 +1720,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, list(members.values())\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         else:\n             return False, [m for m in members.values() if m.class_ == self.object]\n \n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..f6f4844ae 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,15 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n+\n def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -658,6 +661,7 @@ class Documenter:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n+\n         elif self.options.inherited_members:\n             return False, [(m.name, m.value) for m in members.values()]\n         else:\n@@ -679,20 +683,21 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ in self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n \n         ret = []\n \n@@ -828,9 +833,15 @@ class Documenter:\n         if self.objpath:\n             self.env.temp_data['autodoc:class'] = self.objpath[0]\n \n-        want_all = (all_members or\n-                    self.options.inherited_members or\n-                    self.options.members is ALL)\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         # find out which members are documentable\n         members_check_module, members = self.get_object_members(want_all)\n \n@@ -1709,8 +1720,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, list(members.values())\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         else:\n             return False, [m for m in members.values() if m.class_ == self.object]\n \n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..118ecaad2 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,15 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n+\n def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -658,8 +661,9 @@ class Documenter:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, [(m.name, m.value) for m in members.values()]\n+\n+elif self.options.inherited_members:\n+    return False, [(m.name, m.value) for m in members.values()]\n         else:\n             return False, [(m.name, m.value) for m in members.values()\n                            if m.directly_defined]\n@@ -679,20 +683,21 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ in self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n \n         ret = []\n \n@@ -828,9 +833,15 @@ class Documenter:\n         if self.objpath:\n             self.env.temp_data['autodoc:class'] = self.objpath[0]\n \n-        want_all = (all_members or\n-                    self.options.inherited_members or\n-                    self.options.members is ALL)\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         # find out which members are documentable\n         members_check_module, members = self.get_object_members(want_all)\n \n@@ -1709,8 +1720,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, list(members.values())\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         else:\n             return False, [m for m in members.values() if m.class_ == self.object]\n \n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..f6f4844ae 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,15 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n+\n def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -658,6 +661,7 @@ class Documenter:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n+\n         elif self.options.inherited_members:\n             return False, [(m.name, m.value) for m in members.values()]\n         else:\n@@ -679,20 +683,21 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ in self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n \n         ret = []\n \n@@ -828,9 +833,15 @@ class Documenter:\n         if self.objpath:\n             self.env.temp_data['autodoc:class'] = self.objpath[0]\n \n-        want_all = (all_members or\n-                    self.options.inherited_members or\n-                    self.options.members is ALL)\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         # find out which members are documentable\n         members_check_module, members = self.get_object_members(want_all)\n \n@@ -1709,8 +1720,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, list(members.values())\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         else:\n             return False, [m for m in members.values() if m.class_ == self.object]\n \n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..f6f4844ae 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,15 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n+\n def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -658,6 +661,7 @@ class Documenter:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n+\n         elif self.options.inherited_members:\n             return False, [(m.name, m.value) for m in members.values()]\n         else:\n@@ -679,20 +683,21 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ in self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n \n         ret = []\n \n@@ -828,9 +833,15 @@ class Documenter:\n         if self.objpath:\n             self.env.temp_data['autodoc:class'] = self.objpath[0]\n \n-        want_all = (all_members or\n-                    self.options.inherited_members or\n-                    self.options.members is ALL)\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         # find out which members are documentable\n         members_check_module, members = self.get_object_members(want_all)\n \n@@ -1709,8 +1720,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, list(members.values())\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         else:\n             return False, [m for m in members.values() if m.class_ == self.object]\n \n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..f6f4844ae 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,15 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n+\n def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -658,6 +661,7 @@ class Documenter:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n+\n         elif self.options.inherited_members:\n             return False, [(m.name, m.value) for m in members.values()]\n         else:\n@@ -679,20 +683,21 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ in self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n \n         ret = []\n \n@@ -828,9 +833,15 @@ class Documenter:\n         if self.objpath:\n             self.env.temp_data['autodoc:class'] = self.objpath[0]\n \n-        want_all = (all_members or\n-                    self.options.inherited_members or\n-                    self.options.members is ALL)\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         # find out which members are documentable\n         members_check_module, members = self.get_object_members(want_all)\n \n@@ -1709,8 +1720,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, list(members.values())\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         else:\n             return False, [m for m in members.values() if m.class_ == self.object]\n \n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 62631f7ff..118ecaad2 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,15 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n+\n def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -658,8 +661,9 @@ class Documenter:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, [(m.name, m.value) for m in members.values()]\n+\n+elif self.options.inherited_members:\n+    return False, [(m.name, m.value) for m in members.values()]\n         else:\n             return False, [(m.name, m.value) for m in members.values()\n                            if m.directly_defined]\n@@ -679,20 +683,21 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ in self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n \n         ret = []\n \n@@ -828,9 +833,15 @@ class Documenter:\n         if self.objpath:\n             self.env.temp_data['autodoc:class'] = self.objpath[0]\n \n-        want_all = (all_members or\n-                    self.options.inherited_members or\n-                    self.options.members is ALL)\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         # find out which members are documentable\n         members_check_module, members = self.get_object_members(want_all)\n \n@@ -1709,8 +1720,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                     logger.warning(__('missing attribute %s in object %s') %\n                                    (name, self.fullname), type='autodoc')\n             return False, selected\n-        elif self.options.inherited_members:\n-            return False, list(members.values())\n+\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n+    if arg in (None, True):\n+        return {'object'}\n+    elif arg is False:\n+        return set()\n+    else:\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n         else:\n             return False, [m for m in members.values() if m.class_ == self.object]\n \n"
  }
}