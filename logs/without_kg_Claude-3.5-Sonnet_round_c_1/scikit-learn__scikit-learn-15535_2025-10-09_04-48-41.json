{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/scikit-learn/sklearn/metrics/cluster/_supervised.py lines 45-47)": "\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
    "Location 2 (/root/hy/projects_1/scikit-learn/sklearn/metrics/cluster/_supervised.py lines 48-50)": "\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
    "Location 3 (/root/hy/projects_1/scikit-learn/sklearn/metrics/cluster/_supervised.py lines 34-61)": "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n    \"\"\"\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
    "Location 4 (/root/hy/projects_1/scikit-learn/sklearn/metrics/cluster/_supervised.py lines 615-625)": "\n    if contingency is None:\n        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n        contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n    else:\n        contingency = check_array(contingency,\n                                  accept_sparse=['csr', 'csc', 'coo'],\n                                  dtype=[int, np.int32, np.int64])\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/scikit-learn/sklearn/metrics/cluster/_supervised.py lines 45-47)": [
      "\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n"
    ],
    "Location 2 (/root/hy/projects_1/scikit-learn/sklearn/metrics/cluster/_supervised.py lines 48-50)": [
      "\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n",
      "\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n"
    ],
    "Location 3 (/root/hy/projects_1/scikit-learn/sklearn/metrics/cluster/_supervised.py lines 34-61)": [
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n    \"\"\"\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n    \"\"\"\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n    \"\"\"\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n    \"\"\"\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n    \"\"\"\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n    \"\"\"\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n    \"\"\"\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n    \"\"\"\n    labels_true = check_array(\n        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n    labels_pred = check_array(\n        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n    )\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n"
    ],
    "Location 4 (/root/hy/projects_1/scikit-learn/sklearn/metrics/cluster/_supervised.py lines 615-625)": [
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n\n    Returns\n    -------\n    labels_true : array of shape (n_samples,)\n        The true labels as array.\n    labels_pred : array of shape (n_samples,)\n        The predicted labels as array.\n    \"\"\"\n    labels_true = check_array(labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None)\n    labels_pred = check_array(labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None)\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n\n    Returns\n    -------\n    labels_true : array of shape (n_samples,)\n        The true labels as array.\n    labels_pred : array of shape (n_samples,)\n        The predicted labels as array.\n    \"\"\"\n    labels_true = check_array(labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None)\n    labels_pred = check_array(labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None)\n\n    # Check that both arrays have the same shape\n    if labels_true.shape != labels_pred.shape:\n        raise ValueError(\n            \"labels_true and labels_pred must have same size, got %d and %d\"\n            % (labels_true.shape[0], labels_pred.shape[0]))\n\n    return labels_true, labels_pred\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n\n    Returns\n    -------\n    labels_true : array of shape (n_samples,)\n        The true labels as array.\n    labels_pred : array of shape (n_samples,)\n        The predicted labels as array.\n    \"\"\"\n    labels_true = check_array(labels_true, ensure_2d=False, ensure_min_samples=0,\n                              dtype=None)\n    labels_pred = check_array(labels_pred, ensure_2d=False, ensure_min_samples=0,\n                              dtype=None)\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\n    if contingency is None:\n        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n        contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n    else:\n        contingency = check_array(contingency,\n                                  accept_sparse=['csr', 'csc', 'coo'],\n                                  dtype=[int, np.int32, np.int64])\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n\n    Returns\n    -------\n    labels_true : array of shape (n_samples,)\n        The true labels as array.\n    labels_pred : array of shape (n_samples,)\n        The predicted labels as array.\n    \"\"\"\n    labels_true = check_array(labels_true, ensure_2d=False, ensure_min_samples=0,\n                              dtype=None)\n    labels_pred = check_array(labels_pred, ensure_2d=False, ensure_min_samples=0,\n                              dtype=None)\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\n    \"\"\"\n    if contingency is None:\n        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n        contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n    else:\n        contingency = check_array(contingency,\n                                  accept_sparse=['csr', 'csc', 'coo'],\n                                  dtype=[int, np.int32, np.int64])\n",
      "\ndef check_clusterings(labels_true, labels_pred):\n    \"\"\"Check that the labels arrays are 1D and of same dimension.\n\n    Parameters\n    ----------\n    labels_true : array-like of shape (n_samples,)\n        The true labels.\n    labels_pred : array-like of shape (n_samples,)\n        The predicted labels.\n\n    Returns\n    -------\n    labels_true : array of shape (n_samples,)\n        The true labels as a numpy array.\n    labels_pred : array of shape (n_samples,)\n        The predicted labels as a numpy array.\n    \"\"\"\n    labels_true = check_array(labels_true, ensure_2d=False, ensure_min_samples=0,\n                              dtype=None)\n    labels_pred = check_array(labels_pred, ensure_2d=False, ensure_min_samples=0,\n                              dtype=None)\n\n    # input checks\n    if labels_true.ndim != 1:\n        raise ValueError(\n            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n    if labels_pred.ndim != 1:\n        raise ValueError(\n            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n    check_consistent_length(labels_true, labels_pred)\n\n    return labels_true, labels_pred\n",
      "\n    if contingency is None:\n        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n        contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n    else:\n        contingency = check_array(contingency,\n                                  accept_sparse=['csr', 'csc', 'coo'],\n                                  dtype=[int, np.int32, np.int64])\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/metrics/cluster/_supervised.py b/sklearn/metrics/cluster/_supervised.py\nindex 4bddae35c..aa101d6a2 100644\n--- a/sklearn/metrics/cluster/_supervised.py\n+++ b/sklearn/metrics/cluster/_supervised.py\n@@ -31,6 +31,7 @@ def _comb2(n):\n     return comb(n, 2, exact=1)\n \n \n+\n def check_clusterings(labels_true, labels_pred):\n     \"\"\"Check that the labels arrays are 1D and of same dimension.\n \n@@ -43,10 +44,10 @@ def check_clusterings(labels_true, labels_pred):\n         The predicted labels.\n     \"\"\"\n     labels_true = check_array(\n-        labels_true, ensure_2d=False, ensure_min_samples=0\n+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n     labels_pred = check_array(\n-        labels_pred, ensure_2d=False, ensure_min_samples=0\n+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n \n     # input checks\n@@ -60,6 +61,8 @@ def check_clusterings(labels_true, labels_pred):\n \n     return labels_true, labels_pred\n \n+    return labels_true, labels_pred\n+\n \n def _generalized_average(U, V, average_method):\n     \"\"\"Return a particular mean of two numbers.\"\"\"\n@@ -612,6 +615,7 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n \n     See also\n     --------\n+\n     adjusted_mutual_info_score: Adjusted against chance Mutual Information\n     normalized_mutual_info_score: Normalized Mutual Information\n     \"\"\"\n@@ -622,7 +626,6 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n         contingency = check_array(contingency,\n                                   accept_sparse=['csr', 'csc', 'coo'],\n                                   dtype=[int, np.int32, np.int64])\n-\n     if isinstance(contingency, np.ndarray):\n         # For an array\n         nzx, nzy = np.nonzero(contingency)\n",
    "variant_0": "diff --git a/sklearn/metrics/cluster/_supervised.py b/sklearn/metrics/cluster/_supervised.py\nindex 4bddae35c..d5a8c50ee 100644\n--- a/sklearn/metrics/cluster/_supervised.py\n+++ b/sklearn/metrics/cluster/_supervised.py\n@@ -31,6 +31,7 @@ def _comb2(n):\n     return comb(n, 2, exact=1)\n \n \n+\n def check_clusterings(labels_true, labels_pred):\n     \"\"\"Check that the labels arrays are 1D and of same dimension.\n \n@@ -43,10 +44,10 @@ def check_clusterings(labels_true, labels_pred):\n         The predicted labels.\n     \"\"\"\n     labels_true = check_array(\n-        labels_true, ensure_2d=False, ensure_min_samples=0\n+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n     labels_pred = check_array(\n-        labels_pred, ensure_2d=False, ensure_min_samples=0\n+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n \n     # input checks\n@@ -60,6 +61,8 @@ def check_clusterings(labels_true, labels_pred):\n \n     return labels_true, labels_pred\n \n+    return labels_true, labels_pred\n+\n \n def _generalized_average(U, V, average_method):\n     \"\"\"Return a particular mean of two numbers.\"\"\"\n@@ -612,9 +615,7 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n \n     See also\n     --------\n-    adjusted_mutual_info_score: Adjusted against chance Mutual Information\n-    normalized_mutual_info_score: Normalized Mutual Information\n-    \"\"\"\n+\n     if contingency is None:\n         labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n         contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n@@ -622,7 +623,6 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n         contingency = check_array(contingency,\n                                   accept_sparse=['csr', 'csc', 'coo'],\n                                   dtype=[int, np.int32, np.int64])\n-\n     if isinstance(contingency, np.ndarray):\n         # For an array\n         nzx, nzy = np.nonzero(contingency)\n",
    "variant_1": "diff --git a/sklearn/metrics/cluster/_supervised.py b/sklearn/metrics/cluster/_supervised.py\nindex 4bddae35c..03e316b68 100644\n--- a/sklearn/metrics/cluster/_supervised.py\n+++ b/sklearn/metrics/cluster/_supervised.py\n@@ -31,6 +31,7 @@ def _comb2(n):\n     return comb(n, 2, exact=1)\n \n \n+\n def check_clusterings(labels_true, labels_pred):\n     \"\"\"Check that the labels arrays are 1D and of same dimension.\n \n@@ -43,10 +44,10 @@ def check_clusterings(labels_true, labels_pred):\n         The predicted labels.\n     \"\"\"\n     labels_true = check_array(\n-        labels_true, ensure_2d=False, ensure_min_samples=0\n+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n     labels_pred = check_array(\n-        labels_pred, ensure_2d=False, ensure_min_samples=0\n+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n \n     # input checks\n@@ -60,6 +61,8 @@ def check_clusterings(labels_true, labels_pred):\n \n     return labels_true, labels_pred\n \n+    return labels_true, labels_pred\n+\n \n def _generalized_average(U, V, average_method):\n     \"\"\"Return a particular mean of two numbers.\"\"\"\n@@ -612,17 +615,37 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n \n     See also\n     --------\n-    adjusted_mutual_info_score: Adjusted against chance Mutual Information\n-    normalized_mutual_info_score: Normalized Mutual Information\n+\n+def check_clusterings(labels_true, labels_pred):\n+    \"\"\"Check that the labels arrays are 1D and of same dimension.\n+\n+    Parameters\n+    ----------\n+    labels_true : array-like of shape (n_samples,)\n+        The true labels.\n+    labels_pred : array-like of shape (n_samples,)\n+        The predicted labels.\n+\n+    Returns\n+    -------\n+    labels_true : array of shape (n_samples,)\n+        The true labels as array.\n+    labels_pred : array of shape (n_samples,)\n+        The predicted labels as array.\n     \"\"\"\n-    if contingency is None:\n-        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n-        contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n-    else:\n-        contingency = check_array(contingency,\n-                                  accept_sparse=['csr', 'csc', 'coo'],\n-                                  dtype=[int, np.int32, np.int64])\n+    labels_true = check_array(labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None)\n+    labels_pred = check_array(labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None)\n \n+    # input checks\n+    if labels_true.ndim != 1:\n+        raise ValueError(\n+            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n+    if labels_pred.ndim != 1:\n+        raise ValueError(\n+            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n+    check_consistent_length(labels_true, labels_pred)\n+\n+    return labels_true, labels_pred\n     if isinstance(contingency, np.ndarray):\n         # For an array\n         nzx, nzy = np.nonzero(contingency)\n",
    "variant_2": "diff --git a/sklearn/metrics/cluster/_supervised.py b/sklearn/metrics/cluster/_supervised.py\nindex 4bddae35c..d363b8cfc 100644\n--- a/sklearn/metrics/cluster/_supervised.py\n+++ b/sklearn/metrics/cluster/_supervised.py\n@@ -31,6 +31,7 @@ def _comb2(n):\n     return comb(n, 2, exact=1)\n \n \n+\n def check_clusterings(labels_true, labels_pred):\n     \"\"\"Check that the labels arrays are 1D and of same dimension.\n \n@@ -43,10 +44,10 @@ def check_clusterings(labels_true, labels_pred):\n         The predicted labels.\n     \"\"\"\n     labels_true = check_array(\n-        labels_true, ensure_2d=False, ensure_min_samples=0\n+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n     labels_pred = check_array(\n-        labels_pred, ensure_2d=False, ensure_min_samples=0\n+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n \n     # input checks\n@@ -60,6 +61,8 @@ def check_clusterings(labels_true, labels_pred):\n \n     return labels_true, labels_pred\n \n+    return labels_true, labels_pred\n+\n \n def _generalized_average(U, V, average_method):\n     \"\"\"Return a particular mean of two numbers.\"\"\"\n@@ -612,17 +615,34 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n \n     See also\n     --------\n-    adjusted_mutual_info_score: Adjusted against chance Mutual Information\n-    normalized_mutual_info_score: Normalized Mutual Information\n+\n+def check_clusterings(labels_true, labels_pred):\n+    \"\"\"Check that the labels arrays are 1D and of same dimension.\n+\n+    Parameters\n+    ----------\n+    labels_true : array-like of shape (n_samples,)\n+        The true labels.\n+    labels_pred : array-like of shape (n_samples,)\n+        The predicted labels.\n+\n+    Returns\n+    -------\n+    labels_true : array of shape (n_samples,)\n+        The true labels as array.\n+    labels_pred : array of shape (n_samples,)\n+        The predicted labels as array.\n     \"\"\"\n-    if contingency is None:\n-        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n-        contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n-    else:\n-        contingency = check_array(contingency,\n-                                  accept_sparse=['csr', 'csc', 'coo'],\n-                                  dtype=[int, np.int32, np.int64])\n+    labels_true = check_array(labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None)\n+    labels_pred = check_array(labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None)\n \n+    # Check that both arrays have the same shape\n+    if labels_true.shape != labels_pred.shape:\n+        raise ValueError(\n+            \"labels_true and labels_pred must have same size, got %d and %d\"\n+            % (labels_true.shape[0], labels_pred.shape[0]))\n+\n+    return labels_true, labels_pred\n     if isinstance(contingency, np.ndarray):\n         # For an array\n         nzx, nzy = np.nonzero(contingency)\n",
    "variant_3": "diff --git a/sklearn/metrics/cluster/_supervised.py b/sklearn/metrics/cluster/_supervised.py\nindex 4bddae35c..80d7ea8c9 100644\n--- a/sklearn/metrics/cluster/_supervised.py\n+++ b/sklearn/metrics/cluster/_supervised.py\n@@ -31,6 +31,7 @@ def _comb2(n):\n     return comb(n, 2, exact=1)\n \n \n+\n def check_clusterings(labels_true, labels_pred):\n     \"\"\"Check that the labels arrays are 1D and of same dimension.\n \n@@ -43,10 +44,10 @@ def check_clusterings(labels_true, labels_pred):\n         The predicted labels.\n     \"\"\"\n     labels_true = check_array(\n-        labels_true, ensure_2d=False, ensure_min_samples=0\n+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n     labels_pred = check_array(\n-        labels_pred, ensure_2d=False, ensure_min_samples=0\n+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n \n     # input checks\n@@ -60,6 +61,8 @@ def check_clusterings(labels_true, labels_pred):\n \n     return labels_true, labels_pred\n \n+    return labels_true, labels_pred\n+\n \n def _generalized_average(U, V, average_method):\n     \"\"\"Return a particular mean of two numbers.\"\"\"\n@@ -612,17 +615,39 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n \n     See also\n     --------\n-    adjusted_mutual_info_score: Adjusted against chance Mutual Information\n-    normalized_mutual_info_score: Normalized Mutual Information\n+\n+def check_clusterings(labels_true, labels_pred):\n+    \"\"\"Check that the labels arrays are 1D and of same dimension.\n+\n+    Parameters\n+    ----------\n+    labels_true : array-like of shape (n_samples,)\n+        The true labels.\n+    labels_pred : array-like of shape (n_samples,)\n+        The predicted labels.\n+\n+    Returns\n+    -------\n+    labels_true : array of shape (n_samples,)\n+        The true labels as array.\n+    labels_pred : array of shape (n_samples,)\n+        The predicted labels as array.\n     \"\"\"\n-    if contingency is None:\n-        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n-        contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n-    else:\n-        contingency = check_array(contingency,\n-                                  accept_sparse=['csr', 'csc', 'coo'],\n-                                  dtype=[int, np.int32, np.int64])\n+    labels_true = check_array(labels_true, ensure_2d=False, ensure_min_samples=0,\n+                              dtype=None)\n+    labels_pred = check_array(labels_pred, ensure_2d=False, ensure_min_samples=0,\n+                              dtype=None)\n \n+    # input checks\n+    if labels_true.ndim != 1:\n+        raise ValueError(\n+            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n+    if labels_pred.ndim != 1:\n+        raise ValueError(\n+            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n+    check_consistent_length(labels_true, labels_pred)\n+\n+    return labels_true, labels_pred\n     if isinstance(contingency, np.ndarray):\n         # For an array\n         nzx, nzy = np.nonzero(contingency)\n",
    "variant_4": "diff --git a/sklearn/metrics/cluster/_supervised.py b/sklearn/metrics/cluster/_supervised.py\nindex 4bddae35c..d5a8c50ee 100644\n--- a/sklearn/metrics/cluster/_supervised.py\n+++ b/sklearn/metrics/cluster/_supervised.py\n@@ -31,6 +31,7 @@ def _comb2(n):\n     return comb(n, 2, exact=1)\n \n \n+\n def check_clusterings(labels_true, labels_pred):\n     \"\"\"Check that the labels arrays are 1D and of same dimension.\n \n@@ -43,10 +44,10 @@ def check_clusterings(labels_true, labels_pred):\n         The predicted labels.\n     \"\"\"\n     labels_true = check_array(\n-        labels_true, ensure_2d=False, ensure_min_samples=0\n+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n     labels_pred = check_array(\n-        labels_pred, ensure_2d=False, ensure_min_samples=0\n+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n \n     # input checks\n@@ -60,6 +61,8 @@ def check_clusterings(labels_true, labels_pred):\n \n     return labels_true, labels_pred\n \n+    return labels_true, labels_pred\n+\n \n def _generalized_average(U, V, average_method):\n     \"\"\"Return a particular mean of two numbers.\"\"\"\n@@ -612,9 +615,7 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n \n     See also\n     --------\n-    adjusted_mutual_info_score: Adjusted against chance Mutual Information\n-    normalized_mutual_info_score: Normalized Mutual Information\n-    \"\"\"\n+\n     if contingency is None:\n         labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n         contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n@@ -622,7 +623,6 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n         contingency = check_array(contingency,\n                                   accept_sparse=['csr', 'csc', 'coo'],\n                                   dtype=[int, np.int32, np.int64])\n-\n     if isinstance(contingency, np.ndarray):\n         # For an array\n         nzx, nzy = np.nonzero(contingency)\n",
    "variant_5": "diff --git a/sklearn/metrics/cluster/_supervised.py b/sklearn/metrics/cluster/_supervised.py\nindex 4bddae35c..80d7ea8c9 100644\n--- a/sklearn/metrics/cluster/_supervised.py\n+++ b/sklearn/metrics/cluster/_supervised.py\n@@ -31,6 +31,7 @@ def _comb2(n):\n     return comb(n, 2, exact=1)\n \n \n+\n def check_clusterings(labels_true, labels_pred):\n     \"\"\"Check that the labels arrays are 1D and of same dimension.\n \n@@ -43,10 +44,10 @@ def check_clusterings(labels_true, labels_pred):\n         The predicted labels.\n     \"\"\"\n     labels_true = check_array(\n-        labels_true, ensure_2d=False, ensure_min_samples=0\n+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n     labels_pred = check_array(\n-        labels_pred, ensure_2d=False, ensure_min_samples=0\n+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n \n     # input checks\n@@ -60,6 +61,8 @@ def check_clusterings(labels_true, labels_pred):\n \n     return labels_true, labels_pred\n \n+    return labels_true, labels_pred\n+\n \n def _generalized_average(U, V, average_method):\n     \"\"\"Return a particular mean of two numbers.\"\"\"\n@@ -612,17 +615,39 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n \n     See also\n     --------\n-    adjusted_mutual_info_score: Adjusted against chance Mutual Information\n-    normalized_mutual_info_score: Normalized Mutual Information\n+\n+def check_clusterings(labels_true, labels_pred):\n+    \"\"\"Check that the labels arrays are 1D and of same dimension.\n+\n+    Parameters\n+    ----------\n+    labels_true : array-like of shape (n_samples,)\n+        The true labels.\n+    labels_pred : array-like of shape (n_samples,)\n+        The predicted labels.\n+\n+    Returns\n+    -------\n+    labels_true : array of shape (n_samples,)\n+        The true labels as array.\n+    labels_pred : array of shape (n_samples,)\n+        The predicted labels as array.\n     \"\"\"\n-    if contingency is None:\n-        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n-        contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n-    else:\n-        contingency = check_array(contingency,\n-                                  accept_sparse=['csr', 'csc', 'coo'],\n-                                  dtype=[int, np.int32, np.int64])\n+    labels_true = check_array(labels_true, ensure_2d=False, ensure_min_samples=0,\n+                              dtype=None)\n+    labels_pred = check_array(labels_pred, ensure_2d=False, ensure_min_samples=0,\n+                              dtype=None)\n \n+    # input checks\n+    if labels_true.ndim != 1:\n+        raise ValueError(\n+            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n+    if labels_pred.ndim != 1:\n+        raise ValueError(\n+            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n+    check_consistent_length(labels_true, labels_pred)\n+\n+    return labels_true, labels_pred\n     if isinstance(contingency, np.ndarray):\n         # For an array\n         nzx, nzy = np.nonzero(contingency)\n",
    "variant_6": "diff --git a/sklearn/metrics/cluster/_supervised.py b/sklearn/metrics/cluster/_supervised.py\nindex 4bddae35c..c4b79654b 100644\n--- a/sklearn/metrics/cluster/_supervised.py\n+++ b/sklearn/metrics/cluster/_supervised.py\n@@ -31,6 +31,7 @@ def _comb2(n):\n     return comb(n, 2, exact=1)\n \n \n+\n def check_clusterings(labels_true, labels_pred):\n     \"\"\"Check that the labels arrays are 1D and of same dimension.\n \n@@ -43,10 +44,10 @@ def check_clusterings(labels_true, labels_pred):\n         The predicted labels.\n     \"\"\"\n     labels_true = check_array(\n-        labels_true, ensure_2d=False, ensure_min_samples=0\n+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n     labels_pred = check_array(\n-        labels_pred, ensure_2d=False, ensure_min_samples=0\n+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n \n     # input checks\n@@ -60,6 +61,8 @@ def check_clusterings(labels_true, labels_pred):\n \n     return labels_true, labels_pred\n \n+    return labels_true, labels_pred\n+\n \n def _generalized_average(U, V, average_method):\n     \"\"\"Return a particular mean of two numbers.\"\"\"\n@@ -612,8 +615,7 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n \n     See also\n     --------\n-    adjusted_mutual_info_score: Adjusted against chance Mutual Information\n-    normalized_mutual_info_score: Normalized Mutual Information\n+\n     \"\"\"\n     if contingency is None:\n         labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n@@ -622,7 +624,6 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n         contingency = check_array(contingency,\n                                   accept_sparse=['csr', 'csc', 'coo'],\n                                   dtype=[int, np.int32, np.int64])\n-\n     if isinstance(contingency, np.ndarray):\n         # For an array\n         nzx, nzy = np.nonzero(contingency)\n",
    "variant_7": "diff --git a/sklearn/metrics/cluster/_supervised.py b/sklearn/metrics/cluster/_supervised.py\nindex 4bddae35c..7728302f6 100644\n--- a/sklearn/metrics/cluster/_supervised.py\n+++ b/sklearn/metrics/cluster/_supervised.py\n@@ -31,6 +31,7 @@ def _comb2(n):\n     return comb(n, 2, exact=1)\n \n \n+\n def check_clusterings(labels_true, labels_pred):\n     \"\"\"Check that the labels arrays are 1D and of same dimension.\n \n@@ -43,10 +44,10 @@ def check_clusterings(labels_true, labels_pred):\n         The predicted labels.\n     \"\"\"\n     labels_true = check_array(\n-        labels_true, ensure_2d=False, ensure_min_samples=0\n+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n     labels_pred = check_array(\n-        labels_pred, ensure_2d=False, ensure_min_samples=0\n+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n \n     # input checks\n@@ -60,6 +61,8 @@ def check_clusterings(labels_true, labels_pred):\n \n     return labels_true, labels_pred\n \n+    return labels_true, labels_pred\n+\n \n def _generalized_average(U, V, average_method):\n     \"\"\"Return a particular mean of two numbers.\"\"\"\n@@ -612,17 +615,39 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n \n     See also\n     --------\n-    adjusted_mutual_info_score: Adjusted against chance Mutual Information\n-    normalized_mutual_info_score: Normalized Mutual Information\n+\n+def check_clusterings(labels_true, labels_pred):\n+    \"\"\"Check that the labels arrays are 1D and of same dimension.\n+\n+    Parameters\n+    ----------\n+    labels_true : array-like of shape (n_samples,)\n+        The true labels.\n+    labels_pred : array-like of shape (n_samples,)\n+        The predicted labels.\n+\n+    Returns\n+    -------\n+    labels_true : array of shape (n_samples,)\n+        The true labels as a numpy array.\n+    labels_pred : array of shape (n_samples,)\n+        The predicted labels as a numpy array.\n     \"\"\"\n-    if contingency is None:\n-        labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n-        contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n-    else:\n-        contingency = check_array(contingency,\n-                                  accept_sparse=['csr', 'csc', 'coo'],\n-                                  dtype=[int, np.int32, np.int64])\n+    labels_true = check_array(labels_true, ensure_2d=False, ensure_min_samples=0,\n+                              dtype=None)\n+    labels_pred = check_array(labels_pred, ensure_2d=False, ensure_min_samples=0,\n+                              dtype=None)\n \n+    # input checks\n+    if labels_true.ndim != 1:\n+        raise ValueError(\n+            \"labels_true must be 1D: shape is %r\" % (labels_true.shape,))\n+    if labels_pred.ndim != 1:\n+        raise ValueError(\n+            \"labels_pred must be 1D: shape is %r\" % (labels_pred.shape,))\n+    check_consistent_length(labels_true, labels_pred)\n+\n+    return labels_true, labels_pred\n     if isinstance(contingency, np.ndarray):\n         # For an array\n         nzx, nzy = np.nonzero(contingency)\n",
    "variant_8": "diff --git a/sklearn/metrics/cluster/_supervised.py b/sklearn/metrics/cluster/_supervised.py\nindex 4bddae35c..d5a8c50ee 100644\n--- a/sklearn/metrics/cluster/_supervised.py\n+++ b/sklearn/metrics/cluster/_supervised.py\n@@ -31,6 +31,7 @@ def _comb2(n):\n     return comb(n, 2, exact=1)\n \n \n+\n def check_clusterings(labels_true, labels_pred):\n     \"\"\"Check that the labels arrays are 1D and of same dimension.\n \n@@ -43,10 +44,10 @@ def check_clusterings(labels_true, labels_pred):\n         The predicted labels.\n     \"\"\"\n     labels_true = check_array(\n-        labels_true, ensure_2d=False, ensure_min_samples=0\n+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n     labels_pred = check_array(\n-        labels_pred, ensure_2d=False, ensure_min_samples=0\n+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None\n     )\n \n     # input checks\n@@ -60,6 +61,8 @@ def check_clusterings(labels_true, labels_pred):\n \n     return labels_true, labels_pred\n \n+    return labels_true, labels_pred\n+\n \n def _generalized_average(U, V, average_method):\n     \"\"\"Return a particular mean of two numbers.\"\"\"\n@@ -612,9 +615,7 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n \n     See also\n     --------\n-    adjusted_mutual_info_score: Adjusted against chance Mutual Information\n-    normalized_mutual_info_score: Normalized Mutual Information\n-    \"\"\"\n+\n     if contingency is None:\n         labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n         contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n@@ -622,7 +623,6 @@ def mutual_info_score(labels_true, labels_pred, contingency=None):\n         contingency = check_array(contingency,\n                                   accept_sparse=['csr', 'csc', 'coo'],\n                                   dtype=[int, np.int32, np.int64])\n-\n     if isinstance(contingency, np.ndarray):\n         # For an array\n         nzx, nzy = np.nonzero(contingency)\n"
  }
}