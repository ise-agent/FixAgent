{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/pytest/src/_pytest/skipping.py lines 273-274)": "\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                if item.config.option.runxfail:\n                    rep.outcome = \"failed\"\n                else:\n                    rep.wasxfail = \"reason: \" + xfailed.reason\n                    rep.outcome = \"skipped\"\n        else:\n            if item.config.option.runxfail:\n                rep.outcome = \"failed\"\n            else:\n                rep.wasxfail = \"reason: \" + xfailed.reason\n                rep.outcome = \"skipped\"\n    elif (\n        item.config.option.runxfail\n        and not rep.skipped\n        and xfailed\n        and call.excinfo\n        and not isinstance(call.excinfo.value, xfail.Exception)\n    ):\n        rep.outcome = \"failed\"\n    elif rep.skipped and call.excinfo and isinstance(call.excinfo.value, skip.Exception):\n        # Adjust the skip location to point to the test itself\n        # instead of where the skip exception was raised\n        if call.excinfo.value.msg:\n            rep.longrepr = call.excinfo.value.msg\n        else:\n            rep.longrepr = \"\"\n        \n        # Find the test location from the traceback\n        tb = call.excinfo.tb\n        while tb is not None:\n            frame = tb.tb_frame\n            filename = frame.f_code.co_filename\n            # Look for the test file (not pytest internal files)\n            if not filename.startswith(os.path.dirname(_pytest.__file__)):\n                rep.longrepr = (filename, tb.tb_lineno, rep.longrepr)\n                break\n            tb = tb.tb_next\n",
    "Location 2 (/root/hy/projects_1/pytest/src/_pytest/skipping.py lines 294-305)": "\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n    outcome = call.excinfo\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = f\"Unexpected success: {reason}\"\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        # Handle xfail behavior under --runxfail, but don't bypass skip location adjustment\n        if xfailed and rep.when == \"call\" and rep.skipped:\n            # Convert xfail skip to actual skip under --runxfail\n            pass\n    elif xfailed:\n        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n            assert call.excinfo.value.msg is not None\n            rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n            rep.outcome = \"skipped\"\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"setup\":\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n        else:\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n    \n    # Skip location adjustment logic - should run regardless of --runxfail\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/pytest/src/_pytest/skipping.py lines 273-274)": [
      "\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                if item.config.option.runxfail:\n                    rep.outcome = \"failed\"\n                else:\n                    rep.wasxfail = \"reason: \" + xfailed.reason\n                    rep.outcome = \"skipped\"\n        else:\n            if item.config.option.runxfail:\n                rep.outcome = \"failed\"\n            else:\n                rep.wasxfail = \"reason: \" + xfailed.reason\n                rep.outcome = \"skipped\"\n    if call.excinfo and isinstance(call.excinfo.value, skip.Exception):\n        # Compute the skip location to report.  Note we report the\n        # user code, not the direct skip() call.\n        assert call.excinfo.traceback is not None\n        for i, line in enumerate(call.excinfo.traceback):\n            if line.frame.f_locals.get(\"__tracebackhide__\"):\n                continue\n            break\n        else:\n            i = len(call.excinfo.traceback) - 1\n        rep.longrepr = call.excinfo.traceback[i:].getcrashentry()\n",
      "\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                if item.config.option.runxfail:\n                    rep.outcome = \"failed\"\n                else:\n                    rep.wasxfail = \"reason: \" + xfailed.reason\n                    rep.outcome = \"skipped\"\n        else:\n            if item.config.option.runxfail:\n                rep.outcome = \"failed\"\n            else:\n                rep.wasxfail = \"reason: \" + xfailed.reason\n                rep.outcome = \"skipped\"\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                if item.config.option.runxfail:\n                    rep.outcome = \"failed\"\n                else:\n                    rep.wasxfail = \"reason: \" + xfailed.reason\n                    rep.outcome = \"skipped\"\n        else:\n            if item.config.option.runxfail:\n                rep.outcome = \"failed\"\n            else:\n                rep.wasxfail = \"reason: \" + xfailed.reason\n                rep.outcome = \"skipped\"\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                if not item.config.option.runxfail:\n                    rep.outcome = \"skipped\"\n                    rep.wasxfail = xfailed.reason\n        else:\n            if not item.config.option.runxfail:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n\n    if call.excinfo and call.excinfo.errisinstance(skip.Exception):\n        # Skipped by mark.skip or mark.skipif\n        rep.outcome = \"skipped\"\n        r = call.excinfo._getreprcrash()\n        if len(r.path.parts) >= 3 and r.path.parts[-3:-1] == (\"_pytest\", \"skipping\"):\n            # skipped by mark.skipif; use the mark's location\n            # TODO: check all the pytest skip exceptions, not just skipif\n            skipped = item._store.get(skipped_by_mark_key, None)\n            if skipped:\n                rep.longrepr = skipped.longrepr\n",
      "\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                if item.config.option.runxfail:\n                    rep.outcome = \"failed\"\n                else:\n                    rep.wasxfail = \"reason: \" + xfailed.reason\n                    rep.outcome = \"skipped\"\n        else:\n            if item.config.option.runxfail:\n                rep.outcome = \"failed\"\n            else:\n                rep.wasxfail = \"reason: \" + xfailed.reason\n                rep.outcome = \"skipped\"\n\n    if call.when == \"call\":\n        if rep.outcome == \"skipped\" and type(rep.longrepr) is tuple:\n            # skipped by mark.skipif; change the location of the failure\n            # to point to the item definition, otherwise it will display\n            # the location of where the skip exception was raised within pytest\n            _, _, reason = rep.longrepr\n            filename, line = item.reportinfo()[:2]\n            assert line is not None\n            rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                if item.config.option.runxfail:\n                    rep.outcome = \"failed\"\n                else:\n                    rep.wasxfail = \"reason: \" + xfailed.reason\n                    rep.outcome = \"skipped\"\n        else:\n            if item.config.option.runxfail:\n                rep.outcome = \"failed\"\n            else:\n                rep.wasxfail = \"reason: \" + xfailed.reason\n                rep.outcome = \"skipped\"\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                if item.config.option.runxfail:\n                    rep.outcome = \"failed\"\n                else:\n                    rep.wasxfail = \"reason: \" + xfailed.reason\n                    rep.outcome = \"skipped\"\n        else:\n            if item.config.option.runxfail:\n                rep.outcome = \"failed\"\n            else:\n                rep.wasxfail = \"reason: \" + xfailed.reason\n                rep.outcome = \"skipped\"\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skip marker, fix the location of the reported\n        # skipped test to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                if item.config.option.runxfail:\n                    rep.outcome = \"failed\"\n                else:\n                    rep.wasxfail = \"reason: \" + xfailed.reason\n                    rep.outcome = \"skipped\"\n        else:\n            if item.config.option.runxfail:\n                rep.outcome = \"failed\"\n            else:\n                rep.wasxfail = \"reason: \" + xfailed.reason\n                rep.outcome = \"skipped\"\n\n    if call.when == \"call\":\n        if rep.outcome == \"skipped\" and type(rep.longrepr) is tuple:\n            # skipped by mark.skipif; change the location of the failure\n            # to point to the item definition, otherwise it will display\n            # the location of where the skip exception is raised within pytest\n            _, _, reason = rep.longrepr\n            filename, line = item.reportinfo()[:2]\n            assert line is not None\n            rep.longrepr = str(filename), line + 1, reason\n"
    ],
    "Location 2 (/root/hy/projects_1/pytest/src/_pytest/skipping.py lines 294-305)": [
      "\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n    outcome = call.excinfo\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest.SkipTest reports class name, we just want the message\n    if (\n        outcome.skipped\n        and call.excinfo is not None\n        and call.excinfo.errisinstance(unittest.SkipTest)\n    ):\n        rep.longrepr = call.excinfo.value.args[0]\n\n    if item._store.get(evalxfail_key, None):\n        if call.excinfo is not None:\n            if call.excinfo.errisinstance(xfail.Exception):\n                assert call.excinfo.value.msg is not None\n                rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n                rep.outcome = \"skipped\"\n            else:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[NOTRUN] \" + call.excinfo.getrepr(style=\"short\")\n        elif call.when == \"call\":\n            rep.outcome = \"failed\"\n            rep.longrepr = \"[NOTRUN] test passes unexpectedly\"\n\n    elif xfailed and not item.config.option.runxfail:\n        if call.excinfo is not None:\n            if call.excinfo.errisinstance(xfail.Exception):\n                assert call.excinfo.value.msg is not None\n                rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n                rep.outcome = \"skipped\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n    \n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n    outcome = call.excinfo\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = f\"Unexpected success: {reason}\"\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        # Handle xfail behavior under --runxfail, but don't bypass skip location adjustment\n        if xfailed and call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n            # Convert xfail to regular failure under --runxfail\n            rep.outcome = \"failed\"\n    elif xfailed:\n        if call.excinfo:\n            if call.excinfo.errisinstance(xfail.Exception):\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n    \n    # Skip location adjustment - always run this logic regardless of --runxfail\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n    outcome = call.excinfo\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = f\"Unexpected success: {reason}\"\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        # Handle runxfail but don't bypass skip location adjustment\n        if xfailed is not None:\n            # Only modify xfail behavior, let skip location adjustment proceed below\n            pass\n    elif xfailed is not None:\n        if call.excinfo:\n            if call.excinfo.errisinstance(xfail.Exception):\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n            else:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n    \n    # Skip location adjustment - always execute regardless of runxfail\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n    outcome = call.excinfo\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        # Handle --runxfail flag but don't bypass skip location adjustment\n        if xfailed:\n            # Only process xfail-related logic here, skip location adjustment will happen below\n            pass\n    elif xfailed:\n        if call.excinfo:\n            if call.excinfo.errisinstance(xfail.Exception):\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n            else:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XFAIL] \" + xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n    \n    # Skip location adjustment - always process regardless of --runxfail\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n    outcome = call.excinfo\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = f\"Unexpected success: {reason}\"\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        # Only bypass xfail-specific logic, not skip location adjustment\n        if xfailed:\n            if call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n            elif call.when == \"call\":\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XFAIL(run)] \" + xfailed.reason\n    elif xfailed:\n        if call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n            if call.excinfo.errisinstance(pytest.skip.Exception):\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n    \n    # Always perform skip location adjustment regardless of runxfail\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n    outcome = call.excinfo\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest.SkipTest reports class name only.\n    if isinstance(rep.longrepr, tuple):\n        modpath, lineno, msg = rep.longrepr\n        # Checking that modpath is a string on purpose since\n        # unittest.SkipTest.args can contain arbitrary stuff.\n        if isinstance(modpath, str):\n            rep.longrepr = modpath, lineno, msg\n\n    if item.config.option.runxfail:\n        # don't interfere with runxfail for xfail tests\n        if xfailed:\n            return\n    elif xfailed:\n        if call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n            assert call.excinfo.value.msg is not None\n            rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n            rep.outcome = \"skipped\"\n        elif call.when == \"setup\":\n            rep.skipped = True\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n        elif call.when == \"teardown\":\n            if call.excinfo:\n                rep.outcome = \"failed\"\n                rep.longrepr = xfailed.reason\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n    \n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..4867f5011 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,8 +270,9 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+\n+    elif item.config.option.runxfail and call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        pass  # don't interfere with xfail when runxfail is enabled\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +292,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_0": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..8e72e782a 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,8 +270,54 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                if item.config.option.runxfail:\n+                    rep.outcome = \"failed\"\n+                else:\n+                    rep.wasxfail = \"reason: \" + xfailed.reason\n+                    rep.outcome = \"skipped\"\n+        else:\n+            if item.config.option.runxfail:\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.wasxfail = \"reason: \" + xfailed.reason\n+                rep.outcome = \"skipped\"\n+    elif (\n+        item.config.option.runxfail\n+        and not rep.skipped\n+        and xfailed\n+        and call.excinfo\n+        and not isinstance(call.excinfo.value, xfail.Exception)\n+    ):\n+        rep.outcome = \"failed\"\n+    elif rep.skipped and call.excinfo and isinstance(call.excinfo.value, skip.Exception):\n+        # Adjust the skip location to point to the test itself\n+        # instead of where the skip exception was raised\n+        if call.excinfo.value.msg:\n+            rep.longrepr = call.excinfo.value.msg\n+        else:\n+            rep.longrepr = \"\"\n+        \n+        # Find the test location from the traceback\n+        tb = call.excinfo.tb\n+        while tb is not None:\n+            frame = tb.tb_frame\n+            filename = frame.f_code.co_filename\n+            # Look for the test file (not pytest internal files)\n+            if not filename.startswith(os.path.dirname(_pytest.__file__)):\n+                rep.longrepr = (filename, tb.tb_lineno, rep.longrepr)\n+                break\n+            tb = tb.tb_next\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,7 +337,45 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n-    elif (\n+\n+def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n+    outcome = call.excinfo\n+    rep = outcome.get_result()\n+    xfailed = item._store.get(xfailed_key, None)\n+    # unittest special case, see setting of unexpectedsuccess_key\n+    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n+        reason = item._store[unexpectedsuccess_key]\n+        if reason:\n+            rep.longrepr = f\"Unexpected success: {reason}\"\n+        else:\n+            rep.longrepr = \"Unexpected success\"\n+        rep.outcome = \"failed\"\n+    elif item.config.option.runxfail:\n+        # Handle xfail behavior under --runxfail, but don't bypass skip location adjustment\n+        if xfailed and rep.when == \"call\" and rep.skipped:\n+            # Convert xfail skip to actual skip under --runxfail\n+            pass\n+    elif xfailed:\n+        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+            assert call.excinfo.value.msg is not None\n+            rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+            rep.outcome = \"skipped\"\n+        elif call.when == \"call\":\n+            if xfailed.strict:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n+            else:\n+                rep.outcome = \"passed\"\n+                rep.wasxfail = xfailed.reason\n+        elif call.when == \"setup\":\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+        else:\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+    \n+    # Skip location adjustment logic - should run regardless of --runxfail\n+    if (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n         and type(rep.longrepr) is tuple\n",
    "variant_1": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..b83720fac 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,8 +270,39 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                if item.config.option.runxfail:\n+                    rep.outcome = \"failed\"\n+                else:\n+                    rep.wasxfail = \"reason: \" + xfailed.reason\n+                    rep.outcome = \"skipped\"\n+        else:\n+            if item.config.option.runxfail:\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.wasxfail = \"reason: \" + xfailed.reason\n+                rep.outcome = \"skipped\"\n+    if call.excinfo and isinstance(call.excinfo.value, skip.Exception):\n+        # Compute the skip location to report.  Note we report the\n+        # user code, not the direct skip() call.\n+        assert call.excinfo.traceback is not None\n+        for i, line in enumerate(call.excinfo.traceback):\n+            if line.frame.f_locals.get(\"__tracebackhide__\"):\n+                continue\n+            break\n+        else:\n+            i = len(call.excinfo.traceback) - 1\n+        rep.longrepr = call.excinfo.traceback[i:].getcrashentry()\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,7 +322,50 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n-    elif (\n+\n+def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n+    outcome = call.excinfo\n+    rep = outcome.get_result()\n+    xfailed = item._store.get(xfailed_key, None)\n+    # unittest.SkipTest reports class name, we just want the message\n+    if (\n+        outcome.skipped\n+        and call.excinfo is not None\n+        and call.excinfo.errisinstance(unittest.SkipTest)\n+    ):\n+        rep.longrepr = call.excinfo.value.args[0]\n+\n+    if item._store.get(evalxfail_key, None):\n+        if call.excinfo is not None:\n+            if call.excinfo.errisinstance(xfail.Exception):\n+                assert call.excinfo.value.msg is not None\n+                rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+                rep.outcome = \"skipped\"\n+            else:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[NOTRUN] \" + call.excinfo.getrepr(style=\"short\")\n+        elif call.when == \"call\":\n+            rep.outcome = \"failed\"\n+            rep.longrepr = \"[NOTRUN] test passes unexpectedly\"\n+\n+    elif xfailed and not item.config.option.runxfail:\n+        if call.excinfo is not None:\n+            if call.excinfo.errisinstance(xfail.Exception):\n+                assert call.excinfo.value.msg is not None\n+                rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+                rep.outcome = \"skipped\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        elif call.when == \"call\":\n+            if xfailed.strict:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n+            else:\n+                rep.outcome = \"passed\"\n+                rep.wasxfail = xfailed.reason\n+    \n+    if (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n         and type(rep.longrepr) is tuple\n",
    "variant_2": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..756ca36f9 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,8 +270,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -282,6 +281,69 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             if raises is not None and not isinstance(call.excinfo.value, raises):\n                 rep.outcome = \"failed\"\n             else:\n+                if item.config.option.runxfail:\n+                    rep.outcome = \"failed\"\n+                else:\n+                    rep.wasxfail = \"reason: \" + xfailed.reason\n+                    rep.outcome = \"skipped\"\n+        else:\n+            if item.config.option.runxfail:\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.wasxfail = \"reason: \" + xfailed.reason\n+                rep.outcome = \"skipped\"\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        elif call.when == \"call\":\n+            if xfailed.strict:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n+            else:\n+                rep.outcome = \"passed\"\n+                rep.wasxfail = xfailed.reason\n+\n+def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n+    outcome = call.excinfo\n+    rep = outcome.get_result()\n+    xfailed = item._store.get(xfailed_key, None)\n+    # unittest special case, see setting of unexpectedsuccess\n+    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n+        reason = item._store[unexpectedsuccess_key]\n+        if reason:\n+            rep.longrepr = f\"Unexpected success: {reason}\"\n+        else:\n+            rep.longrepr = \"Unexpected success\"\n+        rep.outcome = \"failed\"\n+    elif item.config.option.runxfail:\n+        # Handle xfail behavior under --runxfail, but don't bypass skip location adjustment\n+        if xfailed and call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n+            # Convert xfail to regular failure under --runxfail\n+            rep.outcome = \"failed\"\n+    elif xfailed:\n+        if call.excinfo:\n+            if call.excinfo.errisinstance(xfail.Exception):\n                 rep.outcome = \"skipped\"\n                 rep.wasxfail = xfailed.reason\n         elif call.when == \"call\":\n@@ -291,7 +353,9 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n-    elif (\n+    \n+    # Skip location adjustment - always run this logic regardless of --runxfail\n+    if (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n         and type(rep.longrepr) is tuple\n",
    "variant_3": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..dcd9d3f81 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,8 +270,41 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                if item.config.option.runxfail:\n+                    rep.outcome = \"failed\"\n+                else:\n+                    rep.wasxfail = \"reason: \" + xfailed.reason\n+                    rep.outcome = \"skipped\"\n+        else:\n+            if item.config.option.runxfail:\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.wasxfail = \"reason: \" + xfailed.reason\n+                rep.outcome = \"skipped\"\n+\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,7 +324,42 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n-    elif (\n+\n+def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n+    outcome = call.excinfo\n+    rep = outcome.get_result()\n+    xfailed = item._store.get(xfailed_key, None)\n+    # unittest special case, see setting of unexpectedsuccess\n+    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n+        reason = item._store[unexpectedsuccess_key]\n+        if reason:\n+            rep.longrepr = f\"Unexpected success: {reason}\"\n+        else:\n+            rep.longrepr = \"Unexpected success\"\n+        rep.outcome = \"failed\"\n+    elif item.config.option.runxfail:\n+        # Handle runxfail but don't bypass skip location adjustment\n+        if xfailed is not None:\n+            # Only modify xfail behavior, let skip location adjustment proceed below\n+            pass\n+    elif xfailed is not None:\n+        if call.excinfo:\n+            if call.excinfo.errisinstance(xfail.Exception):\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+            else:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n+        elif call.when == \"call\":\n+            if xfailed.strict:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n+            else:\n+                rep.outcome = \"passed\"\n+                rep.wasxfail = xfailed.reason\n+    \n+    # Skip location adjustment - always execute regardless of runxfail\n+    if (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n         and type(rep.longrepr) is tuple\n",
    "variant_4": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..b4f1f98eb 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,8 +270,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -282,8 +281,69 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             if raises is not None and not isinstance(call.excinfo.value, raises):\n                 rep.outcome = \"failed\"\n             else:\n+                if not item.config.option.runxfail:\n+                    rep.outcome = \"skipped\"\n+                    rep.wasxfail = xfailed.reason\n+        else:\n+            if not item.config.option.runxfail:\n                 rep.outcome = \"skipped\"\n                 rep.wasxfail = xfailed.reason\n+\n+    if call.excinfo and call.excinfo.errisinstance(skip.Exception):\n+        # Skipped by mark.skip or mark.skipif\n+        rep.outcome = \"skipped\"\n+        r = call.excinfo._getreprcrash()\n+        if len(r.path.parts) >= 3 and r.path.parts[-3:-1] == (\"_pytest\", \"skipping\"):\n+            # skipped by mark.skipif; use the mark's location\n+            # TODO: check all the pytest skip exceptions, not just skipif\n+            skipped = item._store.get(skipped_by_mark_key, None)\n+            if skipped:\n+                rep.longrepr = skipped.longrepr\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        elif call.when == \"call\":\n+            if xfailed.strict:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n+            else:\n+                rep.outcome = \"passed\"\n+                rep.wasxfail = xfailed.reason\n+\n+def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n+    outcome = call.excinfo\n+    rep = outcome.get_result()\n+    xfailed = item._store.get(xfailed_key, None)\n+    # unittest special case, see setting of unexpectedsuccess\n+    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n+        reason = item._store[unexpectedsuccess_key]\n+        if reason:\n+            rep.longrepr = \"Unexpected success: {}\".format(reason)\n+        else:\n+            rep.longrepr = \"Unexpected success\"\n+        rep.outcome = \"failed\"\n+    elif item.config.option.runxfail:\n+        # Handle --runxfail flag but don't bypass skip location adjustment\n+        if xfailed:\n+            # Only process xfail-related logic here, skip location adjustment will happen below\n+            pass\n+    elif xfailed:\n+        if call.excinfo:\n+            if call.excinfo.errisinstance(xfail.Exception):\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+            else:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XFAIL] \" + xfailed.reason\n         elif call.when == \"call\":\n             if xfailed.strict:\n                 rep.outcome = \"failed\"\n@@ -291,7 +351,9 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n-    elif (\n+    \n+    # Skip location adjustment - always process regardless of --runxfail\n+    if (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n         and type(rep.longrepr) is tuple\n",
    "variant_5": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..d517480b5 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,8 +270,38 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                if item.config.option.runxfail:\n+                    rep.outcome = \"failed\"\n+                else:\n+                    rep.wasxfail = \"reason: \" + xfailed.reason\n+                    rep.outcome = \"skipped\"\n+        else:\n+            if item.config.option.runxfail:\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.wasxfail = \"reason: \" + xfailed.reason\n+                rep.outcome = \"skipped\"\n+\n+    if call.when == \"call\":\n+        if rep.outcome == \"skipped\" and type(rep.longrepr) is tuple:\n+            # skipped by mark.skipif; change the location of the failure\n+            # to point to the item definition, otherwise it will display\n+            # the location of where the skip exception was raised within pytest\n+            _, _, reason = rep.longrepr\n+            filename, line = item.reportinfo()[:2]\n+            assert line is not None\n+            rep.longrepr = str(filename), line + 1, reason\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,7 +321,46 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n-    elif (\n+\n+def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n+    outcome = call.excinfo\n+    rep = outcome.get_result()\n+    xfailed = item._store.get(xfailed_key, None)\n+    # unittest special case, see setting of unexpectedsuccess_key\n+    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n+        reason = item._store[unexpectedsuccess_key]\n+        if reason:\n+            rep.longrepr = f\"Unexpected success: {reason}\"\n+        else:\n+            rep.longrepr = \"Unexpected success\"\n+        rep.outcome = \"failed\"\n+    elif item.config.option.runxfail:\n+        # Only bypass xfail-specific logic, not skip location adjustment\n+        if xfailed:\n+            if call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+            elif call.when == \"call\":\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XFAIL(run)] \" + xfailed.reason\n+    elif xfailed:\n+        if call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n+            if call.excinfo.errisinstance(pytest.skip.Exception):\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        elif call.when == \"call\":\n+            if xfailed.strict:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n+            else:\n+                rep.outcome = \"passed\"\n+                rep.wasxfail = xfailed.reason\n+    \n+    # Always perform skip location adjustment regardless of runxfail\n+    if (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n         and type(rep.longrepr) is tuple\n",
    "variant_6": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..d3089e9f5 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,8 +270,40 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                if item.config.option.runxfail:\n+                    rep.outcome = \"failed\"\n+                else:\n+                    rep.wasxfail = \"reason: \" + xfailed.reason\n+                    rep.outcome = \"skipped\"\n+        else:\n+            if item.config.option.runxfail:\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.wasxfail = \"reason: \" + xfailed.reason\n+                rep.outcome = \"skipped\"\n+    elif (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +323,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_7": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..891279a30 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,8 +270,40 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                if item.config.option.runxfail:\n+                    rep.outcome = \"failed\"\n+                else:\n+                    rep.wasxfail = \"reason: \" + xfailed.reason\n+                    rep.outcome = \"skipped\"\n+        else:\n+            if item.config.option.runxfail:\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.wasxfail = \"reason: \" + xfailed.reason\n+                rep.outcome = \"skipped\"\n+    elif (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skip marker, fix the location of the reported\n+        # skipped test to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +323,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_8": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..832628a50 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -270,8 +270,38 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                if item.config.option.runxfail:\n+                    rep.outcome = \"failed\"\n+                else:\n+                    rep.wasxfail = \"reason: \" + xfailed.reason\n+                    rep.outcome = \"skipped\"\n+        else:\n+            if item.config.option.runxfail:\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.wasxfail = \"reason: \" + xfailed.reason\n+                rep.outcome = \"skipped\"\n+\n+    if call.when == \"call\":\n+        if rep.outcome == \"skipped\" and type(rep.longrepr) is tuple:\n+            # skipped by mark.skipif; change the location of the failure\n+            # to point to the item definition, otherwise it will display\n+            # the location of where the skip exception is raised within pytest\n+            _, _, reason = rep.longrepr\n+            filename, line = item.reportinfo()[:2]\n+            assert line is not None\n+            rep.longrepr = str(filename), line + 1, reason\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,7 +321,48 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n-    elif (\n+\n+def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\n+    outcome = call.excinfo\n+    rep = outcome.get_result()\n+    xfailed = item._store.get(xfailed_key, None)\n+    # unittest.SkipTest reports class name only.\n+    if isinstance(rep.longrepr, tuple):\n+        modpath, lineno, msg = rep.longrepr\n+        # Checking that modpath is a string on purpose since\n+        # unittest.SkipTest.args can contain arbitrary stuff.\n+        if isinstance(modpath, str):\n+            rep.longrepr = modpath, lineno, msg\n+\n+    if item.config.option.runxfail:\n+        # don't interfere with runxfail for xfail tests\n+        if xfailed:\n+            return\n+    elif xfailed:\n+        if call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n+            assert call.excinfo.value.msg is not None\n+            rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+            rep.outcome = \"skipped\"\n+        elif call.when == \"setup\":\n+            rep.skipped = True\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+        elif call.when == \"teardown\":\n+            if call.excinfo:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = xfailed.reason\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        elif call.when == \"call\":\n+            if xfailed.strict:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n+            else:\n+                rep.outcome = \"passed\"\n+                rep.wasxfail = xfailed.reason\n+    \n+    if (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n         and type(rep.longrepr) is tuple\n"
  }
}