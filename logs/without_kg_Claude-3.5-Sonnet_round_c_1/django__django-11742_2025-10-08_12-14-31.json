{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 201-210)": "\n    def check(self, **kwargs):\n        return [\n            *self._check_field_name(),\n            *self._check_choices(),\n            *self._check_choices_max_length(),\n            *self._check_db_index(),\n            *self._check_null_allowed_for_primary_keys(),\n            *self._check_backend_specific_checks(**kwargs),\n            *self._check_validators(),\n            *self._check_deprecation_details(),\n        ]\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 293-325)": "\n    def _check_db_index(self):\n        if self.db_index not in (None, True, False):\n            return [\n                checks.Error(\n                    \"'db_index' must be None, True or False.\",\n                    obj=self,\n                    id='fields.E006',\n                )\n            ]\n        else:\n            return []\n\n    def _check_choices_max_length(self):\n        if self.choices is None or self.max_length is None:\n            return []\n        \n        if not self.flatchoices:\n            return []\n        \n        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value in 'choices' ({max_choice_length} characters).\",\n                    hint=f\"Increase 'max_length' to at least {max_choice_length}.\",\n                    obj=self,\n                    id='fields.E009',\n                )\n            ]\n        return []\n\n    def _check_null_allowed_for_primary_keys(self):\n        if (self.primary_key and self.null and\n                not connection.features.interprets_empty_strings_as_nulls):\n            # We cannot reliably check this for backends like Oracle which\n            # consider NULL and '' to be equal (and thus set up\n            # character-based fields a little differently).\n            return [\n                checks.Error(\n                    'Primary keys must not have null=True.',\n                    hint=('Set null=False on the field, or '\n                          'remove primary_key=True argument.'),\n                    obj=self,\n                    id='fields.E007',\n                )\n            ]\n        else:\n            return []\n\n    def _check_backend_specific_checks(self, **kwargs):\n        app_label = self.model._meta.app_label\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 201-210)": [
      "\n    def check(self, **kwargs):\n        return [\n            *self._check_field_name(),\n            *self._check_choices(),\n            *self._check_choices_max_length(),\n            *self._check_db_index(),\n            *self._check_null_allowed_for_primary_keys(),\n            *self._check_backend_specific_checks(**kwargs),\n            *self._check_validators(),\n            *self._check_deprecation_details(),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *self._check_field_name(),\n            *self._check_choices(),\n            *self._check_choices_max_length(),\n            *self._check_db_index(),\n            *self._check_null_allowed_for_primary_keys(),\n            *self._check_backend_specific_checks(**kwargs),\n            *self._check_validators(),\n            *self._check_deprecation_details(),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *self._check_field_name(),\n            *self._check_choices(),\n            *self._check_choices_max_length(),\n            *self._check_db_index(),\n            *self._check_null_allowed_for_primary_keys(),\n            *self._check_backend_specific_checks(**kwargs),\n            *self._check_validators(),\n            *self._check_deprecation_details(),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *self._check_field_name(),\n            *self._check_choices(),\n            *self._check_choices_max_length(),\n            *self._check_db_index(),\n            *self._check_null_allowed_for_primary_keys(),\n            *self._check_backend_specific_checks(**kwargs),\n            *self._check_validators(),\n            *self._check_deprecation_details(),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *self._check_field_name(),\n            *self._check_choices(),\n            *self._check_choices_max_length(),\n            *self._check_db_index(),\n            *self._check_null_allowed_for_primary_keys(),\n            *self._check_backend_specific_checks(**kwargs),\n            *self._check_validators(),\n            *self._check_deprecation_details(),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *self._check_field_name(),\n            *self._check_choices(),\n            *self._check_choices_max_length(),\n            *self._check_db_index(),\n            *self._check_null_allowed_for_primary_keys(),\n            *self._check_backend_specific_checks(**kwargs),\n            *self._check_validators(),\n            *self._check_deprecation_details(),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *self._check_field_name(),\n            *self._check_choices(),\n            *self._check_choices_max_length(),\n            *self._check_db_index(),\n            *self._check_null_allowed_for_primary_keys(),\n            *self._check_backend_specific_checks(**kwargs),\n            *self._check_validators(),\n            *self._check_deprecation_details(),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *self._check_field_name(),\n            *self._check_choices(),\n            *self._check_choices_max_length(),\n            *self._check_db_index(),\n            *self._check_null_allowed_for_primary_keys(),\n            *self._check_backend_specific_checks(**kwargs),\n            *self._check_validators(),\n            *self._check_deprecation_details(),\n        ]\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 293-325)": [
      "\n    def _check_db_index(self):\n        if self.db_index not in (None, True, False):\n            return [\n                checks.Error(\n                    \"'db_index' must be None, True or False.\",\n                    obj=self,\n                    id='fields.E006',\n                )\n            ]\n        else:\n            return []\n\n    def _check_choices_max_length(self):\n        if self.choices is None or self.max_length is None:\n            return []\n\n        choice_max_length = max(\n            (len(str(choice)) for choice, _ in self.flatchoices),\n            default=0,\n        )\n        \n        if choice_max_length > self.max_length:\n            return [\n                checks.Error(\n                    \"Field's 'max_length' is too small to fit the longest value \"\n                    \"in 'choices' (%d characters).\" % choice_max_length,\n                    hint='Increase max_length to at least %d.' % choice_max_length,\n                    obj=self,\n                    id='fields.E009',\n                )\n            ]\n        return []\n\n    def _check_null_allowed_for_primary_keys(self):\n        if (self.primary_key and self.null and\n                not connection.features.interprets_empty_strings_as_nulls):\n            # We cannot reliably check this for backends like Oracle which\n            # consider NULL and '' to be equal (and thus set up\n            # character-based fields a little differently).\n            return [\n                checks.Error(\n                    'Primary keys must not have null=True.',\n                    hint=('Set null=False on the field, or '\n                          'remove primary_key=True argument.'),\n                    obj=self,\n                    id='fields.E007',\n                )\n            ]\n        else:\n            return []\n\n    def _check_backend_specific_checks(self, **kwargs):\n        app_label = self.model._meta.app_label\n",
      "\n    def _check_db_index(self):\n        if self.db_index not in (None, True, False):\n            return [\n                checks.Error(\n                    \"'db_index' must be None, True or False.\",\n                    obj=self,\n                    id='fields.E006',\n                )\n            ]\n        else:\n            return []\n\n    def _check_choices_max_length(self):\n        if self.choices is None or self.max_length is None:\n            return []\n        \n        if not hasattr(self, 'flatchoices') or not self.flatchoices:\n            return []\n        \n        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    'The longest choice value is %d characters, but max_length is %d.' % (\n                        max_choice_length, self.max_length\n                    ),\n                    hint='Increase max_length to at least %d characters.' % max_choice_length,\n                    obj=self,\n                    id='fields.E009',\n                )\n            ]\n        return []\n\n    def _check_null_allowed_for_primary_keys(self):\n        if (self.primary_key and self.null and\n                not connection.features.interprets_empty_strings_as_nulls):\n            # We cannot reliably check this for backends like Oracle which\n            # consider NULL and '' to be equal (and thus set up\n            # character-based fields a little differently).\n            return [\n                checks.Error(\n                    'Primary keys must not have null=True.',\n                    hint=('Set null=False on the field, or '\n                          'remove primary_key=True argument.'),\n                    obj=self,\n                    id='fields.E007',\n                )\n            ]\n        else:\n            return []\n\n    def _check_backend_specific_checks(self, **kwargs):\n        app_label = self.model._meta.app_label\n",
      "\n    def _check_db_index(self):\n        if self.db_index not in (None, True, False):\n            return [\n                checks.Error(\n                    \"'db_index' must be None, True or False.\",\n                    obj=self,\n                    id='fields.E006',\n                )\n            ]\n        else:\n            return []\n\n    def _check_choices_max_length(self):\n        if self.choices is None or self.max_length is None:\n            return []\n        \n        if not self.flatchoices:\n            return []\n        \n        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    \"Field's max_length is too small to fit the longest choice value.\",\n                    hint=f\"The longest choice value requires {max_choice_length} characters, \"\n                         f\"but max_length is only {self.max_length}. \"\n                         f\"Increase max_length to at least {max_choice_length}.\",\n                    obj=self,\n                    id='fields.E009',\n                )\n            ]\n        return []\n\n    def _check_null_allowed_for_primary_keys(self):\n        if (self.primary_key and self.null and\n                not connection.features.interprets_empty_strings_as_nulls):\n            # We cannot reliably check this for backends like Oracle which\n            # consider NULL and '' to be equal (and thus set up\n            # character-based fields a little differently).\n            return [\n                checks.Error(\n                    'Primary keys must not have null=True.',\n                    hint=('Set null=False on the field, or '\n                          'remove primary_key=True argument.'),\n                    obj=self,\n                    id='fields.E007',\n                )\n            ]\n        else:\n            return []\n\n    def _check_backend_specific_checks(self, **kwargs):\n        app_label = self.model._meta.app_label\n",
      "\n    def _check_choices_max_length(self):\n        if self.choices is None or self.max_length is None:\n            return []\n        \n        if not self.flatchoices:\n            return []\n        \n        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    \"Field's 'max_length' is too small to fit the longest value \"\n                    \"in 'choices' (%d characters).\" % max_choice_length,\n                    hint=\"Increase 'max_length' to %d or more.\" % max_choice_length,\n                    obj=self,\n                    id='fields.E009',\n                )\n            ]\n        return []\n\n    def _check_db_index(self):\n        if self.db_index not in (None, True, False):\n            return [\n                checks.Error(\n                    \"'db_index' must be None, True or False.\",\n                    obj=self,\n                    id='fields.E006',\n                )\n            ]\n        else:\n            return []\n\n    def _check_null_allowed_for_primary_keys(self):\n        if (self.primary_key and self.null and\n                not connection.features.interprets_empty_strings_as_nulls):\n            # We cannot reliably check this for backends like Oracle which\n            # consider NULL and '' to be equal (and thus set up\n            # character-based fields a little differently).\n            return [\n                checks.Error(\n                    'Primary keys must not have null=True.',\n                    hint=('Set null=False on the field, or '\n                          'remove primary_key=True argument.'),\n                    obj=self,\n                    id='fields.E007',\n                )\n            ]\n        else:\n            return []\n\n    def _check_backend_specific_checks(self, **kwargs):\n        app_label = self.model._meta.app_label\n",
      "\n    def _check_db_index(self):\n        if self.db_index not in (None, True, False):\n            return [\n                checks.Error(\n                    \"'db_index' must be None, True or False.\",\n                    obj=self,\n                    id='fields.E006',\n                )\n            ]\n        else:\n            return []\n\n    def _check_choices_max_length(self):\n        if self.choices is None or self.max_length is None:\n            return []\n\n        choice_max_length = max(\n            len(str(choice)) for choice, _ in self.flatchoices\n        ) if self.flatchoices else 0\n\n        if choice_max_length > self.max_length:\n            return [\n                checks.Error(\n                    \"Field's 'max_length' is too small to fit the longest value \"\n                    \"in 'choices' (%d characters).\" % choice_max_length,\n                    hint='Increase the max_length argument to at least %d.' % choice_max_length,\n                    obj=self,\n                    id='fields.E009',\n                )\n            ]\n        else:\n            return []\n\n    def _check_null_allowed_for_primary_keys(self):\n        if (self.primary_key and self.null and\n                not connection.features.interprets_empty_strings_as_nulls):\n            # We cannot reliably check this for backends like Oracle which\n            # consider NULL and '' to be equal (and thus set up\n            # character-based fields a little differently).\n            return [\n                checks.Error(\n                    'Primary keys must not have null=True.',\n                    hint=('Set null=False on the field, or '\n                          'remove primary_key=True argument.'),\n                    obj=self,\n                    id='fields.E007',\n                )\n            ]\n        else:\n            return []\n\n    def _check_backend_specific_checks(self, **kwargs):\n        app_label = self.model._meta.app_label\n",
      "\n    def _check_db_index(self):\n        if self.db_index not in (None, True, False):\n            return [\n                checks.Error(\n                    \"'db_index' must be None, True or False.\",\n                    obj=self,\n                    id='fields.E006',\n                )\n            ]\n        else:\n            return []\n\n    def _check_choices_max_length(self):\n        if self.choices is None or self.max_length is None:\n            return []\n        \n        if not self.flatchoices:\n            return []\n        \n        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    hint=f\"Set 'max_length' to at least {max_choice_length}.\",\n                    obj=self,\n                    id='fields.E009',\n                )\n            ]\n        else:\n            return []\n\n    def _check_null_allowed_for_primary_keys(self):\n        if (self.primary_key and self.null and\n                not connection.features.interprets_empty_strings_as_nulls):\n            # We cannot reliably check this for backends like Oracle which\n            # consider NULL and '' to be equal (and thus set up\n            # character-based fields a little differently).\n            return [\n                checks.Error(\n                    'Primary keys must not have null=True.',\n                    hint=('Set null=False on the field, or '\n                          'remove primary_key=True argument.'),\n                    obj=self,\n                    id='fields.E007',\n                )\n            ]\n        else:\n            return []\n\n    def _check_backend_specific_checks(self, **kwargs):\n        app_label = self.model._meta.app_label\n",
      "\n    def _check_db_index(self):\n        if self.db_index not in (None, True, False):\n            return [\n                checks.Error(\n                    \"'db_index' must be None, True or False.\",\n                    obj=self,\n                    id='fields.E006',\n                )\n            ]\n        else:\n            return []\n\n    def _check_choices_max_length(self):\n        if self.choices is None or self.max_length is None:\n            return []\n        \n        if not self.flatchoices:\n            return []\n            \n        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    hint=f\"Set 'max_length' to at least {max_choice_length}.\",\n                    obj=self,\n                    id='fields.E009',\n                )\n            ]\n        return []\n\n    def _check_null_allowed_for_primary_keys(self):\n        if (self.primary_key and self.null and\n                not connection.features.interprets_empty_strings_as_nulls):\n            # We cannot reliably check this for backends like Oracle which\n            # consider NULL and '' to be equal (and thus set up\n            # character-based fields a little differently).\n            return [\n                checks.Error(\n                    'Primary keys must not have null=True.',\n                    hint=('Set null=False on the field, or '\n                          'remove primary_key=True argument.'),\n                    obj=self,\n                    id='fields.E007',\n                )\n            ]\n        else:\n            return []\n\n    def _check_backend_specific_checks(self, **kwargs):\n        app_label = self.model._meta.app_label\n",
      "\n    def _check_db_index(self):\n        if self.db_index not in (None, True, False):\n            return [\n                checks.Error(\n                    \"'db_index' must be None, True or False.\",\n                    obj=self,\n                    id='fields.E006',\n                )\n            ]\n        else:\n            return []\n\n    def _check_choices_max_length(self):\n        if self.choices is None or self.max_length is None:\n            return []\n        \n        if not self.flatchoices:\n            return []\n        \n        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    \"'max_length' is too small to fit the longest value \"\n                    \"in 'choices' (%d characters).\" % max_choice_length,\n                    hint='Increase max_length to at least %d.' % max_choice_length,\n                    obj=self,\n                    id='fields.E009',\n                )\n            ]\n        else:\n            return []\n\n    def _check_null_allowed_for_primary_keys(self):\n        if (self.primary_key and self.null and\n                not connection.features.interprets_empty_strings_as_nulls):\n            # We cannot reliably check this for backends like Oracle which\n            # consider NULL and '' to be equal (and thus set up\n            # character-based fields a little differently).\n            return [\n                checks.Error(\n                    'Primary keys must not have null=True.',\n                    hint=('Set null=False on the field, or '\n                          'remove primary_key=True argument.'),\n                    obj=self,\n                    id='fields.E007',\n                )\n            ]\n        else:\n            return []\n\n    def _check_backend_specific_checks(self, **kwargs):\n        app_label = self.model._meta.app_label\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..7e03d69e36 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -198,10 +198,12 @@ class Field(RegisterLookupMixin):\n             return '<%s: %s>' % (path, name)\n         return '<%s>' % path\n \n+\n     def check(self, **kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_choices_max_length(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n             *self._check_backend_specific_checks(**kwargs),\n@@ -291,6 +293,29 @@ class Field(RegisterLookupMixin):\n             )\n         ]\n \n+\n+    def _check_choices_max_length(self):\n+        \"\"\"\n+        Check that max_length is sufficient for the longest choice value.\n+        \"\"\"\n+        if self.choices is None or self.max_length is None:\n+            return []\n+        \n+        # Use existing flatchoices to get all choice values\n+        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices) if self.flatchoices else 0\n+        \n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    hint=f\"Increase 'max_length' to at least {max_choice_length}.\",\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        return []\n+\n     def _check_db_index(self):\n         if self.db_index not in (None, True, False):\n             return [\n",
    "variant_0": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..18f58d32e6 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -198,10 +198,12 @@ class Field(RegisterLookupMixin):\n             return '<%s: %s>' % (path, name)\n         return '<%s>' % path\n \n+\n     def check(self, **kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_choices_max_length(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n             *self._check_backend_specific_checks(**kwargs),\n@@ -303,6 +305,25 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+    def _check_choices_max_length(self):\n+        if self.choices is None or self.max_length is None:\n+            return []\n+        \n+        if not self.flatchoices:\n+            return []\n+        \n+        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value in 'choices' ({max_choice_length} characters).\",\n+                    hint=f\"Increase 'max_length' to at least {max_choice_length}.\",\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        return []\n+\n     def _check_null_allowed_for_primary_keys(self):\n         if (self.primary_key and self.null and\n                 not connection.features.interprets_empty_strings_as_nulls):\n",
    "variant_1": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..6bc174072b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -198,10 +198,12 @@ class Field(RegisterLookupMixin):\n             return '<%s: %s>' % (path, name)\n         return '<%s>' % path\n \n+\n     def check(self, **kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_choices_max_length(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n             *self._check_backend_specific_checks(**kwargs),\n@@ -303,6 +305,27 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+    def _check_choices_max_length(self):\n+        if self.choices is None or self.max_length is None:\n+            return []\n+\n+        choice_max_length = max(\n+            (len(str(choice)) for choice, _ in self.flatchoices),\n+            default=0,\n+        )\n+        \n+        if choice_max_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    \"Field's 'max_length' is too small to fit the longest value \"\n+                    \"in 'choices' (%d characters).\" % choice_max_length,\n+                    hint='Increase max_length to at least %d.' % choice_max_length,\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        return []\n+\n     def _check_null_allowed_for_primary_keys(self):\n         if (self.primary_key and self.null and\n                 not connection.features.interprets_empty_strings_as_nulls):\n",
    "variant_2": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..95481060bc 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -198,10 +198,12 @@ class Field(RegisterLookupMixin):\n             return '<%s: %s>' % (path, name)\n         return '<%s>' % path\n \n+\n     def check(self, **kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_choices_max_length(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n             *self._check_backend_specific_checks(**kwargs),\n@@ -303,6 +305,27 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+    def _check_choices_max_length(self):\n+        if self.choices is None or self.max_length is None:\n+            return []\n+        \n+        if not hasattr(self, 'flatchoices') or not self.flatchoices:\n+            return []\n+        \n+        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    'The longest choice value is %d characters, but max_length is %d.' % (\n+                        max_choice_length, self.max_length\n+                    ),\n+                    hint='Increase max_length to at least %d characters.' % max_choice_length,\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        return []\n+\n     def _check_null_allowed_for_primary_keys(self):\n         if (self.primary_key and self.null and\n                 not connection.features.interprets_empty_strings_as_nulls):\n",
    "variant_3": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..8a54000daf 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -198,10 +198,12 @@ class Field(RegisterLookupMixin):\n             return '<%s: %s>' % (path, name)\n         return '<%s>' % path\n \n+\n     def check(self, **kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_choices_max_length(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n             *self._check_backend_specific_checks(**kwargs),\n@@ -303,6 +305,27 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+    def _check_choices_max_length(self):\n+        if self.choices is None or self.max_length is None:\n+            return []\n+        \n+        if not self.flatchoices:\n+            return []\n+        \n+        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    \"Field's max_length is too small to fit the longest choice value.\",\n+                    hint=f\"The longest choice value requires {max_choice_length} characters, \"\n+                         f\"but max_length is only {self.max_length}. \"\n+                         f\"Increase max_length to at least {max_choice_length}.\",\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        return []\n+\n     def _check_null_allowed_for_primary_keys(self):\n         if (self.primary_key and self.null and\n                 not connection.features.interprets_empty_strings_as_nulls):\n",
    "variant_4": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..1b0799c61d 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -198,10 +198,12 @@ class Field(RegisterLookupMixin):\n             return '<%s: %s>' % (path, name)\n         return '<%s>' % path\n \n+\n     def check(self, **kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_choices_max_length(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n             *self._check_backend_specific_checks(**kwargs),\n@@ -291,6 +293,26 @@ class Field(RegisterLookupMixin):\n             )\n         ]\n \n+    def _check_choices_max_length(self):\n+        if self.choices is None or self.max_length is None:\n+            return []\n+        \n+        if not self.flatchoices:\n+            return []\n+        \n+        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    \"Field's 'max_length' is too small to fit the longest value \"\n+                    \"in 'choices' (%d characters).\" % max_choice_length,\n+                    hint=\"Increase 'max_length' to %d or more.\" % max_choice_length,\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        return []\n+\n     def _check_db_index(self):\n         if self.db_index not in (None, True, False):\n             return [\n",
    "variant_5": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..6231ab44ef 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -198,10 +198,12 @@ class Field(RegisterLookupMixin):\n             return '<%s: %s>' % (path, name)\n         return '<%s>' % path\n \n+\n     def check(self, **kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_choices_max_length(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n             *self._check_backend_specific_checks(**kwargs),\n@@ -303,6 +305,27 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+    def _check_choices_max_length(self):\n+        if self.choices is None or self.max_length is None:\n+            return []\n+\n+        choice_max_length = max(\n+            len(str(choice)) for choice, _ in self.flatchoices\n+        ) if self.flatchoices else 0\n+\n+        if choice_max_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    \"Field's 'max_length' is too small to fit the longest value \"\n+                    \"in 'choices' (%d characters).\" % choice_max_length,\n+                    hint='Increase the max_length argument to at least %d.' % choice_max_length,\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        else:\n+            return []\n+\n     def _check_null_allowed_for_primary_keys(self):\n         if (self.primary_key and self.null and\n                 not connection.features.interprets_empty_strings_as_nulls):\n",
    "variant_6": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..e2b84b29be 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -198,10 +198,12 @@ class Field(RegisterLookupMixin):\n             return '<%s: %s>' % (path, name)\n         return '<%s>' % path\n \n+\n     def check(self, **kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_choices_max_length(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n             *self._check_backend_specific_checks(**kwargs),\n@@ -303,6 +305,27 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+    def _check_choices_max_length(self):\n+        if self.choices is None or self.max_length is None:\n+            return []\n+        \n+        if not self.flatchoices:\n+            return []\n+        \n+        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    hint=f\"Set 'max_length' to at least {max_choice_length}.\",\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        else:\n+            return []\n+\n     def _check_null_allowed_for_primary_keys(self):\n         if (self.primary_key and self.null and\n                 not connection.features.interprets_empty_strings_as_nulls):\n",
    "variant_7": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..fa0f387b33 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -198,10 +198,12 @@ class Field(RegisterLookupMixin):\n             return '<%s: %s>' % (path, name)\n         return '<%s>' % path\n \n+\n     def check(self, **kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_choices_max_length(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n             *self._check_backend_specific_checks(**kwargs),\n@@ -303,6 +305,26 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+    def _check_choices_max_length(self):\n+        if self.choices is None or self.max_length is None:\n+            return []\n+        \n+        if not self.flatchoices:\n+            return []\n+            \n+        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    hint=f\"Set 'max_length' to at least {max_choice_length}.\",\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        return []\n+\n     def _check_null_allowed_for_primary_keys(self):\n         if (self.primary_key and self.null and\n                 not connection.features.interprets_empty_strings_as_nulls):\n",
    "variant_8": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..c47def98e9 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -198,10 +198,12 @@ class Field(RegisterLookupMixin):\n             return '<%s: %s>' % (path, name)\n         return '<%s>' % path\n \n+\n     def check(self, **kwargs):\n         return [\n             *self._check_field_name(),\n             *self._check_choices(),\n+            *self._check_choices_max_length(),\n             *self._check_db_index(),\n             *self._check_null_allowed_for_primary_keys(),\n             *self._check_backend_specific_checks(**kwargs),\n@@ -303,6 +305,27 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+    def _check_choices_max_length(self):\n+        if self.choices is None or self.max_length is None:\n+            return []\n+        \n+        if not self.flatchoices:\n+            return []\n+        \n+        max_choice_length = max(len(str(choice)) for choice, _ in self.flatchoices)\n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    \"'max_length' is too small to fit the longest value \"\n+                    \"in 'choices' (%d characters).\" % max_choice_length,\n+                    hint='Increase max_length to at least %d.' % max_choice_length,\n+                    obj=self,\n+                    id='fields.E009',\n+                )\n+            ]\n+        else:\n+            return []\n+\n     def _check_null_allowed_for_primary_keys(self):\n         if (self.primary_key and self.null and\n                 not connection.features.interprets_empty_strings_as_nulls):\n"
  }
}