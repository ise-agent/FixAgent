{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 2526-2527)": "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/options.py lines 245-246)": "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls_) for cls_ in cls._subclasses) or super().__subclasscheck__(subclass)\n",
    "Location 3 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 2520-2521)": "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
    "Location 4 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 2539-2542)": "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
    "Location 5 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 2548-2551)": "\nclass AutoFieldMeta(type):\n    @property\n    def _subclasses(self):\n        return (\n            BigAutoField, SmallAutoField\n        )\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 2526-2527)": [
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/options.py lines 245-246)": [
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls_) for cls_ in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, field_cls) for field_cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 2520-2521)": [
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 2539-2542)": [
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It's intentional that this inherits from type, not from Field. This is\n    because this metaclass is only used by AutoField.\n    \"\"\"\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It allows for the usage of \"AutoField\" in database backend lookups while\n    letting the user transparent use BigAutoField and SmallAutoField in model\n    definitions.\n    \"\"\"\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(self, instance):\n        return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(self, subclass):\n        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n",
      "\nclass AutoFieldMeta(type):\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, subcls) for subcls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\nclass AutoFieldMeta(type):\n    @property\n    def _subclasses(cls):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\nclass AutoFieldMeta(type):\n    @property\n    def _subclasses(self):\n        return (AutoField, BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\nclass AutoFieldMeta(type):\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, base_cls) for base_cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It's intentionally private to avoid creating a public metaclass API.\n\n    This metaclass provides the following features:\n\n    1. Overridden __subclasscheck__ method to maintain backward\n       compatibility as detailed in #27018.\n\n    2. Overridden __instancecheck__ method that warns on use of the\n       following pattern::\n\n           isinstance(auto_field_instance, AutoField)\n\n       This pattern will no longer be supported in Django 4.0. See #27018.\n    \"\"\"\n\n    @property\n    def _subclasses(cls):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        instance_type = type(instance)\n        if instance_type in cls._subclasses:\n            warnings.warn(\n                \"Using isinstance() to check for AutoField instances is \"\n                \"deprecated. Use instance.get_internal_type() == 'AutoField' \"\n                \"instead.\",\n                RemovedInDjango40Warning,\n                stacklevel=2,\n            )\n            return True\n        return super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls_) for cls_ in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\nclass AutoFieldMeta(type):\n    @property\n    def _subclasses(cls):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 2548-2551)": [
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It allows for the usage of \"AutoField\" in base classes but uses the\n    DEFAULT_AUTO_FIELD as the implementation field.\n    \"\"\"\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\nclass AutoFieldMeta(type):\n    @property\n    def _subclasses(self):\n        return (AutoField, BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, auto_field_cls) for auto_field_cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, auto_field_cls) for auto_field_cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It is intended that AutoFieldMixin become public API when it is possible\n    to create a non-integer AutoField.\n    \"\"\"\n    @property\n    def _subclasses(self):\n        return (AutoField, BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses)\n\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n",
      "\n    def __subclasscheck__(cls, subclass):\n        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..6ba1b7c70d 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2517,14 +2517,16 @@ class AutoFieldMeta(type):\n     \"\"\"\n \n     @property\n+\n     def _subclasses(self):\n         return (BigAutoField, SmallAutoField)\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2536,6 +2538,7 @@ class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n         return IntegerField().db_type(connection=connection)\n \n \n+\n class BigAutoField(AutoFieldMixin, BigIntegerField):\n \n     def get_internal_type(self):\n@@ -2545,6 +2548,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..31a45cd95b 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,6 +242,7 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n+\n         if not issubclass(pk_class, AutoField):\n             raise ValueError(\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n",
    "variant_0": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..76e4f96a7d 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2517,14 +2517,16 @@ class AutoFieldMeta(type):\n     \"\"\"\n \n     @property\n-    def _subclasses(self):\n-        return (BigAutoField, SmallAutoField)\n+\n+    def __subclasscheck__(self, subclass):\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2536,19 +2538,27 @@ class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n         return IntegerField().db_type(connection=connection)\n \n \n-class BigAutoField(AutoFieldMixin, BigIntegerField):\n \n-    def get_internal_type(self):\n-        return 'BigAutoField'\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return BigIntegerField().db_type(connection=connection)\n \n \n-class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n-    def get_internal_type(self):\n-        return 'SmallAutoField'\n+class AutoFieldMeta(type):\n+    @property\n+    def _subclasses(self):\n+        return (\n+            BigAutoField, SmallAutoField\n+        )\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return SmallIntegerField().db_type(connection=connection)\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..1ff2884019 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,9 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls_) for cls_ in cls._subclasses) or super().__subclasscheck__(subclass)\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_1": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..7cbfd338c4 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2517,14 +2517,16 @@ class AutoFieldMeta(type):\n     \"\"\"\n \n     @property\n-    def _subclasses(self):\n-        return (BigAutoField, SmallAutoField)\n+\n+    def __subclasscheck__(self, subclass):\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2536,19 +2538,45 @@ class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n         return IntegerField().db_type(connection=connection)\n \n \n-class BigAutoField(AutoFieldMixin, BigIntegerField):\n \n-    def get_internal_type(self):\n-        return 'BigAutoField'\n+class AutoFieldMeta(type):\n+    \"\"\"\n+    Metaclass to maintain backward inheritance compatibility for AutoField.\n+\n+    It's intentional that this inherits from type, not from Field. This is\n+    because this metaclass is only used by AutoField.\n+    \"\"\"\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return BigIntegerField().db_type(connection=connection)\n \n \n-class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n-    def get_internal_type(self):\n-        return 'SmallAutoField'\n+class AutoFieldMeta(type):\n+    \"\"\"\n+    Metaclass to maintain backward inheritance compatibility for AutoField.\n+\n+    It allows for the usage of \"AutoField\" in base classes but uses the\n+    DEFAULT_AUTO_FIELD as the implementation field.\n+    \"\"\"\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return SmallIntegerField().db_type(connection=connection)\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..0895bcbe35 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,9 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_2": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..fb4d38d5c5 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2517,14 +2517,16 @@ class AutoFieldMeta(type):\n     \"\"\"\n \n     @property\n-    def _subclasses(self):\n-        return (BigAutoField, SmallAutoField)\n+\n+    def __subclasscheck__(self, subclass):\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2536,19 +2538,40 @@ class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n         return IntegerField().db_type(connection=connection)\n \n \n-class BigAutoField(AutoFieldMixin, BigIntegerField):\n \n-    def get_internal_type(self):\n-        return 'BigAutoField'\n+class AutoFieldMeta(type):\n+    \"\"\"\n+    Metaclass to maintain backward inheritance compatibility for AutoField.\n+\n+    It allows for the usage of \"AutoField\" in database backend lookups while\n+    letting the user transparent use BigAutoField and SmallAutoField in model\n+    definitions.\n+    \"\"\"\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(self, instance):\n+        return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(self, subclass):\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return BigIntegerField().db_type(connection=connection)\n \n \n-class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n-    def get_internal_type(self):\n-        return 'SmallAutoField'\n+class AutoFieldMeta(type):\n+    @property\n+    def _subclasses(self):\n+        return (AutoField, BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return SmallIntegerField().db_type(connection=connection)\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..1ff2884019 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,9 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls_) for cls_ in cls._subclasses) or super().__subclasscheck__(subclass)\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_3": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..ebb7f8ec92 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2517,14 +2517,16 @@ class AutoFieldMeta(type):\n     \"\"\"\n \n     @property\n-    def _subclasses(self):\n-        return (BigAutoField, SmallAutoField)\n+\n+    def __subclasscheck__(self, subclass):\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2536,19 +2538,25 @@ class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n         return IntegerField().db_type(connection=connection)\n \n \n-class BigAutoField(AutoFieldMixin, BigIntegerField):\n \n-    def get_internal_type(self):\n-        return 'BigAutoField'\n+class AutoFieldMeta(type):\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, subcls) for subcls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return BigIntegerField().db_type(connection=connection)\n \n \n-class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n-    def get_internal_type(self):\n-        return 'SmallAutoField'\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, auto_field_cls) for auto_field_cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return SmallIntegerField().db_type(connection=connection)\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..0895bcbe35 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,9 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_4": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..6f868cc395 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2517,14 +2517,16 @@ class AutoFieldMeta(type):\n     \"\"\"\n \n     @property\n-    def _subclasses(self):\n-        return (BigAutoField, SmallAutoField)\n+\n+    def __subclasscheck__(self, subclass):\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2536,19 +2538,25 @@ class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n         return IntegerField().db_type(connection=connection)\n \n \n-class BigAutoField(AutoFieldMixin, BigIntegerField):\n \n-    def get_internal_type(self):\n-        return 'BigAutoField'\n+class AutoFieldMeta(type):\n+    @property\n+    def _subclasses(cls):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return BigIntegerField().db_type(connection=connection)\n \n \n-class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n-    def get_internal_type(self):\n-        return 'SmallAutoField'\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, auto_field_cls) for auto_field_cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return SmallIntegerField().db_type(connection=connection)\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..0895bcbe35 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,9 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_5": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..5ad7ba2b21 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2517,14 +2517,16 @@ class AutoFieldMeta(type):\n     \"\"\"\n \n     @property\n-    def _subclasses(self):\n-        return (BigAutoField, SmallAutoField)\n+\n+    def __subclasscheck__(self, subclass):\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2536,19 +2538,25 @@ class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n         return IntegerField().db_type(connection=connection)\n \n \n-class BigAutoField(AutoFieldMixin, BigIntegerField):\n \n-    def get_internal_type(self):\n-        return 'BigAutoField'\n+class AutoFieldMeta(type):\n+    @property\n+    def _subclasses(self):\n+        return (AutoField, BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return BigIntegerField().db_type(connection=connection)\n \n \n-class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n-    def get_internal_type(self):\n-        return 'SmallAutoField'\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return SmallIntegerField().db_type(connection=connection)\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..0895bcbe35 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,9 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_6": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..28ec38aaf4 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2517,14 +2517,16 @@ class AutoFieldMeta(type):\n     \"\"\"\n \n     @property\n-    def _subclasses(self):\n-        return (BigAutoField, SmallAutoField)\n+\n+    def __subclasscheck__(self, subclass):\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2536,19 +2538,39 @@ class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n         return IntegerField().db_type(connection=connection)\n \n \n-class BigAutoField(AutoFieldMixin, BigIntegerField):\n \n-    def get_internal_type(self):\n-        return 'BigAutoField'\n+class AutoFieldMeta(type):\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, base_cls) for base_cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return BigIntegerField().db_type(connection=connection)\n \n \n-class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n-    def get_internal_type(self):\n-        return 'SmallAutoField'\n+class AutoFieldMeta(type):\n+    \"\"\"\n+    Metaclass to maintain backward inheritance compatibility for AutoField.\n+\n+    It is intended that AutoFieldMixin become public API when it is possible\n+    to create a non-integer AutoField.\n+    \"\"\"\n+    @property\n+    def _subclasses(self):\n+        return (AutoField, BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return SmallIntegerField().db_type(connection=connection)\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..0895bcbe35 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,9 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_7": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..d23df88edc 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2517,14 +2517,16 @@ class AutoFieldMeta(type):\n     \"\"\"\n \n     @property\n-    def _subclasses(self):\n-        return (BigAutoField, SmallAutoField)\n+\n+    def __subclasscheck__(self, subclass):\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2536,19 +2538,53 @@ class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n         return IntegerField().db_type(connection=connection)\n \n \n-class BigAutoField(AutoFieldMixin, BigIntegerField):\n \n-    def get_internal_type(self):\n-        return 'BigAutoField'\n+class AutoFieldMeta(type):\n+    \"\"\"\n+    Metaclass to maintain backward inheritance compatibility for AutoField.\n+\n+    It's intentionally private to avoid creating a public metaclass API.\n+\n+    This metaclass provides the following features:\n+\n+    1. Overridden __subclasscheck__ method to maintain backward\n+       compatibility as detailed in #27018.\n+\n+    2. Overridden __instancecheck__ method that warns on use of the\n+       following pattern::\n+\n+           isinstance(auto_field_instance, AutoField)\n+\n+       This pattern will no longer be supported in Django 4.0. See #27018.\n+    \"\"\"\n+\n+    @property\n+    def _subclasses(cls):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        instance_type = type(instance)\n+        if instance_type in cls._subclasses:\n+            warnings.warn(\n+                \"Using isinstance() to check for AutoField instances is \"\n+                \"deprecated. Use instance.get_internal_type() == 'AutoField' \"\n+                \"instead.\",\n+                RemovedInDjango40Warning,\n+                stacklevel=2,\n+            )\n+            return True\n+        return super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls_) for cls_ in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return BigIntegerField().db_type(connection=connection)\n \n \n-class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n-    def get_internal_type(self):\n-        return 'SmallAutoField'\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return SmallIntegerField().db_type(connection=connection)\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..81eeabc81d 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,9 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, field_cls) for field_cls in cls._subclasses) or super().__subclasscheck__(subclass)\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_8": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..7b3cfa8397 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2517,14 +2517,16 @@ class AutoFieldMeta(type):\n     \"\"\"\n \n     @property\n-    def _subclasses(self):\n-        return (BigAutoField, SmallAutoField)\n+\n+    def __subclasscheck__(self, subclass):\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return any(issubclass(subclass, cls) for cls in self._subclasses) or super().__subclasscheck__(subclass)\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2536,19 +2538,25 @@ class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n         return IntegerField().db_type(connection=connection)\n \n \n-class BigAutoField(AutoFieldMixin, BigIntegerField):\n \n-    def get_internal_type(self):\n-        return 'BigAutoField'\n+class AutoFieldMeta(type):\n+    @property\n+    def _subclasses(cls):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return BigIntegerField().db_type(connection=connection)\n \n \n-class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n-    def get_internal_type(self):\n-        return 'SmallAutoField'\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n \n     def rel_db_type(self, connection):\n         return SmallIntegerField().db_type(connection=connection)\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..0895bcbe35 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,9 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(cls, subclass):\n+        return any(issubclass(subclass, cls) for cls in cls._subclasses) or super().__subclasscheck__(subclass)\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n"
  }
}