{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/colorbar.py lines 1105-1111)": "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        \n        # Handle LogNorm special case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # Set vmin to a small positive value for LogNorm\n            if hasattr(self, 'mappable') and hasattr(self.mappable, 'get_array'):\n                array = self.mappable.get_array()\n                if array is not None and len(array) > 0:\n                    data_min = np.min(array[array > 0]) if np.any(array > 0) else 1e-10\n                    self.norm.vmin = max(data_min, 1e-10)\n                else:\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            b = self.norm.inverse(b)\n",
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/colorbar.py lines 510-512)": "\n        if mappable.norm != self.norm:\n            old_norm_type = type(self.norm)\n            new_norm_type = type(mappable.norm)\n            self.norm = mappable.norm\n            \n            # Handle LogNorm-specific requirements when norm type changes\n            if new_norm_type == colors.LogNorm and old_norm_type != colors.LogNorm:\n                # Ensure vmin > 0 for LogNorm to prevent division by zero\n                if hasattr(self.norm, 'vmin') and self.norm.vmin is not None:\n                    if self.norm.vmin <= 0:\n                        # Get valid data range from mappable\n                        if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                            data = mappable.get_array()\n                            valid_data = data[np.isfinite(data) & (data > 0)]\n                            if len(valid_data) > 0:\n                                self.norm.vmin = max(valid_data.min(), 1e-10)\n                            else:\n                                self.norm.vmin = 1e-10\n                        else:\n                            self.norm.vmin = 1e-10\n            \n            self._reset_locator_formatter_scale()\n",
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/colorbar.py lines 1107-1108)": "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Special handling for LogNorm to ensure vmin > 0\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # Use a small positive value or the minimum positive value from boundaries\n            positive_b = b[b > 0]\n            if len(positive_b) > 0:\n                self.norm.vmin = positive_b.min() * 0.1\n            else:\n                self.norm.vmin = 1e-10\n        \n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n",
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/colorbar.py lines 1170-1173)": "\ndef _reset_locator_formatter_scale(self):\n    \"\"\"\n    Reset the locator et al to defaults.  Any user-hardcoded changes\n    need to be re-entered if this gets called (either at init, or when\n    the mappable normal gets changed: Colorbar.update_normal)\n    \"\"\"\n    # Ensure valid vmin/vmax for LogNorm before processing values\n    if isinstance(self.norm, colors.LogNorm):\n        if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n            # Get data range from mappable to set a reasonable vmin\n            if hasattr(self.mappable, 'get_array'):\n                data = self.mappable.get_array()\n                if data is not None:\n                    data_min = np.ma.masked_invalid(data).min()\n                    if np.ma.is_masked(data_min):\n                        self.vmin = 1e-10\n                    else:\n                        self.vmin = max(float(data_min), 1e-10)\n                else:\n                    self.vmin = 1e-10\n            else:\n                self.vmin = 1e-10\n    \n    self._process_values()\n    self._locator = None\n    self._minorlocator = None\n    self._formatter = None\n    self._minorformatter = None\n    if (isinstance(self.mappable, contour.ContourSet) and\n            isinstance(self.norm, colors.LogNorm)):\n        # if contours have lognorm, give them a log scale...\n        self._set_scale('log')\n    elif (self.boundaries is not None or\n            isinstance(self.norm, colors.BoundaryNorm)):\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/colorbar.py lines 1105-1111)": [
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Handle LogNorm specifically to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # For LogNorm, vmin must be positive\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                # Try to get a reasonable positive vmin from the mappable's data\n                try:\n                    data = self.mappable.get_array()\n                    if data is not None and len(data) > 0:\n                        positive_data = data[data > 0]\n                        if len(positive_data) > 0:\n                            self.norm.vmin = max(positive_data.min(), 1e-10)\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                except (AttributeError, TypeError):\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        # Use LogNorm-aware nonsingular transformation\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, use multiplicative expander to maintain vmin > 0\n            vmin_orig, vmax_orig = self.norm.vmin, self.norm.vmax\n            if vmin_orig > 0 and vmax_orig > vmin_orig:\n                ratio = vmax_orig / vmin_orig\n                expander = max(1.1, ratio * 0.1)\n                self.norm.vmin = vmin_orig / expander\n                self.norm.vmax = vmax_orig * expander\n            else:\n                self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n                    max(self.norm.vmin, 1e-10), self.norm.vmax, expander=0.1)\n                # Ensure vmin is still positive after nonsingular\n                if self.norm.vmin <= 0:\n                    self.norm.vmin = 1e-10\n        else:\n            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n                self.norm.vmin, self.norm.vmax, expander=0.1)\n        \n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Handle LogNorm special case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # Set vmin to a small positive value for LogNorm\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                try:\n                    data = self.mappable.get_array()\n                    if data is not None and len(data) > 0:\n                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                        self.norm.vmin = max(data_min, 1e-10)\n                    else:\n                        self.norm.vmin = 1e-10\n                except (AttributeError, ValueError):\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        # Use multiplicative expander for LogNorm to maintain vmin > 0\n        if isinstance(self.norm, colors.LogNorm):\n            if self.norm.vmin <= 0:\n                self.norm.vmin = 1e-10\n            vmin_orig, vmax_orig = self.norm.vmin, self.norm.vmax\n            self.norm.vmin = vmin_orig / 1.1 if vmin_orig > 0 else 1e-10\n            self.norm.vmax = vmax_orig * 1.1\n        else:\n            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n                self.norm.vmin, self.norm.vmax, expander=0.1)\n        \n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Handle LogNorm case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # For LogNorm, vmin must be positive\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                data = self.mappable.get_array()\n                if data is not None and len(data) > 0:\n                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                    self.norm.vmin = max(data_min, 1e-10)\n                else:\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        \n        # For LogNorm, ensure vmin remains positive after nonsingular transform\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            self.norm.vmin = 1e-10\n            \n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Handle LogNorm case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # For LogNorm, vmin must be positive\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                # Try to get a reasonable vmin from the mappable's data\n                try:\n                    data = self.mappable.get_array()\n                    if data is not None and len(data) > 0:\n                        data_min = np.min(data[data > 0])  # Only positive values\n                        if data_min > 0:\n                            self.norm.vmin = data_min\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                except (AttributeError, ValueError):\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Handle LogNorm special case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # For LogNorm, vmin must be positive\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                # Try to get a reasonable vmin from the mappable's data\n                try:\n                    data = self.mappable.get_array()\n                    if data is not None and len(data) > 0:\n                        positive_data = data[data > 0]\n                        if len(positive_data) > 0:\n                            self.norm.vmin = max(positive_data.min(), 1e-10)\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                except (AttributeError, ValueError):\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Ensure LogNorm compatibility by preventing vmin <= 0\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # For LogNorm, vmin must be positive to avoid division by zero\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                # Try to get a reasonable vmin from the mappable's data\n                try:\n                    data = self.mappable.get_array()\n                    if data is not None and len(data) > 0:\n                        positive_data = data[data > 0]\n                        if len(positive_data) > 0:\n                            self.norm.vmin = max(positive_data.min(), 1e-10)\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                except (AttributeError, ValueError):\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Handle LogNorm case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # For LogNorm, vmin must be positive\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                # Try to get a reasonable positive vmin from the mappable's data\n                try:\n                    data = self.mappable.get_array()\n                    if data is not None and len(data) > 0:\n                        positive_data = data[data > 0]\n                        if len(positive_data) > 0:\n                            self.norm.vmin = max(positive_data.min(), 1e-10)\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                except (AttributeError, ValueError):\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Handle LogNorm case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # For LogNorm, vmin must be positive\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                # Try to get a reasonable vmin from the mappable's data\n                try:\n                    data = self.mappable.get_array()\n                    if data is not None and len(data) > 0:\n                        positive_data = data[data > 0]\n                        if len(positive_data) > 0:\n                            self.norm.vmin = positive_data.min()\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                except (AttributeError, ValueError):\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            b = self.norm.inverse(b)\n"
    ],
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/colorbar.py lines 510-512)": [
      "\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            # Handle LogNorm transition - ensure valid vmin/vmax\n            if isinstance(mappable.norm, colors.LogNorm):\n                # Get data range from mappable\n                if hasattr(mappable, 'get_array'):\n                    data = mappable.get_array()\n                    if data is not None and data.size > 0:\n                        data_min = np.nanmin(data[data > 0]) if np.any(data > 0) else 1e-10\n                        data_max = np.nanmax(data)\n                        # Ensure LogNorm has valid vmin > 0\n                        if mappable.norm.vmin is None or mappable.norm.vmin <= 0:\n                            mappable.norm.vmin = data_min\n                        if mappable.norm.vmax is None:\n                            mappable.norm.vmax = data_max\n            self.norm = mappable.norm\n            self._reset_locator_formatter_scale()\n",
      "\n        if mappable.norm != self.norm:\n            old_norm_type = type(self.norm)\n            new_norm_type = type(mappable.norm)\n            \n            # Check if switching to LogNorm and ensure valid vmin/vmax\n            if new_norm_type == colors.LogNorm:\n                # Get the data range from mappable to ensure valid log bounds\n                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                    data = mappable.get_array()\n                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                    data_max = np.max(data) if data.size > 0 else 1.0\n                    \n                    # Ensure vmin is positive for LogNorm\n                    vmin = max(mappable.norm.vmin or data_min, 1e-10)\n                    vmax = mappable.norm.vmax or data_max\n                    \n                    # Create a new LogNorm with valid bounds\n                    self.norm = colors.LogNorm(vmin=vmin, vmax=vmax)\n                else:\n                    self.norm = mappable.norm\n            else:\n                self.norm = mappable.norm\n            \n            self._reset_locator_formatter_scale()\n",
      "\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            # Handle LogNorm case - ensure vmin > 0 to prevent division by zero\n            if isinstance(mappable.norm, colors.LogNorm):\n                # Get the data range from mappable if available\n                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                    data = mappable.get_array()\n                    if np.ma.is_masked(data):\n                        data = data.compressed()\n                    if len(data) > 0:\n                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                        # Ensure norm has valid vmin/vmax for LogNorm\n                        if mappable.norm.vmin is None or mappable.norm.vmin <= 0:\n                            mappable.norm.vmin = data_min\n                        if mappable.norm.vmax is None:\n                            mappable.norm.vmax = np.max(data)\n            self.norm = mappable.norm\n            self._reset_locator_formatter_scale()\n",
      "\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # Ensure LogNorm compatibility by validating vmin/vmax\n            if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n                if isinstance(self.norm, colors.LogNorm):\n                    # For LogNorm, ensure vmin > 0 to prevent division by zero\n                    if self.norm.vmin is None or self.norm.vmin <= 0:\n                        # Get data range from mappable to set appropriate vmin\n                        try:\n                            data = mappable.get_array()\n                            if data is not None and data.size > 0:\n                                data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                                self.norm.vmin = max(data_min, 1e-10)\n                            else:\n                                self.norm.vmin = 1e-10\n                        except (AttributeError, ValueError):\n                            self.norm.vmin = 1e-10\n            self._reset_locator_formatter_scale()\n",
      "\n        if mappable.norm != self.norm:\n            # Store old norm type for comparison\n            old_norm_type = type(self.norm)\n            new_norm_type = type(mappable.norm)\n            \n            # If switching to LogNorm, ensure vmin/vmax are valid\n            if new_norm_type == colors.LogNorm and old_norm_type != colors.LogNorm:\n                # Get the mappable's data range to set proper vmin/vmax\n                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                    data = mappable.get_array()\n                    if data.size > 0:\n                        data_min = np.ma.masked_invalid(data, copy=False).min()\n                        data_max = np.ma.masked_invalid(data, copy=False).max()\n                        # Ensure vmin > 0 for LogNorm\n                        if data_min <= 0:\n                            data_min = max(1e-10, data_max * 1e-10) if data_max > 0 else 1e-10\n                        # Update the mappable's norm with proper vmin/vmax\n                        mappable.norm.vmin = data_min\n                        mappable.norm.vmax = data_max\n            \n            self.norm = mappable.norm\n            self._reset_locator_formatter_scale()\n",
      "\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # Ensure LogNorm compatibility by validating vmin/vmax\n            if isinstance(self.norm, colors.LogNorm):\n                # Get the actual data range from the mappable\n                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                    data = mappable.get_array()\n                    data_min = np.ma.masked_invalid(data, copy=False).min()\n                    if data_min <= 0:\n                        data_min = 1e-10\n                    # Ensure norm vmin is positive for LogNorm\n                    if self.norm.vmin is None or self.norm.vmin <= 0:\n                        self.norm.vmin = data_min\n                    if self.norm.vmax is None:\n                        data_max = np.ma.masked_invalid(data, copy=False).max()\n                        self.norm.vmax = data_max\n            self._reset_locator_formatter_scale()\n",
      "\n        if mappable.norm != self.norm:\n            # Store old norm for comparison\n            old_norm_type = type(self.norm)\n            new_norm_type = type(mappable.norm)\n            \n            self.norm = mappable.norm\n            \n            # If switching to LogNorm, ensure valid vmin/vmax\n            if (isinstance(self.norm, colors.LogNorm) and \n                old_norm_type != colors.LogNorm):\n                # Get data range from mappable\n                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                    data = mappable.get_array()\n                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                    if self.norm.vmin is None or self.norm.vmin <= 0:\n                        self.norm.vmin = max(data_min, 1e-10)\n                    if self.norm.vmax is None:\n                        self.norm.vmax = np.max(data)\n            \n            self._reset_locator_formatter_scale()\n",
      "\n        if mappable.norm != self.norm:\n            # Store old norm type for comparison\n            old_norm_type = type(self.norm)\n            new_norm_type = type(mappable.norm)\n            \n            self.norm = mappable.norm\n            \n            # If switching to LogNorm, ensure valid vmin/vmax\n            if (new_norm_type != old_norm_type and \n                isinstance(self.norm, colors.LogNorm)):\n                # Get valid range from mappable data\n                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                    data = mappable.get_array()\n                    if data.size > 0:\n                        data_min = np.ma.masked_invalid(data, copy=False).min()\n                        data_max = np.ma.masked_invalid(data, copy=False).max()\n                        if data_min > 0:\n                            # Ensure norm has valid vmin/vmax for LogNorm\n                            if self.norm.vmin <= 0:\n                                self.norm.vmin = max(data_min, 1e-10)\n                            if self.norm.vmax <= self.norm.vmin:\n                                self.norm.vmax = max(data_max, self.norm.vmin * 10)\n            \n            self._reset_locator_formatter_scale()\n"
    ],
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/colorbar.py lines 1107-1108)": [
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Handle LogNorm case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # For LogNorm, vmin must be positive\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                data = self.mappable.get_array()\n                if data is not None and len(data) > 0:\n                    positive_data = data[data > 0]\n                    if len(positive_data) > 0:\n                        self.norm.vmin = max(positive_data.min(), 1e-10)\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        # Use appropriate nonsingular transformation based on norm type\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, use multiplicative expander to keep vmin > 0\n            vmin_new = self.norm.vmin / 1.1\n            vmax_new = self.norm.vmax * 1.1\n            self.norm.vmin, self.norm.vmax = vmin_new, vmax_new\n        else:\n            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n                self.norm.vmin, self.norm.vmax, expander=0.1)\n",
      "\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        \n        # Ensure LogNorm compatibility: vmin must be positive\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # Set vmin to a small positive value based on data range\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                data = self.mappable.get_array()\n                if data is not None and len(data) > 0:\n                    positive_data = data[data > 0]\n                    if len(positive_data) > 0:\n                        self.norm.vmin = max(positive_data.min(), 1e-10)\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n",
      "\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        \n        # Ensure LogNorm compatibility by preventing vmin <= 0\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # Set vmin to a small positive value for LogNorm\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                data = self.mappable.get_array()\n                if data is not None:\n                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                    self.norm.vmin = max(data_min, 1e-10)\n                else:\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n",
      "\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        \n        # Ensure LogNorm compatibility by maintaining vmin > 0\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # Set vmin to a small positive value to prevent division by zero\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                data = self.mappable.get_array()\n                if data is not None and len(data) > 0:\n                    positive_data = data[data > 0]\n                    if len(positive_data) > 0:\n                        self.norm.vmin = max(positive_data.min(), 1e-10)\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n",
      "\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        \n        # Ensure LogNorm compatibility by maintaining vmin > 0\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # Set vmin to a small positive value to prevent division by zero\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                # Try to use mappable's data range\n                try:\n                    data = self.mappable.get_array()\n                    if data is not None:\n                        positive_data = data[data > 0]\n                        if len(positive_data) > 0:\n                            self.norm.vmin = max(positive_data.min(), 1e-10)\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                except (AttributeError, ValueError):\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Handle LogNorm case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                # Try to get valid range from mappable data\n                array = self.mappable.get_array()\n                if array is not None and array.size > 0:\n                    valid_data = array[np.isfinite(array) & (array > 0)]\n                    if valid_data.size > 0:\n                        self.norm.vmin = max(valid_data.min(), 1e-10)\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        # Use LogNorm-aware nonsingular transformation\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, use multiplicative expander to maintain vmin > 0\n            if self.norm.vmin <= 0:\n                self.norm.vmin = 1e-10\n            if self.norm.vmax <= self.norm.vmin:\n                self.norm.vmax = self.norm.vmin * 10\n            # Apply multiplicative expansion for log scale\n            log_range = np.log10(self.norm.vmax) - np.log10(self.norm.vmin)\n            if log_range < 1e-10:  # Very small range\n                expansion = 0.1\n                log_vmin = np.log10(self.norm.vmin) - expansion\n                log_vmax = np.log10(self.norm.vmax) + expansion\n                self.norm.vmin = 10**log_vmin\n                self.norm.vmax = 10**log_vmax\n        else:\n            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n                self.norm.vmin, self.norm.vmax, expander=0.1)\n",
      "\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        \n        # Ensure LogNorm compatibility: vmin must be positive\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # Set vmin to a small positive value to prevent division by zero\n            if hasattr(self, 'mappable') and hasattr(self.mappable, 'get_array'):\n                data = self.mappable.get_array()\n                if data is not None and len(data) > 0:\n                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                    self.norm.vmin = max(data_min, 1e-10)\n                else:\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        \n        # Handle LogNorm case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            # For LogNorm, vmin must be positive\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                data = self.mappable.get_array()\n                if data is not None:\n                    data_min = np.ma.masked_invalid(data).min()\n                    if data_min > 0:\n                        self.norm.vmin = data_min\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        # Apply nonsingular transform with LogNorm awareness\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, use multiplicative expander to maintain vmin > 0\n            vmin_new = self.norm.vmin / 1.1\n            vmax_new = self.norm.vmax * 1.1\n            self.norm.vmin, self.norm.vmax = vmin_new, vmax_new\n        else:\n            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n                self.norm.vmin, self.norm.vmax, expander=0.1)\n"
    ],
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/colorbar.py lines 1170-1173)": [
      "\ndef _reset_locator_formatter_scale(self):\n    \"\"\"\n    Reset the locator et al to defaults.  Any user-hardcoded changes\n    need to be re-entered if this gets called (either at init, or when\n    the mappable normal gets changed: Colorbar.update_normal)\n    \"\"\"\n    # Ensure vmin/vmax are compatible with the current norm before processing\n    if isinstance(self.norm, colors.LogNorm):\n        if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n            # For LogNorm, vmin must be positive\n            if hasattr(self.mappable, 'get_array'):\n                array = self.mappable.get_array()\n                if array is not None and len(array) > 0:\n                    positive_data = array[array > 0]\n                    if len(positive_data) > 0:\n                        self.vmin = positive_data.min()\n                    else:\n                        self.vmin = 1e-10\n                else:\n                    self.vmin = 1e-10\n            else:\n                self.vmin = 1e-10\n    \n    self._process_values()\n    self._locator = None\n    self._minorlocator = None\n    self._formatter = None\n    self._minorformatter = None\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure vmin/vmax are compatible with the current norm before processing\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin > 0 to prevent division by zero\n            if hasattr(self.mappable, 'get_array'):\n                array = self.mappable.get_array()\n                if array is not None and array.size > 0:\n                    data_min = np.min(array[array > 0]) if np.any(array > 0) else 1e-10\n                    if self.norm.vmin is None or self.norm.vmin <= 0:\n                        self.norm.vmin = max(data_min, 1e-10)\n                    if self.norm.vmax is None:\n                        self.norm.vmax = np.max(array)\n        \n        self._process_values()\n        self._locator = None\n        self._minorlocator = None\n        self._formatter = None\n        self._minorformatter = None\n        if (isinstance(self.mappable, contour.ContourSet) and\n                isinstance(self.norm, colors.LogNorm)):\n            # if contours have lognorm, give them a log scale...\n            self._set_scale('log')\n        elif (self.boundaries is not None or\n                isinstance(self.norm, colors.BoundaryNorm)):\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Process values first, but handle LogNorm edge cases\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure we have valid data range before processing\n            if hasattr(self.mappable, 'get_array'):\n                array = self.mappable.get_array()\n                if array is not None and array.size > 0:\n                    # Get valid positive data for LogNorm\n                    positive_data = array[array > 0]\n                    if positive_data.size > 0:\n                        data_min = positive_data.min()\n                        data_max = positive_data.max()\n                        # Ensure norm has valid vmin/vmax for LogNorm\n                        if self.norm.vmin is None or self.norm.vmin <= 0:\n                            self.norm.vmin = data_min\n                        if self.norm.vmax is None or self.norm.vmax <= 0:\n                            self.norm.vmax = data_max\n        \n        self._process_values()\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        self._process_values()\n        # Handle LogNorm case to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm):\n            if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n                # Set vmin to a small positive value for LogNorm\n                if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n                    data = self.mappable.get_array()\n                    data_min = np.ma.masked_invalid(data, copy=False).min()\n                    self.vmin = max(data_min, 1e-10) if data_min > 0 else 1e-10\n                else:\n                    self.vmin = 1e-10\n            if hasattr(self, 'vmax') and self.vmax is not None and self.vmax <= 0:\n                self.vmax = 1.0\n        self._locator = None\n        self._minorlocator = None\n        self._formatter = None\n        self._minorformatter = None\n",
      "\ndef _reset_locator_formatter_scale(self):\n    \"\"\"\n    Reset the locator et al to defaults.  Any user-hardcoded changes\n    need to be re-entered if this gets called (either at init, or when\n    the mappable normal gets changed: Colorbar.update_normal)\n    \"\"\"\n    # Process values first, ensuring LogNorm compatibility\n    self._process_values()\n    \n    # Additional LogNorm validation after processing values\n    if isinstance(self.norm, colors.LogNorm):\n        if hasattr(self, 'vmin') and self.vmin <= 0:\n            # For LogNorm, ensure vmin is positive\n            if hasattr(self.mappable, 'get_array'):\n                array = self.mappable.get_array()\n                if array is not None and len(array) > 0:\n                    positive_min = array[array > 0].min() if np.any(array > 0) else 1e-10\n                    self.vmin = max(positive_min, 1e-10)\n                else:\n                    self.vmin = 1e-10\n            else:\n                self.vmin = 1e-10\n                \n    self._locator = None\n    self._minorlocator = None\n    self._formatter = None\n    self._minorformatter = None\n",
      "\ndef _reset_locator_formatter_scale(self):\n    \"\"\"\n    Reset the locator et al to defaults.  Any user-hardcoded changes\n    need to be re-entered if this gets called (either at init, or when\n    the mappable normal gets changed: Colorbar.update_normal)\n    \"\"\"\n    # Ensure vmin/vmax are compatible with the current norm before processing\n    if isinstance(self.norm, colors.LogNorm):\n        if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n            # For LogNorm, vmin must be positive\n            if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n                data = self.mappable.get_array()\n                data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                self.vmin = max(data_min, 1e-10)\n            else:\n                self.vmin = 1e-10\n    \n    self._process_values()\n    self._locator = None\n    self._minorlocator = None\n    self._formatter = None\n    self._minorformatter = None\n    if (isinstance(self.mappable, contour.ContourSet) and\n            isinstance(self.norm, colors.LogNorm)):\n        # if contours have lognorm, give them a log scale...\n        self._set_scale('log')\n    elif (self.boundaries is not None or\n            isinstance(self.norm, colors.BoundaryNorm)):\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure LogNorm compatibility before processing values\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin > 0 to prevent division by zero\n            if hasattr(self.norm, 'vmin') and self.norm.vmin is not None:\n                if self.norm.vmin <= 0:\n                    # Get data from mappable to determine appropriate vmin\n                    if hasattr(self.mappable, 'get_array'):\n                        data = self.mappable.get_array()\n                        if data is not None and len(data) > 0:\n                            data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                            self.norm.vmin = max(data_min, 1e-10)\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n        \n        self._process_values()\n        self._locator = None\n        self._minorlocator = None\n        self._formatter = None\n        self._minorformatter = None\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Process values first, but handle LogNorm edge cases\n        if isinstance(self.norm, colors.LogNorm):\n            # Ensure vmin > 0 for LogNorm to prevent division by zero\n            if hasattr(self.norm, 'vmin') and self.norm.vmin is not None:\n                if self.norm.vmin <= 0:\n                    # Get data from mappable to determine appropriate vmin\n                    if hasattr(self.mappable, 'get_array'):\n                        data = self.mappable.get_array()\n                        if data is not None and len(data) > 0:\n                            data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                            self.norm.vmin = max(data_min, 1e-10)\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n        \n        self._process_values()\n        self._locator = None\n        self._minorlocator = None\n        self._formatter = None\n        self._minorformatter = None\n        if (isinstance(self.mappable, contour.ContourSet) and\n                isinstance(self.norm, colors.LogNorm)):\n            # if contours have lognorm, give them a log scale...\n            self._set_scale('log')\n        elif (self.boundaries is not None or\n                isinstance(self.norm, colors.BoundaryNorm)):\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..5e95121581 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -507,7 +507,21 @@ class Colorbar:\n         self.mappable = mappable\n         self.set_alpha(mappable.get_alpha())\n         self.cmap = mappable.cmap\n+\n         if mappable.norm != self.norm:\n+            # Ensure LogNorm compatibility when changing norm types\n+            if isinstance(mappable.norm, colors.LogNorm):\n+                # Sync vmin/vmax from mappable data for LogNorm\n+                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                    data = mappable.get_array()\n+                    data_min = np.ma.masked_invalid(data, copy=False).min()\n+                    data_max = np.ma.masked_invalid(data, copy=False).max()\n+                    if data_min > 0:\n+                        mappable.norm.vmin = data_min\n+                        mappable.norm.vmax = data_max\n+                    else:\n+                        mappable.norm.vmin = 1e-10\n+                        mappable.norm.vmax = max(data_max, 1.0)\n             self.norm = mappable.norm\n             self._reset_locator_formatter_scale()\n \n@@ -1102,10 +1116,41 @@ class Colorbar:\n \n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n-            self.norm.vmin = 0\n-            self.norm.vmax = 1\n-        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n-            self.norm.vmin, self.norm.vmax, expander=0.1)\n+\n+            # For LogNorm, ensure vmin > 0 to prevent division by zero\n+            if isinstance(self.norm, colors.LogNorm):\n+                if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n+                    data = self.mappable.get_array()\n+                    data_min = np.ma.masked_invalid(data, copy=False).min()\n+                    self.norm.vmin = max(data_min, 1e-10) if data_min > 0 else 1e-10\n+                    self.norm.vmax = np.ma.masked_invalid(data, copy=False).max()\n+                else:\n+                    self.norm.vmin = 1e-10\n+                    self.norm.vmax = 1\n+            else:\n+                self.norm.vmin = 0\n+                self.norm.vmax = 1\n+        # For LogNorm, use multiplicative expander to maintain vmin > 0\n+        if isinstance(self.norm, colors.LogNorm):\n+            if self.norm.vmin <= 0:\n+                self.norm.vmin = 1e-10\n+            # Use multiplicative expansion for LogNorm\n+            vmin_new = self.norm.vmin / 1.1\n+            vmax_new = self.norm.vmax * 1.1\n+            self.norm.vmin, self.norm.vmax = vmin_new, vmax_new\n+        else:\n+            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n+                self.norm.vmin, self.norm.vmax, expander=0.1)\n+        if (not isinstance(self.norm, colors.BoundaryNorm) and\n+                (self.boundaries is None)):\n+            b = self.norm.inverse(b)\n+            # Use multiplicative expansion for LogNorm\n+            vmin_new = self.norm.vmin / 1.1\n+            vmax_new = self.norm.vmax * 1.1\n+            self.norm.vmin, self.norm.vmax = vmin_new, vmax_new\n+        else:\n+            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n+                self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\n@@ -1167,10 +1212,42 @@ class Colorbar:\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n+\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n         self._process_values()\n+        \n+    def update_bruteforce(self, mappable):\n+        \"\"\"\n+        Destroy and rebuild the colorbar.  This is intended to become\n+        obsolete, and will probably be deprecated and then removed.\n+        It is not called anywhere in the matplotlib library.\n+        \"\"\"\n+        # Ensure LogNorm compatibility\n+        if isinstance(mappable.norm, colors.LogNorm):\n+            if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                data = mappable.get_array()\n+                data_min = np.ma.masked_invalid(data, copy=False).min()\n+                data_max = np.ma.masked_invalid(data, copy=False).max()\n+                if data_min > 0:\n+                    mappable.norm.vmin = data_min\n+                    mappable.norm.vmax = data_max\n+                else:\n+                    mappable.norm.vmin = 1e-10\n+                    mappable.norm.vmax = max(data_max, 1.0)\n+        \n+        self.mappable = mappable\n+        self.set_alpha(mappable.get_alpha())\n+        self.cmap = mappable.cmap\n+        self.norm = mappable.norm\n+        self._reset_locator_formatter_scale()\n+        self._draw_all()\n+        if isinstance(self.mappable, contour.ContourSet):\n+            CS = self.mappable\n+            if not CS.filled:\n+                self.add_lines(CS)\n+        self.stale = True\n         self._locator = None\n         self._minorlocator = None\n         self._formatter = None\n",
    "variant_0": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..f68c7a99b0 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -507,8 +507,28 @@ class Colorbar:\n         self.mappable = mappable\n         self.set_alpha(mappable.get_alpha())\n         self.cmap = mappable.cmap\n+\n         if mappable.norm != self.norm:\n+            old_norm_type = type(self.norm)\n+            new_norm_type = type(mappable.norm)\n             self.norm = mappable.norm\n+            \n+            # Handle LogNorm-specific requirements when norm type changes\n+            if new_norm_type == colors.LogNorm and old_norm_type != colors.LogNorm:\n+                # Ensure vmin > 0 for LogNorm to prevent division by zero\n+                if hasattr(self.norm, 'vmin') and self.norm.vmin is not None:\n+                    if self.norm.vmin <= 0:\n+                        # Get valid data range from mappable\n+                        if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                            data = mappable.get_array()\n+                            valid_data = data[np.isfinite(data) & (data > 0)]\n+                            if len(valid_data) > 0:\n+                                self.norm.vmin = max(valid_data.min(), 1e-10)\n+                            else:\n+                                self.norm.vmin = 1e-10\n+                        else:\n+                            self.norm.vmin = 1e-10\n+            \n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1100,10 +1120,42 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+        if not self.norm.scaled():\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n+        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n+            self.norm.vmin, self.norm.vmax, expander=0.1)\n+        \n+        # Handle LogNorm special case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # Set vmin to a small positive value for LogNorm\n+            if hasattr(self, 'mappable') and hasattr(self.mappable, 'get_array'):\n+                array = self.mappable.get_array()\n+                if array is not None and len(array) > 0:\n+                    data_min = np.min(array[array > 0]) if np.any(array > 0) else 1e-10\n+                    self.norm.vmin = max(data_min, 1e-10)\n+                else:\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n+        if (not isinstance(self.norm, colors.BoundaryNorm) and\n+                (self.boundaries is None)):\n+            b = self.norm.inverse(b)\n+        \n+        # Special handling for LogNorm to ensure vmin > 0\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # Use a small positive value or the minimum positive value from boundaries\n+            positive_b = b[b > 0]\n+            if len(positive_b) > 0:\n+                self.norm.vmin = positive_b.min() * 0.1\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n@@ -1167,10 +1219,41 @@ class Colorbar:\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n-        need to be re-entered if this gets called (either at init, or when\n-        the mappable normal gets changed: Colorbar.update_normal)\n-        \"\"\"\n-        self._process_values()\n+\n+def _reset_locator_formatter_scale(self):\n+    \"\"\"\n+    Reset the locator et al to defaults.  Any user-hardcoded changes\n+    need to be re-entered if this gets called (either at init, or when\n+    the mappable normal gets changed: Colorbar.update_normal)\n+    \"\"\"\n+    # Ensure valid vmin/vmax for LogNorm before processing values\n+    if isinstance(self.norm, colors.LogNorm):\n+        if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n+            # Get data range from mappable to set a reasonable vmin\n+            if hasattr(self.mappable, 'get_array'):\n+                data = self.mappable.get_array()\n+                if data is not None:\n+                    data_min = np.ma.masked_invalid(data).min()\n+                    if np.ma.is_masked(data_min):\n+                        self.vmin = 1e-10\n+                    else:\n+                        self.vmin = max(float(data_min), 1e-10)\n+                else:\n+                    self.vmin = 1e-10\n+            else:\n+                self.vmin = 1e-10\n+    \n+    self._process_values()\n+    self._locator = None\n+    self._minorlocator = None\n+    self._formatter = None\n+    self._minorformatter = None\n+    if (isinstance(self.mappable, contour.ContourSet) and\n+            isinstance(self.norm, colors.LogNorm)):\n+        # if contours have lognorm, give them a log scale...\n+        self._set_scale('log')\n+    elif (self.boundaries is not None or\n+            isinstance(self.norm, colors.BoundaryNorm)):\n         self._locator = None\n         self._minorlocator = None\n         self._formatter = None\n",
    "variant_1": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..21b8f06136 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -503,11 +503,29 @@ class Colorbar:\n         changes values of *vmin*, *vmax* or *cmap* then the old formatter\n         and locator will be preserved.\n         \"\"\"\n+        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n+        self.mappable = mappable\n+        self.set_alpha(mappable.get_alpha())\n+        self.cmap = mappable.cmap\n+\n         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n         self.mappable = mappable\n         self.set_alpha(mappable.get_alpha())\n         self.cmap = mappable.cmap\n         if mappable.norm != self.norm:\n+            # Handle LogNorm transition - ensure valid vmin/vmax\n+            if isinstance(mappable.norm, colors.LogNorm):\n+                # Get data range from mappable\n+                if hasattr(mappable, 'get_array'):\n+                    data = mappable.get_array()\n+                    if data is not None and data.size > 0:\n+                        data_min = np.nanmin(data[data > 0]) if np.any(data > 0) else 1e-10\n+                        data_max = np.nanmax(data)\n+                        # Ensure LogNorm has valid vmin > 0\n+                        if mappable.norm.vmin is None or mappable.norm.vmin <= 0:\n+                            mappable.norm.vmin = data_min\n+                        if mappable.norm.vmax is None:\n+                            mappable.norm.vmax = data_max\n             self.norm = mappable.norm\n             self._reset_locator_formatter_scale()\n \n@@ -1100,12 +1118,82 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+        if not self.norm.scaled():\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n-        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n-            self.norm.vmin, self.norm.vmax, expander=0.1)\n+        \n+        # Handle LogNorm specifically to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # For LogNorm, vmin must be positive\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                # Try to get a reasonable positive vmin from the mappable's data\n+                try:\n+                    data = self.mappable.get_array()\n+                    if data is not None and len(data) > 0:\n+                        positive_data = data[data > 0]\n+                        if len(positive_data) > 0:\n+                            self.norm.vmin = max(positive_data.min(), 1e-10)\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                except (AttributeError, TypeError):\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n+        # Use LogNorm-aware nonsingular transformation\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, use multiplicative expander to maintain vmin > 0\n+            vmin_orig, vmax_orig = self.norm.vmin, self.norm.vmax\n+            if vmin_orig > 0 and vmax_orig > vmin_orig:\n+                ratio = vmax_orig / vmin_orig\n+                expander = max(1.1, ratio * 0.1)\n+                self.norm.vmin = vmin_orig / expander\n+                self.norm.vmax = vmax_orig * expander\n+            else:\n+                self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n+                    max(self.norm.vmin, 1e-10), self.norm.vmax, expander=0.1)\n+                # Ensure vmin is still positive after nonsingular\n+                if self.norm.vmin <= 0:\n+                    self.norm.vmin = 1e-10\n+        else:\n+            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n+                self.norm.vmin, self.norm.vmax, expander=0.1)\n+        \n+        if (not isinstance(self.norm, colors.BoundaryNorm) and\n+                (self.boundaries is None)):\n+            b = self.norm.inverse(b)\n+        \n+        # Handle LogNorm case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # For LogNorm, vmin must be positive\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                data = self.mappable.get_array()\n+                if data is not None and len(data) > 0:\n+                    positive_data = data[data > 0]\n+                    if len(positive_data) > 0:\n+                        self.norm.vmin = max(positive_data.min(), 1e-10)\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n+        # Use appropriate nonsingular transformation based on norm type\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, use multiplicative expander to keep vmin > 0\n+            vmin_new = self.norm.vmin / 1.1\n+            vmax_new = self.norm.vmax * 1.1\n+            self.norm.vmin, self.norm.vmax = vmin_new, vmax_new\n+        else:\n+            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n+                self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\n@@ -1167,10 +1255,35 @@ class Colorbar:\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n-        need to be re-entered if this gets called (either at init, or when\n-        the mappable normal gets changed: Colorbar.update_normal)\n-        \"\"\"\n-        self._process_values()\n+\n+def _reset_locator_formatter_scale(self):\n+    \"\"\"\n+    Reset the locator et al to defaults.  Any user-hardcoded changes\n+    need to be re-entered if this gets called (either at init, or when\n+    the mappable normal gets changed: Colorbar.update_normal)\n+    \"\"\"\n+    # Ensure vmin/vmax are compatible with the current norm before processing\n+    if isinstance(self.norm, colors.LogNorm):\n+        if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n+            # For LogNorm, vmin must be positive\n+            if hasattr(self.mappable, 'get_array'):\n+                array = self.mappable.get_array()\n+                if array is not None and len(array) > 0:\n+                    positive_data = array[array > 0]\n+                    if len(positive_data) > 0:\n+                        self.vmin = positive_data.min()\n+                    else:\n+                        self.vmin = 1e-10\n+                else:\n+                    self.vmin = 1e-10\n+            else:\n+                self.vmin = 1e-10\n+    \n+    self._process_values()\n+    self._locator = None\n+    self._minorlocator = None\n+    self._formatter = None\n+    self._minorformatter = None\n         self._locator = None\n         self._minorlocator = None\n         self._formatter = None\n",
    "variant_2": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..8eb1ede6e5 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -507,8 +507,30 @@ class Colorbar:\n         self.mappable = mappable\n         self.set_alpha(mappable.get_alpha())\n         self.cmap = mappable.cmap\n+\n         if mappable.norm != self.norm:\n-            self.norm = mappable.norm\n+            old_norm_type = type(self.norm)\n+            new_norm_type = type(mappable.norm)\n+            \n+            # Check if switching to LogNorm and ensure valid vmin/vmax\n+            if new_norm_type == colors.LogNorm:\n+                # Get the data range from mappable to ensure valid log bounds\n+                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                    data = mappable.get_array()\n+                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                    data_max = np.max(data) if data.size > 0 else 1.0\n+                    \n+                    # Ensure vmin is positive for LogNorm\n+                    vmin = max(mappable.norm.vmin or data_min, 1e-10)\n+                    vmax = mappable.norm.vmax or data_max\n+                    \n+                    # Create a new LogNorm with valid bounds\n+                    self.norm = colors.LogNorm(vmin=vmin, vmax=vmax)\n+                else:\n+                    self.norm = mappable.norm\n+            else:\n+                self.norm = mappable.norm\n+            \n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1100,12 +1122,58 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+        if not self.norm.scaled():\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n-        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n-            self.norm.vmin, self.norm.vmax, expander=0.1)\n+        \n+        # Handle LogNorm special case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # Set vmin to a small positive value for LogNorm\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                try:\n+                    data = self.mappable.get_array()\n+                    if data is not None and len(data) > 0:\n+                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                        self.norm.vmin = max(data_min, 1e-10)\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                except (AttributeError, ValueError):\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n+        # Use multiplicative expander for LogNorm to maintain vmin > 0\n+        if isinstance(self.norm, colors.LogNorm):\n+            if self.norm.vmin <= 0:\n+                self.norm.vmin = 1e-10\n+            vmin_orig, vmax_orig = self.norm.vmin, self.norm.vmax\n+            self.norm.vmin = vmin_orig / 1.1 if vmin_orig > 0 else 1e-10\n+            self.norm.vmax = vmax_orig * 1.1\n+        else:\n+            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n+                self.norm.vmin, self.norm.vmax, expander=0.1)\n+        \n+        if (not isinstance(self.norm, colors.BoundaryNorm) and\n+                (self.boundaries is None)):\n+            b = self.norm.inverse(b)\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # Set vmin to a small positive value based on data range\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                data = self.mappable.get_array()\n+                if data is not None and len(data) > 0:\n+                    positive_data = data[data > 0]\n+                    if len(positive_data) > 0:\n+                        self.norm.vmin = max(positive_data.min(), 1e-10)\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\n@@ -1164,17 +1232,43 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+    def _reset_locator_formatter_scale(self):\n+        \"\"\"\n+        Reset the locator et al to defaults.  Any user-hardcoded changes\n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure vmin/vmax are compatible with the current norm before processing\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin > 0 to prevent division by zero\n+            if hasattr(self.mappable, 'get_array'):\n+                array = self.mappable.get_array()\n+                if array is not None and array.size > 0:\n+                    data_min = np.min(array[array > 0]) if np.any(array > 0) else 1e-10\n+                    if self.norm.vmin is None or self.norm.vmin <= 0:\n+                        self.norm.vmin = max(data_min, 1e-10)\n+                    if self.norm.vmax is None:\n+                        self.norm.vmax = np.max(array)\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n         self._formatter = None\n         self._minorformatter = None\n+        if (isinstance(self.mappable, contour.ContourSet) and\n+                isinstance(self.norm, colors.LogNorm)):\n+            # if contours have lognorm, give them a log scale...\n+            self._set_scale('log')\n+        elif (self.boundaries is not None or\n+                isinstance(self.norm, colors.BoundaryNorm)):\n+        self._locator = None\n+        self._minorlocator = None\n+        self._formatter = None\n+        self._minorformatter = None\n         if (isinstance(self.mappable, contour.ContourSet) and\n                 isinstance(self.norm, colors.LogNorm)):\n             # if contours have lognorm, give them a log scale...\n",
    "variant_3": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..57af907ba8 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -503,11 +503,30 @@ class Colorbar:\n         changes values of *vmin*, *vmax* or *cmap* then the old formatter\n         and locator will be preserved.\n         \"\"\"\n+        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n+        self.mappable = mappable\n+        self.set_alpha(mappable.get_alpha())\n+        self.cmap = mappable.cmap\n+\n         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n         self.mappable = mappable\n         self.set_alpha(mappable.get_alpha())\n         self.cmap = mappable.cmap\n         if mappable.norm != self.norm:\n+            # Handle LogNorm case - ensure vmin > 0 to prevent division by zero\n+            if isinstance(mappable.norm, colors.LogNorm):\n+                # Get the data range from mappable if available\n+                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                    data = mappable.get_array()\n+                    if np.ma.is_masked(data):\n+                        data = data.compressed()\n+                    if len(data) > 0:\n+                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                        # Ensure norm has valid vmin/vmax for LogNorm\n+                        if mappable.norm.vmin is None or mappable.norm.vmin <= 0:\n+                            mappable.norm.vmin = data_min\n+                        if mappable.norm.vmax is None:\n+                            mappable.norm.vmax = np.max(data)\n             self.norm = mappable.norm\n             self._reset_locator_formatter_scale()\n \n@@ -1100,12 +1119,48 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+        if not self.norm.scaled():\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n+        \n+        # Handle LogNorm case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # For LogNorm, vmin must be positive\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                data = self.mappable.get_array()\n+                if data is not None and len(data) > 0:\n+                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                    self.norm.vmin = max(data_min, 1e-10)\n+                else:\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n+        \n+        # For LogNorm, ensure vmin remains positive after nonsingular transform\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            self.norm.vmin = 1e-10\n+            \n+        if (not isinstance(self.norm, colors.BoundaryNorm) and\n+                (self.boundaries is None)):\n+            b = self.norm.inverse(b)\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # Set vmin to a small positive value for LogNorm\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                data = self.mappable.get_array()\n+                if data is not None:\n+                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                    self.norm.vmin = max(data_min, 1e-10)\n+                else:\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\n@@ -1164,12 +1219,33 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+    def _reset_locator_formatter_scale(self):\n+        \"\"\"\n+        Reset the locator et al to defaults.  Any user-hardcoded changes\n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Process values first, but handle LogNorm edge cases\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure we have valid data range before processing\n+            if hasattr(self.mappable, 'get_array'):\n+                array = self.mappable.get_array()\n+                if array is not None and array.size > 0:\n+                    # Get valid positive data for LogNorm\n+                    positive_data = array[array > 0]\n+                    if positive_data.size > 0:\n+                        data_min = positive_data.min()\n+                        data_max = positive_data.max()\n+                        # Ensure norm has valid vmin/vmax for LogNorm\n+                        if self.norm.vmin is None or self.norm.vmin <= 0:\n+                            self.norm.vmin = data_min\n+                        if self.norm.vmax is None or self.norm.vmax <= 0:\n+                            self.norm.vmax = data_max\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n",
    "variant_4": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..3d093a544f 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -507,8 +507,24 @@ class Colorbar:\n         self.mappable = mappable\n         self.set_alpha(mappable.get_alpha())\n         self.cmap = mappable.cmap\n+\n         if mappable.norm != self.norm:\n             self.norm = mappable.norm\n+            # Ensure LogNorm compatibility by validating vmin/vmax\n+            if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n+                if isinstance(self.norm, colors.LogNorm):\n+                    # For LogNorm, ensure vmin > 0 to prevent division by zero\n+                    if self.norm.vmin is None or self.norm.vmin <= 0:\n+                        # Get data range from mappable to set appropriate vmin\n+                        try:\n+                            data = mappable.get_array()\n+                            if data is not None and data.size > 0:\n+                                data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                                self.norm.vmin = max(data_min, 1e-10)\n+                            else:\n+                                self.norm.vmin = 1e-10\n+                        except (AttributeError, ValueError):\n+                            self.norm.vmin = 1e-10\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1100,15 +1116,56 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+        if not self.norm.scaled():\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n+        \n+        # Handle LogNorm case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # For LogNorm, vmin must be positive\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                # Try to get a reasonable vmin from the mappable's data\n+                try:\n+                    data = self.mappable.get_array()\n+                    if data is not None and len(data) > 0:\n+                        data_min = np.min(data[data > 0])  # Only positive values\n+                        if data_min > 0:\n+                            self.norm.vmin = data_min\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                except (AttributeError, ValueError):\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # Set vmin to a small positive value to prevent division by zero\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                data = self.mappable.get_array()\n+                if data is not None and len(data) > 0:\n+                    positive_data = data[data > 0]\n+                    if len(positive_data) > 0:\n+                        self.norm.vmin = max(positive_data.min(), 1e-10)\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        if (not isinstance(self.norm, colors.BoundaryNorm) and\n+                (self.boundaries is None)):\n+            b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\n@@ -1164,6 +1221,10 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+    def _reset_locator_formatter_scale(self):\n+        \"\"\"\n+        Reset the locator et al to defaults.  Any user-hardcoded changes\n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n@@ -1171,6 +1232,22 @@ class Colorbar:\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n         self._process_values()\n+        # Handle LogNorm case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm):\n+            if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n+                # Set vmin to a small positive value for LogNorm\n+                if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n+                    data = self.mappable.get_array()\n+                    data_min = np.ma.masked_invalid(data, copy=False).min()\n+                    self.vmin = max(data_min, 1e-10) if data_min > 0 else 1e-10\n+                else:\n+                    self.vmin = 1e-10\n+            if hasattr(self, 'vmax') and self.vmax is not None and self.vmax <= 0:\n+                self.vmax = 1.0\n+        self._locator = None\n+        self._minorlocator = None\n+        self._formatter = None\n+        self._minorformatter = None\n         self._locator = None\n         self._minorlocator = None\n         self._formatter = None\n",
    "variant_5": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..7caf64163a 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -507,7 +507,27 @@ class Colorbar:\n         self.mappable = mappable\n         self.set_alpha(mappable.get_alpha())\n         self.cmap = mappable.cmap\n+\n         if mappable.norm != self.norm:\n+            # Store old norm type for comparison\n+            old_norm_type = type(self.norm)\n+            new_norm_type = type(mappable.norm)\n+            \n+            # If switching to LogNorm, ensure vmin/vmax are valid\n+            if new_norm_type == colors.LogNorm and old_norm_type != colors.LogNorm:\n+                # Get the mappable's data range to set proper vmin/vmax\n+                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                    data = mappable.get_array()\n+                    if data.size > 0:\n+                        data_min = np.ma.masked_invalid(data, copy=False).min()\n+                        data_max = np.ma.masked_invalid(data, copy=False).max()\n+                        # Ensure vmin > 0 for LogNorm\n+                        if data_min <= 0:\n+                            data_min = max(1e-10, data_max * 1e-10) if data_max > 0 else 1e-10\n+                        # Update the mappable's norm with proper vmin/vmax\n+                        mappable.norm.vmin = data_min\n+                        mappable.norm.vmax = data_max\n+            \n             self.norm = mappable.norm\n             self._reset_locator_formatter_scale()\n \n@@ -1100,15 +1120,60 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+        if not self.norm.scaled():\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n+        \n+        # Handle LogNorm special case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # For LogNorm, vmin must be positive\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                # Try to get a reasonable vmin from the mappable's data\n+                try:\n+                    data = self.mappable.get_array()\n+                    if data is not None and len(data) > 0:\n+                        positive_data = data[data > 0]\n+                        if len(positive_data) > 0:\n+                            self.norm.vmin = max(positive_data.min(), 1e-10)\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                except (AttributeError, ValueError):\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # Set vmin to a small positive value to prevent division by zero\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                # Try to use mappable's data range\n+                try:\n+                    data = self.mappable.get_array()\n+                    if data is not None:\n+                        positive_data = data[data > 0]\n+                        if len(positive_data) > 0:\n+                            self.norm.vmin = max(positive_data.min(), 1e-10)\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                except (AttributeError, ValueError):\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        if (not isinstance(self.norm, colors.BoundaryNorm) and\n+                (self.boundaries is None)):\n+            b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\n@@ -1167,10 +1232,34 @@ class Colorbar:\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n-        need to be re-entered if this gets called (either at init, or when\n-        the mappable normal gets changed: Colorbar.update_normal)\n-        \"\"\"\n-        self._process_values()\n+\n+def _reset_locator_formatter_scale(self):\n+    \"\"\"\n+    Reset the locator et al to defaults.  Any user-hardcoded changes\n+    need to be re-entered if this gets called (either at init, or when\n+    the mappable normal gets changed: Colorbar.update_normal)\n+    \"\"\"\n+    # Process values first, ensuring LogNorm compatibility\n+    self._process_values()\n+    \n+    # Additional LogNorm validation after processing values\n+    if isinstance(self.norm, colors.LogNorm):\n+        if hasattr(self, 'vmin') and self.vmin <= 0:\n+            # For LogNorm, ensure vmin is positive\n+            if hasattr(self.mappable, 'get_array'):\n+                array = self.mappable.get_array()\n+                if array is not None and len(array) > 0:\n+                    positive_min = array[array > 0].min() if np.any(array > 0) else 1e-10\n+                    self.vmin = max(positive_min, 1e-10)\n+                else:\n+                    self.vmin = 1e-10\n+            else:\n+                self.vmin = 1e-10\n+                \n+    self._locator = None\n+    self._minorlocator = None\n+    self._formatter = None\n+    self._minorformatter = None\n         self._locator = None\n         self._minorlocator = None\n         self._formatter = None\n",
    "variant_6": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..098279c1d4 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -507,8 +507,23 @@ class Colorbar:\n         self.mappable = mappable\n         self.set_alpha(mappable.get_alpha())\n         self.cmap = mappable.cmap\n+\n         if mappable.norm != self.norm:\n             self.norm = mappable.norm\n+            # Ensure LogNorm compatibility by validating vmin/vmax\n+            if isinstance(self.norm, colors.LogNorm):\n+                # Get the actual data range from the mappable\n+                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                    data = mappable.get_array()\n+                    data_min = np.ma.masked_invalid(data, copy=False).min()\n+                    if data_min <= 0:\n+                        data_min = 1e-10\n+                    # Ensure norm vmin is positive for LogNorm\n+                    if self.norm.vmin is None or self.norm.vmin <= 0:\n+                        self.norm.vmin = data_min\n+                    if self.norm.vmax is None:\n+                        data_max = np.ma.masked_invalid(data, copy=False).max()\n+                        self.norm.vmax = data_max\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1100,15 +1115,77 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+        if not self.norm.scaled():\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n+        \n+        # Ensure LogNorm compatibility by preventing vmin <= 0\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # For LogNorm, vmin must be positive to avoid division by zero\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                # Try to get a reasonable vmin from the mappable's data\n+                try:\n+                    data = self.mappable.get_array()\n+                    if data is not None and len(data) > 0:\n+                        positive_data = data[data > 0]\n+                        if len(positive_data) > 0:\n+                            self.norm.vmin = max(positive_data.min(), 1e-10)\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                except (AttributeError, ValueError):\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\n+        \n+        # Handle LogNorm case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                # Try to get valid range from mappable data\n+                array = self.mappable.get_array()\n+                if array is not None and array.size > 0:\n+                    valid_data = array[np.isfinite(array) & (array > 0)]\n+                    if valid_data.size > 0:\n+                        self.norm.vmin = max(valid_data.min(), 1e-10)\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n+        # Use LogNorm-aware nonsingular transformation\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, use multiplicative expander to maintain vmin > 0\n+            if self.norm.vmin <= 0:\n+                self.norm.vmin = 1e-10\n+            if self.norm.vmax <= self.norm.vmin:\n+                self.norm.vmax = self.norm.vmin * 10\n+            # Apply multiplicative expansion for log scale\n+            log_range = np.log10(self.norm.vmax) - np.log10(self.norm.vmin)\n+            if log_range < 1e-10:  # Very small range\n+                expansion = 0.1\n+                log_vmin = np.log10(self.norm.vmin) - expansion\n+                log_vmax = np.log10(self.norm.vmax) + expansion\n+                self.norm.vmin = 10**log_vmin\n+                self.norm.vmax = 10**log_vmax\n+        else:\n+            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n+                self.norm.vmin, self.norm.vmax, expander=0.1)\n+        if (not isinstance(self.norm, colors.BoundaryNorm) and\n+                (self.boundaries is None)):\n+            b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\n@@ -1167,10 +1244,35 @@ class Colorbar:\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n-        need to be re-entered if this gets called (either at init, or when\n-        the mappable normal gets changed: Colorbar.update_normal)\n-        \"\"\"\n-        self._process_values()\n+\n+def _reset_locator_formatter_scale(self):\n+    \"\"\"\n+    Reset the locator et al to defaults.  Any user-hardcoded changes\n+    need to be re-entered if this gets called (either at init, or when\n+    the mappable normal gets changed: Colorbar.update_normal)\n+    \"\"\"\n+    # Ensure vmin/vmax are compatible with the current norm before processing\n+    if isinstance(self.norm, colors.LogNorm):\n+        if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n+            # For LogNorm, vmin must be positive\n+            if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n+                data = self.mappable.get_array()\n+                data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                self.vmin = max(data_min, 1e-10)\n+            else:\n+                self.vmin = 1e-10\n+    \n+    self._process_values()\n+    self._locator = None\n+    self._minorlocator = None\n+    self._formatter = None\n+    self._minorformatter = None\n+    if (isinstance(self.mappable, contour.ContourSet) and\n+            isinstance(self.norm, colors.LogNorm)):\n+        # if contours have lognorm, give them a log scale...\n+        self._set_scale('log')\n+    elif (self.boundaries is not None or\n+            isinstance(self.norm, colors.BoundaryNorm)):\n         self._locator = None\n         self._minorlocator = None\n         self._formatter = None\n",
    "variant_7": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..a5942003ca 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -507,8 +507,26 @@ class Colorbar:\n         self.mappable = mappable\n         self.set_alpha(mappable.get_alpha())\n         self.cmap = mappable.cmap\n+\n         if mappable.norm != self.norm:\n+            # Store old norm for comparison\n+            old_norm_type = type(self.norm)\n+            new_norm_type = type(mappable.norm)\n+            \n             self.norm = mappable.norm\n+            \n+            # If switching to LogNorm, ensure valid vmin/vmax\n+            if (isinstance(self.norm, colors.LogNorm) and \n+                old_norm_type != colors.LogNorm):\n+                # Get data range from mappable\n+                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                    data = mappable.get_array()\n+                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                    if self.norm.vmin is None or self.norm.vmin <= 0:\n+                        self.norm.vmin = max(data_min, 1e-10)\n+                    if self.norm.vmax is None:\n+                        self.norm.vmax = np.max(data)\n+            \n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1100,15 +1118,53 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+        if not self.norm.scaled():\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n+        \n+        # Handle LogNorm case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # For LogNorm, vmin must be positive\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                # Try to get a reasonable positive vmin from the mappable's data\n+                try:\n+                    data = self.mappable.get_array()\n+                    if data is not None and len(data) > 0:\n+                        positive_data = data[data > 0]\n+                        if len(positive_data) > 0:\n+                            self.norm.vmin = max(positive_data.min(), 1e-10)\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                except (AttributeError, ValueError):\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # Set vmin to a small positive value to prevent division by zero\n+            if hasattr(self, 'mappable') and hasattr(self.mappable, 'get_array'):\n+                data = self.mappable.get_array()\n+                if data is not None and len(data) > 0:\n+                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                    self.norm.vmin = max(data_min, 1e-10)\n+                else:\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        if (not isinstance(self.norm, colors.BoundaryNorm) and\n+                (self.boundaries is None)):\n+            b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\n@@ -1164,17 +1220,41 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+    def _reset_locator_formatter_scale(self):\n+        \"\"\"\n+        Reset the locator et al to defaults.  Any user-hardcoded changes\n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure LogNorm compatibility before processing values\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin > 0 to prevent division by zero\n+            if hasattr(self.norm, 'vmin') and self.norm.vmin is not None:\n+                if self.norm.vmin <= 0:\n+                    # Get data from mappable to determine appropriate vmin\n+                    if hasattr(self.mappable, 'get_array'):\n+                        data = self.mappable.get_array()\n+                        if data is not None and len(data) > 0:\n+                            data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                            self.norm.vmin = max(data_min, 1e-10)\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n         self._formatter = None\n         self._minorformatter = None\n+        self._locator = None\n+        self._minorlocator = None\n+        self._formatter = None\n+        self._minorformatter = None\n         if (isinstance(self.mappable, contour.ContourSet) and\n                 isinstance(self.norm, colors.LogNorm)):\n             # if contours have lognorm, give them a log scale...\n",
    "variant_8": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..6b6a906b18 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -507,8 +507,30 @@ class Colorbar:\n         self.mappable = mappable\n         self.set_alpha(mappable.get_alpha())\n         self.cmap = mappable.cmap\n+\n         if mappable.norm != self.norm:\n+            # Store old norm type for comparison\n+            old_norm_type = type(self.norm)\n+            new_norm_type = type(mappable.norm)\n+            \n             self.norm = mappable.norm\n+            \n+            # If switching to LogNorm, ensure valid vmin/vmax\n+            if (new_norm_type != old_norm_type and \n+                isinstance(self.norm, colors.LogNorm)):\n+                # Get valid range from mappable data\n+                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                    data = mappable.get_array()\n+                    if data.size > 0:\n+                        data_min = np.ma.masked_invalid(data, copy=False).min()\n+                        data_max = np.ma.masked_invalid(data, copy=False).max()\n+                        if data_min > 0:\n+                            # Ensure norm has valid vmin/vmax for LogNorm\n+                            if self.norm.vmin <= 0:\n+                                self.norm.vmin = max(data_min, 1e-10)\n+                            if self.norm.vmax <= self.norm.vmin:\n+                                self.norm.vmax = max(data_max, self.norm.vmin * 10)\n+            \n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1100,15 +1122,68 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+        if not self.norm.scaled():\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n+        \n+        # Handle LogNorm case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # For LogNorm, vmin must be positive\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                # Try to get a reasonable vmin from the mappable's data\n+                try:\n+                    data = self.mappable.get_array()\n+                    if data is not None and len(data) > 0:\n+                        positive_data = data[data > 0]\n+                        if len(positive_data) > 0:\n+                            self.norm.vmin = positive_data.min()\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                except (AttributeError, ValueError):\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\n+        \n+        # Handle LogNorm case to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            # For LogNorm, vmin must be positive\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                data = self.mappable.get_array()\n+                if data is not None:\n+                    data_min = np.ma.masked_invalid(data).min()\n+                    if data_min > 0:\n+                        self.norm.vmin = data_min\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n+        # Apply nonsingular transform with LogNorm awareness\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, use multiplicative expander to maintain vmin > 0\n+            vmin_new = self.norm.vmin / 1.1\n+            vmax_new = self.norm.vmax * 1.1\n+            self.norm.vmin, self.norm.vmax = vmin_new, vmax_new\n+        else:\n+            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n+                self.norm.vmin, self.norm.vmax, expander=0.1)\n+        if (not isinstance(self.norm, colors.BoundaryNorm) and\n+                (self.boundaries is None)):\n+            b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\n@@ -1164,17 +1239,47 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+    def _reset_locator_formatter_scale(self):\n+        \"\"\"\n+        Reset the locator et al to defaults.  Any user-hardcoded changes\n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Process values first, but handle LogNorm edge cases\n+        if isinstance(self.norm, colors.LogNorm):\n+            # Ensure vmin > 0 for LogNorm to prevent division by zero\n+            if hasattr(self.norm, 'vmin') and self.norm.vmin is not None:\n+                if self.norm.vmin <= 0:\n+                    # Get data from mappable to determine appropriate vmin\n+                    if hasattr(self.mappable, 'get_array'):\n+                        data = self.mappable.get_array()\n+                        if data is not None and len(data) > 0:\n+                            data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                            self.norm.vmin = max(data_min, 1e-10)\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n         self._formatter = None\n         self._minorformatter = None\n+        if (isinstance(self.mappable, contour.ContourSet) and\n+                isinstance(self.norm, colors.LogNorm)):\n+            # if contours have lognorm, give them a log scale...\n+            self._set_scale('log')\n+        elif (self.boundaries is not None or\n+                isinstance(self.norm, colors.BoundaryNorm)):\n+        self._locator = None\n+        self._minorlocator = None\n+        self._formatter = None\n+        self._minorformatter = None\n         if (isinstance(self.mappable, contour.ContourSet) and\n                 isinstance(self.norm, colors.LogNorm)):\n             # if contours have lognorm, give them a log scale...\n"
  }
}