{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/base.py lines 1867-1869)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                # Create forward fields map for field validation\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n\n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' contains a ManyToManyField '%s', but \"\n                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/base.py lines 1640-1679)": "\n    @classmethod\n    def _check_constraints(cls, **kwargs):\n        errors = []\n        \n        # Check UniqueConstraint field validation\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields') and constraint.fields:\n                # Create forward_fields_map to avoid hitting relation tree prematurely\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if hasattr(field, 'remote_field') and isinstance(field.remote_field, models.ManyToManyRel):\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n                        elif field not in cls._meta.local_fields:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to field '%s' which is not local to model '%s'.\"\n                                    % (field_name, cls._meta.object_name),\n                                    hint=\"This issue may be caused by multi-table inheritance.\",\n                                    obj=cls,\n                                    id='models.E016',\n                                )\n                            )\n        \n        for constraint in cls._meta.constraints:\n            if not connection.features.supports_table_check_constraints:\n                if isinstance(constraint, CheckConstraint):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support check constraints.' % connection.display_name,\n                            hint=(\n                                \"A constraint won't be created. Silence this \"\n                                \"warning if you don't care about it.\"\n                            ),\n                            obj=cls,\n                            id='models.W027',\n                        )\n                    )\n            if (\n                isinstance(constraint, UniqueConstraint) and\n                constraint.condition and\n                not connection.features.supports_partial_indexes\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if (\n                isinstance(constraint, UniqueConstraint) and\n                constraint.deferrable is not None and\n                not connection.features.supports_deferrable_unique_constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        return errors\n",
    "Location 3 (/root/hy/projects_1/django/django/db/models/constraints.py lines 79-95)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check UniqueConstraint field validity\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields') and hasattr(constraint, '__class__') and constraint.__class__.__name__ == 'UniqueConstraint':\n                # Create a map of field names to field objects for validation\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n\n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_check_constraints(connection))\n            if not connection.features.supports_partial_indexes:\n                errors.extend(cls._check_unique_constraints(connection))\n        return errors\n",
    "Location 4 (/root/hy/projects_1/django/tests/invalid_models_tests/test_models.py lines 199-204)": "\n    def test_pointing_to_missing_field(self):\n        class Model(models.Model):\n            class Meta:\n                unique_together = [['missing_field']]\n\n        self.assertEqual(Model.check(), [\n            Error(\n                \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n                obj=Model,\n                id='models.E012',\n            ),\n        ])\n\n    def test_unique_constraint_pointing_to_missing_field(self):\n        class Model(models.Model):\n            class Meta:\n                constraints = [\n                    models.UniqueConstraint(fields=['missing_field'], name='unique_missing'),\n                ]\n\n        self.assertEqual(Model.check(), [\n            Error(\n                \"'constraints' refers to the nonexistent field 'missing_field'.\",\n                obj=Model,\n                id='models.E012',\n            ),\n        ])\n\n    def test_unique_constraint_pointing_to_m2m_field(self):\n        class Model(models.Model):\n            m2m = models.ManyToManyField('self')\n\n            class Meta:\n                constraints = [\n                    models.UniqueConstraint(fields=['m2m'], name='unique_m2m'),\n                ]\n\n        self.assertEqual(Model.check(), [\n            Error(\n                \"'constraints' refers to a ManyToManyField 'm2m', but \"\n                \"ManyToManyFields are not permitted in 'constraints'.\",\n                obj=Model,\n                id='models.E013',\n            ),\n        ])\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/base.py lines 1867-1869)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                # Create a mapping of field names to field objects\n                forward_fields_map = {}\n                for field in cls._meta.get_fields():\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                # Check each field in the constraint\n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s', because \"\n                                    \"ManyToManyFields cannot be included in constraints. Consider using \"\n                                    \"through model's constraints instead.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check constraint fields exist and are valid\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):  # UniqueConstraint and other field-based constraints\n                # Create forward fields map similar to _check_local_fields\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                # Check each field in the constraint\n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                # Check field existence\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if isinstance(field, ManyToManyField):\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s', \"\n                                    \"because ManyToManyFields do not have a column in the table of \"\n                                    \"this model.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n                fields = constraint.fields\n                forward_fields_map = {}\n                for field in cls._meta.get_fields():\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n\n                for field_name in fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s', \"\n                                    \"because ManyToManyFields cannot be part of an index.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check that constraint fields actually exist on the model\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):  # UniqueConstraint and other field-based constraints\n                fields = constraint.fields\n                if isinstance(constraint, UniqueConstraint):\n                    # Create forward fields map like in _check_local_fields\n                    forward_fields_map = {}\n                    for field in cls._meta._get_fields(reverse=False):\n                        forward_fields_map[field.name] = field\n                        if hasattr(field, 'attname'):\n                            forward_fields_map[field.attname] = field\n                    \n                    # Check each field in the constraint\n                    for field_name in fields:\n                        try:\n                            field = forward_fields_map[field_name]\n                        except KeyError:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E012',\n                                )\n                            )\n                        else:\n                            if field.many_to_many:\n                                errors.append(\n                                    checks.Error(\n                                        \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n                                        obj=cls,\n                                        id='models.E013',\n                                    )\n                                )\n        \n        for db in databases:\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        if cls._meta.constraints:\n            # Create forward_fields_map for field validation (similar to _check_local_fields)\n            forward_fields_map = {}\n            for field in cls._meta.local_fields:\n                forward_fields_map[field.name] = field\n                # Also handle attname for fields with db_column\n                if hasattr(field, 'attname') and field.attname != field.name:\n                    forward_fields_map[field.attname] = field\n            \n            for constraint in cls._meta.constraints:\n                if isinstance(constraint, UniqueConstraint):\n                    for field_name in constraint.fields:\n                        try:\n                            field = forward_fields_map[field_name]\n                        except KeyError:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E012',\n                                )\n                            )\n                        else:\n                            if isinstance(field, models.ManyToManyField):\n                                errors.append(\n                                    checks.Error(\n                                        \"'constraints' contains a ManyToManyField '%s', but \"\n                                        \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n                                        obj=cls,\n                                        id='models.E013',\n                                    )\n                                )\n        \n        for db in databases:\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check constraint field validation\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields') and constraint.fields:\n                # Create forward fields map for field validation\n                forward_fields_map = {}\n                for field in cls._meta.get_fields():\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                # Validate each field in the constraint\n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                # Create a mapping of field names to field objects\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                # Check each field in the constraint\n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s', \"\n                                    \"because ManyToManyFields cannot be included in constraints. \"\n                                    \"Consider using through model's constraints instead.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/base.py lines 1640-1679)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check UniqueConstraint field validation\n        for constraint in cls._meta.constraints:\n            if constraint.__class__.__name__ == 'UniqueConstraint':\n                # Use the same field validation logic as _check_local_fields\n                constraint_errors = cls._check_local_fields(constraint.fields, 'constraints')\n                errors.extend(constraint_errors)\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(databases))\n                break\n        if cls._meta.constraints:\n            errors.extend(cls._check_constraints_database_backends(databases))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields') and constraint.fields:\n                # Use the same field validation logic as _check_local_fields\n                from django.db import models\n                \n                # Build forward fields map to avoid hitting relation tree prematurely\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if isinstance(field.remote_field, models.ManyToManyRel):\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n                        elif field not in cls._meta.local_fields:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to field '%s' which is not local to model '%s'.\"\n                                    % (field_name, cls._meta.object_name),\n                                    hint=\"This issue may be caused by multi-table inheritance.\",\n                                    obj=cls,\n                                    id='models.E016',\n                                )\n                            )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(databases))\n                break\n        if cls._meta.required_db_vendor:\n            for db in databases:\n                if not router.allow_migrate_model(db, cls):\n                    continue\n                connection = connections[db]\n                if connection.vendor != cls._meta.required_db_vendor:\n                    errors.append(\n                        checks.Error(\n                            '%s can only be used on %s.'\n                            % (cls._meta.object_name, cls._meta.required_db_vendor),\n                            obj=cls,\n                            id='models.E021'\n                        )\n                    )\n                    break\n\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check field existence for UniqueConstraints\n        from django.db.models.constraints import UniqueConstraint\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                # Use the same field validation logic as _check_local_fields\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if hasattr(field, 'remote_field') and isinstance(field.remote_field, models.ManyToManyRel):\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_support(connection))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check field existence for UniqueConstraints\n        from django.db.models.constraints import UniqueConstraint\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                # Use the same field validation pattern as _check_local_fields\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if hasattr(field, 'remote_field') and hasattr(field.remote_field, '__class__'):\n                            from django.db import models\n                            if isinstance(field.remote_field, models.ManyToManyRel):\n                                errors.append(\n                                    checks.Error(\n                                        \"'constraints' refers to a ManyToManyField '%s', but \"\n                                        \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n                                        obj=cls,\n                                        id='models.E013',\n                                    )\n                                )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_model_constraints_and_indexes_not_supported(connection))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check that UniqueConstraint fields exist and are valid\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):  # UniqueConstraint and similar\n                # Build forward fields map to avoid hitting relation tree prematurely\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if hasattr(field, 'remote_field') and isinstance(field.remote_field, models.ManyToManyRel):\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n                        elif field not in cls._meta.local_fields:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to field '%s' which is not local to model '%s'.\"\n                                    % (field_name, cls._meta.object_name),\n                                    hint=\"This issue may be caused by multi-table inheritance.\",\n                                    obj=cls,\n                                    id='models.E016',\n                                )\n                            )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(databases))\n                break\n        if cls._meta.constraints:\n            errors.extend(cls._check_constraints_database_backends(databases))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n                # Create forward fields map similar to _check_local_fields\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % (\n                                    field_name,\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if hasattr(field, 'remote_field') and isinstance(field.remote_field, models.ManyToManyRel):\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n                                    \"ManyToManyFields are not permitted in 'constraints'.\" % (\n                                        field_name,\n                                    ),\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backend(db))\n            if connection.features.supports_over_clause:\n                errors.extend(cls._check_constraints_deferrable(db))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check UniqueConstraint field validity\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                # Validate that fields exist and are valid for constraints\n                constraint_errors = cls._check_local_fields(\n                    constraint.fields, 'constraints'\n                )\n                errors.extend(constraint_errors)\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(db))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraints\n        from django.db.models.constraints import UniqueConstraint\n        \n        # Build forward fields map for field validation\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if isinstance(field.remote_field, models.ManyToManyRel):\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(databases=[db]))\n            if connection.features.supports_over_clause:\n                errors.extend(cls._check_constraints_deferrable(databases=[db]))\n        return errors\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/models/constraints.py lines 79-95)": [
      "\nclass UniqueConstraint(BaseConstraint):\n    def __init__(self, *, fields, name, condition=None, deferrable=None):\n        if not fields:\n            raise ValueError('At least one field is required to define a unique constraint.')\n        if not isinstance(condition, (type(None), Q)):\n            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n        if condition and deferrable:\n            raise ValueError(\n                'UniqueConstraint with conditions cannot be deferred.'\n            )\n        if not isinstance(deferrable, (type(None), Deferrable)):\n            raise ValueError(\n                'UniqueConstraint.deferrable must be a Deferrable instance.'\n            )\n        self.fields = tuple(fields)\n        self.condition = condition\n        self.deferrable = deferrable\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint field names\n        for constraint in cls._meta.constraints:\n            if constraint.__class__.__name__ == 'UniqueConstraint':\n                # Create forward_fields_map similar to _check_local_fields\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(databases))\n                break\n        return errors\n",
      "\nclass UniqueConstraint(BaseConstraint):\n    def __init__(self, *, fields, name, condition=None, deferrable=None):\n        if not fields:\n            raise ValueError('At least one field is required to define a unique constraint.')\n        if not isinstance(condition, (type(None), Q)):\n            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n        if condition and deferrable:\n            raise ValueError(\n                'UniqueConstraint with conditions cannot be deferred.'\n            )\n        if not isinstance(deferrable, (type(None), Deferrable)):\n            raise ValueError(\n                'UniqueConstraint.deferrable must be a Deferrable instance.'\n            )\n        self.fields = tuple(fields)\n        self.condition = condition\n        self.deferrable = deferrable\n",
      "\nclass UniqueConstraint(BaseConstraint):\n    def __init__(self, *, fields, name, condition=None, deferrable=None):\n        if not fields:\n            raise ValueError('At least one field is required to define a unique constraint.')\n        if not isinstance(condition, (type(None), Q)):\n            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n        if condition and deferrable:\n            raise ValueError(\n                'UniqueConstraint with conditions cannot be deferred.'\n            )\n        if not isinstance(deferrable, (type(None), Deferrable)):\n            raise ValueError(\n                'UniqueConstraint.deferrable must be a Deferrable instance.'\n            )\n        self.fields = tuple(fields)\n        self.condition = condition\n        self.deferrable = deferrable\n",
      "\nclass UniqueConstraint(BaseConstraint):\n    def __init__(self, *, fields, name, condition=None, deferrable=None):\n        if not fields:\n            raise ValueError('At least one field is required to define a unique constraint.')\n        if not isinstance(condition, (type(None), Q)):\n            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n        if condition and deferrable:\n            raise ValueError(\n                'UniqueConstraint with conditions cannot be deferred.'\n            )\n        if not isinstance(deferrable, (type(None), Deferrable)):\n            raise ValueError(\n                'UniqueConstraint.deferrable must be a Deferrable instance.'\n            )\n        self.fields = tuple(fields)\n        self.condition = condition\n        self.deferrable = deferrable\n",
      "\nclass UniqueConstraint(BaseConstraint):\n    def __init__(self, *, fields, name, condition=None, deferrable=None):\n        if not fields:\n            raise ValueError('At least one field is required to define a unique constraint.')\n        if not isinstance(condition, (type(None), Q)):\n            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n        if condition and deferrable:\n            raise ValueError(\n                'UniqueConstraint with conditions cannot be deferred.'\n            )\n        if not isinstance(deferrable, (type(None), Deferrable)):\n            raise ValueError(\n                'UniqueConstraint.deferrable must be a Deferrable instance.'\n            )\n        self.fields = tuple(fields)\n        self.condition = condition\n        self.deferrable = deferrable\n",
      "\nclass UniqueConstraint(BaseConstraint):\n    def __init__(self, *, fields, name, condition=None, deferrable=None):\n        if not fields:\n            raise ValueError('At least one field is required to define a unique constraint.')\n        if not isinstance(condition, (type(None), Q)):\n            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n        if condition and deferrable:\n            raise ValueError(\n                'UniqueConstraint with conditions cannot be deferred.'\n            )\n        if not isinstance(deferrable, (type(None), Deferrable)):\n            raise ValueError(\n                'UniqueConstraint.deferrable must be a Deferrable instance.'\n            )\n        self.fields = tuple(fields)\n        self.condition = condition\n        self.deferrable = deferrable\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint field names\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n                forward_fields_map = {}\n                for f in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[f.name] = f\n                    if hasattr(f, 'attname'):\n                        forward_fields_map[f.attname] = f\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                checks.Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ):\n                for constraint in cls._meta.constraints:\n                    if (\n                        getattr(constraint, 'condition', None) and\n                        getattr(constraint, 'fields', None)\n                    ):\n                        errors.append(\n                            checks.Warning(\n                                '%s does not support unique constraints with '\n                                'conditions.' % connection.display_name,\n                                hint=(\n                                    'A constraint will not be created. Silence '\n                                    'this warning if you don\\'t care about it.'\n                                ),\n                                obj=cls,\n                                id='models.W040',\n                            )\n                        )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ):\n                for constraint in cls._meta.constraints:\n                    if (\n                        getattr(constraint, 'deferrable', None) and\n                        getattr(constraint, 'fields', None)\n                    ):\n                        errors.append(\n                            checks.Warning(\n                                '%s does not support deferrable unique '\n                                'constraints.' % connection.display_name,\n                                hint=(\n                                    'A constraint will not be created. Silence '\n                                    'this warning if you don\\'t care about it.'\n                                ),\n                                obj=cls,\n                                id='models.W041',\n                            )\n                        )\n        return errors\n"
    ],
    "Location 4 (/root/hy/projects_1/django/tests/invalid_models_tests/test_models.py lines 199-204)": [
      "\n    def test_pointing_to_missing_field(self):\n        class Model(models.Model):\n            class Meta:\n                unique_together = [['missing_field']]\n\n        self.assertEqual(Model.check(), [\n            Error(\n                \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n                obj=Model,\n                id='models.E012',\n            ),\n        ])\n\n    def test_constraint_pointing_to_missing_field(self):\n        class Model(models.Model):\n            class Meta:\n                constraints = [\n                    models.UniqueConstraint(fields=['missing_field'], name='test_constraint')\n                ]\n\n        self.assertEqual(Model.check(), [\n            Error(\n                \"'constraints' refers to the nonexistent field 'missing_field'.\",\n                obj=Model,\n                id='models.E012',\n            ),\n        ])\n\n    def test_constraint_pointing_to_m2m(self):\n        class Model(models.Model):\n            m2m = models.ManyToManyField('self')\n\n            class Meta:\n                constraints = [\n                    models.UniqueConstraint(fields=['m2m'], name='test_constraint')\n                ]\n\n        self.assertEqual(Model.check(), [\n            Error(\n                \"'constraints' refers to a ManyToManyField 'm2m', but \"\n                \"ManyToManyFields are not permitted in 'constraints'.\",\n                obj=Model,\n                id='models.E013',\n            ),\n        ])\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases=None, **kwargs):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):\n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                Error(\n                                    \"'constraints' cannot include the ManyToManyField field '%s'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        if not databases:\n            databases = connections\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(\n                    Error(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            'A constraint won\\'t be created. Silence this '\n                            'warning if you don\\'t care about it.'\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                    for constraint in cls._meta.constraints\n                    if isinstance(constraint, CheckConstraint)\n                )\n            if not connection.features.supports_partial_indexes:\n                errors.extend(\n                    Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            'A constraint won\\'t be created. Silence this '\n                            'warning if you don\\'t care about it.'\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                    for constraint in cls._meta.constraints\n                    if isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                )\n            if not connection.features.supports_deferrable_unique_constraints:\n                errors.extend(\n                    Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            'A constraint won\\'t be created. Silence this '\n                            'warning if you don\\'t care about it.'\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                    for constraint in cls._meta.constraints\n                    if isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                )\n        return errors\n",
      "\n    def test_pointing_to_missing_field(self):\n        class Model(models.Model):\n            class Meta:\n                unique_together = [['missing_field']]\n\n        self.assertEqual(Model.check(), [\n            Error(\n                \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n                obj=Model,\n                id='models.E012',\n            ),\n        ])\n\n    def test_constraints_pointing_to_missing_field(self):\n        class Model(models.Model):\n            class Meta:\n                constraints = [\n                    models.UniqueConstraint(fields=['missing_field'], name='unique_missing'),\n                ]\n\n        self.assertEqual(Model.check(), [\n            Error(\n                \"'constraints' refers to the nonexistent field 'missing_field'.\",\n                obj=Model,\n                id='models.E012',\n            ),\n        ])\n",
      "\n            Error(\n                \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n                obj=Model,\n                id='models.E012',\n            ),\n        ])\n\n    def test_unique_constraint_pointing_to_missing_field(self):\n        class Model(models.Model):\n            class Meta:\n                constraints = [\n                    models.UniqueConstraint(fields=['missing_field'], name='unique_missing')\n                ]\n\n        self.assertEqual(Model.check(), [\n            Error(\n                \"'constraints' refers to the nonexistent field 'missing_field'.\",\n                obj=Model,\n                id='models.E012',\n            ),\n        ])\n\n    def test_unique_constraint_pointing_to_m2m(self):\n        class Model(models.Model):\n            m2m = models.ManyToManyField('self')\n\n            class Meta:\n                constraints = [\n                    models.UniqueConstraint(fields=['m2m'], name='unique_m2m')\n                ]\n\n        self.assertEqual(Model.check(), [\n            Error(\n                \"'constraints' refers to a ManyToManyField 'm2m', but \"\n                \"ManyToManyFields are not permitted in 'constraints'.\",\n                obj=Model,\n                id='models.E013',\n            ),\n        ])\n",
      "\n            Error(\n                f\"'constraints' refers to the nonexistent field '{field_name}'.\",\n                obj=Model,\n                id='models.E012',\n            ),\n",
      "\n    @classmethod\n    def _check_constraints(cls, **kwargs):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n                try:\n                    forward_fields_map = {field.name: field for field in cls._meta.get_fields()}\n                except AttributeError:\n                    # Handle case where get_fields() might not exist in some contexts\n                    forward_fields_map = {}\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                Error(\n                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        if not connection.features.supports_table_check_constraints:\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n                try:\n                    forward_fields_map = {\n                        field.name: field for field in cls._meta.get_fields()\n                        if hasattr(field, 'name')\n                    }\n                except FieldDoesNotExist:\n                    forward_fields_map = {}\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            for constraint in cls._meta.constraints:\n                if not (\n                    constraint.condition is None or\n                    'supports_partial_indexes' in cls._get_FIELD_display.__code__.co_varnames or\n                    connection.features.supports_partial_indexes\n                ):\n                    errors.append(\n                        Warning(\n                            '%s does not support check constraints with a '\n                            'condition.' % connection.display_name,\n                            hint=(\n                                'A constraint won\\'t be created. Silence this '\n                                'warning if you don\\'t care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W027',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases=None, **kwargs):\n        errors = []\n        \n        # Check that constraint fields exist and are valid\n        for constraint in cls._meta.constraints:\n            from django.db.models.constraints import UniqueConstraint\n            if isinstance(constraint, UniqueConstraint):\n                # Check field existence and validity using the same pattern as _check_local_fields\n                forward_fields_map = {}\n                for field in cls._meta.get_fields():\n                    forward_fields_map[field.name] = field\n                    # Due to the way Django's internals work, get_field() should also\n                    # be able to fetch a field by attname. In the case of a concrete\n                    # field with relation, includes the *_id name too\n                    try:\n                        forward_fields_map[field.attname] = field\n                    except AttributeError:\n                        # field (probably NullBooleanField) doesn't have an attname.\n                        pass\n                \n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if field.many_to_many:\n                            errors.append(\n                                Error(\n                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n        \n        for db in databases or []:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(databases))\n        return errors\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..2d187b6711 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1636,6 +1636,8 @@ class Model(metaclass=ModelBase):\n         errors.extend(cls._check_local_fields(fields, 'indexes'))\n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_local_fields(cls, fields, option):\n         from django.db import models\n@@ -1684,6 +1686,14 @@ class Model(metaclass=ModelBase):\n                             id='models.E016',\n                         )\n                     )\n+        return errors\n+                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+                            % (option, field_name, cls._meta.object_name),\n+                            hint=\"This issue may be caused by multi-table inheritance.\",\n+                            obj=cls,\n+                            id='models.E016',\n+                        )\n+                    )\n         return errors\n \n     @classmethod\n@@ -1863,9 +1873,54 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Check field existence for UniqueConstraints before database-specific validation\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                # Validate fields using the same pattern as _check_local_fields\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if isinstance(field.remote_field, models.ManyToManyRel):\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+                        elif field not in cls._meta.local_fields:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to field '%s' which is not local to model '%s'.\"\n+                                    % (field_name, cls._meta.object_name),\n+                                    hint=\"This issue may be caused by multi-table inheritance.\",\n+                                    obj=cls,\n+                                    id='models.E016',\n+                                )\n+                            )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..d66eea3bfc 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,6 +76,7 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n+\n class UniqueConstraint(BaseConstraint):\n     def __init__(self, *, fields, name, condition=None, deferrable=None):\n         if not fields:\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..26152bab90 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -196,6 +196,7 @@ class UniqueTogetherTests(SimpleTestCase):\n                 unique_together = [['missing_field']]\n \n         self.assertEqual(Model.check(), [\n+\n             Error(\n                 \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n                 obj=Model,\n",
    "variant_0": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..01d642f736 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,46 +1637,102 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, **kwargs):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n+        \n+        # Check UniqueConstraint field validation\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields') and constraint.fields:\n+                # Create forward_fields_map to avoid hitting relation tree prematurely\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if hasattr(field, 'remote_field') and isinstance(field.remote_field, models.ManyToManyRel):\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+                        elif field not in cls._meta.local_fields:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to field '%s' which is not local to model '%s'.\"\n+                                    % (field_name, cls._meta.object_name),\n+                                    hint=\"This issue may be caused by multi-table inheritance.\",\n+                                    obj=cls,\n+                                    id='models.E016',\n+                                )\n+                            )\n+        \n+        for constraint in cls._meta.constraints:\n+            if not connection.features.supports_table_check_constraints:\n+                if isinstance(constraint, CheckConstraint):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support check constraints.' % connection.display_name,\n+                            hint=(\n+                                \"A constraint won't be created. Silence this \"\n+                                \"warning if you don't care about it.\"\n+                            ),\n+                            obj=cls,\n+                            id='models.W027',\n+                        )\n+                    )\n+            if (\n+                isinstance(constraint, UniqueConstraint) and\n+                constraint.condition and\n+                not connection.features.supports_partial_indexes\n+            ):\n                 errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n+                    checks.Warning(\n+                        '%s does not support unique constraints with '\n+                        'conditions.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n                         ),\n                         obj=cls,\n-                        id='models.E012',\n+                        id='models.W036',\n                     )\n                 )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n+            if (\n+                isinstance(constraint, UniqueConstraint) and\n+                constraint.deferrable is not None and\n+                not connection.features.supports_deferrable_unique_constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support deferrable unique constraints.'\n+                        % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W038',\n                     )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n+                )\n+        return errors\n                             \"'%s' refers to field '%s' which is not local to model '%s'.\"\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n@@ -1863,9 +1919,44 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                # Create forward fields map for field validation\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' contains a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..6ac41bb867 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,23 +76,54 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Check UniqueConstraint field validity\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields') and hasattr(constraint, '__class__') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                # Create a map of field names to field objects for validation\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_check_constraints(connection))\n+            if not connection.features.supports_partial_indexes:\n+                errors.extend(cls._check_unique_constraints(connection))\n+        return errors\n         super().__init__(name)\n \n     def _get_condition_sql(self, model, schema_editor):\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..c3033c07eb 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -190,6 +190,13 @@ class UniqueTogetherTests(SimpleTestCase):\n \n         self.assertEqual(Model.check(), [])\n \n+    def test_pointing_to_missing_field(self):\n+        class Model(models.Model):\n+            class Meta:\n+                unique_together = [['missing_field']]\n+\n+        self.assertEqual(Model.check(), [\n+\n     def test_pointing_to_missing_field(self):\n         class Model(models.Model):\n             class Meta:\n@@ -203,6 +210,39 @@ class UniqueTogetherTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_unique_constraint_pointing_to_missing_field(self):\n+        class Model(models.Model):\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(fields=['missing_field'], name='unique_missing'),\n+                ]\n+\n+        self.assertEqual(Model.check(), [\n+            Error(\n+                \"'constraints' refers to the nonexistent field 'missing_field'.\",\n+                obj=Model,\n+                id='models.E012',\n+            ),\n+        ])\n+\n+    def test_unique_constraint_pointing_to_m2m_field(self):\n+        class Model(models.Model):\n+            m2m = models.ManyToManyField('self')\n+\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(fields=['m2m'], name='unique_m2m'),\n+                ]\n+\n+        self.assertEqual(Model.check(), [\n+            Error(\n+                \"'constraints' refers to a ManyToManyField 'm2m', but \"\n+                \"ManyToManyFields are not permitted in 'constraints'.\",\n+                obj=Model,\n+                id='models.E013',\n+            ),\n+        ])\n+\n     def test_pointing_to_m2m(self):\n         class Model(models.Model):\n             m2m = models.ManyToManyField('self')\n",
    "variant_1": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..dc1beb3ecb 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,46 +1637,31 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n+        \n+        # Check UniqueConstraint field validation\n+        for constraint in cls._meta.constraints:\n+            if constraint.__class__.__name__ == 'UniqueConstraint':\n+                # Use the same field validation logic as _check_local_fields\n+                constraint_errors = cls._check_local_fields(constraint.fields, 'constraints')\n+                errors.extend(constraint_errors)\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(databases))\n+                break\n+        if cls._meta.constraints:\n+            errors.extend(cls._check_constraints_database_backends(databases))\n+        return errors\n                             \"'%s' refers to field '%s' which is not local to model '%s'.\"\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n@@ -1863,9 +1848,46 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                # Create a mapping of field names to field objects\n+                forward_fields_map = {}\n+                for field in cls._meta.get_fields():\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                # Check each field in the constraint\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s', because \"\n+                                    \"ManyToManyFields cannot be included in constraints. Consider using \"\n+                                    \"through model's constraints instead.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..d66eea3bfc 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,6 +76,7 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n+\n class UniqueConstraint(BaseConstraint):\n     def __init__(self, *, fields, name, condition=None, deferrable=None):\n         if not fields:\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..8ecc44a7f2 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -190,6 +190,13 @@ class UniqueTogetherTests(SimpleTestCase):\n \n         self.assertEqual(Model.check(), [])\n \n+    def test_pointing_to_missing_field(self):\n+        class Model(models.Model):\n+            class Meta:\n+                unique_together = [['missing_field']]\n+\n+        self.assertEqual(Model.check(), [\n+\n     def test_pointing_to_missing_field(self):\n         class Model(models.Model):\n             class Meta:\n@@ -203,6 +210,39 @@ class UniqueTogetherTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_constraint_pointing_to_missing_field(self):\n+        class Model(models.Model):\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(fields=['missing_field'], name='test_constraint')\n+                ]\n+\n+        self.assertEqual(Model.check(), [\n+            Error(\n+                \"'constraints' refers to the nonexistent field 'missing_field'.\",\n+                obj=Model,\n+                id='models.E012',\n+            ),\n+        ])\n+\n+    def test_constraint_pointing_to_m2m(self):\n+        class Model(models.Model):\n+            m2m = models.ManyToManyField('self')\n+\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(fields=['m2m'], name='test_constraint')\n+                ]\n+\n+        self.assertEqual(Model.check(), [\n+            Error(\n+                \"'constraints' refers to a ManyToManyField 'm2m', but \"\n+                \"ManyToManyFields are not permitted in 'constraints'.\",\n+                obj=Model,\n+                id='models.E013',\n+            ),\n+        ])\n+\n     def test_pointing_to_m2m(self):\n         class Model(models.Model):\n             m2m = models.ManyToManyField('self')\n",
    "variant_2": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..1b4650f77a 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,46 +1637,83 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n+        \n+        # Validate fields in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields') and constraint.fields:\n+                # Use the same field validation logic as _check_local_fields\n+                from django.db import models\n+                \n+                # Build forward fields map to avoid hitting relation tree prematurely\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if isinstance(field.remote_field, models.ManyToManyRel):\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+                        elif field not in cls._meta.local_fields:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to field '%s' which is not local to model '%s'.\"\n+                                    % (field_name, cls._meta.object_name),\n+                                    hint=\"This issue may be caused by multi-table inheritance.\",\n+                                    obj=cls,\n+                                    id='models.E016',\n+                                )\n+                            )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(databases))\n+                break\n+        if cls._meta.required_db_vendor:\n+            for db in databases:\n+                if not router.allow_migrate_model(db, cls):\n+                    continue\n+                connection = connections[db]\n+                if connection.vendor != cls._meta.required_db_vendor:\n                     errors.append(\n                         checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n+                            '%s can only be used on %s.'\n+                            % (cls._meta.object_name, cls._meta.required_db_vendor),\n                             obj=cls,\n-                            id='models.E013',\n+                            id='models.E021'\n                         )\n                     )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n+                    break\n+\n+        return errors\n                             \"'%s' refers to field '%s' which is not local to model '%s'.\"\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n@@ -1863,9 +1900,44 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Check constraint fields exist and are valid\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):  # UniqueConstraint and other field-based constraints\n+                # Create forward fields map similar to _check_local_fields\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                # Check each field in the constraint\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..e6185e1b7d 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,23 +76,53 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate UniqueConstraint field names\n+        for constraint in cls._meta.constraints:\n+            if constraint.__class__.__name__ == 'UniqueConstraint':\n+                # Create forward_fields_map similar to _check_local_fields\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(databases))\n+                break\n+        return errors\n         super().__init__(name)\n \n     def _get_condition_sql(self, model, schema_editor):\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..769a307f45 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -196,12 +196,95 @@ class UniqueTogetherTests(SimpleTestCase):\n                 unique_together = [['missing_field']]\n \n         self.assertEqual(Model.check(), [\n-            Error(\n-                \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n-                obj=Model,\n-                id='models.E012',\n-            ),\n-        ])\n+\n+    @classmethod\n+    def _check_constraints(cls, databases=None, **kwargs):\n+        errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        forward_fields_map = {}\n+        for field in cls._meta._get_fields(reverse=False):\n+            forward_fields_map[field.name] = field\n+            if hasattr(field, 'attname'):\n+                forward_fields_map[field.attname] = field\n+        \n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                Error(\n+                                    \"'constraints' cannot include the ManyToManyField field '%s'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n+        if not databases:\n+            databases = connections\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(\n+                    Error(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            'A constraint won\\'t be created. Silence this '\n+                            'warning if you don\\'t care about it.'\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                    for constraint in cls._meta.constraints\n+                    if isinstance(constraint, CheckConstraint)\n+                )\n+            if not connection.features.supports_partial_indexes:\n+                errors.extend(\n+                    Warning(\n+                        '%s does not support unique constraints with '\n+                        'conditions.' % connection.display_name,\n+                        hint=(\n+                            'A constraint won\\'t be created. Silence this '\n+                            'warning if you don\\'t care about it.'\n+                        ),\n+                        obj=cls,\n+                        id='models.W036',\n+                    )\n+                    for constraint in cls._meta.constraints\n+                    if isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n+                )\n+            if not connection.features.supports_deferrable_unique_constraints:\n+                errors.extend(\n+                    Warning(\n+                        '%s does not support deferrable unique constraints.'\n+                        % connection.display_name,\n+                        hint=(\n+                            'A constraint won\\'t be created. Silence this '\n+                            'warning if you don\\'t care about it.'\n+                        ),\n+                        obj=cls,\n+                        id='models.W038',\n+                    )\n+                    for constraint in cls._meta.constraints\n+                    if isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n+                )\n+        return errors\n \n     def test_pointing_to_m2m(self):\n         class Model(models.Model):\n",
    "variant_3": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..14197894a4 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,46 +1637,54 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        # Check field existence for UniqueConstraints\n+        from django.db.models.constraints import UniqueConstraint\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                # Use the same field validation logic as _check_local_fields\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n+                    else:\n+                        if hasattr(field, 'remote_field') and isinstance(field.remote_field, models.ManyToManyRel):\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_support(connection))\n+        return errors\n                             \"'%s' refers to field '%s' which is not local to model '%s'.\"\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n@@ -1863,10 +1871,54 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                # Check field existence\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if isinstance(field, ManyToManyField):\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s', \"\n+                                    \"because ManyToManyFields do not have a column in the table of \"\n+                                    \"this model.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n         for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                'supports_table_check_constraints' in cls._meta.required_db_features\n+            ) and any(\n+                isinstance(constraint, CheckConstraint)\n+                for constraint in cls._meta.constraints\n+            ):\n             if not router.allow_migrate_model(db, cls):\n                 continue\n             connection = connections[db]\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..d66eea3bfc 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,6 +76,7 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n+\n class UniqueConstraint(BaseConstraint):\n     def __init__(self, *, fields, name, condition=None, deferrable=None):\n         if not fields:\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..3e9c312180 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -190,6 +190,13 @@ class UniqueTogetherTests(SimpleTestCase):\n \n         self.assertEqual(Model.check(), [])\n \n+    def test_pointing_to_missing_field(self):\n+        class Model(models.Model):\n+            class Meta:\n+                unique_together = [['missing_field']]\n+\n+        self.assertEqual(Model.check(), [\n+\n     def test_pointing_to_missing_field(self):\n         class Model(models.Model):\n             class Meta:\n@@ -203,6 +210,21 @@ class UniqueTogetherTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_constraints_pointing_to_missing_field(self):\n+        class Model(models.Model):\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(fields=['missing_field'], name='unique_missing'),\n+                ]\n+\n+        self.assertEqual(Model.check(), [\n+            Error(\n+                \"'constraints' refers to the nonexistent field 'missing_field'.\",\n+                obj=Model,\n+                id='models.E012',\n+            ),\n+        ])\n+\n     def test_pointing_to_m2m(self):\n         class Model(models.Model):\n             m2m = models.ManyToManyField('self')\n",
    "variant_4": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..d08150fe24 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,46 +1637,56 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        # Check field existence for UniqueConstraints\n+        from django.db.models.constraints import UniqueConstraint\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                # Use the same field validation pattern as _check_local_fields\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n+                    else:\n+                        if hasattr(field, 'remote_field') and hasattr(field.remote_field, '__class__'):\n+                            from django.db import models\n+                            if isinstance(field.remote_field, models.ManyToManyRel):\n+                                errors.append(\n+                                    checks.Error(\n+                                        \"'constraints' refers to a ManyToManyField '%s', but \"\n+                                        \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n+                                        obj=cls,\n+                                        id='models.E013',\n+                                    )\n+                                )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_model_constraints_and_indexes_not_supported(connection))\n+        return errors\n                             \"'%s' refers to field '%s' which is not local to model '%s'.\"\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n@@ -1863,9 +1873,44 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Check UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n+                fields = constraint.fields\n+                forward_fields_map = {}\n+                for field in cls._meta.get_fields():\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+\n+                for field_name in fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s', \"\n+                                    \"because ManyToManyFields cannot be part of an index.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..d66eea3bfc 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,6 +76,7 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n+\n class UniqueConstraint(BaseConstraint):\n     def __init__(self, *, fields, name, condition=None, deferrable=None):\n         if not fields:\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..da3f1c2791 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -196,6 +196,7 @@ class UniqueTogetherTests(SimpleTestCase):\n                 unique_together = [['missing_field']]\n \n         self.assertEqual(Model.check(), [\n+\n             Error(\n                 \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n                 obj=Model,\n@@ -203,6 +204,39 @@ class UniqueTogetherTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_unique_constraint_pointing_to_missing_field(self):\n+        class Model(models.Model):\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(fields=['missing_field'], name='unique_missing')\n+                ]\n+\n+        self.assertEqual(Model.check(), [\n+            Error(\n+                \"'constraints' refers to the nonexistent field 'missing_field'.\",\n+                obj=Model,\n+                id='models.E012',\n+            ),\n+        ])\n+\n+    def test_unique_constraint_pointing_to_m2m(self):\n+        class Model(models.Model):\n+            m2m = models.ManyToManyField('self')\n+\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(fields=['m2m'], name='unique_m2m')\n+                ]\n+\n+        self.assertEqual(Model.check(), [\n+            Error(\n+                \"'constraints' refers to a ManyToManyField 'm2m', but \"\n+                \"ManyToManyFields are not permitted in 'constraints'.\",\n+                obj=Model,\n+                id='models.E013',\n+            ),\n+        ])\n+\n     def test_pointing_to_m2m(self):\n         class Model(models.Model):\n             m2m = models.ManyToManyField('self')\n",
    "variant_5": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..9253bdcd9d 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,46 +1637,66 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        # Check that UniqueConstraint fields exist and are valid\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):  # UniqueConstraint and similar\n+                # Build forward fields map to avoid hitting relation tree prematurely\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n+                    else:\n+                        if hasattr(field, 'remote_field') and isinstance(field.remote_field, models.ManyToManyRel):\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+                        elif field not in cls._meta.local_fields:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to field '%s' which is not local to model '%s'.\"\n+                                    % (field_name, cls._meta.object_name),\n+                                    hint=\"This issue may be caused by multi-table inheritance.\",\n+                                    obj=cls,\n+                                    id='models.E016',\n+                                )\n+                            )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(databases))\n+                break\n+        if cls._meta.constraints:\n+            errors.extend(cls._check_constraints_database_backends(databases))\n+        return errors\n                             \"'%s' refers to field '%s' which is not local to model '%s'.\"\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n@@ -1863,9 +1883,46 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Check that constraint fields actually exist on the model\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):  # UniqueConstraint and other field-based constraints\n+                fields = constraint.fields\n+                if isinstance(constraint, UniqueConstraint):\n+                    # Create forward fields map like in _check_local_fields\n+                    forward_fields_map = {}\n+                    for field in cls._meta._get_fields(reverse=False):\n+                        forward_fields_map[field.name] = field\n+                        if hasattr(field, 'attname'):\n+                            forward_fields_map[field.attname] = field\n+                    \n+                    # Check each field in the constraint\n+                    for field_name in fields:\n+                        try:\n+                            field = forward_fields_map[field_name]\n+                        except KeyError:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E012',\n+                                )\n+                            )\n+                        else:\n+                            if field.many_to_many:\n+                                errors.append(\n+                                    checks.Error(\n+                                        \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n+                                        obj=cls,\n+                                        id='models.E013',\n+                                    )\n+                                )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..d66eea3bfc 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,6 +76,7 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n+\n class UniqueConstraint(BaseConstraint):\n     def __init__(self, *, fields, name, condition=None, deferrable=None):\n         if not fields:\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..2dca04a96a 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -196,12 +196,12 @@ class UniqueTogetherTests(SimpleTestCase):\n                 unique_together = [['missing_field']]\n \n         self.assertEqual(Model.check(), [\n+\n             Error(\n-                \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n+                f\"'constraints' refers to the nonexistent field '{field_name}'.\",\n                 obj=Model,\n                 id='models.E012',\n             ),\n-        ])\n \n     def test_pointing_to_m2m(self):\n         class Model(models.Model):\n",
    "variant_6": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..f1986ef894 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,46 +1637,59 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n+                # Create forward fields map similar to _check_local_fields\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % (\n+                                    field_name,\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n+                    else:\n+                        if hasattr(field, 'remote_field') and isinstance(field.remote_field, models.ManyToManyRel):\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in 'constraints'.\" % (\n+                                        field_name,\n+                                    ),\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backend(db))\n+            if connection.features.supports_over_clause:\n+                errors.extend(cls._check_constraints_deferrable(db))\n+        return errors\n                             \"'%s' refers to field '%s' which is not local to model '%s'.\"\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n@@ -1863,9 +1876,46 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        if cls._meta.constraints:\n+            # Create forward_fields_map for field validation (similar to _check_local_fields)\n+            forward_fields_map = {}\n+            for field in cls._meta.local_fields:\n+                forward_fields_map[field.name] = field\n+                # Also handle attname for fields with db_column\n+                if hasattr(field, 'attname') and field.attname != field.name:\n+                    forward_fields_map[field.attname] = field\n+            \n+            for constraint in cls._meta.constraints:\n+                if isinstance(constraint, UniqueConstraint):\n+                    for field_name in constraint.fields:\n+                        try:\n+                            field = forward_fields_map[field_name]\n+                        except KeyError:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E012',\n+                                )\n+                            )\n+                        else:\n+                            if isinstance(field, models.ManyToManyField):\n+                                errors.append(\n+                                    checks.Error(\n+                                        \"'constraints' contains a ManyToManyField '%s', but \"\n+                                        \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n+                                        obj=cls,\n+                                        id='models.E013',\n+                                    )\n+                                )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..d66eea3bfc 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,6 +76,7 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n+\n class UniqueConstraint(BaseConstraint):\n     def __init__(self, *, fields, name, condition=None, deferrable=None):\n         if not fields:\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..2610e08d84 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -196,12 +196,43 @@ class UniqueTogetherTests(SimpleTestCase):\n                 unique_together = [['missing_field']]\n \n         self.assertEqual(Model.check(), [\n-            Error(\n-                \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n-                obj=Model,\n-                id='models.E012',\n-            ),\n-        ])\n+\n+    @classmethod\n+    def _check_constraints(cls, **kwargs):\n+        errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n+                try:\n+                    forward_fields_map = {field.name: field for field in cls._meta.get_fields()}\n+                except AttributeError:\n+                    # Handle case where get_fields() might not exist in some contexts\n+                    forward_fields_map = {}\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                Error(\n+                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n+        if not connection.features.supports_table_check_constraints:\n \n     def test_pointing_to_m2m(self):\n         class Model(models.Model):\n",
    "variant_7": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..09711e0898 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,46 +1637,30 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n+        \n+        # Check UniqueConstraint field validity\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                # Validate that fields exist and are valid for constraints\n+                constraint_errors = cls._check_local_fields(\n+                    constraint.fields, 'constraints'\n                 )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n+                errors.extend(constraint_errors)\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(db))\n+        return errors\n                             \"'%s' refers to field '%s' which is not local to model '%s'.\"\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n@@ -1863,9 +1847,44 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Check constraint field validation\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields') and constraint.fields:\n+                # Create forward fields map for field validation\n+                forward_fields_map = {}\n+                for field in cls._meta.get_fields():\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                # Validate each field in the constraint\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..d66eea3bfc 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,6 +76,7 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n+\n class UniqueConstraint(BaseConstraint):\n     def __init__(self, *, fields, name, condition=None, deferrable=None):\n         if not fields:\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..753d2baf82 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -196,12 +196,66 @@ class UniqueTogetherTests(SimpleTestCase):\n                 unique_together = [['missing_field']]\n \n         self.assertEqual(Model.check(), [\n-            Error(\n-                \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n-                obj=Model,\n-                id='models.E012',\n-            ),\n-        ])\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n+                try:\n+                    forward_fields_map = {\n+                        field.name: field for field in cls._meta.get_fields()\n+                        if hasattr(field, 'name')\n+                    }\n+                except FieldDoesNotExist:\n+                    forward_fields_map = {}\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            for constraint in cls._meta.constraints:\n+                if not (\n+                    constraint.condition is None or\n+                    'supports_partial_indexes' in cls._get_FIELD_display.__code__.co_varnames or\n+                    connection.features.supports_partial_indexes\n+                ):\n+                    errors.append(\n+                        Warning(\n+                            '%s does not support check constraints with a '\n+                            'condition.' % connection.display_name,\n+                            hint=(\n+                                'A constraint won\\'t be created. Silence this '\n+                                'warning if you don\\'t care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W027',\n+                        )\n+                    )\n+        return errors\n \n     def test_pointing_to_m2m(self):\n         class Model(models.Model):\n",
    "variant_8": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..96a6e18eb3 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,46 +1637,57 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n \n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate fields in UniqueConstraints\n+        from django.db.models.constraints import UniqueConstraint\n+        \n+        # Build forward fields map for field validation\n         forward_fields_map = {}\n         for field in cls._meta._get_fields(reverse=False):\n             forward_fields_map[field.name] = field\n             if hasattr(field, 'attname'):\n                 forward_fields_map[field.attname] = field\n-\n-        errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n+                    else:\n+                        if isinstance(field.remote_field, models.ManyToManyRel):\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' refers to a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in 'constraints'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(databases=[db]))\n+            if connection.features.supports_over_clause:\n+                errors.extend(cls._check_constraints_deferrable(databases=[db]))\n+        return errors\n                             \"'%s' refers to field '%s' which is not local to model '%s'.\"\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n@@ -1863,9 +1874,46 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                # Create a mapping of field names to field objects\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                # Check each field in the constraint\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s', \"\n+                                    \"because ManyToManyFields cannot be included in constraints. \"\n+                                    \"Consider using through model's constraints instead.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..4833bc5275 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,23 +76,88 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate UniqueConstraint field names\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n+                forward_fields_map = {}\n+                for f in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[f.name] = f\n+                    if hasattr(f, 'attname'):\n+                        forward_fields_map[f.attname] = f\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                'supports_partial_indexes' in cls._meta.required_db_features\n+            ):\n+                for constraint in cls._meta.constraints:\n+                    if (\n+                        getattr(constraint, 'condition', None) and\n+                        getattr(constraint, 'fields', None)\n+                    ):\n+                        errors.append(\n+                            checks.Warning(\n+                                '%s does not support unique constraints with '\n+                                'conditions.' % connection.display_name,\n+                                hint=(\n+                                    'A constraint will not be created. Silence '\n+                                    'this warning if you don\\'t care about it.'\n+                                ),\n+                                obj=cls,\n+                                id='models.W040',\n+                            )\n+                        )\n+            if not (\n+                connection.features.supports_deferrable_unique_constraints or\n+                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n+            ):\n+                for constraint in cls._meta.constraints:\n+                    if (\n+                        getattr(constraint, 'deferrable', None) and\n+                        getattr(constraint, 'fields', None)\n+                    ):\n+                        errors.append(\n+                            checks.Warning(\n+                                '%s does not support deferrable unique '\n+                                'constraints.' % connection.display_name,\n+                                hint=(\n+                                    'A constraint will not be created. Silence '\n+                                    'this warning if you don\\'t care about it.'\n+                                ),\n+                                obj=cls,\n+                                id='models.W041',\n+                            )\n+                        )\n+        return errors\n         super().__init__(name)\n \n     def _get_condition_sql(self, model, schema_editor):\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6c062b2990..e403145802 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -196,12 +196,59 @@ class UniqueTogetherTests(SimpleTestCase):\n                 unique_together = [['missing_field']]\n \n         self.assertEqual(Model.check(), [\n-            Error(\n-                \"'unique_together' refers to the nonexistent field 'missing_field'.\",\n-                obj=Model,\n-                id='models.E012',\n-            ),\n-        ])\n+\n+    @classmethod\n+    def _check_constraints(cls, databases=None, **kwargs):\n+        errors = []\n+        \n+        # Check that constraint fields exist and are valid\n+        for constraint in cls._meta.constraints:\n+            from django.db.models.constraints import UniqueConstraint\n+            if isinstance(constraint, UniqueConstraint):\n+                # Check field existence and validity using the same pattern as _check_local_fields\n+                forward_fields_map = {}\n+                for field in cls._meta.get_fields():\n+                    forward_fields_map[field.name] = field\n+                    # Due to the way Django's internals work, get_field() should also\n+                    # be able to fetch a field by attname. In the case of a concrete\n+                    # field with relation, includes the *_id name too\n+                    try:\n+                        forward_fields_map[field.attname] = field\n+                    except AttributeError:\n+                        # field (probably NullBooleanField) doesn't have an attname.\n+                        pass\n+                \n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if field.many_to_many:\n+                            errors.append(\n+                                Error(\n+                                    \"'constraints' cannot include the ManyToManyField '%s'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+        \n+        for db in databases or []:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(databases))\n+        return errors\n \n     def test_pointing_to_m2m(self):\n         class Model(models.Model):\n"
  }
}