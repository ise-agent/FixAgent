{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/astropy/astropy/wcs/wcs.py lines 1220-1231)": "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays early to avoid WCS transformation errors\n            if axes[0].size == 0:\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]), np.array([]))\n                return [np.array([]) for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/astropy/astropy/wcs/wcs.py lines 1220-1231)": [
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays - return empty arrays with correct structure\n            if axes[0].size == 0:\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]), np.array([]))\n                return [np.array([]) for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays to avoid InconsistentAxisTypesError\n            if axes[0].size == 0:\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]), np.array([]))\n                return [np.array([]) for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays - return empty arrays without calling WCS transformation\n            if axes[0].size == 0:\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]), np.array([]))\n                return [np.array([]) for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays early to avoid WCS transformation errors\n            if axes[0].size == 0:\n                empty_arrays = [np.array([]) for _ in range(self.naxis)]\n                if ra_dec_order and sky == 'output':\n                    return (empty_arrays[0], empty_arrays[1])\n                return empty_arrays\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays case\n            if axes[0].size == 0:\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]), np.array([]))\n                return [np.array([]) for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays early to avoid WCS transformation errors\n            if axes[0].size == 0:\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]), np.array([]))\n                return [np.array([]) for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays case\n            if axes[0].size == 0:\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]), np.array([]))\n                return [np.array([]) for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays early to avoid WCS transformation errors\n            if axes[0].size == 0:\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]), np.array([]))\n                return [np.array([]) for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..f765b318eb 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+\n+            # Handle empty arrays - return empty arrays without calling WCS transformation\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]), np.array([]))\n+                return [np.array([]) for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_0": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..6b55c7f1f6 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+            # Handle empty arrays early to avoid WCS transformation errors\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]), np.array([]))\n+                return [np.array([]) for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_1": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..0a199ec2c4 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+            # Handle empty arrays - return empty arrays with correct structure\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]), np.array([]))\n+                return [np.array([]) for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_2": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..7bd27071cf 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+            # Handle empty arrays to avoid InconsistentAxisTypesError\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]), np.array([]))\n+                return [np.array([]) for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_3": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..e6cd6175a0 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+            # Handle empty arrays - return empty arrays without calling WCS transformation\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]), np.array([]))\n+                return [np.array([]) for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_4": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..82ec943696 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,20 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+            # Handle empty arrays early to avoid WCS transformation errors\n+            if axes[0].size == 0:\n+                empty_arrays = [np.array([]) for _ in range(self.naxis)]\n+                if ra_dec_order and sky == 'output':\n+                    return (empty_arrays[0], empty_arrays[1])\n+                return empty_arrays\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_5": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..5f5234c719 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+            # Handle empty arrays case\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]), np.array([]))\n+                return [np.array([]) for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_6": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..6b55c7f1f6 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+            # Handle empty arrays early to avoid WCS transformation errors\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]), np.array([]))\n+                return [np.array([]) for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_7": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..5f5234c719 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+            # Handle empty arrays case\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]), np.array([]))\n+                return [np.array([]) for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_8": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..6b55c7f1f6 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,6 +1218,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+            # Handle empty arrays early to avoid WCS transformation errors\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]), np.array([]))\n+                return [np.array([]) for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n"
  }
}