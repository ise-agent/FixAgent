{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/sql/compiler.py lines 500-503)": "\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n            \n            # Apply distinct fields to combinator result if present\n            if self.query.distinct_fields:\n                distinct_fields, distinct_params = self.get_distinct()\n                if distinct_fields:\n                    # Wrap union query with distinct fields\n                    wrapped_sql = 'SELECT {} * FROM ({}) subquery'.format(distinct_fields, result)\n                    result = wrapped_sql\n                    params = distinct_params + params\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/sql/compiler.py lines 429-482)": "\n    def get_combinator_sql(self, combinator, all):\n        features = self.connection.features\n        compilers = [\n            query.get_compiler(self.using, self.connection)\n            for query in self.query.combined_queries if not query.is_empty()\n        ]\n        if not features.supports_slicing_ordering_in_compound:\n            for query, compiler in zip(self.query.combined_queries, compilers):\n                if query.low_mark or query.high_mark:\n                    raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                if compiler.get_order_by():\n                    raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n        parts = ()\n        for compiler in compilers:\n            try:\n                # If the columns list is limited, then all combined queries\n                # must have the same columns list. Set the selects defined on\n                # the query on all combined queries, if not already set.\n                if not compiler.query.values_select and self.query.values_select:\n                    compiler.query = compiler.query.clone()\n                    compiler.query.set_values((\n                        *self.query.extra_select,\n                        *self.query.values_select,\n                        *self.query.annotation_select,\n                    ))\n                part_sql, part_args = compiler.as_sql()\n                if compiler.query.combinator:\n                    # Wrap in a subquery if wrapping in parentheses isn't\n                    # supported.\n                    if not features.supports_parentheses_in_compound:\n                        part_sql = 'SELECT * FROM ({})'.format(part_sql)\n                    # Add parentheses when combining with compound query if not\n                    # already added for all compound queries.\n                    elif not features.supports_slicing_ordering_in_compound:\n                        part_sql = '({})'.format(part_sql)\n                parts += ((part_sql, part_args),)\n            except EmptyResultSet:\n                # Omit the empty queryset with UNION and with DIFFERENCE if the\n                # first queryset is nonempty.\n                if combinator == 'union' or (combinator == 'difference' and parts):\n                    continue\n                raise\n        if not parts:\n            raise EmptyResultSet\n        combinator_sql = self.connection.ops.set_operators[combinator]\n        if all and combinator == 'union':\n            combinator_sql += ' ALL'\n        braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n        sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n        result = [' {} '.format(combinator_sql).join(sql_parts)]\n        params = []\n        for part in args_parts:\n            params.extend(part)\n        return result, params\n",
    "Location 3 (/root/hy/projects_1/django/django/db/models/sql/compiler.py lines 516-530)": "\n            if self.query.combinator:\n                result, params = self.get_combinator_sql(\n                    self.query.combinator, self.query.combinator_all\n                )\n                \n                # If distinct fields are specified, wrap the combinator result in a subquery\n                if self.query.distinct_fields:\n                    distinct_fields, distinct_params = self._setup_joins(\n                        [field.split(LOOKUP_SEP) for field in self.query.distinct_fields], None, None\n                    )[0]\n                    \n                    # Wrap the union result in a subquery and apply DISTINCT ON\n                    subquery_sql = f\"({' '.join(result)})\"\n                    distinct_result, distinct_params_sql = self.connection.ops.distinct_sql(\n                        distinct_fields,\n                        distinct_params,\n                    )\n                    result = ['SELECT'] + distinct_result + ['*', 'FROM', subquery_sql, 'AS', 'subquery']\n                    params = params + distinct_params_sql\n                \n            else:\n",
    "Location 4 (/root/hy/projects_1/django/django/db/models/query.py lines 1137-1145)": "\n    def distinct(self, *field_names):\n        \"\"\"\n        Return a new QuerySet instance that will select only distinct results.\n        \"\"\"\n        assert not self.query.is_sliced, \\\n            \"Cannot create distinct fields once a slice has been taken.\"\n        obj = self._chain()\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
    "Location 5 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 1840-1845)": "\n    def add_distinct_fields(self, *field_names):\n        \"\"\"\n        Add and resolve the given fields to the query's \"distinct on\" clause.\n        \"\"\"\n        self.distinct_fields = field_names\n        self.distinct = True\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/sql/compiler.py lines 500-503)": [
      "\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n            \n            # Handle distinct fields after combinator operations\n            if self.query.distinct_fields:\n                if not features.supports_distinct_on:\n                    raise NotSupportedError('DISTINCT ON fields is not supported by this database backend.')\n                \n                distinct_fields, distinct_params = self.get_distinct()\n                # Wrap the combinator result in a subquery with DISTINCT ON\n                wrapped_sql = 'SELECT DISTINCT ON ({}) * FROM ({}) AS subquery'.format(\n                    ', '.join(distinct_fields), \n                    result\n                )\n                result = wrapped_sql\n                params = distinct_params + params\n",
      "\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n            \n            # Handle distinct fields for combinator queries by wrapping in subquery\n            if self.query.distinct_fields:\n                distinct_fields, distinct_params = self.get_distinct()\n                if distinct_fields:\n                    # Wrap the combinator result in a subquery with DISTINCT ON\n                    subquery_sql = '({})'.format(' '.join(result))\n                    result = ['SELECT', distinct_fields, '* FROM', subquery_sql, 'AS subquery']\n                    params = params + distinct_params\n",
      "\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n            \n            # Apply distinct fields to combinator results by wrapping in subquery\n            if self.query.distinct_fields:\n                distinct_fields, distinct_params = self.get_distinct()\n                if distinct_fields:\n                    # Wrap the union query in a subquery and apply DISTINCT ON\n                    subquery_sql = '({})'.format(result[0])\n                    result = ['SELECT DISTINCT ON ({}) * FROM {} AS subquery'.format(\n                        ', '.join(distinct_fields), subquery_sql)]\n                    params = params + distinct_params\n",
      "\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n            \n            # Apply distinct fields to combinator result if present\n            if self.query.distinct_fields:\n                if not features.supports_distinct_on_fields:\n                    raise NotSupportedError('DISTINCT ON fields is not supported by this database backend.')\n                \n                distinct_fields, distinct_params = self.get_distinct()\n                # Wrap the combinator result in a subquery with DISTINCT ON\n                subquery_sql = '({})'.format(result[0])\n                result = ['SELECT DISTINCT ON ({}) * FROM {} AS subquery'.format(\n                    ', '.join(distinct_fields), subquery_sql\n                )]\n                params = params + distinct_params\n",
      "\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n            \n            # Apply distinct fields to the combinator result if present\n            if self.query.distinct_fields:\n                if not features.supports_distinct_on:\n                    raise NotSupportedError(\n                        'DISTINCT ON fields is not supported by this database backend.'\n                    )\n                distinct_fields, distinct_params = self.get_distinct()\n                # Wrap the union result in a subquery with DISTINCT ON\n                subquery_sql = '({})'.format(result[0])\n                result = ['SELECT', distinct_fields, 'FROM', subquery_sql, 'AS subquery']\n                params = distinct_params + params\n",
      "\n        refcounts_before = self.query.alias_refcount.copy()\n        try:\n            extra_select, order_by, group_by = self.pre_sql_setup()\n            for_update_part = None\n            # Is a LIMIT/OFFSET clause needed?\n            with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n            combinator = self.query.combinator\n            features = self.connection.features\n            if combinator:\n                if not getattr(features, 'supports_select_{}'.format(combinator)):\n                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n                \n                # Handle distinct fields after union by wrapping in subquery\n                if self.query.distinct_fields:\n                    distinct_fields, distinct_params = self.get_distinct()\n                    if distinct_fields:\n                        subquery_alias = self.connection.ops.quote_name('subquery')\n                        wrapped_result = ['SELECT']\n                        wrapped_result.extend(distinct_fields)\n                        wrapped_result.append('* FROM (')\n                        wrapped_result.extend(result)\n                        wrapped_result.append(') AS %s' % subquery_alias)\n                        result = wrapped_result\n                        params = distinct_params + params\n",
      "\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n            \n            # Apply distinct fields to combinator result if needed\n            if self.query.distinct_fields:\n                distinct_fields, distinct_params = self.get_distinct()\n                if distinct_fields:\n                    # Wrap the combinator result in a subquery with DISTINCT ON\n                    subquery_sql = '({})'.format(result)\n                    result = 'SELECT DISTINCT{} * FROM {} AS subquery'.format(distinct_fields, subquery_sql)\n                    params = params + distinct_params\n",
      "\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n            \n            # Apply distinct fields to combinator result if specified\n            if self.query.distinct_fields:\n                distinct_fields, distinct_params = self.get_distinct()\n                if distinct_fields:\n                    # Wrap the union result in a subquery with DISTINCT ON\n                    subquery_sql = 'SELECT * FROM ({}) AS subquery'.format(result)\n                    result = 'SELECT {}{}'.format(distinct_fields, subquery_sql[6:])  # Replace SELECT with SELECT DISTINCT ON\n                    params = distinct_params + params\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/sql/compiler.py lines 429-482)": [
      "\n    def get_combinator_sql(self, combinator, all):\n        features = self.connection.features\n        compilers = [\n            query.get_compiler(self.using, self.connection)\n            for query in self.query.combined_queries if not query.is_empty()\n        ]\n        if not features.supports_slicing_ordering_in_compound:\n            for query, compiler in zip(self.query.combined_queries, compilers):\n                if query.low_mark or query.high_mark:\n                    raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                if compiler.get_order_by():\n                    raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n        parts = ()\n        for compiler in compilers:\n            try:\n                # If the columns list is limited, then all combined queries\n                # must have the same columns list. Set the selects defined on\n                # the query on all combined queries, if not already set.\n                if not compiler.query.values_select and self.query.values_select:\n                    compiler.query = compiler.query.clone()\n                    compiler.query.set_values((\n                        *self.query.extra_select,\n                        *self.query.values_select,\n                        *self.query.annotation_select,\n                    ))\n                part_sql, part_args = compiler.as_sql()\n                if compiler.query.combinator:\n                    # Wrap in a subquery if wrapping in parentheses isn't\n                    # supported.\n                    if not features.supports_parentheses_in_compound:\n                        part_sql = 'SELECT * FROM ({})'.format(part_sql)\n                    # Add parentheses when combining with compound query if not\n                    # already added for all compound queries.\n                    elif not features.supports_slicing_ordering_in_compound:\n                        part_sql = '({})'.format(part_sql)\n                parts += ((part_sql, part_args),)\n            except EmptyResultSet:\n                # Omit the empty queryset with UNION and with DIFFERENCE if the\n                # first queryset is nonempty.\n                if combinator == 'union' or (combinator == 'difference' and parts):\n                    continue\n                raise\n        if not parts:\n            raise EmptyResultSet\n        combinator_sql = self.connection.ops.set_operators[combinator]\n        if all and combinator == 'union':\n            combinator_sql += ' ALL'\n        braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n        sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n        result = [' {} '.format(combinator_sql).join(sql_parts)]\n        params = []\n        for part in args_parts:\n            params.extend(part)\n        return result, params\n",
      "\n    def get_combinator_sql(self, combinator, all):\n        features = self.connection.features\n        compilers = [\n            query.get_compiler(self.using, self.connection)\n            for query in self.query.combined_queries if not query.is_empty()\n        ]\n        if not features.supports_slicing_ordering_in_compound:\n            for query, compiler in zip(self.query.combined_queries, compilers):\n                if query.low_mark or query.high_mark:\n                    raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                if compiler.get_order_by():\n                    raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n        parts = ()\n        for compiler in compilers:\n            try:\n                # If the columns list is limited, then all combined queries\n                # must have the same columns list. Set the selects defined on\n                # the query on all combined queries, if not already set.\n                if not compiler.query.values_select and self.query.values_select:\n                    compiler.query = compiler.query.clone()\n                    compiler.query.set_values((\n                        *self.query.extra_select,\n                        *self.query.values_select,\n                        *self.query.annotation_select,\n                    ))\n                part_sql, part_args = compiler.as_sql()\n                if compiler.query.combinator:\n                    # Wrap in a subquery if wrapping in parentheses isn't\n                    # supported.\n                    if not features.supports_parentheses_in_compound:\n                        part_sql = 'SELECT * FROM ({})'.format(part_sql)\n                    # Add parentheses when combining with compound query if not\n                    # already added for all compound queries.\n                    elif not features.supports_slicing_ordering_in_compound:\n                        part_sql = '({})'.format(part_sql)\n                parts += ((part_sql, part_args),)\n            except EmptyResultSet:\n                # Omit the empty queryset with UNION and with DIFFERENCE if the\n                # first queryset is nonempty.\n                if combinator == 'union' or (combinator == 'difference' and parts):\n                    continue\n                raise\n        if not parts:\n            raise EmptyResultSet\n        combinator_sql = self.connection.ops.set_operators[combinator]\n        if all and combinator == 'union':\n            combinator_sql += ' ALL'\n        braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n        sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n        result = [' {} '.format(combinator_sql).join(sql_parts)]\n        params = []\n        for part in args_parts:\n            params.extend(part)\n        return result, params\n",
      "\n    def get_combinator_sql(self, combinator, all):\n        features = self.connection.features\n        compilers = [\n            query.get_compiler(self.using, self.connection)\n            for query in self.query.combined_queries if not query.is_empty()\n        ]\n        if not features.supports_slicing_ordering_in_compound:\n            for query, compiler in zip(self.query.combined_queries, compilers):\n                if query.low_mark or query.high_mark:\n                    raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                if compiler.get_order_by():\n                    raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n        parts = ()\n        for compiler in compilers:\n            try:\n                # If the columns list is limited, then all combined queries\n                # must have the same columns list. Set the selects defined on\n                # the query on all combined queries, if not already set.\n                if not compiler.query.values_select and self.query.values_select:\n                    compiler.query = compiler.query.clone()\n                    compiler.query.set_values((\n                        *self.query.extra_select,\n                        *self.query.values_select,\n                        *self.query.annotation_select,\n                    ))\n                part_sql, part_args = compiler.as_sql()\n                if compiler.query.combinator:\n                    # Wrap in a subquery if wrapping in parentheses isn't\n                    # supported.\n                    if not features.supports_parentheses_in_compound:\n                        part_sql = 'SELECT * FROM ({})'.format(part_sql)\n                    # Add parentheses when combining with compound query if not\n                    # already added for all compound queries.\n                    elif not features.supports_slicing_ordering_in_compound:\n                        part_sql = '({})'.format(part_sql)\n                parts += ((part_sql, part_args),)\n            except EmptyResultSet:\n                # Omit the empty queryset with UNION and with DIFFERENCE if the\n                # first queryset is nonempty.\n                if combinator == 'union' or (combinator == 'difference' and parts):\n                    continue\n                raise\n        if not parts:\n            raise EmptyResultSet\n        combinator_sql = self.connection.ops.set_operators[combinator]\n        if all and combinator == 'union':\n            combinator_sql += ' ALL'\n        braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n        sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n        result = [' {} '.format(combinator_sql).join(sql_parts)]\n        params = []\n        for part in args_parts:\n            params.extend(part)\n        return result, params\n",
      "\n    def get_combinator_sql(self, combinator, all):\n        features = self.connection.features\n        compilers = [\n            query.get_compiler(self.using, self.connection)\n            for query in self.query.combined_queries if not query.is_empty()\n        ]\n        if not features.supports_slicing_ordering_in_compound:\n            for query, compiler in zip(self.query.combined_queries, compilers):\n                if query.low_mark or query.high_mark:\n                    raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                if compiler.get_order_by():\n                    raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n        parts = ()\n        for compiler in compilers:\n            try:\n                # If the columns list is limited, then all combined queries\n                # must have the same columns list. Set the selects defined on\n                # the query on all combined queries, if not already set.\n                if not compiler.query.values_select and self.query.values_select:\n                    compiler.query = compiler.query.clone()\n                    compiler.query.set_values((\n                        *self.query.extra_select,\n                        *self.query.values_select,\n                        *self.query.annotation_select,\n                    ))\n                part_sql, part_args = compiler.as_sql()\n                if compiler.query.combinator:\n                    # Wrap in a subquery if wrapping in parentheses isn't\n                    # supported.\n                    if not features.supports_parentheses_in_compound:\n                        part_sql = 'SELECT * FROM ({})'.format(part_sql)\n                    # Add parentheses when combining with compound query if not\n                    # already added for all compound queries.\n                    elif not features.supports_slicing_ordering_in_compound:\n                        part_sql = '({})'.format(part_sql)\n                parts += ((part_sql, part_args),)\n            except EmptyResultSet:\n                # Omit the empty queryset with UNION and with DIFFERENCE if the\n                # first queryset is nonempty.\n                if combinator == 'union' or (combinator == 'difference' and parts):\n                    continue\n                raise\n        if not parts:\n            raise EmptyResultSet\n        combinator_sql = self.connection.ops.set_operators[combinator]\n        if all and combinator == 'union':\n            combinator_sql += ' ALL'\n        braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n        sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n        result = [' {} '.format(combinator_sql).join(sql_parts)]\n        params = []\n        for part in args_parts:\n            params.extend(part)\n        return result, params\n",
      "\n    def get_combinator_sql(self, combinator, all):\n        features = self.connection.features\n        compilers = [\n            query.get_compiler(self.using, self.connection)\n            for query in self.query.combined_queries if not query.is_empty()\n        ]\n        if not features.supports_slicing_ordering_in_compound:\n            for query, compiler in zip(self.query.combined_queries, compilers):\n                if query.low_mark or query.high_mark:\n                    raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                if compiler.get_order_by():\n                    raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n        parts = ()\n        for compiler in compilers:\n            try:\n                # If the columns list is limited, then all combined queries\n                # must have the same columns list. Set the selects defined on\n                # the query on all combined queries, if not already set.\n                if not compiler.query.values_select and self.query.values_select:\n                    compiler.query = compiler.query.clone()\n                    compiler.query.set_values((\n                        *self.query.extra_select,\n                        *self.query.values_select,\n                        *self.query.annotation_select,\n                    ))\n                part_sql, part_args = compiler.as_sql()\n                if compiler.query.combinator:\n                    # Wrap in a subquery if wrapping in parentheses isn't\n                    # supported.\n                    if not features.supports_parentheses_in_compound:\n                        part_sql = 'SELECT * FROM ({})'.format(part_sql)\n                    # Add parentheses when combining with compound query if not\n                    # already added for all compound queries.\n                    elif not features.supports_slicing_ordering_in_compound:\n                        part_sql = '({})'.format(part_sql)\n                parts += ((part_sql, part_args),)\n            except EmptyResultSet:\n                # Omit the empty queryset with UNION and with DIFFERENCE if the\n                # first queryset is nonempty.\n                if combinator == 'union' or (combinator == 'difference' and parts):\n                    continue\n                raise\n        if not parts:\n            raise EmptyResultSet\n        combinator_sql = self.connection.ops.set_operators[combinator]\n        if all and combinator == 'union':\n            combinator_sql += ' ALL'\n        braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n        sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n        result = [' {} '.format(combinator_sql).join(sql_parts)]\n        params = []\n        for part in args_parts:\n            params.extend(part)\n        return result, params\n",
      "\n    def get_combinator_sql(self, combinator, all):\n        features = self.connection.features\n        compilers = [\n            query.get_compiler(self.using, self.connection)\n            for query in self.query.combined_queries if not query.is_empty()\n        ]\n        if not features.supports_slicing_ordering_in_compound:\n            for query, compiler in zip(self.query.combined_queries, compilers):\n                if query.low_mark or query.high_mark:\n                    raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                if compiler.get_order_by():\n                    raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n        parts = ()\n        for compiler in compilers:\n            try:\n                # If the columns list is limited, then all combined queries\n                # must have the same columns list. Set the selects defined on\n                # the query on all combined queries, if not already set.\n                if not compiler.query.values_select and self.query.values_select:\n                    compiler.query = compiler.query.clone()\n                    compiler.query.set_values((\n                        *self.query.extra_select,\n                        *self.query.values_select,\n                        *self.query.annotation_select,\n                    ))\n                part_sql, part_args = compiler.as_sql()\n                if compiler.query.combinator:\n                    # Wrap in a subquery if wrapping in parentheses isn't\n                    # supported.\n                    if not features.supports_parentheses_in_compound:\n                        part_sql = 'SELECT * FROM ({})'.format(part_sql)\n                    # Add parentheses when combining with compound query if not\n                    # already added for all compound queries.\n                    elif not features.supports_slicing_ordering_in_compound:\n                        part_sql = '({})'.format(part_sql)\n                parts += ((part_sql, part_args),)\n            except EmptyResultSet:\n                # Omit the empty queryset with UNION and with DIFFERENCE if the\n                # first queryset is nonempty.\n                if combinator == 'union' or (combinator == 'difference' and parts):\n                    continue\n                raise\n        if not parts:\n            raise EmptyResultSet\n        combinator_sql = self.connection.ops.set_operators[combinator]\n        if all and combinator == 'union':\n            combinator_sql += ' ALL'\n        braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n        sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n        result = [' {} '.format(combinator_sql).join(sql_parts)]\n        params = []\n        for part in args_parts:\n            params.extend(part)\n        return result, params\n",
      "\n    def get_combinator_sql(self, combinator, all):\n        features = self.connection.features\n        compilers = [\n            query.get_compiler(self.using, self.connection)\n            for query in self.query.combined_queries if not query.is_empty()\n        ]\n        if not features.supports_slicing_ordering_in_compound:\n            for query, compiler in zip(self.query.combined_queries, compilers):\n                if query.low_mark or query.high_mark:\n                    raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                if compiler.get_order_by():\n                    raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n        parts = ()\n        for compiler in compilers:\n            try:\n                # If the columns list is limited, then all combined queries\n                # must have the same columns list. Set the selects defined on\n                # the query on all combined queries, if not already set.\n                if not compiler.query.values_select and self.query.values_select:\n                    compiler.query = compiler.query.clone()\n                    compiler.query.set_values((\n                        *self.query.extra_select,\n                        *self.query.values_select,\n                        *self.query.annotation_select,\n                    ))\n                part_sql, part_args = compiler.as_sql()\n                if compiler.query.combinator:\n                    # Wrap in a subquery if wrapping in parentheses isn't\n                    # supported.\n                    if not features.supports_parentheses_in_compound:\n                        part_sql = 'SELECT * FROM ({})'.format(part_sql)\n                    # Add parentheses when combining with compound query if not\n                    # already added for all compound queries.\n                    elif not features.supports_slicing_ordering_in_compound:\n                        part_sql = '({})'.format(part_sql)\n                parts += ((part_sql, part_args),)\n            except EmptyResultSet:\n                # Omit the empty queryset with UNION and with DIFFERENCE if the\n                # first queryset is nonempty.\n                if combinator == 'union' or (combinator == 'difference' and parts):\n                    continue\n                raise\n        if not parts:\n            raise EmptyResultSet\n        combinator_sql = self.connection.ops.set_operators[combinator]\n        if all and combinator == 'union':\n            combinator_sql += ' ALL'\n        braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n        sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n        result = [' {} '.format(combinator_sql).join(sql_parts)]\n        params = []\n        for part in args_parts:\n            params.extend(part)\n        return result, params\n",
      "\n    def get_combinator_sql(self, combinator, all):\n        features = self.connection.features\n        compilers = [\n            query.get_compiler(self.using, self.connection)\n            for query in self.query.combined_queries if not query.is_empty()\n        ]\n        if not features.supports_slicing_ordering_in_compound:\n            for query, compiler in zip(self.query.combined_queries, compilers):\n                if query.low_mark or query.high_mark:\n                    raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n                if compiler.get_order_by():\n                    raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n        parts = ()\n        for compiler in compilers:\n            try:\n                # If the columns list is limited, then all combined queries\n                # must have the same columns list. Set the selects defined on\n                # the query on all combined queries, if not already set.\n                if not compiler.query.values_select and self.query.values_select:\n                    compiler.query = compiler.query.clone()\n                    compiler.query.set_values((\n                        *self.query.extra_select,\n                        *self.query.values_select,\n                        *self.query.annotation_select,\n                    ))\n                part_sql, part_args = compiler.as_sql()\n                if compiler.query.combinator:\n                    # Wrap in a subquery if wrapping in parentheses isn't\n                    # supported.\n                    if not features.supports_parentheses_in_compound:\n                        part_sql = 'SELECT * FROM ({})'.format(part_sql)\n                    # Add parentheses when combining with compound query if not\n                    # already added for all compound queries.\n                    elif not features.supports_slicing_ordering_in_compound:\n                        part_sql = '({})'.format(part_sql)\n                parts += ((part_sql, part_args),)\n            except EmptyResultSet:\n                # Omit the empty queryset with UNION and with DIFFERENCE if the\n                # first queryset is nonempty.\n                if combinator == 'union' or (combinator == 'difference' and parts):\n                    continue\n                raise\n        if not parts:\n            raise EmptyResultSet\n        combinator_sql = self.connection.ops.set_operators[combinator]\n        if all and combinator == 'union':\n            combinator_sql += ' ALL'\n        braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n        sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n        result = [' {} '.format(combinator_sql).join(sql_parts)]\n        params = []\n        for part in args_parts:\n            params.extend(part)\n        return result, params\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/models/sql/compiler.py lines 516-530)": [
      "\n            if self.query.combinator:\n                result, params = self.get_combinator_sql(\n                    self.query.combinator, self.query.combinator_all\n                )\n                # Handle distinct fields for union queries by wrapping in a subquery\n                if self.query.distinct and self.query.distinct_fields:\n                    # Get distinct fields SQL\n                    distinct_fields, distinct_params = self._get_distinct_fields()\n                    distinct_result, distinct_sql_params = self.connection.ops.distinct_sql(\n                        distinct_fields,\n                        distinct_params,\n                    )\n                    # Wrap the union in a subquery with DISTINCT ON\n                    subquery_sql = '(%s)' % ' '.join(result)\n                    subquery_alias = self.connection.ops.quote_name('subquery')\n                    result = ['SELECT'] + distinct_result + ['*', 'FROM', subquery_sql, 'AS', subquery_alias]\n                    params.extend(distinct_sql_params)\n            else:\n",
      "\n            if self.query.combinator:\n                result, params = self.get_combinator_sql(\n                    self.query.combinator, self.query.combinator_all\n                )\n                \n                # Apply distinct fields if present after union\n                if self.query.distinct_fields:\n                    distinct_fields, distinct_params = self._get_distinct_fields()\n                    if distinct_fields:\n                        distinct_result, distinct_params = self.connection.ops.distinct_sql(\n                            distinct_fields,\n                            distinct_params,\n                        )\n                        # Wrap the union result in a subquery with DISTINCT ON\n                        union_sql = '(%s)' % ' '.join(result)\n                        result = ['SELECT'] + distinct_result + ['*', 'FROM', union_sql, 'AS', 'subquery']\n                        params = distinct_params + params\n                \n            else:\n",
      "\n        if self.query.combinator:\n            result, params = self.get_combinator_sql(\n                self.query.combinator, self.query.combinator_all\n            )\n            # If distinct fields are specified, wrap the combinator result in a subquery with DISTINCT ON\n            if self.query.distinct_fields:\n                distinct_fields, distinct_params = self._get_distinct_fields()\n                distinct_result, distinct_params = self.connection.ops.distinct_sql(\n                    distinct_fields,\n                    distinct_params,\n                )\n                # Wrap the combinator result in a subquery\n                subquery_alias = 'subquery'\n                wrapped_result = ['SELECT'] + distinct_result + ['*', 'FROM', '(%s)' % ' '.join(result), 'AS', subquery_alias]\n                return ' '.join(wrapped_result), params + distinct_params\n            return ' '.join(result), params\n",
      "\n            if combinator:\n                result, params = self.get_combinator_sql(\n                    combinator, self.query.combinator_all\n                )\n                \n                # Handle distinct fields after union operations\n                if self.query.distinct_fields:\n                    # Extract distinct field compilation logic into reusable method\n                    distinct_result, distinct_params = self._compile_distinct_fields()\n                    # Wrap the union result in a subquery with DISTINCT ON\n                    subquery_alias = self.connection.ops.quote_name('subquery')\n                    result = [\n                        'SELECT', \n                        *distinct_result,\n                        '* FROM (',\n                        *result,\n                        f') AS {subquery_alias}'\n                    ]\n                    params = distinct_params + params\n                \n                return ' '.join(result), params\n            else:\n                # This must come after 'select', 'ordering', and 'distinct'\n                # (see docstring of get_from_clause() for details).\n                from_, f_params = self.get_from_clause()\n                where, w_params = self.compile(self.where) if self.where is not None else (\"\", [])\n                having, h_params = self.compile(self.having) if self.having is not None else (\"\", [])\n                result = ['SELECT']\n                params = []\n\n                if self.query.distinct:\n                    distinct_result, distinct_params = self._compile_distinct_fields()\n                    result += distinct_result\n                    params += distinct_params\n\n                out_cols = []\n                col_idx = 1\n                for _, (s_sql, s_params), alias in self.select + extra_select:\n                    if alias:\n                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n                    elif with_col_aliases:\n                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n                        col_idx += 1\n                    params.extend(s_params)\n",
      "\n            if self.query.combinator:\n                result, params = self.get_combinator_sql(\n                    self.query.combinator, self.query.combinator_all\n                )\n                \n                # Apply distinct fields after union if they exist\n                if self.query.distinct_fields:\n                    distinct_fields, distinct_params = self._get_distinct_fields()\n                    if distinct_fields:\n                        distinct_result, distinct_field_params = self.connection.ops.distinct_sql(\n                            distinct_fields,\n                            distinct_params,\n                        )\n                        # Wrap the union result in a subquery with DISTINCT\n                        distinct_sql = ' '.join(distinct_result)\n                        result = [f'{distinct_sql} * FROM ({\" \".join(result)}) AS subquery']\n                        params.extend(distinct_field_params)\n            else:\n                distinct_fields, distinct_params = self._get_distinct_fields()\n",
      "\n            if self.query.combinator:\n                result, params = self.get_combinator_sql(\n                    self.query.combinator, self.query.combinator_all\n                )\n                \n                # Handle distinct fields for combinator queries\n                if self.query.distinct_fields:\n                    distinct_result, distinct_params = self.connection.ops.distinct_sql(\n                        self.query.distinct_fields,\n                        []\n                    )\n                    # Wrap the combinator result in a subquery with DISTINCT ON\n                    subquery_alias = self.connection.ops.quote_name('subquery')\n                    result = ['SELECT'] + distinct_result + ['* FROM ('] + result + [') AS %s' % subquery_alias]\n                    params = distinct_params + params\n                    \n                return ' '.join(result), params\n",
      "\n            if self.query.combinator:\n                # Handle combinator queries (UNION, INTERSECT, EXCEPT)\n                result, params = self.get_combinator_sql(\n                    self.query.combinator, self.query.combinator_all\n                )\n                \n                # If distinct fields are specified, wrap the combinator result in a subquery\n                if self.query.distinct_fields:\n                    distinct_result, distinct_params = self.connection.ops.distinct_sql(\n                        self.query.distinct_fields, []\n                    )\n                    # Wrap the union query in a subquery with DISTINCT ON\n                    subquery_alias = self.connection.ops.quote_name('subquery')\n                    result = ['SELECT'] + distinct_result + ['* FROM ('] + result + [') AS', subquery_alias]\n                    params = distinct_params + params\n                \n                return result, params\n            else:\n",
      "\n        if combinator:\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n            # If distinct fields are specified, wrap the combinator result in a subquery\n            if self.query.distinct_fields:\n                distinct_fields = self.get_distinct()\n                distinct_result, distinct_params = self.connection.ops.distinct_sql(\n                    distinct_fields,\n                    []\n                )\n                wrapped_result = ['SELECT'] + distinct_result + ['* FROM ('] + result + [') AS subquery']\n                result = wrapped_result\n                params = distinct_params + params\n        else:\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/models/query.py lines 1137-1145)": [
      "\n    def distinct(self, *field_names):\n        \"\"\"\n        Return a new QuerySet instance that will select only distinct results.\n        \"\"\"\n        assert not self.query.is_sliced, \\\n            \"Cannot create distinct fields once a slice has been taken.\"\n        obj = self._chain()\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\n    def distinct(self, *field_names):\n        \"\"\"\n        Return a new QuerySet instance that will select only distinct results.\n        \"\"\"\n        assert not self.query.is_sliced, \\\n            \"Cannot create distinct fields once a slice has been taken.\"\n        obj = self._chain()\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\ndef distinct(self, *field_names):\n    \"\"\"\n    Return a new QuerySet instance that will select only distinct results.\n    \"\"\"\n    assert not self.query.is_sliced, \\\n        \"Cannot create distinct fields once a slice has been taken.\"\n    obj = self._chain()\n    obj.query.add_distinct_fields(*field_names)\n    return obj\n",
      "\n    def distinct(self, *field_names):\n        \"\"\"\n        Return a new QuerySet instance that will select only distinct results.\n        \"\"\"\n        assert not self.query.is_sliced, \\\n            \"Cannot create distinct fields once a slice has been taken.\"\n        obj = self._chain()\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\n    def distinct(self, *field_names):\n        \"\"\"\n        Return a new QuerySet instance that will select only distinct results.\n        \"\"\"\n        assert not self.query.is_sliced, \\\n            \"Cannot create distinct fields once a slice has been taken.\"\n        obj = self._chain()\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\n    def distinct(self, *field_names):\n        \"\"\"\n        Return a new QuerySet instance that will select only distinct results.\n        \"\"\"\n        assert not self.query.is_sliced, \\\n            \"Cannot create distinct fields once a slice has been taken.\"\n        obj = self._chain()\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\n    def distinct(self, *field_names):\n        \"\"\"\n        Return a new QuerySet instance that will select only distinct results.\n        \"\"\"\n        assert not self.query.is_sliced, \\\n            \"Cannot create distinct fields once a slice has been taken.\"\n        obj = self._chain()\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\n    def distinct(self, *field_names):\n        \"\"\"\n        Return a new QuerySet instance that will select only distinct results.\n        \"\"\"\n        assert not self.query.is_sliced, \\\n            \"Cannot create distinct fields once a slice has been taken.\"\n        obj = self._chain()\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 1840-1845)": [
      "\ndef add_distinct_fields(self, *field_names):\n    \"\"\"\n    Add and resolve the given fields to the query's \"distinct on\" clause.\n    \"\"\"\n    self.distinct_fields = field_names\n    self.distinct = True\n",
      "\n    def add_distinct_fields(self, *field_names):\n        \"\"\"\n        Add and resolve the given fields to the query's \"distinct on\" clause.\n        \"\"\"\n        self.distinct_fields = field_names\n        self.distinct = True\n",
      "\n    def add_distinct_fields(self, *field_names):\n        \"\"\"\n        Add and resolve the given fields to the query's \"distinct on\" clause.\n        \"\"\"\n        self.distinct_fields = field_names\n        self.distinct = True\n        # Resolve field names to actual field references for later use\n        if field_names:\n            resolved_fields = []\n            opts = self.get_meta()\n            for field_name in field_names:\n                try:\n                    field = opts.get_field(field_name)\n                    resolved_fields.append(field)\n                except FieldDoesNotExist:\n                    # Handle related field lookups\n                    resolved_fields.append(field_name)\n            self._distinct_field_refs = resolved_fields\n",
      "\n    def add_distinct_fields(self, *field_names):\n        \"\"\"\n        Add and resolve the given fields to the query's \"distinct on\" clause.\n        \"\"\"\n        self.distinct_fields = field_names\n        self.distinct = True\n",
      "\ndef add_distinct_fields(self, *field_names):\n    \"\"\"\n    Add and resolve the given fields to the query's \"distinct on\" clause.\n    \"\"\"\n    self.distinct_fields = field_names\n    self.distinct = True\n",
      "\n    def add_distinct_fields(self, *field_names):\n        \"\"\"\n        Add and resolve the given fields to the query's \"distinct on\" clause.\n        \"\"\"\n        self.distinct_fields = field_names\n        self.distinct = True\n",
      "\n    def add_distinct_fields(self, *field_names):\n        \"\"\"\n        Add and resolve the given fields to the query's \"distinct on\" clause.\n        \"\"\"\n        self.distinct_fields = field_names\n        self.distinct = True\n        # Ensure distinct fields are properly resolved for subqueries\n        if self.combinator and field_names:\n            # Force the combinator query to be wrapped in a subquery\n            # so that DISTINCT ON can be applied at the outer level\n            self._combinator_needs_distinct_wrap = True\n",
      "\n    def add_distinct_fields(self, *field_names):\n        \"\"\"\n        Add and resolve the given fields to the query's \"distinct on\" clause.\n        \"\"\"\n        self.distinct_fields = field_names\n        self.distinct = True\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..6e3c499188 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 09a9d73077..8441f50a45 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n+\n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n         compilers = [\n@@ -497,10 +498,29 @@ class SQLCompiler:\n             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n             combinator = self.query.combinator\n             features = self.connection.features\n+\n             if combinator:\n                 if not getattr(features, 'supports_select_{}'.format(combinator)):\n                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+                \n+                # Handle distinct fields for combinator queries by wrapping in a subquery\n+                if self.query.distinct and self.query.distinct_fields:\n+                    distinct_fields, distinct_params = self.get_distinct()\n+                    if distinct_fields:\n+                        # Wrap the union result in a subquery with DISTINCT ON\n+                        combinator_sql = ' '.join(result)\n+                        subquery_alias = self.connection.ops.quote_name('subquery')\n+                        distinct_result, _ = self.connection.ops.distinct_sql(\n+                            distinct_fields,\n+                            distinct_params,\n+                        )\n+                        result = ['SELECT'] + distinct_result + ['* FROM ({}){} AS {}'.format(\n+                            combinator_sql, \n+                            ' ' if combinator_sql.endswith(')') else '',\n+                            subquery_alias\n+                        )]\n+                        params = params + distinct_params\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n@@ -513,6 +533,7 @@ class SQLCompiler:\n \n                 if self.query.distinct:\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n+\n                         distinct_fields,\n                         distinct_params,\n                     )\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex bb230647eb..ad55e398c4 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1837,6 +1837,7 @@ class Query(BaseExpression):\n         self.default_cols = False\n         self.select = tuple(cols)\n \n+\n     def add_distinct_fields(self, *field_names):\n         \"\"\"\n         Add and resolve the given fields to the query's \"distinct on\" clause.\n",
    "variant_0": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..6e3c499188 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 09a9d73077..8f54712826 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n+\n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n         compilers = [\n@@ -497,10 +498,20 @@ class SQLCompiler:\n             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n             combinator = self.query.combinator\n             features = self.connection.features\n-            if combinator:\n-                if not getattr(features, 'supports_select_{}'.format(combinator)):\n-                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n-                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+\n+        if combinator:\n+            if not getattr(features, 'supports_select_{}'.format(combinator)):\n+                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n+            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+            \n+            # Apply distinct fields to combinator result if present\n+            if self.query.distinct_fields:\n+                distinct_fields, distinct_params = self.get_distinct()\n+                if distinct_fields:\n+                    # Wrap union query with distinct fields\n+                    wrapped_sql = 'SELECT {} * FROM ({}) subquery'.format(distinct_fields, result)\n+                    result = wrapped_sql\n+                    params = distinct_params + params\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n@@ -513,21 +524,28 @@ class SQLCompiler:\n \n                 if self.query.distinct:\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n+\n+            if self.query.combinator:\n+                result, params = self.get_combinator_sql(\n+                    self.query.combinator, self.query.combinator_all\n+                )\n+                \n+                # If distinct fields are specified, wrap the combinator result in a subquery\n+                if self.query.distinct_fields:\n+                    distinct_fields, distinct_params = self._setup_joins(\n+                        [field.split(LOOKUP_SEP) for field in self.query.distinct_fields], None, None\n+                    )[0]\n+                    \n+                    # Wrap the union result in a subquery and apply DISTINCT ON\n+                    subquery_sql = f\"({' '.join(result)})\"\n+                    distinct_result, distinct_params_sql = self.connection.ops.distinct_sql(\n                         distinct_fields,\n                         distinct_params,\n                     )\n-                    result += distinct_result\n-                    params += distinct_params\n-\n-                out_cols = []\n-                col_idx = 1\n-                for _, (s_sql, s_params), alias in self.select + extra_select:\n-                    if alias:\n-                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n-                    elif with_col_aliases:\n-                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n-                        col_idx += 1\n-                    params.extend(s_params)\n+                    result = ['SELECT'] + distinct_result + ['*', 'FROM', subquery_sql, 'AS', 'subquery']\n+                    params = params + distinct_params_sql\n+                \n+            else:\n                     out_cols.append(s_sql)\n \n                 result += [', '.join(out_cols), 'FROM', *from_]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex bb230647eb..ad55e398c4 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1837,6 +1837,7 @@ class Query(BaseExpression):\n         self.default_cols = False\n         self.select = tuple(cols)\n \n+\n     def add_distinct_fields(self, *field_names):\n         \"\"\"\n         Add and resolve the given fields to the query's \"distinct on\" clause.\n",
    "variant_1": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..6e3c499188 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 09a9d73077..a225fe790c 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n+\n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n         compilers = [\n@@ -497,10 +498,25 @@ class SQLCompiler:\n             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n             combinator = self.query.combinator\n             features = self.connection.features\n-            if combinator:\n-                if not getattr(features, 'supports_select_{}'.format(combinator)):\n-                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n-                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+\n+        if combinator:\n+            if not getattr(features, 'supports_select_{}'.format(combinator)):\n+                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n+            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+            \n+            # Handle distinct fields after combinator operations\n+            if self.query.distinct_fields:\n+                if not features.supports_distinct_on:\n+                    raise NotSupportedError('DISTINCT ON fields is not supported by this database backend.')\n+                \n+                distinct_fields, distinct_params = self.get_distinct()\n+                # Wrap the combinator result in a subquery with DISTINCT ON\n+                wrapped_sql = 'SELECT DISTINCT ON ({}) * FROM ({}) AS subquery'.format(\n+                    ', '.join(distinct_fields), \n+                    result\n+                )\n+                result = wrapped_sql\n+                params = distinct_params + params\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n@@ -513,21 +529,25 @@ class SQLCompiler:\n \n                 if self.query.distinct:\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n+\n+            if self.query.combinator:\n+                result, params = self.get_combinator_sql(\n+                    self.query.combinator, self.query.combinator_all\n+                )\n+                # Handle distinct fields for union queries by wrapping in a subquery\n+                if self.query.distinct and self.query.distinct_fields:\n+                    # Get distinct fields SQL\n+                    distinct_fields, distinct_params = self._get_distinct_fields()\n+                    distinct_result, distinct_sql_params = self.connection.ops.distinct_sql(\n                         distinct_fields,\n                         distinct_params,\n                     )\n-                    result += distinct_result\n-                    params += distinct_params\n-\n-                out_cols = []\n-                col_idx = 1\n-                for _, (s_sql, s_params), alias in self.select + extra_select:\n-                    if alias:\n-                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n-                    elif with_col_aliases:\n-                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n-                        col_idx += 1\n-                    params.extend(s_params)\n+                    # Wrap the union in a subquery with DISTINCT ON\n+                    subquery_sql = '(%s)' % ' '.join(result)\n+                    subquery_alias = self.connection.ops.quote_name('subquery')\n+                    result = ['SELECT'] + distinct_result + ['*', 'FROM', subquery_sql, 'AS', subquery_alias]\n+                    params.extend(distinct_sql_params)\n+            else:\n                     out_cols.append(s_sql)\n \n                 result += [', '.join(out_cols), 'FROM', *from_]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex bb230647eb..382f2335ef 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1837,12 +1837,13 @@ class Query(BaseExpression):\n         self.default_cols = False\n         self.select = tuple(cols)\n \n-    def add_distinct_fields(self, *field_names):\n-        \"\"\"\n-        Add and resolve the given fields to the query's \"distinct on\" clause.\n-        \"\"\"\n-        self.distinct_fields = field_names\n-        self.distinct = True\n+\n+def add_distinct_fields(self, *field_names):\n+    \"\"\"\n+    Add and resolve the given fields to the query's \"distinct on\" clause.\n+    \"\"\"\n+    self.distinct_fields = field_names\n+    self.distinct = True\n \n     def add_fields(self, field_names, allow_m2m=True):\n         \"\"\"\n",
    "variant_2": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..6e3c499188 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 09a9d73077..228a930e4e 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n+\n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n         compilers = [\n@@ -497,10 +498,20 @@ class SQLCompiler:\n             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n             combinator = self.query.combinator\n             features = self.connection.features\n-            if combinator:\n-                if not getattr(features, 'supports_select_{}'.format(combinator)):\n-                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n-                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+\n+        if combinator:\n+            if not getattr(features, 'supports_select_{}'.format(combinator)):\n+                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n+            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+            \n+            # Handle distinct fields for combinator queries by wrapping in subquery\n+            if self.query.distinct_fields:\n+                distinct_fields, distinct_params = self.get_distinct()\n+                if distinct_fields:\n+                    # Wrap the combinator result in a subquery with DISTINCT ON\n+                    subquery_sql = '({})'.format(' '.join(result))\n+                    result = ['SELECT', distinct_fields, '* FROM', subquery_sql, 'AS subquery']\n+                    params = params + distinct_params\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n@@ -513,21 +524,26 @@ class SQLCompiler:\n \n                 if self.query.distinct:\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n-                        distinct_fields,\n-                        distinct_params,\n-                    )\n-                    result += distinct_result\n-                    params += distinct_params\n \n-                out_cols = []\n-                col_idx = 1\n-                for _, (s_sql, s_params), alias in self.select + extra_select:\n-                    if alias:\n-                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n-                    elif with_col_aliases:\n-                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n-                        col_idx += 1\n-                    params.extend(s_params)\n+            if self.query.combinator:\n+                result, params = self.get_combinator_sql(\n+                    self.query.combinator, self.query.combinator_all\n+                )\n+                \n+                # Apply distinct fields if present after union\n+                if self.query.distinct_fields:\n+                    distinct_fields, distinct_params = self._get_distinct_fields()\n+                    if distinct_fields:\n+                        distinct_result, distinct_params = self.connection.ops.distinct_sql(\n+                            distinct_fields,\n+                            distinct_params,\n+                        )\n+                        # Wrap the union result in a subquery with DISTINCT ON\n+                        union_sql = '(%s)' % ' '.join(result)\n+                        result = ['SELECT'] + distinct_result + ['*', 'FROM', union_sql, 'AS', 'subquery']\n+                        params = distinct_params + params\n+                \n+            else:\n                     out_cols.append(s_sql)\n \n                 result += [', '.join(out_cols), 'FROM', *from_]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex bb230647eb..ad55e398c4 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1837,6 +1837,7 @@ class Query(BaseExpression):\n         self.default_cols = False\n         self.select = tuple(cols)\n \n+\n     def add_distinct_fields(self, *field_names):\n         \"\"\"\n         Add and resolve the given fields to the query's \"distinct on\" clause.\n",
    "variant_3": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..93d2b3b9ae 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,15 +1134,16 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n-    def distinct(self, *field_names):\n-        \"\"\"\n-        Return a new QuerySet instance that will select only distinct results.\n-        \"\"\"\n-        assert not self.query.is_sliced, \\\n-            \"Cannot create distinct fields once a slice has been taken.\"\n-        obj = self._chain()\n-        obj.query.add_distinct_fields(*field_names)\n-        return obj\n+\n+def distinct(self, *field_names):\n+    \"\"\"\n+    Return a new QuerySet instance that will select only distinct results.\n+    \"\"\"\n+    assert not self.query.is_sliced, \\\n+        \"Cannot create distinct fields once a slice has been taken.\"\n+    obj = self._chain()\n+    obj.query.add_distinct_fields(*field_names)\n+    return obj\n \n     def extra(self, select=None, where=None, params=None, tables=None,\n               order_by=None, select_params=None):\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 09a9d73077..ad5c2d7306 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n+\n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n         compilers = [\n@@ -497,10 +498,21 @@ class SQLCompiler:\n             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n             combinator = self.query.combinator\n             features = self.connection.features\n-            if combinator:\n-                if not getattr(features, 'supports_select_{}'.format(combinator)):\n-                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n-                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+\n+        if combinator:\n+            if not getattr(features, 'supports_select_{}'.format(combinator)):\n+                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n+            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+            \n+            # Apply distinct fields to combinator results by wrapping in subquery\n+            if self.query.distinct_fields:\n+                distinct_fields, distinct_params = self.get_distinct()\n+                if distinct_fields:\n+                    # Wrap the union query in a subquery and apply DISTINCT ON\n+                    subquery_sql = '({})'.format(result[0])\n+                    result = ['SELECT DISTINCT ON ({}) * FROM {} AS subquery'.format(\n+                        ', '.join(distinct_fields), subquery_sql)]\n+                    params = params + distinct_params\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n@@ -513,21 +525,23 @@ class SQLCompiler:\n \n                 if self.query.distinct:\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n-                        distinct_fields,\n-                        distinct_params,\n-                    )\n-                    result += distinct_result\n-                    params += distinct_params\n \n-                out_cols = []\n-                col_idx = 1\n-                for _, (s_sql, s_params), alias in self.select + extra_select:\n-                    if alias:\n-                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n-                    elif with_col_aliases:\n-                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n-                        col_idx += 1\n-                    params.extend(s_params)\n+        if self.query.combinator:\n+            result, params = self.get_combinator_sql(\n+                self.query.combinator, self.query.combinator_all\n+            )\n+            # If distinct fields are specified, wrap the combinator result in a subquery with DISTINCT ON\n+            if self.query.distinct_fields:\n+                distinct_fields, distinct_params = self._get_distinct_fields()\n+                distinct_result, distinct_params = self.connection.ops.distinct_sql(\n+                    distinct_fields,\n+                    distinct_params,\n+                )\n+                # Wrap the combinator result in a subquery\n+                subquery_alias = 'subquery'\n+                wrapped_result = ['SELECT'] + distinct_result + ['*', 'FROM', '(%s)' % ' '.join(result), 'AS', subquery_alias]\n+                return ' '.join(wrapped_result), params + distinct_params\n+            return ' '.join(result), params\n                     out_cols.append(s_sql)\n \n                 result += [', '.join(out_cols), 'FROM', *from_]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex bb230647eb..53000096a4 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1837,12 +1837,25 @@ class Query(BaseExpression):\n         self.default_cols = False\n         self.select = tuple(cols)\n \n+\n     def add_distinct_fields(self, *field_names):\n         \"\"\"\n         Add and resolve the given fields to the query's \"distinct on\" clause.\n         \"\"\"\n         self.distinct_fields = field_names\n         self.distinct = True\n+        # Resolve field names to actual field references for later use\n+        if field_names:\n+            resolved_fields = []\n+            opts = self.get_meta()\n+            for field_name in field_names:\n+                try:\n+                    field = opts.get_field(field_name)\n+                    resolved_fields.append(field)\n+                except FieldDoesNotExist:\n+                    # Handle related field lookups\n+                    resolved_fields.append(field_name)\n+            self._distinct_field_refs = resolved_fields\n \n     def add_fields(self, field_names, allow_m2m=True):\n         \"\"\"\n",
    "variant_4": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..6e3c499188 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 09a9d73077..b67b86c1a9 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n+\n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n         compilers = [\n@@ -497,10 +498,24 @@ class SQLCompiler:\n             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n             combinator = self.query.combinator\n             features = self.connection.features\n-            if combinator:\n-                if not getattr(features, 'supports_select_{}'.format(combinator)):\n-                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n-                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+\n+        if combinator:\n+            if not getattr(features, 'supports_select_{}'.format(combinator)):\n+                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n+            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+            \n+            # Apply distinct fields to combinator result if present\n+            if self.query.distinct_fields:\n+                if not features.supports_distinct_on_fields:\n+                    raise NotSupportedError('DISTINCT ON fields is not supported by this database backend.')\n+                \n+                distinct_fields, distinct_params = self.get_distinct()\n+                # Wrap the combinator result in a subquery with DISTINCT ON\n+                subquery_sql = '({})'.format(result[0])\n+                result = ['SELECT DISTINCT ON ({}) * FROM {} AS subquery'.format(\n+                    ', '.join(distinct_fields), subquery_sql\n+                )]\n+                params = params + distinct_params\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n@@ -513,9 +528,39 @@ class SQLCompiler:\n \n                 if self.query.distinct:\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n-                        distinct_fields,\n-                        distinct_params,\n-                    )\n+\n+            if combinator:\n+                result, params = self.get_combinator_sql(\n+                    combinator, self.query.combinator_all\n+                )\n+                \n+                # Handle distinct fields after union operations\n+                if self.query.distinct_fields:\n+                    # Extract distinct field compilation logic into reusable method\n+                    distinct_result, distinct_params = self._compile_distinct_fields()\n+                    # Wrap the union result in a subquery with DISTINCT ON\n+                    subquery_alias = self.connection.ops.quote_name('subquery')\n+                    result = [\n+                        'SELECT', \n+                        *distinct_result,\n+                        '* FROM (',\n+                        *result,\n+                        f') AS {subquery_alias}'\n+                    ]\n+                    params = distinct_params + params\n+                \n+                return ' '.join(result), params\n+            else:\n+                # This must come after 'select', 'ordering', and 'distinct'\n+                # (see docstring of get_from_clause() for details).\n+                from_, f_params = self.get_from_clause()\n+                where, w_params = self.compile(self.where) if self.where is not None else (\"\", [])\n+                having, h_params = self.compile(self.having) if self.having is not None else (\"\", [])\n+                result = ['SELECT']\n+                params = []\n+\n+                if self.query.distinct:\n+                    distinct_result, distinct_params = self._compile_distinct_fields()\n                     result += distinct_result\n                     params += distinct_params\n \ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex bb230647eb..ad55e398c4 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1837,6 +1837,7 @@ class Query(BaseExpression):\n         self.default_cols = False\n         self.select = tuple(cols)\n \n+\n     def add_distinct_fields(self, *field_names):\n         \"\"\"\n         Add and resolve the given fields to the query's \"distinct on\" clause.\n",
    "variant_5": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..6e3c499188 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 09a9d73077..9a51da1623 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n+\n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n         compilers = [\n@@ -497,10 +498,23 @@ class SQLCompiler:\n             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n             combinator = self.query.combinator\n             features = self.connection.features\n-            if combinator:\n-                if not getattr(features, 'supports_select_{}'.format(combinator)):\n-                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n-                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+\n+        if combinator:\n+            if not getattr(features, 'supports_select_{}'.format(combinator)):\n+                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n+            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+            \n+            # Apply distinct fields to the combinator result if present\n+            if self.query.distinct_fields:\n+                if not features.supports_distinct_on:\n+                    raise NotSupportedError(\n+                        'DISTINCT ON fields is not supported by this database backend.'\n+                    )\n+                distinct_fields, distinct_params = self.get_distinct()\n+                # Wrap the union result in a subquery with DISTINCT ON\n+                subquery_sql = '({})'.format(result[0])\n+                result = ['SELECT', distinct_fields, 'FROM', subquery_sql, 'AS subquery']\n+                params = distinct_params + params\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n@@ -513,21 +527,26 @@ class SQLCompiler:\n \n                 if self.query.distinct:\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n-                        distinct_fields,\n-                        distinct_params,\n-                    )\n-                    result += distinct_result\n-                    params += distinct_params\n \n-                out_cols = []\n-                col_idx = 1\n-                for _, (s_sql, s_params), alias in self.select + extra_select:\n-                    if alias:\n-                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n-                    elif with_col_aliases:\n-                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n-                        col_idx += 1\n-                    params.extend(s_params)\n+            if self.query.combinator:\n+                result, params = self.get_combinator_sql(\n+                    self.query.combinator, self.query.combinator_all\n+                )\n+                \n+                # Apply distinct fields after union if they exist\n+                if self.query.distinct_fields:\n+                    distinct_fields, distinct_params = self._get_distinct_fields()\n+                    if distinct_fields:\n+                        distinct_result, distinct_field_params = self.connection.ops.distinct_sql(\n+                            distinct_fields,\n+                            distinct_params,\n+                        )\n+                        # Wrap the union result in a subquery with DISTINCT\n+                        distinct_sql = ' '.join(distinct_result)\n+                        result = [f'{distinct_sql} * FROM ({\" \".join(result)}) AS subquery']\n+                        params.extend(distinct_field_params)\n+            else:\n+                distinct_fields, distinct_params = self._get_distinct_fields()\n                     out_cols.append(s_sql)\n \n                 result += [', '.join(out_cols), 'FROM', *from_]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex bb230647eb..382f2335ef 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1837,12 +1837,13 @@ class Query(BaseExpression):\n         self.default_cols = False\n         self.select = tuple(cols)\n \n-    def add_distinct_fields(self, *field_names):\n-        \"\"\"\n-        Add and resolve the given fields to the query's \"distinct on\" clause.\n-        \"\"\"\n-        self.distinct_fields = field_names\n-        self.distinct = True\n+\n+def add_distinct_fields(self, *field_names):\n+    \"\"\"\n+    Add and resolve the given fields to the query's \"distinct on\" clause.\n+    \"\"\"\n+    self.distinct_fields = field_names\n+    self.distinct = True\n \n     def add_fields(self, field_names, allow_m2m=True):\n         \"\"\"\n",
    "variant_6": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..6e3c499188 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 09a9d73077..4cb546e14a 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n+\n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n         compilers = [\n@@ -489,6 +490,15 @@ class SQLCompiler:\n         If 'with_limits' is False, any limit/offset information is not included\n         in the query.\n         \"\"\"\n+        refcounts_before = self.query.alias_refcount.copy()\n+        try:\n+            extra_select, order_by, group_by = self.pre_sql_setup()\n+            for_update_part = None\n+            # Is a LIMIT/OFFSET clause needed?\n+            with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n+            combinator = self.query.combinator\n+            features = self.connection.features\n+\n         refcounts_before = self.query.alias_refcount.copy()\n         try:\n             extra_select, order_by, group_by = self.pre_sql_setup()\n@@ -501,6 +511,19 @@ class SQLCompiler:\n                 if not getattr(features, 'supports_select_{}'.format(combinator)):\n                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+                \n+                # Handle distinct fields after union by wrapping in subquery\n+                if self.query.distinct_fields:\n+                    distinct_fields, distinct_params = self.get_distinct()\n+                    if distinct_fields:\n+                        subquery_alias = self.connection.ops.quote_name('subquery')\n+                        wrapped_result = ['SELECT']\n+                        wrapped_result.extend(distinct_fields)\n+                        wrapped_result.append('* FROM (')\n+                        wrapped_result.extend(result)\n+                        wrapped_result.append(') AS %s' % subquery_alias)\n+                        result = wrapped_result\n+                        params = distinct_params + params\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n@@ -513,21 +536,24 @@ class SQLCompiler:\n \n                 if self.query.distinct:\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n-                        distinct_fields,\n-                        distinct_params,\n-                    )\n-                    result += distinct_result\n-                    params += distinct_params\n \n-                out_cols = []\n-                col_idx = 1\n-                for _, (s_sql, s_params), alias in self.select + extra_select:\n-                    if alias:\n-                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n-                    elif with_col_aliases:\n-                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n-                        col_idx += 1\n-                    params.extend(s_params)\n+            if self.query.combinator:\n+                result, params = self.get_combinator_sql(\n+                    self.query.combinator, self.query.combinator_all\n+                )\n+                \n+                # Handle distinct fields for combinator queries\n+                if self.query.distinct_fields:\n+                    distinct_result, distinct_params = self.connection.ops.distinct_sql(\n+                        self.query.distinct_fields,\n+                        []\n+                    )\n+                    # Wrap the combinator result in a subquery with DISTINCT ON\n+                    subquery_alias = self.connection.ops.quote_name('subquery')\n+                    result = ['SELECT'] + distinct_result + ['* FROM ('] + result + [') AS %s' % subquery_alias]\n+                    params = distinct_params + params\n+                    \n+                return ' '.join(result), params\n                     out_cols.append(s_sql)\n \n                 result += [', '.join(out_cols), 'FROM', *from_]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex bb230647eb..ad55e398c4 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1837,6 +1837,7 @@ class Query(BaseExpression):\n         self.default_cols = False\n         self.select = tuple(cols)\n \n+\n     def add_distinct_fields(self, *field_names):\n         \"\"\"\n         Add and resolve the given fields to the query's \"distinct on\" clause.\n",
    "variant_7": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..6e3c499188 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 09a9d73077..ecb2f64701 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n+\n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n         compilers = [\n@@ -497,10 +498,20 @@ class SQLCompiler:\n             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n             combinator = self.query.combinator\n             features = self.connection.features\n-            if combinator:\n-                if not getattr(features, 'supports_select_{}'.format(combinator)):\n-                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n-                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+\n+        if combinator:\n+            if not getattr(features, 'supports_select_{}'.format(combinator)):\n+                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n+            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+            \n+            # Apply distinct fields to combinator result if needed\n+            if self.query.distinct_fields:\n+                distinct_fields, distinct_params = self.get_distinct()\n+                if distinct_fields:\n+                    # Wrap the combinator result in a subquery with DISTINCT ON\n+                    subquery_sql = '({})'.format(result)\n+                    result = 'SELECT DISTINCT{} * FROM {} AS subquery'.format(distinct_fields, subquery_sql)\n+                    params = params + distinct_params\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n@@ -513,21 +524,25 @@ class SQLCompiler:\n \n                 if self.query.distinct:\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n-                        distinct_fields,\n-                        distinct_params,\n-                    )\n-                    result += distinct_result\n-                    params += distinct_params\n \n-                out_cols = []\n-                col_idx = 1\n-                for _, (s_sql, s_params), alias in self.select + extra_select:\n-                    if alias:\n-                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n-                    elif with_col_aliases:\n-                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n-                        col_idx += 1\n-                    params.extend(s_params)\n+            if self.query.combinator:\n+                # Handle combinator queries (UNION, INTERSECT, EXCEPT)\n+                result, params = self.get_combinator_sql(\n+                    self.query.combinator, self.query.combinator_all\n+                )\n+                \n+                # If distinct fields are specified, wrap the combinator result in a subquery\n+                if self.query.distinct_fields:\n+                    distinct_result, distinct_params = self.connection.ops.distinct_sql(\n+                        self.query.distinct_fields, []\n+                    )\n+                    # Wrap the union query in a subquery with DISTINCT ON\n+                    subquery_alias = self.connection.ops.quote_name('subquery')\n+                    result = ['SELECT'] + distinct_result + ['* FROM ('] + result + [') AS', subquery_alias]\n+                    params = distinct_params + params\n+                \n+                return result, params\n+            else:\n                     out_cols.append(s_sql)\n \n                 result += [', '.join(out_cols), 'FROM', *from_]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex bb230647eb..704b6e87f6 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1837,12 +1837,18 @@ class Query(BaseExpression):\n         self.default_cols = False\n         self.select = tuple(cols)\n \n+\n     def add_distinct_fields(self, *field_names):\n         \"\"\"\n         Add and resolve the given fields to the query's \"distinct on\" clause.\n         \"\"\"\n         self.distinct_fields = field_names\n         self.distinct = True\n+        # Ensure distinct fields are properly resolved for subqueries\n+        if self.combinator and field_names:\n+            # Force the combinator query to be wrapped in a subquery\n+            # so that DISTINCT ON can be applied at the outer level\n+            self._combinator_needs_distinct_wrap = True\n \n     def add_fields(self, field_names, allow_m2m=True):\n         \"\"\"\n",
    "variant_8": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..6e3c499188 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 09a9d73077..cd8d739b9b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ class SQLCompiler:\n             sql, params = node.as_sql(self, self.connection)\n         return sql, params\n \n+\n     def get_combinator_sql(self, combinator, all):\n         features = self.connection.features\n         compilers = [\n@@ -497,10 +498,20 @@ class SQLCompiler:\n             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n             combinator = self.query.combinator\n             features = self.connection.features\n-            if combinator:\n-                if not getattr(features, 'supports_select_{}'.format(combinator)):\n-                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n-                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+\n+        if combinator:\n+            if not getattr(features, 'supports_select_{}'.format(combinator)):\n+                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n+            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+            \n+            # Apply distinct fields to combinator result if specified\n+            if self.query.distinct_fields:\n+                distinct_fields, distinct_params = self.get_distinct()\n+                if distinct_fields:\n+                    # Wrap the union result in a subquery with DISTINCT ON\n+                    subquery_sql = 'SELECT * FROM ({}) AS subquery'.format(result)\n+                    result = 'SELECT {}{}'.format(distinct_fields, subquery_sql[6:])  # Replace SELECT with SELECT DISTINCT ON\n+                    params = distinct_params + params\n             else:\n                 distinct_fields, distinct_params = self.get_distinct()\n                 # This must come after 'select', 'ordering', and 'distinct'\n@@ -513,21 +524,20 @@ class SQLCompiler:\n \n                 if self.query.distinct:\n                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n-                        distinct_fields,\n-                        distinct_params,\n-                    )\n-                    result += distinct_result\n-                    params += distinct_params\n \n-                out_cols = []\n-                col_idx = 1\n-                for _, (s_sql, s_params), alias in self.select + extra_select:\n-                    if alias:\n-                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n-                    elif with_col_aliases:\n-                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n-                        col_idx += 1\n-                    params.extend(s_params)\n+        if combinator:\n+            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n+            # If distinct fields are specified, wrap the combinator result in a subquery\n+            if self.query.distinct_fields:\n+                distinct_fields = self.get_distinct()\n+                distinct_result, distinct_params = self.connection.ops.distinct_sql(\n+                    distinct_fields,\n+                    []\n+                )\n+                wrapped_result = ['SELECT'] + distinct_result + ['* FROM ('] + result + [') AS subquery']\n+                result = wrapped_result\n+                params = distinct_params + params\n+        else:\n                     out_cols.append(s_sql)\n \n                 result += [', '.join(out_cols), 'FROM', *from_]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex bb230647eb..ad55e398c4 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1837,6 +1837,7 @@ class Query(BaseExpression):\n         self.default_cols = False\n         self.select = tuple(cols)\n \n+\n     def add_distinct_fields(self, *field_names):\n         \"\"\"\n         Add and resolve the given fields to the query's \"distinct on\" clause.\n"
  }
}