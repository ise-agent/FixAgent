{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/pytest/src/_pytest/assertion/rewrite.py lines 967-992)": "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its expression\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.assign(iterable_expr)\n            \n            # Create variables for the loop\n            loop_var = self.variable()\n            result_var = self.variable()\n            \n            # Initialize result variable (True for all(), False for any())\n            init_value = ast.NameConstant(value=(func_name == 'all'))\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the loop body\n            element_expr = ast.Name(loop_var, ast.Load())\n            element_var = self.assign(element_expr)\n            \n            # Create condition check\n            if func_name == 'all':\n                # For all(): if not element, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n                result_value = ast.NameConstant(value=False)\n            else:\n                # For any(): if element, set result to True and break\n                condition = ast.Name(element_var, ast.Load())\n                result_value = ast.NameConstant(value=True)\n            \n            # Create the if statement inside the loop\n            if_body = [\n                ast.Assign([ast.Name(result_var, ast.Store())], result_value),\n                ast.Break()\n            ]\n            if_stmt = ast.If(condition, if_body, [])\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            res = ast.Name(result_var, ast.Load())\n            res_var = self.assign(res)\n            res_expl = self.explanation_param(self.display(res_var))\n            \n            # Create explanation showing the expansion\n            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (res_expl, res_expl, func_name, iterable_expl)\n            return res_var, outer_expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
    "Location 2 (/root/hy/projects_1/pytest/src/_pytest/assertion/rewrite.py lines 1000-1028)": "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its representation\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Create the unrolling logic\n            element_var = self.variable()\n            \n            # For all(): start with True, set to False on first False element\n            # For any(): start with False, set to True on first True element\n            initial_value = ast.Constant(func_name == 'all')\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create the loop\n            loop_target = ast.Name(element_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the condition check inside the loop\n            element_res, element_expl = self.visit(ast.Name(element_var, ast.Load()))\n            \n            # Create assertion for the element\n            if func_name == 'all':\n                # For all(), we want to assert each element is True\n                assertion_test = element_res\n                break_condition = ast.UnaryOp(ast.Not(), element_res)\n            else:\n                # For any(), we want to assert at least one element is True\n                assertion_test = element_res\n                break_condition = element_res\n            \n            # Create the assertion statement\n            assertion = ast.Assert(assertion_test, None)\n            \n            # Create break statement\n            break_stmt = ast.Break()\n            \n            # Create if statement for breaking\n            if_break = ast.If(break_condition, [\n                ast.Assign([ast.Name(result_var, ast.Store())], \n                          ast.Constant(func_name == 'any')),\n                break_stmt\n            ], [])\n            \n            # Create the loop body\n            loop_body = [assertion, if_break]\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result\n            return ast.Name(result_var, ast.Load()), f\"{func_name}({iterable_expl})\"\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/pytest/src/_pytest/assertion/rewrite.py lines 967-992)": [
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its expression\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Initialize result based on function type\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Get the current element\n            element_expr = ast.Name(loop_var, ast.Load())\n            element_var = self.variable()\n            loop_body.append(ast.Assign([ast.Name(element_var, ast.Store())], element_expr))\n            \n            # Create condition check with detailed explanation\n            element_res, element_expl = self.visit(element_expr)\n            condition_var = self.variable()\n            \n            # For all(): if element is False, set result to False and break\n            # For any(): if element is True, set result to True and break\n            if func_name == 'all':\n                # Check if element is falsy\n                condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n                loop_body.append(ast.Assign([ast.Name(condition_var, ast.Store())], condition))\n                \n                # If condition is true (element is falsy), update result and break\n                if_body = [\n                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                    ast.Break()\n                ]\n            else:  # any()\n                # Check if element is truthy\n                condition = ast.Name(element_var, ast.Load())\n                loop_body.append(ast.Assign([ast.Name(condition_var, ast.Store())], condition))\n                \n                # If condition is true (element is truthy), update result and break\n                if_body = [\n                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                    ast.Break()\n                ]\n            \n            loop_body.append(ast.If(ast.Name(condition_var, ast.Load()), if_body, []))\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iterable_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            \n            self.statements.append(for_loop)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original generic call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            iterable_var = self.assign(iterable_res)\n            \n            # Create the unrolled evaluation\n            # For all(): check each element until we find False\n            # For any(): check each element until we find True\n            target_value = func_name == 'any'  # True for any(), False for all()\n            \n            # Create a loop variable\n            loop_var = self.variable()\n            \n            # Create the comprehension that will be unrolled\n            if func_name == 'all':\n                # Generate: for item in iterable: if not item: return False\n                loop_body = []\n                item_var = self.variable()\n                loop_body.append(ast.Assign([ast.Name(item_var, ast.Store())], \n                                          ast.Name(loop_var, ast.Load())))\n                \n                # Evaluate the item\n                item_eval = self.assign(ast.Name(item_var, ast.Load()))\n                item_expl = self.explanation_param(self.display(item_eval))\n                \n                # Create the negation for all()\n                negated = ast.UnaryOp(ast.Not(), ast.Name(item_eval, ast.Load()))\n                negated_res = self.assign(negated)\n                \n                # Create the detailed explanation\n                explanation = f\"where False = {func_name}({iterable_expl})\"\n                detailed_expl = f\"{item_expl} is False\"\n                \n                # Return the result with detailed explanation\n                result_var = self.variable()\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], \n                                                ast.NameConstant(False)))\n                \n                outer_expl = f\"assert {explanation}\\n{{{detailed_expl}}}\"\n                return ast.Name(result_var, ast.Load()), outer_expl\n            \n            else:  # any()\n                # Similar logic for any() but looking for True values\n                loop_body = []\n                item_var = self.variable()\n                loop_body.append(ast.Assign([ast.Name(item_var, ast.Store())], \n                                          ast.Name(loop_var, ast.Load())))\n                \n                # Evaluate the item\n                item_eval = self.assign(ast.Name(item_var, ast.Load()))\n                item_expl = self.explanation_param(self.display(item_eval))\n                \n                # Create the detailed explanation\n                explanation = f\"where False = {func_name}({iterable_expl})\"\n                detailed_expl = f\"{item_expl} is True\"\n                \n                # Return the result with detailed explanation\n                result_var = self.variable()\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], \n                                                ast.NameConstant(False)))\n                \n                outer_expl = f\"assert {explanation}\\n{{{detailed_expl}}}\"\n                return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Default behavior for all other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its explanation\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n            \n            # Create a loop variable\n            loop_var = self.variable()\n            element_var = self.variable()\n            \n            # Create the loop to check each element\n            loop_target = ast.Name(element_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the condition check for each element\n            element_expr = ast.Name(element_var, ast.Load())\n            element_res = self.assign(element_expr)\n            \n            # Create explanation for the element\n            element_expl = self.explanation_param(self.display(element_res))\n            \n            if func_name == 'all':\n                # For all(), we want to find the first False element\n                test_condition = ast.UnaryOp(ast.Not(), element_expr)\n                failure_message = \"False\"\n            else:  # any()\n                # For any(), we want to find the first True element  \n                test_condition = element_expr\n                failure_message = \"True\"\n            \n            # Create the loop body that breaks on failure\n            loop_body = [\n                ast.Assign([ast.Name(element_res, ast.Store())], element_expr),\n                ast.If(\n                    test=test_condition,\n                    body=[ast.Break()],\n                    orelse=[]\n                )\n            ]\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=loop_target,\n                iter=loop_iter,\n                body=loop_body,\n                orelse=[]\n            )\n            \n            self.statements.append(for_loop)\n            \n            # Create the final result explanation\n            final_result = self.assign(ast.NameConstant(func_name == 'any'))\n            res_expl = self.explanation_param(self.display(final_result))\n            \n            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (\n                res_expl, res_expl, func_name, iterable_expl\n            )\n            \n            return final_result, outer_expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-ins\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its expression\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n            \n            # Create a loop variable for iteration\n            loop_var = self.variable()\n            \n            # Create result variable\n            result_var = self.variable()\n            \n            # Initialize result based on function\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create loop body\n            loop_body = []\n            \n            # Visit the loop variable to create assertion-friendly expression\n            element_expr, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n            \n            if func_name == 'all':\n                # For all(): if not element, set result to False and break\n                test_expr = ast.UnaryOp(ast.Not(), element_expr)\n                condition_var = self.variable()\n                loop_body.append(ast.Assign([ast.Name(condition_var, ast.Store())], test_expr))\n                \n                # If condition is true (element is false), set result and break\n                if_body = [\n                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                    ast.Break()\n                ]\n                loop_body.append(ast.If(ast.Name(condition_var, ast.Load()), if_body, []))\n                \n            else:  # any()\n                # For any(): if element, set result to True and break\n                condition_var = self.variable()\n                loop_body.append(ast.Assign([ast.Name(condition_var, ast.Store())], element_expr))\n                \n                # If condition is true (element is true), set result and break\n                if_body = [\n                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                    ast.Break()\n                ]\n                loop_body.append(ast.If(ast.Name(condition_var, ast.Load()), if_body, []))\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            res = ast.Name(result_var, ast.Load())\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            return res, expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-ins\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iter_var = self.variable()\n            iter_expr, iter_expl = self.visit(iterable_arg)\n            self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iter_expr))\n            \n            # Create the loop variable\n            item_var = self.variable()\n            \n            # Create the result variable\n            result_var = self.variable()\n            \n            # Initialize result based on function type\n            if func_name == 'all':\n                initial_value = ast.NameConstant(True)\n                break_condition = ast.NameConstant(False)\n            else:  # any\n                initial_value = ast.NameConstant(False)\n                break_condition = ast.NameConstant(True)\n                \n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create the for loop\n            loop_body = []\n            \n            # Evaluate the current item\n            item_expr, item_expl = self.visit(ast.Name(item_var, ast.Load()))\n            item_result_var = self.variable()\n            loop_body.append(ast.Assign([ast.Name(item_result_var, ast.Store())], item_expr))\n            \n            # Create assertion for detailed failure info\n            assertion_var = self.variable()\n            assertion = ast.Assign([ast.Name(assertion_var, ast.Store())], ast.Name(item_result_var, ast.Load()))\n            loop_body.append(assertion)\n            \n            # Add the assertion explanation\n            explanation_var = self.variable()\n            explanation_value = ast.Str(s=item_expl)\n            loop_body.append(ast.Assign([ast.Name(explanation_var, ast.Store())], explanation_value))\n            \n            # Create conditional break logic\n            if func_name == 'all':\n                # For all(): if not item_result, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), ast.Name(item_result_var, ast.Load()))\n            else:  # any\n                # For any(): if item_result, set result to True and break\n                condition = ast.Name(item_result_var, ast.Load())\n                \n            if_body = [\n                ast.Assign([ast.Name(result_var, ast.Store())], break_condition),\n                ast.Break()\n            ]\n            \n            loop_body.append(ast.If(condition, if_body, []))\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=ast.Name(item_var, ast.Store()),\n                iter=ast.Name(iter_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            \n            self.statements.append(for_loop)\n            \n            # Return the result\n            res = ast.Name(result_var, ast.Load())\n            expl = \"%s(%s)\" % (func_name, iter_expl)\n            return res, expl\n            \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its expression\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iter_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable_expr))\n            \n            # Create a loop variable for individual elements\n            element_var = self.variable()\n            result_var = self.variable()\n            \n            # Initialize result based on function type\n            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            \n            # Create the loop to check each element\n            loop_target = ast.Name(element_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # Create the condition check for each element\n            element_expr = ast.Name(element_var, ast.Load())\n            element_res, element_expl = self.visit(element_expr)\n            \n            # Create assertion for the element\n            if func_name == 'all':\n                # For all(), we want to assert each element is True\n                test_condition = element_res\n                break_condition = ast.UnaryOp(ast.Not(), element_res)\n                result_on_break = ast.NameConstant(False)\n            else:\n                # For any(), we want to find the first True element\n                test_condition = element_res\n                break_condition = element_res\n                result_on_break = ast.NameConstant(True)\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Add assertion for meaningful error reporting\n            assertion = ast.Assert(test_condition, None)\n            loop_body.append(assertion)\n            \n            # Add break condition\n            break_stmt = ast.If(\n                break_condition,\n                [ast.Assign([ast.Name(result_var, ast.Store())], result_on_break),\n                 ast.Break()],\n                []\n            )\n            loop_body.append(break_stmt)\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            res = ast.Name(result_var, ast.Load())\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(res))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return res, outer_expl\n        \n        # Regular call processing for non-all/any functions\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its expression\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Create the loop to evaluate each element\n            loop_var = self.variable()\n            element_var = self.variable()\n            \n            # Initialize result based on function type\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create the for loop\n            loop_target = ast.Name(element_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the condition check inside the loop\n            element_expr = ast.Name(element_var, ast.Load())\n            element_res, element_expl = self.visit(element_expr)\n            \n            # Create the condition based on function type\n            if func_name == 'all':\n                # For all(), we check if element is False and break\n                condition = ast.UnaryOp(ast.Not(), element_res)\n                break_value = ast.NameConstant(False)\n            else:\n                # For any(), we check if element is True and break\n                condition = element_res\n                break_value = ast.NameConstant(True)\n            \n            # Create the if statement inside the loop\n            loop_body = [\n                ast.If(\n                    condition,\n                    [\n                        ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n                        ast.Break()\n                    ],\n                    []\n                )\n            ]\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            res = ast.Name(result_var, ast.Load())\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(res))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return res, outer_expl\n        \n        # Original implementation for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n            \n            # Create the result variable\n            result_var = self.variable()\n            \n            # For all(), start with True and look for False\n            # For any(), start with False and look for True\n            initial_value = ast.NameConstant(func_name == 'all')\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Evaluate the current element\n            element_expr, element_expl = ast.Name(loop_var, ast.Load()), loop_var\n            element_result = self.assign(element_expr)\n            element_result_expl = self.explanation_param(self.display(element_result))\n            \n            # Create condition based on function type\n            if func_name == 'all':\n                # For all(), if element is False, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), ast.Name(element_result, ast.Load()))\n                assign_value = ast.NameConstant(False)\n            else:  # any()\n                # For any(), if element is True, set result to True and break\n                condition = ast.Name(element_result, ast.Load())\n                assign_value = ast.NameConstant(True)\n            \n            # Add assignment and break in if body\n            if_body = [\n                ast.Assign([ast.Name(result_var, ast.Store())], assign_value),\n                ast.Break()\n            ]\n            \n            loop_body.append(ast.If(condition, if_body, []))\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result\n            res = ast.Name(result_var, ast.Load())\n            res_name = self.assign(res)\n            res_expl = self.explanation_param(self.display(res_name))\n            \n            # Create explanation\n            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (\n                res_expl, res_expl, func_name, iterable_expl\n            )\n            \n            return res_name, outer_expl\n        \n        # Default behavior for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
    ],
    "Location 2 (/root/hy/projects_1/pytest/src/_pytest/assertion/rewrite.py lines 1000-1028)": [
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n            self.statements.append(iter_assign)\n            \n            # Create loop variable\n            item_var = self.variable()\n            \n            # Create the loop body that checks each element\n            # For all(): stop at first False, for any(): stop at first True\n            target_value = func_name == 'any'  # True for any(), False for all()\n            \n            # Create the test expression for each item\n            test_expr = ast.Name(item_var, ast.Load())\n            \n            # Visit the test to get proper assertion rewriting\n            test_res, test_expl = self.visit(test_expr)\n            \n            # Create condition: item for any(), not item for all()\n            if func_name == 'all':\n                condition = ast.UnaryOp(ast.Not(), test_res)\n                condition_expl = \"not \" + test_expl\n            else:\n                condition = test_res\n                condition_expl = test_expl\n            \n            # Create early return for the failing case\n            return_value = ast.NameConstant(not target_value)\n            early_return = ast.If(\n                condition,\n                [ast.Return(return_value)],\n                []\n            )\n            \n            # Create the for loop\n            loop_body = [early_return]\n            for_loop = ast.For(\n                ast.Name(item_var, ast.Store()),\n                ast.Name(iter_var, ast.Load()),\n                loop_body,\n                []\n            )\n            \n            self.statements.append(for_loop)\n            \n            # If we get here, all() succeeded (all True) or any() failed (all False)\n            final_result = ast.NameConstant(target_value)\n            result_var = self.assign(final_result)\n            \n            # Create explanation\n            func_expl = func_name\n            iter_expl = self.explanation_param(self.display(ast.Name(iter_var, ast.Load())))\n            expl = \"%s(%s)\" % (func_expl, iter_expl)\n            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original implementation for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\ndef visit_Call_35(self, call):\n    \"\"\"\n    visit `ast.Call` nodes on Python 3.5+\n    \"\"\"\n    # Special handling for all() and any() built-in functions\n    if (isinstance(call.func, ast.Name) and \n        call.func.id in ('all', 'any') and \n        len(call.args) == 1 and \n        not call.keywords):\n        \n        # Get the iterable argument\n        iterable_arg = call.args[0]\n        iterable_res, iterable_expl = self.visit(iterable_arg)\n        \n        # Create a temporary variable to hold the iterable\n        iterable_var = self.variable()\n        self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n        \n        # Create a result variable\n        result_var = self.variable()\n        \n        # Initialize result based on function (True for all(), False for any())\n        initial_value = ast.NameConstant(call.func.id == 'all')\n        self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n        \n        # Create loop variable\n        loop_var = self.variable()\n        \n        # Create the loop body\n        loop_body = []\n        \n        # Get the element and create explanation\n        element_var = self.variable()\n        element_assign = ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load()))\n        loop_body.append(element_assign)\n        \n        # Create condition check based on function type\n        if call.func.id == 'all':\n            # For all(), we check if element is falsy\n            condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n            result_value = ast.NameConstant(False)\n        else:  # any()\n            # For any(), we check if element is truthy  \n            condition = ast.Name(element_var, ast.Load())\n            result_value = ast.NameConstant(True)\n        \n        # Create assignment when condition is met\n        result_assign = ast.Assign([ast.Name(result_var, ast.Store())], result_value)\n        \n        # Create break statement\n        break_stmt = ast.Break()\n        \n        # Create if statement\n        if_stmt = ast.If(condition, [result_assign, break_stmt], [])\n        loop_body.append(if_stmt)\n        \n        # Create the for loop\n        for_loop = ast.For(\n            target=ast.Name(loop_var, ast.Store()),\n            iter=ast.Name(iterable_var, ast.Load()),\n            body=loop_body,\n            orelse=[]\n        )\n        self.statements.append(for_loop)\n        \n        # Return the result\n        res = ast.Name(result_var, ast.Load())\n        res_expl = self.explanation_param(self.display(res))\n        \n        # Create explanation showing the element that caused failure\n        if call.func.id == 'all':\n            expl = \"all(%s)\" % iterable_expl\n        else:\n            expl = \"any(%s)\" % iterable_expl\n            \n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n    \n    new_func, func_expl = self.visit(call.func)\n    arg_expls = []\n    new_args = []\n    new_kwargs = []\n    for arg in call.args:\n        res, expl = self.visit(arg)\n        new_args.append(res)\n        arg_expls.append(expl)\n    for keyword in call.keywords:\n        res, expl = self.visit(keyword.value)\n        new_kwargs.append(ast.keyword(keyword.arg, res))\n        if keyword.arg:\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        else:\n            arg_expls.append(\"**\" + expl)\n\n    expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n    new_call = ast.Call(new_func, new_args, new_kwargs)\n    res = self.assign(new_call)\n    res_expl = self.explanation_param(self.display(res))\n    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n    return res, outer_expl\n\ndef visit_Call_legacy(self, call):\n    \"\"\"\n    visit `ast.Call nodes on 3.4 and below`\n    \"\"\"\n    # Special handling for all() and any() built-in functions\n    if (isinstance(call.func, ast.Name) and \n        call.func.id in ('all', 'any') and \n        len(call.args) == 1 and \n        not call.keywords and \n        not call.starargs and \n        not call.kwargs):\n        \n        # Get the iterable argument\n        iterable_arg = call.args[0]\n        iterable_res, iterable_expl = self.visit(iterable_arg)\n        \n        # Create a temporary variable to hold the iterable\n        iterable_var = self.variable()\n        self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n        \n        # Create a result variable\n        result_var = self.variable()\n        \n        # Initialize result based on function (True for all(), False for any())\n        initial_value = ast.NameConstant(call.func.id == 'all')\n        self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n        \n        # Create loop variable\n        loop_var = self.variable()\n        \n        # Create the loop body\n        loop_body = []\n        \n        # Get the element and create explanation\n        element_var = self.variable()\n        element_assign = ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load()))\n        loop_body.append(element_assign)\n        \n        # Create condition check based on function type\n        if call.func.id == 'all':\n            # For all(), we check if element is falsy\n            condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n            result_value = ast.NameConstant(False)\n        else:  # any()\n            # For any(), we check if element is truthy  \n            condition = ast.Name(element_var, ast.Load())\n            result_value = ast.NameConstant(True)\n        \n        # Create assignment when condition is met\n        result_assign = ast.Assign([ast.Name(result_var, ast.Store())], result_value)\n        \n        # Create break statement\n        break_stmt = ast.Break()\n        \n        # Create if statement\n        if_stmt = ast.If(condition, [result_assign, break_stmt], [])\n        loop_body.append(if_stmt)\n        \n        # Create the for loop\n        for_loop = ast.For(\n            target=ast.Name(loop_var, ast.Store()),\n            iter=ast.Name(iterable_var, ast.Load()),\n            body=loop_body,\n            orelse=[]\n        )\n        self.statements.append(for_loop)\n        \n        # Return the result\n        res = ast.Name(result_var, ast.Load())\n        res_expl = self.explanation_param(self.display(res))\n        \n        # Create explanation showing the element that caused failure\n        if call.func.id == 'all':\n            expl = \"all(%s)\" % iterable_expl\n        else:\n            expl = \"any(%s)\" % iterable_expl\n            \n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n        \n    new_func, func_expl = self.visit(call.func)\n    arg_expls = []\n    new_args = []\n    new_kwargs = []\n    new_star = new_kwarg = None\n    for arg in call.args:\n        res, expl = self.visit(arg)\n        new_args.append(res)\n        arg_expls.append(expl)\n    for keyword in call.keywords:\n        res, expl = self.visit(keyword.value)\n        new_kwargs.append(ast.keyword(keyword.arg, res))\n        arg_expls.append(keyword.arg + \"=\" + expl)\n    if call.starargs:\n        new_star, expl = self.visit(call.starargs)\n        arg_expls.append(\"*\" + expl)\n    if call.kwargs:\n        new_kwarg, expl = self.visit(call.kwargs)\n        arg_expls.append(\"**\" + expl)\n    expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n    new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n    res = self.assign(new_call)\n    res_expl = self.explanation_param(self.display(res))\n    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n    return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n            self.statements.append(iter_assign)\n            \n            # Create a loop variable for iteration\n            loop_var = self.variable()\n            \n            # Create the for loop to check each element\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # Create the condition check inside the loop\n            if func_name == 'all':\n                # For all(), we want to find the first False element\n                test_condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n                result_value = ast.NameConstant(False)\n            else:  # any()\n                # For any(), we want to find the first True element  \n                test_condition = ast.Name(loop_var, ast.Load())\n                result_value = ast.NameConstant(True)\n            \n            # Create result variable\n            result_var = self.variable()\n            \n            # Initialize result to the default value\n            default_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_init = ast.Assign([ast.Name(result_var, ast.Store())], default_value)\n            self.statements.append(result_init)\n            \n            # Create the if statement inside the loop\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], result_value)\n            break_stmt = ast.Break()\n            if_body = [result_assign, break_stmt]\n            if_stmt = ast.If(test_condition, if_body, [])\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            res = ast.Name(result_var, ast.Load())\n            res_explanation = self.explanation_param(self.display(res))\n            \n            # Create explanation showing the element that caused the result\n            elem_expl = self.explanation_param(self.display(ast.Name(loop_var, ast.Load())))\n            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (res_explanation, res_explanation, func_name, elem_expl)\n            \n            return res, outer_expl\n        \n        # Original implementation for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            # Get the iterable argument\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable to get its explanation\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Create the unrolling logic\n            item_var = self.variable()\n            loop_var = self.variable()\n            \n            # For all(): result starts True, becomes False on first False item\n            # For any(): result starts False, becomes True on first True item\n            initial_value = call.func.id == 'all'\n            target_value = not initial_value\n            \n            # Initialize result\n            self.statements.append(ast.Assign(\n                [ast.Name(result_var, ast.Store())],\n                ast.NameConstant(initial_value)\n            ))\n            \n            # Create the loop\n            loop_target = ast.Name(item_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create loop body\n            # Get the item value and create assertion\n            item_res, item_expl = self.visit(ast.Name(item_var, ast.Load()))\n            \n            # Create condition check\n            if call.func.id == 'all':\n                # For all(): if not item, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), ast.Name(item_var, ast.Load()))\n                break_value = ast.NameConstant(False)\n            else:\n                # For any(): if item, set result to True and break\n                condition = ast.Name(item_var, ast.Load())\n                break_value = ast.NameConstant(True)\n            \n            # Create the if statement that sets result and breaks\n            if_body = [\n                ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n                ast.Break()\n            ]\n            \n            loop_body = [ast.If(condition, if_body, [])]\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result\n            res = ast.Name(result_var, ast.Load())\n            res_name = self.assign(res)\n            res_expl = self.explanation_param(self.display(res_name))\n            \n            # Create explanation showing the unrolled evaluation\n            func_expl = call.func.id\n            expl = \"%s(%s)\" % (func_expl, iterable_expl)\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(res_name, ast.Load()), outer_expl\n\n        # Original logic for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_keywords = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_keywords.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_keywords)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            # Get the iterable argument\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable to get its explanation\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Create the unrolling logic\n            item_var = self.variable()\n            loop_var = self.variable()\n            \n            # For all(): result starts True, becomes False on first False item\n            # For any(): result starts False, becomes True on first True item\n            initial_value = call.func.id == 'all'\n            target_value = not initial_value\n            \n            # Initialize result\n            self.statements.append(ast.Assign(\n                [ast.Name(result_var, ast.Store())],\n                ast.NameConstant(initial_value)\n            ))\n            \n            # Create the loop\n            loop_target = ast.Name(item_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create loop body\n            # Get the item value and create assertion\n            item_res, item_expl = self.visit(ast.Name(item_var, ast.Load()))\n            \n            # Create condition check\n            if call.func.id == 'all':\n                # For all(): if not item, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), ast.Name(item_var, ast.Load()))\n                break_value = ast.NameConstant(False)\n            else:\n                # For any(): if item, set result to True and break\n                condition = ast.Name(item_var, ast.Load())\n                break_value = ast.NameConstant(True)\n            \n            # Create the if statement that sets result and breaks\n            if_body = [\n                ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n                ast.Break()\n            ]\n            \n            loop_body = [ast.If(condition, if_body, [])]\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result\n            res = ast.Name(result_var, ast.Load())\n            res_name = self.assign(res)\n            res_expl = self.explanation_param(self.display(res_name))\n            \n            # Create explanation showing the unrolled evaluation\n            func_expl = call.func.id\n            expl = \"%s(%s)\" % (func_expl, iterable_expl)\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(res_name, ast.Load()), outer_expl\n\n        # Original logic for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its explanation\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # For all(), we start with True and look for False\n            # For any(), we start with False and look for True\n            initial_value = ast.NameConstant(func_name == 'all')\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Get the element value and create assertion\n            element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n            \n            # Create condition check\n            if func_name == 'all':\n                # For all(), break on first False\n                condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n                break_value = ast.NameConstant(False)\n            else:\n                # For any(), break on first True  \n                condition = ast.Name(loop_var, ast.Load())\n                break_value = ast.NameConstant(True)\n            \n            # Create if statement to break early and capture failing element\n            failing_element_var = self.variable()\n            if_body = [\n                ast.Assign([ast.Name(failing_element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n                ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n                ast.Break()\n            ]\n            \n            if_stmt = ast.If(condition, if_body, [])\n            loop_body.append(if_stmt)\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            \n            # Return the result\n            res = ast.Name(result_var, ast.Load())\n            res_var = self.assign(res)\n            res_expl = self.explanation_param(self.display(res_var))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return res_var, outer_expl\n        \n        # Original implementation for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_keywords = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_keywords.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_keywords)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n            self.statements.append(iter_assign)\n            \n            # Create loop variable\n            item_var = self.variable()\n            \n            # Create the loop body that evaluates each element\n            if func_name == 'all':\n                # For all(), we want to find the first False element\n                test_expr = ast.Name(item_var, ast.Load())\n                test_res = self.assign(test_expr)\n                test_expl = self.explanation_param(self.display(test_res))\n                \n                # Create assertion that fails on first False\n                fail_condition = ast.UnaryOp(ast.Not(), ast.Name(test_res, ast.Load()))\n                early_return = ast.Return(ast.NameConstant(False))\n                \n                fail_stmt = ast.If(\n                    fail_condition,\n                    [early_return],\n                    []\n                )\n                \n                loop_body = [\n                    ast.Assign([ast.Name(test_res, ast.Store())], test_expr),\n                    self.expl_stmts(test_expl),\n                    fail_stmt\n                ]\n            else:  # any()\n                # For any(), we want to find the first True element\n                test_expr = ast.Name(item_var, ast.Load())\n                test_res = self.assign(test_expr)\n                test_expl = self.explanation_param(self.display(test_res))\n                \n                # Create assertion that succeeds on first True\n                success_condition = ast.Name(test_res, ast.Load())\n                early_return = ast.Return(ast.NameConstant(True))\n                \n                success_stmt = ast.If(\n                    success_condition,\n                    [early_return],\n                    []\n                )\n                \n                loop_body = [\n                    ast.Assign([ast.Name(test_res, ast.Store())], test_expr),\n                    self.expl_stmts(test_expl),\n                    success_stmt\n                ]\n            \n            # Create the for loop\n            loop = ast.For(\n                ast.Name(item_var, ast.Store()),\n                ast.Name(iter_var, ast.Load()),\n                loop_body,\n                []\n            )\n            \n            self.statements.append(loop)\n            \n            # Return the appropriate default value\n            default_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_var = self.assign(default_value)\n            \n            # Create explanation\n            func_expl = func_name\n            arg_res, arg_expl = self.visit(iterable_arg)\n            expl = \"%s(%s)\" % (func_expl, arg_expl)\n            res_expl = self.explanation_param(self.display(result_var))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original implementation for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its explanation\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            iterable_assign = ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res)\n            self.statements.append(iterable_assign)\n            \n            # Create a loop to check each element\n            loop_var = self.variable()\n            element_var = self.variable()\n            result_var = self.variable()\n            \n            # Initialize result based on function type\n            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n            self.statements.append(result_assign)\n            \n            # Create the loop\n            loop_target = ast.Name(element_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the loop body\n            element_res, element_expl = self.visit(ast.Name(element_var, ast.Load()))\n            \n            # Create condition check\n            if func_name == 'all':\n                # For all(), break on first False\n                condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n                break_value = ast.NameConstant(False)\n            else:\n                # For any(), break on first True  \n                condition = ast.Name(element_var, ast.Load())\n                break_value = ast.NameConstant(True)\n            \n            # Create if statement to break early\n            break_assign = ast.Assign([ast.Name(result_var, ast.Store())], break_value)\n            break_stmt = ast.Break()\n            if_stmt = ast.If(condition, [break_assign, break_stmt], [])\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n            self.statements.append(for_loop)\n            \n            # Return the result\n            res = ast.Name(result_var, ast.Load())\n            res_name = self.assign(res)\n            res_expl = self.explanation_param(self.display(res_name))\n            \n            # Create explanation showing the function call\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return res_name, outer_expl\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_keywords = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_keywords.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_keywords)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its representation\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create a loop variable for iteration\n            loop_var = self.variable()\n            \n            # Create the result variable\n            result_var = self.variable()\n            \n            # Initialize result based on function type\n            if func_name == 'all':\n                init_value = ast.NameConstant(True)\n            else:  # any\n                init_value = ast.NameConstant(False)\n            \n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Visit the loop variable to create explanation\n            element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n            \n            # Create condition check\n            if func_name == 'all':\n                # For all(), check if element is False\n                condition = ast.UnaryOp(ast.Not(), element_res)\n                break_value = ast.NameConstant(False)\n            else:  # any\n                # For any(), check if element is True\n                condition = element_res\n                break_value = ast.NameConstant(True)\n            \n            # Create if statement for early termination\n            if_body = [\n                ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n                ast.Break()\n            ]\n            \n            loop_body.append(ast.If(condition, if_body, []))\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result\n            res = ast.Name(result_var, ast.Load())\n            res_var = self.assign(res)\n            res_expl = self.explanation_param(self.display(res_var))\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return res_var, outer_expl\n        \n        # Original visit_Call_35 logic for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            arg_expls.append(keyword.arg + \"=\" + expl)\n            new_args.append(ast.keyword(keyword.arg, res))\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, call.keywords)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its representation\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create a loop variable for iteration\n            loop_var = self.variable()\n            \n            # Create the result variable\n            result_var = self.variable()\n            \n            # Initialize result based on function type\n            if func_name == 'all':\n                init_value = ast.NameConstant(True)\n            else:  # any\n                init_value = ast.NameConstant(False)\n            \n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Visit the loop variable to create explanation\n            element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n            \n            # Create condition check\n            if func_name == 'all':\n                # For all(), check if element is False\n                condition = ast.UnaryOp(ast.Not(), element_res)\n                break_value = ast.NameConstant(False)\n            else:  # any\n                # For any(), check if element is True\n                condition = element_res\n                break_value = ast.NameConstant(True)\n            \n            # Create if statement for early termination\n            if_body = [\n                ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n                ast.Break()\n            ]\n            \n            loop_body.append(ast.If(condition, if_body, []))\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result\n            res = ast.Name(result_var, ast.Load())\n            res_var = self.assign(res)\n            res_expl = self.explanation_param(self.display(res_var))\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return res_var, outer_expl\n        \n        # Original visit_Call_legacy logic for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..ae2f45807 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,65 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its AST representation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.assign(iterable_res)\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the loop body that evaluates each element\n+            element_node = ast.Name(loop_var, ast.Load())\n+            element_res, element_expl = self.visit(element_node)\n+            \n+            # For all(), we want to find the first False element\n+            # For any(), we want to find the first True element\n+            if func_name == 'all':\n+                # Create: for loop_var in iterable_var: assert loop_var\n+                test_node = element_node\n+                expected_result = True\n+            else:  # any()\n+                # Create: for loop_var in iterable_var: if loop_var: return True\n+                test_node = element_node  \n+                expected_result = True\n+            \n+            # Visit the test node to get proper assertion rewriting\n+            test_res, test_expl = self.visit(test_node)\n+            \n+            # Create the builtin function call for fallback\n+            builtin_name = ast.Attribute(\n+                ast.Name(\"@py_builtins\", ast.Load()),\n+                func_name,\n+                ast.Load()\n+            )\n+            new_call = ast.Call(builtin_name, [iterable_var], [])\n+            res = self.assign(new_call)\n+            \n+            # Create explanation that shows the iterable and hints at element checking\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (\n+                res_expl, res_expl, func_name, iterable_expl\n+            )\n+            \n+            return res, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1052,67 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and\n+            not call.starargs and\n+            not call.kwargs):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its AST representation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.assign(iterable_res)\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the loop body that evaluates each element\n+            element_node = ast.Name(loop_var, ast.Load())\n+            element_res, element_expl = self.visit(element_node)\n+            \n+            # For all(), we want to find the first False element\n+            # For any(), we want to find the first True element\n+            if func_name == 'all':\n+                # Create: for loop_var in iterable_var: assert loop_var\n+                test_node = element_node\n+                expected_result = True\n+            else:  # any()\n+                # Create: for loop_var in iterable_var: if loop_var: return True\n+                test_node = element_node  \n+                expected_result = True\n+            \n+            # Visit the test node to get proper assertion rewriting\n+            test_res, test_expl = self.visit(test_node)\n+            \n+            # Create the builtin function call for fallback\n+            builtin_name = ast.Attribute(\n+                ast.Name(\"@py_builtins\", ast.Load()),\n+                func_name,\n+                ast.Load()\n+            )\n+            new_call = ast.Call(builtin_name, [iterable_var], [], None, None)\n+            res = self.assign(new_call)\n+            \n+            # Create explanation that shows the iterable and hints at element checking\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (\n+                res_expl, res_expl, func_name, iterable_expl\n+            )\n+            \n+            return res, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_0": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..ef04ce03b 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,73 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its expression\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.assign(iterable_expr)\n+            \n+            # Create variables for the loop\n+            loop_var = self.variable()\n+            result_var = self.variable()\n+            \n+            # Initialize result variable (True for all(), False for any())\n+            init_value = ast.NameConstant(value=(func_name == 'all'))\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the loop body\n+            element_expr = ast.Name(loop_var, ast.Load())\n+            element_var = self.assign(element_expr)\n+            \n+            # Create condition check\n+            if func_name == 'all':\n+                # For all(): if not element, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n+                result_value = ast.NameConstant(value=False)\n+            else:\n+                # For any(): if element, set result to True and break\n+                condition = ast.Name(element_var, ast.Load())\n+                result_value = ast.NameConstant(value=True)\n+            \n+            # Create the if statement inside the loop\n+            if_body = [\n+                ast.Assign([ast.Name(result_var, ast.Store())], result_value),\n+                ast.Break()\n+            ]\n+            if_stmt = ast.If(condition, if_body, [])\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            res_var = self.assign(res)\n+            res_expl = self.explanation_param(self.display(res_var))\n+            \n+            # Create explanation showing the expansion\n+            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (res_expl, res_expl, func_name, iterable_expl)\n+            return res_var, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1060,96 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its representation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Create the unrolling logic\n+            element_var = self.variable()\n+            \n+            # For all(): start with True, set to False on first False element\n+            # For any(): start with False, set to True on first True element\n+            initial_value = ast.Constant(func_name == 'all')\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create the loop\n+            loop_target = ast.Name(element_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the condition check inside the loop\n+            element_res, element_expl = self.visit(ast.Name(element_var, ast.Load()))\n+            \n+            # Create assertion for the element\n+            if func_name == 'all':\n+                # For all(), we want to assert each element is True\n+                assertion_test = element_res\n+                break_condition = ast.UnaryOp(ast.Not(), element_res)\n+            else:\n+                # For any(), we want to assert at least one element is True\n+                assertion_test = element_res\n+                break_condition = element_res\n+            \n+            # Create the assertion statement\n+            assertion = ast.Assert(assertion_test, None)\n+            \n+            # Create break statement\n+            break_stmt = ast.Break()\n+            \n+            # Create if statement for breaking\n+            if_break = ast.If(break_condition, [\n+                ast.Assign([ast.Name(result_var, ast.Store())], \n+                          ast.Constant(func_name == 'any')),\n+                break_stmt\n+            ], [])\n+            \n+            # Create the loop body\n+            loop_body = [assertion, if_break]\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result\n+            return ast.Name(result_var, ast.Load()), f\"{func_name}({iterable_expl})\"\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n-        new_star = new_kwarg = None\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n             new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n-            arg_expls.append(\"**\" + expl)\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **args\n+                arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n",
    "variant_1": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..0d5b42b21 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,91 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its expression\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Get the current element\n+            element_expr = ast.Name(loop_var, ast.Load())\n+            element_var = self.variable()\n+            loop_body.append(ast.Assign([ast.Name(element_var, ast.Store())], element_expr))\n+            \n+            # Create condition check with detailed explanation\n+            element_res, element_expl = self.visit(element_expr)\n+            condition_var = self.variable()\n+            \n+            # For all(): if element is False, set result to False and break\n+            # For any(): if element is True, set result to True and break\n+            if func_name == 'all':\n+                # Check if element is falsy\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n+                loop_body.append(ast.Assign([ast.Name(condition_var, ast.Store())], condition))\n+                \n+                # If condition is true (element is falsy), update result and break\n+                if_body = [\n+                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                    ast.Break()\n+                ]\n+            else:  # any()\n+                # Check if element is truthy\n+                condition = ast.Name(element_var, ast.Load())\n+                loop_body.append(ast.Assign([ast.Name(condition_var, ast.Store())], condition))\n+                \n+                # If condition is true (element is truthy), update result and break\n+                if_body = [\n+                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                    ast.Break()\n+                ]\n+            \n+            loop_body.append(ast.If(ast.Name(condition_var, ast.Load()), if_body, []))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iterable_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            \n+            self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original generic call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1078,81 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create loop variable\n+            item_var = self.variable()\n+            \n+            # Create the loop body that checks each element\n+            # For all(): stop at first False, for any(): stop at first True\n+            target_value = func_name == 'any'  # True for any(), False for all()\n+            \n+            # Create the test expression for each item\n+            test_expr = ast.Name(item_var, ast.Load())\n+            \n+            # Visit the test to get proper assertion rewriting\n+            test_res, test_expl = self.visit(test_expr)\n+            \n+            # Create condition: item for any(), not item for all()\n+            if func_name == 'all':\n+                condition = ast.UnaryOp(ast.Not(), test_res)\n+                condition_expl = \"not \" + test_expl\n+            else:\n+                condition = test_res\n+                condition_expl = test_expl\n+            \n+            # Create early return for the failing case\n+            return_value = ast.NameConstant(not target_value)\n+            early_return = ast.If(\n+                condition,\n+                [ast.Return(return_value)],\n+                []\n+            )\n+            \n+            # Create the for loop\n+            loop_body = [early_return]\n+            for_loop = ast.For(\n+                ast.Name(item_var, ast.Store()),\n+                ast.Name(iter_var, ast.Load()),\n+                loop_body,\n+                []\n+            )\n+            \n+            self.statements.append(for_loop)\n+            \n+            # If we get here, all() succeeded (all True) or any() failed (all False)\n+            final_result = ast.NameConstant(target_value)\n+            result_var = self.assign(final_result)\n+            \n+            # Create explanation\n+            func_expl = func_name\n+            iter_expl = self.explanation_param(self.display(ast.Name(iter_var, ast.Load())))\n+            expl = \"%s(%s)\" % (func_expl, iter_expl)\n+            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original implementation for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_2": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..1d5339421 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,84 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            iterable_var = self.assign(iterable_res)\n+            \n+            # Create the unrolled evaluation\n+            # For all(): check each element until we find False\n+            # For any(): check each element until we find True\n+            target_value = func_name == 'any'  # True for any(), False for all()\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the comprehension that will be unrolled\n+            if func_name == 'all':\n+                # Generate: for item in iterable: if not item: return False\n+                loop_body = []\n+                item_var = self.variable()\n+                loop_body.append(ast.Assign([ast.Name(item_var, ast.Store())], \n+                                          ast.Name(loop_var, ast.Load())))\n+                \n+                # Evaluate the item\n+                item_eval = self.assign(ast.Name(item_var, ast.Load()))\n+                item_expl = self.explanation_param(self.display(item_eval))\n+                \n+                # Create the negation for all()\n+                negated = ast.UnaryOp(ast.Not(), ast.Name(item_eval, ast.Load()))\n+                negated_res = self.assign(negated)\n+                \n+                # Create the detailed explanation\n+                explanation = f\"where False = {func_name}({iterable_expl})\"\n+                detailed_expl = f\"{item_expl} is False\"\n+                \n+                # Return the result with detailed explanation\n+                result_var = self.variable()\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], \n+                                                ast.NameConstant(False)))\n+                \n+                outer_expl = f\"assert {explanation}\\n{{{detailed_expl}}}\"\n+                return ast.Name(result_var, ast.Load()), outer_expl\n+            \n+            else:  # any()\n+                # Similar logic for any() but looking for True values\n+                loop_body = []\n+                item_var = self.variable()\n+                loop_body.append(ast.Assign([ast.Name(item_var, ast.Store())], \n+                                          ast.Name(loop_var, ast.Load())))\n+                \n+                # Evaluate the item\n+                item_eval = self.assign(ast.Name(item_var, ast.Load()))\n+                item_expl = self.explanation_param(self.display(item_eval))\n+                \n+                # Create the detailed explanation\n+                explanation = f\"where False = {func_name}({iterable_expl})\"\n+                detailed_expl = f\"{item_expl} is True\"\n+                \n+                # Return the result with detailed explanation\n+                result_var = self.variable()\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], \n+                                                ast.NameConstant(False)))\n+                \n+                outer_expl = f\"assert {explanation}\\n{{{detailed_expl}}}\"\n+                return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Default behavior for all other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,35 +1071,213 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n-        \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n-        \"\"\"\n-        new_func, func_expl = self.visit(call.func)\n-        arg_expls = []\n-        new_args = []\n-        new_kwargs = []\n-        new_star = new_kwarg = None\n-        for arg in call.args:\n-            res, expl = self.visit(arg)\n-            new_args.append(res)\n-            arg_expls.append(expl)\n-        for keyword in call.keywords:\n-            res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n+\n+def visit_Call_35(self, call):\n+    \"\"\"\n+    visit `ast.Call` nodes on Python 3.5+\n+    \"\"\"\n+    # Special handling for all() and any() built-in functions\n+    if (isinstance(call.func, ast.Name) and \n+        call.func.id in ('all', 'any') and \n+        len(call.args) == 1 and \n+        not call.keywords):\n+        \n+        # Get the iterable argument\n+        iterable_arg = call.args[0]\n+        iterable_res, iterable_expl = self.visit(iterable_arg)\n+        \n+        # Create a temporary variable to hold the iterable\n+        iterable_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+        \n+        # Create a result variable\n+        result_var = self.variable()\n+        \n+        # Initialize result based on function (True for all(), False for any())\n+        initial_value = ast.NameConstant(call.func.id == 'all')\n+        self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+        \n+        # Create loop variable\n+        loop_var = self.variable()\n+        \n+        # Create the loop body\n+        loop_body = []\n+        \n+        # Get the element and create explanation\n+        element_var = self.variable()\n+        element_assign = ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load()))\n+        loop_body.append(element_assign)\n+        \n+        # Create condition check based on function type\n+        if call.func.id == 'all':\n+            # For all(), we check if element is falsy\n+            condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n+            result_value = ast.NameConstant(False)\n+        else:  # any()\n+            # For any(), we check if element is truthy  \n+            condition = ast.Name(element_var, ast.Load())\n+            result_value = ast.NameConstant(True)\n+        \n+        # Create assignment when condition is met\n+        result_assign = ast.Assign([ast.Name(result_var, ast.Store())], result_value)\n+        \n+        # Create break statement\n+        break_stmt = ast.Break()\n+        \n+        # Create if statement\n+        if_stmt = ast.If(condition, [result_assign, break_stmt], [])\n+        loop_body.append(if_stmt)\n+        \n+        # Create the for loop\n+        for_loop = ast.For(\n+            target=ast.Name(loop_var, ast.Store()),\n+            iter=ast.Name(iterable_var, ast.Load()),\n+            body=loop_body,\n+            orelse=[]\n+        )\n+        self.statements.append(for_loop)\n+        \n+        # Return the result\n+        res = ast.Name(result_var, ast.Load())\n+        res_expl = self.explanation_param(self.display(res))\n+        \n+        # Create explanation showing the element that caused failure\n+        if call.func.id == 'all':\n+            expl = \"all(%s)\" % iterable_expl\n+        else:\n+            expl = \"any(%s)\" % iterable_expl\n+            \n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n+    \n+    new_func, func_expl = self.visit(call.func)\n+    arg_expls = []\n+    new_args = []\n+    new_kwargs = []\n+    for arg in call.args:\n+        res, expl = self.visit(arg)\n+        new_args.append(res)\n+        arg_expls.append(expl)\n+    for keyword in call.keywords:\n+        res, expl = self.visit(keyword.value)\n+        new_kwargs.append(ast.keyword(keyword.arg, res))\n+        if keyword.arg:\n             arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n+        else:\n             arg_expls.append(\"**\" + expl)\n-        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n-        res = self.assign(new_call)\n+\n+    expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+    new_call = ast.Call(new_func, new_args, new_kwargs)\n+    res = self.assign(new_call)\n+    res_expl = self.explanation_param(self.display(res))\n+    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+    return res, outer_expl\n+\n+def visit_Call_legacy(self, call):\n+    \"\"\"\n+    visit `ast.Call nodes on 3.4 and below`\n+    \"\"\"\n+    # Special handling for all() and any() built-in functions\n+    if (isinstance(call.func, ast.Name) and \n+        call.func.id in ('all', 'any') and \n+        len(call.args) == 1 and \n+        not call.keywords and \n+        not call.starargs and \n+        not call.kwargs):\n+        \n+        # Get the iterable argument\n+        iterable_arg = call.args[0]\n+        iterable_res, iterable_expl = self.visit(iterable_arg)\n+        \n+        # Create a temporary variable to hold the iterable\n+        iterable_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+        \n+        # Create a result variable\n+        result_var = self.variable()\n+        \n+        # Initialize result based on function (True for all(), False for any())\n+        initial_value = ast.NameConstant(call.func.id == 'all')\n+        self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+        \n+        # Create loop variable\n+        loop_var = self.variable()\n+        \n+        # Create the loop body\n+        loop_body = []\n+        \n+        # Get the element and create explanation\n+        element_var = self.variable()\n+        element_assign = ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load()))\n+        loop_body.append(element_assign)\n+        \n+        # Create condition check based on function type\n+        if call.func.id == 'all':\n+            # For all(), we check if element is falsy\n+            condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n+            result_value = ast.NameConstant(False)\n+        else:  # any()\n+            # For any(), we check if element is truthy  \n+            condition = ast.Name(element_var, ast.Load())\n+            result_value = ast.NameConstant(True)\n+        \n+        # Create assignment when condition is met\n+        result_assign = ast.Assign([ast.Name(result_var, ast.Store())], result_value)\n+        \n+        # Create break statement\n+        break_stmt = ast.Break()\n+        \n+        # Create if statement\n+        if_stmt = ast.If(condition, [result_assign, break_stmt], [])\n+        loop_body.append(if_stmt)\n+        \n+        # Create the for loop\n+        for_loop = ast.For(\n+            target=ast.Name(loop_var, ast.Store()),\n+            iter=ast.Name(iterable_var, ast.Load()),\n+            body=loop_body,\n+            orelse=[]\n+        )\n+        self.statements.append(for_loop)\n+        \n+        # Return the result\n+        res = ast.Name(result_var, ast.Load())\n         res_expl = self.explanation_param(self.display(res))\n+        \n+        # Create explanation showing the element that caused failure\n+        if call.func.id == 'all':\n+            expl = \"all(%s)\" % iterable_expl\n+        else:\n+            expl = \"any(%s)\" % iterable_expl\n+            \n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n         return res, outer_expl\n+        \n+    new_func, func_expl = self.visit(call.func)\n+    arg_expls = []\n+    new_args = []\n+    new_kwargs = []\n+    new_star = new_kwarg = None\n+    for arg in call.args:\n+        res, expl = self.visit(arg)\n+        new_args.append(res)\n+        arg_expls.append(expl)\n+    for keyword in call.keywords:\n+        res, expl = self.visit(keyword.value)\n+        new_kwargs.append(ast.keyword(keyword.arg, res))\n+        arg_expls.append(keyword.arg + \"=\" + expl)\n+    if call.starargs:\n+        new_star, expl = self.visit(call.starargs)\n+        arg_expls.append(\"*\" + expl)\n+    if call.kwargs:\n+        new_kwarg, expl = self.visit(call.kwargs)\n+        arg_expls.append(\"**\" + expl)\n+    expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+    new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+    res = self.assign(new_call)\n+    res_expl = self.explanation_param(self.display(res))\n+    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+    return res, outer_expl\n \n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n",
    "variant_3": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..027a5da1b 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,81 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its explanation\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            element_var = self.variable()\n+            \n+            # Create the loop to check each element\n+            loop_target = ast.Name(element_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the condition check for each element\n+            element_expr = ast.Name(element_var, ast.Load())\n+            element_res = self.assign(element_expr)\n+            \n+            # Create explanation for the element\n+            element_expl = self.explanation_param(self.display(element_res))\n+            \n+            if func_name == 'all':\n+                # For all(), we want to find the first False element\n+                test_condition = ast.UnaryOp(ast.Not(), element_expr)\n+                failure_message = \"False\"\n+            else:  # any()\n+                # For any(), we want to find the first True element  \n+                test_condition = element_expr\n+                failure_message = \"True\"\n+            \n+            # Create the loop body that breaks on failure\n+            loop_body = [\n+                ast.Assign([ast.Name(element_res, ast.Store())], element_expr),\n+                ast.If(\n+                    test=test_condition,\n+                    body=[ast.Break()],\n+                    orelse=[]\n+                )\n+            ]\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=loop_target,\n+                iter=loop_iter,\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            \n+            self.statements.append(for_loop)\n+            \n+            # Create the final result explanation\n+            final_result = self.assign(ast.NameConstant(func_name == 'any'))\n+            res_expl = self.explanation_param(self.display(final_result))\n+            \n+            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (\n+                res_expl, res_expl, func_name, iterable_expl\n+            )\n+            \n+            return final_result, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1068,73 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create a loop variable for iteration\n+            loop_var = self.variable()\n+            \n+            # Create the for loop to check each element\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # Create the condition check inside the loop\n+            if func_name == 'all':\n+                # For all(), we want to find the first False element\n+                test_condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n+                result_value = ast.NameConstant(False)\n+            else:  # any()\n+                # For any(), we want to find the first True element  \n+                test_condition = ast.Name(loop_var, ast.Load())\n+                result_value = ast.NameConstant(True)\n+            \n+            # Create result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result to the default value\n+            default_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_init = ast.Assign([ast.Name(result_var, ast.Store())], default_value)\n+            self.statements.append(result_init)\n+            \n+            # Create the if statement inside the loop\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], result_value)\n+            break_stmt = ast.Break()\n+            if_body = [result_assign, break_stmt]\n+            if_stmt = ast.If(test_condition, if_body, [])\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            res_explanation = self.explanation_param(self.display(res))\n+            \n+            # Create explanation showing the element that caused the result\n+            elem_expl = self.explanation_param(self.display(ast.Name(loop_var, ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (res_explanation, res_explanation, func_name, elem_expl)\n+            \n+            return res, outer_expl\n+        \n+        # Original implementation for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_4": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..516d18477 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,81 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-ins\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its expression\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n+            \n+            # Create a loop variable for iteration\n+            loop_var = self.variable()\n+            \n+            # Create result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create loop body\n+            loop_body = []\n+            \n+            # Visit the loop variable to create assertion-friendly expression\n+            element_expr, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n+            \n+            if func_name == 'all':\n+                # For all(): if not element, set result to False and break\n+                test_expr = ast.UnaryOp(ast.Not(), element_expr)\n+                condition_var = self.variable()\n+                loop_body.append(ast.Assign([ast.Name(condition_var, ast.Store())], test_expr))\n+                \n+                # If condition is true (element is false), set result and break\n+                if_body = [\n+                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                    ast.Break()\n+                ]\n+                loop_body.append(ast.If(ast.Name(condition_var, ast.Load()), if_body, []))\n+                \n+            else:  # any()\n+                # For any(): if element, set result to True and break\n+                condition_var = self.variable()\n+                loop_body.append(ast.Assign([ast.Name(condition_var, ast.Store())], element_expr))\n+                \n+                # If condition is true (element is true), set result and break\n+                if_body = [\n+                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                    ast.Break()\n+                ]\n+                loop_body.append(ast.If(ast.Name(condition_var, ast.Load()), if_body, []))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            return res, expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1068,190 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on 3.5+\n+        \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            # Get the iterable argument\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable to get its explanation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Create the unrolling logic\n+            item_var = self.variable()\n+            loop_var = self.variable()\n+            \n+            # For all(): result starts True, becomes False on first False item\n+            # For any(): result starts False, becomes True on first True item\n+            initial_value = call.func.id == 'all'\n+            target_value = not initial_value\n+            \n+            # Initialize result\n+            self.statements.append(ast.Assign(\n+                [ast.Name(result_var, ast.Store())],\n+                ast.NameConstant(initial_value)\n+            ))\n+            \n+            # Create the loop\n+            loop_target = ast.Name(item_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create loop body\n+            # Get the item value and create assertion\n+            item_res, item_expl = self.visit(ast.Name(item_var, ast.Load()))\n+            \n+            # Create condition check\n+            if call.func.id == 'all':\n+                # For all(): if not item, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(item_var, ast.Load()))\n+                break_value = ast.NameConstant(False)\n+            else:\n+                # For any(): if item, set result to True and break\n+                condition = ast.Name(item_var, ast.Load())\n+                break_value = ast.NameConstant(True)\n+            \n+            # Create the if statement that sets result and breaks\n+            if_body = [\n+                ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n+                ast.Break()\n+            ]\n+            \n+            loop_body = [ast.If(condition, if_body, [])]\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result\n+            res = ast.Name(result_var, ast.Load())\n+            res_name = self.assign(res)\n+            res_expl = self.explanation_param(self.display(res_name))\n+            \n+            # Create explanation showing the unrolled evaluation\n+            func_expl = call.func.id\n+            expl = \"%s(%s)\" % (func_expl, iterable_expl)\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(res_name, ast.Load()), outer_expl\n+\n+        # Original logic for non-all/any calls\n+        new_func, func_expl = self.visit(call.func)\n+        arg_expls = []\n+        new_args = []\n+        new_keywords = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            new_args.append(res)\n+            arg_expls.append(expl)\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            new_keywords.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:\n+                arg_expls.append(\"**\" + expl)\n+\n+        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+        new_call = ast.Call(new_func, new_args, new_keywords)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            # Get the iterable argument\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable to get its explanation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Create the unrolling logic\n+            item_var = self.variable()\n+            loop_var = self.variable()\n+            \n+            # For all(): result starts True, becomes False on first False item\n+            # For any(): result starts False, becomes True on first True item\n+            initial_value = call.func.id == 'all'\n+            target_value = not initial_value\n+            \n+            # Initialize result\n+            self.statements.append(ast.Assign(\n+                [ast.Name(result_var, ast.Store())],\n+                ast.NameConstant(initial_value)\n+            ))\n+            \n+            # Create the loop\n+            loop_target = ast.Name(item_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create loop body\n+            # Get the item value and create assertion\n+            item_res, item_expl = self.visit(ast.Name(item_var, ast.Load()))\n+            \n+            # Create condition check\n+            if call.func.id == 'all':\n+                # For all(): if not item, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(item_var, ast.Load()))\n+                break_value = ast.NameConstant(False)\n+            else:\n+                # For any(): if item, set result to True and break\n+                condition = ast.Name(item_var, ast.Load())\n+                break_value = ast.NameConstant(True)\n+            \n+            # Create the if statement that sets result and breaks\n+            if_body = [\n+                ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n+                ast.Break()\n+            ]\n+            \n+            loop_body = [ast.If(condition, if_body, [])]\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result\n+            res = ast.Name(result_var, ast.Load())\n+            res_name = self.assign(res)\n+            res_expl = self.explanation_param(self.display(res_name))\n+            \n+            # Create explanation showing the unrolled evaluation\n+            func_expl = call.func.id\n+            expl = \"%s(%s)\" % (func_expl, iterable_expl)\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(res_name, ast.Load()), outer_expl\n+\n+        # Original logic for non-all/any calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_5": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..533fdfe2b 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,89 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-ins\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iter_var = self.variable()\n+            iter_expr, iter_expl = self.visit(iterable_arg)\n+            self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iter_expr))\n+            \n+            # Create the loop variable\n+            item_var = self.variable()\n+            \n+            # Create the result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            if func_name == 'all':\n+                initial_value = ast.NameConstant(True)\n+                break_condition = ast.NameConstant(False)\n+            else:  # any\n+                initial_value = ast.NameConstant(False)\n+                break_condition = ast.NameConstant(True)\n+                \n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create the for loop\n+            loop_body = []\n+            \n+            # Evaluate the current item\n+            item_expr, item_expl = self.visit(ast.Name(item_var, ast.Load()))\n+            item_result_var = self.variable()\n+            loop_body.append(ast.Assign([ast.Name(item_result_var, ast.Store())], item_expr))\n+            \n+            # Create assertion for detailed failure info\n+            assertion_var = self.variable()\n+            assertion = ast.Assign([ast.Name(assertion_var, ast.Store())], ast.Name(item_result_var, ast.Load()))\n+            loop_body.append(assertion)\n+            \n+            # Add the assertion explanation\n+            explanation_var = self.variable()\n+            explanation_value = ast.Str(s=item_expl)\n+            loop_body.append(ast.Assign([ast.Name(explanation_var, ast.Store())], explanation_value))\n+            \n+            # Create conditional break logic\n+            if func_name == 'all':\n+                # For all(): if not item_result, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(item_result_var, ast.Load()))\n+            else:  # any\n+                # For any(): if item_result, set result to True and break\n+                condition = ast.Name(item_result_var, ast.Load())\n+                \n+            if_body = [\n+                ast.Assign([ast.Name(result_var, ast.Store())], break_condition),\n+                ast.Break()\n+            ]\n+            \n+            loop_body.append(ast.If(condition, if_body, []))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(item_var, ast.Store()),\n+                iter=ast.Name(iter_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            \n+            self.statements.append(for_loop)\n+            \n+            # Return the result\n+            res = ast.Name(result_var, ast.Load())\n+            expl = \"%s(%s)\" % (func_name, iter_expl)\n+            return res, expl\n+            \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1076,102 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its explanation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # For all(), we start with True and look for False\n+            # For any(), we start with False and look for True\n+            initial_value = ast.NameConstant(func_name == 'all')\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Get the element value and create assertion\n+            element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n+            \n+            # Create condition check\n+            if func_name == 'all':\n+                # For all(), break on first False\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n+                break_value = ast.NameConstant(False)\n+            else:\n+                # For any(), break on first True  \n+                condition = ast.Name(loop_var, ast.Load())\n+                break_value = ast.NameConstant(True)\n+            \n+            # Create if statement to break early and capture failing element\n+            failing_element_var = self.variable()\n+            if_body = [\n+                ast.Assign([ast.Name(failing_element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n+                ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n+                ast.Break()\n+            ]\n+            \n+            if_stmt = ast.If(condition, if_body, [])\n+            loop_body.append(if_stmt)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            \n+            # Return the result\n+            res = ast.Name(result_var, ast.Load())\n+            res_var = self.assign(res)\n+            res_expl = self.explanation_param(self.display(res_var))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return res_var, outer_expl\n+        \n+        # Original implementation for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n-        new_kwargs = []\n-        new_star = new_kwarg = None\n+        new_keywords = []\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n-            arg_expls.append(\"**\" + expl)\n+            new_keywords.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **args\n+                arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_keywords)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n",
    "variant_6": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..a1bdc9fc0 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,82 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its expression\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iter_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable_expr))\n+            \n+            # Create a loop variable for individual elements\n+            element_var = self.variable()\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create the loop to check each element\n+            loop_target = ast.Name(element_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # Create the condition check for each element\n+            element_expr = ast.Name(element_var, ast.Load())\n+            element_res, element_expl = self.visit(element_expr)\n+            \n+            # Create assertion for the element\n+            if func_name == 'all':\n+                # For all(), we want to assert each element is True\n+                test_condition = element_res\n+                break_condition = ast.UnaryOp(ast.Not(), element_res)\n+                result_on_break = ast.NameConstant(False)\n+            else:\n+                # For any(), we want to find the first True element\n+                test_condition = element_res\n+                break_condition = element_res\n+                result_on_break = ast.NameConstant(True)\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Add assertion for meaningful error reporting\n+            assertion = ast.Assert(test_condition, None)\n+            loop_body.append(assertion)\n+            \n+            # Add break condition\n+            break_stmt = ast.If(\n+                break_condition,\n+                [ast.Assign([ast.Name(result_var, ast.Store())], result_on_break),\n+                 ast.Break()],\n+                []\n+            )\n+            loop_body.append(break_stmt)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return res, outer_expl\n+        \n+        # Regular call processing for non-all/any functions\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1069,98 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create loop variable\n+            item_var = self.variable()\n+            \n+            # Create the loop body that evaluates each element\n+            if func_name == 'all':\n+                # For all(), we want to find the first False element\n+                test_expr = ast.Name(item_var, ast.Load())\n+                test_res = self.assign(test_expr)\n+                test_expl = self.explanation_param(self.display(test_res))\n+                \n+                # Create assertion that fails on first False\n+                fail_condition = ast.UnaryOp(ast.Not(), ast.Name(test_res, ast.Load()))\n+                early_return = ast.Return(ast.NameConstant(False))\n+                \n+                fail_stmt = ast.If(\n+                    fail_condition,\n+                    [early_return],\n+                    []\n+                )\n+                \n+                loop_body = [\n+                    ast.Assign([ast.Name(test_res, ast.Store())], test_expr),\n+                    self.expl_stmts(test_expl),\n+                    fail_stmt\n+                ]\n+            else:  # any()\n+                # For any(), we want to find the first True element\n+                test_expr = ast.Name(item_var, ast.Load())\n+                test_res = self.assign(test_expr)\n+                test_expl = self.explanation_param(self.display(test_res))\n+                \n+                # Create assertion that succeeds on first True\n+                success_condition = ast.Name(test_res, ast.Load())\n+                early_return = ast.Return(ast.NameConstant(True))\n+                \n+                success_stmt = ast.If(\n+                    success_condition,\n+                    [early_return],\n+                    []\n+                )\n+                \n+                loop_body = [\n+                    ast.Assign([ast.Name(test_res, ast.Store())], test_expr),\n+                    self.expl_stmts(test_expl),\n+                    success_stmt\n+                ]\n+            \n+            # Create the for loop\n+            loop = ast.For(\n+                ast.Name(item_var, ast.Store()),\n+                ast.Name(iter_var, ast.Load()),\n+                loop_body,\n+                []\n+            )\n+            \n+            self.statements.append(loop)\n+            \n+            # Return the appropriate default value\n+            default_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_var = self.assign(default_value)\n+            \n+            # Create explanation\n+            func_expl = func_name\n+            arg_res, arg_expl = self.visit(iterable_arg)\n+            expl = \"%s(%s)\" % (func_expl, arg_expl)\n+            res_expl = self.explanation_param(self.display(result_var))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original implementation for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_7": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..fab536808 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,80 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its expression\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Create the loop to evaluate each element\n+            loop_var = self.variable()\n+            element_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(element_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the condition check inside the loop\n+            element_expr = ast.Name(element_var, ast.Load())\n+            element_res, element_expl = self.visit(element_expr)\n+            \n+            # Create the condition based on function type\n+            if func_name == 'all':\n+                # For all(), we check if element is False and break\n+                condition = ast.UnaryOp(ast.Not(), element_res)\n+                break_value = ast.NameConstant(False)\n+            else:\n+                # For any(), we check if element is True and break\n+                condition = element_res\n+                break_value = ast.NameConstant(True)\n+            \n+            # Create the if statement inside the loop\n+            loop_body = [\n+                ast.If(\n+                    condition,\n+                    [\n+                        ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n+                        ast.Break()\n+                    ],\n+                    []\n+                )\n+            ]\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return res, outer_expl\n+        \n+        # Original implementation for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1067,92 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its explanation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            iterable_assign = ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res)\n+            self.statements.append(iterable_assign)\n+            \n+            # Create a loop to check each element\n+            loop_var = self.variable()\n+            element_var = self.variable()\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create the loop\n+            loop_target = ast.Name(element_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the loop body\n+            element_res, element_expl = self.visit(ast.Name(element_var, ast.Load()))\n+            \n+            # Create condition check\n+            if func_name == 'all':\n+                # For all(), break on first False\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n+                break_value = ast.NameConstant(False)\n+            else:\n+                # For any(), break on first True  \n+                condition = ast.Name(element_var, ast.Load())\n+                break_value = ast.NameConstant(True)\n+            \n+            # Create if statement to break early\n+            break_assign = ast.Assign([ast.Name(result_var, ast.Store())], break_value)\n+            break_stmt = ast.Break()\n+            if_stmt = ast.If(condition, [break_assign, break_stmt], [])\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result\n+            res = ast.Name(result_var, ast.Load())\n+            res_name = self.assign(res)\n+            res_expl = self.explanation_param(self.display(res_name))\n+            \n+            # Create explanation showing the function call\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return res_name, outer_expl\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n-        new_kwargs = []\n-        new_star = new_kwarg = None\n+        new_keywords = []\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n-            arg_expls.append(\"**\" + expl)\n+            new_keywords.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **args\n+                arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_keywords)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n",
    "variant_8": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..edf5bc8f9 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,83 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n+            \n+            # Create the result variable\n+            result_var = self.variable()\n+            \n+            # For all(), start with True and look for False\n+            # For any(), start with False and look for True\n+            initial_value = ast.NameConstant(func_name == 'all')\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Evaluate the current element\n+            element_expr, element_expl = ast.Name(loop_var, ast.Load()), loop_var\n+            element_result = self.assign(element_expr)\n+            element_result_expl = self.explanation_param(self.display(element_result))\n+            \n+            # Create condition based on function type\n+            if func_name == 'all':\n+                # For all(), if element is False, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(element_result, ast.Load()))\n+                assign_value = ast.NameConstant(False)\n+            else:  # any()\n+                # For any(), if element is True, set result to True and break\n+                condition = ast.Name(element_result, ast.Load())\n+                assign_value = ast.NameConstant(True)\n+            \n+            # Add assignment and break in if body\n+            if_body = [\n+                ast.Assign([ast.Name(result_var, ast.Store())], assign_value),\n+                ast.Break()\n+            ]\n+            \n+            loop_body.append(ast.If(condition, if_body, []))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result\n+            res = ast.Name(result_var, ast.Load())\n+            res_name = self.assign(res)\n+            res_expl = self.explanation_param(self.display(res_name))\n+            \n+            # Create explanation\n+            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (\n+                res_expl, res_expl, func_name, iterable_expl\n+            )\n+            \n+            return res_name, outer_expl\n+        \n+        # Default behavior for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1070,177 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on 3.5+\n+        \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its representation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a loop variable for iteration\n+            loop_var = self.variable()\n+            \n+            # Create the result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            if func_name == 'all':\n+                init_value = ast.NameConstant(True)\n+            else:  # any\n+                init_value = ast.NameConstant(False)\n+            \n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Visit the loop variable to create explanation\n+            element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n+            \n+            # Create condition check\n+            if func_name == 'all':\n+                # For all(), check if element is False\n+                condition = ast.UnaryOp(ast.Not(), element_res)\n+                break_value = ast.NameConstant(False)\n+            else:  # any\n+                # For any(), check if element is True\n+                condition = element_res\n+                break_value = ast.NameConstant(True)\n+            \n+            # Create if statement for early termination\n+            if_body = [\n+                ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n+                ast.Break()\n+            ]\n+            \n+            loop_body.append(ast.If(condition, if_body, []))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result\n+            res = ast.Name(result_var, ast.Load())\n+            res_var = self.assign(res)\n+            res_expl = self.explanation_param(self.display(res_var))\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return res_var, outer_expl\n+        \n+        # Original visit_Call_35 logic for non-all/any calls\n+        new_func, func_expl = self.visit(call.func)\n+        arg_expls = []\n+        new_args = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            arg_expls.append(expl)\n+            new_args.append(res)\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            arg_expls.append(keyword.arg + \"=\" + expl)\n+            new_args.append(ast.keyword(keyword.arg, res))\n+        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+        new_call = ast.Call(new_func, new_args, call.keywords)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its representation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a loop variable for iteration\n+            loop_var = self.variable()\n+            \n+            # Create the result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            if func_name == 'all':\n+                init_value = ast.NameConstant(True)\n+            else:  # any\n+                init_value = ast.NameConstant(False)\n+            \n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Visit the loop variable to create explanation\n+            element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n+            \n+            # Create condition check\n+            if func_name == 'all':\n+                # For all(), check if element is False\n+                condition = ast.UnaryOp(ast.Not(), element_res)\n+                break_value = ast.NameConstant(False)\n+            else:  # any\n+                # For any(), check if element is True\n+                condition = element_res\n+                break_value = ast.NameConstant(True)\n+            \n+            # Create if statement for early termination\n+            if_body = [\n+                ast.Assign([ast.Name(result_var, ast.Store())], break_value),\n+                ast.Break()\n+            ]\n+            \n+            loop_body.append(ast.If(condition, if_body, []))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result\n+            res = ast.Name(result_var, ast.Load())\n+            res_var = self.assign(res)\n+            res_expl = self.explanation_param(self.display(res_var))\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return res_var, outer_expl\n+        \n+        # Original visit_Call_legacy logic for non-all/any calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n"
  }
}