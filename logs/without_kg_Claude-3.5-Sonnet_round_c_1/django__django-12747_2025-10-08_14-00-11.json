{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/deletion.py lines 392-398)": "\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/deletion.py lines 445-445)": "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
    "Location 3 (/root/hy/projects_1/django/django/db/models/deletion.py lines 388-389)": "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
    "Location 4 (/root/hy/projects_1/django/django/db/models/deletion.py lines 425-429)": "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # fast deletes\n        for qs in self.fast_deletes:\n            count = qs._raw_delete(using=self.using)\n            if count:\n                deleted_counter[qs.model._meta.label] += count\n\n        # update fields\n        for model, instances_for_fieldvalues in self.field_updates.items():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                query = sql.UpdateQuery(model)\n                query.update_batch([obj.pk for obj in instances],\n                                   {field.name: value}, self.using)\n\n        # reverse instance collections\n        for instances in self.data.values():\n            instances.reverse()\n\n        # delete instances\n        for model, instances in self.data.items():\n            query = sql.DeleteQuery(model)\n            pk_list = [obj.pk for obj in instances]\n            count = query.delete_batch(pk_list, self.using)\n            deleted_counter[model._meta.label] += count\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/deletion.py lines 392-398)": [
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/deletion.py lines 445-445)": [
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the common case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error(self.using):\n                    count = sql.DeleteQuery(model).delete_batch(\n                        [instance.pk], self.using\n                    )\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n\n        with transaction.atomic(using=self.using, savepoint=False):\n            # send pre_delete signals\n            for model, obj in self.instances_with_model():\n                if not model._meta.auto_created:\n                    signals.pre_delete.send(\n                        sender=model, instance=obj, using=self.using\n                    )\n\n            # fast deletes\n            for qs in self.fast_deletes:\n                count = qs.delete()\n                if count:\n                    deleted_counter.update({qs.model._meta.label: count})\n\n            # update fields\n            for model, instances_for_fieldvalues in self.field_updates.items():\n                for (field, value), instances in instances_for_fieldvalues.items():\n                    query = sql.UpdateQuery(model)\n                    query.update_batch(\n                        [obj.pk for obj in instances], {field.name: value}, self.using\n                    )\n\n            # reverse instance collections\n            for instances in self.data.values():\n                instances.reverse()\n\n            # delete instances\n            for model, instances in self.data.items():\n                query = sql.DeleteQuery(model)\n                pk_list = [obj.pk for obj in instances]\n                count = query.delete_batch(pk_list, self.using)\n                if count:\n                    deleted_counter[model._meta.label] += count\n\n                if not model._meta.auto_created:\n                    for obj in instances:\n                        signals.post_delete.send(\n                            sender=model, instance=obj, using=self.using\n                        )\n\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/models/deletion.py lines 388-389)": [
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/models/deletion.py lines 425-429)": [
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        if not self.data:\n            return (0, {})\n\n        with transaction.atomic(using=self.using, savepoint=False):\n            # send pre_delete signals\n            for model, obj in self.instances_with_model():\n                if not model._meta.auto_created:\n                    signals.pre_delete.send(\n                        sender=model, instance=obj, using=self.using\n                    )\n\n            # fast deletes\n            for qs in self.fast_deletes:\n                count = qs._raw_delete(using=self.using)\n                deleted_counter[qs.model._meta.label] += count\n\n            # update fields\n            for model, instances_for_fieldvalues in self.field_updates.items():\n                for (field, value), instances in instances_for_fieldvalues.items():\n                    query = sql.UpdateQuery(model)\n                    query.update_batch([obj.pk for obj in instances],\n                                       {field.name: value}, self.using)\n\n            # reverse instance collections\n            for instances in self.data.values():\n                instances.reverse()\n\n            # delete instances\n            for model, instances in self.data.items():\n                query = sql.DeleteQuery(model)\n                pk_list = [obj.pk for obj in instances]\n                count = query.delete_batch(pk_list, self.using)\n                deleted_counter[model._meta.label] += count\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # fast deletes\n        for qs in self.fast_deletes:\n            count = qs._raw_delete(using=self.using)\n            deleted_counter[qs.model._meta.label] += count\n\n        # update fields\n        for model, instances_for_fieldvalues in self.field_updates.items():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                query = sql.UpdateQuery(model)\n                query.update_batch([obj.pk for obj in instances],\n                                   {field.name: value}, self.using)\n\n        # reverse instance collections\n        for instances in self.data.values():\n            instances.reverse()\n\n        # delete instances\n        for model, instances in self.data.items():\n            query = sql.DeleteQuery(model)\n            pk_list = [obj.pk for obj in instances]\n            count = query.delete_batch(pk_list, self.using)\n            deleted_counter[model._meta.label] += count\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # Optimize for the common case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            obj = list(instances)[0]\n            if self.can_fast_delete(obj):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([obj.pk], self.using)\n                if not model._meta.auto_created:\n                    signals.post_delete.send(\n                        sender=model, instance=obj, using=self.using\n                    )\n                return count, {model._meta.label: count}\n\n        with transaction.atomic(using=self.using, savepoint=False):\n            # send pre_delete signals\n            for model, obj in self.instances_with_model():\n                if not model._meta.auto_created:\n                    signals.pre_delete.send(\n                        sender=model, instance=obj, using=self.using\n                    )\n\n            # fast deletes\n            for qs in self.fast_deletes:\n                count = qs._raw_delete(using=self.using)\n                if count:\n                    deleted_counter[qs.model._meta.label] += count\n\n            # update fields\n            for model, instances_for_fieldvalues in self.field_updates.items():\n                for (field, value), instances in instances_for_fieldvalues.items():\n                    query = sql.UpdateQuery(model)\n                    query.update_batch([obj.pk for obj in instances],\n                                       {field.name: value}, self.using)\n\n            # reverse instance collections\n            for instances in self.data.values():\n                instances.reverse()\n\n            # delete instances\n            for model, instances in self.data.items():\n                query = sql.DeleteQuery(model)\n                pk_list = [obj.pk for obj in instances]\n                count = query.delete_batch(pk_list, self.using)\n                deleted_counter[model._meta.label] += count\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # delete instances\n        for model, instances in self.data.items():\n            query = sql.DeleteQuery(model)\n            pk_list = [obj.pk for obj in instances]\n            count = query.delete_batch(pk_list, self.using)\n            deleted_counter[model._meta.label] += count\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        if self.can_fast_delete(objs):\n            # fast deletes\n            for qs in self.fast_deletes:\n                count = qs._raw_delete(using=self.using)\n                if count:\n                    deleted_counter[qs.model._meta.label] = count\n                    return count, dict(deleted_counter)\n            for model, instances in self.data.items():\n                query = sql.DeleteQuery(model)\n                pk_list = [obj.pk for obj in instances]\n                count = query.delete_batch(pk_list, self.using)\n                deleted_counter[model._meta.label] = count\n                return count, dict(deleted_counter)\n        with transaction.atomic(using=self.using, savepoint=False):\n            # send pre_delete signals\n            for model, obj in self.instances_with_model():\n                if not model._meta.auto_created:\n                    signals.pre_delete.send(\n                        sender=model, instance=obj, using=self.using\n                    )\n\n            # fast deletes\n            for qs in self.fast_deletes:\n                count = qs._raw_delete(using=self.using)\n                deleted_counter[qs.model._meta.label] += count\n\n            # update fields\n            for model, instances_for_fieldvalues in self.field_updates.items():\n                for (field, value), instances in instances_for_fieldvalues.items():\n                    query = sql.UpdateQuery(model)\n                    query.update_batch([obj.pk for obj in instances],\n                                       {field.name: value}, self.using)\n\n            # reverse instance collections\n            for instances in self.data.values():\n                instances.reverse()\n\n            # delete instances\n            for model, instances in self.data.items():\n                query = sql.DeleteQuery(model)\n                pk_list = [obj.pk for obj in instances]\n                count = query.delete_batch(pk_list, self.using)\n                deleted_counter[model._meta.label] += count\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        # delete instances\n        for model, instances in self.data.items():\n            query = sql.DeleteQuery(model)\n            pk_list = [obj.pk for obj in instances]\n            count = query.delete_batch(pk_list, self.using)\n            deleted_counter[model._meta.label] += count\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        if not self.data:\n            return 0, {}\n\n        with transaction.atomic(using=self.using, savepoint=False):\n            # send pre_delete signals\n            for model, obj in self.instances_with_model():\n                if not model._meta.auto_created:\n                    signals.pre_delete.send(\n                        sender=model, instance=obj, using=self.using\n                    )\n\n            # fast deletes\n            for qs in self.fast_deletes:\n                count = qs._raw_delete(using=self.using)\n                if count:\n                    deleted_counter[qs.model._meta.label] += count\n\n            # update fields\n            for model, instances_for_fieldvalues in self.field_updates.items():\n                for (field, value), instances in instances_for_fieldvalues.items():\n                    query = sql.UpdateQuery(model)\n                    query.update_batch([obj.pk for obj in instances],\n                                       {field.name: value}, self.using)\n\n            # reverse instance collections\n            for instances in self.data.values():\n                instances.reverse()\n\n            # delete instances\n            for model, instances in self.data.items():\n                query = sql.DeleteQuery(model)\n                pk_list = [obj.pk for obj in instances]\n                count = query.delete_batch(pk_list, self.using)\n                deleted_counter[model._meta.label] += count\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Pre-populate counter with all models being processed to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n\n        if not self.data:\n            return\n\n        with transaction.atomic(using=self.using, savepoint=False):\n            # send pre_delete signals\n            for model, obj in self.instances_with_model():\n                if not model._meta.auto_created:\n                    signals.pre_delete.send(\n                        sender=model, instance=obj, using=self.using\n                    )\n\n            # fast deletes\n            for qs in self.fast_deletes:\n                count = qs._raw_delete(using=self.using)\n                deleted_counter[qs.model._meta.label] += count\n\n            # update fields\n            for model, instances_for_fieldvalues in self.field_updates.items():\n                for (field, value), instances in instances_for_fieldvalues.items():\n                    query = sql.UpdateQuery(model)\n                    query.update_batch([obj.pk for obj in instances],\n                                       {field.name: value}, self.using)\n\n            # reverse instance collections\n            for instances in self.data.values():\n                instances.reverse()\n\n            # delete instances\n            for model, instances in self.data.items():\n                query = sql.DeleteQuery(model)\n                pk_list = [obj.pk for obj in instances]\n                count = query.delete_batch(pk_list, self.using)\n                deleted_counter[model._meta.label] += count\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..f998f99aa4 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -385,10 +385,15 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n \n         # Optimize for the case with a single obj and no dependencies\n+\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n@@ -422,6 +427,7 @@ class Collector:\n                 instances.reverse()\n \n             # delete instances\n+\n             for model, instances in self.data.items():\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n@@ -442,4 +448,5 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+\n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_0": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..8cb213f3d1 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -385,8 +385,24 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -422,11 +438,36 @@ class Collector:\n                 instances.reverse()\n \n             # delete instances\n-            for model, instances in self.data.items():\n-                query = sql.DeleteQuery(model)\n-                pk_list = [obj.pk for obj in instances]\n-                count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # fast deletes\n+        for qs in self.fast_deletes:\n+            count = qs._raw_delete(using=self.using)\n+            if count:\n+                deleted_counter[qs.model._meta.label] += count\n+\n+        # update fields\n+        for model, instances_for_fieldvalues in self.field_updates.items():\n+            for (field, value), instances in instances_for_fieldvalues.items():\n+                query = sql.UpdateQuery(model)\n+                query.update_batch([obj.pk for obj in instances],\n+                                   {field.name: value}, self.using)\n+\n+        # reverse instance collections\n+        for instances in self.data.values():\n+            instances.reverse()\n+\n+        # delete instances\n+        for model, instances in self.data.items():\n+            query = sql.DeleteQuery(model)\n+            pk_list = [obj.pk for obj in instances]\n+            count = query.delete_batch(pk_list, self.using)\n+            deleted_counter[model._meta.label] += count\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +483,9 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n",
    "variant_1": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..a808bbe3ac 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -385,8 +385,29 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -397,6 +418,41 @@ class Collector:\n                 setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n+        with transaction.atomic(using=self.using, savepoint=False):\n+            # send pre_delete signals\n+            for model, obj in self.instances_with_model():\n+                if not model._meta.auto_created:\n+                    signals.pre_delete.send(\n+                        sender=model, instance=obj, using=self.using\n+                    )\n+\n+            # fast deletes\n+            for qs in self.fast_deletes:\n+                count = qs._raw_delete(using=self.using)\n+                deleted_counter[qs.model._meta.label] += count\n+\n+            # update fields\n+            for model, instances_for_fieldvalues in self.field_updates.items():\n+                for (field, value), instances in instances_for_fieldvalues.items():\n+                    query = sql.UpdateQuery(model)\n+                    query.update_batch([obj.pk for obj in instances],\n+                                       {field.name: value}, self.using)\n+\n+            # reverse instance collections\n+            for instances in self.data.values():\n+                instances.reverse()\n+\n+            # delete instances\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        if not self.data:\n+            return (0, {})\n+\n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n             for model, obj in self.instances_with_model():\n@@ -442,4 +498,9 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n",
    "variant_2": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..ac645a50cd 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -385,8 +385,42 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count}\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -422,11 +456,35 @@ class Collector:\n                 instances.reverse()\n \n             # delete instances\n-            for model, instances in self.data.items():\n-                query = sql.DeleteQuery(model)\n-                pk_list = [obj.pk for obj in instances]\n-                count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # fast deletes\n+        for qs in self.fast_deletes:\n+            count = qs._raw_delete(using=self.using)\n+            deleted_counter[qs.model._meta.label] += count\n+\n+        # update fields\n+        for model, instances_for_fieldvalues in self.field_updates.items():\n+            for (field, value), instances in instances_for_fieldvalues.items():\n+                query = sql.UpdateQuery(model)\n+                query.update_batch([obj.pk for obj in instances],\n+                                   {field.name: value}, self.using)\n+\n+        # reverse instance collections\n+        for instances in self.data.values():\n+            instances.reverse()\n+\n+        # delete instances\n+        for model, instances in self.data.items():\n+            query = sql.DeleteQuery(model)\n+            pk_list = [obj.pk for obj in instances]\n+            count = query.delete_batch(pk_list, self.using)\n+            deleted_counter[model._meta.label] += count\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +500,9 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n",
    "variant_3": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..f3168cdaa2 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -385,8 +385,20 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -422,6 +434,51 @@ class Collector:\n                 instances.reverse()\n \n             # delete instances\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the common case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            obj = list(instances)[0]\n+            if self.can_fast_delete(obj):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([obj.pk], self.using)\n+                if not model._meta.auto_created:\n+                    signals.post_delete.send(\n+                        sender=model, instance=obj, using=self.using\n+                    )\n+                return count, {model._meta.label: count}\n+\n+        with transaction.atomic(using=self.using, savepoint=False):\n+            # send pre_delete signals\n+            for model, obj in self.instances_with_model():\n+                if not model._meta.auto_created:\n+                    signals.pre_delete.send(\n+                        sender=model, instance=obj, using=self.using\n+                    )\n+\n+            # fast deletes\n+            for qs in self.fast_deletes:\n+                count = qs._raw_delete(using=self.using)\n+                if count:\n+                    deleted_counter[qs.model._meta.label] += count\n+\n+            # update fields\n+            for model, instances_for_fieldvalues in self.field_updates.items():\n+                for (field, value), instances in instances_for_fieldvalues.items():\n+                    query = sql.UpdateQuery(model)\n+                    query.update_batch([obj.pk for obj in instances],\n+                                       {field.name: value}, self.using)\n+\n+            # reverse instance collections\n+            for instances in self.data.values():\n+                instances.reverse()\n+\n+            # delete instances\n             for model, instances in self.data.items():\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n@@ -442,4 +499,9 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n",
    "variant_4": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..642971a049 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -385,8 +385,20 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -422,11 +434,85 @@ class Collector:\n                 instances.reverse()\n \n             # delete instances\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # delete instances\n+        for model, instances in self.data.items():\n+            query = sql.DeleteQuery(model)\n+            pk_list = [obj.pk for obj in instances]\n+            count = query.delete_batch(pk_list, self.using)\n+            deleted_counter[model._meta.label] += count\n+\n+                if not model._meta.auto_created:\n+                    for obj in instances:\n+                        signals.post_delete.send(\n+                            sender=model, instance=obj, using=self.using\n+                        )\n+\n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+            for (field, value), instances in instances_for_fieldvalues.items():\n+                for obj in instances:\n+                    setattr(obj, field.attname, value)\n+        for model, instances in self.data.items():\n+            for instance in instances:\n+                setattr(instance, model._meta.pk.attname, None)\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the common case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error(self.using):\n+                    count = sql.DeleteQuery(model).delete_batch(\n+                        [instance.pk], self.using\n+                    )\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count}\n+\n+        with transaction.atomic(using=self.using, savepoint=False):\n+            # send pre_delete signals\n+            for model, obj in self.instances_with_model():\n+                if not model._meta.auto_created:\n+                    signals.pre_delete.send(\n+                        sender=model, instance=obj, using=self.using\n+                    )\n+\n+            # fast deletes\n+            for qs in self.fast_deletes:\n+                count = qs.delete()\n+                if count:\n+                    deleted_counter.update({qs.model._meta.label: count})\n+\n+            # update fields\n+            for model, instances_for_fieldvalues in self.field_updates.items():\n+                for (field, value), instances in instances_for_fieldvalues.items():\n+                    query = sql.UpdateQuery(model)\n+                    query.update_batch(\n+                        [obj.pk for obj in instances], {field.name: value}, self.using\n+                    )\n+\n+            # reverse instance collections\n+            for instances in self.data.values():\n+                instances.reverse()\n+\n+            # delete instances\n             for model, instances in self.data.items():\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+                if count:\n+                    deleted_counter[model._meta.label] += count\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n",
    "variant_5": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..3ef2b86de0 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -385,8 +385,33 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -397,6 +422,51 @@ class Collector:\n                 setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n+        with transaction.atomic(using=self.using, savepoint=False):\n+            # send pre_delete signals\n+            for model, obj in self.instances_with_model():\n+                if not model._meta.auto_created:\n+                    signals.pre_delete.send(\n+                        sender=model, instance=obj, using=self.using\n+                    )\n+\n+            # fast deletes\n+            for qs in self.fast_deletes:\n+                count = qs._raw_delete(using=self.using)\n+                deleted_counter[qs.model._meta.label] += count\n+\n+            # update fields\n+            for model, instances_for_fieldvalues in self.field_updates.items():\n+                for (field, value), instances in instances_for_fieldvalues.items():\n+                    query = sql.UpdateQuery(model)\n+                    query.update_batch([obj.pk for obj in instances],\n+                                       {field.name: value}, self.using)\n+\n+            # reverse instance collections\n+            for instances in self.data.values():\n+                instances.reverse()\n+\n+            # delete instances\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        if self.can_fast_delete(objs):\n+            # fast deletes\n+            for qs in self.fast_deletes:\n+                count = qs._raw_delete(using=self.using)\n+                if count:\n+                    deleted_counter[qs.model._meta.label] = count\n+                    return count, dict(deleted_counter)\n+            for model, instances in self.data.items():\n+                query = sql.DeleteQuery(model)\n+                pk_list = [obj.pk for obj in instances]\n+                count = query.delete_batch(pk_list, self.using)\n+                deleted_counter[model._meta.label] = count\n+                return count, dict(deleted_counter)\n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n             for model, obj in self.instances_with_model():\n@@ -442,4 +512,9 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n",
    "variant_6": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..698c865910 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -381,12 +381,28 @@ class Collector:\n         for model, instances in self.data.items():\n             self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n \n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n         # if possible, bring the models in an order suitable for databases that\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -422,11 +438,19 @@ class Collector:\n                 instances.reverse()\n \n             # delete instances\n-            for model, instances in self.data.items():\n-                query = sql.DeleteQuery(model)\n-                pk_list = [obj.pk for obj in instances]\n-                count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # delete instances\n+        for model, instances in self.data.items():\n+            query = sql.DeleteQuery(model)\n+            pk_list = [obj.pk for obj in instances]\n+            count = query.delete_batch(pk_list, self.using)\n+            deleted_counter[model._meta.label] += count\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +466,9 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n",
    "variant_7": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..21d5631b0c 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -385,8 +385,38 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count}\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -422,6 +452,42 @@ class Collector:\n                 instances.reverse()\n \n             # delete instances\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        if not self.data:\n+            return 0, {}\n+\n+        with transaction.atomic(using=self.using, savepoint=False):\n+            # send pre_delete signals\n+            for model, obj in self.instances_with_model():\n+                if not model._meta.auto_created:\n+                    signals.pre_delete.send(\n+                        sender=model, instance=obj, using=self.using\n+                    )\n+\n+            # fast deletes\n+            for qs in self.fast_deletes:\n+                count = qs._raw_delete(using=self.using)\n+                if count:\n+                    deleted_counter[qs.model._meta.label] += count\n+\n+            # update fields\n+            for model, instances_for_fieldvalues in self.field_updates.items():\n+                for (field, value), instances in instances_for_fieldvalues.items():\n+                    query = sql.UpdateQuery(model)\n+                    query.update_batch([obj.pk for obj in instances],\n+                                       {field.name: value}, self.using)\n+\n+            # reverse instance collections\n+            for instances in self.data.values():\n+                instances.reverse()\n+\n+            # delete instances\n             for model, instances in self.data.items():\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n@@ -442,4 +508,9 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n",
    "variant_8": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..67059eb590 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -376,6 +376,16 @@ class Collector:\n                 return\n         self.data = {model: self.data[model] for model in sorted_models}\n \n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+\n     def delete(self):\n         # sort instance collections\n         for model, instances in self.data.items():\n@@ -387,6 +397,17 @@ class Collector:\n         self.sort()\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -397,6 +418,41 @@ class Collector:\n                 setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n+        with transaction.atomic(using=self.using, savepoint=False):\n+            # send pre_delete signals\n+            for model, obj in self.instances_with_model():\n+                if not model._meta.auto_created:\n+                    signals.pre_delete.send(\n+                        sender=model, instance=obj, using=self.using\n+                    )\n+\n+            # fast deletes\n+            for qs in self.fast_deletes:\n+                count = qs._raw_delete(using=self.using)\n+                deleted_counter[qs.model._meta.label] += count\n+\n+            # update fields\n+            for model, instances_for_fieldvalues in self.field_updates.items():\n+                for (field, value), instances in instances_for_fieldvalues.items():\n+                    query = sql.UpdateQuery(model)\n+                    query.update_batch([obj.pk for obj in instances],\n+                                       {field.name: value}, self.using)\n+\n+            # reverse instance collections\n+            for instances in self.data.values():\n+                instances.reverse()\n+\n+            # delete instances\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+\n+        if not self.data:\n+            return\n+\n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n             for model, obj in self.instances_with_model():\n@@ -442,4 +498,9 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        # number of objects deleted for each model label\n+        deleted_counter = Counter()\n+        # Pre-populate counter with all models being processed to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n"
  }
}