{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/sql/compiler.py lines 730-747)": "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC', already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        # Also skip if we're explicitly accessing the foreign key's _id field directly\n        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/sql/compiler.py lines 730-747)": [
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        # Also skip if we're explicitly accessing the foreign key's _id field.\n        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        # Also exclude cases where we're explicitly accessing a foreign key's _id field directly.\n        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        # Also skip if we're explicitly accessing the foreign key's _id field directly.\n        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..dec49a9c3e 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,11 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+        # Check if we're accessing the foreign key's _id field directly\n+        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n+        \n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n",
    "variant_0": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..724b4a512f 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,24 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+    def find_ordering_name(self, name, opts, alias=None, default_order='ASC', already_seen=None):\n+        \"\"\"\n+        Return the table alias (the name might be ambiguous, the alias will\n+        not be) and column name for ordering by the given 'name' parameter.\n+        The 'name' is of the form 'field1__field2__...__fieldN'.\n+        \"\"\"\n+        name, order = get_order_dir(name, default_order)\n+        descending = order == 'DESC'\n+        pieces = name.split(LOOKUP_SEP)\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        # Also skip if we're explicitly accessing the foreign key's _id field directly\n+        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -747,6 +764,8 @@ class SQLCompiler:\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n     def _setup_joins(self, pieces, opts, alias):\n         \"\"\"\n",
    "variant_1": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..3801c32d5a 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,13 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        # Also skip if we're explicitly accessing the foreign key's _id field.\n+        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n",
    "variant_2": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..44773daaf3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,12 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n",
    "variant_3": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..018ab215b1 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,13 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        # Also exclude cases where we're explicitly accessing a foreign key's _id field directly.\n+        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n",
    "variant_4": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..c0e74e361c 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,13 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        # Also skip if we're explicitly accessing the foreign key's _id field directly.\n+        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n",
    "variant_5": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..44773daaf3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,12 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n",
    "variant_6": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..44773daaf3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,12 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n",
    "variant_7": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..44773daaf3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,12 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n",
    "variant_8": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..44773daaf3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,12 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        accessing_fk_id_field = name.split(LOOKUP_SEP)[-1] == getattr(field, 'attname', None)\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not accessing_fk_id_field:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n"
  }
}