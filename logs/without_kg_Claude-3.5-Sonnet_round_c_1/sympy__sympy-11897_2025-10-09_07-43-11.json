{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/sympy/sympy/printing/latex.py lines 464-468)": "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Preserve negative exponent structure like pretty printer\n            # Only convert to fraction for simple cases like x^(-1)\n            if expr.exp == -1 and not expr.base.is_Mul:\n                # Simple cases like x^(-1) can still use fraction format\n                return self._print_Mul(expr)\n            else:\n                # Complex cases like exp(-x) should preserve structure\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n        else:\n",
    "Location 2 (/root/hy/projects_1/sympy/sympy/printing/latex.py lines 358-362)": "\n        from sympy.simplify import fraction\n        # Check if this is a simple negative power that was redirected from _print_Pow\n        # If so, avoid fraction() which changes structure\n        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n            # Handle as regular multiplication to preserve structure\n            numer, denom = expr, S.One\n        else:\n            numer, denom = fraction(expr, exact=True)\n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n",
    "Location 3 (/root/hy/projects_1/sympy/sympy/printing/latex.py lines 398-410)": "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            # Check if this is a structure-preserving case that shouldn't use fraction format\n            # Avoid fraction format if numer is 1 and original expr has negative powers\n            preserve_structure = (numer == S.One and \n                                any(arg.is_Pow and arg.exp.is_negative and arg.exp != -1 \n                                    for arg in expr.args if hasattr(arg, 'is_Pow')))\n            \n            if not preserve_structure:\n                snumer = convert(numer)\n                sdenom = convert(denom)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n",
    "Location 4 (/root/hy/projects_1/sympy/sympy/printing/pretty/pretty.py lines 1500-1502)": "\n        if e.is_Rational and e < 0:\n            # Only convert simple cases to fractions, preserve structure for complex expressions\n            if e == -1 and not b.is_Mul:\n                return prettyForm(\"1\")/self._print(b)\n            else:\n                # Preserve structure like exp(-x) rather than converting to 1/exp(x)\n                return self._print(b)**self._print(e)\n",
    "Location 5 (/root/hy/projects_1/sympy/sympy/printing/tests/test_latex.py lines 133-133)": "\ndef test_latex_symbols():\n    Gamma, lmbda, rho = symbols('Gamma lambda rho')\n    mass, volume = symbols('mass volume')\n    assert latex(Gamma + lmbda) == r\"\\Gamma + \\lambda\"\n    assert latex(Gamma * lmbda) == r\"\\Gamma \\lambda\"\n    assert latex(Symbol('q1')) == r\"q_{1}\"\n    assert latex(Symbol('q21')) == r\"q_{21}\"\n    assert latex(Symbol('epsilon0')) == r\"\\epsilon_{0}\"\n    assert latex(Symbol('omega1')) == r\"\\omega_{1}\"\n    assert latex(Symbol('91')) == r\"91\"\n    assert latex(Symbol('alpha_new')) == r\"\\alpha_{new}\"\n    assert latex(Symbol('C^orig')) == r\"C^{orig}\"\n    assert latex(Symbol('x^alpha')) == r\"x^{\\alpha}\"\n    assert latex(Symbol('beta^alpha')) == r\"\\beta^{\\alpha}\"\n    assert latex(Symbol('e^Alpha')) == r\"e^{A}\"\n    assert latex(Symbol('omega_alpha^beta')) == r\"\\omega_{\\alpha}^{\\beta}\"\n    assert latex(Symbol('omega') ** Symbol('beta')) == r\"\\omega^{\\beta}\"\n\n    assert latex(Symbol('Gamma^2')) == r\"\\Gamma^{2}\"\n    assert latex(Symbol('Gamma^2') + Symbol('Gamma^3')) == \\\n        r\"\\Gamma^{2} + \\Gamma^{3}\"\n    assert latex(Symbol('Gamma^2') * Symbol('Gamma^3')) == \\\n        r\"\\Gamma^{2} \\Gamma^{3}\"\n\n    assert latex(Symbol('x_a_b')) == r\"x_{a,b}\"\n    assert latex(Symbol('x_a^b')) == r\"x_{a}^{b}\"\n    assert latex(Symbol('x^a_b')) == r\"x^{a}_{b}\"\n    assert latex(Symbol('x^a^b')) == r\"x^{a^{b}}\"\n    assert latex(Symbol('x__a__b')) == r\"x_{a\\_\\_b}\"\n    assert latex(Symbol('x_a_b_c')) == r\"x_{a,b,c}\"\n    assert latex(Symbol('x_a^b^c')) == r\"x_{a}^{b^{c}}\"\n    assert latex(Symbol('alpha_')) == r\"\\alpha\"\n    assert latex(Symbol('beta_')) == r\"\\beta\"\n\n    # issue 5031\n    assert latex(Symbol('lam')) == r\"\\lambda\"\n\n    # issue 5047\n    assert latex(Symbol('starting_guess')) == r\"starting\\_guess\"\n\n    # issue 5053\n    assert latex(Symbol('fhiggs')) == r\"f_{higgs}\"\n\n    assert latex(Symbol('lamda')) == r\"\\lambda\"\n    assert latex(Symbol('Lamda')) == r\"\\Lambda\"\n    assert latex(Symbol('khi')) == r\"\\chi\"\n    assert latex(Symbol('Khi')) == r\"X\"\n    assert latex(Symbol('varepsilon')) == r\"\\varepsilon\"\n\n    assert latex(Symbol('\\\\')) == r\"\\\\\"\n    assert latex(Symbol('$')) == r\"\\$\"\n    assert latex(Symbol('%')) == r\"\\%\"\n    assert latex(Symbol('#')) == r\"\\#\"\n    assert latex(Symbol('&')) == r\"\\&\"\n    assert latex(Symbol('{')) == r\"\\{\"\n    assert latex(Symbol('}')) == r\"\\}\"\n\n    # issue 5586\n    assert latex(Symbol('preceq')) == r\"preceq\"\n    assert latex(Symbol('succeq')) == r\"succeq\"\n    assert latex(Symbol('mid')) == r\"mid\"\n    assert latex(Symbol('mho')) == r\"mho\"\n    assert latex(Symbol('nsubseteq')) == r\"nsubseteq\"\n    assert latex(Symbol('nsupseteq')) == r\"nsupseteq\"\n    assert latex(Symbol('nmid')) == r\"nmid\"\n    assert latex(Symbol('nparallel')) == r\"nparallel\"\n    assert latex(Symbol('supsetneq')) == r\"supsetneq\"\n    assert latex(Symbol('subsetneq')) == r\"subsetneq\"\n\n    assert latex(Symbol('omega1')) == r\"\\omega_{1}\"\n    assert latex(Symbol('Omega1')) == r\"\\Omega_{1}\"\n\n    assert latex(rho * mass / volume) == r\"\\frac{\\rho mass}{volume}\"\n\n    # issue 7117\n    assert latex(Symbol('beta_13_2')) == r\"\\beta_{13,2}\"\n\n    # issue 7631\n    assert latex(Symbol('Пси')) == r\"\\Пси\"\n\n    # issue 8292\n    assert latex(Symbol('c_c')) == r\"c_{c}\"\n    assert latex(Symbol('A_c')) == r\"A_{c}\"\n    assert latex(Symbol('c_A')) == r\"c_{A}\"\n    assert latex(Symbol('A_A')) == r\"A_{A}\"\n\n    # issue 8107\n    assert latex(Symbol('_A')) == r\"A\"\n\n\ndef test_latex_symbols_failing():\n    lam_01 = Symbol('lambda_01')\n    lam_02 = Symbol('lambda_02')\n    lam_03 = Symbol('lambda_03')\n    lam_10 = Symbol('lambda_10')\n    lam_11 = Symbol('lambda_11')\n    lam_12 = Symbol('lambda_12')\n    lam_20 = Symbol('lambda_20')\n    lam_21 = Symbol('lambda_21')\n    lam_22 = Symbol('lambda_22')\n\n    # fails because x.matches(Symbol('x_01')) returns {_: 01}\n    assert latex(lam_01, symbol_names={lam_01: \"\\\\lambda^{(0,1)}\"}) == \\\n        r\"\\lambda^{(0,1)}\"\n\n    # Test custom symbol names for boolean operators\n    x, y, z = symbols('x y z')\n    assert latex(x & y, symbol_names={x: \"x_i\", y: \"y_i\"}) == r\"x_i \\wedge y_i\"\n    assert latex(x & y & z, symbol_names={x: \"x_i\", y: \"y_i\", z: \"z_i\"}) == \\\n        r\"x_i \\wedge y_i \\wedge z_i\"\n    assert latex(x | y, symbol_names={x: \"x_i\", y: \"y_i\"}) == r\"x_i \\vee y_i\"\n    assert latex(x | y | z, symbol_names={x: \"x_i\", y: \"y_i\", z: \"z_i\"}) == \\\n        r\"x_i \\vee y_i \\vee z_i\"\n    assert latex((x & y) | z, symbol_names={x: \"x_i\", y: \"y_i\", z: \"z_i\"}) == \\\n        r\"z_i \\vee \\left(x_i \\wedge y_i\\right)\"\n    assert latex(Implies(x, y), symbol_names={x: \"x_i\", y: \"y_i\"}) == \\\n        r\"x_i \\Rightarrow y_i\"\n\n    p = Symbol('p', positive=True)\n    assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/sympy/sympy/printing/latex.py lines 464-468)": [
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Preserve negative exponent structure like pretty printer\n            # Only convert to fraction for simple cases like x^(-1)\n            if expr.exp == -1 and not expr.base.is_Mul:\n                # Simple cases like x^(-1) can still use fraction format\n                return self._print_Mul(expr)\n            else:\n                # Complex cases like exp(-x) should preserve structure\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n        else:\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Preserve negative exponent structure like pretty printer\n            # Only convert to fraction for simple cases like x^(-1)\n            if expr.exp == -1 and not expr.base.is_Mul:\n                # Simple cases like x^(-1) can still use fraction format\n                return self._print_Mul(expr)\n            else:\n                # Complex cases like exp(-x) should preserve structure\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n        else:\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Preserve negative exponent structure like pretty printer\n            # Only convert to fraction for simple cases like x^(-1)\n            if expr.exp == -1 and not expr.base.is_Mul:\n                # Simple cases like x^(-1) can still use fraction format\n                return self._print_Mul(expr)\n            else:\n                # Complex cases like exp(-x) should preserve structure\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n        else:\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Preserve negative exponent structure like pretty printer\n            # Only convert to fraction for simple cases like x^(-1)\n            if expr.exp == -1 and not expr.base.is_Mul:\n                # Simple cases like x^(-1) can still use fraction format\n                return self._print_Mul(expr)\n            else:\n                # Complex cases like exp(-x) should preserve structure\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n        else:\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Preserve negative exponent structure like pretty printer\n            # Only convert to fraction for simple cases like x^(-1)\n            if expr.exp == -1 and not expr.base.is_Mul:\n                # Simple cases like x^(-1) can still use fraction format\n                return self._print_Mul(expr)\n            else:\n                # Complex cases like exp(-x) should preserve structure\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n        else:\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Preserve negative exponent structure like pretty printer\n            # Only convert to fraction for simple cases like x^(-1)\n            if expr.exp == -1 and not expr.base.is_Mul:\n                # Simple cases like x^(-1) can still use fraction format\n                return self._print_Mul(expr)\n            else:\n                # Complex cases like exp(-x) should preserve structure\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n        else:\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Preserve negative exponent structure like pretty printer\n            # Only convert to fraction for simple cases like x^(-1)\n            if expr.exp == -1 and not expr.base.is_Mul:\n                # Simple cases like x^(-1) can still use fraction format\n                return self._print_Mul(expr)\n            else:\n                # Complex cases like exp(-x) should preserve structure\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n        else:\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Preserve negative exponent structure like pretty printer\n            # Only convert to fraction for simple cases like x^(-1)\n            if expr.exp == -1 and not expr.base.is_Mul:\n                # Simple cases like x^(-1) can still use fraction format\n                return self._print_Mul(expr)\n            else:\n                # Complex cases like exp(-x) should preserve structure\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n        else:\n"
    ],
    "Location 2 (/root/hy/projects_1/sympy/sympy/printing/latex.py lines 358-362)": [
      "\n        from sympy.simplify import fraction\n        # Check if this is a simple negative power that was redirected from _print_Pow\n        # If so, avoid fraction() which changes structure\n        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n            # Handle as regular multiplication to preserve structure\n            numer, denom = expr, S.One\n        else:\n            numer, denom = fraction(expr, exact=True)\n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n",
      "\nfrom sympy.simplify import fraction\n# Check if this is a simple negative power that was redirected from _print_Pow\n# If so, avoid fraction() which changes structure\nif (len(expr.args) == 1 and expr.args[0].is_Pow and \n    expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n    # Handle as regular multiplication to preserve structure\n    numer, denom = expr, S.One\nelse:\n    numer, denom = fraction(expr, exact=True)\nseparator = self._settings['mul_symbol_latex']\nnumbersep = self._settings['mul_symbol_latex_numbers']\n",
      "\n        from sympy.simplify import fraction\n        # Check if this is a simple negative power that was redirected from _print_Pow\n        # If so, avoid fraction() which changes structure\n        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n            # Handle as regular multiplication to preserve structure\n            numer, denom = expr, S.One\n        else:\n            numer, denom = fraction(expr, exact=True)\n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n",
      "\n        from sympy.simplify import fraction\n        # Check if this is a simple negative power that was redirected from _print_Pow\n        # If so, avoid fraction() which changes structure\n        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n            # Handle as regular multiplication to preserve structure\n            numer, denom = expr, S.One\n        else:\n            numer, denom = fraction(expr, exact=True)\n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n",
      "\n\n        from sympy.simplify import fraction\n        # Check if this is a simple negative power that was redirected from _print_Pow\n        # If so, avoid fraction() which changes structure\n        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n            # Handle as regular multiplication to preserve structure\n            numer, denom = expr, S.One\n        else:\n            numer, denom = fraction(expr, exact=True)\n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n",
      "\n        from sympy.simplify import fraction\n        # Check if this is a simple negative power that was redirected from _print_Pow\n        # If so, avoid fraction() which changes structure\n        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n            # Handle as regular multiplication to preserve structure\n            numer, denom = expr, S.One\n        else:\n            numer, denom = fraction(expr, exact=True)\n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n",
      "\n\n        from sympy.simplify import fraction\n        # Check if this is a simple negative power that was redirected from _print_Pow\n        # If so, avoid fraction() which changes structure\n        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n            # Handle as regular multiplication to preserve structure\n            numer, denom = expr, S.One\n        else:\n            numer, denom = fraction(expr, exact=True)\n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n",
      "\n        from sympy.simplify import fraction\n        # Check if this is a simple negative power that was redirected from _print_Pow\n        # If so, avoid fraction() which changes structure\n        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n            # Handle as regular multiplication to preserve structure\n            numer, denom = expr, S.One\n        else:\n            numer, denom = fraction(expr, exact=True)\n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n"
    ],
    "Location 3 (/root/hy/projects_1/sympy/sympy/printing/latex.py lines 398-410)": [
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            # Check if this fraction came from a negative power that should preserve structure\n            preserve_structure = False\n            if (numer == S.One and len(expr.args) == 1 and \n                expr.args[0].is_Pow and expr.args[0].exp.is_negative and \n                expr.args[0].exp != -1):\n                preserve_structure = True\n            \n            if not preserve_structure:\n                snumer = convert(numer)\n                sdenom = convert(denom)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            # Check if this is a structure-preserving case that shouldn't use fraction format\n            preserve_structure = (numer == S.One and \n                                any(arg.is_Pow and arg.exp.is_negative and arg.exp != -1 \n                                    for arg in expr.args if hasattr(arg, 'is_Pow')))\n            \n            if preserve_structure:\n                # Don't use fraction format for cases like exp(-x) that should preserve structure\n                tex += convert(expr)\n            else:\n                snumer = convert(numer)\n                sdenom = convert(denom)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            # Check if this is a structure-preserving case where we shouldn't use fractions\n            # This prevents destroying meaningful mathematical structure like exp(-x)\n            preserve_structure = (numer == S.One and \n                                any(arg.is_Pow and arg.exp.is_negative and arg.exp != -1 \n                                    for arg in expr.args if hasattr(arg, 'is_Pow')))\n            \n            if not preserve_structure:\n                snumer = convert(numer)\n                sdenom = convert(denom)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            # Check if this fraction came from a negative power that should preserve structure\n            preserve_structure = False\n            if (numer == S.One and len(expr.args) == 1 and expr.args[0].is_Pow and \n                expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n                preserve_structure = True\n            \n            if not preserve_structure:\n                snumer = convert(numer)\n                sdenom = convert(denom)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            # Check if this is a structure-preserving case that shouldn't use fraction format\n            preserve_structure = (numer == S.One and \n                                any(arg.is_Pow and arg.exp.is_negative and arg.exp != -1 \n                                    for arg in expr.args if arg.is_Pow))\n            \n            if preserve_structure:\n                # Don't use fraction format for cases like exp(-x) that should preserve structure\n                tex += convert(expr)\n            else:\n                snumer = convert(numer)\n                sdenom = convert(denom)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            # Check if this is a structure that should be preserved\n            # (e.g., expressions that were originally negative powers)\n            preserve_structure = False\n            if (numer == S.One and len(expr.args) >= 1):\n                # Check if any arg is a power with negative exponent that should preserve structure\n                for arg in expr.args:\n                    if (arg.is_Pow and arg.exp.is_negative and \n                        (arg.exp != -1 or arg.base.is_Add or arg.base.is_Mul)):\n                        preserve_structure = True\n                        break\n            \n            if preserve_structure:\n                # Don't use fraction formatting for structure-preserving cases\n                tex += convert(expr)\n            else:\n                snumer = convert(numer)\n                sdenom = convert(denom)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            # Check if this fraction comes from a negative power that should preserve structure\n            preserve_structure = False\n            if (numer == S.One and len(expr.args) == 1 and \n                expr.args[0].is_Pow and expr.args[0].exp.is_negative and \n                expr.args[0].exp != -1):\n                preserve_structure = True\n            \n            if not preserve_structure:\n                snumer = convert(numer)\n                sdenom = convert(denom)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            # Only apply fraction formatting if it doesn't destroy structure\n            # Check if this came from a negative power that should preserve structure\n            preserve_structure = (numer == S.One and \n                any(arg.is_Pow and arg.exp.is_negative and arg.exp != -1 \n                    for arg in expr.args if hasattr(arg, 'is_Pow')))\n            \n            if not preserve_structure:\n                snumer = convert(numer)\n                sdenom = convert(denom)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n"
    ],
    "Location 4 (/root/hy/projects_1/sympy/sympy/printing/pretty/pretty.py lines 1500-1502)": [
      "\n    def _print_Pow(self, power):\n        from sympy.simplify.simplify import fraction\n        b, e = power.as_base_exp()\n        if power.is_commutative:\n            if e is S.NegativeOne:\n                return prettyForm(\"1\")/self._print(b)\n            n, d = fraction(e)\n            if n is S.One and d.is_Atom and not e.is_Integer:\n                return self._print_nth_root(b, e)\n            if e.is_Rational and e < 0:\n                return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n\n        if b.is_Relational:\n            return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n\n        return self._print(b)**self._print(e)\n",
      "\n            if e.is_Rational and e < 0:\n                # Only convert to fraction for simple cases like x^(-1)\n                if e == -1 and not b.is_Mul:\n                    return prettyForm(\"1\")/self._print(b)\n                else:\n                    # Preserve structure for complex cases\n                    return self._print(b)**self._print(e)\n",
      "\n        if power.is_commutative:\n            if e is S.NegativeOne:\n                return prettyForm(\"1\")/self._print(b)\n            n, d = fraction(e)\n            if n is S.One and d.is_Atom and not e.is_Integer:\n                return self._print_nth_root(b, e)\n            if e.is_Rational and e < 0:\n                return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n",
      "\n    def _print_Pow(self, power):\n        from sympy.simplify.simplify import fraction\n        b, e = power.as_base_exp()\n        if power.is_commutative:\n            if e is S.NegativeOne:\n                return prettyForm(\"1\")/self._print(b)\n            n, d = fraction(e)\n            if n is S.One and d.is_Atom and not e.is_Integer:\n                return self._print_nth_root(b, e)\n            if e.is_Rational and e < 0:\n                return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n\n        if b.is_Relational:\n            return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n\n        return self._print(b)**self._print(e)\n",
      "\n        if e.is_Rational and e < 0:\n            return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n",
      "\n            if e.is_Rational and e < 0:\n                # Only convert to fraction for simple cases like x^(-1)\n                if e == -1 and not b.is_Mul:\n                    return prettyForm(\"1\")/self._print(b)\n                else:\n                    # Preserve structure for complex cases\n                    return self._print(b)**self._print(e)\n",
      "\n        if e.is_Rational and e < 0:\n            return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n",
      "\n        if e.is_Rational and e < 0:\n            # Only convert simple cases to fractions, preserve structure for complex expressions\n            if e == -1 and not b.is_Mul and not isinstance(b, (Function, Pow)):\n                return prettyForm(\"1\")/self._print(b)\n            else:\n                # Preserve structure like exp(-x) instead of converting to 1/exp(x)\n                return self._print(b)**self._print(e)\n"
    ],
    "Location 5 (/root/hy/projects_1/sympy/sympy/printing/tests/test_latex.py lines 133-133)": [
      "\n    p = Symbol('p', positive=True)\n    assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n",
      "\n    p = Symbol('p', positive=True)\n    assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n",
      "\n    p = Symbol('p', positive=True)\n    assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n",
      "\n    p = Symbol('p', positive=True)\n    assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n",
      "\n    p = Symbol('p', positive=True)\n    assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n",
      "\n    p = Symbol('p', positive=True)\n    assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n",
      "\n    p = Symbol('p', positive=True)\n    assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n",
      "\n    p = Symbol('p', positive=True)\n    assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..be8778a708 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,16 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n+\n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Check if this is a simple negative power that was redirected from _print_Pow\n+        # If so, avoid fraction() which changes structure\n+        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n+            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+            # Handle as regular multiplication to preserve structure\n+            numer, denom = expr, S.One\n+        else:\n+            numer, denom = fraction(expr, exact=True)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -395,19 +403,23 @@ def convert(expr):\n             # altered it when producing numer and denom\n             tex += convert(expr)\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n+\n+            # Only apply fraction formatting if it doesn't destroy structure\n+            if (denom != S.One and not (numer == S.One and \n+                any(arg.is_Pow and arg.exp.is_negative for arg in expr.args))):\n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n                 if self._needs_mul_brackets(numer, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n@@ -461,9 +473,17 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Preserve negative exponent structure like pretty printer\n+            # Only convert to fraction for simple cases like x^(-1)\n+            if expr.exp == -1 and not expr.base.is_Mul:\n+                # Simple cases like x^(-1) can still use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # Complex cases like exp(-x) should preserve structure\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n         else:\n             if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 99c30dc5c3..3776dc59e2 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1497,9 +1497,9 @@ def _print_Pow(self, power):\n             n, d = fraction(e)\n             if n is S.One and d.is_Atom and not e.is_Integer:\n                 return self._print_nth_root(b, e)\n+\n             if e.is_Rational and e < 0:\n                 return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n-\n         if b.is_Relational:\n             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n \ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..c336f749fe 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -130,6 +130,7 @@ def test_latex_basic():\n         r\"x_i \\Rightarrow y_i\"\n \n     p = Symbol('p', positive=True)\n+\n     assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n \n \n",
    "variant_0": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..5d2941545b 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -357,7 +357,14 @@ def _print_Mul(self, expr):\n             tex = \"\"\n \n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Check if this is a simple negative power that was redirected from _print_Pow\n+        # If so, avoid fraction() which changes structure\n+        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n+            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+            # Handle as regular multiplication to preserve structure\n+            numer, denom = expr, S.One\n+        else:\n+            numer, denom = fraction(expr, exact=True)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -395,19 +402,32 @@ def convert(expr):\n             # altered it when producing numer and denom\n             tex += convert(expr)\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n+\n+        if denom is S.One:\n+            # use the original expression here, since fraction() may have\n+            # altered it when producing numer and denom\n+            tex += convert(expr)\n+        else:\n+            # Check if this is a structure-preserving case that shouldn't use fraction format\n+            # Avoid fraction format if numer is 1 and original expr has negative powers\n+            preserve_structure = (numer == S.One and \n+                                any(arg.is_Pow and arg.exp.is_negative and arg.exp != -1 \n+                                    for arg in expr.args if hasattr(arg, 'is_Pow')))\n+            \n+            if not preserve_structure:\n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n                 if self._needs_mul_brackets(numer, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n@@ -461,11 +481,18 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Preserve negative exponent structure like pretty printer\n+            # Only convert to fraction for simple cases like x^(-1)\n+            if expr.exp == -1 and not expr.base.is_Mul:\n+                # Simple cases like x^(-1) can still use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # Complex cases like exp(-x) should preserve structure\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n         else:\n-            if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\n             else:\n                 if expr.is_commutative and expr.exp == -1:\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 99c30dc5c3..a4a4e89459 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1497,9 +1497,14 @@ def _print_Pow(self, power):\n             n, d = fraction(e)\n             if n is S.One and d.is_Atom and not e.is_Integer:\n                 return self._print_nth_root(b, e)\n-            if e.is_Rational and e < 0:\n-                return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n \n+        if e.is_Rational and e < 0:\n+            # Only convert simple cases to fractions, preserve structure for complex expressions\n+            if e == -1 and not b.is_Mul:\n+                return prettyForm(\"1\")/self._print(b)\n+            else:\n+                # Preserve structure like exp(-x) rather than converting to 1/exp(x)\n+                return self._print(b)**self._print(e)\n         if b.is_Relational:\n             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n \ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..62d6b8aabd 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -130,6 +130,126 @@ def test_latex_basic():\n         r\"x_i \\Rightarrow y_i\"\n \n     p = Symbol('p', positive=True)\n+\n+def test_latex_symbols():\n+    Gamma, lmbda, rho = symbols('Gamma lambda rho')\n+    mass, volume = symbols('mass volume')\n+    assert latex(Gamma + lmbda) == r\"\\Gamma + \\lambda\"\n+    assert latex(Gamma * lmbda) == r\"\\Gamma \\lambda\"\n+    assert latex(Symbol('q1')) == r\"q_{1}\"\n+    assert latex(Symbol('q21')) == r\"q_{21}\"\n+    assert latex(Symbol('epsilon0')) == r\"\\epsilon_{0}\"\n+    assert latex(Symbol('omega1')) == r\"\\omega_{1}\"\n+    assert latex(Symbol('91')) == r\"91\"\n+    assert latex(Symbol('alpha_new')) == r\"\\alpha_{new}\"\n+    assert latex(Symbol('C^orig')) == r\"C^{orig}\"\n+    assert latex(Symbol('x^alpha')) == r\"x^{\\alpha}\"\n+    assert latex(Symbol('beta^alpha')) == r\"\\beta^{\\alpha}\"\n+    assert latex(Symbol('e^Alpha')) == r\"e^{A}\"\n+    assert latex(Symbol('omega_alpha^beta')) == r\"\\omega_{\\alpha}^{\\beta}\"\n+    assert latex(Symbol('omega') ** Symbol('beta')) == r\"\\omega^{\\beta}\"\n+\n+    assert latex(Symbol('Gamma^2')) == r\"\\Gamma^{2}\"\n+    assert latex(Symbol('Gamma^2') + Symbol('Gamma^3')) == \\\n+        r\"\\Gamma^{2} + \\Gamma^{3}\"\n+    assert latex(Symbol('Gamma^2') * Symbol('Gamma^3')) == \\\n+        r\"\\Gamma^{2} \\Gamma^{3}\"\n+\n+    assert latex(Symbol('x_a_b')) == r\"x_{a,b}\"\n+    assert latex(Symbol('x_a^b')) == r\"x_{a}^{b}\"\n+    assert latex(Symbol('x^a_b')) == r\"x^{a}_{b}\"\n+    assert latex(Symbol('x^a^b')) == r\"x^{a^{b}}\"\n+    assert latex(Symbol('x__a__b')) == r\"x_{a\\_\\_b}\"\n+    assert latex(Symbol('x_a_b_c')) == r\"x_{a,b,c}\"\n+    assert latex(Symbol('x_a^b^c')) == r\"x_{a}^{b^{c}}\"\n+    assert latex(Symbol('alpha_')) == r\"\\alpha\"\n+    assert latex(Symbol('beta_')) == r\"\\beta\"\n+\n+    # issue 5031\n+    assert latex(Symbol('lam')) == r\"\\lambda\"\n+\n+    # issue 5047\n+    assert latex(Symbol('starting_guess')) == r\"starting\\_guess\"\n+\n+    # issue 5053\n+    assert latex(Symbol('fhiggs')) == r\"f_{higgs}\"\n+\n+    assert latex(Symbol('lamda')) == r\"\\lambda\"\n+    assert latex(Symbol('Lamda')) == r\"\\Lambda\"\n+    assert latex(Symbol('khi')) == r\"\\chi\"\n+    assert latex(Symbol('Khi')) == r\"X\"\n+    assert latex(Symbol('varepsilon')) == r\"\\varepsilon\"\n+\n+    assert latex(Symbol('\\\\')) == r\"\\\\\"\n+    assert latex(Symbol('$')) == r\"\\$\"\n+    assert latex(Symbol('%')) == r\"\\%\"\n+    assert latex(Symbol('#')) == r\"\\#\"\n+    assert latex(Symbol('&')) == r\"\\&\"\n+    assert latex(Symbol('{')) == r\"\\{\"\n+    assert latex(Symbol('}')) == r\"\\}\"\n+\n+    # issue 5586\n+    assert latex(Symbol('preceq')) == r\"preceq\"\n+    assert latex(Symbol('succeq')) == r\"succeq\"\n+    assert latex(Symbol('mid')) == r\"mid\"\n+    assert latex(Symbol('mho')) == r\"mho\"\n+    assert latex(Symbol('nsubseteq')) == r\"nsubseteq\"\n+    assert latex(Symbol('nsupseteq')) == r\"nsupseteq\"\n+    assert latex(Symbol('nmid')) == r\"nmid\"\n+    assert latex(Symbol('nparallel')) == r\"nparallel\"\n+    assert latex(Symbol('supsetneq')) == r\"supsetneq\"\n+    assert latex(Symbol('subsetneq')) == r\"subsetneq\"\n+\n+    assert latex(Symbol('omega1')) == r\"\\omega_{1}\"\n+    assert latex(Symbol('Omega1')) == r\"\\Omega_{1}\"\n+\n+    assert latex(rho * mass / volume) == r\"\\frac{\\rho mass}{volume}\"\n+\n+    # issue 7117\n+    assert latex(Symbol('beta_13_2')) == r\"\\beta_{13,2}\"\n+\n+    # issue 7631\n+    assert latex(Symbol('Пси')) == r\"\\Пси\"\n+\n+    # issue 8292\n+    assert latex(Symbol('c_c')) == r\"c_{c}\"\n+    assert latex(Symbol('A_c')) == r\"A_{c}\"\n+    assert latex(Symbol('c_A')) == r\"c_{A}\"\n+    assert latex(Symbol('A_A')) == r\"A_{A}\"\n+\n+    # issue 8107\n+    assert latex(Symbol('_A')) == r\"A\"\n+\n+\n+def test_latex_symbols_failing():\n+    lam_01 = Symbol('lambda_01')\n+    lam_02 = Symbol('lambda_02')\n+    lam_03 = Symbol('lambda_03')\n+    lam_10 = Symbol('lambda_10')\n+    lam_11 = Symbol('lambda_11')\n+    lam_12 = Symbol('lambda_12')\n+    lam_20 = Symbol('lambda_20')\n+    lam_21 = Symbol('lambda_21')\n+    lam_22 = Symbol('lambda_22')\n+\n+    # fails because x.matches(Symbol('x_01')) returns {_: 01}\n+    assert latex(lam_01, symbol_names={lam_01: \"\\\\lambda^{(0,1)}\"}) == \\\n+        r\"\\lambda^{(0,1)}\"\n+\n+    # Test custom symbol names for boolean operators\n+    x, y, z = symbols('x y z')\n+    assert latex(x & y, symbol_names={x: \"x_i\", y: \"y_i\"}) == r\"x_i \\wedge y_i\"\n+    assert latex(x & y & z, symbol_names={x: \"x_i\", y: \"y_i\", z: \"z_i\"}) == \\\n+        r\"x_i \\wedge y_i \\wedge z_i\"\n+    assert latex(x | y, symbol_names={x: \"x_i\", y: \"y_i\"}) == r\"x_i \\vee y_i\"\n+    assert latex(x | y | z, symbol_names={x: \"x_i\", y: \"y_i\", z: \"z_i\"}) == \\\n+        r\"x_i \\vee y_i \\vee z_i\"\n+    assert latex((x & y) | z, symbol_names={x: \"x_i\", y: \"y_i\", z: \"z_i\"}) == \\\n+        r\"z_i \\vee \\left(x_i \\wedge y_i\\right)\"\n+    assert latex(Implies(x, y), symbol_names={x: \"x_i\", y: \"y_i\"}) == \\\n+        r\"x_i \\Rightarrow y_i\"\n+\n+    p = Symbol('p', positive=True)\n     assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n \n \n",
    "variant_1": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..6a59809ba5 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -357,7 +357,14 @@ def _print_Mul(self, expr):\n             tex = \"\"\n \n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Check if this is a simple negative power that was redirected from _print_Pow\n+        # If so, avoid fraction() which changes structure\n+        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n+            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+            # Handle as regular multiplication to preserve structure\n+            numer, denom = expr, S.One\n+        else:\n+            numer, denom = fraction(expr, exact=True)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -395,19 +402,33 @@ def convert(expr):\n             # altered it when producing numer and denom\n             tex += convert(expr)\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n+\n+        if denom is S.One:\n+            # use the original expression here, since fraction() may have\n+            # altered it when producing numer and denom\n+            tex += convert(expr)\n+        else:\n+            # Check if this fraction came from a negative power that should preserve structure\n+            preserve_structure = False\n+            if (numer == S.One and len(expr.args) == 1 and \n+                expr.args[0].is_Pow and expr.args[0].exp.is_negative and \n+                expr.args[0].exp != -1):\n+                preserve_structure = True\n+            \n+            if not preserve_structure:\n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n                 if self._needs_mul_brackets(numer, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n@@ -461,11 +482,18 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Preserve negative exponent structure like pretty printer\n+            # Only convert to fraction for simple cases like x^(-1)\n+            if expr.exp == -1 and not expr.base.is_Mul:\n+                # Simple cases like x^(-1) can still use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # Complex cases like exp(-x) should preserve structure\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n         else:\n-            if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\n             else:\n                 if expr.is_commutative and expr.exp == -1:\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 99c30dc5c3..f2a63d6665 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1488,6 +1488,16 @@ def _print_nth_root(self, base, expt):\n         s = prettyForm(*s.left(rootsign))\n         return s\n \n+    def _print_Pow(self, power):\n+        from sympy.simplify.simplify import fraction\n+        b, e = power.as_base_exp()\n+        if power.is_commutative:\n+            if e is S.NegativeOne:\n+                return prettyForm(\"1\")/self._print(b)\n+            n, d = fraction(e)\n+            if n is S.One and d.is_Atom and not e.is_Integer:\n+                return self._print_nth_root(b, e)\n+\n     def _print_Pow(self, power):\n         from sympy.simplify.simplify import fraction\n         b, e = power.as_base_exp()\n@@ -1504,6 +1514,10 @@ def _print_Pow(self, power):\n             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n \n         return self._print(b)**self._print(e)\n+        if b.is_Relational:\n+            return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n+\n+        return self._print(b)**self._print(e)\n \n     def _print_UnevaluatedExpr(self, expr):\n         return self._print(expr.args[0])\ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..b4a7bb63c9 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -129,6 +129,8 @@ def test_latex_basic():\n     assert latex(Implies(x, y), symbol_names={x: \"x_i\", y: \"y_i\"}) == \\\n         r\"x_i \\Rightarrow y_i\"\n \n+    p = Symbol('p', positive=True)\n+\n     p = Symbol('p', positive=True)\n     assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n \n",
    "variant_2": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..7fe8cd187a 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,10 +356,17 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n-        separator = self._settings['mul_symbol_latex']\n-        numbersep = self._settings['mul_symbol_latex_numbers']\n+from sympy.simplify import fraction\n+# Check if this is a simple negative power that was redirected from _print_Pow\n+# If so, avoid fraction() which changes structure\n+if (len(expr.args) == 1 and expr.args[0].is_Pow and \n+    expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+    # Handle as regular multiplication to preserve structure\n+    numer, denom = expr, S.One\n+else:\n+    numer, denom = fraction(expr, exact=True)\n+separator = self._settings['mul_symbol_latex']\n+numbersep = self._settings['mul_symbol_latex_numbers']\n \n         def convert(expr):\n             if not expr.is_Mul:\n@@ -395,19 +402,34 @@ def convert(expr):\n             # altered it when producing numer and denom\n             tex += convert(expr)\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n+\n+        if denom is S.One:\n+            # use the original expression here, since fraction() may have\n+            # altered it when producing numer and denom\n+            tex += convert(expr)\n+        else:\n+            # Check if this is a structure-preserving case that shouldn't use fraction format\n+            preserve_structure = (numer == S.One and \n+                                any(arg.is_Pow and arg.exp.is_negative and arg.exp != -1 \n+                                    for arg in expr.args if hasattr(arg, 'is_Pow')))\n+            \n+            if preserve_structure:\n+                # Don't use fraction format for cases like exp(-x) that should preserve structure\n+                tex += convert(expr)\n+            else:\n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n                 if self._needs_mul_brackets(numer, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n@@ -461,11 +483,18 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Preserve negative exponent structure like pretty printer\n+            # Only convert to fraction for simple cases like x^(-1)\n+            if expr.exp == -1 and not expr.base.is_Mul:\n+                # Simple cases like x^(-1) can still use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # Complex cases like exp(-x) should preserve structure\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n         else:\n-            if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\n             else:\n                 if expr.is_commutative and expr.exp == -1:\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 99c30dc5c3..d043bd01d8 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1497,9 +1497,14 @@ def _print_Pow(self, power):\n             n, d = fraction(e)\n             if n is S.One and d.is_Atom and not e.is_Integer:\n                 return self._print_nth_root(b, e)\n-            if e.is_Rational and e < 0:\n-                return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n \n+            if e.is_Rational and e < 0:\n+                # Only convert to fraction for simple cases like x^(-1)\n+                if e == -1 and not b.is_Mul:\n+                    return prettyForm(\"1\")/self._print(b)\n+                else:\n+                    # Preserve structure for complex cases\n+                    return self._print(b)**self._print(e)\n         if b.is_Relational:\n             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n \ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..b4a7bb63c9 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -129,6 +129,8 @@ def test_latex_basic():\n     assert latex(Implies(x, y), symbol_names={x: \"x_i\", y: \"y_i\"}) == \\\n         r\"x_i \\Rightarrow y_i\"\n \n+    p = Symbol('p', positive=True)\n+\n     p = Symbol('p', positive=True)\n     assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n \n",
    "variant_3": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..99b5ce6b24 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -357,7 +357,14 @@ def _print_Mul(self, expr):\n             tex = \"\"\n \n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Check if this is a simple negative power that was redirected from _print_Pow\n+        # If so, avoid fraction() which changes structure\n+        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n+            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+            # Handle as regular multiplication to preserve structure\n+            numer, denom = expr, S.One\n+        else:\n+            numer, denom = fraction(expr, exact=True)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -395,19 +402,32 @@ def convert(expr):\n             # altered it when producing numer and denom\n             tex += convert(expr)\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n+\n+        if denom is S.One:\n+            # use the original expression here, since fraction() may have\n+            # altered it when producing numer and denom\n+            tex += convert(expr)\n+        else:\n+            # Check if this is a structure-preserving case where we shouldn't use fractions\n+            # This prevents destroying meaningful mathematical structure like exp(-x)\n+            preserve_structure = (numer == S.One and \n+                                any(arg.is_Pow and arg.exp.is_negative and arg.exp != -1 \n+                                    for arg in expr.args if hasattr(arg, 'is_Pow')))\n+            \n+            if not preserve_structure:\n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n                 if self._needs_mul_brackets(numer, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n@@ -461,11 +481,18 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Preserve negative exponent structure like pretty printer\n+            # Only convert to fraction for simple cases like x^(-1)\n+            if expr.exp == -1 and not expr.base.is_Mul:\n+                # Simple cases like x^(-1) can still use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # Complex cases like exp(-x) should preserve structure\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n         else:\n-            if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\n             else:\n                 if expr.is_commutative and expr.exp == -1:\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 99c30dc5c3..4e4a9ca1b0 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1491,6 +1491,13 @@ def _print_nth_root(self, base, expt):\n     def _print_Pow(self, power):\n         from sympy.simplify.simplify import fraction\n         b, e = power.as_base_exp()\n+        if power.is_commutative:\n+            if e is S.NegativeOne:\n+                return prettyForm(\"1\")/self._print(b)\n+            n, d = fraction(e)\n+            if n is S.One and d.is_Atom and not e.is_Integer:\n+                return self._print_nth_root(b, e)\n+\n         if power.is_commutative:\n             if e is S.NegativeOne:\n                 return prettyForm(\"1\")/self._print(b)\n@@ -1499,7 +1506,6 @@ def _print_Pow(self, power):\n                 return self._print_nth_root(b, e)\n             if e.is_Rational and e < 0:\n                 return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n-\n         if b.is_Relational:\n             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n \ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..b4a7bb63c9 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -129,6 +129,8 @@ def test_latex_basic():\n     assert latex(Implies(x, y), symbol_names={x: \"x_i\", y: \"y_i\"}) == \\\n         r\"x_i \\Rightarrow y_i\"\n \n+    p = Symbol('p', positive=True)\n+\n     p = Symbol('p', positive=True)\n     assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n \n",
    "variant_4": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..8762af14a6 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -357,7 +357,14 @@ def _print_Mul(self, expr):\n             tex = \"\"\n \n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Check if this is a simple negative power that was redirected from _print_Pow\n+        # If so, avoid fraction() which changes structure\n+        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n+            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+            # Handle as regular multiplication to preserve structure\n+            numer, denom = expr, S.One\n+        else:\n+            numer, denom = fraction(expr, exact=True)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -395,19 +402,32 @@ def convert(expr):\n             # altered it when producing numer and denom\n             tex += convert(expr)\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n+\n+        if denom is S.One:\n+            # use the original expression here, since fraction() may have\n+            # altered it when producing numer and denom\n+            tex += convert(expr)\n+        else:\n+            # Check if this fraction came from a negative power that should preserve structure\n+            preserve_structure = False\n+            if (numer == S.One and len(expr.args) == 1 and expr.args[0].is_Pow and \n+                expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+                preserve_structure = True\n+            \n+            if not preserve_structure:\n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n                 if self._needs_mul_brackets(numer, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n@@ -461,11 +481,18 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Preserve negative exponent structure like pretty printer\n+            # Only convert to fraction for simple cases like x^(-1)\n+            if expr.exp == -1 and not expr.base.is_Mul:\n+                # Simple cases like x^(-1) can still use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # Complex cases like exp(-x) should preserve structure\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n         else:\n-            if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\n             else:\n                 if expr.is_commutative and expr.exp == -1:\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 99c30dc5c3..f2a63d6665 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1488,6 +1488,16 @@ def _print_nth_root(self, base, expt):\n         s = prettyForm(*s.left(rootsign))\n         return s\n \n+    def _print_Pow(self, power):\n+        from sympy.simplify.simplify import fraction\n+        b, e = power.as_base_exp()\n+        if power.is_commutative:\n+            if e is S.NegativeOne:\n+                return prettyForm(\"1\")/self._print(b)\n+            n, d = fraction(e)\n+            if n is S.One and d.is_Atom and not e.is_Integer:\n+                return self._print_nth_root(b, e)\n+\n     def _print_Pow(self, power):\n         from sympy.simplify.simplify import fraction\n         b, e = power.as_base_exp()\n@@ -1504,6 +1514,10 @@ def _print_Pow(self, power):\n             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n \n         return self._print(b)**self._print(e)\n+        if b.is_Relational:\n+            return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n+\n+        return self._print(b)**self._print(e)\n \n     def _print_UnevaluatedExpr(self, expr):\n         return self._print(expr.args[0])\ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..b4a7bb63c9 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -129,6 +129,8 @@ def test_latex_basic():\n     assert latex(Implies(x, y), symbol_names={x: \"x_i\", y: \"y_i\"}) == \\\n         r\"x_i \\Rightarrow y_i\"\n \n+    p = Symbol('p', positive=True)\n+\n     p = Symbol('p', positive=True)\n     assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n \n",
    "variant_5": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..1fa4416c41 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,16 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n+\n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Check if this is a simple negative power that was redirected from _print_Pow\n+        # If so, avoid fraction() which changes structure\n+        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n+            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+            # Handle as regular multiplication to preserve structure\n+            numer, denom = expr, S.One\n+        else:\n+            numer, denom = fraction(expr, exact=True)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -395,19 +403,34 @@ def convert(expr):\n             # altered it when producing numer and denom\n             tex += convert(expr)\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n+\n+        if denom is S.One:\n+            # use the original expression here, since fraction() may have\n+            # altered it when producing numer and denom\n+            tex += convert(expr)\n+        else:\n+            # Check if this is a structure-preserving case that shouldn't use fraction format\n+            preserve_structure = (numer == S.One and \n+                                any(arg.is_Pow and arg.exp.is_negative and arg.exp != -1 \n+                                    for arg in expr.args if arg.is_Pow))\n+            \n+            if preserve_structure:\n+                # Don't use fraction format for cases like exp(-x) that should preserve structure\n+                tex += convert(expr)\n+            else:\n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n                 if self._needs_mul_brackets(numer, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n@@ -461,11 +484,18 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Preserve negative exponent structure like pretty printer\n+            # Only convert to fraction for simple cases like x^(-1)\n+            if expr.exp == -1 and not expr.base.is_Mul:\n+                # Simple cases like x^(-1) can still use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # Complex cases like exp(-x) should preserve structure\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n         else:\n-            if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\n             else:\n                 if expr.is_commutative and expr.exp == -1:\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 99c30dc5c3..bf082fe0bb 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1497,9 +1497,9 @@ def _print_Pow(self, power):\n             n, d = fraction(e)\n             if n is S.One and d.is_Atom and not e.is_Integer:\n                 return self._print_nth_root(b, e)\n-            if e.is_Rational and e < 0:\n-                return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n \n+        if e.is_Rational and e < 0:\n+            return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n         if b.is_Relational:\n             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n \ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..b4a7bb63c9 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -129,6 +129,8 @@ def test_latex_basic():\n     assert latex(Implies(x, y), symbol_names={x: \"x_i\", y: \"y_i\"}) == \\\n         r\"x_i \\Rightarrow y_i\"\n \n+    p = Symbol('p', positive=True)\n+\n     p = Symbol('p', positive=True)\n     assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n \n",
    "variant_6": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..62f4af456b 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -357,7 +357,14 @@ def _print_Mul(self, expr):\n             tex = \"\"\n \n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Check if this is a simple negative power that was redirected from _print_Pow\n+        # If so, avoid fraction() which changes structure\n+        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n+            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+            # Handle as regular multiplication to preserve structure\n+            numer, denom = expr, S.One\n+        else:\n+            numer, denom = fraction(expr, exact=True)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -395,19 +402,40 @@ def convert(expr):\n             # altered it when producing numer and denom\n             tex += convert(expr)\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n+\n+        if denom is S.One:\n+            # use the original expression here, since fraction() may have\n+            # altered it when producing numer and denom\n+            tex += convert(expr)\n+        else:\n+            # Check if this is a structure that should be preserved\n+            # (e.g., expressions that were originally negative powers)\n+            preserve_structure = False\n+            if (numer == S.One and len(expr.args) >= 1):\n+                # Check if any arg is a power with negative exponent that should preserve structure\n+                for arg in expr.args:\n+                    if (arg.is_Pow and arg.exp.is_negative and \n+                        (arg.exp != -1 or arg.base.is_Add or arg.base.is_Mul)):\n+                        preserve_structure = True\n+                        break\n+            \n+            if preserve_structure:\n+                # Don't use fraction formatting for structure-preserving cases\n+                tex += convert(expr)\n+            else:\n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n                 if self._needs_mul_brackets(numer, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n@@ -461,11 +489,18 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Preserve negative exponent structure like pretty printer\n+            # Only convert to fraction for simple cases like x^(-1)\n+            if expr.exp == -1 and not expr.base.is_Mul:\n+                # Simple cases like x^(-1) can still use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # Complex cases like exp(-x) should preserve structure\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n         else:\n-            if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\n             else:\n                 if expr.is_commutative and expr.exp == -1:\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 99c30dc5c3..d043bd01d8 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1497,9 +1497,14 @@ def _print_Pow(self, power):\n             n, d = fraction(e)\n             if n is S.One and d.is_Atom and not e.is_Integer:\n                 return self._print_nth_root(b, e)\n-            if e.is_Rational and e < 0:\n-                return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n \n+            if e.is_Rational and e < 0:\n+                # Only convert to fraction for simple cases like x^(-1)\n+                if e == -1 and not b.is_Mul:\n+                    return prettyForm(\"1\")/self._print(b)\n+                else:\n+                    # Preserve structure for complex cases\n+                    return self._print(b)**self._print(e)\n         if b.is_Relational:\n             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n \ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..b4a7bb63c9 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -129,6 +129,8 @@ def test_latex_basic():\n     assert latex(Implies(x, y), symbol_names={x: \"x_i\", y: \"y_i\"}) == \\\n         r\"x_i \\Rightarrow y_i\"\n \n+    p = Symbol('p', positive=True)\n+\n     p = Symbol('p', positive=True)\n     assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n \n",
    "variant_7": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..f2ad2682f6 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,16 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n+\n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Check if this is a simple negative power that was redirected from _print_Pow\n+        # If so, avoid fraction() which changes structure\n+        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n+            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+            # Handle as regular multiplication to preserve structure\n+            numer, denom = expr, S.One\n+        else:\n+            numer, denom = fraction(expr, exact=True)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -395,19 +403,33 @@ def convert(expr):\n             # altered it when producing numer and denom\n             tex += convert(expr)\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n+\n+        if denom is S.One:\n+            # use the original expression here, since fraction() may have\n+            # altered it when producing numer and denom\n+            tex += convert(expr)\n+        else:\n+            # Check if this fraction comes from a negative power that should preserve structure\n+            preserve_structure = False\n+            if (numer == S.One and len(expr.args) == 1 and \n+                expr.args[0].is_Pow and expr.args[0].exp.is_negative and \n+                expr.args[0].exp != -1):\n+                preserve_structure = True\n+            \n+            if not preserve_structure:\n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n                 if self._needs_mul_brackets(numer, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n@@ -461,11 +483,18 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Preserve negative exponent structure like pretty printer\n+            # Only convert to fraction for simple cases like x^(-1)\n+            if expr.exp == -1 and not expr.base.is_Mul:\n+                # Simple cases like x^(-1) can still use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # Complex cases like exp(-x) should preserve structure\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n         else:\n-            if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\n             else:\n                 if expr.is_commutative and expr.exp == -1:\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 99c30dc5c3..bf082fe0bb 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1497,9 +1497,9 @@ def _print_Pow(self, power):\n             n, d = fraction(e)\n             if n is S.One and d.is_Atom and not e.is_Integer:\n                 return self._print_nth_root(b, e)\n-            if e.is_Rational and e < 0:\n-                return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n \n+        if e.is_Rational and e < 0:\n+            return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n         if b.is_Relational:\n             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n \ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..b4a7bb63c9 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -129,6 +129,8 @@ def test_latex_basic():\n     assert latex(Implies(x, y), symbol_names={x: \"x_i\", y: \"y_i\"}) == \\\n         r\"x_i \\Rightarrow y_i\"\n \n+    p = Symbol('p', positive=True)\n+\n     p = Symbol('p', positive=True)\n     assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n \n",
    "variant_8": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..0c1eb6bedb 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -357,7 +357,14 @@ def _print_Mul(self, expr):\n             tex = \"\"\n \n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Check if this is a simple negative power that was redirected from _print_Pow\n+        # If so, avoid fraction() which changes structure\n+        if (len(expr.args) == 1 and expr.args[0].is_Pow and \n+            expr.args[0].exp.is_negative and expr.args[0].exp != -1):\n+            # Handle as regular multiplication to preserve structure\n+            numer, denom = expr, S.One\n+        else:\n+            numer, denom = fraction(expr, exact=True)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -395,19 +402,32 @@ def convert(expr):\n             # altered it when producing numer and denom\n             tex += convert(expr)\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n-                else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n+\n+        if denom is S.One:\n+            # use the original expression here, since fraction() may have\n+            # altered it when producing numer and denom\n+            tex += convert(expr)\n+        else:\n+            # Only apply fraction formatting if it doesn't destroy structure\n+            # Check if this came from a negative power that should preserve structure\n+            preserve_structure = (numer == S.One and \n+                any(arg.is_Pow and arg.exp.is_negative and arg.exp != -1 \n+                    for arg in expr.args if hasattr(arg, 'is_Pow')))\n+            \n+            if not preserve_structure:\n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n                 if self._needs_mul_brackets(numer, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n@@ -461,11 +481,18 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Preserve negative exponent structure like pretty printer\n+            # Only convert to fraction for simple cases like x^(-1)\n+            if expr.exp == -1 and not expr.base.is_Mul:\n+                # Simple cases like x^(-1) can still use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # Complex cases like exp(-x) should preserve structure\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                return r\"%s^{%s}\" % (base, self._print(expr.exp))\n         else:\n-            if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\n             else:\n                 if expr.is_commutative and expr.exp == -1:\ndiff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py\nindex 99c30dc5c3..5c7a117342 100644\n--- a/sympy/printing/pretty/pretty.py\n+++ b/sympy/printing/pretty/pretty.py\n@@ -1497,9 +1497,14 @@ def _print_Pow(self, power):\n             n, d = fraction(e)\n             if n is S.One and d.is_Atom and not e.is_Integer:\n                 return self._print_nth_root(b, e)\n-            if e.is_Rational and e < 0:\n-                return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n \n+        if e.is_Rational and e < 0:\n+            # Only convert simple cases to fractions, preserve structure for complex expressions\n+            if e == -1 and not b.is_Mul and not isinstance(b, (Function, Pow)):\n+                return prettyForm(\"1\")/self._print(b)\n+            else:\n+                # Preserve structure like exp(-x) instead of converting to 1/exp(x)\n+                return self._print(b)**self._print(e)\n         if b.is_Relational:\n             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n \ndiff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 8a70549050..b4a7bb63c9 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -129,6 +129,8 @@ def test_latex_basic():\n     assert latex(Implies(x, y), symbol_names={x: \"x_i\", y: \"y_i\"}) == \\\n         r\"x_i \\Rightarrow y_i\"\n \n+    p = Symbol('p', positive=True)\n+\n     p = Symbol('p', positive=True)\n     assert latex(exp(-p)*log(p)) == r\"e^{- p} \\log{\\left (p \\right )}\"\n \n"
  }
}