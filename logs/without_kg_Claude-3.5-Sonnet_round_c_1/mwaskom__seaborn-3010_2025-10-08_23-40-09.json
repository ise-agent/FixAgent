{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/seaborn/seaborn/_stats/regression.py lines 24-32)": "\n    def _fit_predict(self, data):\n\n        clean_data = data.dropna(subset=[\"x\", \"y\"])\n        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            x = clean_data[\"x\"]\n            y = clean_data[\"y\"]\n            p = np.polyfit(x, y, self.order)\n            xx = np.linspace(x.min(), x.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/seaborn/seaborn/_stats/regression.py lines 24-32)": [
      "\n    def _fit_predict(self, data):\n\n        clean_data = data.dropna(subset=[\"x\", \"y\"])\n        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            x = clean_data[\"x\"]\n            y = clean_data[\"y\"]\n            p = np.polyfit(x, y, self.order)\n            xx = np.linspace(x.min(), x.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        clean_data = data.dropna(subset=[\"x\", \"y\"])\n        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            x = clean_data[\"x\"]\n            y = clean_data[\"y\"]\n            p = np.polyfit(x, y, self.order)\n            xx = np.linspace(x.min(), x.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        clean_data = data.dropna(subset=[\"x\", \"y\"])\n        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            x = clean_data[\"x\"]\n            y = clean_data[\"y\"]\n            p = np.polyfit(x, y, self.order)\n            xx = np.linspace(x.min(), x.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        clean_data = data.dropna(subset=[\"x\", \"y\"])\n        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            x = clean_data[\"x\"]\n            y = clean_data[\"y\"]\n            p = np.polyfit(x, y, self.order)\n            xx = np.linspace(x.min(), x.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        clean_data = data.dropna(subset=[\"x\", \"y\"])\n        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            x = clean_data[\"x\"]\n            y = clean_data[\"y\"]\n            p = np.polyfit(x, y, self.order)\n            xx = np.linspace(x.min(), x.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        clean_data = data.dropna(subset=[\"x\", \"y\"])\n        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            x = clean_data[\"x\"]\n            y = clean_data[\"y\"]\n            p = np.polyfit(x, y, self.order)\n            xx = np.linspace(x.min(), x.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        clean_data = data.dropna(subset=[\"x\", \"y\"])\n        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            x = clean_data[\"x\"]\n            y = clean_data[\"y\"]\n            p = np.polyfit(x, y, self.order)\n            xx = np.linspace(x.min(), x.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        clean_data = data.dropna(subset=[\"x\", \"y\"])\n        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            x = clean_data[\"x\"]\n            y = clean_data[\"y\"]\n            p = np.polyfit(x, y, self.order)\n            xx = np.linspace(x.min(), x.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..e0535d75 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,12 +21,16 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+\n+        # Filter out missing values following seaborn pattern\n+        clean_data = data.dropna(subset=[\"x\", \"y\"])\n+        \n+        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n+            x = clean_data[\"x\"]\n+            y = clean_data[\"y\"]\n             p = np.polyfit(x, y, self.order)\n             xx = np.linspace(x.min(), x.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n",
    "variant_0": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..1a504862 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,18 +21,24 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+\n+    def _fit_predict(self, data):\n+\n+        clean_data = data.dropna(subset=[\"x\", \"y\"])\n+        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n+            x = clean_data[\"x\"]\n+            y = clean_data[\"y\"]\n             p = np.polyfit(x, y, self.order)\n             xx = np.linspace(x.min(), x.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_1": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..1a504862 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,18 +21,24 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+\n+    def _fit_predict(self, data):\n+\n+        clean_data = data.dropna(subset=[\"x\", \"y\"])\n+        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n+            x = clean_data[\"x\"]\n+            y = clean_data[\"y\"]\n             p = np.polyfit(x, y, self.order)\n             xx = np.linspace(x.min(), x.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_2": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..1a504862 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,18 +21,24 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+\n+    def _fit_predict(self, data):\n+\n+        clean_data = data.dropna(subset=[\"x\", \"y\"])\n+        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n+            x = clean_data[\"x\"]\n+            y = clean_data[\"y\"]\n             p = np.polyfit(x, y, self.order)\n             xx = np.linspace(x.min(), x.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_3": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..1a504862 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,18 +21,24 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+\n+    def _fit_predict(self, data):\n+\n+        clean_data = data.dropna(subset=[\"x\", \"y\"])\n+        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n+            x = clean_data[\"x\"]\n+            y = clean_data[\"y\"]\n             p = np.polyfit(x, y, self.order)\n             xx = np.linspace(x.min(), x.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_4": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..1a504862 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,18 +21,24 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+\n+    def _fit_predict(self, data):\n+\n+        clean_data = data.dropna(subset=[\"x\", \"y\"])\n+        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n+            x = clean_data[\"x\"]\n+            y = clean_data[\"y\"]\n             p = np.polyfit(x, y, self.order)\n             xx = np.linspace(x.min(), x.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_5": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..1a504862 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,18 +21,24 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+\n+    def _fit_predict(self, data):\n+\n+        clean_data = data.dropna(subset=[\"x\", \"y\"])\n+        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n+            x = clean_data[\"x\"]\n+            y = clean_data[\"y\"]\n             p = np.polyfit(x, y, self.order)\n             xx = np.linspace(x.min(), x.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_6": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..1a504862 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,18 +21,24 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+\n+    def _fit_predict(self, data):\n+\n+        clean_data = data.dropna(subset=[\"x\", \"y\"])\n+        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n+            x = clean_data[\"x\"]\n+            y = clean_data[\"y\"]\n             p = np.polyfit(x, y, self.order)\n             xx = np.linspace(x.min(), x.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_7": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..1a504862 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,18 +21,24 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+\n+    def _fit_predict(self, data):\n+\n+        clean_data = data.dropna(subset=[\"x\", \"y\"])\n+        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n+            x = clean_data[\"x\"]\n+            y = clean_data[\"y\"]\n             p = np.polyfit(x, y, self.order)\n             xx = np.linspace(x.min(), x.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_8": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..1a504862 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,18 +21,24 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+\n+    def _fit_predict(self, data):\n+\n+        clean_data = data.dropna(subset=[\"x\", \"y\"])\n+        if len(clean_data) == 0 or clean_data[\"x\"].nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n+            x = clean_data[\"x\"]\n+            y = clean_data[\"y\"]\n             p = np.polyfit(x, y, self.order)\n             xx = np.linspace(x.min(), x.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n"
  }
}