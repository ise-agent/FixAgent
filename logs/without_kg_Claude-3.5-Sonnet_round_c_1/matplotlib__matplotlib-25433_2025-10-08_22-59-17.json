{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/widgets.py lines 942-969)": "\ndef set_val(self, val):\n    \"\"\"\n    Set slider value to *val*.\n\n    Parameters\n    ----------\n    val : tuple or array-like of float\n    \"\"\"\n    val = np.sort(val)\n    _api.check_shape((2,), val=val)\n    # Reset value to allow _value_in_bounds() to work.\n    self.val = (self.valmin, self.valmax)\n    vmin, vmax = self._value_in_bounds(val)\n    self._update_selection_poly(vmin, vmax)\n    if self.orientation == \"vertical\":\n        self._handles[0].set_ydata([vmin])\n        self._handles[1].set_ydata([vmax])\n    else:\n        self._handles[0].set_xdata([vmin])\n        self._handles[1].set_xdata([vmax])\n\n    self.valtext.set_text(self._format((vmin, vmax)))\n\n    if self.drawon:\n        self.ax.figure.canvas.draw_idle()\n    self.val = (vmin, vmax)\n    \n    # Only trigger callbacks if we're not in the middle of a drag operation\n    # to prevent interference with mouse grab/release handling\n    if self.eventson and not getattr(self, '_dragging', False):\n        self._observers.process(\"changed\", (vmin, vmax))\n",
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/widgets.py lines 867-906)": "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            self._active_handle = None\n            # Trigger any pending callbacks after mouse is released\n            if hasattr(self, '_pending_callback') and self._pending_callback:\n                self._call_observers('changed', self.val)\n                self._pending_callback = False\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/widgets.py lines 823-866)": "\ndef set_val(self, val):\n    \"\"\"\n    Set the value of the slider.\n\n    Parameters\n    ----------\n    val : array-like\n        The new value for the slider.  This will be forced to be within\n        the bounds of the slider.\n    \"\"\"\n    val = np.sort(val)\n    _api.check_shape((2,), val=val)\n    val[0] = self._min_in_bounds(val[0])\n    val[1] = self._max_in_bounds(val[1])\n    xy = self.poly.xy\n    if self.orientation == \"vertical\":\n        xy[0] = .25, val[0]\n        xy[1] = .25, val[1]\n        xy[2] = .75, val[1]\n        xy[3] = .75, val[0]\n        xy[4] = .25, val[0]\n    else:\n        xy[0] = val[0], .25\n        xy[1] = val[0], .75\n        xy[2] = val[1], .75\n        xy[3] = val[1], .25\n        xy[4] = val[0], .25\n    if self.drawon:\n        self.ax.figure.canvas.draw_idle()\n    self.val = val\n    if not np.array_equal(self.val, val):\n        return\n    # Only trigger callbacks if we're not in an active drag operation\n    # to prevent interference with plt.clf()/plt.draw() operations\n    if not getattr(self, 'drag_active', False):\n        for cid, func in self.observers.items():\n            func(val)\n",
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/widgets.py lines 256-305)": "\nclass SliderBase(AxesWidget):\n    \"\"\"\n    The base class for constructing Slider widgets. Not intended for direct\n    usage.\n\n    For the slider to remain responsive you must maintain a reference to it.\n    \"\"\"\n    def __init__(self, ax, orientation, closedmin, closedmax,\n                 valmin, valmax, valfmt, dragging, valstep):\n        if ax.name == '3d':\n            raise ValueError('Sliders cannot be added to 3D Axes')\n\n        super().__init__(ax)\n        _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)\n\n        self.orientation = orientation\n        self.closedmin = closedmin\n        self.closedmax = closedmax\n        self.valmin = valmin\n        self.valmax = valmax\n        self.valstep = valstep\n        self.drag_active = False\n        self._callback_blocked = False\n        self.valfmt = valfmt\n\n        if orientation == \"vertical\":\n            ax.set_ylim((valmin, valmax))\n            axis = ax.yaxis\n        else:\n            ax.set_xlim((valmin, valmax))\n            axis = ax.xaxis\n\n        self._fmt = axis.get_major_formatter()\n        if not isinstance(self._fmt, ticker.ScalarFormatter):\n            self._fmt = ticker.ScalarFormatter()\n            self._fmt.set_axis(axis)\n        self._fmt.set_useOffset(False)  # No additive offset.\n        self._fmt.set_useMathText(True)  # x sign before multiplicative offset.\n\n        ax.set_axis_off()\n        ax.set_navigate(False)\n\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n\n    def _stepped_value(self, val):\n        \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n        if isinstance(self.valstep, Number):\n",
    "Location 5 (/root/hy/projects_1/matplotlib/lib/matplotlib/widgets.py lines 223-228)": "\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        # Release mouse grab BEFORE triggering any callbacks to prevent interference\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            self._observers.process('clicked', event)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/widgets.py lines 942-969)": [
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        \n        # Only trigger callbacks if we're not in the middle of a drag operation\n        # This prevents interference with mouse grab state during plt.clf()/plt.draw()\n        if self.eventson and not getattr(self, '_dragging', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\ndef set_val(self, val):\n    \"\"\"\n    Set slider value to *val*.\n\n    Parameters\n    ----------\n    val : tuple or array-like of float\n    \"\"\"\n    val = np.sort(val)\n    _api.check_shape((2,), val=val)\n    # Reset value to allow _value_in_bounds() to work.\n    self.val = (self.valmin, self.valmax)\n    vmin, vmax = self._value_in_bounds(val)\n    self._update_selection_poly(vmin, vmax)\n    if self.orientation == \"vertical\":\n        self._handles[0].set_ydata([vmin])\n        self._handles[1].set_ydata([vmax])\n    else:\n        self._handles[0].set_xdata([vmin])\n        self._handles[1].set_xdata([vmax])\n\n    self.valtext.set_text(self._format((vmin, vmax)))\n\n    if self.drawon:\n        self.ax.figure.canvas.draw_idle()\n    self.val = (vmin, vmax)\n    \n    # Defer callback execution if we're in the middle of a drag operation\n    # to prevent interference with mouse grab state\n    if self.eventson:\n        if hasattr(self, '_active') and self._active:\n            # Store callback for later execution when drag completes\n            self._pending_callback = (vmin, vmax)\n        else:\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        \n        # Defer callback execution if we're in the middle of a drag operation\n        # to prevent interference with mouse event handling\n        if self.eventson:\n            if hasattr(self, '_active') and self._active:\n                # Store the callback for later execution when drag ends\n                self._pending_callback = (vmin, vmax)\n            else:\n                self._observers.process(\"changed\", (vmin, vmax))\n",
      "\ndef set_val(self, val):\n    \"\"\"\n    Set slider value to *val*.\n\n    Parameters\n    ----------\n    val : tuple or array-like of float\n    \"\"\"\n    val = np.sort(val)\n    _api.check_shape((2,), val=val)\n    # Reset value to allow _value_in_bounds() to work.\n    self.val = (self.valmin, self.valmax)\n    vmin, vmax = self._value_in_bounds(val)\n    self._update_selection_poly(vmin, vmax)\n    if self.orientation == \"vertical\":\n        self._handles[0].set_ydata([vmin])\n        self._handles[1].set_ydata([vmax])\n    else:\n        self._handles[0].set_xdata([vmin])\n        self._handles[1].set_xdata([vmax])\n\n    self.valtext.set_text(self._format((vmin, vmax)))\n\n    if self.drawon:\n        self.ax.figure.canvas.draw_idle()\n    self.val = (vmin, vmax)\n    \n    # Defer callback execution if we're in the middle of a drag operation\n    if self.eventson:\n        # Check if we're currently dragging by seeing if we have active mouse capture\n        if hasattr(self, '_active') and self._active:\n            # Store the callback for later execution\n            self._pending_callback = (vmin, vmax)\n        else:\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\ndef set_val(self, val):\n    \"\"\"\n    Set slider value to *val*.\n\n    Parameters\n    ----------\n    val : tuple or array-like of float\n    \"\"\"\n    val = np.sort(val)\n    _api.check_shape((2,), val=val)\n    # Reset value to allow _value_in_bounds() to work.\n    self.val = (self.valmin, self.valmax)\n    vmin, vmax = self._value_in_bounds(val)\n    self._update_selection_poly(vmin, vmax)\n    if self.orientation == \"vertical\":\n        self._handles[0].set_ydata([vmin])\n        self._handles[1].set_ydata([vmax])\n    else:\n        self._handles[0].set_xdata([vmin])\n        self._handles[1].set_xdata([vmax])\n\n    self.valtext.set_text(self._format((vmin, vmax)))\n\n    if self.drawon:\n        self.ax.figure.canvas.draw_idle()\n    self.val = (vmin, vmax)\n    \n    # Only trigger callbacks if not in active drag state\n    if self.eventson and not getattr(self, '_active', False):\n        self._observers.process(\"changed\", (vmin, vmax))\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        \n        # Only trigger callbacks if not currently in an active drag operation\n        # This prevents interference with mouse grab during plt.clf()/plt.draw()\n        if self.eventson and not getattr(self, '_active', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        \n        # Only trigger callbacks if we're not in an active drag operation\n        # to prevent interference with mouse grab state\n        if self.eventson and not getattr(self, '_dragging', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\ndef set_val(self, val):\n    \"\"\"\n    Set slider value to *val*.\n\n    Parameters\n    ----------\n    val : tuple or array-like of float\n    \"\"\"\n    val = np.sort(val)\n    _api.check_shape((2,), val=val)\n    # Reset value to allow _value_in_bounds() to work.\n    self.val = (self.valmin, self.valmax)\n    vmin, vmax = self._value_in_bounds(val)\n    self._update_selection_poly(vmin, vmax)\n    if self.orientation == \"vertical\":\n        self._handles[0].set_ydata([vmin])\n        self._handles[1].set_ydata([vmax])\n    else:\n        self._handles[0].set_xdata([vmin])\n        self._handles[1].set_xdata([vmax])\n\n    self.valtext.set_text(self._format((vmin, vmax)))\n\n    if self.drawon:\n        self.ax.figure.canvas.draw_idle()\n    self.val = (vmin, vmax)\n    \n    # Only trigger callbacks if we're not in an active drag state\n    # This prevents interference with mouse grab during plt.clf()/plt.draw() calls\n    if self.eventson and not getattr(self, '_active', False):\n        self._observers.process(\"changed\", (vmin, vmax))\n"
    ],
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/widgets.py lines 867-906)": [
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            self._active_handle = None\n            # Trigger callbacks after releasing mouse grab\n            if event.name == \"button_release_event\":\n                self._observers.process('changed', self.val)\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
      "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.button != 1:\n        return\n\n    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n        self.drag_active = True\n        event.canvas.grab_mouse(self.ax)\n\n    if not self.drag_active:\n        return\n\n    elif (event.name == \"button_release_event\") or (\n        event.name == \"button_press_event\" and event.inaxes != self.ax\n    ):\n        self.drag_active = False\n        event.canvas.release_mouse(self.ax)\n        self._active_handle = None\n        # Trigger callbacks after releasing mouse grab\n        if event.name == \"button_release_event\":\n            self._observers.process('changed', self.val)\n        return\n\n    # determine which handle was grabbed\n    if self.orientation == \"vertical\":\n        handle_index = np.argmin(\n            np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n        )\n    else:\n        handle_index = np.argmin(\n            np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n        )\n    handle = self._handles[handle_index]\n\n    # these checks ensure smooth behavior if the handles swap which one\n    # has a higher value. i.e. if one is dragged over and past the other.\n    if handle is not self._active_handle:\n        self._active_handle = handle\n\n    if self.orientation == \"vertical\":\n        self._update_val_from_pos(event.ydata)\n    else:\n        self._update_val_from_pos(event.xdata)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            self._active_handle = None\n            # Trigger callbacks after releasing mouse grab\n            if event.name == \"button_release_event\":\n                self._observers.process('changed', self.val)\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
      "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.button != 1:\n        return\n\n    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n        self.drag_active = True\n        event.canvas.grab_mouse(self.ax)\n\n    if not self.drag_active:\n        return\n\n    elif (event.name == \"button_release_event\") or (\n        event.name == \"button_press_event\" and event.inaxes != self.ax\n    ):\n        # Release mouse grab BEFORE triggering any callbacks\n        self.drag_active = False\n        event.canvas.release_mouse(self.ax)\n        self._active_handle = None\n        \n        # Trigger callbacks after mouse is released\n        if event.name == \"button_release_event\":\n            self._observers.process('changed', self.val)\n        return\n\n    # determine which handle was grabbed\n    if self.orientation == \"vertical\":\n        handle_index = np.argmin(\n            np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n        )\n    else:\n        handle_index = np.argmin(\n            np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n        )\n    handle = self._handles[handle_index]\n\n    # these checks ensure smooth behavior if the handles swap which one\n    # has a higher value. i.e. if one is dragged over and past the other.\n    if handle is not self._active_handle:\n        self._active_handle = handle\n\n    if self.orientation == \"vertical\":\n        self._update_val_from_pos(event.ydata)\n    else:\n        self._update_val_from_pos(event.xdata)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            self._active_handle = None\n            # Trigger callbacks after releasing mouse grab\n            self._observers.process('changed', self.val)\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            self._active_handle = None\n            # Trigger callbacks after releasing mouse grab\n            if event.name == \"button_release_event\":\n                self._observers.process('changed', self.val)\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
      "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.button != 1:\n        return\n\n    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n        self.drag_active = True\n        event.canvas.grab_mouse(self.ax)\n\n    if not self.drag_active:\n        return\n\n    elif (event.name == \"button_release_event\") or (\n        event.name == \"button_press_event\" and event.inaxes != self.ax\n    ):\n        self.drag_active = False\n        event.canvas.release_mouse(self.ax)\n        self._active_handle = None\n        # Trigger callbacks after releasing mouse grab\n        if event.name == \"button_release_event\":\n            self._observers.process('changed', self.val)\n        return\n\n    # determine which handle was grabbed\n    if self.orientation == \"vertical\":\n        handle_index = np.argmin(\n            np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n        )\n    else:\n        handle_index = np.argmin(\n            np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n        )\n    handle = self._handles[handle_index]\n\n    # these checks ensure smooth behavior if the handles swap which one\n    # has a higher value. i.e. if one is dragged over and past the other.\n    if handle is not self._active_handle:\n        self._active_handle = handle\n\n    if self.orientation == \"vertical\":\n        self._update_val_from_pos(event.ydata, trigger_callback=False)\n    else:\n        self._update_val_from_pos(event.xdata, trigger_callback=False)\n",
      "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.button != 1:\n        return\n\n    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n        self.drag_active = True\n        event.canvas.grab_mouse(self.ax)\n\n    if not self.drag_active:\n        return\n\n    elif (event.name == \"button_release_event\") or (\n        event.name == \"button_press_event\" and event.inaxes != self.ax\n    ):\n        self.drag_active = False\n        event.canvas.release_mouse(self.ax)\n        self._active_handle = None\n        # Trigger callbacks after releasing mouse grab\n        if hasattr(self, '_pending_callback') and self._pending_callback:\n            self._pending_callback = False\n            self._observers.process('changed', self.val)\n        return\n\n    # determine which handle was grabbed\n    if self.orientation == \"vertical\":\n        handle_index = np.argmin(\n            np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n        )\n    else:\n        handle_index = np.argmin(\n            np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n        )\n    handle = self._handles[handle_index]\n\n    # these checks ensure smooth behavior if the handles swap which one\n    # has a higher value. i.e. if one is dragged over and past the other.\n    if handle is not self._active_handle:\n        self._active_handle = handle\n\n    if self.orientation == \"vertical\":\n        self._update_val_from_pos(event.ydata)\n    else:\n        self._update_val_from_pos(event.xdata)\n"
    ],
    "Location 3 (/root/hy/projects_1/matplotlib/lib/matplotlib/widgets.py lines 823-866)": [
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val)\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val)\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        if event.name == \"button_release_event\":\n            # Release mouse grab BEFORE triggering any callbacks\n            if self.drag_active:\n                event.canvas.release_mouse(self.ax)\n                self.drag_active = False\n            return\n\n        if event.inaxes == self.ax:\n            if self.orientation == \"vertical\":\n                pos = self._min_in_bounds(event.ydata)\n            else:\n                pos = self._min_in_bounds(event.xdata)\n            \n            # Only update position during drag, don't trigger callbacks yet\n            self._update_val_from_pos(pos)\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val, trigger_callback=not self.drag_active)\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val, trigger_callback=not self.drag_active)\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        if event.name == \"button_release_event\":\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Trigger callback after releasing mouse grab\n            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n                self.eventson = True\n                self._observers.process('changed', self.val)\n                self._deferred_callback = False\n            return\n\n        if event.inaxes != self.ax:\n            return\n\n        if self.orientation == \"vertical\":\n            pos = self._value_in_bounds((event.ydata,) * 2)[0]\n        else:\n            pos = self._value_in_bounds((event.xdata,) * 2)[0]\n        self._update_val_from_pos(pos)\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val)\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val)\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        if event.name == \"button_release_event\":\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Trigger callbacks after releasing mouse grab\n            self._observers.process('changed', self.val)\n            return\n\n        if event.name == \"motion_notify_event\":\n            if self.orientation == \"vertical\":\n                pos = self._get_data_interval()[0] + event.ydata * np.ptp(self._get_data_interval())\n            else:\n                pos = self._get_data_interval()[0] + event.xdata * np.ptp(self._get_data_interval())\n            \n            # Update position without triggering callbacks during drag\n            old_val = self.val\n            self._update_val_from_pos(pos)\n            \n            # Only update visual elements during drag, not callbacks\n            if self.drawon:\n                self.ax.figure.canvas.draw_idle()\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val)\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val)\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif event.name == \"button_release_event\" \\\n                or event.name == \"button_press_event\":\n            if event.inaxes != self.ax:\n                return\n            self._determine_active_handle(event)\n        elif event.name == \"motion_notify_event\":\n            if event.inaxes != self.ax:\n                return\n\n        pos = self._get_data_coords(event)\n        lastval = self.val.copy()\n        self._update_val_from_pos(pos)\n        if lastval != self.val:\n            self.poly.xy = self._update_selection_poly()\n            if self.drawon:\n                self.ax.figure.canvas.draw_idle()\n            # Only trigger callbacks when not in active drag or on release\n            if event.name == \"button_release_event\" or not self.drag_active:\n                self._observers.process('changed', self.val.copy())\n\n        if event.name == \"button_release_event\":\n            self.drag_active = False\n            # Release mouse grab before any potential callbacks\n            event.canvas.release_mouse(self.ax)\n            self._active_handle = None\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val)\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val)\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        if event.name == \"button_release_event\":\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Trigger callbacks after releasing mouse grab\n            self._observers.process('changed', self.val)\n            return\n\n        if event.name == \"motion_notify_event\":\n            if self.orientation == \"vertical\":\n                self._update_val_from_pos(event.ydata)\n            else:\n                self._update_val_from_pos(event.xdata)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        if event.name == \"button_press_event\":\n            # determine which handle is closest to the event\n            if self.orientation == \"vertical\":\n                self._active_handle = min(self._handles, key=lambda h:\n                                        abs(h.get_ydata()[0] - event.ydata))\n            else:\n                self._active_handle = min(self._handles, key=lambda h:\n                                        abs(h.get_xdata()[0] - event.xdata))\n\n        elif event.name == \"button_release_event\" \\\n                or (event.name == \"motion_notify_event\" and\n                    event.inaxes != self.ax):\n            # Release mouse grab BEFORE any callbacks\n            if self.drag_active:\n                event.canvas.release_mouse(self.ax)\n                self.drag_active = False\n                self._active_handle = None\n            return\n\n        # Update position during drag\n        if event.inaxes == self.ax:\n            if self.orientation == \"vertical\":\n                self._update_val_from_pos(event.ydata)\n            else:\n                self._update_val_from_pos(event.xdata)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif event.name == \"button_release_event\":\n            if self.drag_active:\n                self.drag_active = False\n                event.canvas.release_mouse(self.ax)\n\n        if event.name == \"motion_notify_event\":\n            if self.orientation == \"vertical\":\n                self._update_val_from_pos(event.ydata)\n            else:\n                self._update_val_from_pos(event.xdata)\n\n        elif event.name == \"button_press_event\":\n            if self.orientation == \"vertical\":\n                self._update_val_from_pos(event.ydata)\n            else:\n                self._update_val_from_pos(event.xdata)\n\n        elif event.name == \"button_release_event\":\n            if self.orientation == \"vertical\":\n                self._update_val_from_pos(event.ydata)\n            else:\n                self._update_val_from_pos(event.xdata)\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : array-like of length 2\n            Lower and upper bounds for the slider.\n\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        val[0] = self._min_in_bounds(val[0])\n        val[1] = self._max_in_bounds(val[1])\n        xy = self.poly.xy\n        if self.orientation == \"vertical\":\n            xy[0] = .25, val[0]\n            xy[1] = .25, val[1]\n            xy[2] = .75, val[1]\n            xy[3] = .75, val[0]\n            xy[4] = .25, val[0]\n        else:\n            xy[0] = val[0], .25\n            xy[1] = val[0], .75\n            xy[2] = val[1], .75\n            xy[3] = val[1], .25\n            xy[4] = val[0], .25\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if np.any(self.val != val):\n            self.val = val\n            # Only trigger callbacks if not in an active drag state\n            # This prevents interference when callbacks contain plt.clf()/plt.draw()\n            if not getattr(self, 'drag_active', False):\n                if not self.eventson:\n                    return\n                for cid, func in self.observers.items():\n                    func(val)\n        self.ax.stale = True\n"
    ],
    "Location 4 (/root/hy/projects_1/matplotlib/lib/matplotlib/widgets.py lines 256-305)": [
      "\nclass SliderBase(AxesWidget):\n    \"\"\"\n    The base class for constructing Slider widgets. Not intended for direct\n    usage.\n\n    For the slider to remain responsive you must maintain a reference to it.\n    \"\"\"\n    def __init__(self, ax, orientation, closedmin, closedmax,\n                 valmin, valmax, valfmt, dragging, valstep):\n        if ax.name == '3d':\n            raise ValueError('Sliders cannot be added to 3D Axes')\n\n        super().__init__(ax)\n        _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)\n\n        self.orientation = orientation\n        self.closedmin = closedmin\n        self.closedmax = closedmax\n        self.valmin = valmin\n        self.valmax = valmax\n        self.valstep = valstep\n        self.drag_active = False\n        self._pending_callbacks = []\n        self.valfmt = valfmt\n\n        if orientation == \"vertical\":\n            ax.set_ylim((valmin, valmax))\n            axis = ax.yaxis\n        else:\n            ax.set_xlim((valmin, valmax))\n            axis = ax.xaxis\n\n        self._fmt = axis.get_major_formatter()\n        if not isinstance(self._fmt, ticker.ScalarFormatter):\n            self._fmt = ticker.ScalarFormatter()\n            self._fmt.set_axis(axis)\n        self._fmt.set_useOffset(False)  # No additive offset.\n        self._fmt.set_useMathText(True)  # x sign before multiplicative offset.\n\n        ax.set_axis_off()\n        ax.set_navigate(False)\n\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n\n    def _stepped_value(self, val):\n        \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n        if isinstance(self.valstep, Number):\n            val = (self.valmin\n                   + round((val - self.valmin) / self.valstep) * self.valstep)\n        elif self.valstep is not None:\n            valstep = np.asanyarray(self.valstep)\n            if valstep.ndim != 1:\n                raise ValueError(\n                    f\"valstep must have 1 dimension but has {valstep.ndim}\"\n                )\n            val = valstep[np.argmin(np.abs(valstep - val))]\n        return val\n",
      "\nclass SliderBase(AxesWidget):\n    \"\"\"\n    The base class for constructing Slider widgets. Not intended for direct\n    usage.\n\n    For the slider to remain responsive you must maintain a reference to it.\n    \"\"\"\n    def __init__(self, ax, orientation, closedmin, closedmax,\n                 valmin, valmax, valfmt, dragging, valstep):\n        if ax.name == '3d':\n            raise ValueError('Sliders cannot be added to 3D Axes')\n\n        super().__init__(ax)\n        _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)\n\n        self.orientation = orientation\n        self.closedmin = closedmin\n        self.closedmax = closedmax\n        self.valmin = valmin\n        self.valmax = valmax\n        self.valstep = valstep\n        self.drag_active = False\n        self._pending_callbacks = False\n        self.valfmt = valfmt\n\n        if orientation == \"vertical\":\n            ax.set_ylim((valmin, valmax))\n            axis = ax.yaxis\n        else:\n            ax.set_xlim((valmin, valmax))\n            axis = ax.xaxis\n\n        self._fmt = axis.get_major_formatter()\n        if not isinstance(self._fmt, ticker.ScalarFormatter):\n            self._fmt = ticker.ScalarFormatter()\n            self._fmt.set_axis(axis)\n        self._fmt.set_useOffset(False)  # No additive offset.\n        self._fmt.set_useMathText(True)  # x sign before multiplicative offset.\n\n        ax.set_axis_off()\n        ax.set_navigate(False)\n\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n\n    def _stepped_value(self, val):\n        \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n        if isinstance(self.valstep, Number):\n",
      "\nclass SliderBase(AxesWidget):\n    \"\"\"\n    The base class for constructing Slider widgets. Not intended for direct\n    usage.\n\n    For the slider to remain responsive you must maintain a reference to it.\n    \"\"\"\n    def __init__(self, ax, orientation, closedmin, closedmax,\n                 valmin, valmax, valfmt, dragging, valstep):\n        if ax.name == '3d':\n            raise ValueError('Sliders cannot be added to 3D Axes')\n\n        super().__init__(ax)\n        _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)\n\n        self.orientation = orientation\n        self.closedmin = closedmin\n        self.closedmax = closedmax\n        self.valmin = valmin\n        self.valmax = valmax\n        self.valstep = valstep\n        self.drag_active = False\n        self._pending_callback = False\n        self.valfmt = valfmt\n\n        if orientation == \"vertical\":\n            ax.set_ylim((valmin, valmax))\n            axis = ax.yaxis\n        else:\n            ax.set_xlim((valmin, valmax))\n            axis = ax.xaxis\n\n        self._fmt = axis.get_major_formatter()\n        if not isinstance(self._fmt, ticker.ScalarFormatter):\n            self._fmt = ticker.ScalarFormatter()\n            self._fmt.set_axis(axis)\n        self._fmt.set_useOffset(False)  # No additive offset.\n        self._fmt.set_useMathText(True)  # x sign before multiplicative offset.\n\n        ax.set_axis_off()\n        ax.set_navigate(False)\n\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n\n    def _stepped_value(self, val):\n        \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n        if isinstance(self.valstep, Number):\n",
      "\nclass SliderBase(AxesWidget):\n    \"\"\"\n    The base class for constructing Slider widgets. Not intended for direct\n    usage.\n\n    For the slider to remain responsive you must maintain a reference to it.\n    \"\"\"\n    def __init__(self, ax, orientation, closedmin, closedmax,\n                 valmin, valmax, valfmt, dragging, valstep):\n        if ax.name == '3d':\n            raise ValueError('Sliders cannot be added to 3D Axes')\n\n        super().__init__(ax)\n        _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)\n\n        self.orientation = orientation\n        self.closedmin = closedmin\n        self.closedmax = closedmax\n        self.valmin = valmin\n        self.valmax = valmax\n        self.valstep = valstep\n        self.drag_active = False\n        self._mouse_grabbed = False\n        self.valfmt = valfmt\n\n        if orientation == \"vertical\":\n            ax.set_ylim((valmin, valmax))\n            axis = ax.yaxis\n        else:\n            ax.set_xlim((valmin, valmax))\n            axis = ax.xaxis\n\n        self._fmt = axis.get_major_formatter()\n        if not isinstance(self._fmt, ticker.ScalarFormatter):\n            self._fmt = ticker.ScalarFormatter()\n            self._fmt.set_axis(axis)\n        self._fmt.set_useOffset(False)  # No additive offset.\n        self._fmt.set_useMathText(True)  # x sign before multiplicative offset.\n\n        ax.set_axis_off()\n        ax.set_navigate(False)\n\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n\n    def _stepped_value(self, val):\n        \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n        if isinstance(self.valstep, Number):\n",
      "\nclass SliderBase(AxesWidget):\n    \"\"\"\n    The base class for constructing Slider widgets. Not intended for direct\n    usage.\n\n    For the slider to remain responsive you must maintain a reference to it.\n    \"\"\"\n    def __init__(self, ax, orientation, closedmin, closedmax,\n                 valmin, valmax, valfmt, dragging, valstep):\n        if ax.name == '3d':\n            raise ValueError('Sliders cannot be added to 3D Axes')\n\n        super().__init__(ax)\n        _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)\n\n        self.orientation = orientation\n        self.closedmin = closedmin\n        self.closedmax = closedmax\n        self.valmin = valmin\n        self.valmax = valmax\n        self.valstep = valstep\n        self.drag_active = False\n        self._in_drag_state = False  # Track if currently in a drag operation\n        self.valfmt = valfmt\n\n        if orientation == \"vertical\":\n            ax.set_ylim((valmin, valmax))\n            axis = ax.yaxis\n        else:\n            ax.set_xlim((valmin, valmax))\n            axis = ax.xaxis\n\n        self._fmt = axis.get_major_formatter()\n        if not isinstance(self._fmt, ticker.ScalarFormatter):\n            self._fmt = ticker.ScalarFormatter()\n            self._fmt.set_axis(axis)\n        self._fmt.set_useOffset(False)  # No additive offset.\n        self._fmt.set_useMathText(True)  # x sign before multiplicative offset.\n\n        ax.set_axis_off()\n        ax.set_navigate(False)\n\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n\n    def _stepped_value(self, val):\n        \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n        if isinstance(self.valstep, Number):\n",
      "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.inaxes != self.ax:\n        return\n\n    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n        self.drag_active = True\n        xy = self.ax.transData.inverted().transform((event.x, event.y))\n        if self.orientation == 'vertical':\n            self._active_handle = self._handle_grabber(xy[1])\n        else:\n            self._active_handle = self._handle_grabber(xy[0])\n\n    if not self.drag_active:\n        return\n\n    if self.orientation == 'vertical':\n        val = self.ax.transData.inverted().transform((event.x, event.y))[1]\n    else:\n        val = self.ax.transData.inverted().transform((event.x, event.y))[0]\n    val = self._stepped_value(val)\n\n    if self._active_handle:\n        # Update the handle position but don't trigger callbacks yet during drag\n        if self._active_handle == \"min\":\n            if val <= self.val[1]:\n                self.val = (val, self.val[1])\n        elif self._active_handle == \"max\":\n            if val >= self.val[0]:\n                self.val = (self.val[0], val)\n\n        # Update visual representation\n        self._update_selection_poly()\n        \n        # Only update display, don't trigger callbacks during active drag\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n\n    # Handle button release - release drag first, then trigger callbacks\n    if event.name == \"button_release_event\":\n        self.drag_active = False\n        self._active_handle = None\n        # Now it's safe to trigger callbacks after drag is complete\n        if not self.eventson:\n            return\n        self._observers.process(\"changed\", self.val)\n",
      "\nclass SliderBase(AxesWidget):\n    \"\"\"\n    The base class for constructing Slider widgets. Not intended for direct\n    usage.\n\n    For the slider to remain responsive you must maintain a reference to it.\n    \"\"\"\n    def __init__(self, ax, orientation, closedmin, closedmax,\n                 valmin, valmax, valfmt, dragging, valstep):\n        if ax.name == '3d':\n            raise ValueError('Sliders cannot be added to 3D Axes')\n\n        super().__init__(ax)\n        _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)\n\n        self.orientation = orientation\n        self.closedmin = closedmin\n        self.closedmax = closedmax\n        self.valmin = valmin\n        self.valmax = valmax\n        self.valstep = valstep\n        self.drag_active = False\n        self._callback_blocked = False  # Track if callbacks should be deferred\n        self._pending_callback = False  # Track if callback is pending\n        self.valfmt = valfmt\n\n        if orientation == \"vertical\":\n            ax.set_ylim((valmin, valmax))\n            axis = ax.yaxis\n        else:\n            ax.set_xlim((valmin, valmax))\n            axis = ax.xaxis\n\n        self._fmt = axis.get_major_formatter()\n        if not isinstance(self._fmt, ticker.ScalarFormatter):\n            self._fmt = ticker.ScalarFormatter()\n            self._fmt.set_axis(axis)\n        self._fmt.set_useOffset(False)  # No additive offset.\n        self._fmt.set_useMathText(True)  # x sign before multiplicative offset.\n\n        ax.set_axis_off()\n        ax.set_navigate(False)\n\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n\n    def _stepped_value(self, val):\n        \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n        if isinstance(self.valstep, Number):\n",
      "\nclass SliderBase(AxesWidget):\n    \"\"\"\n    The base class for constructing Slider widgets. Not intended for direct\n    usage.\n\n    For the slider to remain responsive you must maintain a reference to it.\n    \"\"\"\n    def __init__(self, ax, orientation, closedmin, closedmax,\n                 valmin, valmax, valfmt, dragging, valstep):\n        if ax.name == '3d':\n            raise ValueError('Sliders cannot be added to 3D Axes')\n\n        super().__init__(ax)\n        _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)\n\n        self.orientation = orientation\n        self.closedmin = closedmin\n        self.closedmax = closedmax\n        self.valmin = valmin\n        self.valmax = valmax\n        self.valstep = valstep\n        self.drag_active = False\n        self._pending_callbacks = []\n        self.valfmt = valfmt\n\n        if orientation == \"vertical\":\n            ax.set_ylim((valmin, valmax))\n            axis = ax.yaxis\n        else:\n            ax.set_xlim((valmin, valmax))\n            axis = ax.xaxis\n\n        self._fmt = axis.get_major_formatter()\n        if not isinstance(self._fmt, ticker.ScalarFormatter):\n            self._fmt = ticker.ScalarFormatter()\n            self._fmt.set_axis(axis)\n        self._fmt.set_useOffset(False)  # No additive offset.\n        self._fmt.set_useMathText(True)  # x sign before multiplicative offset.\n\n        ax.set_axis_off()\n        ax.set_navigate(False)\n\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n\n    def _execute_pending_callbacks(self):\n        \"\"\"Execute any callbacks that were deferred during drag operations.\"\"\"\n        for callback_args in self._pending_callbacks:\n            self._observers.process(\"changed\", *callback_args)\n        self._pending_callbacks.clear()\n\n    def _stepped_value(self, val):\n        \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n        if isinstance(self.valstep, Number):\n"
    ],
    "Location 5 (/root/hy/projects_1/matplotlib/lib/matplotlib/widgets.py lines 223-228)": [
      "\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        # Release mouse grab BEFORE triggering callbacks to prevent interference\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            self._observers.process('clicked', event)\n",
      "\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        # Release mouse grab BEFORE triggering any callbacks\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            # Ensure any pending state updates are flushed before callback\n            if hasattr(self, '_active') and self._active:\n                self._active = False\n            self._observers.process('clicked', event)\n",
      "\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        # Release mouse grab BEFORE processing callbacks to prevent interference\n        # with operations like plt.clf() and plt.draw() in callbacks\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            self._observers.process('clicked', event)\n",
      "\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        # Release mouse grab FIRST before triggering any callbacks\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            self._observers.process('clicked', event)\n",
      "\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        # Release mouse grab FIRST before triggering any callbacks\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            self._observers.process('clicked', event)\n",
      "\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            self._observers.process('clicked', event)\n",
      "\ndef _release(self, event):\n    if self.ignore(event):\n        return\n    \n    # Only process if we actually have the mouse grab\n    if event.canvas.mouse_grabber != self.ax:\n        return\n        \n    # Release mouse grab first to prevent interference with callbacks\n    event.canvas.release_mouse(self.ax)\n    \n    # Only trigger callback if the release happened over our axes\n    if self.eventson and event.inaxes == self.ax:\n        self._observers.process('clicked', event)\n",
      "\n    def _release(self, event):\n        if self.ignore(event):\n            return\n        # Release mouse grab first, before any callbacks\n        if event.canvas.mouse_grabber == self.ax:\n            event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            self._observers.process('clicked', event)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..725659045f 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -220,6 +220,7 @@ class Button(AxesWidget):\n         if event.canvas.mouse_grabber != self.ax:\n             event.canvas.grab_mouse(self.ax)\n \n+\n     def _release(self, event):\n         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n             return\n@@ -253,6 +254,7 @@ class Button(AxesWidget):\n         self._observers.disconnect(cid)\n \n \n+\n class SliderBase(AxesWidget):\n     \"\"\"\n     The base class for constructing Slider widgets. Not intended for direct\n@@ -820,6 +822,7 @@ class RangeSlider(SliderBase):\n         else:\n             verts[0] = verts[4] = vmin, .25\n             verts[1] = vmin, .75\n+\n             verts[2] = vmax, .75\n             verts[3] = vmax, .25\n \n@@ -882,6 +885,9 @@ class RangeSlider(SliderBase):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n             self._active_handle = None\n+            # Trigger callbacks after releasing mouse grab, following Button's pattern\n+            if self.eventson:\n+                self._observers.process(\"changed\", self.val)\n             return\n \n         # determine which handle was grabbed\n@@ -939,6 +945,7 @@ class RangeSlider(SliderBase):\n         \"\"\"\n         self.set_val((self.val[0], max))\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -965,7 +972,9 @@ class RangeSlider(SliderBase):\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        # Only trigger callbacks if not in active drag state\n+        # This prevents interference when plt.clf() and plt.draw() are called in callbacks\n+        if self.eventson and not self.drag_active:\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_0": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..c095994c26 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -220,9 +220,11 @@ class Button(AxesWidget):\n         if event.canvas.mouse_grabber != self.ax:\n             event.canvas.grab_mouse(self.ax)\n \n+\n     def _release(self, event):\n         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n             return\n+        # Release mouse grab BEFORE triggering any callbacks to prevent interference\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n             self._observers.process('clicked', event)\n@@ -253,6 +255,7 @@ class Button(AxesWidget):\n         self._observers.disconnect(cid)\n \n \n+\n class SliderBase(AxesWidget):\n     \"\"\"\n     The base class for constructing Slider widgets. Not intended for direct\n@@ -275,6 +278,7 @@ class SliderBase(AxesWidget):\n         self.valmax = valmax\n         self.valstep = valstep\n         self.drag_active = False\n+        self._callback_blocked = False\n         self.valfmt = valfmt\n \n         if orientation == \"vertical\":\n@@ -820,49 +824,44 @@ class RangeSlider(SliderBase):\n         else:\n             verts[0] = verts[4] = vmin, .25\n             verts[1] = vmin, .75\n-            verts[2] = vmax, .75\n-            verts[3] = vmax, .25\n-\n-    def _min_in_bounds(self, min):\n-        \"\"\"Ensure the new min value is between valmin and self.val[1].\"\"\"\n-        if min <= self.valmin:\n-            if not self.closedmin:\n-                return self.val[0]\n-            min = self.valmin\n \n-        if min > self.val[1]:\n-            min = self.val[1]\n-        return self._stepped_value(min)\n+def set_val(self, val):\n+    \"\"\"\n+    Set the value of the slider.\n \n-    def _max_in_bounds(self, max):\n-        \"\"\"Ensure the new max value is between valmax and self.val[0].\"\"\"\n-        if max >= self.valmax:\n-            if not self.closedmax:\n-                return self.val[1]\n-            max = self.valmax\n-\n-        if max <= self.val[0]:\n-            max = self.val[0]\n-        return self._stepped_value(max)\n-\n-    def _value_in_bounds(self, vals):\n-        \"\"\"Clip min, max values to the bounds.\"\"\"\n-        return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n-\n-    def _update_val_from_pos(self, pos):\n-        \"\"\"Update the slider value based on a given position.\"\"\"\n-        idx = np.argmin(np.abs(self.val - pos))\n-        if idx == 0:\n-            val = self._min_in_bounds(pos)\n-            self.set_min(val)\n-        else:\n-            val = self._max_in_bounds(pos)\n-            self.set_max(val)\n-        if self._active_handle:\n-            if self.orientation == \"vertical\":\n-                self._active_handle.set_ydata([val])\n-            else:\n-                self._active_handle.set_xdata([val])\n+    Parameters\n+    ----------\n+    val : array-like\n+        The new value for the slider.  This will be forced to be within\n+        the bounds of the slider.\n+    \"\"\"\n+    val = np.sort(val)\n+    _api.check_shape((2,), val=val)\n+    val[0] = self._min_in_bounds(val[0])\n+    val[1] = self._max_in_bounds(val[1])\n+    xy = self.poly.xy\n+    if self.orientation == \"vertical\":\n+        xy[0] = .25, val[0]\n+        xy[1] = .25, val[1]\n+        xy[2] = .75, val[1]\n+        xy[3] = .75, val[0]\n+        xy[4] = .25, val[0]\n+    else:\n+        xy[0] = val[0], .25\n+        xy[1] = val[0], .75\n+        xy[2] = val[1], .75\n+        xy[3] = val[1], .25\n+        xy[4] = val[0], .25\n+    if self.drawon:\n+        self.ax.figure.canvas.draw_idle()\n+    self.val = val\n+    if not np.array_equal(self.val, val):\n+        return\n+    # Only trigger callbacks if we're not in an active drag operation\n+    # to prevent interference with plt.clf()/plt.draw() operations\n+    if not getattr(self, 'drag_active', False):\n+        for cid, func in self.observers.items():\n+            func(val)\n \n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n@@ -882,6 +881,10 @@ class RangeSlider(SliderBase):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n             self._active_handle = None\n+            # Trigger any pending callbacks after mouse is released\n+            if hasattr(self, '_pending_callback') and self._pending_callback:\n+                self._call_observers('changed', self.val)\n+                self._pending_callback = False\n             return\n \n         # determine which handle was grabbed\n@@ -939,34 +942,38 @@ class RangeSlider(SliderBase):\n         \"\"\"\n         self.set_val((self.val[0], max))\n \n-    def set_val(self, val):\n-        \"\"\"\n-        Set slider value to *val*.\n \n-        Parameters\n-        ----------\n-        val : tuple or array-like of float\n-        \"\"\"\n-        val = np.sort(val)\n-        _api.check_shape((2,), val=val)\n-        # Reset value to allow _value_in_bounds() to work.\n-        self.val = (self.valmin, self.valmax)\n-        vmin, vmax = self._value_in_bounds(val)\n-        self._update_selection_poly(vmin, vmax)\n-        if self.orientation == \"vertical\":\n-            self._handles[0].set_ydata([vmin])\n-            self._handles[1].set_ydata([vmax])\n-        else:\n-            self._handles[0].set_xdata([vmin])\n-            self._handles[1].set_xdata([vmax])\n-\n-        self.valtext.set_text(self._format((vmin, vmax)))\n+def set_val(self, val):\n+    \"\"\"\n+    Set slider value to *val*.\n \n-        if self.drawon:\n-            self.ax.figure.canvas.draw_idle()\n-        self.val = (vmin, vmax)\n-        if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+    Parameters\n+    ----------\n+    val : tuple or array-like of float\n+    \"\"\"\n+    val = np.sort(val)\n+    _api.check_shape((2,), val=val)\n+    # Reset value to allow _value_in_bounds() to work.\n+    self.val = (self.valmin, self.valmax)\n+    vmin, vmax = self._value_in_bounds(val)\n+    self._update_selection_poly(vmin, vmax)\n+    if self.orientation == \"vertical\":\n+        self._handles[0].set_ydata([vmin])\n+        self._handles[1].set_ydata([vmax])\n+    else:\n+        self._handles[0].set_xdata([vmin])\n+        self._handles[1].set_xdata([vmax])\n+\n+    self.valtext.set_text(self._format((vmin, vmax)))\n+\n+    if self.drawon:\n+        self.ax.figure.canvas.draw_idle()\n+    self.val = (vmin, vmax)\n+    \n+    # Only trigger callbacks if we're not in the middle of a drag operation\n+    # to prevent interference with mouse grab/release handling\n+    if self.eventson and not getattr(self, '_dragging', False):\n+        self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_1": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..1484b139a7 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -220,9 +220,11 @@ class Button(AxesWidget):\n         if event.canvas.mouse_grabber != self.ax:\n             event.canvas.grab_mouse(self.ax)\n \n+\n     def _release(self, event):\n         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n             return\n+        # Release mouse grab BEFORE triggering callbacks to prevent interference\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n             self._observers.process('clicked', event)\n@@ -253,6 +255,7 @@ class Button(AxesWidget):\n         self._observers.disconnect(cid)\n \n \n+\n class SliderBase(AxesWidget):\n     \"\"\"\n     The base class for constructing Slider widgets. Not intended for direct\n@@ -275,6 +278,7 @@ class SliderBase(AxesWidget):\n         self.valmax = valmax\n         self.valstep = valstep\n         self.drag_active = False\n+        self._pending_callbacks = []\n         self.valfmt = valfmt\n \n         if orientation == \"vertical\":\n@@ -313,6 +317,16 @@ class SliderBase(AxesWidget):\n                 )\n             val = valstep[np.argmin(np.abs(valstep - val))]\n         return val\n+            val = (self.valmin\n+                   + round((val - self.valmin) / self.valstep) * self.valstep)\n+        elif self.valstep is not None:\n+            valstep = np.asanyarray(self.valstep)\n+            if valstep.ndim != 1:\n+                raise ValueError(\n+                    f\"valstep must have 1 dimension but has {valstep.ndim}\"\n+                )\n+            val = valstep[np.argmin(np.abs(valstep - val))]\n+        return val\n \n     def disconnect(self, cid):\n         \"\"\"\n@@ -820,34 +834,6 @@ class RangeSlider(SliderBase):\n         else:\n             verts[0] = verts[4] = vmin, .25\n             verts[1] = vmin, .75\n-            verts[2] = vmax, .75\n-            verts[3] = vmax, .25\n-\n-    def _min_in_bounds(self, min):\n-        \"\"\"Ensure the new min value is between valmin and self.val[1].\"\"\"\n-        if min <= self.valmin:\n-            if not self.closedmin:\n-                return self.val[0]\n-            min = self.valmin\n-\n-        if min > self.val[1]:\n-            min = self.val[1]\n-        return self._stepped_value(min)\n-\n-    def _max_in_bounds(self, max):\n-        \"\"\"Ensure the new max value is between valmax and self.val[0].\"\"\"\n-        if max >= self.valmax:\n-            if not self.closedmax:\n-                return self.val[1]\n-            max = self.valmax\n-\n-        if max <= self.val[0]:\n-            max = self.val[0]\n-        return self._stepped_value(max)\n-\n-    def _value_in_bounds(self, vals):\n-        \"\"\"Clip min, max values to the bounds.\"\"\"\n-        return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n@@ -864,6 +850,37 @@ class RangeSlider(SliderBase):\n             else:\n                 self._active_handle.set_xdata([val])\n \n+    def _update(self, event):\n+        \"\"\"Update the slider position.\"\"\"\n+        if self.ignore(event) or event.button != 1:\n+            return\n+\n+        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+            self.drag_active = True\n+            event.canvas.grab_mouse(self.ax)\n+\n+        if not self.drag_active:\n+            return\n+\n+        if event.name == \"button_release_event\":\n+            # Release mouse grab BEFORE triggering any callbacks\n+            if self.drag_active:\n+                event.canvas.release_mouse(self.ax)\n+                self.drag_active = False\n+            return\n+\n+        if event.inaxes == self.ax:\n+            if self.orientation == \"vertical\":\n+                pos = self._min_in_bounds(event.ydata)\n+            else:\n+                pos = self._min_in_bounds(event.xdata)\n+            \n+            # Only update position during drag, don't trigger callbacks yet\n+            self._update_val_from_pos(pos)\n+\n+        if self.drawon:\n+            self.ax.figure.canvas.draw_idle()\n+\n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n         if self.ignore(event) or event.button != 1:\n@@ -882,6 +899,9 @@ class RangeSlider(SliderBase):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n             self._active_handle = None\n+            # Trigger callbacks after releasing mouse grab\n+            if event.name == \"button_release_event\":\n+                self._observers.process('changed', self.val)\n             return\n \n         # determine which handle was grabbed\n@@ -939,6 +959,7 @@ class RangeSlider(SliderBase):\n         \"\"\"\n         self.set_val((self.val[0], max))\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -965,7 +986,10 @@ class RangeSlider(SliderBase):\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        \n+        # Only trigger callbacks if we're not in the middle of a drag operation\n+        # This prevents interference with mouse grab state during plt.clf()/plt.draw()\n+        if self.eventson and not getattr(self, '_dragging', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_2": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..6b3ce664d7 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -220,11 +220,16 @@ class Button(AxesWidget):\n         if event.canvas.mouse_grabber != self.ax:\n             event.canvas.grab_mouse(self.ax)\n \n+\n     def _release(self, event):\n         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n             return\n+        # Release mouse grab BEFORE triggering any callbacks\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n+            # Ensure any pending state updates are flushed before callback\n+            if hasattr(self, '_active') and self._active:\n+                self._active = False\n             self._observers.process('clicked', event)\n \n     def _motion(self, event):\n@@ -253,6 +258,7 @@ class Button(AxesWidget):\n         self._observers.disconnect(cid)\n \n \n+\n class SliderBase(AxesWidget):\n     \"\"\"\n     The base class for constructing Slider widgets. Not intended for direct\n@@ -275,6 +281,7 @@ class SliderBase(AxesWidget):\n         self.valmax = valmax\n         self.valstep = valstep\n         self.drag_active = False\n+        self._pending_callbacks = False\n         self.valfmt = valfmt\n \n         if orientation == \"vertical\":\n@@ -820,44 +827,16 @@ class RangeSlider(SliderBase):\n         else:\n             verts[0] = verts[4] = vmin, .25\n             verts[1] = vmin, .75\n-            verts[2] = vmax, .75\n-            verts[3] = vmax, .25\n-\n-    def _min_in_bounds(self, min):\n-        \"\"\"Ensure the new min value is between valmin and self.val[1].\"\"\"\n-        if min <= self.valmin:\n-            if not self.closedmin:\n-                return self.val[0]\n-            min = self.valmin\n-\n-        if min > self.val[1]:\n-            min = self.val[1]\n-        return self._stepped_value(min)\n-\n-    def _max_in_bounds(self, max):\n-        \"\"\"Ensure the new max value is between valmax and self.val[0].\"\"\"\n-        if max >= self.valmax:\n-            if not self.closedmax:\n-                return self.val[1]\n-            max = self.valmax\n-\n-        if max <= self.val[0]:\n-            max = self.val[0]\n-        return self._stepped_value(max)\n-\n-    def _value_in_bounds(self, vals):\n-        \"\"\"Clip min, max values to the bounds.\"\"\"\n-        return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, trigger_callback=not self.drag_active)\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, trigger_callback=not self.drag_active)\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -876,34 +855,68 @@ class RangeSlider(SliderBase):\n         if not self.drag_active:\n             return\n \n-        elif (event.name == \"button_release_event\") or (\n-            event.name == \"button_press_event\" and event.inaxes != self.ax\n-        ):\n+        if event.name == \"button_release_event\":\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n-            self._active_handle = None\n+            # Trigger callback after releasing mouse grab\n+            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n+                self.eventson = True\n+                self._observers.process('changed', self.val)\n+                self._deferred_callback = False\n+            return\n+\n+        if event.inaxes != self.ax:\n             return\n \n-        # determine which handle was grabbed\n         if self.orientation == \"vertical\":\n-            handle_index = np.argmin(\n-                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n-            )\n+            pos = self._value_in_bounds((event.ydata,) * 2)[0]\n         else:\n-            handle_index = np.argmin(\n-                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n-            )\n-        handle = self._handles[handle_index]\n+            pos = self._value_in_bounds((event.xdata,) * 2)[0]\n+        self._update_val_from_pos(pos)\n \n-        # these checks ensure smooth behavior if the handles swap which one\n-        # has a higher value. i.e. if one is dragged over and past the other.\n-        if handle is not self._active_handle:\n-            self._active_handle = handle\n+def _update(self, event):\n+    \"\"\"Update the slider position.\"\"\"\n+    if self.ignore(event) or event.button != 1:\n+        return\n \n-        if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n-        else:\n-            self._update_val_from_pos(event.xdata)\n+    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+        self.drag_active = True\n+        event.canvas.grab_mouse(self.ax)\n+\n+    if not self.drag_active:\n+        return\n+\n+    elif (event.name == \"button_release_event\") or (\n+        event.name == \"button_press_event\" and event.inaxes != self.ax\n+    ):\n+        self.drag_active = False\n+        event.canvas.release_mouse(self.ax)\n+        self._active_handle = None\n+        # Trigger callbacks after releasing mouse grab\n+        if event.name == \"button_release_event\":\n+            self._observers.process('changed', self.val)\n+        return\n+\n+    # determine which handle was grabbed\n+    if self.orientation == \"vertical\":\n+        handle_index = np.argmin(\n+            np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+        )\n+    else:\n+        handle_index = np.argmin(\n+            np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+        )\n+    handle = self._handles[handle_index]\n+\n+    # these checks ensure smooth behavior if the handles swap which one\n+    # has a higher value. i.e. if one is dragged over and past the other.\n+    if handle is not self._active_handle:\n+        self._active_handle = handle\n+\n+    if self.orientation == \"vertical\":\n+        self._update_val_from_pos(event.ydata)\n+    else:\n+        self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -939,33 +952,41 @@ class RangeSlider(SliderBase):\n         \"\"\"\n         self.set_val((self.val[0], max))\n \n-    def set_val(self, val):\n-        \"\"\"\n-        Set slider value to *val*.\n-\n-        Parameters\n-        ----------\n-        val : tuple or array-like of float\n-        \"\"\"\n-        val = np.sort(val)\n-        _api.check_shape((2,), val=val)\n-        # Reset value to allow _value_in_bounds() to work.\n-        self.val = (self.valmin, self.valmax)\n-        vmin, vmax = self._value_in_bounds(val)\n-        self._update_selection_poly(vmin, vmax)\n-        if self.orientation == \"vertical\":\n-            self._handles[0].set_ydata([vmin])\n-            self._handles[1].set_ydata([vmax])\n-        else:\n-            self._handles[0].set_xdata([vmin])\n-            self._handles[1].set_xdata([vmax])\n \n-        self.valtext.set_text(self._format((vmin, vmax)))\n+def set_val(self, val):\n+    \"\"\"\n+    Set slider value to *val*.\n \n-        if self.drawon:\n-            self.ax.figure.canvas.draw_idle()\n-        self.val = (vmin, vmax)\n-        if self.eventson:\n+    Parameters\n+    ----------\n+    val : tuple or array-like of float\n+    \"\"\"\n+    val = np.sort(val)\n+    _api.check_shape((2,), val=val)\n+    # Reset value to allow _value_in_bounds() to work.\n+    self.val = (self.valmin, self.valmax)\n+    vmin, vmax = self._value_in_bounds(val)\n+    self._update_selection_poly(vmin, vmax)\n+    if self.orientation == \"vertical\":\n+        self._handles[0].set_ydata([vmin])\n+        self._handles[1].set_ydata([vmax])\n+    else:\n+        self._handles[0].set_xdata([vmin])\n+        self._handles[1].set_xdata([vmax])\n+\n+    self.valtext.set_text(self._format((vmin, vmax)))\n+\n+    if self.drawon:\n+        self.ax.figure.canvas.draw_idle()\n+    self.val = (vmin, vmax)\n+    \n+    # Defer callback execution if we're in the middle of a drag operation\n+    # to prevent interference with mouse grab state\n+    if self.eventson:\n+        if hasattr(self, '_active') and self._active:\n+            # Store callback for later execution when drag completes\n+            self._pending_callback = (vmin, vmax)\n+        else:\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_3": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..f8af1c620e 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -220,9 +220,12 @@ class Button(AxesWidget):\n         if event.canvas.mouse_grabber != self.ax:\n             event.canvas.grab_mouse(self.ax)\n \n+\n     def _release(self, event):\n         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n             return\n+        # Release mouse grab BEFORE processing callbacks to prevent interference\n+        # with operations like plt.clf() and plt.draw() in callbacks\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n             self._observers.process('clicked', event)\n@@ -253,6 +256,7 @@ class Button(AxesWidget):\n         self._observers.disconnect(cid)\n \n \n+\n class SliderBase(AxesWidget):\n     \"\"\"\n     The base class for constructing Slider widgets. Not intended for direct\n@@ -275,6 +279,7 @@ class SliderBase(AxesWidget):\n         self.valmax = valmax\n         self.valstep = valstep\n         self.drag_active = False\n+        self._pending_callback = False\n         self.valfmt = valfmt\n \n         if orientation == \"vertical\":\n@@ -820,34 +825,6 @@ class RangeSlider(SliderBase):\n         else:\n             verts[0] = verts[4] = vmin, .25\n             verts[1] = vmin, .75\n-            verts[2] = vmax, .75\n-            verts[3] = vmax, .25\n-\n-    def _min_in_bounds(self, min):\n-        \"\"\"Ensure the new min value is between valmin and self.val[1].\"\"\"\n-        if min <= self.valmin:\n-            if not self.closedmin:\n-                return self.val[0]\n-            min = self.valmin\n-\n-        if min > self.val[1]:\n-            min = self.val[1]\n-        return self._stepped_value(min)\n-\n-    def _max_in_bounds(self, max):\n-        \"\"\"Ensure the new max value is between valmax and self.val[0].\"\"\"\n-        if max >= self.valmax:\n-            if not self.closedmax:\n-                return self.val[1]\n-            max = self.valmax\n-\n-        if max <= self.val[0]:\n-            max = self.val[0]\n-        return self._stepped_value(max)\n-\n-    def _value_in_bounds(self, vals):\n-        \"\"\"Clip min, max values to the bounds.\"\"\"\n-        return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n@@ -864,6 +841,39 @@ class RangeSlider(SliderBase):\n             else:\n                 self._active_handle.set_xdata([val])\n \n+    def _update(self, event):\n+        \"\"\"Update the slider position.\"\"\"\n+        if self.ignore(event) or event.button != 1:\n+            return\n+\n+        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+            self.drag_active = True\n+            event.canvas.grab_mouse(self.ax)\n+\n+        if not self.drag_active:\n+            return\n+\n+        if event.name == \"button_release_event\":\n+            self.drag_active = False\n+            event.canvas.release_mouse(self.ax)\n+            # Trigger callbacks after releasing mouse grab\n+            self._observers.process('changed', self.val)\n+            return\n+\n+        if event.name == \"motion_notify_event\":\n+            if self.orientation == \"vertical\":\n+                pos = self._get_data_interval()[0] + event.ydata * np.ptp(self._get_data_interval())\n+            else:\n+                pos = self._get_data_interval()[0] + event.xdata * np.ptp(self._get_data_interval())\n+            \n+            # Update position without triggering callbacks during drag\n+            old_val = self.val\n+            self._update_val_from_pos(pos)\n+            \n+            # Only update visual elements during drag, not callbacks\n+            if self.drawon:\n+                self.ax.figure.canvas.draw_idle()\n+\n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n         if self.ignore(event) or event.button != 1:\n@@ -882,6 +892,9 @@ class RangeSlider(SliderBase):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n             self._active_handle = None\n+            # Trigger callbacks after releasing mouse grab\n+            if event.name == \"button_release_event\":\n+                self._observers.process('changed', self.val)\n             return\n \n         # determine which handle was grabbed\n@@ -939,6 +952,7 @@ class RangeSlider(SliderBase):\n         \"\"\"\n         self.set_val((self.val[0], max))\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -965,8 +979,15 @@ class RangeSlider(SliderBase):\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n+        \n+        # Defer callback execution if we're in the middle of a drag operation\n+        # to prevent interference with mouse event handling\n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            if hasattr(self, '_active') and self._active:\n+                # Store the callback for later execution when drag ends\n+                self._pending_callback = (vmin, vmax)\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_4": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..14213cd182 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -220,9 +220,11 @@ class Button(AxesWidget):\n         if event.canvas.mouse_grabber != self.ax:\n             event.canvas.grab_mouse(self.ax)\n \n+\n     def _release(self, event):\n         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n             return\n+        # Release mouse grab FIRST before triggering any callbacks\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n             self._observers.process('clicked', event)\n@@ -253,6 +255,7 @@ class Button(AxesWidget):\n         self._observers.disconnect(cid)\n \n \n+\n class SliderBase(AxesWidget):\n     \"\"\"\n     The base class for constructing Slider widgets. Not intended for direct\n@@ -275,6 +278,7 @@ class SliderBase(AxesWidget):\n         self.valmax = valmax\n         self.valstep = valstep\n         self.drag_active = False\n+        self._mouse_grabbed = False\n         self.valfmt = valfmt\n \n         if orientation == \"vertical\":\n@@ -820,34 +824,6 @@ class RangeSlider(SliderBase):\n         else:\n             verts[0] = verts[4] = vmin, .25\n             verts[1] = vmin, .75\n-            verts[2] = vmax, .75\n-            verts[3] = vmax, .25\n-\n-    def _min_in_bounds(self, min):\n-        \"\"\"Ensure the new min value is between valmin and self.val[1].\"\"\"\n-        if min <= self.valmin:\n-            if not self.closedmin:\n-                return self.val[0]\n-            min = self.valmin\n-\n-        if min > self.val[1]:\n-            min = self.val[1]\n-        return self._stepped_value(min)\n-\n-    def _max_in_bounds(self, max):\n-        \"\"\"Ensure the new max value is between valmax and self.val[0].\"\"\"\n-        if max >= self.valmax:\n-            if not self.closedmax:\n-                return self.val[1]\n-            max = self.valmax\n-\n-        if max <= self.val[0]:\n-            max = self.val[0]\n-        return self._stepped_value(max)\n-\n-    def _value_in_bounds(self, vals):\n-        \"\"\"Clip min, max values to the bounds.\"\"\"\n-        return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n@@ -876,34 +852,77 @@ class RangeSlider(SliderBase):\n         if not self.drag_active:\n             return\n \n-        elif (event.name == \"button_release_event\") or (\n-            event.name == \"button_press_event\" and event.inaxes != self.ax\n-        ):\n+        elif event.name == \"button_release_event\" \\\n+                or event.name == \"button_press_event\":\n+            if event.inaxes != self.ax:\n+                return\n+            self._determine_active_handle(event)\n+        elif event.name == \"motion_notify_event\":\n+            if event.inaxes != self.ax:\n+                return\n+\n+        pos = self._get_data_coords(event)\n+        lastval = self.val.copy()\n+        self._update_val_from_pos(pos)\n+        if lastval != self.val:\n+            self.poly.xy = self._update_selection_poly()\n+            if self.drawon:\n+                self.ax.figure.canvas.draw_idle()\n+            # Only trigger callbacks when not in active drag or on release\n+            if event.name == \"button_release_event\" or not self.drag_active:\n+                self._observers.process('changed', self.val.copy())\n+\n+        if event.name == \"button_release_event\":\n             self.drag_active = False\n+            # Release mouse grab before any potential callbacks\n             event.canvas.release_mouse(self.ax)\n             self._active_handle = None\n-            return\n \n-        # determine which handle was grabbed\n-        if self.orientation == \"vertical\":\n-            handle_index = np.argmin(\n-                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n-            )\n-        else:\n-            handle_index = np.argmin(\n-                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n-            )\n-        handle = self._handles[handle_index]\n+def _update(self, event):\n+    \"\"\"Update the slider position.\"\"\"\n+    if self.ignore(event) or event.button != 1:\n+        return\n \n-        # these checks ensure smooth behavior if the handles swap which one\n-        # has a higher value. i.e. if one is dragged over and past the other.\n-        if handle is not self._active_handle:\n-            self._active_handle = handle\n+    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+        self.drag_active = True\n+        event.canvas.grab_mouse(self.ax)\n \n-        if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n-        else:\n-            self._update_val_from_pos(event.xdata)\n+    if not self.drag_active:\n+        return\n+\n+    elif (event.name == \"button_release_event\") or (\n+        event.name == \"button_press_event\" and event.inaxes != self.ax\n+    ):\n+        # Release mouse grab BEFORE triggering any callbacks\n+        self.drag_active = False\n+        event.canvas.release_mouse(self.ax)\n+        self._active_handle = None\n+        \n+        # Trigger callbacks after mouse is released\n+        if event.name == \"button_release_event\":\n+            self._observers.process('changed', self.val)\n+        return\n+\n+    # determine which handle was grabbed\n+    if self.orientation == \"vertical\":\n+        handle_index = np.argmin(\n+            np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+        )\n+    else:\n+        handle_index = np.argmin(\n+            np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+        )\n+    handle = self._handles[handle_index]\n+\n+    # these checks ensure smooth behavior if the handles swap which one\n+    # has a higher value. i.e. if one is dragged over and past the other.\n+    if handle is not self._active_handle:\n+        self._active_handle = handle\n+\n+    if self.orientation == \"vertical\":\n+        self._update_val_from_pos(event.ydata)\n+    else:\n+        self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -939,33 +958,41 @@ class RangeSlider(SliderBase):\n         \"\"\"\n         self.set_val((self.val[0], max))\n \n-    def set_val(self, val):\n-        \"\"\"\n-        Set slider value to *val*.\n \n-        Parameters\n-        ----------\n-        val : tuple or array-like of float\n-        \"\"\"\n-        val = np.sort(val)\n-        _api.check_shape((2,), val=val)\n-        # Reset value to allow _value_in_bounds() to work.\n-        self.val = (self.valmin, self.valmax)\n-        vmin, vmax = self._value_in_bounds(val)\n-        self._update_selection_poly(vmin, vmax)\n-        if self.orientation == \"vertical\":\n-            self._handles[0].set_ydata([vmin])\n-            self._handles[1].set_ydata([vmax])\n-        else:\n-            self._handles[0].set_xdata([vmin])\n-            self._handles[1].set_xdata([vmax])\n-\n-        self.valtext.set_text(self._format((vmin, vmax)))\n+def set_val(self, val):\n+    \"\"\"\n+    Set slider value to *val*.\n \n-        if self.drawon:\n-            self.ax.figure.canvas.draw_idle()\n-        self.val = (vmin, vmax)\n-        if self.eventson:\n+    Parameters\n+    ----------\n+    val : tuple or array-like of float\n+    \"\"\"\n+    val = np.sort(val)\n+    _api.check_shape((2,), val=val)\n+    # Reset value to allow _value_in_bounds() to work.\n+    self.val = (self.valmin, self.valmax)\n+    vmin, vmax = self._value_in_bounds(val)\n+    self._update_selection_poly(vmin, vmax)\n+    if self.orientation == \"vertical\":\n+        self._handles[0].set_ydata([vmin])\n+        self._handles[1].set_ydata([vmax])\n+    else:\n+        self._handles[0].set_xdata([vmin])\n+        self._handles[1].set_xdata([vmax])\n+\n+    self.valtext.set_text(self._format((vmin, vmax)))\n+\n+    if self.drawon:\n+        self.ax.figure.canvas.draw_idle()\n+    self.val = (vmin, vmax)\n+    \n+    # Defer callback execution if we're in the middle of a drag operation\n+    if self.eventson:\n+        # Check if we're currently dragging by seeing if we have active mouse capture\n+        if hasattr(self, '_active') and self._active:\n+            # Store the callback for later execution\n+            self._pending_callback = (vmin, vmax)\n+        else:\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_5": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..75600d73f4 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -220,9 +220,11 @@ class Button(AxesWidget):\n         if event.canvas.mouse_grabber != self.ax:\n             event.canvas.grab_mouse(self.ax)\n \n+\n     def _release(self, event):\n         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n             return\n+        # Release mouse grab FIRST before triggering any callbacks\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n             self._observers.process('clicked', event)\n@@ -253,6 +255,7 @@ class Button(AxesWidget):\n         self._observers.disconnect(cid)\n \n \n+\n class SliderBase(AxesWidget):\n     \"\"\"\n     The base class for constructing Slider widgets. Not intended for direct\n@@ -275,6 +278,7 @@ class SliderBase(AxesWidget):\n         self.valmax = valmax\n         self.valstep = valstep\n         self.drag_active = False\n+        self._in_drag_state = False  # Track if currently in a drag operation\n         self.valfmt = valfmt\n \n         if orientation == \"vertical\":\n@@ -820,34 +824,6 @@ class RangeSlider(SliderBase):\n         else:\n             verts[0] = verts[4] = vmin, .25\n             verts[1] = vmin, .75\n-            verts[2] = vmax, .75\n-            verts[3] = vmax, .25\n-\n-    def _min_in_bounds(self, min):\n-        \"\"\"Ensure the new min value is between valmin and self.val[1].\"\"\"\n-        if min <= self.valmin:\n-            if not self.closedmin:\n-                return self.val[0]\n-            min = self.valmin\n-\n-        if min > self.val[1]:\n-            min = self.val[1]\n-        return self._stepped_value(min)\n-\n-    def _max_in_bounds(self, max):\n-        \"\"\"Ensure the new max value is between valmax and self.val[0].\"\"\"\n-        if max >= self.valmax:\n-            if not self.closedmax:\n-                return self.val[1]\n-            max = self.valmax\n-\n-        if max <= self.val[0]:\n-            max = self.val[0]\n-        return self._stepped_value(max)\n-\n-    def _value_in_bounds(self, vals):\n-        \"\"\"Clip min, max values to the bounds.\"\"\"\n-        return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n@@ -864,6 +840,31 @@ class RangeSlider(SliderBase):\n             else:\n                 self._active_handle.set_xdata([val])\n \n+    def _update(self, event):\n+        \"\"\"Update the slider position.\"\"\"\n+        if self.ignore(event) or event.button != 1:\n+            return\n+\n+        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+            self.drag_active = True\n+            event.canvas.grab_mouse(self.ax)\n+\n+        if not self.drag_active:\n+            return\n+\n+        if event.name == \"button_release_event\":\n+            self.drag_active = False\n+            event.canvas.release_mouse(self.ax)\n+            # Trigger callbacks after releasing mouse grab\n+            self._observers.process('changed', self.val)\n+            return\n+\n+        if event.name == \"motion_notify_event\":\n+            if self.orientation == \"vertical\":\n+                self._update_val_from_pos(event.ydata)\n+            else:\n+                self._update_val_from_pos(event.xdata)\n+\n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n         if self.ignore(event) or event.button != 1:\n@@ -882,6 +883,8 @@ class RangeSlider(SliderBase):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n             self._active_handle = None\n+            # Trigger callbacks after releasing mouse grab\n+            self._observers.process('changed', self.val)\n             return\n \n         # determine which handle was grabbed\n@@ -939,34 +942,37 @@ class RangeSlider(SliderBase):\n         \"\"\"\n         self.set_val((self.val[0], max))\n \n-    def set_val(self, val):\n-        \"\"\"\n-        Set slider value to *val*.\n-\n-        Parameters\n-        ----------\n-        val : tuple or array-like of float\n-        \"\"\"\n-        val = np.sort(val)\n-        _api.check_shape((2,), val=val)\n-        # Reset value to allow _value_in_bounds() to work.\n-        self.val = (self.valmin, self.valmax)\n-        vmin, vmax = self._value_in_bounds(val)\n-        self._update_selection_poly(vmin, vmax)\n-        if self.orientation == \"vertical\":\n-            self._handles[0].set_ydata([vmin])\n-            self._handles[1].set_ydata([vmax])\n-        else:\n-            self._handles[0].set_xdata([vmin])\n-            self._handles[1].set_xdata([vmax])\n \n-        self.valtext.set_text(self._format((vmin, vmax)))\n+def set_val(self, val):\n+    \"\"\"\n+    Set slider value to *val*.\n \n-        if self.drawon:\n-            self.ax.figure.canvas.draw_idle()\n-        self.val = (vmin, vmax)\n-        if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+    Parameters\n+    ----------\n+    val : tuple or array-like of float\n+    \"\"\"\n+    val = np.sort(val)\n+    _api.check_shape((2,), val=val)\n+    # Reset value to allow _value_in_bounds() to work.\n+    self.val = (self.valmin, self.valmax)\n+    vmin, vmax = self._value_in_bounds(val)\n+    self._update_selection_poly(vmin, vmax)\n+    if self.orientation == \"vertical\":\n+        self._handles[0].set_ydata([vmin])\n+        self._handles[1].set_ydata([vmax])\n+    else:\n+        self._handles[0].set_xdata([vmin])\n+        self._handles[1].set_xdata([vmax])\n+\n+    self.valtext.set_text(self._format((vmin, vmax)))\n+\n+    if self.drawon:\n+        self.ax.figure.canvas.draw_idle()\n+    self.val = (vmin, vmax)\n+    \n+    # Only trigger callbacks if not in active drag state\n+    if self.eventson and not getattr(self, '_active', False):\n+        self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_6": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..bbe114446f 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -220,6 +220,7 @@ class Button(AxesWidget):\n         if event.canvas.mouse_grabber != self.ax:\n             event.canvas.grab_mouse(self.ax)\n \n+\n     def _release(self, event):\n         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n             return\n@@ -253,56 +254,53 @@ class Button(AxesWidget):\n         self._observers.disconnect(cid)\n \n \n-class SliderBase(AxesWidget):\n-    \"\"\"\n-    The base class for constructing Slider widgets. Not intended for direct\n-    usage.\n \n-    For the slider to remain responsive you must maintain a reference to it.\n-    \"\"\"\n-    def __init__(self, ax, orientation, closedmin, closedmax,\n-                 valmin, valmax, valfmt, dragging, valstep):\n-        if ax.name == '3d':\n-            raise ValueError('Sliders cannot be added to 3D Axes')\n-\n-        super().__init__(ax)\n-        _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)\n-\n-        self.orientation = orientation\n-        self.closedmin = closedmin\n-        self.closedmax = closedmax\n-        self.valmin = valmin\n-        self.valmax = valmax\n-        self.valstep = valstep\n-        self.drag_active = False\n-        self.valfmt = valfmt\n+def _update(self, event):\n+    \"\"\"Update the slider position.\"\"\"\n+    if self.ignore(event) or event.inaxes != self.ax:\n+        return\n \n-        if orientation == \"vertical\":\n-            ax.set_ylim((valmin, valmax))\n-            axis = ax.yaxis\n+    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+        self.drag_active = True\n+        xy = self.ax.transData.inverted().transform((event.x, event.y))\n+        if self.orientation == 'vertical':\n+            self._active_handle = self._handle_grabber(xy[1])\n         else:\n-            ax.set_xlim((valmin, valmax))\n-            axis = ax.xaxis\n-\n-        self._fmt = axis.get_major_formatter()\n-        if not isinstance(self._fmt, ticker.ScalarFormatter):\n-            self._fmt = ticker.ScalarFormatter()\n-            self._fmt.set_axis(axis)\n-        self._fmt.set_useOffset(False)  # No additive offset.\n-        self._fmt.set_useMathText(True)  # x sign before multiplicative offset.\n-\n-        ax.set_axis_off()\n-        ax.set_navigate(False)\n-\n-        self.connect_event(\"button_press_event\", self._update)\n-        self.connect_event(\"button_release_event\", self._update)\n-        if dragging:\n-            self.connect_event(\"motion_notify_event\", self._update)\n-        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+            self._active_handle = self._handle_grabber(xy[0])\n+\n+    if not self.drag_active:\n+        return\n+\n+    if self.orientation == 'vertical':\n+        val = self.ax.transData.inverted().transform((event.x, event.y))[1]\n+    else:\n+        val = self.ax.transData.inverted().transform((event.x, event.y))[0]\n+    val = self._stepped_value(val)\n+\n+    if self._active_handle:\n+        # Update the handle position but don't trigger callbacks yet during drag\n+        if self._active_handle == \"min\":\n+            if val <= self.val[1]:\n+                self.val = (val, self.val[1])\n+        elif self._active_handle == \"max\":\n+            if val >= self.val[0]:\n+                self.val = (self.val[0], val)\n+\n+        # Update visual representation\n+        self._update_selection_poly()\n+        \n+        # Only update display, don't trigger callbacks during active drag\n+        if self.drawon:\n+            self.ax.figure.canvas.draw_idle()\n \n-    def _stepped_value(self, val):\n-        \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n-        if isinstance(self.valstep, Number):\n+    # Handle button release - release drag first, then trigger callbacks\n+    if event.name == \"button_release_event\":\n+        self.drag_active = False\n+        self._active_handle = None\n+        # Now it's safe to trigger callbacks after drag is complete\n+        if not self.eventson:\n+            return\n+        self._observers.process(\"changed\", self.val)\n             val = (self.valmin\n                    + round((val - self.valmin) / self.valstep) * self.valstep)\n         elif self.valstep is not None:\n@@ -820,49 +818,44 @@ class RangeSlider(SliderBase):\n         else:\n             verts[0] = verts[4] = vmin, .25\n             verts[1] = vmin, .75\n-            verts[2] = vmax, .75\n-            verts[3] = vmax, .25\n \n-    def _min_in_bounds(self, min):\n-        \"\"\"Ensure the new min value is between valmin and self.val[1].\"\"\"\n-        if min <= self.valmin:\n-            if not self.closedmin:\n-                return self.val[0]\n-            min = self.valmin\n+    def _update(self, event):\n+        \"\"\"Update the slider position.\"\"\"\n+        if self.ignore(event) or event.button != 1:\n+            return\n \n-        if min > self.val[1]:\n-            min = self.val[1]\n-        return self._stepped_value(min)\n+        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+            self.drag_active = True\n+            event.canvas.grab_mouse(self.ax)\n \n-    def _max_in_bounds(self, max):\n-        \"\"\"Ensure the new max value is between valmax and self.val[0].\"\"\"\n-        if max >= self.valmax:\n-            if not self.closedmax:\n-                return self.val[1]\n-            max = self.valmax\n-\n-        if max <= self.val[0]:\n-            max = self.val[0]\n-        return self._stepped_value(max)\n-\n-    def _value_in_bounds(self, vals):\n-        \"\"\"Clip min, max values to the bounds.\"\"\"\n-        return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n-\n-    def _update_val_from_pos(self, pos):\n-        \"\"\"Update the slider value based on a given position.\"\"\"\n-        idx = np.argmin(np.abs(self.val - pos))\n-        if idx == 0:\n-            val = self._min_in_bounds(pos)\n-            self.set_min(val)\n-        else:\n-            val = self._max_in_bounds(pos)\n-            self.set_max(val)\n-        if self._active_handle:\n+        if not self.drag_active:\n+            return\n+\n+        if event.name == \"button_press_event\":\n+            # determine which handle is closest to the event\n             if self.orientation == \"vertical\":\n-                self._active_handle.set_ydata([val])\n+                self._active_handle = min(self._handles, key=lambda h:\n+                                        abs(h.get_ydata()[0] - event.ydata))\n             else:\n-                self._active_handle.set_xdata([val])\n+                self._active_handle = min(self._handles, key=lambda h:\n+                                        abs(h.get_xdata()[0] - event.xdata))\n+\n+        elif event.name == \"button_release_event\" \\\n+                or (event.name == \"motion_notify_event\" and\n+                    event.inaxes != self.ax):\n+            # Release mouse grab BEFORE any callbacks\n+            if self.drag_active:\n+                event.canvas.release_mouse(self.ax)\n+                self.drag_active = False\n+                self._active_handle = None\n+            return\n+\n+        # Update position during drag\n+        if event.inaxes == self.ax:\n+            if self.orientation == \"vertical\":\n+                self._update_val_from_pos(event.ydata)\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n@@ -882,6 +875,9 @@ class RangeSlider(SliderBase):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n             self._active_handle = None\n+            # Trigger callbacks after releasing mouse grab\n+            if event.name == \"button_release_event\":\n+                self._observers.process('changed', self.val)\n             return\n \n         # determine which handle was grabbed\n@@ -939,6 +935,7 @@ class RangeSlider(SliderBase):\n         \"\"\"\n         self.set_val((self.val[0], max))\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -965,7 +962,10 @@ class RangeSlider(SliderBase):\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        \n+        # Only trigger callbacks if not currently in an active drag operation\n+        # This prevents interference with mouse grab during plt.clf()/plt.draw()\n+        if self.eventson and not getattr(self, '_active', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_7": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..0200f19d7c 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -220,12 +220,21 @@ class Button(AxesWidget):\n         if event.canvas.mouse_grabber != self.ax:\n             event.canvas.grab_mouse(self.ax)\n \n-    def _release(self, event):\n-        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n-            return\n-        event.canvas.release_mouse(self.ax)\n-        if self.eventson and event.inaxes == self.ax:\n-            self._observers.process('clicked', event)\n+\n+def _release(self, event):\n+    if self.ignore(event):\n+        return\n+    \n+    # Only process if we actually have the mouse grab\n+    if event.canvas.mouse_grabber != self.ax:\n+        return\n+        \n+    # Release mouse grab first to prevent interference with callbacks\n+    event.canvas.release_mouse(self.ax)\n+    \n+    # Only trigger callback if the release happened over our axes\n+    if self.eventson and event.inaxes == self.ax:\n+        self._observers.process('clicked', event)\n \n     def _motion(self, event):\n         if self.ignore(event):\n@@ -253,6 +262,7 @@ class Button(AxesWidget):\n         self._observers.disconnect(cid)\n \n \n+\n class SliderBase(AxesWidget):\n     \"\"\"\n     The base class for constructing Slider widgets. Not intended for direct\n@@ -275,6 +285,8 @@ class SliderBase(AxesWidget):\n         self.valmax = valmax\n         self.valstep = valstep\n         self.drag_active = False\n+        self._callback_blocked = False  # Track if callbacks should be deferred\n+        self._pending_callback = False  # Track if callback is pending\n         self.valfmt = valfmt\n \n         if orientation == \"vertical\":\n@@ -820,49 +832,6 @@ class RangeSlider(SliderBase):\n         else:\n             verts[0] = verts[4] = vmin, .25\n             verts[1] = vmin, .75\n-            verts[2] = vmax, .75\n-            verts[3] = vmax, .25\n-\n-    def _min_in_bounds(self, min):\n-        \"\"\"Ensure the new min value is between valmin and self.val[1].\"\"\"\n-        if min <= self.valmin:\n-            if not self.closedmin:\n-                return self.val[0]\n-            min = self.valmin\n-\n-        if min > self.val[1]:\n-            min = self.val[1]\n-        return self._stepped_value(min)\n-\n-    def _max_in_bounds(self, max):\n-        \"\"\"Ensure the new max value is between valmax and self.val[0].\"\"\"\n-        if max >= self.valmax:\n-            if not self.closedmax:\n-                return self.val[1]\n-            max = self.valmax\n-\n-        if max <= self.val[0]:\n-            max = self.val[0]\n-        return self._stepped_value(max)\n-\n-    def _value_in_bounds(self, vals):\n-        \"\"\"Clip min, max values to the bounds.\"\"\"\n-        return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n-\n-    def _update_val_from_pos(self, pos):\n-        \"\"\"Update the slider value based on a given position.\"\"\"\n-        idx = np.argmin(np.abs(self.val - pos))\n-        if idx == 0:\n-            val = self._min_in_bounds(pos)\n-            self.set_min(val)\n-        else:\n-            val = self._max_in_bounds(pos)\n-            self.set_max(val)\n-        if self._active_handle:\n-            if self.orientation == \"vertical\":\n-                self._active_handle.set_ydata([val])\n-            else:\n-                self._active_handle.set_xdata([val])\n \n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n@@ -876,34 +845,72 @@ class RangeSlider(SliderBase):\n         if not self.drag_active:\n             return\n \n-        elif (event.name == \"button_release_event\") or (\n-            event.name == \"button_press_event\" and event.inaxes != self.ax\n-        ):\n-            self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n-            self._active_handle = None\n-            return\n+        elif event.name == \"button_release_event\":\n+            if self.drag_active:\n+                self.drag_active = False\n+                event.canvas.release_mouse(self.ax)\n \n-        # determine which handle was grabbed\n-        if self.orientation == \"vertical\":\n-            handle_index = np.argmin(\n-                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n-            )\n-        else:\n-            handle_index = np.argmin(\n-                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n-            )\n-        handle = self._handles[handle_index]\n+        if event.name == \"motion_notify_event\":\n+            if self.orientation == \"vertical\":\n+                self._update_val_from_pos(event.ydata)\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n-        # these checks ensure smooth behavior if the handles swap which one\n-        # has a higher value. i.e. if one is dragged over and past the other.\n-        if handle is not self._active_handle:\n-            self._active_handle = handle\n+        elif event.name == \"button_press_event\":\n+            if self.orientation == \"vertical\":\n+                self._update_val_from_pos(event.ydata)\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n-        if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n-        else:\n-            self._update_val_from_pos(event.xdata)\n+        elif event.name == \"button_release_event\":\n+            if self.orientation == \"vertical\":\n+                self._update_val_from_pos(event.ydata)\n+            else:\n+                self._update_val_from_pos(event.xdata)\n+\n+def _update(self, event):\n+    \"\"\"Update the slider position.\"\"\"\n+    if self.ignore(event) or event.button != 1:\n+        return\n+\n+    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+        self.drag_active = True\n+        event.canvas.grab_mouse(self.ax)\n+\n+    if not self.drag_active:\n+        return\n+\n+    elif (event.name == \"button_release_event\") or (\n+        event.name == \"button_press_event\" and event.inaxes != self.ax\n+    ):\n+        self.drag_active = False\n+        event.canvas.release_mouse(self.ax)\n+        self._active_handle = None\n+        # Trigger callbacks after releasing mouse grab\n+        if event.name == \"button_release_event\":\n+            self._observers.process('changed', self.val)\n+        return\n+\n+    # determine which handle was grabbed\n+    if self.orientation == \"vertical\":\n+        handle_index = np.argmin(\n+            np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+        )\n+    else:\n+        handle_index = np.argmin(\n+            np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+        )\n+    handle = self._handles[handle_index]\n+\n+    # these checks ensure smooth behavior if the handles swap which one\n+    # has a higher value. i.e. if one is dragged over and past the other.\n+    if handle is not self._active_handle:\n+        self._active_handle = handle\n+\n+    if self.orientation == \"vertical\":\n+        self._update_val_from_pos(event.ydata, trigger_callback=False)\n+    else:\n+        self._update_val_from_pos(event.xdata, trigger_callback=False)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -939,6 +946,7 @@ class RangeSlider(SliderBase):\n         \"\"\"\n         self.set_val((self.val[0], max))\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -965,7 +973,10 @@ class RangeSlider(SliderBase):\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        \n+        # Only trigger callbacks if we're not in an active drag operation\n+        # to prevent interference with mouse grab state\n+        if self.eventson and not getattr(self, '_dragging', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_8": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..be857574aa 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -220,10 +220,13 @@ class Button(AxesWidget):\n         if event.canvas.mouse_grabber != self.ax:\n             event.canvas.grab_mouse(self.ax)\n \n+\n     def _release(self, event):\n-        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n+        if self.ignore(event):\n             return\n-        event.canvas.release_mouse(self.ax)\n+        # Release mouse grab first, before any callbacks\n+        if event.canvas.mouse_grabber == self.ax:\n+            event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n             self._observers.process('clicked', event)\n \n@@ -253,6 +256,7 @@ class Button(AxesWidget):\n         self._observers.disconnect(cid)\n \n \n+\n class SliderBase(AxesWidget):\n     \"\"\"\n     The base class for constructing Slider widgets. Not intended for direct\n@@ -275,6 +279,7 @@ class SliderBase(AxesWidget):\n         self.valmax = valmax\n         self.valstep = valstep\n         self.drag_active = False\n+        self._pending_callbacks = []\n         self.valfmt = valfmt\n \n         if orientation == \"vertical\":\n@@ -300,6 +305,12 @@ class SliderBase(AxesWidget):\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n \n+    def _execute_pending_callbacks(self):\n+        \"\"\"Execute any callbacks that were deferred during drag operations.\"\"\"\n+        for callback_args in self._pending_callbacks:\n+            self._observers.process(\"changed\", *callback_args)\n+        self._pending_callbacks.clear()\n+\n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n         if isinstance(self.valstep, Number):\n@@ -820,90 +831,91 @@ class RangeSlider(SliderBase):\n         else:\n             verts[0] = verts[4] = vmin, .25\n             verts[1] = vmin, .75\n-            verts[2] = vmax, .75\n-            verts[3] = vmax, .25\n-\n-    def _min_in_bounds(self, min):\n-        \"\"\"Ensure the new min value is between valmin and self.val[1].\"\"\"\n-        if min <= self.valmin:\n-            if not self.closedmin:\n-                return self.val[0]\n-            min = self.valmin\n-\n-        if min > self.val[1]:\n-            min = self.val[1]\n-        return self._stepped_value(min)\n \n-    def _max_in_bounds(self, max):\n-        \"\"\"Ensure the new max value is between valmax and self.val[0].\"\"\"\n-        if max >= self.valmax:\n-            if not self.closedmax:\n-                return self.val[1]\n-            max = self.valmax\n-\n-        if max <= self.val[0]:\n-            max = self.val[0]\n-        return self._stepped_value(max)\n-\n-    def _value_in_bounds(self, vals):\n-        \"\"\"Clip min, max values to the bounds.\"\"\"\n-        return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n-\n-    def _update_val_from_pos(self, pos):\n-        \"\"\"Update the slider value based on a given position.\"\"\"\n-        idx = np.argmin(np.abs(self.val - pos))\n-        if idx == 0:\n-            val = self._min_in_bounds(pos)\n-            self.set_min(val)\n-        else:\n-            val = self._max_in_bounds(pos)\n-            self.set_max(val)\n-        if self._active_handle:\n-            if self.orientation == \"vertical\":\n-                self._active_handle.set_ydata([val])\n-            else:\n-                self._active_handle.set_xdata([val])\n-\n-    def _update(self, event):\n-        \"\"\"Update the slider position.\"\"\"\n-        if self.ignore(event) or event.button != 1:\n-            return\n-\n-        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n-            self.drag_active = True\n-            event.canvas.grab_mouse(self.ax)\n-\n-        if not self.drag_active:\n-            return\n+    def set_val(self, val):\n+        \"\"\"\n+        Set slider value to *val*.\n \n-        elif (event.name == \"button_release_event\") or (\n-            event.name == \"button_press_event\" and event.inaxes != self.ax\n-        ):\n-            self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n-            self._active_handle = None\n-            return\n+        Parameters\n+        ----------\n+        val : array-like of length 2\n+            Lower and upper bounds for the slider.\n \n-        # determine which handle was grabbed\n+        \"\"\"\n+        val = np.sort(val)\n+        _api.check_shape((2,), val=val)\n+        val[0] = self._min_in_bounds(val[0])\n+        val[1] = self._max_in_bounds(val[1])\n+        xy = self.poly.xy\n         if self.orientation == \"vertical\":\n-            handle_index = np.argmin(\n-                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n-            )\n+            xy[0] = .25, val[0]\n+            xy[1] = .25, val[1]\n+            xy[2] = .75, val[1]\n+            xy[3] = .75, val[0]\n+            xy[4] = .25, val[0]\n         else:\n-            handle_index = np.argmin(\n-                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n-            )\n-        handle = self._handles[handle_index]\n+            xy[0] = val[0], .25\n+            xy[1] = val[0], .75\n+            xy[2] = val[1], .75\n+            xy[3] = val[1], .25\n+            xy[4] = val[0], .25\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n+        if np.any(self.val != val):\n+            self.val = val\n+            # Only trigger callbacks if not in an active drag state\n+            # This prevents interference when callbacks contain plt.clf()/plt.draw()\n+            if not getattr(self, 'drag_active', False):\n+                if not self.eventson:\n+                    return\n+                for cid, func in self.observers.items():\n+                    func(val)\n+        self.ax.stale = True\n+\n+def _update(self, event):\n+    \"\"\"Update the slider position.\"\"\"\n+    if self.ignore(event) or event.button != 1:\n+        return\n+\n+    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+        self.drag_active = True\n+        event.canvas.grab_mouse(self.ax)\n+\n+    if not self.drag_active:\n+        return\n+\n+    elif (event.name == \"button_release_event\") or (\n+        event.name == \"button_press_event\" and event.inaxes != self.ax\n+    ):\n+        self.drag_active = False\n+        event.canvas.release_mouse(self.ax)\n+        self._active_handle = None\n+        # Trigger callbacks after releasing mouse grab\n+        if hasattr(self, '_pending_callback') and self._pending_callback:\n+            self._pending_callback = False\n+            self._observers.process('changed', self.val)\n+        return\n+\n+    # determine which handle was grabbed\n+    if self.orientation == \"vertical\":\n+        handle_index = np.argmin(\n+            np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+        )\n+    else:\n+        handle_index = np.argmin(\n+            np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+        )\n+    handle = self._handles[handle_index]\n \n-        # these checks ensure smooth behavior if the handles swap which one\n-        # has a higher value. i.e. if one is dragged over and past the other.\n-        if handle is not self._active_handle:\n-            self._active_handle = handle\n+    # these checks ensure smooth behavior if the handles swap which one\n+    # has a higher value. i.e. if one is dragged over and past the other.\n+    if handle is not self._active_handle:\n+        self._active_handle = handle\n \n-        if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n-        else:\n-            self._update_val_from_pos(event.xdata)\n+    if self.orientation == \"vertical\":\n+        self._update_val_from_pos(event.ydata)\n+    else:\n+        self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -939,34 +951,38 @@ class RangeSlider(SliderBase):\n         \"\"\"\n         self.set_val((self.val[0], max))\n \n-    def set_val(self, val):\n-        \"\"\"\n-        Set slider value to *val*.\n-\n-        Parameters\n-        ----------\n-        val : tuple or array-like of float\n-        \"\"\"\n-        val = np.sort(val)\n-        _api.check_shape((2,), val=val)\n-        # Reset value to allow _value_in_bounds() to work.\n-        self.val = (self.valmin, self.valmax)\n-        vmin, vmax = self._value_in_bounds(val)\n-        self._update_selection_poly(vmin, vmax)\n-        if self.orientation == \"vertical\":\n-            self._handles[0].set_ydata([vmin])\n-            self._handles[1].set_ydata([vmax])\n-        else:\n-            self._handles[0].set_xdata([vmin])\n-            self._handles[1].set_xdata([vmax])\n \n-        self.valtext.set_text(self._format((vmin, vmax)))\n+def set_val(self, val):\n+    \"\"\"\n+    Set slider value to *val*.\n \n-        if self.drawon:\n-            self.ax.figure.canvas.draw_idle()\n-        self.val = (vmin, vmax)\n-        if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+    Parameters\n+    ----------\n+    val : tuple or array-like of float\n+    \"\"\"\n+    val = np.sort(val)\n+    _api.check_shape((2,), val=val)\n+    # Reset value to allow _value_in_bounds() to work.\n+    self.val = (self.valmin, self.valmax)\n+    vmin, vmax = self._value_in_bounds(val)\n+    self._update_selection_poly(vmin, vmax)\n+    if self.orientation == \"vertical\":\n+        self._handles[0].set_ydata([vmin])\n+        self._handles[1].set_ydata([vmax])\n+    else:\n+        self._handles[0].set_xdata([vmin])\n+        self._handles[1].set_xdata([vmax])\n+\n+    self.valtext.set_text(self._format((vmin, vmax)))\n+\n+    if self.drawon:\n+        self.ax.figure.canvas.draw_idle()\n+    self.val = (vmin, vmax)\n+    \n+    # Only trigger callbacks if we're not in an active drag state\n+    # This prevents interference with mouse grab during plt.clf()/plt.draw() calls\n+    if self.eventson and not getattr(self, '_active', False):\n+        self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n"
  }
}