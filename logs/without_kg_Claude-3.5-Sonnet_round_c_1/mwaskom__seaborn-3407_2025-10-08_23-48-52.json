{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1664-1670)": "\n    def _find_numeric_cols(self, data):\n        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n        numeric_cols = []\n        for col in data:\n            if variable_type(data[col]) == \"numeric\":\n                # Ensure MultiIndex columns remain as tuples\n                numeric_cols.append(col)\n        return numeric_cols\n",
    "Location 2 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1251-1254)": "\n        if x_vars is None:\n            x_vars = numeric_cols\n        if y_vars is None:\n            y_vars = numeric_cols\n",
    "Location 3 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1261-1262)": "\n        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.Index) else x_vars.tolist()\n        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.Index) else y_vars.tolist()\n",
    "Location 4 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1444-1475)": "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        # Ensure MultiIndex columns are preserved as tuples\n                        if isinstance(x_var, tuple) and isinstance(self.data.columns, pd.MultiIndex):\n                            diag_vars.append(x_var)\n                        else:\n                            diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n                        # Remove main y axis from density axes in a corner plot\n                        if self._corner:\n                            ax.yaxis.set_visible(False)\n                            if self._despine:\n                                utils.despine(ax=ax, left=True)\n                            # TODO add optional density ticks (on the right)\n                            # when drawing a corner plot?\n\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = np.array(diag_vars, np.object_)\n",
    "Location 5 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1488-1492)": "\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            # Ensure var is properly formatted for MultiIndex columns\n            if isinstance(self.data.columns, pd.MultiIndex):\n                if isinstance(var, str) and var in [str(col) for col in self.data.columns]:\n                    # Find the actual tuple column that matches the string representation\n                    for col in self.data.columns:\n                        if str(col) == var:\n                            var = col\n                            break\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1664-1670)": [
      "\n    def _find_numeric_cols(self, data):\n        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n        numeric_cols = []\n        for col in data:\n            if variable_type(data[col]) == \"numeric\":\n                # Ensure MultiIndex tuples are preserved as-is\n                numeric_cols.append(col)\n        return numeric_cols\n",
      "\n    def _find_numeric_cols(self, data):\n        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n        numeric_cols = []\n        for col in data:\n            if variable_type(data[col]) == \"numeric\":\n                numeric_cols.append(col)\n        return numeric_cols\n",
      "\n    def _find_numeric_cols(self, data):\n        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n        numeric_cols = []\n        for col in data:\n            if variable_type(data[col]) == \"numeric\":\n                # Ensure MultiIndex columns are preserved as tuples\n                numeric_cols.append(col)\n        return numeric_cols\n",
      "\n    def _find_numeric_cols(self, data):\n        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n        numeric_cols = []\n        for col in data:\n            if variable_type(data[col]) == \"numeric\":\n                # Preserve MultiIndex column tuples as-is\n                numeric_cols.append(col)\n        return numeric_cols\n",
      "\n    def _find_numeric_cols(self, data):\n        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n        numeric_cols = []\n        for col in data:\n            if variable_type(data[col]) == \"numeric\":\n                # Ensure MultiIndex columns remain as tuples\n                if isinstance(data.columns, pd.MultiIndex):\n                    # col is already a tuple for MultiIndex\n                    numeric_cols.append(col)\n                else:\n                    numeric_cols.append(col)\n        return numeric_cols\n",
      "\n    def _find_numeric_cols(self, data):\n        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n        numeric_cols = []\n        for col in data:\n            if variable_type(data[col]) == \"numeric\":\n                # Preserve MultiIndex column tuples as-is\n                numeric_cols.append(col)\n        return numeric_cols\n",
      "\n    def _find_numeric_cols(self, data):\n        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n        numeric_cols = []\n        for col in data:\n            if variable_type(data[col]) == \"numeric\":\n                # Preserve MultiIndex tuple structure\n                numeric_cols.append(col)\n        return numeric_cols\n",
      "\n    def _find_numeric_cols(self, data):\n        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n        numeric_cols = []\n        for col in data:\n            if variable_type(data[col]) == \"numeric\":\n                # Ensure MultiIndex columns remain as tuples\n                if isinstance(data.columns, pd.MultiIndex):\n                    numeric_cols.append(col)\n                else:\n                    numeric_cols.append(col)\n        return numeric_cols\n"
    ],
    "Location 2 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1251-1254)": [
      "\n        if x_vars is None:\n            x_vars = numeric_cols\n        if y_vars is None:\n            y_vars = numeric_cols\n",
      "\n        if x_vars is None:\n            x_vars = numeric_cols\n        if y_vars is None:\n            y_vars = numeric_cols\n",
      "\n        if x_vars is None:\n            x_vars = numeric_cols\n        if y_vars is None:\n            y_vars = numeric_cols\n",
      "\n        if x_vars is None:\n            x_vars = numeric_cols\n        if y_vars is None:\n            y_vars = numeric_cols\n",
      "\n        if x_vars is None:\n            x_vars = numeric_cols\n        if y_vars is None:\n            y_vars = numeric_cols\n",
      "\n        if x_vars is None:\n            x_vars = numeric_cols\n        if y_vars is None:\n            y_vars = numeric_cols\n",
      "\n        if x_vars is None:\n            x_vars = numeric_cols\n        if y_vars is None:\n            y_vars = numeric_cols\n",
      "\n        if x_vars is None:\n            x_vars = numeric_cols\n        if y_vars is None:\n            y_vars = numeric_cols\n"
    ],
    "Location 3 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1261-1262)": [
      "\n        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.Index) else x_vars.tolist()\n        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.Index) else y_vars.tolist()\n",
      "\n        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, list) else x_vars\n        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, list) else y_vars\n",
      "\n        self.x_vars = x_vars = list(x_vars) if not hasattr(x_vars, '__iter__') or isinstance(x_vars, str) else list(x_vars)\n        self.y_vars = y_vars = list(y_vars) if not hasattr(y_vars, '__iter__') or isinstance(y_vars, str) else list(y_vars)\n",
      "\n        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.Index) else x_vars.tolist()\n        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.Index) else y_vars.tolist()\n",
      "\n        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.MultiIndex) else list(x_vars)\n        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.MultiIndex) else list(y_vars)\n",
      "\n        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.MultiIndex) else list(x_vars)\n        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.MultiIndex) else list(y_vars)\n",
      "\n        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.MultiIndex) else x_vars.tolist()\n        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.MultiIndex) else y_vars.tolist()\n",
      "\n        self.x_vars = x_vars = list(x_vars)\n        self.y_vars = y_vars = list(y_vars)\n"
    ],
    "Location 4 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1444-1475)": [
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n                        # Remove main y axis from density axes in a corner plot\n                        if self._corner:\n                            ax.yaxis.set_visible(False)\n                            if self._despine:\n                                utils.despine(ax=ax, left=True)\n                            # TODO add optional density ticks (on the right)\n                            # when drawing a corner plot?\n\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = np.array(diag_vars, dtype=object)\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        # Ensure MultiIndex columns are preserved as tuples\n                        if isinstance(x_var, tuple):\n                            diag_vars.append(x_var)\n                        else:\n                            diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n                        # Remove main y axis from density axes in a corner plot\n                        if self._corner:\n                            ax.yaxis.set_visible(False)\n                            if self._despine:\n                                utils.despine(ax=ax, left=True)\n                            # TODO add optional density ticks (on the right)\n                            # when drawing a corner plot?\n\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = np.array(diag_vars, dtype=object)\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        # Ensure MultiIndex columns are preserved as tuples\n                        if isinstance(x_var, tuple):\n                            diag_vars.append(x_var)\n                        else:\n                            diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n                        # Remove main y axis from density axes in a corner plot\n                        if self._corner:\n                            ax.yaxis.set_visible(False)\n                            if self._despine:\n                                utils.despine(ax=ax, left=True)\n                            # TODO add optional density ticks (on the right)\n                            # when drawing a corner plot?\n\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = np.array(diag_vars, dtype=object)\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        # Ensure MultiIndex columns are preserved as tuples\n                        if isinstance(x_var, tuple):\n                            diag_vars.append(x_var)\n                        else:\n                            diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n                        # Remove main y axis from density axes in a corner plot\n                        if self._corner:\n                            ax.yaxis.set_visible(False)\n                            if self._despine:\n                                utils.despine(ax=ax, left=True)\n                            # TODO add optional density ticks (on the right)\n                            # when drawing a corner plot?\n\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = np.array(diag_vars, dtype=object)\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        # Ensure MultiIndex columns are preserved as tuples\n                        if isinstance(x_var, tuple):\n                            diag_vars.append(x_var)\n                        else:\n                            diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n                        # Remove main y axis from density axes in a corner plot\n                        if self._corner:\n                            ax.yaxis.set_visible(False)\n                            if self._despine:\n                                utils.despine(ax=ax, left=True)\n                            # TODO add optional density ticks (on the right)\n                            # when drawing a corner plot?\n\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = np.array(diag_vars, dtype=object)\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        # Preserve MultiIndex column tuples\n                        if isinstance(x_var, tuple):\n                            diag_vars.append(x_var)\n                        else:\n                            diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n                        # Remove main y axis from density axes in a corner plot\n                        if self._corner:\n                            ax.yaxis.set_visible(False)\n                            if self._despine:\n                                utils.despine(ax=ax, left=True)\n                            # TODO add optional density ticks (on the right)\n                            # when drawing a corner plot?\n\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = np.array(diag_vars, dtype=object)\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        # Ensure MultiIndex columns remain as tuples\n                        if isinstance(x_var, tuple):\n                            diag_vars.append(x_var)\n                        else:\n                            diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n                        # Remove main y axis from density axes in a corner plot\n                        if self._corner:\n                            ax.yaxis.set_visible(False)\n                            if self._despine:\n                                utils.despine(ax=ax, left=True)\n                            # TODO add optional density ticks (on the right)\n                            # when drawing a corner plot?\n\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            # Preserve MultiIndex structure when creating numpy array\n            self.diag_vars = np.array(diag_vars, dtype=object)\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        # Ensure MultiIndex columns are preserved as tuples\n                        if isinstance(x_var, tuple):\n                            diag_vars.append(x_var)\n                        else:\n                            diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n                        # Remove main y axis from density axes in a corner plot\n                        if self._corner:\n                            ax.yaxis.set_visible(False)\n                            if self._despine:\n                                utils.despine(ax=ax, left=True)\n                            # TODO add optional density ticks (on the right)\n                            # when drawing a corner plot?\n\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = np.array(diag_vars, dtype=object)\n"
    ],
    "Location 5 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1488-1492)": [
      "\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            # Ensure var is properly formatted for MultiIndex columns\n            if isinstance(self.data.columns, pd.MultiIndex):\n                # For MultiIndex, var should be a tuple\n                if isinstance(var, str) and var in [str(col) for col in self.data.columns]:\n                    # Find the original tuple column that matches this string representation\n                    for col in self.data.columns:\n                        if str(col) == var:\n                            var = col\n                            break\n            \n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            # Ensure var is in the correct format for MultiIndex columns\n            if isinstance(self.data.columns, pd.MultiIndex):\n                if isinstance(var, str) and var not in self.data.columns:\n                    # Try to find the matching tuple column\n                    matching_cols = [col for col in self.data.columns if str(col) == var or (isinstance(col, tuple) and str(col[-1]) == var)]\n                    if matching_cols:\n                        var = matching_cols[0]\n            \n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            # Ensure var is in the correct format for MultiIndex columns\n            if isinstance(self.data.columns, pd.MultiIndex):\n                # If var is not a tuple but should be, find the matching column\n                if not isinstance(var, tuple) and var in [str(col) for col in self.data.columns]:\n                    # Find the actual tuple column that matches this string representation\n                    matching_cols = [col for col in self.data.columns if str(col) == var]\n                    if matching_cols:\n                        var = matching_cols[0]\n            \n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            # Ensure var is properly formatted for MultiIndex columns\n            if isinstance(self.data.columns, pd.MultiIndex):\n                # For MultiIndex, var should be a tuple\n                if isinstance(var, str) and var in [str(col) for col in self.data.columns]:\n                    # Find the actual tuple column that matches this string representation\n                    for col in self.data.columns:\n                        if str(col) == var:\n                            var = col\n                            break\n            \n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            # Handle MultiIndex columns properly\n            if isinstance(var, str) and var not in self.data.columns:\n                # Check if this might be a string representation of a MultiIndex tuple\n                for col in self.data.columns:\n                    if isinstance(col, tuple) and str(col) == var:\n                        var = col\n                        break\n            \n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            # Ensure MultiIndex columns are properly handled\n            if isinstance(self.data.columns, pd.MultiIndex):\n                # For MultiIndex, var should be a tuple\n                if not isinstance(var, tuple):\n                    # Try to find the matching MultiIndex column\n                    matching_cols = [col for col in self.data.columns if str(col).endswith(str(var))]\n                    if len(matching_cols) == 1:\n                        var = matching_cols[0]\n                    else:\n                        # If we can't find a unique match, use the original var\n                        pass\n            \n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue_var = self._hue_var\n                # Apply same MultiIndex handling to hue variable\n                if isinstance(self.data.columns, pd.MultiIndex) and not isinstance(hue_var, tuple):\n                    matching_hue_cols = [col for col in self.data.columns if str(col).endswith(str(hue_var))]\n                    if len(matching_hue_cols) == 1:\n                        hue_var = matching_hue_cols[0]\n                hue = self.data[hue_var]\n",
      "\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            # Ensure MultiIndex columns are handled correctly\n            if isinstance(self.data.columns, pd.MultiIndex) and isinstance(var, str):\n                # Convert string back to tuple if needed for MultiIndex access\n                try:\n                    # Try to find matching tuple column\n                    matching_cols = [col for col in self.data.columns if str(col) == var]\n                    if matching_cols:\n                        var = matching_cols[0]\n                except:\n                    pass\n            \n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            # Ensure var is properly formatted for MultiIndex columns\n            if isinstance(self.data.columns, pd.MultiIndex):\n                # For MultiIndex, ensure var is a tuple if it should be\n                if isinstance(var, str) and var in [str(col) for col in self.data.columns]:\n                    # Find the matching tuple column\n                    var = next(col for col in self.data.columns if str(col) == var)\n            \n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..5a0776a1 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1248,6 +1248,7 @@ class PairGrid(Grid):\n         if vars is not None:\n             x_vars = list(vars)\n             y_vars = list(vars)\n+\n         if x_vars is None:\n             x_vars = numeric_cols\n         if y_vars is None:\n@@ -1258,6 +1259,7 @@ class PairGrid(Grid):\n         if np.isscalar(y_vars):\n             y_vars = [y_vars]\n \n+\n         self.x_vars = x_vars = list(x_vars)\n         self.y_vars = y_vars = list(y_vars)\n         self.square_grid = self.x_vars == self.y_vars\n@@ -1441,6 +1443,7 @@ class PairGrid(Grid):\n         \"\"\"\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n+\n             diag_vars = []\n             diag_axes = []\n             for i, y_var in enumerate(self.y_vars):\n@@ -1472,7 +1475,8 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n+            # Store diag_vars as a regular list to preserve MultiIndex tuples\n+            self.diag_vars = diag_vars\n             self.diag_axes = np.array(diag_axes, np.object_)\n \n         if \"hue\" not in signature(func).parameters:\n@@ -1485,6 +1489,7 @@ class PairGrid(Grid):\n             if str(func.__module__).startswith(\"seaborn\"):\n                 plot_kwargs[\"ax\"] = ax\n             else:\n+\n                 plt.sca(ax)\n \n             vector = self.data[var]\n@@ -1661,6 +1666,7 @@ class PairGrid(Grid):\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n+\n     def _find_numeric_cols(self, data):\n         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n         numeric_cols = []\n",
    "variant_0": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..09f3d4a8 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1248,6 +1248,7 @@ class PairGrid(Grid):\n         if vars is not None:\n             x_vars = list(vars)\n             y_vars = list(vars)\n+\n         if x_vars is None:\n             x_vars = numeric_cols\n         if y_vars is None:\n@@ -1258,8 +1259,9 @@ class PairGrid(Grid):\n         if np.isscalar(y_vars):\n             y_vars = [y_vars]\n \n-        self.x_vars = x_vars = list(x_vars)\n-        self.y_vars = y_vars = list(y_vars)\n+\n+        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.Index) else x_vars.tolist()\n+        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.Index) else y_vars.tolist()\n         self.square_grid = self.x_vars == self.y_vars\n \n         if not x_vars:\n@@ -1439,6 +1441,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1448,7 +1453,11 @@ class PairGrid(Grid):\n                     if x_var == y_var:\n \n                         # Make the density axes\n-                        diag_vars.append(x_var)\n+                        # Ensure MultiIndex columns are preserved as tuples\n+                        if isinstance(x_var, tuple) and isinstance(self.data.columns, pd.MultiIndex):\n+                            diag_vars.append(x_var)\n+                        else:\n+                            diag_vars.append(x_var)\n                         ax = self.axes[i, j]\n                         diag_ax = ax.twinx()\n                         diag_ax.set_axis_off()\n@@ -1478,6 +1487,14 @@ class PairGrid(Grid):\n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n \n+        # Loop over diagonal variables and axes, making one plot in each\n+        for var, ax in zip(self.diag_vars, self.diag_axes):\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+\n         # Loop over diagonal variables and axes, making one plot in each\n         for var, ax in zip(self.diag_vars, self.diag_axes):\n \n@@ -1487,6 +1504,15 @@ class PairGrid(Grid):\n             else:\n                 plt.sca(ax)\n \n+            # Ensure var is properly formatted for MultiIndex columns\n+            if isinstance(self.data.columns, pd.MultiIndex):\n+                if isinstance(var, str) and var in [str(col) for col in self.data.columns]:\n+                    # Find the actual tuple column that matches the string representation\n+                    for col in self.data.columns:\n+                        if str(col) == var:\n+                            var = col\n+                            break\n+\n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n@@ -1661,11 +1687,13 @@ class PairGrid(Grid):\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n+\n     def _find_numeric_cols(self, data):\n         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n         numeric_cols = []\n         for col in data:\n             if variable_type(data[col]) == \"numeric\":\n+                # Ensure MultiIndex columns remain as tuples\n                 numeric_cols.append(col)\n         return numeric_cols\n \n",
    "variant_1": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..1825cfbd 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1248,6 +1248,7 @@ class PairGrid(Grid):\n         if vars is not None:\n             x_vars = list(vars)\n             y_vars = list(vars)\n+\n         if x_vars is None:\n             x_vars = numeric_cols\n         if y_vars is None:\n@@ -1258,8 +1259,9 @@ class PairGrid(Grid):\n         if np.isscalar(y_vars):\n             y_vars = [y_vars]\n \n-        self.x_vars = x_vars = list(x_vars)\n-        self.y_vars = y_vars = list(y_vars)\n+\n+        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.Index) else x_vars.tolist()\n+        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.Index) else y_vars.tolist()\n         self.square_grid = self.x_vars == self.y_vars\n \n         if not x_vars:\n@@ -1439,6 +1441,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1472,7 +1477,7 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n+            self.diag_vars = np.array(diag_vars, dtype=object)\n             self.diag_axes = np.array(diag_axes, np.object_)\n \n         if \"hue\" not in signature(func).parameters:\n@@ -1481,12 +1486,27 @@ class PairGrid(Grid):\n         # Loop over diagonal variables and axes, making one plot in each\n         for var, ax in zip(self.diag_vars, self.diag_axes):\n \n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+\n             plot_kwargs = kwargs.copy()\n             if str(func.__module__).startswith(\"seaborn\"):\n                 plot_kwargs[\"ax\"] = ax\n             else:\n                 plt.sca(ax)\n \n+            # Ensure var is properly formatted for MultiIndex columns\n+            if isinstance(self.data.columns, pd.MultiIndex):\n+                # For MultiIndex, var should be a tuple\n+                if isinstance(var, str) and var in [str(col) for col in self.data.columns]:\n+                    # Find the original tuple column that matches this string representation\n+                    for col in self.data.columns:\n+                        if str(col) == var:\n+                            var = col\n+                            break\n+            \n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n@@ -1661,11 +1681,13 @@ class PairGrid(Grid):\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n+\n     def _find_numeric_cols(self, data):\n         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n         numeric_cols = []\n         for col in data:\n             if variable_type(data[col]) == \"numeric\":\n+                # Ensure MultiIndex tuples are preserved as-is\n                 numeric_cols.append(col)\n         return numeric_cols\n \n",
    "variant_2": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..cf07134d 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1248,6 +1248,7 @@ class PairGrid(Grid):\n         if vars is not None:\n             x_vars = list(vars)\n             y_vars = list(vars)\n+\n         if x_vars is None:\n             x_vars = numeric_cols\n         if y_vars is None:\n@@ -1258,8 +1259,9 @@ class PairGrid(Grid):\n         if np.isscalar(y_vars):\n             y_vars = [y_vars]\n \n-        self.x_vars = x_vars = list(x_vars)\n-        self.y_vars = y_vars = list(y_vars)\n+\n+        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, list) else x_vars\n+        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, list) else y_vars\n         self.square_grid = self.x_vars == self.y_vars\n \n         if not x_vars:\n@@ -1439,6 +1441,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1448,7 +1453,11 @@ class PairGrid(Grid):\n                     if x_var == y_var:\n \n                         # Make the density axes\n-                        diag_vars.append(x_var)\n+                        # Ensure MultiIndex columns are preserved as tuples\n+                        if isinstance(x_var, tuple):\n+                            diag_vars.append(x_var)\n+                        else:\n+                            diag_vars.append(x_var)\n                         ax = self.axes[i, j]\n                         diag_ax = ax.twinx()\n                         diag_ax.set_axis_off()\n@@ -1472,12 +1481,20 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n+            self.diag_vars = np.array(diag_vars, dtype=object)\n             self.diag_axes = np.array(diag_axes, np.object_)\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n \n+        # Loop over diagonal variables and axes, making one plot in each\n+        for var, ax in zip(self.diag_vars, self.diag_axes):\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+\n         # Loop over diagonal variables and axes, making one plot in each\n         for var, ax in zip(self.diag_vars, self.diag_axes):\n \n@@ -1487,6 +1504,14 @@ class PairGrid(Grid):\n             else:\n                 plt.sca(ax)\n \n+            # Ensure var is in the correct format for MultiIndex columns\n+            if isinstance(self.data.columns, pd.MultiIndex):\n+                if isinstance(var, str) and var not in self.data.columns:\n+                    # Try to find the matching tuple column\n+                    matching_cols = [col for col in self.data.columns if str(col) == var or (isinstance(col, tuple) and str(col[-1]) == var)]\n+                    if matching_cols:\n+                        var = matching_cols[0]\n+            \n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n@@ -1661,6 +1686,7 @@ class PairGrid(Grid):\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n+\n     def _find_numeric_cols(self, data):\n         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n         numeric_cols = []\n",
    "variant_3": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..731ceed1 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1248,6 +1248,7 @@ class PairGrid(Grid):\n         if vars is not None:\n             x_vars = list(vars)\n             y_vars = list(vars)\n+\n         if x_vars is None:\n             x_vars = numeric_cols\n         if y_vars is None:\n@@ -1258,8 +1259,9 @@ class PairGrid(Grid):\n         if np.isscalar(y_vars):\n             y_vars = [y_vars]\n \n-        self.x_vars = x_vars = list(x_vars)\n-        self.y_vars = y_vars = list(y_vars)\n+\n+        self.x_vars = x_vars = list(x_vars) if not hasattr(x_vars, '__iter__') or isinstance(x_vars, str) else list(x_vars)\n+        self.y_vars = y_vars = list(y_vars) if not hasattr(y_vars, '__iter__') or isinstance(y_vars, str) else list(y_vars)\n         self.square_grid = self.x_vars == self.y_vars\n \n         if not x_vars:\n@@ -1439,6 +1441,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1448,7 +1453,11 @@ class PairGrid(Grid):\n                     if x_var == y_var:\n \n                         # Make the density axes\n-                        diag_vars.append(x_var)\n+                        # Ensure MultiIndex columns are preserved as tuples\n+                        if isinstance(x_var, tuple):\n+                            diag_vars.append(x_var)\n+                        else:\n+                            diag_vars.append(x_var)\n                         ax = self.axes[i, j]\n                         diag_ax = ax.twinx()\n                         diag_ax.set_axis_off()\n@@ -1472,12 +1481,20 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n+            self.diag_vars = np.array(diag_vars, dtype=object)\n             self.diag_axes = np.array(diag_axes, np.object_)\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n \n+        # Loop over diagonal variables and axes, making one plot in each\n+        for var, ax in zip(self.diag_vars, self.diag_axes):\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+\n         # Loop over diagonal variables and axes, making one plot in each\n         for var, ax in zip(self.diag_vars, self.diag_axes):\n \n@@ -1487,6 +1504,15 @@ class PairGrid(Grid):\n             else:\n                 plt.sca(ax)\n \n+            # Ensure var is in the correct format for MultiIndex columns\n+            if isinstance(self.data.columns, pd.MultiIndex):\n+                # If var is not a tuple but should be, find the matching column\n+                if not isinstance(var, tuple) and var in [str(col) for col in self.data.columns]:\n+                    # Find the actual tuple column that matches this string representation\n+                    matching_cols = [col for col in self.data.columns if str(col) == var]\n+                    if matching_cols:\n+                        var = matching_cols[0]\n+            \n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n@@ -1661,11 +1687,13 @@ class PairGrid(Grid):\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n+\n     def _find_numeric_cols(self, data):\n         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n         numeric_cols = []\n         for col in data:\n             if variable_type(data[col]) == \"numeric\":\n+                # Ensure MultiIndex columns are preserved as tuples\n                 numeric_cols.append(col)\n         return numeric_cols\n \n",
    "variant_4": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..f2569cb8 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1248,6 +1248,7 @@ class PairGrid(Grid):\n         if vars is not None:\n             x_vars = list(vars)\n             y_vars = list(vars)\n+\n         if x_vars is None:\n             x_vars = numeric_cols\n         if y_vars is None:\n@@ -1258,8 +1259,9 @@ class PairGrid(Grid):\n         if np.isscalar(y_vars):\n             y_vars = [y_vars]\n \n-        self.x_vars = x_vars = list(x_vars)\n-        self.y_vars = y_vars = list(y_vars)\n+\n+        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.Index) else x_vars.tolist()\n+        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.Index) else y_vars.tolist()\n         self.square_grid = self.x_vars == self.y_vars\n \n         if not x_vars:\n@@ -1439,6 +1441,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1448,7 +1453,11 @@ class PairGrid(Grid):\n                     if x_var == y_var:\n \n                         # Make the density axes\n-                        diag_vars.append(x_var)\n+                        # Ensure MultiIndex columns are preserved as tuples\n+                        if isinstance(x_var, tuple):\n+                            diag_vars.append(x_var)\n+                        else:\n+                            diag_vars.append(x_var)\n                         ax = self.axes[i, j]\n                         diag_ax = ax.twinx()\n                         diag_ax.set_axis_off()\n@@ -1472,7 +1481,7 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n+            self.diag_vars = np.array(diag_vars, dtype=object)\n             self.diag_axes = np.array(diag_axes, np.object_)\n \n         if \"hue\" not in signature(func).parameters:\n@@ -1481,12 +1490,27 @@ class PairGrid(Grid):\n         # Loop over diagonal variables and axes, making one plot in each\n         for var, ax in zip(self.diag_vars, self.diag_axes):\n \n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+\n             plot_kwargs = kwargs.copy()\n             if str(func.__module__).startswith(\"seaborn\"):\n                 plot_kwargs[\"ax\"] = ax\n             else:\n                 plt.sca(ax)\n \n+            # Ensure var is properly formatted for MultiIndex columns\n+            if isinstance(self.data.columns, pd.MultiIndex):\n+                # For MultiIndex, var should be a tuple\n+                if isinstance(var, str) and var in [str(col) for col in self.data.columns]:\n+                    # Find the actual tuple column that matches this string representation\n+                    for col in self.data.columns:\n+                        if str(col) == var:\n+                            var = col\n+                            break\n+            \n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n@@ -1661,11 +1685,13 @@ class PairGrid(Grid):\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n+\n     def _find_numeric_cols(self, data):\n         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n         numeric_cols = []\n         for col in data:\n             if variable_type(data[col]) == \"numeric\":\n+                # Preserve MultiIndex column tuples as-is\n                 numeric_cols.append(col)\n         return numeric_cols\n \n",
    "variant_5": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..1d069c5e 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1248,6 +1248,7 @@ class PairGrid(Grid):\n         if vars is not None:\n             x_vars = list(vars)\n             y_vars = list(vars)\n+\n         if x_vars is None:\n             x_vars = numeric_cols\n         if y_vars is None:\n@@ -1258,8 +1259,9 @@ class PairGrid(Grid):\n         if np.isscalar(y_vars):\n             y_vars = [y_vars]\n \n-        self.x_vars = x_vars = list(x_vars)\n-        self.y_vars = y_vars = list(y_vars)\n+\n+        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.MultiIndex) else list(x_vars)\n+        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.MultiIndex) else list(y_vars)\n         self.square_grid = self.x_vars == self.y_vars\n \n         if not x_vars:\n@@ -1439,6 +1441,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1448,7 +1453,11 @@ class PairGrid(Grid):\n                     if x_var == y_var:\n \n                         # Make the density axes\n-                        diag_vars.append(x_var)\n+                        # Ensure MultiIndex columns are preserved as tuples\n+                        if isinstance(x_var, tuple):\n+                            diag_vars.append(x_var)\n+                        else:\n+                            diag_vars.append(x_var)\n                         ax = self.axes[i, j]\n                         diag_ax = ax.twinx()\n                         diag_ax.set_axis_off()\n@@ -1472,12 +1481,20 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n+            self.diag_vars = np.array(diag_vars, dtype=object)\n             self.diag_axes = np.array(diag_axes, np.object_)\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n \n+        # Loop over diagonal variables and axes, making one plot in each\n+        for var, ax in zip(self.diag_vars, self.diag_axes):\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+\n         # Loop over diagonal variables and axes, making one plot in each\n         for var, ax in zip(self.diag_vars, self.diag_axes):\n \n@@ -1487,6 +1504,14 @@ class PairGrid(Grid):\n             else:\n                 plt.sca(ax)\n \n+            # Handle MultiIndex columns properly\n+            if isinstance(var, str) and var not in self.data.columns:\n+                # Check if this might be a string representation of a MultiIndex tuple\n+                for col in self.data.columns:\n+                    if isinstance(col, tuple) and str(col) == var:\n+                        var = col\n+                        break\n+            \n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n@@ -1661,12 +1686,18 @@ class PairGrid(Grid):\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n+\n     def _find_numeric_cols(self, data):\n         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n         numeric_cols = []\n         for col in data:\n             if variable_type(data[col]) == \"numeric\":\n-                numeric_cols.append(col)\n+                # Ensure MultiIndex columns remain as tuples\n+                if isinstance(data.columns, pd.MultiIndex):\n+                    # col is already a tuple for MultiIndex\n+                    numeric_cols.append(col)\n+                else:\n+                    numeric_cols.append(col)\n         return numeric_cols\n \n \n",
    "variant_6": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..21155b00 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1248,6 +1248,7 @@ class PairGrid(Grid):\n         if vars is not None:\n             x_vars = list(vars)\n             y_vars = list(vars)\n+\n         if x_vars is None:\n             x_vars = numeric_cols\n         if y_vars is None:\n@@ -1258,8 +1259,9 @@ class PairGrid(Grid):\n         if np.isscalar(y_vars):\n             y_vars = [y_vars]\n \n-        self.x_vars = x_vars = list(x_vars)\n-        self.y_vars = y_vars = list(y_vars)\n+\n+        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.MultiIndex) else list(x_vars)\n+        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.MultiIndex) else list(y_vars)\n         self.square_grid = self.x_vars == self.y_vars\n \n         if not x_vars:\n@@ -1439,6 +1441,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1448,7 +1453,11 @@ class PairGrid(Grid):\n                     if x_var == y_var:\n \n                         # Make the density axes\n-                        diag_vars.append(x_var)\n+                        # Preserve MultiIndex column tuples\n+                        if isinstance(x_var, tuple):\n+                            diag_vars.append(x_var)\n+                        else:\n+                            diag_vars.append(x_var)\n                         ax = self.axes[i, j]\n                         diag_ax = ax.twinx()\n                         diag_ax.set_axis_off()\n@@ -1472,12 +1481,20 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n+            self.diag_vars = np.array(diag_vars, dtype=object)\n             self.diag_axes = np.array(diag_axes, np.object_)\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n \n+        # Loop over diagonal variables and axes, making one plot in each\n+        for var, ax in zip(self.diag_vars, self.diag_axes):\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+\n         # Loop over diagonal variables and axes, making one plot in each\n         for var, ax in zip(self.diag_vars, self.diag_axes):\n \n@@ -1487,9 +1504,27 @@ class PairGrid(Grid):\n             else:\n                 plt.sca(ax)\n \n+            # Ensure MultiIndex columns are properly handled\n+            if isinstance(self.data.columns, pd.MultiIndex):\n+                # For MultiIndex, var should be a tuple\n+                if not isinstance(var, tuple):\n+                    # Try to find the matching MultiIndex column\n+                    matching_cols = [col for col in self.data.columns if str(col).endswith(str(var))]\n+                    if len(matching_cols) == 1:\n+                        var = matching_cols[0]\n+                    else:\n+                        # If we can't find a unique match, use the original var\n+                        pass\n+            \n             vector = self.data[var]\n             if self._hue_var is not None:\n-                hue = self.data[self._hue_var]\n+                hue_var = self._hue_var\n+                # Apply same MultiIndex handling to hue variable\n+                if isinstance(self.data.columns, pd.MultiIndex) and not isinstance(hue_var, tuple):\n+                    matching_hue_cols = [col for col in self.data.columns if str(col).endswith(str(hue_var))]\n+                    if len(matching_hue_cols) == 1:\n+                        hue_var = matching_hue_cols[0]\n+                hue = self.data[hue_var]\n             else:\n                 hue = None\n \n@@ -1661,11 +1696,13 @@ class PairGrid(Grid):\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n+\n     def _find_numeric_cols(self, data):\n         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n         numeric_cols = []\n         for col in data:\n             if variable_type(data[col]) == \"numeric\":\n+                # Preserve MultiIndex column tuples as-is\n                 numeric_cols.append(col)\n         return numeric_cols\n \n",
    "variant_7": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..221b9c50 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1248,6 +1248,7 @@ class PairGrid(Grid):\n         if vars is not None:\n             x_vars = list(vars)\n             y_vars = list(vars)\n+\n         if x_vars is None:\n             x_vars = numeric_cols\n         if y_vars is None:\n@@ -1258,8 +1259,9 @@ class PairGrid(Grid):\n         if np.isscalar(y_vars):\n             y_vars = [y_vars]\n \n-        self.x_vars = x_vars = list(x_vars)\n-        self.y_vars = y_vars = list(y_vars)\n+\n+        self.x_vars = x_vars = list(x_vars) if not isinstance(x_vars, pd.MultiIndex) else x_vars.tolist()\n+        self.y_vars = y_vars = list(y_vars) if not isinstance(y_vars, pd.MultiIndex) else y_vars.tolist()\n         self.square_grid = self.x_vars == self.y_vars\n \n         if not x_vars:\n@@ -1439,6 +1441,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1448,7 +1453,11 @@ class PairGrid(Grid):\n                     if x_var == y_var:\n \n                         # Make the density axes\n-                        diag_vars.append(x_var)\n+                        # Ensure MultiIndex columns remain as tuples\n+                        if isinstance(x_var, tuple):\n+                            diag_vars.append(x_var)\n+                        else:\n+                            diag_vars.append(x_var)\n                         ax = self.axes[i, j]\n                         diag_ax = ax.twinx()\n                         diag_ax.set_axis_off()\n@@ -1472,12 +1481,21 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n+            # Preserve MultiIndex structure when creating numpy array\n+            self.diag_vars = np.array(diag_vars, dtype=object)\n             self.diag_axes = np.array(diag_axes, np.object_)\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n \n+        # Loop over diagonal variables and axes, making one plot in each\n+        for var, ax in zip(self.diag_vars, self.diag_axes):\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+\n         # Loop over diagonal variables and axes, making one plot in each\n         for var, ax in zip(self.diag_vars, self.diag_axes):\n \n@@ -1487,6 +1505,17 @@ class PairGrid(Grid):\n             else:\n                 plt.sca(ax)\n \n+            # Ensure MultiIndex columns are handled correctly\n+            if isinstance(self.data.columns, pd.MultiIndex) and isinstance(var, str):\n+                # Convert string back to tuple if needed for MultiIndex access\n+                try:\n+                    # Try to find matching tuple column\n+                    matching_cols = [col for col in self.data.columns if str(col) == var]\n+                    if matching_cols:\n+                        var = matching_cols[0]\n+                except:\n+                    pass\n+            \n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n@@ -1661,11 +1690,13 @@ class PairGrid(Grid):\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n+\n     def _find_numeric_cols(self, data):\n         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n         numeric_cols = []\n         for col in data:\n             if variable_type(data[col]) == \"numeric\":\n+                # Preserve MultiIndex tuple structure\n                 numeric_cols.append(col)\n         return numeric_cols\n \n",
    "variant_8": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..fa768b28 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1248,6 +1248,7 @@ class PairGrid(Grid):\n         if vars is not None:\n             x_vars = list(vars)\n             y_vars = list(vars)\n+\n         if x_vars is None:\n             x_vars = numeric_cols\n         if y_vars is None:\n@@ -1258,6 +1259,7 @@ class PairGrid(Grid):\n         if np.isscalar(y_vars):\n             y_vars = [y_vars]\n \n+\n         self.x_vars = x_vars = list(x_vars)\n         self.y_vars = y_vars = list(y_vars)\n         self.square_grid = self.x_vars == self.y_vars\n@@ -1439,6 +1441,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1448,7 +1453,11 @@ class PairGrid(Grid):\n                     if x_var == y_var:\n \n                         # Make the density axes\n-                        diag_vars.append(x_var)\n+                        # Ensure MultiIndex columns are preserved as tuples\n+                        if isinstance(x_var, tuple):\n+                            diag_vars.append(x_var)\n+                        else:\n+                            diag_vars.append(x_var)\n                         ax = self.axes[i, j]\n                         diag_ax = ax.twinx()\n                         diag_ax.set_axis_off()\n@@ -1472,12 +1481,20 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n+            self.diag_vars = np.array(diag_vars, dtype=object)\n             self.diag_axes = np.array(diag_axes, np.object_)\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n \n+        # Loop over diagonal variables and axes, making one plot in each\n+        for var, ax in zip(self.diag_vars, self.diag_axes):\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+\n         # Loop over diagonal variables and axes, making one plot in each\n         for var, ax in zip(self.diag_vars, self.diag_axes):\n \n@@ -1487,6 +1504,13 @@ class PairGrid(Grid):\n             else:\n                 plt.sca(ax)\n \n+            # Ensure var is properly formatted for MultiIndex columns\n+            if isinstance(self.data.columns, pd.MultiIndex):\n+                # For MultiIndex, ensure var is a tuple if it should be\n+                if isinstance(var, str) and var in [str(col) for col in self.data.columns]:\n+                    # Find the matching tuple column\n+                    var = next(col for col in self.data.columns if str(col) == var)\n+            \n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n@@ -1661,12 +1685,17 @@ class PairGrid(Grid):\n         for ax, label in zip(self.axes[:, 0], self.y_vars):\n             ax.set_ylabel(label)\n \n+\n     def _find_numeric_cols(self, data):\n         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n         numeric_cols = []\n         for col in data:\n             if variable_type(data[col]) == \"numeric\":\n-                numeric_cols.append(col)\n+                # Ensure MultiIndex columns remain as tuples\n+                if isinstance(data.columns, pd.MultiIndex):\n+                    numeric_cols.append(col)\n+                else:\n+                    numeric_cols.append(col)\n         return numeric_cols\n \n \n"
  }
}