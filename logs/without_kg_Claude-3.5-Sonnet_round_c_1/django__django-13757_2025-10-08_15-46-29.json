{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/fields/json.py lines 368-371)": "\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/fields/json.py lines 373-376)": "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check if key doesn't exist using JSON_TYPE IS NULL\n        template = 'JSON_TYPE(%s, %%s) IS NULL'\n        sql, params = self.lhs.lhs.as_sql(compiler, connection)\n        return template % sql, tuple(params) + (self.lhs.key_name,)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/fields/json.py lines 368-371)": [
      "\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n",
      "\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        # Use NOT JSON_EXISTS to check for key absence (inverse of HasKey)\n        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n",
      "\ndef as_oracle(self, compiler, connection):\n    if not self.rhs:\n        return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n    sql, params = self.lhs.as_sql(compiler, connection)\n    return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n\ndef as_sqlite(self, compiler, connection):\n    if not self.rhs:\n        return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n    sql, params = self.lhs.as_sql(compiler, connection)\n    return \"JSON_TYPE(%s, %%s) IS NULL\" % sql, params + [self.lhs.key_name]\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check if key is missing (inverse of HasKey)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return 'NOT JSON_EXISTS(%s, \\'%s\\')' % (sql, self.lhs.key_name), params\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check if key is missing (inverse of HasKey)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return 'JSON_TYPE(%s, %s) IS NULL' % (sql, '%s'), params + [self.lhs.key_name]\n",
      "\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return \"JSON_TYPE(%s, %%s) IS NULL\" % sql, params + [self.lhs.key_name]\n",
      "\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check if key is missing (inverse of HasKey)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return 'NOT JSON_EXISTS(%s, \\'%s\\')' % (sql, self.lhs.key_name), params\n",
      "\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check if key is missing (inverse of HasKey)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, we need the inverse of HasKey logic\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, we need the inverse of HasKey logic\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return \"JSON_TYPE(%s, %%s) IS NULL\" % sql, params + [self.lhs.key_name]\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/fields/json.py lines 373-376)": [
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, we need to check if the key doesn't exist\n        # This is the inverse of HasKey logic\n        template = 'JSON_TYPE(%s, %%s) IS NULL'\n        sql, params = self.lhs.lhs.as_sql(compiler, connection)\n        params.append(self.lhs.compile_json_path([self.lhs.key_name], include_root=False))\n        return template % sql, params\n",
      "\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        sql = \"NOT JSON_EXISTS(%s, '%%s')\" % sql\n        return sql, params + [self.lhs.key_name]\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        sql = \"JSON_TYPE(%s, %%s) IS NULL\" % sql\n        return sql, params + [self.lhs.key_name]\n",
      "\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check if key is missing (inverse of HasKey)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        key_name = self.lhs.key_name\n        return f\"NOT JSON_EXISTS({sql}, %s)\", params + [f'$.{key_name}']\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check if key is missing (inverse of HasKey)\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return f\"JSON_TYPE({sql}, %s) IS NULL\", params + [f'$.{self.lhs.key_name}']\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check if key is missing (JSON_TYPE returns NULL for missing keys)\n        template = 'JSON_TYPE(%s, %%s) IS NULL'\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return template % sql, params + [self.lhs.key_name]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check if key is missing (JSON_TYPE returns NULL for missing keys)\n        template = 'JSON_TYPE(%s, %%s) IS NULL'\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return template % sql, tuple(params) + (self.lhs.key_name,)\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check if key is missing (JSON_TYPE returns NULL for missing keys)\n        template = 'JSON_TYPE(%s, %%s) IS NULL'\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return template % sql, params + [self.lhs.key_name]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check if key is missing (JSON_TYPE returns NULL for missing keys)\n        template = 'JSON_TYPE(%s, %%s) IS NULL'\n        sql, params = self.lhs.lhs.as_sql(compiler, connection)\n        return template % sql, params + [self.lhs.key_name]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        template = 'JSON_TYPE(%s, %%s) IS NULL'\n        sql, params = self.lhs.as_sql(compiler, connection)\n        return template % sql, params + [self.lhs.key_name]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..7d1b910301 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,22 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key does NOT exist\n+        sql, params = HasKey(self.lhs.lhs, self.lhs.key_name).as_sql(compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\")\n+        # Add paths directly into SQL because path expressions cannot be passed\n+        # as bind variables on Oracle.\n+        return 'NOT (%s)' % (sql % tuple(params)), []\n+\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key does NOT exist\n+        return HasKey(self.lhs.lhs, self.lhs.key_name).as_sql(compiler, connection, template='JSON_TYPE(%s, %%s) IS NULL')\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_0": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..63670e44f1 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,21 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n+\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check if key doesn't exist using JSON_TYPE IS NULL\n+        template = 'JSON_TYPE(%s, %%s) IS NULL'\n+        sql, params = self.lhs.lhs.as_sql(compiler, connection)\n+        return template % sql, tuple(params) + (self.lhs.key_name,)\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_1": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..02106a84a8 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,23 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n+\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, we need to check if the key doesn't exist\n+        # This is the inverse of HasKey logic\n+        template = 'JSON_TYPE(%s, %%s) IS NULL'\n+        sql, params = self.lhs.lhs.as_sql(compiler, connection)\n+        params.append(self.lhs.compile_json_path([self.lhs.key_name], include_root=False))\n+        return template % sql, params\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_2": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..692db01cf7 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,28 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        # Use NOT JSON_EXISTS to check for key absence (inverse of HasKey)\n+        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n+\n+\n+    def as_oracle(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        sql = \"NOT JSON_EXISTS(%s, '%%s')\" % sql\n+        return sql, params + [self.lhs.key_name]\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        sql = \"JSON_TYPE(%s, %%s) IS NULL\" % sql\n+        return sql, params + [self.lhs.key_name]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_3": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..74e88b7ca1 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,34 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n+def as_oracle(self, compiler, connection):\n+    if not self.rhs:\n+        return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n+    sql, params = self.lhs.as_sql(compiler, connection)\n+    return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n+\n+def as_sqlite(self, compiler, connection):\n+    if not self.rhs:\n+        return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+    sql, params = self.lhs.as_sql(compiler, connection)\n+    return \"JSON_TYPE(%s, %%s) IS NULL\" % sql, params + [self.lhs.key_name]\n+\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check if key is missing (inverse of HasKey)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        key_name = self.lhs.key_name\n+        return f\"NOT JSON_EXISTS({sql}, %s)\", params + [f'$.{key_name}']\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check if key is missing (inverse of HasKey)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return f\"JSON_TYPE({sql}, %s) IS NULL\", params + [f'$.{self.lhs.key_name}']\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_4": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..f74da06c80 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,33 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check if key is missing (inverse of HasKey)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return 'NOT JSON_EXISTS(%s, \\'%s\\')' % (sql, self.lhs.key_name), params\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check if key is missing (inverse of HasKey)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return 'JSON_TYPE(%s, %s) IS NULL' % (sql, '%s'), params + [self.lhs.key_name]\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        # For isnull=True, check if key is missing (JSON_TYPE returns NULL for missing keys)\n+        template = 'JSON_TYPE(%s, %%s) IS NULL'\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return template % sql, params + [self.lhs.key_name]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_5": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..0850bebc0d 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,27 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return \"JSON_TYPE(%s, %%s) IS NULL\" % sql, params + [self.lhs.key_name]\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        # For isnull=True, check if key is missing (JSON_TYPE returns NULL for missing keys)\n+        template = 'JSON_TYPE(%s, %%s) IS NULL'\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return template % sql, tuple(params) + (self.lhs.key_name,)\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_6": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..6c347cdca1 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,22 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check if key is missing (inverse of HasKey)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return 'NOT JSON_EXISTS(%s, \\'%s\\')' % (sql, self.lhs.key_name), params\n+\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check if key is missing (JSON_TYPE returns NULL for missing keys)\n+        template = 'JSON_TYPE(%s, %%s) IS NULL'\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return template % sql, params + [self.lhs.key_name]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_7": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..3066be598c 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,22 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check if key is missing (inverse of HasKey)\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n+\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check if key is missing (JSON_TYPE returns NULL for missing keys)\n+        template = 'JSON_TYPE(%s, %%s) IS NULL'\n+        sql, params = self.lhs.lhs.as_sql(compiler, connection)\n+        return template % sql, params + [self.lhs.key_name]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_8": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..7ccdcbefb6 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,32 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, we need the inverse of HasKey logic\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return \"NOT JSON_EXISTS(%s, '%%s')\" % sql, params + [self.lhs.key_name]\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, we need the inverse of HasKey logic\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return \"JSON_TYPE(%s, %%s) IS NULL\" % sql, params + [self.lhs.key_name]\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        template = 'JSON_TYPE(%s, %%s) IS NULL'\n+        sql, params = self.lhs.as_sql(compiler, connection)\n+        return template % sql, params + [self.lhs.key_name]\n \n \n class KeyTransformIn(lookups.In):\n"
  }
}