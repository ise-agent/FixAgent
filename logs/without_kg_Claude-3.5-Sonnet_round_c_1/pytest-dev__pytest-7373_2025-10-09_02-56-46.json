{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/pytest/src/_pytest/mark/evaluate.py lines 18-18)": "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
    "Location 2 (/root/hy/projects_1/pytest/src/_pytest/mark/evaluate.py lines 21-31)": "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
    "Location 3 (/root/hy/projects_1/pytest/src/_pytest/mark/evaluate.py lines 101-101)": "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/pytest/src/_pytest/mark/evaluate.py lines 18-18)": [
      "\n# Remove the evalcache_key line entirely - no replacement needed\n",
      "\n# Remove this line entirely - no replacement needed\n",
      "\nimport os\nimport platform\nimport sys\nimport traceback\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\n\nfrom ..outcomes import fail\nfrom ..outcomes import TEST_OUTCOME\nfrom .structures import Mark\nfrom _pytest.config import Config\nfrom _pytest.nodes import Item\nfrom _pytest.store import StoreKey\nimport _pytest._code\n\n\ndef _get_env() -> Dict[str, str]:\n    return dict(os.environ)\n\n\ndef _get_platform() -> str:\n    return platform.platform()\n\n\ndef _get_python_version() -> str:\n    return \".\".join(str(x) for x in sys.version_info[:3])\n\n\nclass MarkEvaluator:\n    def __init__(self, item: Item, name: str) -> None:\n        self.item = item\n        self.name = name\n\n    def _getglobals(self) -> Dict[str, object]:\n        d = {\"os\": os, \"sys\": sys, \"platform\": platform, \"config\": self.item.config}\n        if hasattr(self.item, \"module\"):\n            d.update(self.item.module.__dict__)\n        d[\"item\"] = self.item\n        return d\n\n    def _ismatch(self, name: str, value: object) -> bool:\n        return self.name in name\n\n    def _marks(self) -> List[Mark]:\n        return [mark for mark in self.item.iter_markers(name=self.name)]\n\n    def _istrue(self, condition: str) -> bool:\n        if condition:\n            d = self._getglobals()\n            import _pytest._code\n            exprcode = _pytest._code.compile(condition, mode=\"eval\")\n            result = eval(exprcode, d)\n            return bool(result)\n        return False\n\n    def get(self, attr: str, default: Optional[object] = None) -> object:\n        if self._marks():\n            mark = self._marks()[-1]\n            if hasattr(mark, attr):\n                return getattr(mark, attr)\n        return default\n\n    def __bool__(self) -> bool:\n        return bool(self._marks())\n\n    def wasvalid(self) -> bool:\n        return not hasattr(self, \"exc\")\n\n    def invalidraise(self, exc: Exception) -> None:\n        raises = self.get(\"raises\")\n        if raises is not None:\n            fail(f\"Error evaluating {self.name!r} expression\\n\"\n                 f\"    {self.condition!r}\\n{exc}\", pytrace=False)\n\n    def istrue(self) -> bool:\n        try:\n            return self._istrue(self.condition)\n        except Exception as exc:\n            self.exc = exc\n            if isinstance(exc, SyntaxError):\n                msg = [\" \" * (exc.offset or 0) + \"^\"]\n                msg.append(f\"SyntaxError: {exc.msg}\")\n                fail(f\"Error evaluating {self.name!r} expression\\n\"\n                     f\"    {self.condition!r}\\n\" + \"\\n\".join(msg), pytrace=False)\n            else:\n                fail(f\"Error evaluating {self.name!r} expression\\n\"\n                     f\"    {self.condition!r}\\n{exc}\", pytrace=False)\n\n    @property\n    def condition(self) -> str:\n        mark = self._marks()[-1] if self._marks() else None\n        if mark and mark.args:\n            return mark.args[0]\n        else:\n            return \"\"\n\n    @property\n    def reason(self) -> str:\n        mark = self._marks()[-1] if self._marks() else None\n        if mark:\n            if len(mark.args) >= 2:\n                return mark.args[1]\n            elif \"reason\" in mark.kwargs:\n                return mark.kwargs[\"reason\"]\n        return \"\"\n\n\ndef pytest_runtest_setup(item: Item) -> None:\n    # Evaluate skip conditions\n    eval_skipif = MarkEvaluator(item, \"skipif\")\n    if eval_skipif:\n        if eval_skipif.istrue():\n            pytest.skip(eval_skipif.reason)\n\n    # Evaluate xfail conditions  \n    eval_xfail = MarkEvaluator(item, \"xfail\")\n    if eval_xfail:\n        condition = eval_xfail.condition\n        if condition:\n            if eval_xfail.istrue():\n                reason = eval_xfail.reason\n                pytest.xfail(reason)\n        else:\n            reason = eval_xfail.reason\n            pytest.xfail(reason)\n",
      "\n# Remove this line - no cache key needed\n",
      "\n# Remove this line - evalcache_key definition should be deleted entirely\n",
      "\n# Remove this line entirely - no replacement needed\n",
      "\n# Remove this line entirely - no replacement needed\n",
      "\n# Remove this line - no cache key needed\n"
    ],
    "Location 2 (/root/hy/projects_1/pytest/src/_pytest/mark/evaluate.py lines 21-31)": [
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n"
    ],
    "Location 3 (/root/hy/projects_1/pytest/src/_pytest/mark/evaluate.py lines 101-101)": [
      "\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n",
      "\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n",
      "\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n",
      "\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n",
      "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n",
      "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n",
      "\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n",
      "\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..5d89cbaab 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,12 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+\n+\n+\n \n \n class MarkEvaluator:\n@@ -98,7 +90,9 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_0": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..ebf106f3c 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,19 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n-\n \n def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n+    import _pytest._code\n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n+\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +97,23 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n+                        if \"reason\" not in mark.kwargs:\n+                            # XXX better be checked at collection time\n+                            msg = (\n+                                \"you need to specify reason=STRING \"\n+                                \"when using booleans as conditions.\"\n+                            )\n+                            fail(msg)\n+                        result = bool(expr)\n+                    if result:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_1": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..f5d67c058 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,16 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n+\n+# Remove the evalcache_key line entirely - no replacement needed\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +94,13 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_2": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..89c85c664 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,16 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n+\n+# Remove this line entirely - no replacement needed\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +94,13 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_3": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..f1836e34b 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,142 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n \n+import os\n+import platform\n+import sys\n+import traceback\n+from typing import Any\n+from typing import Dict\n+from typing import List\n+from typing import Optional\n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n+from ..outcomes import fail\n+from ..outcomes import TEST_OUTCOME\n+from .structures import Mark\n+from _pytest.config import Config\n+from _pytest.nodes import Item\n+from _pytest.store import StoreKey\n+import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+\n+def _get_env() -> Dict[str, str]:\n+    return dict(os.environ)\n+\n+\n+def _get_platform() -> str:\n+    return platform.platform()\n+\n+\n+def _get_python_version() -> str:\n+    return \".\".join(str(x) for x in sys.version_info[:3])\n+\n+\n+class MarkEvaluator:\n+    def __init__(self, item: Item, name: str) -> None:\n+        self.item = item\n+        self.name = name\n+\n+    def _getglobals(self) -> Dict[str, object]:\n+        d = {\"os\": os, \"sys\": sys, \"platform\": platform, \"config\": self.item.config}\n+        if hasattr(self.item, \"module\"):\n+            d.update(self.item.module.__dict__)\n+        d[\"item\"] = self.item\n+        return d\n+\n+    def _ismatch(self, name: str, value: object) -> bool:\n+        return self.name in name\n+\n+    def _marks(self) -> List[Mark]:\n+        return [mark for mark in self.item.iter_markers(name=self.name)]\n+\n+    def _istrue(self, condition: str) -> bool:\n+        if condition:\n+            d = self._getglobals()\n+            import _pytest._code\n+            exprcode = _pytest._code.compile(condition, mode=\"eval\")\n+            result = eval(exprcode, d)\n+            return bool(result)\n+        return False\n+\n+    def get(self, attr: str, default: Optional[object] = None) -> object:\n+        if self._marks():\n+            mark = self._marks()[-1]\n+            if hasattr(mark, attr):\n+                return getattr(mark, attr)\n+        return default\n+\n+    def __bool__(self) -> bool:\n+        return bool(self._marks())\n+\n+    def wasvalid(self) -> bool:\n+        return not hasattr(self, \"exc\")\n+\n+    def invalidraise(self, exc: Exception) -> None:\n+        raises = self.get(\"raises\")\n+        if raises is not None:\n+            fail(f\"Error evaluating {self.name!r} expression\\n\"\n+                 f\"    {self.condition!r}\\n{exc}\", pytrace=False)\n+\n+    def istrue(self) -> bool:\n+        try:\n+            return self._istrue(self.condition)\n+        except Exception as exc:\n+            self.exc = exc\n+            if isinstance(exc, SyntaxError):\n+                msg = [\" \" * (exc.offset or 0) + \"^\"]\n+                msg.append(f\"SyntaxError: {exc.msg}\")\n+                fail(f\"Error evaluating {self.name!r} expression\\n\"\n+                     f\"    {self.condition!r}\\n\" + \"\\n\".join(msg), pytrace=False)\n+            else:\n+                fail(f\"Error evaluating {self.name!r} expression\\n\"\n+                     f\"    {self.condition!r}\\n{exc}\", pytrace=False)\n+\n+    @property\n+    def condition(self) -> str:\n+        mark = self._marks()[-1] if self._marks() else None\n+        if mark and mark.args:\n+            return mark.args[0]\n+        else:\n+            return \"\"\n+\n+    @property\n+    def reason(self) -> str:\n+        mark = self._marks()[-1] if self._marks() else None\n+        if mark:\n+            if len(mark.args) >= 2:\n+                return mark.args[1]\n+            elif \"reason\" in mark.kwargs:\n+                return mark.kwargs[\"reason\"]\n+        return \"\"\n+\n+\n+def pytest_runtest_setup(item: Item) -> None:\n+    # Evaluate skip conditions\n+    eval_skipif = MarkEvaluator(item, \"skipif\")\n+    if eval_skipif:\n+        if eval_skipif.istrue():\n+            pytest.skip(eval_skipif.reason)\n+\n+    # Evaluate xfail conditions  \n+    eval_xfail = MarkEvaluator(item, \"xfail\")\n+    if eval_xfail:\n+        condition = eval_xfail.condition\n+        if condition:\n+            if eval_xfail.istrue():\n+                reason = eval_xfail.reason\n+                pytest.xfail(reason)\n+        else:\n+            reason = eval_xfail.reason\n+            pytest.xfail(reason)\n+\n+\n+\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +220,11 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_4": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..117ff8902 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,16 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n+\n+# Remove this line - no cache key needed\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +94,10 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_5": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..0bc9bcf72 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,16 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n+\n+# Remove this line - evalcache_key definition should be deleted entirely\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +94,23 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n+                        if \"reason\" not in mark.kwargs:\n+                            # XXX better be checked at collection time\n+                            msg = (\n+                                \"you need to specify reason=STRING \"\n+                                \"when using booleans as conditions.\"\n+                            )\n+                            fail(msg)\n+                        result = bool(expr)\n+                    if result:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_6": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..56cac2e0a 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,16 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n+\n+# Remove this line entirely - no replacement needed\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +94,23 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n+                        if \"reason\" not in mark.kwargs:\n+                            # XXX better be checked at collection time\n+                            msg = (\n+                                \"you need to specify reason=STRING \"\n+                                \"when using booleans as conditions.\"\n+                            )\n+                            fail(msg)\n+                        result = bool(expr)\n+                    if result:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_7": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..89c85c664 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,16 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n+\n+# Remove this line entirely - no replacement needed\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +94,13 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_8": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..4d6f2b56c 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,16 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n+\n+# Remove this line - no cache key needed\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +94,11 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n"
  }
}