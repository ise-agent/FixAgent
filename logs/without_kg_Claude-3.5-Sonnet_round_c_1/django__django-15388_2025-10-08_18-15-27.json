{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/template/autoreload.py lines 20-24)": "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that would cause excessive watching\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip if directory is the project root or a parent directory\n            if dir_path.resolve() == cwd.resolve() or cwd.resolve().is_relative_to(dir_path.resolve()):\n                continue\n            items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n",
    "Location 2 (/root/hy/projects_1/django/django/template/autoreload.py lines 44-47)": "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that would be too broad (like project root)\n        try:\n            # Check if directory is a parent of the current working directory\n            cwd = Path.cwd()\n            if directory == cwd or cwd.is_relative_to(directory):\n                continue\n            \n            # Check if directory contains too many files (safety limit)\n            file_count = sum(1 for _ in directory.rglob('*') if _.is_file())\n            if file_count > 10000:  # Reasonable limit for template files\n                continue\n                \n        except (OSError, ValueError):\n            # Skip directories that can't be accessed or analyzed\n            continue\n            \n        sender.watch_dir(directory, '**/*')\n",
    "Location 3 (/root/hy/projects_1/django/django/template/autoreload.py lines 50-54)": "\n@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndef template_changed(sender, file_path, **kwargs):\n    # Convert file_path to Path object if it isn't already\n    file_path = to_path(file_path)\n    \n    for template_dir in get_template_directories():\n        template_dir = to_path(template_dir)\n        try:\n            # Use resolve() to handle symlinks and relative_to() for accurate comparison\n            file_path.resolve().relative_to(template_dir.resolve())\n            reset_loaders()\n            return True\n        except ValueError:\n            # file_path is not under template_dir, continue checking\n            continue\n    return False\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/template/autoreload.py lines 20-24)": [
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are too broad to watch efficiently\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip if directory is the project root or a parent directory\n            if dir_path.resolve() == cwd.resolve() or cwd.resolve().is_relative_to(dir_path.resolve()):\n                continue\n            items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that would cause excessive watching\n        for dir_path in backend.engine.dirs:\n            resolved_dir = cwd / to_path(dir_path)\n            # Skip if directory is the project root or would watch too broadly\n            if resolved_dir.resolve() == cwd.resolve():\n                continue\n            # Skip if directory is a parent of the current working directory\n            try:\n                cwd.relative_to(resolved_dir.resolve())\n                continue  # Skip this directory as it's a parent of cwd\n            except ValueError:\n                pass  # Not a parent, safe to add\n            items.add(resolved_dir)\n\n        for loader in backend.engine.template_loaders:\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that would cause excessive file watching\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip if directory is the project root or a parent directory\n            if dir_path.resolve() == cwd.resolve() or cwd.resolve().is_relative_to(dir_path.resolve()):\n                continue\n            items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are too broad to watch efficiently\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip if directory is the project root or a parent directory\n            if dir_path == cwd or cwd.is_relative_to(dir_path):\n                continue\n            items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are too broad to watch efficiently\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip if directory is the project root or contains it\n            if dir_path == cwd or cwd.is_relative_to(dir_path):\n                continue\n            items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that would cause excessive file watching\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip if directory is the project root or a parent directory\n            if dir_path.resolve() == cwd.resolve() or cwd.resolve().is_relative_to(dir_path.resolve()):\n                continue\n            items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            items.update(\n                cwd / to_path(directory)\n                for directory in loader.get_dirs()\n                if not is_django_path(directory)\n            )\n    return items\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are too broad (like project root)\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip if directory is the current working directory or a parent of it\n            if dir_path == cwd or cwd.is_relative_to(dir_path):\n                continue\n            items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that would cause excessive file watching\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip if directory is the project root or contains it\n            if dir_path == cwd or cwd.is_relative_to(dir_path):\n                continue\n            items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/template/autoreload.py lines 44-47)": [
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are too broad (like project root)\n        try:\n            # Check if directory is a parent of the current working directory\n            cwd = Path.cwd()\n            if directory == cwd or cwd.is_relative_to(directory):\n                continue\n            \n            # Check if directory contains too many files (potential project root)\n            file_count = sum(1 for _ in directory.rglob('*') if _.is_file())\n            if file_count > 1000:  # Arbitrary threshold for \"too many files\"\n                continue\n                \n        except (OSError, ValueError):\n            # Skip directories that cause errors during validation\n            continue\n            \n        sender.watch_dir(directory, '**/*')\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are too broad (like project root)\n        try:\n            # Check if directory is a parent of current working directory\n            cwd = Path.cwd()\n            if directory == cwd or cwd.is_relative_to(directory):\n                continue\n            \n            # Estimate file count to avoid overwhelming the watcher\n            file_count = sum(1 for _ in directory.rglob('*') if _.is_file())\n            if file_count > 10000:  # Skip directories with too many files\n                continue\n                \n        except (OSError, ValueError):\n            # Skip directories that can't be accessed or processed\n            continue\n            \n        sender.watch_dir(directory, '**/*')\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip directories that are too broad or could cause performance issues\n        try:\n            # Convert to Path object for easier manipulation\n            dir_path = Path(directory)\n            \n            # Skip if directory is the current working directory or a parent of it\n            cwd = Path.cwd()\n            if dir_path == cwd or cwd.is_relative_to(dir_path):\n                continue\n                \n            # Skip if directory contains common project markers indicating it's a project root\n            project_markers = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n            if any((dir_path / marker).exists() for marker in project_markers):\n                continue\n                \n            sender.watch_dir(directory, '**/*')\n        except (OSError, ValueError):\n            # Skip directories that can't be accessed or processed\n            continue\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are too broad (like project root)\n        try:\n            # Check if directory contains too many files/subdirectories\n            dir_path = Path(directory)\n            if dir_path.exists():\n                # Count immediate subdirectories to estimate scope\n                subdirs = sum(1 for p in dir_path.iterdir() if p.is_dir())\n                # Skip if directory has many subdirectories (likely project root)\n                if subdirs > 20:\n                    continue\n                \n                # Check if this directory is a parent of the current working directory\n                cwd = Path.cwd()\n                if cwd != dir_path and (dir_path in cwd.parents or cwd in dir_path.parents):\n                    continue\n        except (OSError, PermissionError):\n            # Skip directories we can't access\n            continue\n            \n        sender.watch_dir(directory, '**/*')\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that would cause excessive file monitoring\n        try:\n            # Check if directory is too broad by looking for common project indicators\n            if any((directory / indicator).exists() for indicator in ['manage.py', 'setup.py', '.git', 'pyproject.toml']):\n                continue\n            \n            # Estimate file count to avoid watching directories with too many files\n            file_count = sum(1 for _ in directory.rglob('*') if _.is_file())\n            if file_count > 1000:  # Reasonable threshold for template directories\n                continue\n                \n        except (OSError, PermissionError):\n            # Skip directories we can't read\n            continue\n            \n        sender.watch_dir(directory, '**/*')\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are too broad or could cause performance issues\n        try:\n            # Check if directory is the current working directory or a parent of it\n            cwd = Path.cwd()\n            if directory == cwd or directory in cwd.parents:\n                continue\n            \n            # Check if directory contains common project root indicators\n            project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n            if any((directory / indicator).exists() for indicator in project_indicators):\n                continue\n                \n            sender.watch_dir(directory, '**/*')\n        except (OSError, ValueError):\n            # Skip directories that can't be accessed or processed\n            continue\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip directories that would cause excessive file watching\n        try:\n            # Convert to Path for consistent comparison\n            dir_path = to_path(directory)\n            \n            # Skip if directory contains the current working directory\n            cwd = Path.cwd()\n            if cwd == dir_path or cwd in dir_path.parents:\n                continue\n                \n            # Skip if directory appears to be a project root (contains manage.py or common project files)\n            if any((dir_path / marker).exists() for marker in ['manage.py', 'setup.py', 'pyproject.toml', '.git']):\n                continue\n                \n        except (OSError, ValueError):\n            # Skip directories that can't be processed\n            continue\n            \n        sender.watch_dir(directory, '**/*')\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that would be too broad (like project root)\n        try:\n            # Check if directory is too broad by counting immediate subdirectories\n            subdirs = [p for p in directory.iterdir() if p.is_dir()]\n            if len(subdirs) > 20:  # Arbitrary threshold for \"too many subdirs\"\n                continue\n            \n            # Check if directory contains manage.py (likely project root)\n            if (directory / 'manage.py').exists():\n                continue\n                \n            # Check if directory is ancestor of current working directory\n            cwd = Path.cwd()\n            if cwd != directory and cwd.is_relative_to(directory):\n                continue\n                \n        except (OSError, PermissionError):\n            # Skip directories we can't read\n            continue\n            \n        sender.watch_dir(directory, '**/*')\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/template/autoreload.py lines 50-54)": [
      "\n@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndef template_changed(sender, file_path, **kwargs):\n    # Convert to Path object if needed\n    file_path = Path(file_path) if not isinstance(file_path, Path) else file_path\n    \n    # Cache template directories to avoid repeated calls\n    if not hasattr(template_changed, '_template_dirs'):\n        template_changed._template_dirs = list(get_template_directories())\n    \n    # Check if the changed file is in any template directory\n    # Use more efficient path checking to avoid expensive operations on broad directories\n    for template_dir in template_changed._template_dirs:\n        try:\n            # Use relative_to() which is more efficient than checking parents\n            file_path.relative_to(template_dir)\n            reset_loaders()\n            return True\n        except ValueError:\n            # File is not under this template directory, continue checking\n            continue\n    \n    return False\n",
      "\n@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndef template_changed(sender, file_path, **kwargs):\n    # Convert file_path to Path object if it isn't already\n    if not isinstance(file_path, Path):\n        file_path = Path(file_path)\n    \n    # Cache template directories to avoid repeated calls\n    template_dirs = list(get_template_directories())\n    \n    # Quick check: if no template directories, nothing to do\n    if not template_dirs:\n        return False\n    \n    # Check if the changed file is under any template directory\n    # Use a more efficient approach by checking parents once\n    file_parents = set(file_path.parents)\n    file_parents.add(file_path.parent)  # Include immediate parent\n    \n    for template_dir in template_dirs:\n        if template_dir in file_parents:\n            reset_loaders()\n            return True\n    \n    return False\n",
      "\n@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndef template_changed(sender, file_path, **kwargs):\n    # Convert file_path to Path object if it isn't already\n    file_path = to_path(file_path)\n    \n    for template_dir in get_template_directories():\n        template_dir = to_path(template_dir)\n        try:\n            # Use relative_to() to check if file is within template directory\n            # This is more efficient than checking all parents\n            file_path.relative_to(template_dir)\n            reset_loaders()\n            return True\n        except ValueError:\n            # file_path is not relative to template_dir, continue checking\n            continue\n    \n    return False\n",
      "\n@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndef template_changed(sender, file_path, **kwargs):\n    # Convert file_path to Path object for consistent comparison\n    file_path = Path(file_path)\n    \n    for template_dir in get_template_directories():\n        template_dir = Path(template_dir)\n        \n        # Check if file is within template directory\n        try:\n            file_path.relative_to(template_dir)\n            # File is within this template directory\n            reset_loaders()\n            return True\n        except ValueError:\n            # File is not within this template directory, continue checking\n            continue\n    \n    return False\n",
      "\n@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndef template_changed(sender, file_path, **kwargs):\n    # Convert file_path to Path object if it isn't already\n    file_path = to_path(file_path)\n    \n    for template_dir in get_template_directories():\n        template_dir = to_path(template_dir)\n        \n        # Use resolve() to handle symlinks and relative paths properly\n        try:\n            if template_dir.resolve() in file_path.resolve().parents or template_dir.resolve() == file_path.resolve().parent:\n                reset_loaders()\n                return True\n        except (OSError, ValueError):\n            # Handle cases where paths can't be resolved (e.g., non-existent paths)\n            continue\n",
      "\n@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndef template_changed(sender, file_path, **kwargs):\n    # Convert file_path to Path object if it's not already\n    file_path = to_path(file_path)\n    \n    for template_dir in get_template_directories():\n        template_dir = to_path(template_dir)\n        try:\n            # Use resolve() to handle symlinks and relative paths properly\n            if template_dir.resolve() in file_path.resolve().parents or template_dir.resolve() == file_path.resolve().parent:\n                reset_loaders()\n                return True\n        except (OSError, ValueError):\n            # Handle cases where paths can't be resolved (broken symlinks, etc.)\n            continue\n    return False\n",
      "\n@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndef template_changed(sender, file_path, **kwargs):\n    # Convert file_path to Path object if it isn't already\n    file_path = to_path(file_path)\n    \n    for template_dir in get_template_directories():\n        template_dir = to_path(template_dir)\n        try:\n            # Check if file_path is relative to template_dir\n            file_path.relative_to(template_dir)\n            reset_loaders()\n            return True\n        except ValueError:\n            # file_path is not under template_dir, continue checking\n            continue\n    return False\n",
      "\n@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndef template_changed(sender, file_path, **kwargs):\n    file_path = Path(file_path)\n    for template_dir in get_template_directories():\n        template_dir = Path(template_dir)\n        try:\n            # Use relative_to to check if file_path is under template_dir\n            # This is more efficient than checking parents\n            file_path.relative_to(template_dir)\n            reset_loaders()\n            return True\n        except ValueError:\n            # file_path is not under template_dir, continue checking\n            continue\n    return False\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..6d7a6d4367 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -17,9 +17,20 @@ def get_template_directories():\n     items = set()\n     for backend in engines.all():\n         if not isinstance(backend, DjangoTemplates):\n+\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out problematic directories like project roots that would cause\n+        # the file watcher to monitor too many files recursively\n+        template_dirs = []\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip directories that are at or above the current working directory\n+            # as they would cause recursive watching of the entire project\n+            if dir_path == cwd or cwd in dir_path.parents:\n+                continue\n+            template_dirs.append(dir_path)\n+        items.update(template_dirs)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -41,12 +52,22 @@ def reset_loaders():\n \n \n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n+        # Additional safety check: skip directories that are too broad\n+        # This prevents watching project roots even if they pass initial filtering\n+        try:\n+            # Check if directory has too many immediate subdirectories (likely a project root)\n+            if len(list(directory.iterdir())) > 50:\n+                continue\n+        except (OSError, PermissionError):\n+            # Skip directories we can't read\n+            continue\n         sender.watch_dir(directory, '**/*')\n \n-\n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n+\n def template_changed(sender, file_path, **kwargs):\n     for template_dir in get_template_directories():\n         if template_dir in file_path.parents:\n",
    "variant_0": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..ccb4cb0e84 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,15 @@ from django.utils.autoreload import (\n )\n \n \n+def get_template_directories():\n+    # Iterate through each template backend and find\n+    # any template_loader that has a 'get_dirs' method.\n+    # Collect the directories, filtering out Django templates.\n+    cwd = Path.cwd()\n+    items = set()\n+    for backend in engines.all():\n+        if not isinstance(backend, DjangoTemplates):\n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +28,13 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that would cause excessive watching\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip if directory is the project root or a parent directory\n+            if dir_path.resolve() == cwd.resolve() or cwd.resolve().is_relative_to(dir_path.resolve()):\n+                continue\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -40,15 +55,44 @@ def reset_loaders():\n             loader.reset()\n \n \n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n+        # Skip watching directories that would be too broad (like project root)\n+        try:\n+            # Check if directory is a parent of the current working directory\n+            cwd = Path.cwd()\n+            if directory == cwd or cwd.is_relative_to(directory):\n+                continue\n+            \n+            # Check if directory contains too many files (safety limit)\n+            file_count = sum(1 for _ in directory.rglob('*') if _.is_file())\n+            if file_count > 10000:  # Reasonable limit for template files\n+                continue\n+                \n+        except (OSError, ValueError):\n+            # Skip directories that can't be accessed or analyzed\n+            continue\n+            \n         sender.watch_dir(directory, '**/*')\n \n+@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n def template_changed(sender, file_path, **kwargs):\n+    # Convert file_path to Path object if it isn't already\n+    file_path = to_path(file_path)\n+    \n     for template_dir in get_template_directories():\n-        if template_dir in file_path.parents:\n+        template_dir = to_path(template_dir)\n+        try:\n+            # Use resolve() to handle symlinks and relative_to() for accurate comparison\n+            file_path.resolve().relative_to(template_dir.resolve())\n             reset_loaders()\n             return True\n+        except ValueError:\n+            # file_path is not under template_dir, continue checking\n+            continue\n+    return False\n",
    "variant_1": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..2b044beb2f 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,15 @@ from django.utils.autoreload import (\n )\n \n \n+def get_template_directories():\n+    # Iterate through each template backend and find\n+    # any template_loader that has a 'get_dirs' method.\n+    # Collect the directories, filtering out Django templates.\n+    cwd = Path.cwd()\n+    items = set()\n+    for backend in engines.all():\n+        if not isinstance(backend, DjangoTemplates):\n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +28,13 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are too broad to watch efficiently\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip if directory is the project root or a parent directory\n+            if dir_path.resolve() == cwd.resolve() or cwd.resolve().is_relative_to(dir_path.resolve()):\n+                continue\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -40,15 +55,50 @@ def reset_loaders():\n             loader.reset()\n \n \n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n+        # Skip watching directories that are too broad (like project root)\n+        try:\n+            # Check if directory is a parent of the current working directory\n+            cwd = Path.cwd()\n+            if directory == cwd or cwd.is_relative_to(directory):\n+                continue\n+            \n+            # Check if directory contains too many files (potential project root)\n+            file_count = sum(1 for _ in directory.rglob('*') if _.is_file())\n+            if file_count > 1000:  # Arbitrary threshold for \"too many files\"\n+                continue\n+                \n+        except (OSError, ValueError):\n+            # Skip directories that cause errors during validation\n+            continue\n+            \n         sender.watch_dir(directory, '**/*')\n \n+@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n def template_changed(sender, file_path, **kwargs):\n-    for template_dir in get_template_directories():\n-        if template_dir in file_path.parents:\n+    # Convert to Path object if needed\n+    file_path = Path(file_path) if not isinstance(file_path, Path) else file_path\n+    \n+    # Cache template directories to avoid repeated calls\n+    if not hasattr(template_changed, '_template_dirs'):\n+        template_changed._template_dirs = list(get_template_directories())\n+    \n+    # Check if the changed file is in any template directory\n+    # Use more efficient path checking to avoid expensive operations on broad directories\n+    for template_dir in template_changed._template_dirs:\n+        try:\n+            # Use relative_to() which is more efficient than checking parents\n+            file_path.relative_to(template_dir)\n             reset_loaders()\n             return True\n+        except ValueError:\n+            # File is not under this template directory, continue checking\n+            continue\n+    \n+    return False\n",
    "variant_2": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..4e3ce8268d 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,15 @@ from django.utils.autoreload import (\n )\n \n \n+def get_template_directories():\n+    # Iterate through each template backend and find\n+    # any template_loader that has a 'get_dirs' method.\n+    # Collect the directories, filtering out Django templates.\n+    cwd = Path.cwd()\n+    items = set()\n+    for backend in engines.all():\n+        if not isinstance(backend, DjangoTemplates):\n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +28,19 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that would cause excessive watching\n+        for dir_path in backend.engine.dirs:\n+            resolved_dir = cwd / to_path(dir_path)\n+            # Skip if directory is the project root or would watch too broadly\n+            if resolved_dir.resolve() == cwd.resolve():\n+                continue\n+            # Skip if directory is a parent of the current working directory\n+            try:\n+                cwd.relative_to(resolved_dir.resolve())\n+                continue  # Skip this directory as it's a parent of cwd\n+            except ValueError:\n+                pass  # Not a parent, safe to add\n+            items.add(resolved_dir)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -40,15 +61,52 @@ def reset_loaders():\n             loader.reset()\n \n \n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n+        # Skip watching directories that are too broad (like project root)\n+        try:\n+            # Check if directory is a parent of current working directory\n+            cwd = Path.cwd()\n+            if directory == cwd or cwd.is_relative_to(directory):\n+                continue\n+            \n+            # Estimate file count to avoid overwhelming the watcher\n+            file_count = sum(1 for _ in directory.rglob('*') if _.is_file())\n+            if file_count > 10000:  # Skip directories with too many files\n+                continue\n+                \n+        except (OSError, ValueError):\n+            # Skip directories that can't be accessed or processed\n+            continue\n+            \n         sender.watch_dir(directory, '**/*')\n \n+@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n def template_changed(sender, file_path, **kwargs):\n-    for template_dir in get_template_directories():\n-        if template_dir in file_path.parents:\n+    # Convert file_path to Path object if it isn't already\n+    if not isinstance(file_path, Path):\n+        file_path = Path(file_path)\n+    \n+    # Cache template directories to avoid repeated calls\n+    template_dirs = list(get_template_directories())\n+    \n+    # Quick check: if no template directories, nothing to do\n+    if not template_dirs:\n+        return False\n+    \n+    # Check if the changed file is under any template directory\n+    # Use a more efficient approach by checking parents once\n+    file_parents = set(file_path.parents)\n+    file_parents.add(file_path.parent)  # Include immediate parent\n+    \n+    for template_dir in template_dirs:\n+        if template_dir in file_parents:\n             reset_loaders()\n             return True\n+    \n+    return False\n",
    "variant_3": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..4c5de902ba 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,15 @@ from django.utils.autoreload import (\n )\n \n \n+def get_template_directories():\n+    # Iterate through each template backend and find\n+    # any template_loader that has a 'get_dirs' method.\n+    # Collect the directories, filtering out Django templates.\n+    cwd = Path.cwd()\n+    items = set()\n+    for backend in engines.all():\n+        if not isinstance(backend, DjangoTemplates):\n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +28,13 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that would cause excessive file watching\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip if directory is the project root or a parent directory\n+            if dir_path.resolve() == cwd.resolve() or cwd.resolve().is_relative_to(dir_path.resolve()):\n+                continue\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -40,15 +55,48 @@ def reset_loaders():\n             loader.reset()\n \n \n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip directories that are too broad or could cause performance issues\n+        try:\n+            # Convert to Path object for easier manipulation\n+            dir_path = Path(directory)\n+            \n+            # Skip if directory is the current working directory or a parent of it\n+            cwd = Path.cwd()\n+            if dir_path == cwd or cwd.is_relative_to(dir_path):\n+                continue\n+                \n+            # Skip if directory contains common project markers indicating it's a project root\n+            project_markers = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n+            if any((dir_path / marker).exists() for marker in project_markers):\n+                continue\n+                \n+            sender.watch_dir(directory, '**/*')\n+        except (OSError, ValueError):\n+            # Skip directories that can't be accessed or processed\n+            continue\n \n+@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n def template_changed(sender, file_path, **kwargs):\n+    # Convert file_path to Path object if it isn't already\n+    file_path = to_path(file_path)\n+    \n     for template_dir in get_template_directories():\n-        if template_dir in file_path.parents:\n+        template_dir = to_path(template_dir)\n+        try:\n+            # Use relative_to() to check if file is within template directory\n+            # This is more efficient than checking all parents\n+            file_path.relative_to(template_dir)\n             reset_loaders()\n             return True\n+        except ValueError:\n+            # file_path is not relative to template_dir, continue checking\n+            continue\n+    \n+    return False\n",
    "variant_4": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..43680a852e 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,15 @@ from django.utils.autoreload import (\n )\n \n \n+def get_template_directories():\n+    # Iterate through each template backend and find\n+    # any template_loader that has a 'get_dirs' method.\n+    # Collect the directories, filtering out Django templates.\n+    cwd = Path.cwd()\n+    items = set()\n+    for backend in engines.all():\n+        if not isinstance(backend, DjangoTemplates):\n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +28,13 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are too broad to watch efficiently\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip if directory is the project root or a parent directory\n+            if dir_path == cwd or cwd.is_relative_to(dir_path):\n+                continue\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -40,15 +55,50 @@ def reset_loaders():\n             loader.reset()\n \n \n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n+        # Skip watching directories that are too broad (like project root)\n+        try:\n+            # Check if directory contains too many files/subdirectories\n+            dir_path = Path(directory)\n+            if dir_path.exists():\n+                # Count immediate subdirectories to estimate scope\n+                subdirs = sum(1 for p in dir_path.iterdir() if p.is_dir())\n+                # Skip if directory has many subdirectories (likely project root)\n+                if subdirs > 20:\n+                    continue\n+                \n+                # Check if this directory is a parent of the current working directory\n+                cwd = Path.cwd()\n+                if cwd != dir_path and (dir_path in cwd.parents or cwd in dir_path.parents):\n+                    continue\n+        except (OSError, PermissionError):\n+            # Skip directories we can't access\n+            continue\n+            \n         sender.watch_dir(directory, '**/*')\n \n+@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n def template_changed(sender, file_path, **kwargs):\n+    # Convert file_path to Path object for consistent comparison\n+    file_path = Path(file_path)\n+    \n     for template_dir in get_template_directories():\n-        if template_dir in file_path.parents:\n+        template_dir = Path(template_dir)\n+        \n+        # Check if file is within template directory\n+        try:\n+            file_path.relative_to(template_dir)\n+            # File is within this template directory\n             reset_loaders()\n             return True\n+        except ValueError:\n+            # File is not within this template directory, continue checking\n+            continue\n+    \n+    return False\n",
    "variant_5": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..411a137bee 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,15 @@ from django.utils.autoreload import (\n )\n \n \n+def get_template_directories():\n+    # Iterate through each template backend and find\n+    # any template_loader that has a 'get_dirs' method.\n+    # Collect the directories, filtering out Django templates.\n+    cwd = Path.cwd()\n+    items = set()\n+    for backend in engines.all():\n+        if not isinstance(backend, DjangoTemplates):\n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +28,13 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are too broad to watch efficiently\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip if directory is the project root or contains it\n+            if dir_path == cwd or cwd.is_relative_to(dir_path):\n+                continue\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -40,15 +55,43 @@ def reset_loaders():\n             loader.reset()\n \n \n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n+        # Skip watching directories that would cause excessive file monitoring\n+        try:\n+            # Check if directory is too broad by looking for common project indicators\n+            if any((directory / indicator).exists() for indicator in ['manage.py', 'setup.py', '.git', 'pyproject.toml']):\n+                continue\n+            \n+            # Estimate file count to avoid watching directories with too many files\n+            file_count = sum(1 for _ in directory.rglob('*') if _.is_file())\n+            if file_count > 1000:  # Reasonable threshold for template directories\n+                continue\n+                \n+        except (OSError, PermissionError):\n+            # Skip directories we can't read\n+            continue\n+            \n         sender.watch_dir(directory, '**/*')\n \n+@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n def template_changed(sender, file_path, **kwargs):\n+    # Convert file_path to Path object if it isn't already\n+    file_path = to_path(file_path)\n+    \n     for template_dir in get_template_directories():\n-        if template_dir in file_path.parents:\n-            reset_loaders()\n-            return True\n+        template_dir = to_path(template_dir)\n+        \n+        # Use resolve() to handle symlinks and relative paths properly\n+        try:\n+            if template_dir.resolve() in file_path.resolve().parents or template_dir.resolve() == file_path.resolve().parent:\n+                reset_loaders()\n+                return True\n+        except (OSError, ValueError):\n+            # Handle cases where paths can't be resolved (e.g., non-existent paths)\n+            continue\n",
    "variant_6": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..37bdf73ece 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,15 @@ from django.utils.autoreload import (\n )\n \n \n+def get_template_directories():\n+    # Iterate through each template backend and find\n+    # any template_loader that has a 'get_dirs' method.\n+    # Collect the directories, filtering out Django templates.\n+    cwd = Path.cwd()\n+    items = set()\n+    for backend in engines.all():\n+        if not isinstance(backend, DjangoTemplates):\n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +28,13 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that would cause excessive file watching\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip if directory is the project root or a parent directory\n+            if dir_path.resolve() == cwd.resolve() or cwd.resolve().is_relative_to(dir_path.resolve()):\n+                continue\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -30,6 +45,14 @@ def get_template_directories():\n                 if not is_django_path(directory)\n             )\n     return items\n+            if not hasattr(loader, 'get_dirs'):\n+                continue\n+            items.update(\n+                cwd / to_path(directory)\n+                for directory in loader.get_dirs()\n+                if not is_django_path(directory)\n+            )\n+    return items\n \n \n def reset_loaders():\n@@ -40,15 +63,43 @@ def reset_loaders():\n             loader.reset()\n \n \n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip watching directories that are too broad or could cause performance issues\n+        try:\n+            # Check if directory is the current working directory or a parent of it\n+            cwd = Path.cwd()\n+            if directory == cwd or directory in cwd.parents:\n+                continue\n+            \n+            # Check if directory contains common project root indicators\n+            project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n+            if any((directory / indicator).exists() for indicator in project_indicators):\n+                continue\n+                \n+            sender.watch_dir(directory, '**/*')\n+        except (OSError, ValueError):\n+            # Skip directories that can't be accessed or processed\n+            continue\n \n+@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n def template_changed(sender, file_path, **kwargs):\n+    # Convert file_path to Path object if it's not already\n+    file_path = to_path(file_path)\n+    \n     for template_dir in get_template_directories():\n-        if template_dir in file_path.parents:\n-            reset_loaders()\n-            return True\n+        template_dir = to_path(template_dir)\n+        try:\n+            # Use resolve() to handle symlinks and relative paths properly\n+            if template_dir.resolve() in file_path.resolve().parents or template_dir.resolve() == file_path.resolve().parent:\n+                reset_loaders()\n+                return True\n+        except (OSError, ValueError):\n+            # Handle cases where paths can't be resolved (broken symlinks, etc.)\n+            continue\n+    return False\n",
    "variant_7": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..d5a904feff 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,15 @@ from django.utils.autoreload import (\n )\n \n \n+def get_template_directories():\n+    # Iterate through each template backend and find\n+    # any template_loader that has a 'get_dirs' method.\n+    # Collect the directories, filtering out Django templates.\n+    cwd = Path.cwd()\n+    items = set()\n+    for backend in engines.all():\n+        if not isinstance(backend, DjangoTemplates):\n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +28,13 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are too broad (like project root)\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip if directory is the current working directory or a parent of it\n+            if dir_path == cwd or cwd.is_relative_to(dir_path):\n+                continue\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -40,15 +55,46 @@ def reset_loaders():\n             loader.reset()\n \n \n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n+        # Skip directories that would cause excessive file watching\n+        try:\n+            # Convert to Path for consistent comparison\n+            dir_path = to_path(directory)\n+            \n+            # Skip if directory contains the current working directory\n+            cwd = Path.cwd()\n+            if cwd == dir_path or cwd in dir_path.parents:\n+                continue\n+                \n+            # Skip if directory appears to be a project root (contains manage.py or common project files)\n+            if any((dir_path / marker).exists() for marker in ['manage.py', 'setup.py', 'pyproject.toml', '.git']):\n+                continue\n+                \n+        except (OSError, ValueError):\n+            # Skip directories that can't be processed\n+            continue\n+            \n         sender.watch_dir(directory, '**/*')\n \n+@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n def template_changed(sender, file_path, **kwargs):\n+    # Convert file_path to Path object if it isn't already\n+    file_path = to_path(file_path)\n+    \n     for template_dir in get_template_directories():\n-        if template_dir in file_path.parents:\n+        template_dir = to_path(template_dir)\n+        try:\n+            # Check if file_path is relative to template_dir\n+            file_path.relative_to(template_dir)\n             reset_loaders()\n             return True\n+        except ValueError:\n+            # file_path is not under template_dir, continue checking\n+            continue\n+    return False\n",
    "variant_8": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..e5fd3f2fae 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,15 @@ from django.utils.autoreload import (\n )\n \n \n+def get_template_directories():\n+    # Iterate through each template backend and find\n+    # any template_loader that has a 'get_dirs' method.\n+    # Collect the directories, filtering out Django templates.\n+    cwd = Path.cwd()\n+    items = set()\n+    for backend in engines.all():\n+        if not isinstance(backend, DjangoTemplates):\n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +28,13 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that would cause excessive file watching\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip if directory is the project root or contains it\n+            if dir_path == cwd or cwd.is_relative_to(dir_path):\n+                continue\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -40,15 +55,47 @@ def reset_loaders():\n             loader.reset()\n \n \n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n+        # Skip watching directories that would be too broad (like project root)\n+        try:\n+            # Check if directory is too broad by counting immediate subdirectories\n+            subdirs = [p for p in directory.iterdir() if p.is_dir()]\n+            if len(subdirs) > 20:  # Arbitrary threshold for \"too many subdirs\"\n+                continue\n+            \n+            # Check if directory contains manage.py (likely project root)\n+            if (directory / 'manage.py').exists():\n+                continue\n+                \n+            # Check if directory is ancestor of current working directory\n+            cwd = Path.cwd()\n+            if cwd != directory and cwd.is_relative_to(directory):\n+                continue\n+                \n+        except (OSError, PermissionError):\n+            # Skip directories we can't read\n+            continue\n+            \n         sender.watch_dir(directory, '**/*')\n \n+@receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\n def template_changed(sender, file_path, **kwargs):\n+    file_path = Path(file_path)\n     for template_dir in get_template_directories():\n-        if template_dir in file_path.parents:\n+        template_dir = Path(template_dir)\n+        try:\n+            # Use relative_to to check if file_path is under template_dir\n+            # This is more efficient than checking parents\n+            file_path.relative_to(template_dir)\n             reset_loaders()\n             return True\n+        except ValueError:\n+            # file_path is not under template_dir, continue checking\n+            continue\n+    return False\n"
  }
}