{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/base.py lines 946-950)": "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Get the field from the current model's meta to ensure we use\n        # the child model's choices, not the parent's captured field\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 766-772)": "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self),\n                )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/base.py lines 946-950)": [
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Get the field definition from the current model instance to handle inheritance\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically get the field from the current model to ensure we use\n        # the child model's choices if they've been overridden\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Get the field from the current model's meta to handle inheritance properly\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Get the field from the current model's meta to ensure we use child model's choices\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically get the field from the current model to handle inheritance\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Get the field from the current model's meta to ensure we use\n        # the child model's field definition with extended choices\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Get the field from the current model's meta to ensure we use\n        # the child model's choices if they've been overridden\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically get the field from the current model to ensure we use\n        # the child model's choices if they've been extended\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/fields/__init__.py lines 766-772)": [
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field=self),\n                )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..165bec2585 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,10 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        choices_dict = dict(make_hashable(self._meta.get_field(field.name).flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..a2127de85b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,6 +763,7 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n",
    "variant_0": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..a758412680 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,13 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Get the field from the current model's meta to ensure we use\n+        # the child model's choices, not the parent's captured field\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..a2127de85b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,6 +763,7 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n",
    "variant_1": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..652806859a 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Get the field definition from the current model instance to handle inheritance\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..a2127de85b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,6 +763,7 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n",
    "variant_2": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..7fcb5d0c30 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,13 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically get the field from the current model to ensure we use\n+        # the child model's choices if they've been overridden\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..a2127de85b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,6 +763,7 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n",
    "variant_3": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..70a63dee80 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Get the field from the current model's meta to handle inheritance properly\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..a2127de85b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,6 +763,7 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n",
    "variant_4": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..54442a970e 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Get the field from the current model's meta to ensure we use child model's choices\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..a2127de85b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,6 +763,7 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n",
    "variant_5": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..741adbaeda 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically get the field from the current model to handle inheritance\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..a2127de85b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,6 +763,7 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n",
    "variant_6": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..fa20dd968e 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,13 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Get the field from the current model's meta to ensure we use\n+        # the child model's field definition with extended choices\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..a2127de85b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,6 +763,7 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n",
    "variant_7": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..8160acd688 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,13 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Get the field from the current model's meta to ensure we use\n+        # the child model's choices if they've been overridden\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..a2127de85b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,6 +763,7 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n",
    "variant_8": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..fe4a1021eb 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,13 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically get the field from the current model to ensure we use\n+        # the child model's choices if they've been extended\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..a2127de85b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,6 +763,7 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n"
  }
}