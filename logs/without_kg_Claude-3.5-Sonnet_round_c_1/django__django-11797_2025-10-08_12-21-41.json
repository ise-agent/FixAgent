{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 2085-2088)": "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 1920-1936)": "\ndef set_group_by(self, preserve_existing=False):\n    \"\"\"\n    Expand the GROUP BY clause required by the query.\n\n    This will usually be the set of all non-aggregate fields in the\n    return data. If the database backend supports grouping by the\n    primary key, and the query would be equivalent, the optimization\n    will be made automatically.\n    \n    Args:\n        preserve_existing: If True and group_by is already a tuple, preserve it\n    \"\"\"\n    if preserve_existing and isinstance(self.group_by, tuple):\n        return  # Don't override existing explicit GROUP BY\n        \n    group_by = list(self.select)\n    if self.annotation_select:\n        for alias, annotation in self.annotation_select.items():\n            try:\n                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n            except TypeError:\n                annotation_class = annotation.__class__\n                msg = (\n                    '`alias=None` must be added to the signature of '\n                    '%s.%s.get_group_by_cols().'\n                ) % (annotation_class.__module__, annotation_class.__qualname__)\n                warnings.warn(msg, category=RemovedInDjango40Warning)\n                group_by_cols = annotation.get_group_by_cols()\n            else:\n                group_by_cols = annotation.get_group_by_cols(alias=alias)\n            group_by.extend(group_by_cols)\n    self.group_by = tuple(group_by)\n",
    "Location 3 (/root/hy/projects_1/django/django/db/models/sql/where.py lines 241-245)": "\ndef as_sql(self, compiler, connection):\n    query = self.query_object\n    query.set_values(self.targets)\n    query_compiler = query.get_compiler(connection=connection)\n    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
    "Location 4 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 522-524)": "\n    def has_results(self, using):\n        q = self.clone()\n        if not q.distinct:\n            if q.group_by is True:\n                q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                q.set_group_by()\n            elif isinstance(q.group_by, tuple):\n                # Preserve existing GROUP BY clause when it's already set to specific fields\n                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n                pass\n            q.clear_select_clause()\n        q.clear_ordering(True)\n        q.set_limits(high=1)\n        compiler = q.get_compiler(using=using)\n        return compiler.has_results()\n",
    "Location 5 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 2080-2114)": "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n\n        if fields:\n            field_names = []\n            extra_names = []\n            annotation_names = []\n            if not self.extra and not self.annotations:\n                # Shortcut - if there are no extra or annotations, then\n                # the values() clause must be just field names.\n                field_names = list(fields)\n            else:\n                self.default_cols = False\n                for f in fields:\n                    if f in self.extra_select:\n                        extra_names.append(f)\n                    elif f in self.annotation_select:\n                        annotation_names.append(f)\n                    else:\n                        field_names.append(f)\n            self.set_extra_mask(extra_names)\n            self.set_annotation_mask(annotation_names)\n        else:\n            field_names = [f.attname for f in self.model._meta.concrete_fields]\n\n        self.values_select = tuple(field_names)\n        self.add_fields(field_names, True)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 2085-2088)": [
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass  # Don't call set_group_by() to preserve the original GROUP BY\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass  # Don't call set_group_by() to preserve the original GROUP BY\n\n        if fields:\n            field_names = []\n            extra_names = []\n            annotation_names = []\n            if not self.extra and not self.annotations:\n                # Shortcut - if there are no extra or annotations, then\n                # the values() clause must be just field names.\n                field_names = list(fields)\n            else:\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass  # Don't call set_group_by() to preserve the original GROUP BY\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 1920-1936)": [
      "\ndef set_group_by(self, preserve_existing=False):\n    \"\"\"\n    Expand the GROUP BY clause required by the query.\n\n    This will usually be the set of all non-aggregate fields in the\n    return data. If the database backend supports grouping by the\n    primary key, and the query would be equivalent, the optimization\n    will be made automatically.\n    \n    Args:\n        preserve_existing: If True and group_by is already a tuple, preserve it\n    \"\"\"\n    if preserve_existing and isinstance(self.group_by, tuple):\n        return  # Don't override existing explicit GROUP BY\n        \n    group_by = list(self.select)\n    if self.annotation_select:\n        for alias, annotation in self.annotation_select.items():\n            try:\n                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n            except TypeError:\n                annotation_class = annotation.__class__\n                msg = (\n                    '`alias=None` must be added to the signature of '\n                    '%s.%s.get_group_by_cols().'\n                ) % (annotation_class.__module__, annotation_class.__qualname__)\n                warnings.warn(msg, category=RemovedInDjango40Warning)\n                group_by_cols = annotation.get_group_by_cols()\n            else:\n                group_by_cols = annotation.get_group_by_cols(alias=alias)\n            group_by.extend(group_by_cols)\n    self.group_by = tuple(group_by)\n",
      "\ndef set_group_by(self, preserve_existing=False):\n    \"\"\"\n    Expand the GROUP BY clause required by the query.\n\n    This will usually be the set of all non-aggregate fields in the\n    return data. If the database backend supports grouping by the\n    primary key, and the query would be equivalent, the optimization\n    will be made automatically.\n    \n    Args:\n        preserve_existing: If True and group_by is already a tuple, preserve it\n    \"\"\"\n    if preserve_existing and isinstance(self.group_by, tuple):\n        return  # Don't override existing explicit GROUP BY\n        \n    group_by = list(self.select)\n    if self.annotation_select:\n        for alias, annotation in self.annotation_select.items():\n            try:\n                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n            except TypeError:\n                annotation_class = annotation.__class__\n                msg = (\n                    '`alias=None` must be added to the signature of '\n                    '%s.%s.get_group_by_cols().'\n                ) % (annotation_class.__module__, annotation_class.__qualname__)\n                warnings.warn(msg, category=RemovedInDjango40Warning)\n                group_by_cols = annotation.get_group_by_cols()\n            else:\n                group_by_cols = annotation.get_group_by_cols(alias=alias)\n            group_by.extend(group_by_cols)\n    self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self, preserve_existing=False):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \n        Args:\n            preserve_existing: If True and group_by is already a tuple, preserve it\n        \"\"\"\n        if preserve_existing and isinstance(self.group_by, tuple):\n            return  # Don't override existing explicit GROUP BY\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\ndef set_group_by(self, preserve_existing=False):\n    \"\"\"\n    Expand the GROUP BY clause required by the query.\n\n    This will usually be the set of all non-aggregate fields in the\n    return data. If the database backend supports grouping by the\n    primary key, and the query would be equivalent, the optimization\n    will be made automatically.\n    \n    Args:\n        preserve_existing: If True and group_by is already a tuple, preserve it\n    \"\"\"\n    if preserve_existing and isinstance(self.group_by, tuple):\n        return  # Don't override existing explicit GROUP BY\n        \n    group_by = list(self.select)\n    if self.annotation_select:\n        for alias, annotation in self.annotation_select.items():\n            try:\n                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n            except TypeError:\n                annotation_class = annotation.__class__\n                msg = (\n                    '`alias=None` must be added to the signature of '\n                    '%s.%s.get_group_by_cols().'\n                ) % (annotation_class.__module__, annotation_class.__qualname__)\n                warnings.warn(msg, category=RemovedInDjango40Warning)\n                group_by_cols = annotation.get_group_by_cols()\n            else:\n                group_by_cols = annotation.get_group_by_cols(alias=alias)\n            group_by.extend(group_by_cols)\n    self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self, preserve_existing=False):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \n        Args:\n            preserve_existing: If True and group_by is already a tuple, preserve it\n        \"\"\"\n        if preserve_existing and isinstance(self.group_by, tuple):\n            return  # Don't override existing explicit GROUP BY\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\ndef set_group_by(self, preserve_existing=False):\n    \"\"\"\n    Expand the GROUP BY clause required by the query.\n\n    This will usually be the set of all non-aggregate fields in the\n    return data. If the database backend supports grouping by the\n    primary key, and the query would be equivalent, the optimization\n    will be made automatically.\n    \n    Args:\n        preserve_existing: If True and group_by is already a tuple, preserve it\n    \"\"\"\n    if preserve_existing and isinstance(self.group_by, tuple):\n        return  # Don't override existing explicit GROUP BY\n        \n    group_by = list(self.select)\n    if self.annotation_select:\n        for alias, annotation in self.annotation_select.items():\n            try:\n                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n            except TypeError:\n                annotation_class = annotation.__class__\n                msg = (\n                    '`alias=None` must be added to the signature of '\n                    '%s.%s.get_group_by_cols().'\n                ) % (annotation_class.__module__, annotation_class.__qualname__)\n                warnings.warn(msg, category=RemovedInDjango40Warning)\n                group_by_cols = annotation.get_group_by_cols()\n            else:\n                group_by_cols = annotation.get_group_by_cols(alias=alias)\n            group_by.extend(group_by_cols)\n    self.group_by = tuple(group_by)\n",
      "\ndef set_group_by(self, preserve_existing=False):\n    \"\"\"\n    Expand the GROUP BY clause required by the query.\n\n    This will usually be the set of all non-aggregate fields in the\n    return data. If the database backend supports grouping by the\n    primary key, and the query would be equivalent, the optimization\n    will be made automatically.\n    \n    Args:\n        preserve_existing: If True and group_by is already a tuple, preserve it\n    \"\"\"\n    if preserve_existing and isinstance(self.group_by, tuple):\n        return  # Don't override existing explicit GROUP BY\n        \n    group_by = list(self.select)\n    if self.annotation_select:\n        for alias, annotation in self.annotation_select.items():\n            try:\n                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n            except TypeError:\n                annotation_class = annotation.__class__\n                msg = (\n                    '`alias=None` must be added to the signature of '\n                    '%s.%s.get_group_by_cols().'\n                ) % (annotation_class.__module__, annotation_class.__qualname__)\n                warnings.warn(msg, category=RemovedInDjango40Warning)\n                group_by_cols = annotation.get_group_by_cols()\n            else:\n                group_by_cols = annotation.get_group_by_cols(alias=alias)\n            group_by.extend(group_by_cols)\n    self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self, preserve_existing=False):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \n        Args:\n            preserve_existing: If True and group_by is already a tuple, preserve it\n        \"\"\"\n        if preserve_existing and isinstance(self.group_by, tuple):\n            return  # Don't override existing explicit GROUP BY\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/models/sql/where.py lines 241-245)": [
      "\ndef as_sql(self, compiler, connection):\n    query = self.query_object\n    # Store original group_by before set_values potentially modifies it\n    original_group_by = query.group_by\n    query.set_values(self.targets)\n    # Restore original group_by if it was explicitly set (not True)\n    if isinstance(original_group_by, tuple):\n        query.group_by = original_group_by\n    query_compiler = query.get_compiler(connection=connection)\n    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
      "\ndef as_sql(self, compiler, connection):\n    query = self.query_object\n    query.set_values(self.targets)\n    query_compiler = query.get_compiler(connection=connection)\n    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
      "\ndef as_sql(self, compiler, connection):\n    query = self.query_object\n    query.set_values(self.targets)\n    query_compiler = query.get_compiler(connection=connection)\n    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
      "\ndef as_sql(self, compiler, connection):\n    query = self.query_object\n    query.set_values(self.targets)\n    query_compiler = query.get_compiler(connection=connection)\n    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
      "\ndef as_sql(self, compiler, connection):\n    query = self.query_object\n    query.set_values(self.targets)\n    query_compiler = query.get_compiler(connection=connection)\n    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
      "\n    def as_sql(self, compiler, connection):\n        query = self.query_object\n        query.set_values(self.targets)\n        query_compiler = query.get_compiler(connection=connection)\n        return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
      "\n    def as_sql(self, compiler, connection):\n        query = self.query_object\n        query.set_values(self.targets)\n        query_compiler = query.get_compiler(connection=connection)\n        return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
      "\n    def as_sql(self, compiler, connection):\n        query = self.query_object\n        # Preserve the original GROUP BY clause before calling set_values\n        original_group_by = query.group_by\n        query.set_values(self.targets)\n        # Restore the original GROUP BY if it was explicitly set to prevent overriding\n        if isinstance(original_group_by, tuple) and original_group_by:\n            query.group_by = original_group_by\n        query_compiler = query.get_compiler(connection=connection)\n        return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 522-524)": [
      "\n    def has_results(self, using):\n        q = self.clone()\n        if not q.distinct:\n            if q.group_by is True:\n                q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                q.set_group_by()\n            elif isinstance(q.group_by, tuple):\n                # Preserve existing GROUP BY clause when it's already set to specific fields\n                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n                pass\n            q.clear_select_clause()\n        q.clear_ordering(True)\n        q.set_limits(high=1)\n        compiler = q.get_compiler(using=using)\n        return compiler.has_results()\n",
      "\n    def has_results(self, using):\n        q = self.clone()\n        if not q.distinct:\n            if q.group_by is True:\n                q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                q.set_group_by()\n            elif isinstance(q.group_by, tuple):\n                # Preserve existing GROUP BY clause when it's already set to specific fields\n                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n                pass  # Don't call set_group_by() to preserve the original GROUP BY\n            q.clear_select_clause()\n        q.clear_ordering(True)\n        q.set_limits(high=1)\n        compiler = q.get_compiler(using=using)\n        return compiler.has_results()\n",
      "\n    def has_results(self, using):\n        q = self.clone()\n        if not q.distinct:\n            if q.group_by is True:\n                q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                q.set_group_by()\n            elif isinstance(q.group_by, tuple):\n                # Preserve existing GROUP BY clause when it's already set to specific fields\n                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n                pass\n        q.clear_select_clause()\n        q.clear_ordering(True)\n        q.set_limits(high=1)\n        compiler = q.get_compiler(using=using)\n        return compiler.has_results()\n",
      "\n    def has_results(self, using):\n        q = self.clone()\n        if not q.distinct:\n            if q.group_by is True:\n                q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                q.set_group_by()\n            elif isinstance(q.group_by, tuple):\n                # Preserve existing GROUP BY clause when it's already set to specific fields\n                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n                pass\n            q.clear_select_clause()\n        q.clear_ordering(True)\n        q.set_limits(high=1)\n        compiler = q.get_compiler(using=using)\n        return compiler.has_results()\n",
      "\n    def has_results(self, using):\n        q = self.clone()\n        if not q.distinct:\n            if q.group_by is True:\n                q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                q.set_group_by()\n            elif isinstance(q.group_by, tuple):\n                # Preserve existing GROUP BY clause when it's already set to specific fields\n                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n                pass\n            q.clear_select_clause()\n        q.clear_ordering(True)\n        q.set_limits(high=1)\n        compiler = q.get_compiler(using=using)\n        return compiler.has_results()\n",
      "\n    def has_results(self, using):\n        q = self.clone()\n        if not q.distinct:\n            if q.group_by is True:\n                q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                q.set_group_by()\n            elif isinstance(q.group_by, tuple):\n                # Preserve existing GROUP BY clause when it's already set to specific fields\n                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n                pass\n            q.clear_select_clause()\n        q.clear_ordering(True)\n        q.set_limits(high=1)\n        compiler = q.get_compiler(using=using)\n        return compiler.has_results()\n",
      "\n    def has_results(self, using):\n        q = self.clone()\n        if not q.distinct:\n            if q.group_by is True:\n                q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                q.set_group_by()\n            elif isinstance(q.group_by, tuple):\n                # Preserve existing GROUP BY clause when it's already set to specific fields\n                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n                pass\n            q.clear_select_clause()\n        q.clear_ordering(True)\n        q.set_limits(high=1)\n        compiler = q.get_compiler(using=using)\n        return compiler.has_results()\n",
      "\n    def has_results(self, using):\n        q = self.clone()\n        if not q.distinct:\n            if q.group_by is True:\n                q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                q.set_group_by()\n            elif isinstance(q.group_by, tuple):\n                # Preserve existing GROUP BY clause when it's already set to specific fields\n                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n                pass\n            q.clear_select_clause()\n        q.clear_ordering(True)\n        q.set_limits(high=1)\n        compiler = q.get_compiler(using=using)\n        return compiler.has_results()\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 2080-2114)": [
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n\n        if fields:\n            field_names = []\n            extra_names = []\n            annotation_names = []\n            if not self.extra and not self.annotations:\n                # Shortcut - if there are no extra or annotations, then\n                # the values() clause must be just field names.\n                field_names = list(fields)\n            else:\n                self.default_cols = False\n                for f in fields:\n                    if f in self.extra_select:\n                        extra_names.append(f)\n                    elif f in self.annotation_select:\n                        annotation_names.append(f)\n                    else:\n                        field_names.append(f)\n            self.set_extra_mask(extra_names)\n            self.set_annotation_mask(annotation_names)\n        else:\n            field_names = [f.attname for f in self.model._meta.concrete_fields]\n\n        self.values_select = tuple(field_names)\n        self.add_fields(field_names, True)\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n\n        if fields:\n            field_names = []\n            extra_names = []\n            annotation_names = []\n            if not self.extra and not self.annotations:\n                # Shortcut - if there are no extra or annotations, then\n                # the values() clause must be just field names.\n                field_names = list(fields)\n            else:\n                self.default_cols = False\n                for f in fields:\n                    if f in self.extra_select:\n                        extra_names.append(f)\n                    elif f in self.annotation_select:\n                        annotation_names.append(f)\n                    else:\n                        field_names.append(f)\n            self.set_extra_mask(extra_names)\n            self.set_annotation_mask(annotation_names)\n        else:\n            field_names = [f.attname for f in self.model._meta.concrete_fields]\n\n        self.values_select = tuple(field_names)\n        self.add_fields(field_names, True)\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n\n        if fields:\n            field_names = []\n            extra_names = []\n            annotation_names = []\n            if not self.extra and not self.annotations:\n                # Shortcut - if there are no extra or annotations, then\n                # the values() clause must be just field names.\n                field_names = list(fields)\n            else:\n                self.default_cols = False\n                for f in fields:\n                    if f in self.extra_select:\n                        extra_names.append(f)\n                    elif f in self.annotation_select:\n                        annotation_names.append(f)\n                    else:\n                        field_names.append(f)\n            self.set_extra_mask(extra_names)\n            self.set_annotation_mask(annotation_names)\n        else:\n            field_names = [f.attname for f in self.model._meta.concrete_fields]\n\n        self.values_select = tuple(field_names)\n        self.add_fields(field_names, True)\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n\n        if fields:\n            field_names = []\n            extra_names = []\n            annotation_names = []\n            if not self.extra and not self.annotations:\n                # Shortcut - if there are no extra or annotations, then\n                # the values() clause must be just field names.\n                field_names = list(fields)\n            else:\n                self.default_cols = False\n                for f in fields:\n                    if f in self.extra_select:\n                        extra_names.append(f)\n                    elif f in self.annotation_select:\n                        annotation_names.append(f)\n                    else:\n                        field_names.append(f)\n            self.set_extra_mask(extra_names)\n            self.set_annotation_mask(annotation_names)\n        else:\n            field_names = [f.attname for f in self.model._meta.concrete_fields]\n\n        self.values_select = tuple(field_names)\n        self.add_fields(field_names, True)\n",
      "\ndef set_values(self, fields):\n    self.select_related = False\n    self.clear_deferred_loading()\n    self.clear_select_fields()\n\n    if self.group_by is True:\n        self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n        self.set_group_by()\n        self.clear_select_fields()\n    elif isinstance(self.group_by, tuple):\n        # Preserve existing GROUP BY clause when it's already set to specific fields\n        # This prevents overriding explicit GROUP BY clauses in subquery contexts\n        pass\n\n    if fields:\n        field_names = []\n        extra_names = []\n        annotation_names = []\n        if not self.extra and not self.annotations:\n            # Shortcut - if there are no extra or annotations, then\n            # the values() clause must be just field names.\n            field_names = list(fields)\n        else:\n            self.default_cols = False\n            for f in fields:\n                if f in self.extra_select:\n                    extra_names.append(f)\n                elif f in self.annotation_select:\n                    annotation_names.append(f)\n                else:\n                    field_names.append(f)\n        self.set_extra_mask(extra_names)\n        self.set_annotation_mask(annotation_names)\n    else:\n        field_names = [f.attname for f in self.model._meta.concrete_fields]\n\n    self.values_select = tuple(field_names)\n    self.add_fields(field_names, True)\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n\n        if fields:\n            field_names = []\n            extra_names = []\n            annotation_names = []\n            if not self.extra and not self.annotations:\n                # Shortcut - if there are no extra or annotations, then\n                # the values() clause must be just field names.\n                field_names = list(fields)\n            else:\n                self.default_cols = False\n                for f in fields:\n                    if f in self.extra_select:\n                        extra_names.append(f)\n                    elif f in self.annotation_select:\n                        annotation_names.append(f)\n                    else:\n                        field_names.append(f)\n            self.set_extra_mask(extra_names)\n            self.set_annotation_mask(annotation_names)\n        else:\n            field_names = [f.attname for f in self.model._meta.concrete_fields]\n\n        self.values_select = tuple(field_names)\n        self.add_fields(field_names, True)\n",
      "\n    def set_values(self, fields):\n        self.select_related = False\n        self.clear_deferred_loading()\n        self.clear_select_fields()\n\n        if self.group_by is True:\n            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n            self.set_group_by()\n            self.clear_select_fields()\n        elif isinstance(self.group_by, tuple):\n            # Preserve existing GROUP BY clause when it's already set to specific fields\n            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n            pass\n\n        if fields:\n            field_names = []\n            extra_names = []\n            annotation_names = []\n            if not self.extra and not self.annotations:\n                # Shortcut - if there are no extra or annotations, then\n                # the values() clause must be just field names.\n                field_names = list(fields)\n            else:\n                self.default_cols = False\n                for f in fields:\n                    if f in self.extra_select:\n                        extra_names.append(f)\n                    elif f in self.annotation_select:\n                        annotation_names.append(f)\n                    else:\n                        field_names.append(f)\n            self.set_extra_mask(extra_names)\n            self.set_annotation_mask(annotation_names)\n        else:\n            field_names = [f.attname for f in self.model._meta.concrete_fields]\n\n        self.values_select = tuple(field_names)\n        self.add_fields(field_names, True)\n",
      "\ndef set_values(self, fields):\n    self.select_related = False\n    self.clear_deferred_loading()\n    self.clear_select_fields()\n\n    if self.group_by is True:\n        self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n        self.set_group_by()\n        self.clear_select_fields()\n    elif isinstance(self.group_by, tuple):\n        # Preserve existing GROUP BY clause when it's already set to specific fields\n        # This prevents overriding explicit GROUP BY clauses in subquery contexts\n        pass\n\n    if fields:\n        field_names = []\n        extra_names = []\n        annotation_names = []\n        if not self.extra and not self.annotations:\n            # Shortcut - if there are no extra or annotations, then\n            # the values() clause must be just field names.\n            field_names = list(fields)\n        else:\n            self.default_cols = False\n            for f in fields:\n                if f in self.extra_select:\n                    extra_names.append(f)\n                elif f in self.annotation_select:\n                    annotation_names.append(f)\n                else:\n                    field_names.append(f)\n        self.set_extra_mask(extra_names)\n        self.set_annotation_mask(annotation_names)\n    else:\n        field_names = [f.attname for f in self.model._meta.concrete_fields]\n\n    self.values_select = tuple(field_names)\n    self.add_fields(field_names, True)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..e360bc8e63 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -519,9 +519,10 @@ class Query(BaseExpression):\n     def has_results(self, using):\n         q = self.clone()\n         if not q.distinct:\n+\n             if q.group_by is True:\n                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n-                q.set_group_by()\n+                q.set_group_by(preserve_existing=True)\n             q.clear_select_clause()\n         q.clear_ordering(True)\n         q.set_limits(high=1)\n@@ -1917,6 +1918,22 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n+\n+    def set_group_by(self, preserve_existing=False):\n+        \"\"\"\n+        Expand the GROUP BY clause required by the query.\n+\n+        This will usually be the set of all non-aggregate fields in the\n+        return data. If the database backend supports grouping by the\n+        primary key, and the query would be equivalent, the optimization\n+        will be made automatically.\n+        \n+        Args:\n+            preserve_existing: If True and group_by is already a tuple, preserve it\n+        \"\"\"\n+        if preserve_existing and isinstance(self.group_by, tuple):\n+            return  # Don't override existing explicit GROUP BY\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -2077,7 +2094,14 @@ class Query(BaseExpression):\n             self.extra_select_mask = set(names)\n         self._extra_select_cache = None\n \n+\n     def set_values(self, fields):\n+        \"\"\"\n+        Set the fields to be selected by this query.\n+        \n+        Note: When group_by is already a tuple (explicit GROUP BY clause),\n+        it will be preserved to maintain subquery integrity.\n+        \"\"\"\n         self.select_related = False\n         self.clear_deferred_loading()\n         self.clear_select_fields()\n@@ -2086,6 +2110,10 @@ class Query(BaseExpression):\n             self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n             self.set_group_by()\n             self.clear_select_fields()\n+        elif isinstance(self.group_by, tuple):\n+            # Preserve existing GROUP BY clause when it's already set to specific fields\n+            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+            pass  # Don't call set_group_by() to preserve the original GROUP BY\n \n         if fields:\n             field_names = []\n@@ -2109,6 +2137,10 @@ class Query(BaseExpression):\n         else:\n             field_names = [f.attname for f in self.model._meta.concrete_fields]\n \n+        self.values_select = tuple(field_names)\n+        self.add_fields(field_names, True)\n+            field_names = [f.attname for f in self.model._meta.concrete_fields]\n+\n         self.values_select = tuple(field_names)\n         self.add_fields(field_names, True)\n \ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex bf0828dc8b..4a68522a46 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -238,6 +238,7 @@ class SubqueryConstraint:\n         self.targets = targets\n         self.query_object = query_object\n \n+\n     def as_sql(self, compiler, connection):\n         query = self.query_object\n         query.set_values(self.targets)\n",
    "variant_0": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..26871b330a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -516,12 +516,25 @@ class Query(BaseExpression):\n     def has_filters(self):\n         return self.where\n \n+    def has_results(self, using):\n+        q = self.clone()\n+        if not q.distinct:\n+\n     def has_results(self, using):\n         q = self.clone()\n         if not q.distinct:\n             if q.group_by is True:\n                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                 q.set_group_by()\n+            elif isinstance(q.group_by, tuple):\n+                # Preserve existing GROUP BY clause when it's already set to specific fields\n+                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+                pass\n+            q.clear_select_clause()\n+        q.clear_ordering(True)\n+        q.set_limits(high=1)\n+        compiler = q.get_compiler(using=using)\n+        return compiler.has_results()\n             q.clear_select_clause()\n         q.clear_ordering(True)\n         q.set_limits(high=1)\n@@ -1917,23 +1930,39 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n-        group_by = list(self.select)\n-        if self.annotation_select:\n-            for alias, annotation in self.annotation_select.items():\n-                try:\n-                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n-                except TypeError:\n-                    annotation_class = annotation.__class__\n-                    msg = (\n-                        '`alias=None` must be added to the signature of '\n-                        '%s.%s.get_group_by_cols().'\n-                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n-                    warnings.warn(msg, category=RemovedInDjango40Warning)\n-                    group_by_cols = annotation.get_group_by_cols()\n-                else:\n-                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n-                group_by.extend(group_by_cols)\n-        self.group_by = tuple(group_by)\n+\n+def set_group_by(self, preserve_existing=False):\n+    \"\"\"\n+    Expand the GROUP BY clause required by the query.\n+\n+    This will usually be the set of all non-aggregate fields in the\n+    return data. If the database backend supports grouping by the\n+    primary key, and the query would be equivalent, the optimization\n+    will be made automatically.\n+    \n+    Args:\n+        preserve_existing: If True and group_by is already a tuple, preserve it\n+    \"\"\"\n+    if preserve_existing and isinstance(self.group_by, tuple):\n+        return  # Don't override existing explicit GROUP BY\n+        \n+    group_by = list(self.select)\n+    if self.annotation_select:\n+        for alias, annotation in self.annotation_select.items():\n+            try:\n+                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+            except TypeError:\n+                annotation_class = annotation.__class__\n+                msg = (\n+                    '`alias=None` must be added to the signature of '\n+                    '%s.%s.get_group_by_cols().'\n+                ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                warnings.warn(msg, category=RemovedInDjango40Warning)\n+                group_by_cols = annotation.get_group_by_cols()\n+            else:\n+                group_by_cols = annotation.get_group_by_cols(alias=alias)\n+            group_by.extend(group_by_cols)\n+    self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n         \"\"\"\n@@ -2077,6 +2106,7 @@ class Query(BaseExpression):\n             self.extra_select_mask = set(names)\n         self._extra_select_cache = None\n \n+\n     def set_values(self, fields):\n         self.select_related = False\n         self.clear_deferred_loading()\n@@ -2086,6 +2116,10 @@ class Query(BaseExpression):\n             self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n             self.set_group_by()\n             self.clear_select_fields()\n+        elif isinstance(self.group_by, tuple):\n+            # Preserve existing GROUP BY clause when it's already set to specific fields\n+            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+            pass\n \n         if fields:\n             field_names = []\n@@ -2109,6 +2143,15 @@ class Query(BaseExpression):\n         else:\n             field_names = [f.attname for f in self.model._meta.concrete_fields]\n \n+        self.values_select = tuple(field_names)\n+        self.add_fields(field_names, True)\n+                    else:\n+                        field_names.append(f)\n+            self.set_extra_mask(extra_names)\n+            self.set_annotation_mask(annotation_names)\n+        else:\n+            field_names = [f.attname for f in self.model._meta.concrete_fields]\n+\n         self.values_select = tuple(field_names)\n         self.add_fields(field_names, True)\n \ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex bf0828dc8b..7793276d38 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -238,8 +238,9 @@ class SubqueryConstraint:\n         self.targets = targets\n         self.query_object = query_object\n \n-    def as_sql(self, compiler, connection):\n-        query = self.query_object\n-        query.set_values(self.targets)\n-        query_compiler = query.get_compiler(connection=connection)\n-        return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n+\n+def as_sql(self, compiler, connection):\n+    query = self.query_object\n+    query.set_values(self.targets)\n+    query_compiler = query.get_compiler(connection=connection)\n+    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
    "variant_1": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..26871b330a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -516,12 +516,25 @@ class Query(BaseExpression):\n     def has_filters(self):\n         return self.where\n \n+    def has_results(self, using):\n+        q = self.clone()\n+        if not q.distinct:\n+\n     def has_results(self, using):\n         q = self.clone()\n         if not q.distinct:\n             if q.group_by is True:\n                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                 q.set_group_by()\n+            elif isinstance(q.group_by, tuple):\n+                # Preserve existing GROUP BY clause when it's already set to specific fields\n+                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+                pass\n+            q.clear_select_clause()\n+        q.clear_ordering(True)\n+        q.set_limits(high=1)\n+        compiler = q.get_compiler(using=using)\n+        return compiler.has_results()\n             q.clear_select_clause()\n         q.clear_ordering(True)\n         q.set_limits(high=1)\n@@ -1917,23 +1930,39 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n-        group_by = list(self.select)\n-        if self.annotation_select:\n-            for alias, annotation in self.annotation_select.items():\n-                try:\n-                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n-                except TypeError:\n-                    annotation_class = annotation.__class__\n-                    msg = (\n-                        '`alias=None` must be added to the signature of '\n-                        '%s.%s.get_group_by_cols().'\n-                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n-                    warnings.warn(msg, category=RemovedInDjango40Warning)\n-                    group_by_cols = annotation.get_group_by_cols()\n-                else:\n-                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n-                group_by.extend(group_by_cols)\n-        self.group_by = tuple(group_by)\n+\n+def set_group_by(self, preserve_existing=False):\n+    \"\"\"\n+    Expand the GROUP BY clause required by the query.\n+\n+    This will usually be the set of all non-aggregate fields in the\n+    return data. If the database backend supports grouping by the\n+    primary key, and the query would be equivalent, the optimization\n+    will be made automatically.\n+    \n+    Args:\n+        preserve_existing: If True and group_by is already a tuple, preserve it\n+    \"\"\"\n+    if preserve_existing and isinstance(self.group_by, tuple):\n+        return  # Don't override existing explicit GROUP BY\n+        \n+    group_by = list(self.select)\n+    if self.annotation_select:\n+        for alias, annotation in self.annotation_select.items():\n+            try:\n+                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+            except TypeError:\n+                annotation_class = annotation.__class__\n+                msg = (\n+                    '`alias=None` must be added to the signature of '\n+                    '%s.%s.get_group_by_cols().'\n+                ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                warnings.warn(msg, category=RemovedInDjango40Warning)\n+                group_by_cols = annotation.get_group_by_cols()\n+            else:\n+                group_by_cols = annotation.get_group_by_cols(alias=alias)\n+            group_by.extend(group_by_cols)\n+    self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n         \"\"\"\n@@ -2077,6 +2106,7 @@ class Query(BaseExpression):\n             self.extra_select_mask = set(names)\n         self._extra_select_cache = None\n \n+\n     def set_values(self, fields):\n         self.select_related = False\n         self.clear_deferred_loading()\n@@ -2086,6 +2116,10 @@ class Query(BaseExpression):\n             self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n             self.set_group_by()\n             self.clear_select_fields()\n+        elif isinstance(self.group_by, tuple):\n+            # Preserve existing GROUP BY clause when it's already set to specific fields\n+            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+            pass\n \n         if fields:\n             field_names = []\n@@ -2109,6 +2143,15 @@ class Query(BaseExpression):\n         else:\n             field_names = [f.attname for f in self.model._meta.concrete_fields]\n \n+        self.values_select = tuple(field_names)\n+        self.add_fields(field_names, True)\n+                    else:\n+                        field_names.append(f)\n+            self.set_extra_mask(extra_names)\n+            self.set_annotation_mask(annotation_names)\n+        else:\n+            field_names = [f.attname for f in self.model._meta.concrete_fields]\n+\n         self.values_select = tuple(field_names)\n         self.add_fields(field_names, True)\n \ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex bf0828dc8b..eef1bafd7e 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -238,8 +238,14 @@ class SubqueryConstraint:\n         self.targets = targets\n         self.query_object = query_object\n \n-    def as_sql(self, compiler, connection):\n-        query = self.query_object\n-        query.set_values(self.targets)\n-        query_compiler = query.get_compiler(connection=connection)\n-        return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n+\n+def as_sql(self, compiler, connection):\n+    query = self.query_object\n+    # Store original group_by before set_values potentially modifies it\n+    original_group_by = query.group_by\n+    query.set_values(self.targets)\n+    # Restore original group_by if it was explicitly set (not True)\n+    if isinstance(original_group_by, tuple):\n+        query.group_by = original_group_by\n+    query_compiler = query.get_compiler(connection=connection)\n+    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
    "variant_2": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..33ccc45600 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -516,12 +516,25 @@ class Query(BaseExpression):\n     def has_filters(self):\n         return self.where\n \n+    def has_results(self, using):\n+        q = self.clone()\n+        if not q.distinct:\n+\n     def has_results(self, using):\n         q = self.clone()\n         if not q.distinct:\n             if q.group_by is True:\n                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                 q.set_group_by()\n+            elif isinstance(q.group_by, tuple):\n+                # Preserve existing GROUP BY clause when it's already set to specific fields\n+                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+                pass  # Don't call set_group_by() to preserve the original GROUP BY\n+            q.clear_select_clause()\n+        q.clear_ordering(True)\n+        q.set_limits(high=1)\n+        compiler = q.get_compiler(using=using)\n+        return compiler.has_results()\n             q.clear_select_clause()\n         q.clear_ordering(True)\n         q.set_limits(high=1)\n@@ -1917,23 +1930,39 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n-        group_by = list(self.select)\n-        if self.annotation_select:\n-            for alias, annotation in self.annotation_select.items():\n-                try:\n-                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n-                except TypeError:\n-                    annotation_class = annotation.__class__\n-                    msg = (\n-                        '`alias=None` must be added to the signature of '\n-                        '%s.%s.get_group_by_cols().'\n-                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n-                    warnings.warn(msg, category=RemovedInDjango40Warning)\n-                    group_by_cols = annotation.get_group_by_cols()\n-                else:\n-                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n-                group_by.extend(group_by_cols)\n-        self.group_by = tuple(group_by)\n+\n+def set_group_by(self, preserve_existing=False):\n+    \"\"\"\n+    Expand the GROUP BY clause required by the query.\n+\n+    This will usually be the set of all non-aggregate fields in the\n+    return data. If the database backend supports grouping by the\n+    primary key, and the query would be equivalent, the optimization\n+    will be made automatically.\n+    \n+    Args:\n+        preserve_existing: If True and group_by is already a tuple, preserve it\n+    \"\"\"\n+    if preserve_existing and isinstance(self.group_by, tuple):\n+        return  # Don't override existing explicit GROUP BY\n+        \n+    group_by = list(self.select)\n+    if self.annotation_select:\n+        for alias, annotation in self.annotation_select.items():\n+            try:\n+                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+            except TypeError:\n+                annotation_class = annotation.__class__\n+                msg = (\n+                    '`alias=None` must be added to the signature of '\n+                    '%s.%s.get_group_by_cols().'\n+                ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                warnings.warn(msg, category=RemovedInDjango40Warning)\n+                group_by_cols = annotation.get_group_by_cols()\n+            else:\n+                group_by_cols = annotation.get_group_by_cols(alias=alias)\n+            group_by.extend(group_by_cols)\n+    self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n         \"\"\"\n@@ -2077,6 +2106,7 @@ class Query(BaseExpression):\n             self.extra_select_mask = set(names)\n         self._extra_select_cache = None\n \n+\n     def set_values(self, fields):\n         self.select_related = False\n         self.clear_deferred_loading()\n@@ -2086,6 +2116,10 @@ class Query(BaseExpression):\n             self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n             self.set_group_by()\n             self.clear_select_fields()\n+        elif isinstance(self.group_by, tuple):\n+            # Preserve existing GROUP BY clause when it's already set to specific fields\n+            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+            pass\n \n         if fields:\n             field_names = []\n@@ -2109,6 +2143,15 @@ class Query(BaseExpression):\n         else:\n             field_names = [f.attname for f in self.model._meta.concrete_fields]\n \n+        self.values_select = tuple(field_names)\n+        self.add_fields(field_names, True)\n+                    else:\n+                        field_names.append(f)\n+            self.set_extra_mask(extra_names)\n+            self.set_annotation_mask(annotation_names)\n+        else:\n+            field_names = [f.attname for f in self.model._meta.concrete_fields]\n+\n         self.values_select = tuple(field_names)\n         self.add_fields(field_names, True)\n \ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex bf0828dc8b..7793276d38 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -238,8 +238,9 @@ class SubqueryConstraint:\n         self.targets = targets\n         self.query_object = query_object\n \n-    def as_sql(self, compiler, connection):\n-        query = self.query_object\n-        query.set_values(self.targets)\n-        query_compiler = query.get_compiler(connection=connection)\n-        return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n+\n+def as_sql(self, compiler, connection):\n+    query = self.query_object\n+    query.set_values(self.targets)\n+    query_compiler = query.get_compiler(connection=connection)\n+    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
    "variant_3": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..2b81f55b2a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -516,12 +516,25 @@ class Query(BaseExpression):\n     def has_filters(self):\n         return self.where\n \n+    def has_results(self, using):\n+        q = self.clone()\n+        if not q.distinct:\n+\n     def has_results(self, using):\n         q = self.clone()\n         if not q.distinct:\n             if q.group_by is True:\n                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                 q.set_group_by()\n+            elif isinstance(q.group_by, tuple):\n+                # Preserve existing GROUP BY clause when it's already set to specific fields\n+                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+                pass\n+        q.clear_select_clause()\n+        q.clear_ordering(True)\n+        q.set_limits(high=1)\n+        compiler = q.get_compiler(using=using)\n+        return compiler.has_results()\n             q.clear_select_clause()\n         q.clear_ordering(True)\n         q.set_limits(high=1)\n@@ -1917,6 +1930,22 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n+\n+    def set_group_by(self, preserve_existing=False):\n+        \"\"\"\n+        Expand the GROUP BY clause required by the query.\n+\n+        This will usually be the set of all non-aggregate fields in the\n+        return data. If the database backend supports grouping by the\n+        primary key, and the query would be equivalent, the optimization\n+        will be made automatically.\n+        \n+        Args:\n+            preserve_existing: If True and group_by is already a tuple, preserve it\n+        \"\"\"\n+        if preserve_existing and isinstance(self.group_by, tuple):\n+            return  # Don't override existing explicit GROUP BY\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -2077,6 +2106,7 @@ class Query(BaseExpression):\n             self.extra_select_mask = set(names)\n         self._extra_select_cache = None\n \n+\n     def set_values(self, fields):\n         self.select_related = False\n         self.clear_deferred_loading()\n@@ -2086,6 +2116,10 @@ class Query(BaseExpression):\n             self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n             self.set_group_by()\n             self.clear_select_fields()\n+        elif isinstance(self.group_by, tuple):\n+            # Preserve existing GROUP BY clause when it's already set to specific fields\n+            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+            pass\n \n         if fields:\n             field_names = []\n@@ -2109,6 +2143,15 @@ class Query(BaseExpression):\n         else:\n             field_names = [f.attname for f in self.model._meta.concrete_fields]\n \n+        self.values_select = tuple(field_names)\n+        self.add_fields(field_names, True)\n+                    else:\n+                        field_names.append(f)\n+            self.set_extra_mask(extra_names)\n+            self.set_annotation_mask(annotation_names)\n+        else:\n+            field_names = [f.attname for f in self.model._meta.concrete_fields]\n+\n         self.values_select = tuple(field_names)\n         self.add_fields(field_names, True)\n \ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex bf0828dc8b..7793276d38 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -238,8 +238,9 @@ class SubqueryConstraint:\n         self.targets = targets\n         self.query_object = query_object\n \n-    def as_sql(self, compiler, connection):\n-        query = self.query_object\n-        query.set_values(self.targets)\n-        query_compiler = query.get_compiler(connection=connection)\n-        return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n+\n+def as_sql(self, compiler, connection):\n+    query = self.query_object\n+    query.set_values(self.targets)\n+    query_compiler = query.get_compiler(connection=connection)\n+    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
    "variant_4": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..26871b330a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -516,12 +516,25 @@ class Query(BaseExpression):\n     def has_filters(self):\n         return self.where\n \n+    def has_results(self, using):\n+        q = self.clone()\n+        if not q.distinct:\n+\n     def has_results(self, using):\n         q = self.clone()\n         if not q.distinct:\n             if q.group_by is True:\n                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                 q.set_group_by()\n+            elif isinstance(q.group_by, tuple):\n+                # Preserve existing GROUP BY clause when it's already set to specific fields\n+                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+                pass\n+            q.clear_select_clause()\n+        q.clear_ordering(True)\n+        q.set_limits(high=1)\n+        compiler = q.get_compiler(using=using)\n+        return compiler.has_results()\n             q.clear_select_clause()\n         q.clear_ordering(True)\n         q.set_limits(high=1)\n@@ -1917,23 +1930,39 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n-        group_by = list(self.select)\n-        if self.annotation_select:\n-            for alias, annotation in self.annotation_select.items():\n-                try:\n-                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n-                except TypeError:\n-                    annotation_class = annotation.__class__\n-                    msg = (\n-                        '`alias=None` must be added to the signature of '\n-                        '%s.%s.get_group_by_cols().'\n-                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n-                    warnings.warn(msg, category=RemovedInDjango40Warning)\n-                    group_by_cols = annotation.get_group_by_cols()\n-                else:\n-                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n-                group_by.extend(group_by_cols)\n-        self.group_by = tuple(group_by)\n+\n+def set_group_by(self, preserve_existing=False):\n+    \"\"\"\n+    Expand the GROUP BY clause required by the query.\n+\n+    This will usually be the set of all non-aggregate fields in the\n+    return data. If the database backend supports grouping by the\n+    primary key, and the query would be equivalent, the optimization\n+    will be made automatically.\n+    \n+    Args:\n+        preserve_existing: If True and group_by is already a tuple, preserve it\n+    \"\"\"\n+    if preserve_existing and isinstance(self.group_by, tuple):\n+        return  # Don't override existing explicit GROUP BY\n+        \n+    group_by = list(self.select)\n+    if self.annotation_select:\n+        for alias, annotation in self.annotation_select.items():\n+            try:\n+                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+            except TypeError:\n+                annotation_class = annotation.__class__\n+                msg = (\n+                    '`alias=None` must be added to the signature of '\n+                    '%s.%s.get_group_by_cols().'\n+                ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                warnings.warn(msg, category=RemovedInDjango40Warning)\n+                group_by_cols = annotation.get_group_by_cols()\n+            else:\n+                group_by_cols = annotation.get_group_by_cols(alias=alias)\n+            group_by.extend(group_by_cols)\n+    self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n         \"\"\"\n@@ -2077,6 +2106,7 @@ class Query(BaseExpression):\n             self.extra_select_mask = set(names)\n         self._extra_select_cache = None\n \n+\n     def set_values(self, fields):\n         self.select_related = False\n         self.clear_deferred_loading()\n@@ -2086,6 +2116,10 @@ class Query(BaseExpression):\n             self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n             self.set_group_by()\n             self.clear_select_fields()\n+        elif isinstance(self.group_by, tuple):\n+            # Preserve existing GROUP BY clause when it's already set to specific fields\n+            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+            pass\n \n         if fields:\n             field_names = []\n@@ -2109,6 +2143,15 @@ class Query(BaseExpression):\n         else:\n             field_names = [f.attname for f in self.model._meta.concrete_fields]\n \n+        self.values_select = tuple(field_names)\n+        self.add_fields(field_names, True)\n+                    else:\n+                        field_names.append(f)\n+            self.set_extra_mask(extra_names)\n+            self.set_annotation_mask(annotation_names)\n+        else:\n+            field_names = [f.attname for f in self.model._meta.concrete_fields]\n+\n         self.values_select = tuple(field_names)\n         self.add_fields(field_names, True)\n \ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex bf0828dc8b..7793276d38 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -238,8 +238,9 @@ class SubqueryConstraint:\n         self.targets = targets\n         self.query_object = query_object\n \n-    def as_sql(self, compiler, connection):\n-        query = self.query_object\n-        query.set_values(self.targets)\n-        query_compiler = query.get_compiler(connection=connection)\n-        return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n+\n+def as_sql(self, compiler, connection):\n+    query = self.query_object\n+    query.set_values(self.targets)\n+    query_compiler = query.get_compiler(connection=connection)\n+    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
    "variant_5": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..0e2cc880a5 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -516,12 +516,25 @@ class Query(BaseExpression):\n     def has_filters(self):\n         return self.where\n \n+    def has_results(self, using):\n+        q = self.clone()\n+        if not q.distinct:\n+\n     def has_results(self, using):\n         q = self.clone()\n         if not q.distinct:\n             if q.group_by is True:\n                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                 q.set_group_by()\n+            elif isinstance(q.group_by, tuple):\n+                # Preserve existing GROUP BY clause when it's already set to specific fields\n+                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+                pass\n+            q.clear_select_clause()\n+        q.clear_ordering(True)\n+        q.set_limits(high=1)\n+        compiler = q.get_compiler(using=using)\n+        return compiler.has_results()\n             q.clear_select_clause()\n         q.clear_ordering(True)\n         q.set_limits(high=1)\n@@ -1917,6 +1930,22 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n+\n+    def set_group_by(self, preserve_existing=False):\n+        \"\"\"\n+        Expand the GROUP BY clause required by the query.\n+\n+        This will usually be the set of all non-aggregate fields in the\n+        return data. If the database backend supports grouping by the\n+        primary key, and the query would be equivalent, the optimization\n+        will be made automatically.\n+        \n+        Args:\n+            preserve_existing: If True and group_by is already a tuple, preserve it\n+        \"\"\"\n+        if preserve_existing and isinstance(self.group_by, tuple):\n+            return  # Don't override existing explicit GROUP BY\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -2077,21 +2106,45 @@ class Query(BaseExpression):\n             self.extra_select_mask = set(names)\n         self._extra_select_cache = None\n \n-    def set_values(self, fields):\n-        self.select_related = False\n-        self.clear_deferred_loading()\n-        self.clear_select_fields()\n \n-        if self.group_by is True:\n-            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n-            self.set_group_by()\n-            self.clear_select_fields()\n+def set_values(self, fields):\n+    self.select_related = False\n+    self.clear_deferred_loading()\n+    self.clear_select_fields()\n+\n+    if self.group_by is True:\n+        self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n+        self.set_group_by()\n+        self.clear_select_fields()\n+    elif isinstance(self.group_by, tuple):\n+        # Preserve existing GROUP BY clause when it's already set to specific fields\n+        # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+        pass\n+\n+    if fields:\n+        field_names = []\n+        extra_names = []\n+        annotation_names = []\n+        if not self.extra and not self.annotations:\n+            # Shortcut - if there are no extra or annotations, then\n+            # the values() clause must be just field names.\n+            field_names = list(fields)\n+        else:\n+            self.default_cols = False\n+            for f in fields:\n+                if f in self.extra_select:\n+                    extra_names.append(f)\n+                elif f in self.annotation_select:\n+                    annotation_names.append(f)\n+                else:\n+                    field_names.append(f)\n+        self.set_extra_mask(extra_names)\n+        self.set_annotation_mask(annotation_names)\n+    else:\n+        field_names = [f.attname for f in self.model._meta.concrete_fields]\n \n-        if fields:\n-            field_names = []\n-            extra_names = []\n-            annotation_names = []\n-            if not self.extra and not self.annotations:\n+    self.values_select = tuple(field_names)\n+    self.add_fields(field_names, True)\n                 # Shortcut - if there are no extra or annotations, then\n                 # the values() clause must be just field names.\n                 field_names = list(fields)\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex bf0828dc8b..7793276d38 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -238,8 +238,9 @@ class SubqueryConstraint:\n         self.targets = targets\n         self.query_object = query_object\n \n-    def as_sql(self, compiler, connection):\n-        query = self.query_object\n-        query.set_values(self.targets)\n-        query_compiler = query.get_compiler(connection=connection)\n-        return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n+\n+def as_sql(self, compiler, connection):\n+    query = self.query_object\n+    query.set_values(self.targets)\n+    query_compiler = query.get_compiler(connection=connection)\n+    return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n",
    "variant_6": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..26871b330a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -516,12 +516,25 @@ class Query(BaseExpression):\n     def has_filters(self):\n         return self.where\n \n+    def has_results(self, using):\n+        q = self.clone()\n+        if not q.distinct:\n+\n     def has_results(self, using):\n         q = self.clone()\n         if not q.distinct:\n             if q.group_by is True:\n                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                 q.set_group_by()\n+            elif isinstance(q.group_by, tuple):\n+                # Preserve existing GROUP BY clause when it's already set to specific fields\n+                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+                pass\n+            q.clear_select_clause()\n+        q.clear_ordering(True)\n+        q.set_limits(high=1)\n+        compiler = q.get_compiler(using=using)\n+        return compiler.has_results()\n             q.clear_select_clause()\n         q.clear_ordering(True)\n         q.set_limits(high=1)\n@@ -1917,23 +1930,39 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n-        group_by = list(self.select)\n-        if self.annotation_select:\n-            for alias, annotation in self.annotation_select.items():\n-                try:\n-                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n-                except TypeError:\n-                    annotation_class = annotation.__class__\n-                    msg = (\n-                        '`alias=None` must be added to the signature of '\n-                        '%s.%s.get_group_by_cols().'\n-                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n-                    warnings.warn(msg, category=RemovedInDjango40Warning)\n-                    group_by_cols = annotation.get_group_by_cols()\n-                else:\n-                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n-                group_by.extend(group_by_cols)\n-        self.group_by = tuple(group_by)\n+\n+def set_group_by(self, preserve_existing=False):\n+    \"\"\"\n+    Expand the GROUP BY clause required by the query.\n+\n+    This will usually be the set of all non-aggregate fields in the\n+    return data. If the database backend supports grouping by the\n+    primary key, and the query would be equivalent, the optimization\n+    will be made automatically.\n+    \n+    Args:\n+        preserve_existing: If True and group_by is already a tuple, preserve it\n+    \"\"\"\n+    if preserve_existing and isinstance(self.group_by, tuple):\n+        return  # Don't override existing explicit GROUP BY\n+        \n+    group_by = list(self.select)\n+    if self.annotation_select:\n+        for alias, annotation in self.annotation_select.items():\n+            try:\n+                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+            except TypeError:\n+                annotation_class = annotation.__class__\n+                msg = (\n+                    '`alias=None` must be added to the signature of '\n+                    '%s.%s.get_group_by_cols().'\n+                ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                warnings.warn(msg, category=RemovedInDjango40Warning)\n+                group_by_cols = annotation.get_group_by_cols()\n+            else:\n+                group_by_cols = annotation.get_group_by_cols(alias=alias)\n+            group_by.extend(group_by_cols)\n+    self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n         \"\"\"\n@@ -2077,6 +2106,7 @@ class Query(BaseExpression):\n             self.extra_select_mask = set(names)\n         self._extra_select_cache = None\n \n+\n     def set_values(self, fields):\n         self.select_related = False\n         self.clear_deferred_loading()\n@@ -2086,6 +2116,10 @@ class Query(BaseExpression):\n             self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n             self.set_group_by()\n             self.clear_select_fields()\n+        elif isinstance(self.group_by, tuple):\n+            # Preserve existing GROUP BY clause when it's already set to specific fields\n+            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+            pass\n \n         if fields:\n             field_names = []\n@@ -2109,6 +2143,15 @@ class Query(BaseExpression):\n         else:\n             field_names = [f.attname for f in self.model._meta.concrete_fields]\n \n+        self.values_select = tuple(field_names)\n+        self.add_fields(field_names, True)\n+                    else:\n+                        field_names.append(f)\n+            self.set_extra_mask(extra_names)\n+            self.set_annotation_mask(annotation_names)\n+        else:\n+            field_names = [f.attname for f in self.model._meta.concrete_fields]\n+\n         self.values_select = tuple(field_names)\n         self.add_fields(field_names, True)\n \ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex bf0828dc8b..4a68522a46 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -238,6 +238,7 @@ class SubqueryConstraint:\n         self.targets = targets\n         self.query_object = query_object\n \n+\n     def as_sql(self, compiler, connection):\n         query = self.query_object\n         query.set_values(self.targets)\n",
    "variant_7": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..26871b330a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -516,12 +516,25 @@ class Query(BaseExpression):\n     def has_filters(self):\n         return self.where\n \n+    def has_results(self, using):\n+        q = self.clone()\n+        if not q.distinct:\n+\n     def has_results(self, using):\n         q = self.clone()\n         if not q.distinct:\n             if q.group_by is True:\n                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                 q.set_group_by()\n+            elif isinstance(q.group_by, tuple):\n+                # Preserve existing GROUP BY clause when it's already set to specific fields\n+                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+                pass\n+            q.clear_select_clause()\n+        q.clear_ordering(True)\n+        q.set_limits(high=1)\n+        compiler = q.get_compiler(using=using)\n+        return compiler.has_results()\n             q.clear_select_clause()\n         q.clear_ordering(True)\n         q.set_limits(high=1)\n@@ -1917,23 +1930,39 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n-        group_by = list(self.select)\n-        if self.annotation_select:\n-            for alias, annotation in self.annotation_select.items():\n-                try:\n-                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n-                except TypeError:\n-                    annotation_class = annotation.__class__\n-                    msg = (\n-                        '`alias=None` must be added to the signature of '\n-                        '%s.%s.get_group_by_cols().'\n-                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n-                    warnings.warn(msg, category=RemovedInDjango40Warning)\n-                    group_by_cols = annotation.get_group_by_cols()\n-                else:\n-                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n-                group_by.extend(group_by_cols)\n-        self.group_by = tuple(group_by)\n+\n+def set_group_by(self, preserve_existing=False):\n+    \"\"\"\n+    Expand the GROUP BY clause required by the query.\n+\n+    This will usually be the set of all non-aggregate fields in the\n+    return data. If the database backend supports grouping by the\n+    primary key, and the query would be equivalent, the optimization\n+    will be made automatically.\n+    \n+    Args:\n+        preserve_existing: If True and group_by is already a tuple, preserve it\n+    \"\"\"\n+    if preserve_existing and isinstance(self.group_by, tuple):\n+        return  # Don't override existing explicit GROUP BY\n+        \n+    group_by = list(self.select)\n+    if self.annotation_select:\n+        for alias, annotation in self.annotation_select.items():\n+            try:\n+                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+            except TypeError:\n+                annotation_class = annotation.__class__\n+                msg = (\n+                    '`alias=None` must be added to the signature of '\n+                    '%s.%s.get_group_by_cols().'\n+                ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                warnings.warn(msg, category=RemovedInDjango40Warning)\n+                group_by_cols = annotation.get_group_by_cols()\n+            else:\n+                group_by_cols = annotation.get_group_by_cols(alias=alias)\n+            group_by.extend(group_by_cols)\n+    self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n         \"\"\"\n@@ -2077,6 +2106,7 @@ class Query(BaseExpression):\n             self.extra_select_mask = set(names)\n         self._extra_select_cache = None\n \n+\n     def set_values(self, fields):\n         self.select_related = False\n         self.clear_deferred_loading()\n@@ -2086,6 +2116,10 @@ class Query(BaseExpression):\n             self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n             self.set_group_by()\n             self.clear_select_fields()\n+        elif isinstance(self.group_by, tuple):\n+            # Preserve existing GROUP BY clause when it's already set to specific fields\n+            # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+            pass\n \n         if fields:\n             field_names = []\n@@ -2109,6 +2143,15 @@ class Query(BaseExpression):\n         else:\n             field_names = [f.attname for f in self.model._meta.concrete_fields]\n \n+        self.values_select = tuple(field_names)\n+        self.add_fields(field_names, True)\n+                    else:\n+                        field_names.append(f)\n+            self.set_extra_mask(extra_names)\n+            self.set_annotation_mask(annotation_names)\n+        else:\n+            field_names = [f.attname for f in self.model._meta.concrete_fields]\n+\n         self.values_select = tuple(field_names)\n         self.add_fields(field_names, True)\n \ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex bf0828dc8b..4a68522a46 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -238,6 +238,7 @@ class SubqueryConstraint:\n         self.targets = targets\n         self.query_object = query_object\n \n+\n     def as_sql(self, compiler, connection):\n         query = self.query_object\n         query.set_values(self.targets)\n",
    "variant_8": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..883814d779 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -516,12 +516,25 @@ class Query(BaseExpression):\n     def has_filters(self):\n         return self.where\n \n+    def has_results(self, using):\n+        q = self.clone()\n+        if not q.distinct:\n+\n     def has_results(self, using):\n         q = self.clone()\n         if not q.distinct:\n             if q.group_by is True:\n                 q.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n                 q.set_group_by()\n+            elif isinstance(q.group_by, tuple):\n+                # Preserve existing GROUP BY clause when it's already set to specific fields\n+                # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+                pass\n+            q.clear_select_clause()\n+        q.clear_ordering(True)\n+        q.set_limits(high=1)\n+        compiler = q.get_compiler(using=using)\n+        return compiler.has_results()\n             q.clear_select_clause()\n         q.clear_ordering(True)\n         q.set_limits(high=1)\n@@ -1917,6 +1930,22 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n+\n+    def set_group_by(self, preserve_existing=False):\n+        \"\"\"\n+        Expand the GROUP BY clause required by the query.\n+\n+        This will usually be the set of all non-aggregate fields in the\n+        return data. If the database backend supports grouping by the\n+        primary key, and the query would be equivalent, the optimization\n+        will be made automatically.\n+        \n+        Args:\n+            preserve_existing: If True and group_by is already a tuple, preserve it\n+        \"\"\"\n+        if preserve_existing and isinstance(self.group_by, tuple):\n+            return  # Don't override existing explicit GROUP BY\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -2077,31 +2106,45 @@ class Query(BaseExpression):\n             self.extra_select_mask = set(names)\n         self._extra_select_cache = None\n \n-    def set_values(self, fields):\n-        self.select_related = False\n-        self.clear_deferred_loading()\n+\n+def set_values(self, fields):\n+    self.select_related = False\n+    self.clear_deferred_loading()\n+    self.clear_select_fields()\n+\n+    if self.group_by is True:\n+        self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n+        self.set_group_by()\n         self.clear_select_fields()\n+    elif isinstance(self.group_by, tuple):\n+        # Preserve existing GROUP BY clause when it's already set to specific fields\n+        # This prevents overriding explicit GROUP BY clauses in subquery contexts\n+        pass\n+\n+    if fields:\n+        field_names = []\n+        extra_names = []\n+        annotation_names = []\n+        if not self.extra and not self.annotations:\n+            # Shortcut - if there are no extra or annotations, then\n+            # the values() clause must be just field names.\n+            field_names = list(fields)\n+        else:\n+            self.default_cols = False\n+            for f in fields:\n+                if f in self.extra_select:\n+                    extra_names.append(f)\n+                elif f in self.annotation_select:\n+                    annotation_names.append(f)\n+                else:\n+                    field_names.append(f)\n+        self.set_extra_mask(extra_names)\n+        self.set_annotation_mask(annotation_names)\n+    else:\n+        field_names = [f.attname for f in self.model._meta.concrete_fields]\n \n-        if self.group_by is True:\n-            self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)\n-            self.set_group_by()\n-            self.clear_select_fields()\n-\n-        if fields:\n-            field_names = []\n-            extra_names = []\n-            annotation_names = []\n-            if not self.extra and not self.annotations:\n-                # Shortcut - if there are no extra or annotations, then\n-                # the values() clause must be just field names.\n-                field_names = list(fields)\n-            else:\n-                self.default_cols = False\n-                for f in fields:\n-                    if f in self.extra_select:\n-                        extra_names.append(f)\n-                    elif f in self.annotation_select:\n-                        annotation_names.append(f)\n+    self.values_select = tuple(field_names)\n+    self.add_fields(field_names, True)\n                     else:\n                         field_names.append(f)\n             self.set_extra_mask(extra_names)\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex bf0828dc8b..3f01f4f8f3 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -238,8 +238,14 @@ class SubqueryConstraint:\n         self.targets = targets\n         self.query_object = query_object\n \n+\n     def as_sql(self, compiler, connection):\n         query = self.query_object\n+        # Preserve the original GROUP BY clause before calling set_values\n+        original_group_by = query.group_by\n         query.set_values(self.targets)\n+        # Restore the original GROUP BY if it was explicitly set to prevent overriding\n+        if isinstance(original_group_by, tuple) and original_group_by:\n+            query.group_by = original_group_by\n         query_compiler = query.get_compiler(connection=connection)\n         return query_compiler.as_subquery_condition(self.alias, self.columns, compiler)\n"
  }
}