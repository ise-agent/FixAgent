{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 1263-1270)": "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n",
    "Location 2 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 1211-1212)": "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        def _format_args(func: Callable) -> str:\n            try:\n                self.env.app.emit('autodoc-before-process-signature', func, False)\n                sig = inspect.signature(func, follow_wrapped=True,\n                                        type_aliases=self.env.config.autodoc_type_aliases)\n                return stringify_signature(sig, **kwargs)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n\n        candidates = self._get_overloaded_signatures()\n        if candidates:\n            result = []\n            for candidate in candidates:\n                args = _format_args(candidate)\n                if args is not None:\n                    result.append(args)\n            if result:\n                return '\\n'.join(result)\n\n        # fallback to normal operation\n        return _format_args(self.object)\n",
    "Location 3 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 1453-1454)": "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is UNRESOLVED_TYPE:\n            return None\n\n        try:\n            overloads = self.get_overloaded_signatures()\n        except ValueError:\n            # failed to get overloads info.  Use default result instead.\n            pass\n        else:\n            if overloads:\n                # Use signatures of overloaded function instead of the implementation function.\n                return '\\n'.join([stringify_signature(sig, **kwargs) for sig in overloads])\n\n        return super().format_args(**kwargs)\n",
    "Location 4 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 1831-1832)": "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.overloaded_signatures:\n            if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n                actual_obj = self.object\n            else:\n                actual_obj = inspect.unwrap_all(self.object, stop=inspect.isfunction)[1]\n\n            doc = []\n            for overload in self.overloaded_signatures:\n                overload = evaluate_signature(overload, self.env.config.autodoc_type_aliases)\n\n                sig = stringify_signature(overload, **kwargs)\n                doc.append(\"(%s) -> %s\" % (sig.parameters, sig.return_annotation))\n\n            return \"\\n\".join(doc)\n        else:\n            return super().format_args(**kwargs)\n",
    "Location 5 (/root/hy/projects_1/sphinx/sphinx/util/inspect.py lines 549-550)": "\ndef format_args(self, **kwargs: Any) -> str:\n    if self.env.config.autodoc_typehints == 'none':\n        kwargs.setdefault('show_annotation', False)\n\n    try:\n        self._signature = inspect.signature(self.object)\n    except (TypeError, ValueError):\n        # Some callables might not be introspectable.\n        return None\n\n    if self.doc_as_attr:\n        # Don't show signature for the class. Show it for the __init__ method instead.\n        return None\n\n    # detect callables created by functools.partial.\n    if hasattr(self.object, 'func') and hasattr(self.object, 'keywords'):\n        if isinstance(self.object, partial) and self.object.args:\n            return None  # avoid broken signature\n\n    sig = stringify_signature(self._signature, **kwargs)\n    sigs = []\n\n    overloads = self.get_overloaded_signatures()\n    if overloads:\n        # Use signatures of overloaded functions instead of the implementation function.\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        for overload in overloads:\n            overload = evaluate_signature(overload, self.parent.__dict__\n                                        if self.parent else {})\n            sig = stringify_signature(overload, **kwargs)\n            sigs.append(sig)\n    else:\n        sigs = [sig]\n\n    return \"\\n\".join(sigs)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 1263-1270)": [
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n"
    ],
    "Location 2 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 1211-1212)": [
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is UNRESOLVED:\n            return None\n\n        overloads = self.analyzer.overloads.get(self.object_name)\n        if overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded_types = []\n            for overload in overloads:\n                overloaded_types.append(stringify_signature(overload, **kwargs))\n\n            return \"(\\n%s)\" % \"\".join(\"| \" + t + \"\\n\" for t in overloaded_types)\n        else:\n            return super().format_args(**kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded functions instead\n            return self._format_args_from_overloads(overloads, **kwargs)\n\n        try:\n            self.env.app.emit('autodoc-before-process-signature', self.object, False)\n            sig = inspect.signature(self.object, follow_wrapped=True,\n                                    type_aliases=self.env.config.autodoc_type_aliases)\n            args = stringify_signature(sig, **kwargs)\n        except TypeError as exc:\n            logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                           self.fullname, exc)\n            return None\n        except ValueError:\n            args = None\n\n        if args is not None:\n            return args\n        else:\n            return super().format_args(**kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        def _format_args(f: Callable) -> str:\n            try:\n                self.env.app.emit('autodoc-before-process-signature', f, False)\n                sig = inspect.signature(f, follow_wrapped=True,\n                                        type_aliases=self.env.config.autodoc_type_aliases)\n                return stringify_signature(sig, **kwargs)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n\n        candidates = self._get_overloaded_signatures()\n        if candidates:\n            return \"\\n\".join([_format_args(c) for c in candidates])\n        else:\n            return _format_args(self.object)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        def_node = self.env.docname, self.objpath[-1]\n        overloads = self.analyzer.overloads.get(def_node, [])\n        if overloads:\n            # Use signatures of overloaded functions instead if given.\n            overloaded_types = []\n            for overload in overloads:\n                overloaded_types.append(stringify_signature(overload, **kwargs))\n\n            return \"\".join(overloaded_types)\n        else:\n            return super().format_args(**kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object == object.__new__:\n            # __new__ method has no signature\n            return None\n\n        if self.config.autodoc_typehints_format == \"short\":\n            kwargs.setdefault('unqualified_typehints', True)\n\n        try:\n            # First, let's see if it's a generic/overloaded method.\n            overloaded_sigs = self.get_overloaded_signatures()\n            if overloaded_sigs:\n                # It's an overloaded method. Generate signatures for all\n                # overloaded signatures.\n                __globals__ = safe_getattr(self.object, '__globals__', {})\n                for overloaded_sig in overloaded_sigs:\n                    if not inspect.isfunction(self.object):\n                        # for classes, the relevant signature is the __init__\n                        overloaded_sig = overloaded_sig.replace(\n                            return_annotation=Parameter.empty)\n\n                    sig = stringify_signature(overloaded_sig, **kwargs)\n                    args = \"(%s)\" % sig\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        def _format_args(func: Callable) -> str:\n            try:\n                self.env.app.emit('autodoc-before-process-signature', func, False)\n                sig = inspect.signature(func, follow_wrapped=True,\n                                        type_aliases=self.env.config.autodoc_type_aliases)\n                return stringify_signature(sig, **kwargs)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n\n        candidates = self._get_overloaded_signatures()\n        if candidates:\n            return '\\n'.join(_format_args(c) for c in candidates)\n        else:\n            return super().format_args(**kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        def _format_args(f: Callable) -> str:\n            try:\n                self.env.app.emit('autodoc-before-process-signature', f, False)\n                sig = inspect.signature(f, follow_wrapped=True,\n                                        type_aliases=self.env.config.autodoc_type_aliases)\n                return stringify_signature(sig, **kwargs)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n\n        candidates = self._get_overloaded_signatures()\n        if candidates:\n            result = []\n            for candidate in candidates:\n                formatted = _format_args(candidate)\n                if formatted is not None:\n                    result.append(formatted)\n\n            if result:\n                return '\\n'.join(result)\n\n        return _format_args(self.object)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object == object.__new__ and self.parent != object:\n            # __new__ of class X takes no parameters in general\n            args = '()'\n        else:\n            overloads = self.analyzer.overloads.get(self.fullname)\n            if overloads:\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n\n                # Use signatures for overloaded functions instead of the implementation\n                args = '\\n'.join([stringify_signature(sig, **kwargs) for sig in overloads])\n            else:\n                try:\n                    self.env.app.emit('autodoc-before-process-signature', self.object, False)\n                    sig = inspect.signature(self.object, follow_wrapped=True,\n                                            type_aliases=self.env.config.autodoc_type_aliases)\n                    args = stringify_signature(sig, **kwargs)\n                except TypeError as exc:\n                    logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                                   self.fullname, exc)\n                    return None\n                except ValueError:\n                    args = ''\n\n        return args\n"
    ],
    "Location 3 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 1453-1454)": [
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        sig = self._get_signature()\n        if sig is None:\n            return None\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded functions instead\n            return \"(*args, **kwargs)\"\n\n        return stringify_signature(sig, **kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is UNRESOLVED:\n            return None\n\n        overloads = self.analyzer.overloads.get(self.objpath)\n        if overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded_types = []\n            for overload in overloads:\n                overloaded_types.append(stringify_signature(overload, **kwargs))\n\n            return \"(%s)\" % \", \".join(overloaded_types)\n        else:\n            return super().format_args(**kwargs)\n",
      "\n        if self.overloads:\n            if self.env.config.autodoc_typehints in ('none', 'description'):\n                kwargs.setdefault('show_annotation', False)\n            \n            # return list of signatures for overloaded functions\n            sigs = []\n            overloads = self.overloads.copy()\n            overloads.reverse()\n            actual = inspect.signature(self.object, type_aliases=self.env.config.autodoc_type_aliases)\n            overloads.append(actual)\n            for overload in overloads:\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n            return \"\\n\".join(sigs)\n",
      "\n        if not sig:\n            return None\n        \n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        \n        return stringify_signature(sig, **kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is UNRESOLVED:\n            return None\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            return '\\n'.join([stringify_signature(sig, **kwargs) for sig in overloads])\n        else:\n            return super().format_args(**kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is UNRESOLVED:\n            return None\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures from @overload decorated methods instead of the\n            # implementation method.\n            return '\\n'.join([stringify_signature(sig, **kwargs).replace('\\\\', '\\\\\\\\')\n                              for sig in overloads])\n\n        return super().format_args(**kwargs)\n",
      "\n        if self.object is UNRESOLVED:\n            return None\n\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        sig = inspect.signature(self.object, type_aliases=self.env.config.autodoc_type_aliases)\n        args = stringify_signature(sig, **kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is UNRESOLVED:\n            return None\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use the first overload as the base signature\n            sig = overloads[0]\n            return stringify_signature(sig, **kwargs)\n\n        sig = inspect.signature(self.object, type_aliases=self.env.config.autodoc_type_aliases)\n        args = stringify_signature(sig, **kwargs)\n        if self.env.config.strip_signature_backslash:\n            # escape backslashes for rST\n            args = args.replace('\\\\', '\\\\\\\\')\n        return args\n"
    ],
    "Location 4 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 1831-1832)": [
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded_sigs = self.analyzer.overloads.get('.'.join(self.objpath))\n            if overloaded_sigs:\n                # TODO: enable autodoc_typehints to support to show overloaded sigs.\n                return \"(*args, **kwargs)\"\n\n        return super().format_args(**kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is None:\n            return None\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures of overloaded function instead of the implementation function.\n            return \"(%s)\" % \", \".join([stringify_signature(sig, **kwargs)[1:-1]\n                                       for sig in overloads])\n        else:\n            return super().format_args(**kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded_sigs = self.analyzer.overloads.get('.'.join(self.objpath))\n            if overloaded_sigs:\n                # Select non-implementation signature if multiple signatures are given.\n                for overloaded_sig in overloaded_sigs:\n                    if not overloaded_sig.endswith('...'):\n                        sig = overloaded_sig\n                        break\n                else:\n                    sig = overloaded_sigs[0]\n\n                return stringify_signature(sig, **kwargs)\n\n        return super().format_args(**kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is None:\n            return None\n        if self.args is not None:\n            # signature given explicitly\n            args = \"(%s)\" % self.args\n        else:\n            # try to introspect the signature of the object and provide it\n            try:\n                args = stringify_signature(self.object, **kwargs)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                args = ''\n\n        if self.env.config.strip_signature_backslash:\n            # escape backslashes for rST\n            args = args.replace('\\\\', '\\\\\\\\')\n        return args\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is None:\n            return None\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures of overloaded function instead of the implementation function.\n            return '\\n'.join(stringify_signature(sig, **kwargs) for sig in overloads)\n        else:\n            return super().format_args(**kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is None:\n            return None\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use the first overload instead of the implementation\n            return stringify_signature(overloads[0], **kwargs)\n        else:\n            return super().format_args(**kwargs)\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is None:\n            return None\n        if self.args is not None:\n            # signature given explicitly\n            args = \"(%s)\" % self.args\n        else:\n            # try to introspect the signature of the object and provide it\n            try:\n                args = stringify_signature(self.object, **kwargs)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            except ValueError:\n                args = ''\n\n        if self.env.config.strip_signature_backslash:\n            # escape backslashes for reST\n            args = args.replace('\\\\', '\\\\\\\\')\n        return args\n",
      "\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        if self.object is None:\n            return None\n        if self.args is not None:\n            # signature given explicitly\n            args = \"(%s)\" % self.args\n        else:\n            # try to introspect the signature of the object and provide it\n            try:\n                args = stringify_signature(self.object, **kwargs)\n            except TypeError as exc:\n                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                               self.fullname, exc)\n                return None\n            if self.env.config.strip_signature_backslash:\n                # escape backslashes for rST\n                args = args.replace('\\\\', '\\\\\\\\')\n        return args\n"
    ],
    "Location 5 (/root/hy/projects_1/sphinx/sphinx/util/inspect.py lines 549-550)": [
      "\ndef format_args(self, **kwargs: Any) -> str:\n    if self.env.config.autodoc_typehints == 'none':\n        kwargs.setdefault('show_annotation', False)\n    if self.env.config.autodoc_typehints_description_target == \"documented_params\":\n        kwargs.setdefault('show_annotation', False)\n\n    try:\n        self._signature_from_str = None\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            if self.env.config.autodoc_typehints in ('none', 'description'):\n                kwargs.setdefault('show_annotation', False)\n            return '\\n'.join([stringify_signature(sig, **kwargs) for sig in overloads])\n        else:\n            return super().format_args(**kwargs)\n    except TypeError:\n        # stringify_signature() failed to return a string\n        return None\n",
      "\ndef format_args(self, **kwargs: Any) -> str:\n    if self.env.config.autodoc_overloaded_signatures:\n        return self._format_args_untyped(**kwargs)\n\n    # try to also get a signature with type annotations\n    overloaded_sigs = self.get_overloaded_signatures()\n    if overloaded_sigs:\n        # Use the implementation from other format_args methods\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n\n        # Favor the overloaded signature over the actual signature\n        return \"(%s)\" % \", \".join([stringify_signature(sig, **kwargs).strip(\"()\")\n                                   for sig in overloaded_sigs])\n    else:\n        return super().format_args(**kwargs)\n",
      "\ndef format_args(self, **kwargs: Any) -> str:\n    if self.env.config.autodoc_typehints_format == \"short\":\n        kwargs.setdefault(\"unqualified_typehints\", True)\n\n    try:\n        self._signature_from_str = None\n        sig = self._call_format_args(**kwargs)\n        if sig:\n            return sig\n    except Exception as exc:\n        logger.warning(__(\"error while formatting arguments for %s: %s\"),\n                       self.fullname, exc, type='autodoc')\n\n    # retry without typehints\n    try:\n        return self._call_format_args(show_annotation=False,\n                                      show_return_annotation=False,\n                                      **kwargs)\n    except Exception:\n        return None\n\ndef _call_format_args(self, **kwargs: Any) -> str:\n    try:\n        # try to create a Signature from inspect module\n        sig = inspect.signature(self.object)\n    except (TypeError, ValueError):\n        # fallback: format_signature()\n        return super().format_args(**kwargs)\n\n    args = []\n\n    if self.env.config.autodoc_typehints in ('none', 'description'):\n        kwargs.setdefault('show_annotation', False)\n\n    # iterate over all overloaded signatures\n    overloads = self.analyzer.overloads.get(self.objpath)\n    if overloads:\n        for overload in overloads:\n            overload = evaluate_signature(overload, self.object.__globals__)\n            sig = stringify_signature(overload, **kwargs)\n            args.append(\"(%s)\" % sig)\n    else:\n        sig = stringify_signature(sig, **kwargs)\n        args.append(\"(%s)\" % sig)\n\n    if args:\n        return \" or \".join(args)\n    else:\n        return None\n",
      "\ndef format_args(self, **kwargs: Any) -> str:\n    if self.env.config.autodoc_typehints == 'none':\n        kwargs.setdefault('show_annotation', False)\n\n    try:\n        self._call_format_args(**kwargs)\n    except TypeError:\n        # avoid chaining exceptions, by putting nothing here\n        pass\n\n    # for all items other than the first one, add their\n    # function signatures to the return value\n    doc = []\n    for i, sig in enumerate(self._signatures):\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        formatted = stringify_signature(sig, **kwargs)\n        if self.config.strip_signature_backslash:\n            formatted = formatted.replace('\\\\', '').replace('\\\\', '')\n        doc.append(formatted)\n\n    return '\\n'.join(doc)\n",
      "\ndef format_args(self, **kwargs: Any) -> str:\n    if self.env.config.autodoc_overloads_format == 'list':\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        \n        # for overloaded functions, show all overloaded signatures\n        return '\\n'.join(stringify_signature(sig, **kwargs)\n                         for sig in self.doc_as_overloads)\n    else:\n        return super().format_args(**kwargs)\n",
      "\ndef format_args(self, **kwargs: Any) -> str:\n    if self.env.config.autodoc_typehints != 'signature':\n        kwargs.setdefault('show_annotation', False)\n\n    try:\n        self._call_format_args(**kwargs)\n    except TypeError:\n        # avoid chaining exceptions, by putting nothing here\n        pass\n\n    # decode function definition\n    overloads = self.analyzer and self.analyzer.overloads.get(self.fullname)\n    if overloads:\n        # Use signatures of overloaded function instead of the implementation.\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        \n        sig = stringify_signature(overloads[0], **kwargs)\n        if len(overloads) > 1:\n            sig += \"\\n\" + \"\\n\".join([stringify_signature(overload, **kwargs)\n                                     for overload in overloads[1:]])\n        return sig\n    else:\n        return super().format_args(**kwargs)\n",
      "\ndef format_args(self, **kwargs: Any) -> str:\n    if self.env.config.autodoc_overloads:\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use the implementation of the method for the actual signature\n            # and add the overloaded signatures as a comment\n            doc = []\n            for overload in overloads:\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                doc.append(stringify_signature(overload, **kwargs))\n\n            actual_signature = super().format_args(**kwargs)\n            doc.append(actual_signature)\n\n            return '\\n'.join(doc)\n\n    return super().format_args(**kwargs)\n",
      "\ndef format_args(self, **kwargs: Any) -> str:\n    if self.env.config.autodoc_typehints in ('none', 'description'):\n        kwargs.setdefault('show_annotation', False)\n\n    try:\n        self._update_annotations(self.object)\n    except (AttributeError, TypeError):\n        # Failed to update signature\n        return None\n\n    if self.doc_as_attr:\n        # Don't show signatures for explicit attributes.\n        return ''\n\n    # for callables, add call signature\n    try:\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            sigs = []\n            for overload in overloads:\n                if self.env.config.autodoc_typehints in ('none', 'description'):\n                    kwargs.setdefault('show_annotation', False)\n                sigs.append(stringify_signature(overload, **kwargs))\n            return \"\\\\n\".join(sigs)\n        else:\n            sig = inspect.signature(self.object)\n            return stringify_signature(sig, **kwargs)\n    except (TypeError, ValueError):\n        # signature not found\n        return None\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..accdb4290 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1208,6 +1208,7 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n \n     def format_args(self, **kwargs: Any) -> str:\n+\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n@@ -1260,12 +1261,15 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1450,6 +1454,7 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         return None, None, None\n \n     def format_args(self, **kwargs: Any) -> str:\n+\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n@@ -1828,6 +1833,7 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n         return ret\n \n     def format_args(self, **kwargs: Any) -> str:\n+\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..fbf4b89f0 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,6 +546,7 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n+\n def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n                         show_return_annotation: bool = True) -> str:\n     \"\"\"Stringify a Signature object.\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..e64be2327 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1207,10 +1207,36 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        def _format_args(func: Callable) -> str:\n+            try:\n+                self.env.app.emit('autodoc-before-process-signature', func, False)\n+                sig = inspect.signature(func, follow_wrapped=True,\n+                                        type_aliases=self.env.config.autodoc_type_aliases)\n+                return stringify_signature(sig, **kwargs)\n+            except TypeError as exc:\n+                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                               self.fullname, exc)\n+                return None\n+\n+        candidates = self._get_overloaded_signatures()\n+        if candidates:\n+            result = []\n+            for candidate in candidates:\n+                args = _format_args(candidate)\n+                if args is not None:\n+                    result.append(args)\n+            if result:\n+                return '\\n'.join(result)\n+\n+        # fallback to normal operation\n+        return _format_args(self.object)\n+\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, follow_wrapped=True,\n@@ -1260,12 +1286,15 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1449,10 +1478,27 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         # with __init__ in C and no `__text_signature__`.\n         return None, None, None\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is UNRESOLVED_TYPE:\n+            return None\n+\n+        try:\n+            overloads = self.get_overloaded_signatures()\n+        except ValueError:\n+            # failed to get overloads info.  Use default result instead.\n+            pass\n+        else:\n+            if overloads:\n+                # Use signatures of overloaded function instead of the implementation function.\n+                return '\\n'.join([stringify_signature(sig, **kwargs) for sig in overloads])\n+\n+        return super().format_args(**kwargs)\n+\n         try:\n             self._signature_class, self._signature_method_name, sig = self._get_signature()\n         except TypeError as exc:\n@@ -1827,10 +1873,29 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n         return ret\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.overloaded_signatures:\n+            if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n+                actual_obj = self.object\n+            else:\n+                actual_obj = inspect.unwrap_all(self.object, stop=inspect.isfunction)[1]\n+\n+            doc = []\n+            for overload in self.overloaded_signatures:\n+                overload = evaluate_signature(overload, self.env.config.autodoc_type_aliases)\n+\n+                sig = stringify_signature(overload, **kwargs)\n+                doc.append(\"(%s) -> %s\" % (sig.parameters, sig.return_annotation))\n+\n+            return \"\\n\".join(doc)\n+        else:\n+            return super().format_args(**kwargs)\n+\n         try:\n             if self.object == object.__init__ and self.parent != object:\n                 # Classes not having own __init__() method are shown as no arguments.\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..a3a47b4d6 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,8 +546,43 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n+\n+def format_args(self, **kwargs: Any) -> str:\n+    if self.env.config.autodoc_typehints == 'none':\n+        kwargs.setdefault('show_annotation', False)\n+\n+    try:\n+        self._signature = inspect.signature(self.object)\n+    except (TypeError, ValueError):\n+        # Some callables might not be introspectable.\n+        return None\n+\n+    if self.doc_as_attr:\n+        # Don't show signature for the class. Show it for the __init__ method instead.\n+        return None\n+\n+    # detect callables created by functools.partial.\n+    if hasattr(self.object, 'func') and hasattr(self.object, 'keywords'):\n+        if isinstance(self.object, partial) and self.object.args:\n+            return None  # avoid broken signature\n+\n+    sig = stringify_signature(self._signature, **kwargs)\n+    sigs = []\n+\n+    overloads = self.get_overloaded_signatures()\n+    if overloads:\n+        # Use signatures of overloaded functions instead of the implementation function.\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+        for overload in overloads:\n+            overload = evaluate_signature(overload, self.parent.__dict__\n+                                        if self.parent else {})\n+            sig = stringify_signature(overload, **kwargs)\n+            sigs.append(sig)\n+    else:\n+        sigs = [sig]\n+\n+    return \"\\n\".join(sigs)\n     \"\"\"Stringify a Signature object.\n \n     :param show_annotation: Show annotation in result\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..71e3cbb0c 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1207,10 +1207,26 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is UNRESOLVED:\n+            return None\n+\n+        overloads = self.analyzer.overloads.get(self.object_name)\n+        if overloads:\n+            # Use signatures for overloaded functions instead of the implementation function.\n+            overloaded_types = []\n+            for overload in overloads:\n+                overloaded_types.append(stringify_signature(overload, **kwargs))\n+\n+            return \"(\\n%s)\" % \"\".join(\"| \" + t + \"\\n\" for t in overloaded_types)\n+        else:\n+            return super().format_args(**kwargs)\n+\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, follow_wrapped=True,\n@@ -1260,12 +1276,15 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1449,10 +1468,23 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         # with __init__ in C and no `__text_signature__`.\n         return None, None, None\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        sig = self._get_signature()\n+        if sig is None:\n+            return None\n+\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use signatures for overloaded functions instead\n+            return \"(*args, **kwargs)\"\n+\n+        return stringify_signature(sig, **kwargs)\n+\n         try:\n             self._signature_class, self._signature_method_name, sig = self._get_signature()\n         except TypeError as exc:\n@@ -1827,10 +1859,21 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n         return ret\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n+            # Use signatures for overloaded functions instead of the implementation function.\n+            overloaded_sigs = self.analyzer.overloads.get('.'.join(self.objpath))\n+            if overloaded_sigs:\n+                # TODO: enable autodoc_typehints to support to show overloaded sigs.\n+                return \"(*args, **kwargs)\"\n+\n+        return super().format_args(**kwargs)\n+\n         try:\n             if self.object == object.__init__ and self.parent != object:\n                 # Classes not having own __init__() method are shown as no arguments.\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..0c13ba7e7 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,8 +546,26 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n+\n+def format_args(self, **kwargs: Any) -> str:\n+    if self.env.config.autodoc_typehints == 'none':\n+        kwargs.setdefault('show_annotation', False)\n+    if self.env.config.autodoc_typehints_description_target == \"documented_params\":\n+        kwargs.setdefault('show_annotation', False)\n+\n+    try:\n+        self._signature_from_str = None\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use signatures for overloaded functions instead of the implementation function.\n+            if self.env.config.autodoc_typehints in ('none', 'description'):\n+                kwargs.setdefault('show_annotation', False)\n+            return '\\n'.join([stringify_signature(sig, **kwargs) for sig in overloads])\n+        else:\n+            return super().format_args(**kwargs)\n+    except TypeError:\n+        # stringify_signature() failed to return a string\n+        return None\n     \"\"\"Stringify a Signature object.\n \n     :param show_annotation: Show annotation in result\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..6f9328a30 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1207,10 +1207,34 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use signatures for overloaded functions instead\n+            return self._format_args_from_overloads(overloads, **kwargs)\n+\n+        try:\n+            self.env.app.emit('autodoc-before-process-signature', self.object, False)\n+            sig = inspect.signature(self.object, follow_wrapped=True,\n+                                    type_aliases=self.env.config.autodoc_type_aliases)\n+            args = stringify_signature(sig, **kwargs)\n+        except TypeError as exc:\n+            logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                           self.fullname, exc)\n+            return None\n+        except ValueError:\n+            args = None\n+\n+        if args is not None:\n+            return args\n+        else:\n+            return super().format_args(**kwargs)\n+\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, follow_wrapped=True,\n@@ -1260,12 +1284,15 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1449,10 +1476,26 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         # with __init__ in C and no `__text_signature__`.\n         return None, None, None\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is UNRESOLVED:\n+            return None\n+\n+        overloads = self.analyzer.overloads.get(self.objpath)\n+        if overloads:\n+            # Use signatures for overloaded functions instead of the implementation function.\n+            overloaded_types = []\n+            for overload in overloads:\n+                overloaded_types.append(stringify_signature(overload, **kwargs))\n+\n+            return \"(%s)\" % \", \".join(overloaded_types)\n+        else:\n+            return super().format_args(**kwargs)\n+\n         try:\n             self._signature_class, self._signature_method_name, sig = self._get_signature()\n         except TypeError as exc:\n@@ -1827,10 +1870,23 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n         return ret\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is None:\n+            return None\n+\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use signatures of overloaded function instead of the implementation function.\n+            return \"(%s)\" % \", \".join([stringify_signature(sig, **kwargs)[1:-1]\n+                                       for sig in overloads])\n+        else:\n+            return super().format_args(**kwargs)\n+\n         try:\n             if self.object == object.__init__ and self.parent != object:\n                 # Classes not having own __init__() method are shown as no arguments.\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..abb56ad5d 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,8 +546,23 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n+\n+def format_args(self, **kwargs: Any) -> str:\n+    if self.env.config.autodoc_overloaded_signatures:\n+        return self._format_args_untyped(**kwargs)\n+\n+    # try to also get a signature with type annotations\n+    overloaded_sigs = self.get_overloaded_signatures()\n+    if overloaded_sigs:\n+        # Use the implementation from other format_args methods\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+\n+        # Favor the overloaded signature over the actual signature\n+        return \"(%s)\" % \", \".join([stringify_signature(sig, **kwargs).strip(\"()\")\n+                                   for sig in overloaded_sigs])\n+    else:\n+        return super().format_args(**kwargs)\n     \"\"\"Stringify a Signature object.\n \n     :param show_annotation: Show annotation in result\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..dec4a0402 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1207,10 +1207,29 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        def _format_args(f: Callable) -> str:\n+            try:\n+                self.env.app.emit('autodoc-before-process-signature', f, False)\n+                sig = inspect.signature(f, follow_wrapped=True,\n+                                        type_aliases=self.env.config.autodoc_type_aliases)\n+                return stringify_signature(sig, **kwargs)\n+            except TypeError as exc:\n+                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                               self.fullname, exc)\n+                return None\n+\n+        candidates = self._get_overloaded_signatures()\n+        if candidates:\n+            return \"\\n\".join([_format_args(c) for c in candidates])\n+        else:\n+            return _format_args(self.object)\n+\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, follow_wrapped=True,\n@@ -1260,12 +1279,15 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1450,8 +1472,21 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         return None, None, None\n \n     def format_args(self, **kwargs: Any) -> str:\n-        if self.env.config.autodoc_typehints in ('none', 'description'):\n-            kwargs.setdefault('show_annotation', False)\n+\n+        if self.overloads:\n+            if self.env.config.autodoc_typehints in ('none', 'description'):\n+                kwargs.setdefault('show_annotation', False)\n+            \n+            # return list of signatures for overloaded functions\n+            sigs = []\n+            overloads = self.overloads.copy()\n+            overloads.reverse()\n+            actual = inspect.signature(self.object, type_aliases=self.env.config.autodoc_type_aliases)\n+            overloads.append(actual)\n+            for overload in overloads:\n+                sig = stringify_signature(overload, **kwargs)\n+                sigs.append(sig)\n+            return \"\\n\".join(sigs)\n \n         try:\n             self._signature_class, self._signature_method_name, sig = self._get_signature()\n@@ -1827,10 +1862,28 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n         return ret\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n+            # Use signatures for overloaded functions instead of the implementation function.\n+            overloaded_sigs = self.analyzer.overloads.get('.'.join(self.objpath))\n+            if overloaded_sigs:\n+                # Select non-implementation signature if multiple signatures are given.\n+                for overloaded_sig in overloaded_sigs:\n+                    if not overloaded_sig.endswith('...'):\n+                        sig = overloaded_sig\n+                        break\n+                else:\n+                    sig = overloaded_sigs[0]\n+\n+                return stringify_signature(sig, **kwargs)\n+\n+        return super().format_args(**kwargs)\n+\n         try:\n             if self.object == object.__init__ and self.parent != object:\n                 # Classes not having own __init__() method are shown as no arguments.\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..14f5d6f44 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,8 +546,56 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n+\n+def format_args(self, **kwargs: Any) -> str:\n+    if self.env.config.autodoc_typehints_format == \"short\":\n+        kwargs.setdefault(\"unqualified_typehints\", True)\n+\n+    try:\n+        self._signature_from_str = None\n+        sig = self._call_format_args(**kwargs)\n+        if sig:\n+            return sig\n+    except Exception as exc:\n+        logger.warning(__(\"error while formatting arguments for %s: %s\"),\n+                       self.fullname, exc, type='autodoc')\n+\n+    # retry without typehints\n+    try:\n+        return self._call_format_args(show_annotation=False,\n+                                      show_return_annotation=False,\n+                                      **kwargs)\n+    except Exception:\n+        return None\n+\n+def _call_format_args(self, **kwargs: Any) -> str:\n+    try:\n+        # try to create a Signature from inspect module\n+        sig = inspect.signature(self.object)\n+    except (TypeError, ValueError):\n+        # fallback: format_signature()\n+        return super().format_args(**kwargs)\n+\n+    args = []\n+\n+    if self.env.config.autodoc_typehints in ('none', 'description'):\n+        kwargs.setdefault('show_annotation', False)\n+\n+    # iterate over all overloaded signatures\n+    overloads = self.analyzer.overloads.get(self.objpath)\n+    if overloads:\n+        for overload in overloads:\n+            overload = evaluate_signature(overload, self.object.__globals__)\n+            sig = stringify_signature(overload, **kwargs)\n+            args.append(\"(%s)\" % sig)\n+    else:\n+        sig = stringify_signature(sig, **kwargs)\n+        args.append(\"(%s)\" % sig)\n+\n+    if args:\n+        return \" or \".join(args)\n+    else:\n+        return None\n     \"\"\"Stringify a Signature object.\n \n     :param show_annotation: Show annotation in result\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..acb24d8d8 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1207,10 +1207,24 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        def_node = self.env.docname, self.objpath[-1]\n+        overloads = self.analyzer.overloads.get(def_node, [])\n+        if overloads:\n+            # Use signatures of overloaded functions instead if given.\n+            overloaded_types = []\n+            for overload in overloads:\n+                overloaded_types.append(stringify_signature(overload, **kwargs))\n+\n+            return \"\".join(overloaded_types)\n+        else:\n+            return super().format_args(**kwargs)\n+\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, follow_wrapped=True,\n@@ -1260,12 +1274,15 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1450,8 +1467,14 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         return None, None, None\n \n     def format_args(self, **kwargs: Any) -> str:\n+\n+        if not sig:\n+            return None\n+        \n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n+        \n+        return stringify_signature(sig, **kwargs)\n \n         try:\n             self._signature_class, self._signature_method_name, sig = self._get_signature()\n@@ -1827,10 +1850,33 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n         return ret\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is None:\n+            return None\n+        if self.args is not None:\n+            # signature given explicitly\n+            args = \"(%s)\" % self.args\n+        else:\n+            # try to introspect the signature of the object and provide it\n+            try:\n+                args = stringify_signature(self.object, **kwargs)\n+            except TypeError as exc:\n+                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                               self.fullname, exc)\n+                return None\n+            except ValueError:\n+                args = ''\n+\n+        if self.env.config.strip_signature_backslash:\n+            # escape backslashes for rST\n+            args = args.replace('\\\\', '\\\\\\\\')\n+        return args\n+\n         try:\n             if self.object == object.__init__ and self.parent != object:\n                 # Classes not having own __init__() method are shown as no arguments.\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..8cd805d7e 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,8 +546,29 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n+\n+def format_args(self, **kwargs: Any) -> str:\n+    if self.env.config.autodoc_typehints == 'none':\n+        kwargs.setdefault('show_annotation', False)\n+\n+    try:\n+        self._call_format_args(**kwargs)\n+    except TypeError:\n+        # avoid chaining exceptions, by putting nothing here\n+        pass\n+\n+    # for all items other than the first one, add their\n+    # function signatures to the return value\n+    doc = []\n+    for i, sig in enumerate(self._signatures):\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+        formatted = stringify_signature(sig, **kwargs)\n+        if self.config.strip_signature_backslash:\n+            formatted = formatted.replace('\\\\', '').replace('\\\\', '')\n+        doc.append(formatted)\n+\n+    return '\\n'.join(doc)\n     \"\"\"Stringify a Signature object.\n \n     :param show_annotation: Show annotation in result\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..288004706 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1207,10 +1207,35 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object == object.__new__:\n+            # __new__ method has no signature\n+            return None\n+\n+        if self.config.autodoc_typehints_format == \"short\":\n+            kwargs.setdefault('unqualified_typehints', True)\n+\n+        try:\n+            # First, let's see if it's a generic/overloaded method.\n+            overloaded_sigs = self.get_overloaded_signatures()\n+            if overloaded_sigs:\n+                # It's an overloaded method. Generate signatures for all\n+                # overloaded signatures.\n+                __globals__ = safe_getattr(self.object, '__globals__', {})\n+                for overloaded_sig in overloaded_sigs:\n+                    if not inspect.isfunction(self.object):\n+                        # for classes, the relevant signature is the __init__\n+                        overloaded_sig = overloaded_sig.replace(\n+                            return_annotation=Parameter.empty)\n+\n+                    sig = stringify_signature(overloaded_sig, **kwargs)\n+                    args = \"(%s)\" % sig\n+\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, follow_wrapped=True,\n@@ -1260,12 +1285,15 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1449,10 +1477,22 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         # with __init__ in C and no `__text_signature__`.\n         return None, None, None\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is UNRESOLVED:\n+            return None\n+\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use signatures for overloaded functions instead of the implementation function.\n+            return '\\n'.join([stringify_signature(sig, **kwargs) for sig in overloads])\n+        else:\n+            return super().format_args(**kwargs)\n+\n         try:\n             self._signature_class, self._signature_method_name, sig = self._get_signature()\n         except TypeError as exc:\n@@ -1827,10 +1867,22 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n         return ret\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is None:\n+            return None\n+\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use signatures of overloaded function instead of the implementation function.\n+            return '\\n'.join(stringify_signature(sig, **kwargs) for sig in overloads)\n+        else:\n+            return super().format_args(**kwargs)\n+\n         try:\n             if self.object == object.__init__ and self.parent != object:\n                 # Classes not having own __init__() method are shown as no arguments.\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..5881295cb 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,8 +546,17 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n+\n+def format_args(self, **kwargs: Any) -> str:\n+    if self.env.config.autodoc_overloads_format == 'list':\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+        \n+        # for overloaded functions, show all overloaded signatures\n+        return '\\n'.join(stringify_signature(sig, **kwargs)\n+                         for sig in self.doc_as_overloads)\n+    else:\n+        return super().format_args(**kwargs)\n     \"\"\"Stringify a Signature object.\n \n     :param show_annotation: Show annotation in result\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..d4beb25fb 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1207,10 +1207,29 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        def _format_args(func: Callable) -> str:\n+            try:\n+                self.env.app.emit('autodoc-before-process-signature', func, False)\n+                sig = inspect.signature(func, follow_wrapped=True,\n+                                        type_aliases=self.env.config.autodoc_type_aliases)\n+                return stringify_signature(sig, **kwargs)\n+            except TypeError as exc:\n+                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                               self.fullname, exc)\n+                return None\n+\n+        candidates = self._get_overloaded_signatures()\n+        if candidates:\n+            return '\\n'.join(_format_args(c) for c in candidates)\n+        else:\n+            return super().format_args(**kwargs)\n+\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, follow_wrapped=True,\n@@ -1260,12 +1279,15 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1449,10 +1471,24 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         # with __init__ in C and no `__text_signature__`.\n         return None, None, None\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is UNRESOLVED:\n+            return None\n+\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use signatures from @overload decorated methods instead of the\n+            # implementation method.\n+            return '\\n'.join([stringify_signature(sig, **kwargs).replace('\\\\', '\\\\\\\\')\n+                              for sig in overloads])\n+\n+        return super().format_args(**kwargs)\n+\n         try:\n             self._signature_class, self._signature_method_name, sig = self._get_signature()\n         except TypeError as exc:\n@@ -1827,10 +1863,21 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n         return ret\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is None:\n+            return None\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use the first overload instead of the implementation\n+            return stringify_signature(overloads[0], **kwargs)\n+        else:\n+            return super().format_args(**kwargs)\n+\n         try:\n             if self.object == object.__init__ and self.parent != object:\n                 # Classes not having own __init__() method are shown as no arguments.\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..4ee4649fe 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,8 +546,31 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n+\n+def format_args(self, **kwargs: Any) -> str:\n+    if self.env.config.autodoc_typehints != 'signature':\n+        kwargs.setdefault('show_annotation', False)\n+\n+    try:\n+        self._call_format_args(**kwargs)\n+    except TypeError:\n+        # avoid chaining exceptions, by putting nothing here\n+        pass\n+\n+    # decode function definition\n+    overloads = self.analyzer and self.analyzer.overloads.get(self.fullname)\n+    if overloads:\n+        # Use signatures of overloaded function instead of the implementation.\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+        \n+        sig = stringify_signature(overloads[0], **kwargs)\n+        if len(overloads) > 1:\n+            sig += \"\\n\" + \"\\n\".join([stringify_signature(overload, **kwargs)\n+                                     for overload in overloads[1:]])\n+        return sig\n+    else:\n+        return super().format_args(**kwargs)\n     \"\"\"Stringify a Signature object.\n \n     :param show_annotation: Show annotation in result\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..fe251978f 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1207,10 +1207,36 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        def _format_args(f: Callable) -> str:\n+            try:\n+                self.env.app.emit('autodoc-before-process-signature', f, False)\n+                sig = inspect.signature(f, follow_wrapped=True,\n+                                        type_aliases=self.env.config.autodoc_type_aliases)\n+                return stringify_signature(sig, **kwargs)\n+            except TypeError as exc:\n+                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                               self.fullname, exc)\n+                return None\n+\n+        candidates = self._get_overloaded_signatures()\n+        if candidates:\n+            result = []\n+            for candidate in candidates:\n+                formatted = _format_args(candidate)\n+                if formatted is not None:\n+                    result.append(formatted)\n+\n+            if result:\n+                return '\\n'.join(result)\n+\n+        return _format_args(self.object)\n+\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, follow_wrapped=True,\n@@ -1260,12 +1286,15 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1450,9 +1479,16 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         return None, None, None\n \n     def format_args(self, **kwargs: Any) -> str:\n+\n+        if self.object is UNRESOLVED:\n+            return None\n+\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        sig = inspect.signature(self.object, type_aliases=self.env.config.autodoc_type_aliases)\n+        args = stringify_signature(sig, **kwargs)\n+\n         try:\n             self._signature_class, self._signature_method_name, sig = self._get_signature()\n         except TypeError as exc:\n@@ -1827,10 +1863,33 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n         return ret\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is None:\n+            return None\n+        if self.args is not None:\n+            # signature given explicitly\n+            args = \"(%s)\" % self.args\n+        else:\n+            # try to introspect the signature of the object and provide it\n+            try:\n+                args = stringify_signature(self.object, **kwargs)\n+            except TypeError as exc:\n+                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                               self.fullname, exc)\n+                return None\n+            except ValueError:\n+                args = ''\n+\n+        if self.env.config.strip_signature_backslash:\n+            # escape backslashes for reST\n+            args = args.replace('\\\\', '\\\\\\\\')\n+        return args\n+\n         try:\n             if self.object == object.__init__ and self.parent != object:\n                 # Classes not having own __init__() method are shown as no arguments.\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..60fb060ce 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,8 +546,25 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n+\n+def format_args(self, **kwargs: Any) -> str:\n+    if self.env.config.autodoc_overloads:\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use the implementation of the method for the actual signature\n+            # and add the overloaded signatures as a comment\n+            doc = []\n+            for overload in overloads:\n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n+                doc.append(stringify_signature(overload, **kwargs))\n+\n+            actual_signature = super().format_args(**kwargs)\n+            doc.append(actual_signature)\n+\n+            return '\\n'.join(doc)\n+\n+    return super().format_args(**kwargs)\n     \"\"\"Stringify a Signature object.\n \n     :param show_annotation: Show annotation in result\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..5b76ae461 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1207,10 +1207,38 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object == object.__new__ and self.parent != object:\n+            # __new__ of class X takes no parameters in general\n+            args = '()'\n+        else:\n+            overloads = self.analyzer.overloads.get(self.fullname)\n+            if overloads:\n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n+\n+                # Use signatures for overloaded functions instead of the implementation\n+                args = '\\n'.join([stringify_signature(sig, **kwargs) for sig in overloads])\n+            else:\n+                try:\n+                    self.env.app.emit('autodoc-before-process-signature', self.object, False)\n+                    sig = inspect.signature(self.object, follow_wrapped=True,\n+                                            type_aliases=self.env.config.autodoc_type_aliases)\n+                    args = stringify_signature(sig, **kwargs)\n+                except TypeError as exc:\n+                    logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                                   self.fullname, exc)\n+                    return None\n+                except ValueError:\n+                    args = ''\n+\n+        return args\n+\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, follow_wrapped=True,\n@@ -1260,12 +1288,15 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1449,10 +1480,28 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         # with __init__ in C and no `__text_signature__`.\n         return None, None, None\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is UNRESOLVED:\n+            return None\n+\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use the first overload as the base signature\n+            sig = overloads[0]\n+            return stringify_signature(sig, **kwargs)\n+\n+        sig = inspect.signature(self.object, type_aliases=self.env.config.autodoc_type_aliases)\n+        args = stringify_signature(sig, **kwargs)\n+        if self.env.config.strip_signature_backslash:\n+            # escape backslashes for rST\n+            args = args.replace('\\\\', '\\\\\\\\')\n+        return args\n+\n         try:\n             self._signature_class, self._signature_method_name, sig = self._get_signature()\n         except TypeError as exc:\n@@ -1827,10 +1876,30 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n         return ret\n \n+    def format_args(self, **kwargs: Any) -> str:\n+\n     def format_args(self, **kwargs: Any) -> str:\n         if self.env.config.autodoc_typehints in ('none', 'description'):\n             kwargs.setdefault('show_annotation', False)\n \n+        if self.object is None:\n+            return None\n+        if self.args is not None:\n+            # signature given explicitly\n+            args = \"(%s)\" % self.args\n+        else:\n+            # try to introspect the signature of the object and provide it\n+            try:\n+                args = stringify_signature(self.object, **kwargs)\n+            except TypeError as exc:\n+                logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                               self.fullname, exc)\n+                return None\n+            if self.env.config.strip_signature_backslash:\n+                # escape backslashes for rST\n+                args = args.replace('\\\\', '\\\\\\\\')\n+        return args\n+\n         try:\n             if self.object == object.__init__ and self.parent != object:\n                 # Classes not having own __init__() method are shown as no arguments.\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..b6a1908f2 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,8 +546,38 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n+\n+def format_args(self, **kwargs: Any) -> str:\n+    if self.env.config.autodoc_typehints in ('none', 'description'):\n+        kwargs.setdefault('show_annotation', False)\n+\n+    try:\n+        self._update_annotations(self.object)\n+    except (AttributeError, TypeError):\n+        # Failed to update signature\n+        return None\n+\n+    if self.doc_as_attr:\n+        # Don't show signatures for explicit attributes.\n+        return ''\n+\n+    # for callables, add call signature\n+    try:\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            # Use signatures for overloaded functions instead of the implementation function.\n+            sigs = []\n+            for overload in overloads:\n+                if self.env.config.autodoc_typehints in ('none', 'description'):\n+                    kwargs.setdefault('show_annotation', False)\n+                sigs.append(stringify_signature(overload, **kwargs))\n+            return \"\\\\n\".join(sigs)\n+        else:\n+            sig = inspect.signature(self.object)\n+            return stringify_signature(sig, **kwargs)\n+    except (TypeError, ValueError):\n+        # signature not found\n+        return None\n     \"\"\"Stringify a Signature object.\n \n     :param show_annotation: Show annotation in result\n"
  }
}