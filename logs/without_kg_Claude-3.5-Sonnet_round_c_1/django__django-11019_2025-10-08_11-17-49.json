{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/forms/widgets.py lines 72-77)": "\n    @property\n    def _js(self):\n        if not self._js_lists:\n            return []\n        if len(self._js_lists) == 1:\n            return self._js_lists[0]\n        \n        # Collect all non-empty JS lists for simultaneous merging\n        js_lists = [js_list for js_list in self._js_lists if js_list]\n        if not js_lists:\n            return []\n        if len(js_lists) == 1:\n            return js_lists[0]\n        \n        # Perform multi-way merge to avoid artificial ordering constraints\n        return self._merge_multiple_js_lists(js_lists)\n",
    "Location 2 (/root/hy/projects_1/django/django/forms/widgets.py lines 141-146)": "\n            if index > last_insert_index:\n                # Check if this is a real conflict by verifying if the elements\n                # have a meaningful dependency relationship in the original lists\n                elem_at_insert = combined_list[last_insert_index]\n                elem_at_index = combined_list[index]\n                \n                # Only warn if both elements appeared in the same original list\n                # in opposite order, indicating a real dependency conflict\n                real_conflict = False\n                for original_list in [list_1, list_2]:\n                    try:\n                        orig_insert_idx = original_list.index(elem_at_insert)\n                        orig_index_idx = original_list.index(elem_at_index)\n                        if orig_insert_idx > orig_index_idx:\n                            real_conflict = True\n                            break\n                    except ValueError:\n                        # One or both elements not in this original list\n                        continue\n                \n                if real_conflict:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (elem_at_insert, elem_at_index),\n                        MediaOrderConflictWarning,\n                    )\n",
    "Location 3 (/root/hy/projects_1/django/django/forms/widgets.py lines 118-150)": "\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge multiple lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not lists:\n            return []\n        if len(lists) == 1:\n            return list(lists[0])\n        \n        # Build a dependency graph from all lists\n        dependencies = {}  # item -> set of items that must come before it\n        all_items = set()\n        \n        for lst in lists:\n            items = list(lst)\n            all_items.update(items)\n            for i, item in enumerate(items):\n                if item not in dependencies:\n                    dependencies[item] = set()\n                # Add all previous items as dependencies\n                dependencies[item].update(items[:i])\n        \n        # Check for conflicts: if A depends on B and B depends on A\n        for item in all_items:\n            item_deps = dependencies.get(item, set())\n            for dep in item_deps:\n                dep_deps = dependencies.get(dep, set())\n                if item in dep_deps:\n                    # Found a circular dependency - this is a real conflict\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order: '\n                        '%s and %s have conflicting order requirements' % (item, dep),\n                        MediaOrderConflictWarning,\n                    )\n        \n        # Topological sort to determine final order\n        result = []\n        remaining = dict(dependencies)\n        \n        while remaining:\n            # Find items with no remaining dependencies\n            ready = [item for item, deps in remaining.items() if not deps]\n            \n            if not ready:\n                # Circular dependency - just pick one and continue\n                ready = [next(iter(remaining.keys()))]\n            \n            # Sort ready items to ensure deterministic output\n            ready.sort()\n            \n            for item in ready:\n                result.append(item)\n                del remaining[item]\n                \n                # Remove this item from other items' dependencies\n                for deps in remaining.values():\n                    deps.discard(item)\n        \n        return result\n",
    "Location 4 (/root/hy/projects_1/django/django/forms/widgets.py lines 152-156)": "\n    def __add__(self, other):\n        combined = Media()\n        # Store the original lists to help merge method make better decisions\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        # Add metadata to track merge context for better conflict detection\n        combined._merge_context = getattr(self, '_merge_context', []) + getattr(other, '_merge_context', [])\n        if not hasattr(combined, '_merge_context'):\n            combined._merge_context = []\n        return combined\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/forms/widgets.py lines 72-77)": [
      "\n    @property\n    def _js(self):\n        if len(self._js_lists) <= 1:\n            return self._js_lists[0] if self._js_lists else []\n        \n        # Collect all non-empty JS lists\n        js_lists = [js_list for js_list in self._js_lists if js_list]\n        if not js_lists:\n            return []\n        if len(js_lists) == 1:\n            return js_lists[0]\n        \n        # Multi-way merge to avoid artificial ordering constraints\n        return self._multi_merge(js_lists)\n",
      "\n    @property\n    def _js(self):\n        if len(self._js_lists) <= 1:\n            return self._js_lists[0] if self._js_lists else []\n        \n        # Collect all non-empty JS lists\n        js_lists = [js_list for js_list in self._js_lists if js_list]\n        \n        if not js_lists:\n            return []\n        \n        if len(js_lists) == 1:\n            return js_lists[0]\n        \n        # Multi-way merge to avoid artificial ordering constraints\n        return self._multi_merge(js_lists)\n",
      "\n    @property\n    def _js(self):\n        if len(self._js_lists) <= 1:\n            return self._js_lists[0] if self._js_lists else []\n        \n        # Collect all non-empty JS lists\n        js_lists = [js_list for js_list in self._js_lists if js_list]\n        \n        if not js_lists:\n            return []\n        if len(js_lists) == 1:\n            return js_lists[0]\n        \n        # Multi-way merge to avoid artificial ordering constraints\n        return self._merge_multiple(js_lists)\n",
      "\n    @property\n    def _js(self):\n        if len(self._js_lists) == 1:\n            return self._js_lists[0]\n        \n        # Collect all non-empty JS lists\n        js_lists = [js for js in self._js_lists if js]\n        if not js_lists:\n            return []\n        if len(js_lists) == 1:\n            return js_lists[0]\n        \n        # Multi-way merge to avoid artificial ordering constraints\n        return self._merge_multiple(js_lists)\n",
      "\n    @property\n    def _js(self):\n        # Collect all non-empty JS lists\n        js_lists = [js_list for js_list in self._js_lists if js_list]\n        \n        if not js_lists:\n            return []\n        elif len(js_lists) == 1:\n            return js_lists[0]\n        else:\n            # Merge all lists simultaneously to avoid artificial ordering constraints\n            return self.merge_multiple(js_lists)\n",
      "\n    @property\n    def _js(self):\n        if len(self._js_lists) <= 1:\n            return self._js_lists[0] if self._js_lists else []\n        \n        # Collect all non-empty JS lists\n        js_lists = [js_list for js_list in self._js_lists if js_list]\n        \n        if not js_lists:\n            return []\n        elif len(js_lists) == 1:\n            return js_lists[0]\n        \n        # Multi-way merge to avoid artificial ordering constraints\n        return self._merge_multiple(js_lists)\n",
      "\n    @property\n    def _js(self):\n        if not self._js_lists:\n            return []\n        if len(self._js_lists) == 1:\n            return self._js_lists[0]\n        \n        # Collect all non-empty JS lists\n        non_empty_lists = [js_list for js_list in self._js_lists if js_list]\n        if not non_empty_lists:\n            return []\n        if len(non_empty_lists) == 1:\n            return non_empty_lists[0]\n        \n        # Multi-way merge to avoid artificial ordering constraints\n        return self._multi_way_merge(non_empty_lists)\n",
      "\n    @property\n    def _js(self):\n        if len(self._js_lists) <= 1:\n            return self._js_lists[0] if self._js_lists else []\n        \n        # Collect all non-empty JS lists\n        js_lists = [js_list for js_list in self._js_lists if js_list]\n        \n        if not js_lists:\n            return []\n        if len(js_lists) == 1:\n            return js_lists[0]\n        \n        # Multi-way merge to avoid artificial ordering constraints\n        return self._merge_multiple(js_lists)\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/forms/widgets.py lines 141-146)": [
      "\n            if index > last_insert_index:\n                # Check if this is a real ordering conflict by verifying if the files\n                # have actual dependency relationships rather than artificial constraints\n                # from sequential merging. Only warn for genuine conflicts.\n                file1 = combined_list[last_insert_index]\n                file2 = combined_list[index]\n                \n                # Skip warning if this appears to be an artificial constraint from\n                # intermediate merging rather than a real dependency conflict\n                if not self._is_artificial_constraint(file1, file2, combined_list):\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (file1, file2),\n                        MediaOrderConflictWarning,\n                    )\n",
      "\n            if index > last_insert_index:\n                # Only warn if this represents a true ordering conflict\n                # Skip warning for artificial constraints from sequential merging\n                path_in_question = combined_list[index]\n                earlier_path = combined_list[last_insert_index]\n                \n                # Check if this might be an artificial constraint by seeing if\n                # the paths were originally from different sources that don't\n                # have inherent ordering requirements\n                should_warn = True\n                \n                # If both paths appear to be unrelated (different prefixes/types),\n                # this might be an artificial constraint from sequential merging\n                if (hasattr(path_in_question, 'split') and hasattr(earlier_path, 'split') and\n                    path_in_question.split('/')[-1] != earlier_path.split('/')[-1]):\n                    # Different files - check if they have common dependency patterns\n                    path_parts = path_in_question.split('/')\n                    earlier_parts = earlier_path.split('/')\n                    if len(path_parts) > 1 and len(earlier_parts) > 1:\n                        # If they're from different top-level directories, likely artificial\n                        if path_parts[0] != earlier_parts[0]:\n                            should_warn = False\n                \n                if should_warn:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (earlier_path, path_in_question),\n                        MediaOrderConflictWarning,\n                    )\n",
      "\n            if index > last_insert_index:\n                # Check if this is a real conflict by verifying if the ordering\n                # constraint was explicitly defined in the original media objects\n                # rather than artificially created by sequential merging\n                is_real_conflict = True\n                \n                # If both files appear in the same original media list in this order,\n                # it's not a real conflict - it's an artifact of sequential merging\n                current_file = combined_list[last_insert_index]\n                duplicate_file = combined_list[index]\n                \n                # This is a simplified heuristic - in a full fix, we'd track\n                # the original source lists to make a more accurate determination\n                if (hasattr(self, '_original_lists') and \n                    any(current_file in lst and duplicate_file in lst and \n                        lst.index(current_file) < lst.index(duplicate_file)\n                        for lst in getattr(self, '_original_lists', []))):\n                    is_real_conflict = False\n                \n                if is_real_conflict:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (current_file, duplicate_file),\n                        MediaOrderConflictWarning,\n                    )\n",
      "\n            if index > last_insert_index:\n                # Check if this is a real conflict by verifying if the files\n                # have a meaningful dependency relationship\n                current_file = combined_list[last_insert_index]\n                existing_file = combined_list[index]\n                \n                # Only warn if the files are different (not just different paths to same file)\n                # and if this appears to be a genuine ordering constraint violation\n                if (current_file != existing_file and \n                    not self._is_same_resource(current_file, existing_file)):\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (current_file, existing_file),\n                        MediaOrderConflictWarning,\n                    )\n",
      "\n            if index > last_insert_index:\n                # Check if this is a real conflict by verifying if the paths\n                # have a meaningful dependency relationship\n                path1 = combined_list[last_insert_index]\n                path2 = combined_list[index]\n                \n                # Only warn if the paths are actually different files\n                # (not just different representations of the same file)\n                if path1 != path2:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (path1, path2),\n                        MediaOrderConflictWarning,\n                    )\n",
      "\n            if index > last_insert_index:\n                # Check if this is a real conflict by verifying if the paths\n                # represent actual dependencies rather than artifacts from\n                # sequential merging\n                path1 = combined_list[last_insert_index]\n                path2 = combined_list[index]\n                \n                # Only warn if the paths are different (real conflict)\n                # Skip warning for identical paths that may appear due to\n                # intermediate merge operations\n                if path1 != path2:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (path1, path2),\n                        MediaOrderConflictWarning,\n                    )\n",
      "\n            if index > last_insert_index:\n                # Check if this is a real conflict by verifying if the paths\n                # have a meaningful ordering relationship in the original lists\n                path_at_insert = combined_list[last_insert_index]\n                path_at_index = combined_list[index]\n                \n                # Only warn if both paths appear in the same original list\n                # and their order contradicts the expected merge order\n                real_conflict = False\n                for original_list in [list_1, list_2]:\n                    try:\n                        insert_pos = original_list.index(path_at_insert)\n                        index_pos = original_list.index(path_at_index)\n                        if insert_pos > index_pos:\n                            real_conflict = True\n                            break\n                    except ValueError:\n                        continue\n                \n                if real_conflict:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (path_at_insert, path_at_index),\n                        MediaOrderConflictWarning,\n                    )\n",
      "\n            if index > last_insert_index:\n                # Check if this is a real conflict by verifying if the elements\n                # have a meaningful dependency relationship\n                current_path = combined_list[last_insert_index]\n                existing_path = combined_list[index]\n                \n                # Only warn if the paths are different (not just positional artifacts)\n                # and if this represents a true ordering constraint violation\n                if current_path != existing_path:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (current_path, existing_path),\n                        MediaOrderConflictWarning,\n                    )\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/forms/widgets.py lines 118-150)": [
      "\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge multiple lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not lists:\n            return []\n        if len(lists) == 1:\n            return list(lists[0])\n        \n        # For backward compatibility, handle the two-argument case\n        if len(lists) == 2:\n            return Media._merge_two(lists[0], lists[1])\n        \n        # Multi-way merge: collect all unique elements while preserving order\n        seen = set()\n        result = []\n        \n        # Build a dependency graph based on relative positions in input lists\n        dependencies = {}  # element -> set of elements that must come before it\n        \n        for lst in lists:\n            lst = list(lst)  # Convert to list if needed\n            for i, item in enumerate(lst):\n                if item not in dependencies:\n                    dependencies[item] = set()\n                # Add all previous items in this list as dependencies\n                for j in range(i):\n                    dependencies[item].add(lst[j])\n        \n        # Check for conflicts: if A depends on B and B depends on A\n        for item, deps in dependencies.items():\n            for dep in deps:\n                if item in dependencies.get(dep, set()):\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order: '\n                        f'{dep} vs {item}',\n                        MediaOrderConflictWarning,\n                    )\n        \n        # Topological sort to resolve dependencies\n        remaining = set(dependencies.keys())\n        \n        while remaining:\n            # Find items with no remaining dependencies\n            ready = []\n            for item in remaining:\n                if not (dependencies[item] & remaining):\n                    ready.append(item)\n            \n            if not ready:\n                # Circular dependency - just pick one\n                ready = [next(iter(remaining))]\n            \n            # Sort ready items to ensure deterministic output\n            ready.sort(key=str)\n            \n            for item in ready:\n                result.append(item)\n                remaining.remove(item)\n        \n        return result\n    \n    @staticmethod\n    def _merge_two(list_1, list_2):\n        \"\"\"\n        Original two-list merge implementation for backward compatibility.\n        \"\"\"\n        # Start with a copy of list_1.\n        combined_list = list(list_1)\n        last_insert_index = len(list_1)\n        # Walk list_2 in reverse, inserting each element into combined_list if\n        # it doesn't already exist.\n        for path in reversed(list_2):\n            try:\n                # Does path already exist in the list?\n                index = combined_list.index(path)\n            except ValueError:\n                # Add path to combined_list since it doesn't exist.\n                combined_list.insert(last_insert_index, path)\n            else:\n                if index > last_insert_index:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n                        MediaOrderConflictWarning,\n                    )\n                # path already exists in the list. Update last_insert_index so\n                # that the following elements are inserted in front of this one.\n                last_insert_index = index\n        return combined_list\n",
      "\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge multiple lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not lists:\n            return []\n        if len(lists) == 1:\n            return list(lists[0])\n        \n        # Build a dependency graph based on relative ordering in each list\n        dependencies = {}  # item -> set of items that must come before it\n        all_items = set()\n        \n        for lst in lists:\n            lst_items = list(lst)\n            all_items.update(lst_items)\n            for i, item in enumerate(lst_items):\n                if item not in dependencies:\n                    dependencies[item] = set()\n                # Add all previous items as dependencies\n                dependencies[item].update(lst_items[:i])\n        \n        # Check for conflicts: if A depends on B and B depends on A\n        for item_a in all_items:\n            for item_b in dependencies[item_a]:\n                if item_a in dependencies[item_b]:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order: '\n                        '%s and %s have conflicting dependencies' % (item_a, item_b),\n                        MediaOrderConflictWarning,\n                    )\n        \n        # Topological sort to resolve dependencies\n        result = []\n        remaining = set(all_items)\n        \n        while remaining:\n            # Find items with no unresolved dependencies\n            ready = []\n            for item in remaining:\n                if not (dependencies[item] & remaining):\n                    ready.append(item)\n            \n            if not ready:\n                # Circular dependency or other issue, fall back to original order\n                # from the first list that contains remaining items\n                for lst in lists:\n                    for item in lst:\n                        if item in remaining:\n                            ready = [item]\n                            break\n                    if ready:\n                        break\n            \n            # Add ready items in the order they first appear across all lists\n            for lst in lists:\n                for item in lst:\n                    if item in ready and item not in result:\n                        result.append(item)\n                        remaining.remove(item)\n                        break\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        # Start with a copy of list_1.\n        combined_list = list(list_1)\n        last_insert_index = len(list_1)\n        # Walk list_2 in reverse, inserting each element into combined_list if\n        # it doesn't already exist.\n        for path in reversed(list_2):\n            try:\n                # Does path already exist in the list?\n                index = combined_list.index(path)\n            except ValueError:\n                # Add path to combined_list since it doesn't exist.\n                combined_list.insert(last_insert_index, path)\n            else:\n                # Only warn if both elements are from the original lists\n                # and they appear in different relative order in both lists\n                if index > last_insert_index:\n                    # Check if this is a real conflict by verifying both elements\n                    # exist in both original lists in opposite order\n                    element_at_insert = combined_list[last_insert_index] if last_insert_index < len(combined_list) else None\n                    if (element_at_insert and \n                        element_at_insert in list_1 and element_at_insert in list_2 and\n                        path in list_1 and path in list_2):\n                        # Check relative order in both lists\n                        list_1_order = (list_1.index(element_at_insert), list_1.index(path))\n                        list_2_order = (list_2.index(element_at_insert), list_2.index(path))\n                        # Only warn if the relative order is actually different\n                        if ((list_1_order[0] < list_1_order[1]) != (list_2_order[0] < list_2_order[1])):\n                            warnings.warn(\n                                'Detected duplicate Media files in an opposite order:\\n'\n                                '%s\\n%s' % (element_at_insert, path),\n                                MediaOrderConflictWarning,\n                            )\n                # path already exists in the list. Update last_insert_index so\n                # that the following elements are inserted in front of this one.\n                last_insert_index = index\n        return combined_list\n",
      "\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge multiple lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not lists:\n            return []\n        if len(lists) == 1:\n            return list(lists[0])\n        \n        # Track original positions of elements in each list\n        element_positions = {}\n        for list_idx, lst in enumerate(lists):\n            for pos, element in enumerate(lst):\n                if element not in element_positions:\n                    element_positions[element] = {}\n                element_positions[element][list_idx] = pos\n        \n        # Start with all unique elements\n        all_elements = []\n        seen = set()\n        for lst in lists:\n            for element in lst:\n                if element not in seen:\n                    all_elements.append(element)\n                    seen.add(element)\n        \n        # Check for real conflicts (same elements in different relative order across input lists)\n        for i, elem1 in enumerate(all_elements):\n            for j, elem2 in enumerate(all_elements):\n                if i >= j:\n                    continue\n                \n                # Check if these elements appear in multiple lists with conflicting order\n                conflict_found = False\n                elem1_positions = element_positions.get(elem1, {})\n                elem2_positions = element_positions.get(elem2, {})\n                \n                # Find lists that contain both elements\n                common_lists = set(elem1_positions.keys()) & set(elem2_positions.keys())\n                if len(common_lists) < 2:\n                    continue\n                \n                # Check if they have consistent ordering across all common lists\n                first_order = None\n                for list_idx in common_lists:\n                    pos1 = elem1_positions[list_idx]\n                    pos2 = elem2_positions[list_idx]\n                    current_order = pos1 < pos2\n                    \n                    if first_order is None:\n                        first_order = current_order\n                    elif first_order != current_order:\n                        conflict_found = True\n                        break\n                \n                if conflict_found:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (elem1, elem2),\n                        MediaOrderConflictWarning,\n                    )\n        \n        # Use topological sort to merge while preserving as much original order as possible\n        result = []\n        remaining = all_elements[:]\n        \n        while remaining:\n            # Find elements that can be placed next (no unplaced dependencies)\n            candidates = []\n            for element in remaining:\n                can_place = True\n                elem_positions = element_positions[element]\n                \n                # Check if any elements that should come before this one are still remaining\n                for other_element in remaining:\n                    if other_element == element:\n                        continue\n                    other_positions = element_positions[other_element]\n                    \n                    # Find lists where both elements appear\n                    common_lists = set(elem_positions.keys()) & set(other_positions.keys())\n                    for list_idx in common_lists:\n                        if other_positions[list_idx] < elem_positions[list_idx]:\n                            can_place = False\n                            break\n                    if not can_place:\n                        break\n                \n                if can_place:\n                    candidates.append(element)\n            \n            # If no candidates found, pick the first remaining (shouldn't happen with valid input)\n            if not candidates:\n                candidates = [remaining[0]]\n            \n            # Among candidates, prefer the one that appears earliest in the first list\n            best_candidate = min(candidates, key=lambda x: min(element_positions[x].values()))\n            result.append(best_candidate)\n            remaining.remove(best_candidate)\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge multiple lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not lists:\n            return []\n        if len(lists) == 1:\n            return list(lists[0])\n        \n        # Build a graph of ordering constraints from all input lists\n        ordering_constraints = {}\n        all_elements = set()\n        \n        for lst in lists:\n            lst_items = list(lst)\n            all_elements.update(lst_items)\n            for i, item in enumerate(lst_items):\n                if item not in ordering_constraints:\n                    ordering_constraints[item] = set()\n                # Add all items that come after this one as constraints\n                for j in range(i + 1, len(lst_items)):\n                    ordering_constraints[item].add(lst_items[j])\n        \n        # Check for conflicts in ordering constraints\n        for item1 in all_elements:\n            for item2 in ordering_constraints.get(item1, set()):\n                if item1 in ordering_constraints.get(item2, set()):\n                    # We have a conflict: item1 should come before item2 in some lists\n                    # but item2 should come before item1 in others\n                    warnings.warn(\n                        'Detected conflicting Media file order requirements:\\n'\n                        '%s and %s have conflicting order requirements' % (item1, item2),\n                        MediaOrderConflictWarning,\n                    )\n        \n        # Perform topological sort to get final ordering\n        result = []\n        remaining = set(all_elements)\n        \n        while remaining:\n            # Find items with no remaining dependencies\n            ready = []\n            for item in remaining:\n                if not (ordering_constraints.get(item, set()) & remaining):\n                    ready.append(item)\n            \n            if not ready:\n                # Circular dependency - just pick the first remaining item\n                ready = [next(iter(remaining))]\n            \n            # Sort ready items to ensure deterministic output\n            ready.sort()\n            \n            for item in ready:\n                result.append(item)\n                remaining.remove(item)\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge multiple lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not lists:\n            return []\n        if len(lists) == 1:\n            return list(lists[0])\n        \n        # Collect all unique elements while preserving order from each list\n        seen = set()\n        result = []\n        \n        # Track original positions of elements across all lists for conflict detection\n        element_positions = {}\n        for list_idx, lst in enumerate(lists):\n            for pos, element in enumerate(lst):\n                if element not in element_positions:\n                    element_positions[element] = {}\n                element_positions[element][list_idx] = pos\n        \n        # Build result by processing all lists simultaneously\n        remaining_lists = [list(lst) for lst in lists]\n        \n        while any(remaining_lists):\n            # Find the next element that can be safely added\n            candidates = []\n            for list_idx, lst in enumerate(remaining_lists):\n                if lst and lst[0] not in seen:\n                    candidates.append((lst[0], list_idx))\n            \n            if not candidates:\n                # All remaining elements are already in result\n                break\n                \n            # Choose the candidate that appears earliest in the most lists\n            best_element = None\n            best_score = float('inf')\n            \n            for element, source_list in candidates:\n                # Calculate average position across all lists containing this element\n                positions = element_positions[element]\n                avg_position = sum(positions.values()) / len(positions)\n                \n                if avg_position < best_score:\n                    best_score = avg_position\n                    best_element = element\n            \n            # Add the best element and remove it from all lists\n            if best_element and best_element not in seen:\n                result.append(best_element)\n                seen.add(best_element)\n                \n                for lst in remaining_lists:\n                    if lst and lst[0] == best_element:\n                        lst.pop(0)\n        \n        # Check for real ordering conflicts (elements that appear in opposite order in multiple lists)\n        for i in range(len(result)):\n            for j in range(i + 1, len(result)):\n                elem1, elem2 = result[i], result[j]\n                \n                # Check if these elements appear in opposite order in any two source lists\n                conflict_found = False\n                for list1_idx in element_positions.get(elem1, {}):\n                    for list2_idx in element_positions.get(elem2, {}):\n                        if list1_idx != list2_idx:\n                            pos1_in_list1 = element_positions[elem1].get(list1_idx)\n                            pos2_in_list1 = element_positions[elem2].get(list1_idx)\n                            pos1_in_list2 = element_positions[elem1].get(list2_idx)\n                            pos2_in_list2 = element_positions[elem2].get(list2_idx)\n                            \n                            if (pos1_in_list1 is not None and pos2_in_list1 is not None and\n                                pos1_in_list2 is not None and pos2_in_list2 is not None):\n                                # Both elements exist in both lists\n                                order1 = pos1_in_list1 < pos2_in_list1\n                                order2 = pos1_in_list2 < pos2_in_list2\n                                if order1 != order2:\n                                    conflict_found = True\n                                    break\n                    if conflict_found:\n                        break\n                \n                if conflict_found:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (elem1, elem2),\n                        MediaOrderConflictWarning,\n                    )\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        # Start with a copy of list_1.\n        combined_list = list(list_1)\n        last_insert_index = len(list_1)\n        # Walk list_2 in reverse, inserting each element into combined_list if\n        # it doesn't already exist.\n        for path in reversed(list_2):\n            try:\n                # Does path already exist in the list?\n                index = combined_list.index(path)\n            except ValueError:\n                # Add path to combined_list since it doesn't exist.\n                combined_list.insert(last_insert_index, path)\n            else:\n                # Only warn if both elements exist in both original lists\n                # and have opposite relative order\n                if (index > last_insert_index and \n                    path in list_1 and combined_list[last_insert_index] in list_2):\n                    # Check if the relative order is actually different in the original lists\n                    try:\n                        index_in_list1 = list_1.index(path)\n                        other_index_in_list1 = list_1.index(combined_list[last_insert_index])\n                        index_in_list2 = list_2.index(path)\n                        other_index_in_list2 = list_2.index(combined_list[last_insert_index])\n                        \n                        # Only warn if the relative order is actually opposite in both lists\n                        if ((index_in_list1 < other_index_in_list1) != \n                            (index_in_list2 < other_index_in_list2)):\n                            warnings.warn(\n                                'Detected duplicate Media files in an opposite order:\\n'\n                                '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n                                MediaOrderConflictWarning,\n                            )\n                    except ValueError:\n                        # One of the elements doesn't exist in one of the lists\n                        pass\n                # path already exists in the list. Update last_insert_index so\n                # that the following elements are inserted in front of this one.\n                last_insert_index = index\n        return combined_list\n",
      "\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge multiple lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not lists:\n            return []\n        if len(lists) == 1:\n            return list(lists[0])\n        \n        # Collect all unique elements while preserving original order within each list\n        all_elements = []\n        element_to_lists = {}  # Track which lists contain each element\n        \n        for list_idx, lst in enumerate(lists):\n            for element in lst:\n                if element not in element_to_lists:\n                    all_elements.append(element)\n                    element_to_lists[element] = []\n                element_to_lists[element].append(list_idx)\n        \n        # Build the final ordering using topological sort approach\n        result = []\n        remaining = set(all_elements)\n        \n        while remaining:\n            # Find elements that can be placed next (no unplaced dependencies)\n            candidates = []\n            for element in remaining:\n                can_place = True\n                # Check if this element should come after any remaining elements\n                for other in remaining:\n                    if other != element and Media._should_come_before(other, element, lists, element_to_lists):\n                        can_place = False\n                        break\n                if can_place:\n                    candidates.append(element)\n            \n            if not candidates:\n                # No clear ordering - just pick the first remaining element\n                candidates = [next(iter(remaining))]\n            \n            # Choose the candidate that appears earliest in the original lists\n            best_candidate = min(candidates, key=lambda x: min(\n                next(i for i, elem in enumerate(lst) if elem == x)\n                for lst in lists if x in lst\n            ))\n            \n            result.append(best_candidate)\n            remaining.remove(best_candidate)\n        \n        return result\n    \n    @staticmethod\n    def _should_come_before(elem1, elem2, lists, element_to_lists):\n        \"\"\"Check if elem1 should come before elem2 based on original list orders.\"\"\"\n        # Only check lists that contain both elements\n        common_lists = set(element_to_lists[elem1]) & set(element_to_lists[elem2])\n        \n        elem1_before_elem2 = 0\n        elem2_before_elem1 = 0\n        \n        for list_idx in common_lists:\n            lst = lists[list_idx]\n            idx1 = lst.index(elem1)\n            idx2 = lst.index(elem2)\n            \n            if idx1 < idx2:\n                elem1_before_elem2 += 1\n            else:\n                elem2_before_elem1 += 1\n        \n        # Only warn if there's a real conflict (different orders in different lists)\n        if elem1_before_elem2 > 0 and elem2_before_elem1 > 0:\n            warnings.warn(\n                'Detected duplicate Media files in an opposite order:\\n'\n                '%s\\n%s' % (elem1, elem2),\n                MediaOrderConflictWarning,\n            )\n        \n        return elem1_before_elem2 > elem2_before_elem1\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/forms/widgets.py lines 152-156)": [
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original media sources to help merge algorithm make better decisions\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        # Add metadata to track merge context and avoid false conflict warnings\n        combined._merge_context = getattr(self, '_merge_context', []) + getattr(other, '_merge_context', [])\n        if not hasattr(combined, '_merge_context'):\n            combined._merge_context = [id(self), id(other)]\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original lists to help merge algorithm distinguish real vs artificial constraints\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store all CSS and JS lists to enable better multi-way merging\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original lists to help merge logic distinguish real vs artificial constraints\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store all CSS and JS lists to enable batch processing\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        # Add flag to indicate this is a combined media object\n        combined._is_combined = True\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original lists to help merge algorithm make better decisions\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store all CSS and JS lists separately to enable better merging\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original lists to help merge algorithm make better decisions\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..ad7865f618 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,12 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Use multi-way merge to avoid creating artificial constraints\n+        return self.merge_all([obj for obj in self._js_lists if obj])\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +113,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,30 +126,90 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n-                    warnings.warn(\n-                        'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n-                        MediaOrderConflictWarning,\n-                    )\n-                # path already exists in the list. Update last_insert_index so\n+        return Media.merge_all([list_1, list_2])\n+\n+    @staticmethod\n+    def merge_all(lists):\n+        \"\"\"\n+        Merge multiple lists while preserving relative order within each list.\n+        Only warn about conflicts when there are actual ordering contradictions\n+        between the same elements across different lists.\n+        \n+        This avoids false warnings caused by sequential merging creating\n+        artificial constraints between unrelated elements.\n+        \"\"\"\n+        if not lists:\n+            return []\n+        \n+        # Filter out empty lists\n+        lists = [lst for lst in lists if lst]\n+        if not lists:\n+            return []\n+        \n+        if len(lists) == 1:\n+            return list(lists[0])\n+        \n+        # Build a graph of dependencies from all lists\n+        dependencies = {}  # element -> set of elements that must come before it\n+        all_elements = set()\n+        \n+        for lst in lists:\n+            all_elements.update(lst)\n+            for i, element in enumerate(lst):\n+                if element not in dependencies:\n+                    dependencies[element] = set()\n+                # Add all previous elements in this list as dependencies\n+                dependencies[element].update(lst[:i])\n+        \n+        # Check for conflicts: if A depends on B and B depends on A\n+        conflicts = []\n+        for element in all_elements:\n+            element_deps = dependencies.get(element, set())\n+            for dep in element_deps:\n+                if element in dependencies.get(dep, set()):\n+                    conflict_pair = tuple(sorted([element, dep]))\n+                    if conflict_pair not in conflicts:\n+                        conflicts.append(conflict_pair)\n+        \n+        # Warn about real conflicts only\n+        for conflict in conflicts:\n+            warnings.warn(\n+                'Detected duplicate Media files in an opposite order:\\n'\n+                '%s\\n%s' % conflict,\n+                MediaOrderConflictWarning,\n+            )\n+        \n+        # Perform topological sort to get final order\n+        result = []\n+        remaining = set(all_elements)\n+        \n+        while remaining:\n+            # Find elements with no remaining dependencies\n+            ready = []\n+            for element in remaining:\n+                element_deps = dependencies.get(element, set())\n+                if not (element_deps & remaining):  # No unresolved dependencies\n+                    ready.append(element)\n+            \n+            if not ready:\n+                # Circular dependency - break it by picking any remaining element\n+                # This handles the conflict cases we warned about above\n+                ready = [next(iter(remaining))]\n+            \n+            # Sort ready elements to ensure deterministic output\n+            ready.sort()\n+            \n+            # Add the first ready element to result\n+            element = ready[0]\n+            result.append(element)\n+            remaining.remove(element)\n+        \n+        return result\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n         combined._css_lists = self._css_lists + other._css_lists\n",
    "variant_0": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..ccd23fe6a8 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,24 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        if not self._js_lists:\n+            return []\n+        if len(self._js_lists) == 1:\n+            return self._js_lists[0]\n+        \n+        # Collect all non-empty JS lists for simultaneous merging\n+        js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not js_lists:\n+            return []\n+        if len(js_lists) == 1:\n+            return js_lists[0]\n+        \n+        # Perform multi-way merge to avoid artificial ordering constraints\n+        return self._merge_multiple_js_lists(js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -115,9 +126,11 @@ class Media:\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n     @staticmethod\n-    def merge(list_1, list_2):\n+\n+    @staticmethod\n+    def merge(*lists):\n         \"\"\"\n-        Merge two lists while trying to keep the relative order of the elements.\n+        Merge multiple lists while trying to keep the relative order of the elements.\n         Warn if the lists have the same two elements in a different relative\n         order.\n \n@@ -125,23 +138,76 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not lists:\n+            return []\n+        if len(lists) == 1:\n+            return list(lists[0])\n+        \n+        # Build a dependency graph from all lists\n+        dependencies = {}  # item -> set of items that must come before it\n+        all_items = set()\n+        \n+        for lst in lists:\n+            items = list(lst)\n+            all_items.update(items)\n+            for i, item in enumerate(items):\n+                if item not in dependencies:\n+                    dependencies[item] = set()\n+                # Add all previous items as dependencies\n+                dependencies[item].update(items[:i])\n+        \n+        # Check for conflicts: if A depends on B and B depends on A\n+        for item in all_items:\n+            item_deps = dependencies.get(item, set())\n+            for dep in item_deps:\n+                dep_deps = dependencies.get(dep, set())\n+                if item in dep_deps:\n+                    # Found a circular dependency - this is a real conflict\n+                    warnings.warn(\n+                        'Detected duplicate Media files in an opposite order: '\n+                        '%s and %s have conflicting order requirements' % (item, dep),\n+                        MediaOrderConflictWarning,\n+                    )\n+        \n+        # Topological sort to determine final order\n+        result = []\n+        remaining = dict(dependencies)\n+        \n+        while remaining:\n+            # Find items with no remaining dependencies\n+            ready = [item for item, deps in remaining.items() if not deps]\n+            \n+            if not ready:\n+                # Circular dependency - just pick one and continue\n+                ready = [next(iter(remaining.keys()))]\n+            \n+            # Sort ready items to ensure deterministic output\n+            ready.sort()\n+            \n+            for item in ready:\n+                result.append(item)\n+                del remaining[item]\n+                \n+                # Remove this item from other items' dependencies\n+                for deps in remaining.values():\n+                    deps.discard(item)\n+        \n+        return result\n+                for original_list in [list_1, list_2]:\n+                    try:\n+                        orig_insert_idx = original_list.index(elem_at_insert)\n+                        orig_index_idx = original_list.index(elem_at_index)\n+                        if orig_insert_idx > orig_index_idx:\n+                            real_conflict = True\n+                            break\n+                    except ValueError:\n+                        # One or both elements not in this original list\n+                        continue\n+                \n+                if real_conflict:\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (elem_at_insert, elem_at_index),\n                         MediaOrderConflictWarning,\n                     )\n                 # path already exists in the list. Update last_insert_index so\n@@ -149,10 +215,16 @@ class Media:\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store the original lists to help merge method make better decisions\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n+        # Add metadata to track merge context for better conflict detection\n+        combined._merge_context = getattr(self, '_merge_context', []) + getattr(other, '_merge_context', [])\n+        if not hasattr(combined, '_merge_context'):\n+            combined._merge_context = []\n         return combined\n \n \n",
    "variant_1": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..3fb5c3e982 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,22 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        if len(self._js_lists) <= 1:\n+            return self._js_lists[0] if self._js_lists else []\n+        \n+        # Collect all non-empty JS lists\n+        js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not js_lists:\n+            return []\n+        if len(js_lists) == 1:\n+            return js_lists[0]\n+        \n+        # Multi-way merge to avoid artificial ordering constraints\n+        return self._multi_merge(js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -115,9 +124,11 @@ class Media:\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n     @staticmethod\n-    def merge(list_1, list_2):\n+\n+    @staticmethod\n+    def merge(*lists):\n         \"\"\"\n-        Merge two lists while trying to keep the relative order of the elements.\n+        Merge multiple lists while trying to keep the relative order of the elements.\n         Warn if the lists have the same two elements in a different relative\n         order.\n \n@@ -125,6 +136,69 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n+        if not lists:\n+            return []\n+        if len(lists) == 1:\n+            return list(lists[0])\n+        \n+        # For backward compatibility, handle the two-argument case\n+        if len(lists) == 2:\n+            return Media._merge_two(lists[0], lists[1])\n+        \n+        # Multi-way merge: collect all unique elements while preserving order\n+        seen = set()\n+        result = []\n+        \n+        # Build a dependency graph based on relative positions in input lists\n+        dependencies = {}  # element -> set of elements that must come before it\n+        \n+        for lst in lists:\n+            lst = list(lst)  # Convert to list if needed\n+            for i, item in enumerate(lst):\n+                if item not in dependencies:\n+                    dependencies[item] = set()\n+                # Add all previous items in this list as dependencies\n+                for j in range(i):\n+                    dependencies[item].add(lst[j])\n+        \n+        # Check for conflicts: if A depends on B and B depends on A\n+        for item, deps in dependencies.items():\n+            for dep in deps:\n+                if item in dependencies.get(dep, set()):\n+                    warnings.warn(\n+                        'Detected duplicate Media files in an opposite order: '\n+                        f'{dep} vs {item}',\n+                        MediaOrderConflictWarning,\n+                    )\n+        \n+        # Topological sort to resolve dependencies\n+        remaining = set(dependencies.keys())\n+        \n+        while remaining:\n+            # Find items with no remaining dependencies\n+            ready = []\n+            for item in remaining:\n+                if not (dependencies[item] & remaining):\n+                    ready.append(item)\n+            \n+            if not ready:\n+                # Circular dependency - just pick one\n+                ready = [next(iter(remaining))]\n+            \n+            # Sort ready items to ensure deterministic output\n+            ready.sort(key=str)\n+            \n+            for item in ready:\n+                result.append(item)\n+                remaining.remove(item)\n+        \n+        return result\n+    \n+    @staticmethod\n+    def _merge_two(list_1, list_2):\n+        \"\"\"\n+        Original two-list merge implementation for backward compatibility.\n+        \"\"\"\n         # Start with a copy of list_1.\n         combined_list = list(list_1)\n         last_insert_index = len(list_1)\n@@ -148,11 +222,27 @@ class Media:\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n+                if not self._is_artificial_constraint(file1, file2, combined_list):\n+                    warnings.warn(\n+                        'Detected duplicate Media files in an opposite order:\\n'\n+                        '%s\\n%s' % (file1, file2),\n+                        MediaOrderConflictWarning,\n+                    )\n+                # path already exists in the list. Update last_insert_index so\n+                # that the following elements are inserted in front of this one.\n+                last_insert_index = index\n+        return combined_list\n+\n \n     def __add__(self, other):\n         combined = Media()\n+        # Store original media sources to help merge algorithm make better decisions\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n+        # Add metadata to track merge context and avoid false conflict warnings\n+        combined._merge_context = getattr(self, '_merge_context', []) + getattr(other, '_merge_context', [])\n+        if not hasattr(combined, '_merge_context'):\n+            combined._merge_context = [id(self), id(other)]\n         return combined\n \n \n",
    "variant_2": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..63eb3ad7b4 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,24 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        if len(self._js_lists) <= 1:\n+            return self._js_lists[0] if self._js_lists else []\n+        \n+        # Collect all non-empty JS lists\n+        js_lists = [js_list for js_list in self._js_lists if js_list]\n+        \n+        if not js_lists:\n+            return []\n+        \n+        if len(js_lists) == 1:\n+            return js_lists[0]\n+        \n+        # Multi-way merge to avoid artificial ordering constraints\n+        return self._multi_merge(js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -115,9 +126,11 @@ class Media:\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n     @staticmethod\n-    def merge(list_1, list_2):\n+\n+    @staticmethod\n+    def merge(*lists):\n         \"\"\"\n-        Merge two lists while trying to keep the relative order of the elements.\n+        Merge multiple lists while trying to keep the relative order of the elements.\n         Warn if the lists have the same two elements in a different relative\n         order.\n \n@@ -125,23 +138,83 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not lists:\n+            return []\n+        if len(lists) == 1:\n+            return list(lists[0])\n+        \n+        # Build a dependency graph based on relative ordering in each list\n+        dependencies = {}  # item -> set of items that must come before it\n+        all_items = set()\n+        \n+        for lst in lists:\n+            lst_items = list(lst)\n+            all_items.update(lst_items)\n+            for i, item in enumerate(lst_items):\n+                if item not in dependencies:\n+                    dependencies[item] = set()\n+                # Add all previous items as dependencies\n+                dependencies[item].update(lst_items[:i])\n+        \n+        # Check for conflicts: if A depends on B and B depends on A\n+        for item_a in all_items:\n+            for item_b in dependencies[item_a]:\n+                if item_a in dependencies[item_b]:\n+                    warnings.warn(\n+                        'Detected duplicate Media files in an opposite order: '\n+                        '%s and %s have conflicting dependencies' % (item_a, item_b),\n+                        MediaOrderConflictWarning,\n+                    )\n+        \n+        # Topological sort to resolve dependencies\n+        result = []\n+        remaining = set(all_items)\n+        \n+        while remaining:\n+            # Find items with no unresolved dependencies\n+            ready = []\n+            for item in remaining:\n+                if not (dependencies[item] & remaining):\n+                    ready.append(item)\n+            \n+            if not ready:\n+                # Circular dependency or other issue, fall back to original order\n+                # from the first list that contains remaining items\n+                for lst in lists:\n+                    for item in lst:\n+                        if item in remaining:\n+                            ready = [item]\n+                            break\n+                    if ready:\n+                        break\n+            \n+            # Add ready items in the order they first appear across all lists\n+            for lst in lists:\n+                for item in lst:\n+                    if item in ready and item not in result:\n+                        result.append(item)\n+                        remaining.remove(item)\n+                        break\n+        \n+        return result\n+                should_warn = True\n+                \n+                # If both paths appear to be unrelated (different prefixes/types),\n+                # this might be an artificial constraint from sequential merging\n+                if (hasattr(path_in_question, 'split') and hasattr(earlier_path, 'split') and\n+                    path_in_question.split('/')[-1] != earlier_path.split('/')[-1]):\n+                    # Different files - check if they have common dependency patterns\n+                    path_parts = path_in_question.split('/')\n+                    earlier_parts = earlier_path.split('/')\n+                    if len(path_parts) > 1 and len(earlier_parts) > 1:\n+                        # If they're from different top-level directories, likely artificial\n+                        if path_parts[0] != earlier_parts[0]:\n+                            should_warn = False\n+                \n+                if should_warn:\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (earlier_path, path_in_question),\n                         MediaOrderConflictWarning,\n                     )\n                 # path already exists in the list. Update last_insert_index so\n@@ -149,8 +222,10 @@ class Media:\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store original lists to help merge algorithm distinguish real vs artificial constraints\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n",
    "variant_3": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..bd418e514b 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,23 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        if len(self._js_lists) <= 1:\n+            return self._js_lists[0] if self._js_lists else []\n+        \n+        # Collect all non-empty JS lists\n+        js_lists = [js_list for js_list in self._js_lists if js_list]\n+        \n+        if not js_lists:\n+            return []\n+        if len(js_lists) == 1:\n+            return js_lists[0]\n+        \n+        # Multi-way merge to avoid artificial ordering constraints\n+        return self._merge_multiple(js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +124,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -138,10 +150,43 @@ class Media:\n                 # Add path to combined_list since it doesn't exist.\n                 combined_list.insert(last_insert_index, path)\n             else:\n+                # Only warn if both elements are from the original lists\n+                # and they appear in different relative order in both lists\n                 if index > last_insert_index:\n+                    # Check if this is a real conflict by verifying both elements\n+                    # exist in both original lists in opposite order\n+                    element_at_insert = combined_list[last_insert_index] if last_insert_index < len(combined_list) else None\n+                    if (element_at_insert and \n+                        element_at_insert in list_1 and element_at_insert in list_2 and\n+                        path in list_1 and path in list_2):\n+                        # Check relative order in both lists\n+                        list_1_order = (list_1.index(element_at_insert), list_1.index(path))\n+                        list_2_order = (list_2.index(element_at_insert), list_2.index(path))\n+                        # Only warn if the relative order is actually different\n+                        if ((list_1_order[0] < list_1_order[1]) != (list_2_order[0] < list_2_order[1])):\n+                            warnings.warn(\n+                                'Detected duplicate Media files in an opposite order:\\n'\n+                                '%s\\n%s' % (element_at_insert, path),\n+                                MediaOrderConflictWarning,\n+                            )\n+                # path already exists in the list. Update last_insert_index so\n+                # that the following elements are inserted in front of this one.\n+                last_insert_index = index\n+        return combined_list\n+                duplicate_file = combined_list[index]\n+                \n+                # This is a simplified heuristic - in a full fix, we'd track\n+                # the original source lists to make a more accurate determination\n+                if (hasattr(self, '_original_lists') and \n+                    any(current_file in lst and duplicate_file in lst and \n+                        lst.index(current_file) < lst.index(duplicate_file)\n+                        for lst in getattr(self, '_original_lists', []))):\n+                    is_real_conflict = False\n+                \n+                if is_real_conflict:\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (current_file, duplicate_file),\n                         MediaOrderConflictWarning,\n                     )\n                 # path already exists in the list. Update last_insert_index so\n@@ -149,8 +194,10 @@ class Media:\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store all CSS and JS lists to enable better multi-way merging\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n",
    "variant_4": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..7a67b3606a 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,22 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        if len(self._js_lists) == 1:\n+            return self._js_lists[0]\n+        \n+        # Collect all non-empty JS lists\n+        js_lists = [js for js in self._js_lists if js]\n+        if not js_lists:\n+            return []\n+        if len(js_lists) == 1:\n+            return js_lists[0]\n+        \n+        # Multi-way merge to avoid artificial ordering constraints\n+        return self._merge_multiple(js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -115,9 +124,11 @@ class Media:\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n     @staticmethod\n-    def merge(list_1, list_2):\n+\n+    @staticmethod\n+    def merge(*lists):\n         \"\"\"\n-        Merge two lists while trying to keep the relative order of the elements.\n+        Merge multiple lists while trying to keep the relative order of the elements.\n         Warn if the lists have the same two elements in a different relative\n         order.\n \n@@ -125,23 +136,107 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not lists:\n+            return []\n+        if len(lists) == 1:\n+            return list(lists[0])\n+        \n+        # Track original positions of elements in each list\n+        element_positions = {}\n+        for list_idx, lst in enumerate(lists):\n+            for pos, element in enumerate(lst):\n+                if element not in element_positions:\n+                    element_positions[element] = {}\n+                element_positions[element][list_idx] = pos\n+        \n+        # Start with all unique elements\n+        all_elements = []\n+        seen = set()\n+        for lst in lists:\n+            for element in lst:\n+                if element not in seen:\n+                    all_elements.append(element)\n+                    seen.add(element)\n+        \n+        # Check for real conflicts (same elements in different relative order across input lists)\n+        for i, elem1 in enumerate(all_elements):\n+            for j, elem2 in enumerate(all_elements):\n+                if i >= j:\n+                    continue\n+                \n+                # Check if these elements appear in multiple lists with conflicting order\n+                conflict_found = False\n+                elem1_positions = element_positions.get(elem1, {})\n+                elem2_positions = element_positions.get(elem2, {})\n+                \n+                # Find lists that contain both elements\n+                common_lists = set(elem1_positions.keys()) & set(elem2_positions.keys())\n+                if len(common_lists) < 2:\n+                    continue\n+                \n+                # Check if they have consistent ordering across all common lists\n+                first_order = None\n+                for list_idx in common_lists:\n+                    pos1 = elem1_positions[list_idx]\n+                    pos2 = elem2_positions[list_idx]\n+                    current_order = pos1 < pos2\n+                    \n+                    if first_order is None:\n+                        first_order = current_order\n+                    elif first_order != current_order:\n+                        conflict_found = True\n+                        break\n+                \n+                if conflict_found:\n+                    warnings.warn(\n+                        'Detected duplicate Media files in an opposite order:\\n'\n+                        '%s\\n%s' % (elem1, elem2),\n+                        MediaOrderConflictWarning,\n+                    )\n+        \n+        # Use topological sort to merge while preserving as much original order as possible\n+        result = []\n+        remaining = all_elements[:]\n+        \n+        while remaining:\n+            # Find elements that can be placed next (no unplaced dependencies)\n+            candidates = []\n+            for element in remaining:\n+                can_place = True\n+                elem_positions = element_positions[element]\n+                \n+                # Check if any elements that should come before this one are still remaining\n+                for other_element in remaining:\n+                    if other_element == element:\n+                        continue\n+                    other_positions = element_positions[other_element]\n+                    \n+                    # Find lists where both elements appear\n+                    common_lists = set(elem_positions.keys()) & set(other_positions.keys())\n+                    for list_idx in common_lists:\n+                        if other_positions[list_idx] < elem_positions[list_idx]:\n+                            can_place = False\n+                            break\n+                    if not can_place:\n+                        break\n+                \n+                if can_place:\n+                    candidates.append(element)\n+            \n+            # If no candidates found, pick the first remaining (shouldn't happen with valid input)\n+            if not candidates:\n+                candidates = [remaining[0]]\n+            \n+            # Among candidates, prefer the one that appears earliest in the first list\n+            best_candidate = min(candidates, key=lambda x: min(element_positions[x].values()))\n+            result.append(best_candidate)\n+            remaining.remove(best_candidate)\n+        \n+        return result\n+                    not self._is_same_resource(current_file, existing_file)):\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (current_file, existing_file),\n                         MediaOrderConflictWarning,\n                     )\n                 # path already exists in the list. Update last_insert_index so\n@@ -149,8 +244,10 @@ class Media:\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store original lists to help merge logic distinguish real vs artificial constraints\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n",
    "variant_5": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..51bc1b2179 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,20 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all non-empty JS lists\n+        js_lists = [js_list for js_list in self._js_lists if js_list]\n+        \n+        if not js_lists:\n+            return []\n+        elif len(js_lists) == 1:\n+            return js_lists[0]\n+        else:\n+            # Merge all lists simultaneously to avoid artificial ordering constraints\n+            return self.merge_multiple(js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -115,9 +122,11 @@ class Media:\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n     @staticmethod\n-    def merge(list_1, list_2):\n+\n+    @staticmethod\n+    def merge(*lists):\n         \"\"\"\n-        Merge two lists while trying to keep the relative order of the elements.\n+        Merge multiple lists while trying to keep the relative order of the elements.\n         Warn if the lists have the same two elements in a different relative\n         order.\n \n@@ -125,23 +134,63 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not lists:\n+            return []\n+        if len(lists) == 1:\n+            return list(lists[0])\n+        \n+        # Build a graph of ordering constraints from all input lists\n+        ordering_constraints = {}\n+        all_elements = set()\n+        \n+        for lst in lists:\n+            lst_items = list(lst)\n+            all_elements.update(lst_items)\n+            for i, item in enumerate(lst_items):\n+                if item not in ordering_constraints:\n+                    ordering_constraints[item] = set()\n+                # Add all items that come after this one as constraints\n+                for j in range(i + 1, len(lst_items)):\n+                    ordering_constraints[item].add(lst_items[j])\n+        \n+        # Check for conflicts in ordering constraints\n+        for item1 in all_elements:\n+            for item2 in ordering_constraints.get(item1, set()):\n+                if item1 in ordering_constraints.get(item2, set()):\n+                    # We have a conflict: item1 should come before item2 in some lists\n+                    # but item2 should come before item1 in others\n+                    warnings.warn(\n+                        'Detected conflicting Media file order requirements:\\n'\n+                        '%s and %s have conflicting order requirements' % (item1, item2),\n+                        MediaOrderConflictWarning,\n+                    )\n+        \n+        # Perform topological sort to get final ordering\n+        result = []\n+        remaining = set(all_elements)\n+        \n+        while remaining:\n+            # Find items with no remaining dependencies\n+            ready = []\n+            for item in remaining:\n+                if not (ordering_constraints.get(item, set()) & remaining):\n+                    ready.append(item)\n+            \n+            if not ready:\n+                # Circular dependency - just pick the first remaining item\n+                ready = [next(iter(remaining))]\n+            \n+            # Sort ready items to ensure deterministic output\n+            ready.sort()\n+            \n+            for item in ready:\n+                result.append(item)\n+                remaining.remove(item)\n+        \n+        return result\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (path1, path2),\n                         MediaOrderConflictWarning,\n                     )\n                 # path already exists in the list. Update last_insert_index so\n@@ -149,10 +198,14 @@ class Media:\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store all CSS and JS lists to enable batch processing\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n+        # Add flag to indicate this is a combined media object\n+        combined._is_combined = True\n         return combined\n \n \n",
    "variant_6": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..d059b11794 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,23 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        if len(self._js_lists) <= 1:\n+            return self._js_lists[0] if self._js_lists else []\n+        \n+        # Collect all non-empty JS lists\n+        js_lists = [js_list for js_list in self._js_lists if js_list]\n+        \n+        if not js_lists:\n+            return []\n+        elif len(js_lists) == 1:\n+            return js_lists[0]\n+        \n+        # Multi-way merge to avoid artificial ordering constraints\n+        return self._merge_multiple(js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -115,9 +125,11 @@ class Media:\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n     @staticmethod\n-    def merge(list_1, list_2):\n+\n+    @staticmethod\n+    def merge(*lists):\n         \"\"\"\n-        Merge two lists while trying to keep the relative order of the elements.\n+        Merge multiple lists while trying to keep the relative order of the elements.\n         Warn if the lists have the same two elements in a different relative\n         order.\n \n@@ -125,23 +137,98 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not lists:\n+            return []\n+        if len(lists) == 1:\n+            return list(lists[0])\n+        \n+        # Collect all unique elements while preserving order from each list\n+        seen = set()\n+        result = []\n+        \n+        # Track original positions of elements across all lists for conflict detection\n+        element_positions = {}\n+        for list_idx, lst in enumerate(lists):\n+            for pos, element in enumerate(lst):\n+                if element not in element_positions:\n+                    element_positions[element] = {}\n+                element_positions[element][list_idx] = pos\n+        \n+        # Build result by processing all lists simultaneously\n+        remaining_lists = [list(lst) for lst in lists]\n+        \n+        while any(remaining_lists):\n+            # Find the next element that can be safely added\n+            candidates = []\n+            for list_idx, lst in enumerate(remaining_lists):\n+                if lst and lst[0] not in seen:\n+                    candidates.append((lst[0], list_idx))\n+            \n+            if not candidates:\n+                # All remaining elements are already in result\n+                break\n+                \n+            # Choose the candidate that appears earliest in the most lists\n+            best_element = None\n+            best_score = float('inf')\n+            \n+            for element, source_list in candidates:\n+                # Calculate average position across all lists containing this element\n+                positions = element_positions[element]\n+                avg_position = sum(positions.values()) / len(positions)\n+                \n+                if avg_position < best_score:\n+                    best_score = avg_position\n+                    best_element = element\n+            \n+            # Add the best element and remove it from all lists\n+            if best_element and best_element not in seen:\n+                result.append(best_element)\n+                seen.add(best_element)\n+                \n+                for lst in remaining_lists:\n+                    if lst and lst[0] == best_element:\n+                        lst.pop(0)\n+        \n+        # Check for real ordering conflicts (elements that appear in opposite order in multiple lists)\n+        for i in range(len(result)):\n+            for j in range(i + 1, len(result)):\n+                elem1, elem2 = result[i], result[j]\n+                \n+                # Check if these elements appear in opposite order in any two source lists\n+                conflict_found = False\n+                for list1_idx in element_positions.get(elem1, {}):\n+                    for list2_idx in element_positions.get(elem2, {}):\n+                        if list1_idx != list2_idx:\n+                            pos1_in_list1 = element_positions[elem1].get(list1_idx)\n+                            pos2_in_list1 = element_positions[elem2].get(list1_idx)\n+                            pos1_in_list2 = element_positions[elem1].get(list2_idx)\n+                            pos2_in_list2 = element_positions[elem2].get(list2_idx)\n+                            \n+                            if (pos1_in_list1 is not None and pos2_in_list1 is not None and\n+                                pos1_in_list2 is not None and pos2_in_list2 is not None):\n+                                # Both elements exist in both lists\n+                                order1 = pos1_in_list1 < pos2_in_list1\n+                                order2 = pos1_in_list2 < pos2_in_list2\n+                                if order1 != order2:\n+                                    conflict_found = True\n+                                    break\n+                    if conflict_found:\n+                        break\n+                \n+                if conflict_found:\n+                    warnings.warn(\n+                        'Detected duplicate Media files in an opposite order:\\n'\n+                        '%s\\n%s' % (elem1, elem2),\n+                        MediaOrderConflictWarning,\n+                    )\n+        \n+        return result\n+                # intermediate merge operations\n+                if path1 != path2:\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (path1, path2),\n                         MediaOrderConflictWarning,\n                     )\n                 # path already exists in the list. Update last_insert_index so\n@@ -149,8 +236,10 @@ class Media:\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store original lists to help merge algorithm make better decisions\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n",
    "variant_7": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..6b619b5a20 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,24 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        if not self._js_lists:\n+            return []\n+        if len(self._js_lists) == 1:\n+            return self._js_lists[0]\n+        \n+        # Collect all non-empty JS lists\n+        non_empty_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not non_empty_lists:\n+            return []\n+        if len(non_empty_lists) == 1:\n+            return non_empty_lists[0]\n+        \n+        # Multi-way merge to avoid artificial ordering constraints\n+        return self._multi_way_merge(non_empty_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +125,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -138,10 +151,46 @@ class Media:\n                 # Add path to combined_list since it doesn't exist.\n                 combined_list.insert(last_insert_index, path)\n             else:\n-                if index > last_insert_index:\n+                # Only warn if both elements exist in both original lists\n+                # and have opposite relative order\n+                if (index > last_insert_index and \n+                    path in list_1 and combined_list[last_insert_index] in list_2):\n+                    # Check if the relative order is actually different in the original lists\n+                    try:\n+                        index_in_list1 = list_1.index(path)\n+                        other_index_in_list1 = list_1.index(combined_list[last_insert_index])\n+                        index_in_list2 = list_2.index(path)\n+                        other_index_in_list2 = list_2.index(combined_list[last_insert_index])\n+                        \n+                        # Only warn if the relative order is actually opposite in both lists\n+                        if ((index_in_list1 < other_index_in_list1) != \n+                            (index_in_list2 < other_index_in_list2)):\n+                            warnings.warn(\n+                                'Detected duplicate Media files in an opposite order:\\n'\n+                                '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                                MediaOrderConflictWarning,\n+                            )\n+                    except ValueError:\n+                        # One of the elements doesn't exist in one of the lists\n+                        pass\n+                # path already exists in the list. Update last_insert_index so\n+                # that the following elements are inserted in front of this one.\n+                last_insert_index = index\n+        return combined_list\n+                for original_list in [list_1, list_2]:\n+                    try:\n+                        insert_pos = original_list.index(path_at_insert)\n+                        index_pos = original_list.index(path_at_index)\n+                        if insert_pos > index_pos:\n+                            real_conflict = True\n+                            break\n+                    except ValueError:\n+                        continue\n+                \n+                if real_conflict:\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (path_at_insert, path_at_index),\n                         MediaOrderConflictWarning,\n                     )\n                 # path already exists in the list. Update last_insert_index so\n@@ -149,8 +198,10 @@ class Media:\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store all CSS and JS lists separately to enable better merging\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n",
    "variant_8": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..9deb550d5d 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,23 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        if len(self._js_lists) <= 1:\n+            return self._js_lists[0] if self._js_lists else []\n+        \n+        # Collect all non-empty JS lists\n+        js_lists = [js_list for js_list in self._js_lists if js_list]\n+        \n+        if not js_lists:\n+            return []\n+        if len(js_lists) == 1:\n+            return js_lists[0]\n+        \n+        # Multi-way merge to avoid artificial ordering constraints\n+        return self._merge_multiple(js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -115,9 +125,11 @@ class Media:\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n     @staticmethod\n-    def merge(list_1, list_2):\n+\n+    @staticmethod\n+    def merge(*lists):\n         \"\"\"\n-        Merge two lists while trying to keep the relative order of the elements.\n+        Merge multiple lists while trying to keep the relative order of the elements.\n         Warn if the lists have the same two elements in a different relative\n         order.\n \n@@ -125,23 +137,85 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n+        if not lists:\n+            return []\n+        if len(lists) == 1:\n+            return list(lists[0])\n+        \n+        # Collect all unique elements while preserving original order within each list\n+        all_elements = []\n+        element_to_lists = {}  # Track which lists contain each element\n+        \n+        for list_idx, lst in enumerate(lists):\n+            for element in lst:\n+                if element not in element_to_lists:\n+                    all_elements.append(element)\n+                    element_to_lists[element] = []\n+                element_to_lists[element].append(list_idx)\n+        \n+        # Build the final ordering using topological sort approach\n+        result = []\n+        remaining = set(all_elements)\n+        \n+        while remaining:\n+            # Find elements that can be placed next (no unplaced dependencies)\n+            candidates = []\n+            for element in remaining:\n+                can_place = True\n+                # Check if this element should come after any remaining elements\n+                for other in remaining:\n+                    if other != element and Media._should_come_before(other, element, lists, element_to_lists):\n+                        can_place = False\n+                        break\n+                if can_place:\n+                    candidates.append(element)\n+            \n+            if not candidates:\n+                # No clear ordering - just pick the first remaining element\n+                candidates = [next(iter(remaining))]\n+            \n+            # Choose the candidate that appears earliest in the original lists\n+            best_candidate = min(candidates, key=lambda x: min(\n+                next(i for i, elem in enumerate(lst) if elem == x)\n+                for lst in lists if x in lst\n+            ))\n+            \n+            result.append(best_candidate)\n+            remaining.remove(best_candidate)\n+        \n+        return result\n+    \n+    @staticmethod\n+    def _should_come_before(elem1, elem2, lists, element_to_lists):\n+        \"\"\"Check if elem1 should come before elem2 based on original list orders.\"\"\"\n+        # Only check lists that contain both elements\n+        common_lists = set(element_to_lists[elem1]) & set(element_to_lists[elem2])\n+        \n+        elem1_before_elem2 = 0\n+        elem2_before_elem1 = 0\n+        \n+        for list_idx in common_lists:\n+            lst = lists[list_idx]\n+            idx1 = lst.index(elem1)\n+            idx2 = lst.index(elem2)\n+            \n+            if idx1 < idx2:\n+                elem1_before_elem2 += 1\n             else:\n-                if index > last_insert_index:\n+                elem2_before_elem1 += 1\n+        \n+        # Only warn if there's a real conflict (different orders in different lists)\n+        if elem1_before_elem2 > 0 and elem2_before_elem1 > 0:\n+            warnings.warn(\n+                'Detected duplicate Media files in an opposite order:\\n'\n+                '%s\\n%s' % (elem1, elem2),\n+                MediaOrderConflictWarning,\n+            )\n+        \n+        return elem1_before_elem2 > elem2_before_elem1\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (current_path, existing_path),\n                         MediaOrderConflictWarning,\n                     )\n                 # path already exists in the list. Update last_insert_index so\n@@ -149,8 +223,10 @@ class Media:\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store original lists to help merge algorithm make better decisions\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n"
  }
}