{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/requests/requests/sessions.py lines 428-428)": "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
    "Location 2 (/root/hy/projects_1/requests/requests/compat.py lines 111-111)": "\n    # Handle both string and binary string methods\n    if isinstance(method, bytes):\n        method = method.decode('utf-8')\n    elif not isinstance(method, str):\n        method = str(method)\n",
    "Location 3 (/root/hy/projects_1/requests/requests/sessions.py lines 432-432)": "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
    "Location 4 (/root/hy/projects_1/requests/requests/sessions.py lines 16-16)": "\nfrom .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n",
    "Location 5 (/root/hy/projects_1/requests/requests/sessions.py lines 378-378)": "\n    def request(self, method, url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, bytes, or file-like object to send\n            in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Create the Request.\n        req = Request(\n            method=method,\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            'timeout': timeout,\n            'allow_redirects': allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/requests/requests/sessions.py lines 428-428)": [
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n"
    ],
    "Location 2 (/root/hy/projects_1/requests/requests/compat.py lines 111-111)": [
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n# Handle both string and binary string methods\nif isinstance(method, bytes):\n    method = method.decode('utf-8')\nelif not isinstance(method, str):\n    method = str(method)\n",
      "\n# Handle both string and binary string methods\nif isinstance(method, bytes):\n    method = method.decode('utf-8')\nelif not isinstance(method, str):\n    method = str(method)\n",
      "\n    # Handle both string and binary string methods\n    if isinstance(method, bytes):\n        method = method.decode('utf-8')\n    elif not isinstance(method, str):\n        method = str(method)\n",
      "\n    # Handle both string and binary string methods\n    if isinstance(method, bytes):\n        method = method.decode('utf-8')\n    elif not isinstance(method, str):\n        method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n    # Handle both string and binary string methods\n    if isinstance(method, bytes):\n        method = method.decode('utf-8')\n    elif not isinstance(method, str):\n        method = str(method)\n",
      "\n    # Handle both string and binary string methods\n    if isinstance(method, bytes):\n        method = method.decode('utf-8')\n    elif not isinstance(method, str):\n        method = str(method)\n"
    ],
    "Location 3 (/root/hy/projects_1/requests/requests/sessions.py lines 432-432)": [
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n",
      "\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n"
    ],
    "Location 4 (/root/hy/projects_1/requests/requests/sessions.py lines 16-16)": [
      "\nfrom .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n",
      "\nfrom .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n",
      "\nfrom .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n",
      "\nfrom .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n",
      "\nfrom .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n",
      "\nfrom .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n",
      "\nfrom .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n",
      "\nfrom .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n"
    ],
    "Location 5 (/root/hy/projects_1/requests/requests/sessions.py lines 378-378)": [
      "\n    def request(self, method, url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, bytes, or file-like object to send\n            in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) if ``True``, the SSL cert will be verified.\n            A CA_BUNDLE path can also be provided.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        \"\"\"\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n        \n        method = method.upper()\n\n        # Create the Request.\n        req = Request(\n            method = method,\n            url = url,\n            headers = headers,\n            files = files,\n            data = data or {},\n            json = json,\n            params = params or {},\n            auth = auth,\n            cookies = cookies,\n            hooks = hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            'timeout': timeout,\n            'allow_redirects': allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n",
      "\n    def request(self, method, url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, bytes, or file-like object to send\n            in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) whether the SSL cert will be verified.\n            A CA_BUNDLE path can also be provided. Defaults to ``True``.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n        \n        # Create the Request.\n        req = Request(\n            method=method.upper(),\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            'timeout': timeout,\n            'allow_redirects': allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n",
      "\n    def request(self, method, url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, bytes, or file-like object to send\n            in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) if ``True``, the SSL cert will be verified.\n            A CA_BUNDLE path can also be provided.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        \"\"\"\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n\n        # Create the Request.\n        req = Request(\n            method = method.upper(),\n            url = url,\n            headers = headers,\n            files = files,\n            data = data or {},\n            json = json,\n            params = params or {},\n            auth = auth,\n            cookies = cookies,\n            hooks = hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            'timeout': timeout,\n            'allow_redirects': allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n",
      "\n    def request(self, method, url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, bytes, or file-like object to send\n            in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n\n        # Create the Request.\n        req = Request(\n            method=method.upper(),\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            'timeout': timeout,\n            'allow_redirects': allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n",
      "\n    def request(self, method, url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, bytes, or file-like object to send\n            in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) if ``True``, the SSL cert will be verified.\n            A CA_BUNDLE path can also be provided.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n\n        # Create the Request.\n        req = Request(\n            method = method.upper(),\n            url = url,\n            headers = headers,\n            files = files,\n            data = data or {},\n            json = json,\n            params = params or {},\n            auth = auth,\n            cookies = cookies,\n            hooks = hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            'timeout': timeout,\n            'allow_redirects': allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n",
      "\n    def request(self, method, url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, bytes, or file-like object to send\n            in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) whether the SSL cert will be verified.\n            A CA_BUNDLE path can also be provided. Defaults to ``True``.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n\n        # Create the Request.\n        req = Request(\n            method=method.upper(),\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            'timeout': timeout,\n            'allow_redirects': allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n",
      "\n    def request(self, method, url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, bytes, or file-like object to send\n            in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) whether the SSL cert will be verified.\n            A CA_BUNDLE path can also be provided. Defaults to ``True``.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n        \n        # Create the Request.\n        req = Request(\n            method=method.upper(),\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            'timeout': timeout,\n            'allow_redirects': allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n",
      "\n    def request(self, method, url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=True,\n        proxies=None,\n        hooks=None,\n        stream=None,\n        verify=None,\n        cert=None,\n        json=None):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, bytes, or file-like object to send\n            in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) whether the SSL cert will be verified.\n            A CA_BUNDLE path can also be provided. Defaults to ``True``.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Handle both string and binary string methods\n        if isinstance(method, bytes):\n            method = method.decode('utf-8')\n        elif not isinstance(method, str):\n            method = str(method)\n\n        # Create the Request.\n        req = Request(\n            method=method.upper(),\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n\n        proxies = proxies or {}\n\n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n\n        # Send the request.\n        send_kwargs = {\n            'timeout': timeout,\n            'allow_redirects': allow_redirects,\n        }\n        send_kwargs.update(settings)\n        resp = self.send(prep, **send_kwargs)\n\n        return resp\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/requests/compat.py b/requests/compat.py\nindex be5a1ed6..1078b0ab 100644\n--- a/requests/compat.py\n+++ b/requests/compat.py\n@@ -108,6 +108,13 @@ elif is_py3:\n     from io import StringIO\n     from collections import OrderedDict\n \n+\n+    def safe_method_str(method):\n+        \"\"\"Convert method to string, handling binary strings properly.\"\"\"\n+        if isinstance(method, bytes):\n+            return method.decode('utf-8')\n+        return str(method)\n+    \n     builtin_str = str\n     str = str\n     bytes = bytes\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..d185891a 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,7 +13,8 @@ from collections import Mapping\n from datetime import datetime\n \n from .auth import _basic_auth_str\n-from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n+\n+from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str, safe_method_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n from .models import Request, PreparedRequest, DEFAULT_REDIRECT_LIMIT\n@@ -375,6 +376,7 @@ class Session(SessionRedirectMixin):\n         )\n         return p\n \n+\n     def request(self, method, url,\n         params=None,\n         data=None,\n@@ -425,10 +427,16 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n \n         # Create the Request.\n         req = Request(\n+\n             method = method.upper(),\n             url = url,\n             headers = headers,\n",
    "variant_0": "diff --git a/requests/compat.py b/requests/compat.py\nindex be5a1ed6..49eb7154 100644\n--- a/requests/compat.py\n+++ b/requests/compat.py\n@@ -108,7 +108,12 @@ elif is_py3:\n     from io import StringIO\n     from collections import OrderedDict\n \n-    builtin_str = str\n+\n+    # Handle both string and binary string methods\n+    if isinstance(method, bytes):\n+        method = method.decode('utf-8')\n+    elif not isinstance(method, str):\n+        method = str(method)\n     str = str\n     bytes = bytes\n     basestring = (str, bytes)\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..11e58eb7 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,6 +13,7 @@ from collections import Mapping\n from datetime import datetime\n \n from .auth import _basic_auth_str\n+\n from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n@@ -375,6 +376,7 @@ class Session(SessionRedirectMixin):\n         )\n         return p\n \n+\n     def request(self, method, url,\n         params=None,\n         data=None,\n@@ -393,6 +395,86 @@ class Session(SessionRedirectMixin):\n         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n         Returns :class:`Response <Response>` object.\n \n+        :param method: method for the new :class:`Request` object.\n+        :param url: URL for the new :class:`Request` object.\n+        :param params: (optional) Dictionary or bytes to be sent in the query\n+            string for the :class:`Request`.\n+        :param data: (optional) Dictionary, bytes, or file-like object to send\n+            in the body of the :class:`Request`.\n+        :param json: (optional) json to send in the body of the\n+            :class:`Request`.\n+        :param headers: (optional) Dictionary of HTTP Headers to send with the\n+            :class:`Request`.\n+        :param cookies: (optional) Dict or CookieJar object to send with the\n+            :class:`Request`.\n+        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n+            for multipart encoding upload.\n+        :param auth: (optional) Auth tuple or callable to enable\n+            Basic/Digest/Custom HTTP Auth.\n+        :param timeout: (optional) How long to wait for the server to send\n+            data before giving up, as a float, or a :ref:`(connect timeout,\n+            read timeout) <timeouts>` tuple.\n+        :type timeout: float or tuple\n+        :param allow_redirects: (optional) Set to True by default.\n+        :type allow_redirects: bool\n+        :param proxies: (optional) Dictionary mapping protocol or protocol and\n+            hostname to the URL of the proxy.\n+        :param stream: (optional) whether to immediately download the response\n+            content. Defaults to ``False``.\n+        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n+            the server's TLS certificate, or a string, in which case it must be a path\n+            to a CA bundle to use. Defaults to ``True``.\n+        :param cert: (optional) if String, path to ssl client cert file (.pem).\n+            If Tuple, ('cert', 'key') pair.\n+        :rtype: requests.Response\n+        \"\"\"\n+        # Create the Request.\n+        req = Request(\n+            method=method,\n+            url=url,\n+            headers=headers,\n+            files=files,\n+            data=data or {},\n+            json=json,\n+            params=params or {},\n+            auth=auth,\n+            cookies=cookies,\n+            hooks=hooks,\n+        )\n+        prep = self.prepare_request(req)\n+\n+        proxies = proxies or {}\n+\n+        settings = self.merge_environment_settings(\n+            prep.url, proxies, stream, verify, cert\n+        )\n+\n+        # Send the request.\n+        send_kwargs = {\n+            'timeout': timeout,\n+            'allow_redirects': allow_redirects,\n+        }\n+        send_kwargs.update(settings)\n+        resp = self.send(prep, **send_kwargs)\n+\n+        return resp\n+        params=None,\n+        data=None,\n+        headers=None,\n+        cookies=None,\n+        files=None,\n+        auth=None,\n+        timeout=None,\n+        allow_redirects=True,\n+        proxies=None,\n+        hooks=None,\n+        stream=None,\n+        verify=None,\n+        cert=None,\n+        json=None):\n+        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n+        Returns :class:`Response <Response>` object.\n+\n         :param method: method for the new :class:`Request` object.\n         :param url: URL for the new :class:`Request` object.\n         :param params: (optional) Dictionary or bytes to be sent in the query\n@@ -425,11 +507,21 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n \n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n             url = url,\n             headers = headers,\n             files = files,\n",
    "variant_1": "diff --git a/requests/compat.py b/requests/compat.py\nindex be5a1ed6..d2088b16 100644\n--- a/requests/compat.py\n+++ b/requests/compat.py\n@@ -108,7 +108,12 @@ elif is_py3:\n     from io import StringIO\n     from collections import OrderedDict\n \n-    builtin_str = str\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n     str = str\n     bytes = bytes\n     basestring = (str, bytes)\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..5e7a9ec7 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,6 +13,7 @@ from collections import Mapping\n from datetime import datetime\n \n from .auth import _basic_auth_str\n+\n from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n@@ -375,6 +376,7 @@ class Session(SessionRedirectMixin):\n         )\n         return p\n \n+\n     def request(self, method, url,\n         params=None,\n         data=None,\n@@ -393,6 +395,92 @@ class Session(SessionRedirectMixin):\n         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n         Returns :class:`Response <Response>` object.\n \n+        :param method: method for the new :class:`Request` object.\n+        :param url: URL for the new :class:`Request` object.\n+        :param params: (optional) Dictionary or bytes to be sent in the query\n+            string for the :class:`Request`.\n+        :param data: (optional) Dictionary, bytes, or file-like object to send\n+            in the body of the :class:`Request`.\n+        :param json: (optional) json to send in the body of the\n+            :class:`Request`.\n+        :param headers: (optional) Dictionary of HTTP Headers to send with the\n+            :class:`Request`.\n+        :param cookies: (optional) Dict or CookieJar object to send with the\n+            :class:`Request`.\n+        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n+            for multipart encoding upload.\n+        :param auth: (optional) Auth tuple or callable to enable\n+            Basic/Digest/Custom HTTP Auth.\n+        :param timeout: (optional) How long to wait for the server to send\n+            data before giving up, as a float, or a :ref:`(connect timeout,\n+            read timeout) <timeouts>` tuple.\n+        :type timeout: float or tuple\n+        :param allow_redirects: (optional) Set to True by default.\n+        :type allow_redirects: bool\n+        :param proxies: (optional) Dictionary mapping protocol or protocol and\n+            hostname to the URL of the proxy.\n+        :param stream: (optional) whether to immediately download the response\n+            content. Defaults to ``False``.\n+        :param verify: (optional) if ``True``, the SSL cert will be verified.\n+            A CA_BUNDLE path can also be provided.\n+        :param cert: (optional) if String, path to ssl client cert file (.pem).\n+            If Tuple, ('cert', 'key') pair.\n+        \"\"\"\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n+        \n+        method = method.upper()\n+\n+        # Create the Request.\n+        req = Request(\n+            method = method,\n+            url = url,\n+            headers = headers,\n+            files = files,\n+            data = data or {},\n+            json = json,\n+            params = params or {},\n+            auth = auth,\n+            cookies = cookies,\n+            hooks = hooks,\n+        )\n+        prep = self.prepare_request(req)\n+\n+        proxies = proxies or {}\n+\n+        settings = self.merge_environment_settings(\n+            prep.url, proxies, stream, verify, cert\n+        )\n+\n+        # Send the request.\n+        send_kwargs = {\n+            'timeout': timeout,\n+            'allow_redirects': allow_redirects,\n+        }\n+        send_kwargs.update(settings)\n+        resp = self.send(prep, **send_kwargs)\n+\n+        return resp\n+        params=None,\n+        data=None,\n+        headers=None,\n+        cookies=None,\n+        files=None,\n+        auth=None,\n+        timeout=None,\n+        allow_redirects=True,\n+        proxies=None,\n+        hooks=None,\n+        stream=None,\n+        verify=None,\n+        cert=None,\n+        json=None):\n+        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n+        Returns :class:`Response <Response>` object.\n+\n         :param method: method for the new :class:`Request` object.\n         :param url: URL for the new :class:`Request` object.\n         :param params: (optional) Dictionary or bytes to be sent in the query\n@@ -425,11 +513,21 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n \n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n             url = url,\n             headers = headers,\n             files = files,\n",
    "variant_2": "diff --git a/requests/compat.py b/requests/compat.py\nindex be5a1ed6..6b592f39 100644\n--- a/requests/compat.py\n+++ b/requests/compat.py\n@@ -108,7 +108,12 @@ elif is_py3:\n     from io import StringIO\n     from collections import OrderedDict\n \n-    builtin_str = str\n+\n+# Handle both string and binary string methods\n+if isinstance(method, bytes):\n+    method = method.decode('utf-8')\n+elif not isinstance(method, str):\n+    method = str(method)\n     str = str\n     bytes = bytes\n     basestring = (str, bytes)\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..2ac50b4a 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,6 +13,7 @@ from collections import Mapping\n from datetime import datetime\n \n from .auth import _basic_auth_str\n+\n from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n@@ -375,6 +376,7 @@ class Session(SessionRedirectMixin):\n         )\n         return p\n \n+\n     def request(self, method, url,\n         params=None,\n         data=None,\n@@ -393,6 +395,91 @@ class Session(SessionRedirectMixin):\n         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n         Returns :class:`Response <Response>` object.\n \n+        :param method: method for the new :class:`Request` object.\n+        :param url: URL for the new :class:`Request` object.\n+        :param params: (optional) Dictionary or bytes to be sent in the query\n+            string for the :class:`Request`.\n+        :param data: (optional) Dictionary, bytes, or file-like object to send\n+            in the body of the :class:`Request`.\n+        :param json: (optional) json to send in the body of the\n+            :class:`Request`.\n+        :param headers: (optional) Dictionary of HTTP Headers to send with the\n+            :class:`Request`.\n+        :param cookies: (optional) Dict or CookieJar object to send with the\n+            :class:`Request`.\n+        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n+            for multipart encoding upload.\n+        :param auth: (optional) Auth tuple or callable to enable\n+            Basic/Digest/Custom HTTP Auth.\n+        :param timeout: (optional) How long to wait for the server to send\n+            data before giving up, as a float, or a :ref:`(connect timeout,\n+            read timeout) <timeouts>` tuple.\n+        :type timeout: float or tuple\n+        :param allow_redirects: (optional) Set to True by default.\n+        :type allow_redirects: bool\n+        :param proxies: (optional) Dictionary mapping protocol or protocol and\n+            hostname to the URL of the proxy.\n+        :param stream: (optional) whether to immediately download the response\n+            content. Defaults to ``False``.\n+        :param verify: (optional) whether the SSL cert will be verified.\n+            A CA_BUNDLE path can also be provided. Defaults to ``True``.\n+        :param cert: (optional) if String, path to ssl client cert file (.pem).\n+            If Tuple, ('cert', 'key') pair.\n+        :rtype: requests.Response\n+        \"\"\"\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n+        \n+        # Create the Request.\n+        req = Request(\n+            method=method.upper(),\n+            url=url,\n+            headers=headers,\n+            files=files,\n+            data=data or {},\n+            json=json,\n+            params=params or {},\n+            auth=auth,\n+            cookies=cookies,\n+            hooks=hooks,\n+        )\n+        prep = self.prepare_request(req)\n+\n+        proxies = proxies or {}\n+\n+        settings = self.merge_environment_settings(\n+            prep.url, proxies, stream, verify, cert\n+        )\n+\n+        # Send the request.\n+        send_kwargs = {\n+            'timeout': timeout,\n+            'allow_redirects': allow_redirects,\n+        }\n+        send_kwargs.update(settings)\n+        resp = self.send(prep, **send_kwargs)\n+\n+        return resp\n+        params=None,\n+        data=None,\n+        headers=None,\n+        cookies=None,\n+        files=None,\n+        auth=None,\n+        timeout=None,\n+        allow_redirects=True,\n+        proxies=None,\n+        hooks=None,\n+        stream=None,\n+        verify=None,\n+        cert=None,\n+        json=None):\n+        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n+        Returns :class:`Response <Response>` object.\n+\n         :param method: method for the new :class:`Request` object.\n         :param url: URL for the new :class:`Request` object.\n         :param params: (optional) Dictionary or bytes to be sent in the query\n@@ -425,11 +512,21 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n \n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n             url = url,\n             headers = headers,\n             files = files,\n",
    "variant_3": "diff --git a/requests/compat.py b/requests/compat.py\nindex be5a1ed6..6b592f39 100644\n--- a/requests/compat.py\n+++ b/requests/compat.py\n@@ -108,7 +108,12 @@ elif is_py3:\n     from io import StringIO\n     from collections import OrderedDict\n \n-    builtin_str = str\n+\n+# Handle both string and binary string methods\n+if isinstance(method, bytes):\n+    method = method.decode('utf-8')\n+elif not isinstance(method, str):\n+    method = str(method)\n     str = str\n     bytes = bytes\n     basestring = (str, bytes)\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..f89fbd12 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,6 +13,7 @@ from collections import Mapping\n from datetime import datetime\n \n from .auth import _basic_auth_str\n+\n from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n@@ -375,6 +376,7 @@ class Session(SessionRedirectMixin):\n         )\n         return p\n \n+\n     def request(self, method, url,\n         params=None,\n         data=None,\n@@ -393,6 +395,90 @@ class Session(SessionRedirectMixin):\n         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n         Returns :class:`Response <Response>` object.\n \n+        :param method: method for the new :class:`Request` object.\n+        :param url: URL for the new :class:`Request` object.\n+        :param params: (optional) Dictionary or bytes to be sent in the query\n+            string for the :class:`Request`.\n+        :param data: (optional) Dictionary, bytes, or file-like object to send\n+            in the body of the :class:`Request`.\n+        :param json: (optional) json to send in the body of the\n+            :class:`Request`.\n+        :param headers: (optional) Dictionary of HTTP Headers to send with the\n+            :class:`Request`.\n+        :param cookies: (optional) Dict or CookieJar object to send with the\n+            :class:`Request`.\n+        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n+            for multipart encoding upload.\n+        :param auth: (optional) Auth tuple or callable to enable\n+            Basic/Digest/Custom HTTP Auth.\n+        :param timeout: (optional) How long to wait for the server to send\n+            data before giving up, as a float, or a :ref:`(connect timeout,\n+            read timeout) <timeouts>` tuple.\n+        :type timeout: float or tuple\n+        :param allow_redirects: (optional) Set to True by default.\n+        :type allow_redirects: bool\n+        :param proxies: (optional) Dictionary mapping protocol or protocol and\n+            hostname to the URL of the proxy.\n+        :param stream: (optional) whether to immediately download the response\n+            content. Defaults to ``False``.\n+        :param verify: (optional) if ``True``, the SSL cert will be verified.\n+            A CA_BUNDLE path can also be provided.\n+        :param cert: (optional) if String, path to ssl client cert file (.pem).\n+            If Tuple, ('cert', 'key') pair.\n+        \"\"\"\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n+\n+        # Create the Request.\n+        req = Request(\n+            method = method.upper(),\n+            url = url,\n+            headers = headers,\n+            files = files,\n+            data = data or {},\n+            json = json,\n+            params = params or {},\n+            auth = auth,\n+            cookies = cookies,\n+            hooks = hooks,\n+        )\n+        prep = self.prepare_request(req)\n+\n+        proxies = proxies or {}\n+\n+        settings = self.merge_environment_settings(\n+            prep.url, proxies, stream, verify, cert\n+        )\n+\n+        # Send the request.\n+        send_kwargs = {\n+            'timeout': timeout,\n+            'allow_redirects': allow_redirects,\n+        }\n+        send_kwargs.update(settings)\n+        resp = self.send(prep, **send_kwargs)\n+\n+        return resp\n+        params=None,\n+        data=None,\n+        headers=None,\n+        cookies=None,\n+        files=None,\n+        auth=None,\n+        timeout=None,\n+        allow_redirects=True,\n+        proxies=None,\n+        hooks=None,\n+        stream=None,\n+        verify=None,\n+        cert=None,\n+        json=None):\n+        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n+        Returns :class:`Response <Response>` object.\n+\n         :param method: method for the new :class:`Request` object.\n         :param url: URL for the new :class:`Request` object.\n         :param params: (optional) Dictionary or bytes to be sent in the query\n@@ -425,11 +511,21 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n \n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n             url = url,\n             headers = headers,\n             files = files,\n",
    "variant_4": "diff --git a/requests/compat.py b/requests/compat.py\nindex be5a1ed6..49eb7154 100644\n--- a/requests/compat.py\n+++ b/requests/compat.py\n@@ -108,7 +108,12 @@ elif is_py3:\n     from io import StringIO\n     from collections import OrderedDict\n \n-    builtin_str = str\n+\n+    # Handle both string and binary string methods\n+    if isinstance(method, bytes):\n+        method = method.decode('utf-8')\n+    elif not isinstance(method, str):\n+        method = str(method)\n     str = str\n     bytes = bytes\n     basestring = (str, bytes)\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..1f072d46 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,6 +13,7 @@ from collections import Mapping\n from datetime import datetime\n \n from .auth import _basic_auth_str\n+\n from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n@@ -375,6 +376,7 @@ class Session(SessionRedirectMixin):\n         )\n         return p\n \n+\n     def request(self, method, url,\n         params=None,\n         data=None,\n@@ -393,6 +395,92 @@ class Session(SessionRedirectMixin):\n         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n         Returns :class:`Response <Response>` object.\n \n+        :param method: method for the new :class:`Request` object.\n+        :param url: URL for the new :class:`Request` object.\n+        :param params: (optional) Dictionary or bytes to be sent in the query\n+            string for the :class:`Request`.\n+        :param data: (optional) Dictionary, bytes, or file-like object to send\n+            in the body of the :class:`Request`.\n+        :param json: (optional) json to send in the body of the\n+            :class:`Request`.\n+        :param headers: (optional) Dictionary of HTTP Headers to send with the\n+            :class:`Request`.\n+        :param cookies: (optional) Dict or CookieJar object to send with the\n+            :class:`Request`.\n+        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n+            for multipart encoding upload.\n+        :param auth: (optional) Auth tuple or callable to enable\n+            Basic/Digest/Custom HTTP Auth.\n+        :param timeout: (optional) How long to wait for the server to send\n+            data before giving up, as a float, or a :ref:`(connect timeout,\n+            read timeout) <timeouts>` tuple.\n+        :type timeout: float or tuple\n+        :param allow_redirects: (optional) Set to True by default.\n+        :type allow_redirects: bool\n+        :param proxies: (optional) Dictionary mapping protocol or protocol and\n+            hostname to the URL of the proxy.\n+        :param stream: (optional) whether to immediately download the response\n+            content. Defaults to ``False``.\n+        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n+            the server's TLS certificate, or a string, in which case it must be a path\n+            to a CA bundle to use. Defaults to ``True``.\n+        :param cert: (optional) if String, path to ssl client cert file (.pem).\n+            If Tuple, ('cert', 'key') pair.\n+        :rtype: requests.Response\n+        \"\"\"\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n+\n+        # Create the Request.\n+        req = Request(\n+            method=method.upper(),\n+            url=url,\n+            headers=headers,\n+            files=files,\n+            data=data or {},\n+            json=json,\n+            params=params or {},\n+            auth=auth,\n+            cookies=cookies,\n+            hooks=hooks,\n+        )\n+        prep = self.prepare_request(req)\n+\n+        proxies = proxies or {}\n+\n+        settings = self.merge_environment_settings(\n+            prep.url, proxies, stream, verify, cert\n+        )\n+\n+        # Send the request.\n+        send_kwargs = {\n+            'timeout': timeout,\n+            'allow_redirects': allow_redirects,\n+        }\n+        send_kwargs.update(settings)\n+        resp = self.send(prep, **send_kwargs)\n+\n+        return resp\n+        params=None,\n+        data=None,\n+        headers=None,\n+        cookies=None,\n+        files=None,\n+        auth=None,\n+        timeout=None,\n+        allow_redirects=True,\n+        proxies=None,\n+        hooks=None,\n+        stream=None,\n+        verify=None,\n+        cert=None,\n+        json=None):\n+        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n+        Returns :class:`Response <Response>` object.\n+\n         :param method: method for the new :class:`Request` object.\n         :param url: URL for the new :class:`Request` object.\n         :param params: (optional) Dictionary or bytes to be sent in the query\n@@ -425,11 +513,21 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n \n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n             url = url,\n             headers = headers,\n             files = files,\n",
    "variant_5": "diff --git a/requests/compat.py b/requests/compat.py\nindex be5a1ed6..49eb7154 100644\n--- a/requests/compat.py\n+++ b/requests/compat.py\n@@ -108,7 +108,12 @@ elif is_py3:\n     from io import StringIO\n     from collections import OrderedDict\n \n-    builtin_str = str\n+\n+    # Handle both string and binary string methods\n+    if isinstance(method, bytes):\n+        method = method.decode('utf-8')\n+    elif not isinstance(method, str):\n+        method = str(method)\n     str = str\n     bytes = bytes\n     basestring = (str, bytes)\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..2d056c83 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,6 +13,7 @@ from collections import Mapping\n from datetime import datetime\n \n from .auth import _basic_auth_str\n+\n from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n@@ -375,6 +376,7 @@ class Session(SessionRedirectMixin):\n         )\n         return p\n \n+\n     def request(self, method, url,\n         params=None,\n         data=None,\n@@ -393,6 +395,91 @@ class Session(SessionRedirectMixin):\n         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n         Returns :class:`Response <Response>` object.\n \n+        :param method: method for the new :class:`Request` object.\n+        :param url: URL for the new :class:`Request` object.\n+        :param params: (optional) Dictionary or bytes to be sent in the query\n+            string for the :class:`Request`.\n+        :param data: (optional) Dictionary, bytes, or file-like object to send\n+            in the body of the :class:`Request`.\n+        :param json: (optional) json to send in the body of the\n+            :class:`Request`.\n+        :param headers: (optional) Dictionary of HTTP Headers to send with the\n+            :class:`Request`.\n+        :param cookies: (optional) Dict or CookieJar object to send with the\n+            :class:`Request`.\n+        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n+            for multipart encoding upload.\n+        :param auth: (optional) Auth tuple or callable to enable\n+            Basic/Digest/Custom HTTP Auth.\n+        :param timeout: (optional) How long to wait for the server to send\n+            data before giving up, as a float, or a :ref:`(connect timeout,\n+            read timeout) <timeouts>` tuple.\n+        :type timeout: float or tuple\n+        :param allow_redirects: (optional) Set to True by default.\n+        :type allow_redirects: bool\n+        :param proxies: (optional) Dictionary mapping protocol or protocol and\n+            hostname to the URL of the proxy.\n+        :param stream: (optional) whether to immediately download the response\n+            content. Defaults to ``False``.\n+        :param verify: (optional) if ``True``, the SSL cert will be verified.\n+            A CA_BUNDLE path can also be provided.\n+        :param cert: (optional) if String, path to ssl client cert file (.pem).\n+            If Tuple, ('cert', 'key') pair.\n+        :rtype: requests.Response\n+        \"\"\"\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n+\n+        # Create the Request.\n+        req = Request(\n+            method = method.upper(),\n+            url = url,\n+            headers = headers,\n+            files = files,\n+            data = data or {},\n+            json = json,\n+            params = params or {},\n+            auth = auth,\n+            cookies = cookies,\n+            hooks = hooks,\n+        )\n+        prep = self.prepare_request(req)\n+\n+        proxies = proxies or {}\n+\n+        settings = self.merge_environment_settings(\n+            prep.url, proxies, stream, verify, cert\n+        )\n+\n+        # Send the request.\n+        send_kwargs = {\n+            'timeout': timeout,\n+            'allow_redirects': allow_redirects,\n+        }\n+        send_kwargs.update(settings)\n+        resp = self.send(prep, **send_kwargs)\n+\n+        return resp\n+        params=None,\n+        data=None,\n+        headers=None,\n+        cookies=None,\n+        files=None,\n+        auth=None,\n+        timeout=None,\n+        allow_redirects=True,\n+        proxies=None,\n+        hooks=None,\n+        stream=None,\n+        verify=None,\n+        cert=None,\n+        json=None):\n+        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n+        Returns :class:`Response <Response>` object.\n+\n         :param method: method for the new :class:`Request` object.\n         :param url: URL for the new :class:`Request` object.\n         :param params: (optional) Dictionary or bytes to be sent in the query\n@@ -425,11 +512,21 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n \n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n             url = url,\n             headers = headers,\n             files = files,\n",
    "variant_6": "diff --git a/requests/compat.py b/requests/compat.py\nindex be5a1ed6..d2088b16 100644\n--- a/requests/compat.py\n+++ b/requests/compat.py\n@@ -108,7 +108,12 @@ elif is_py3:\n     from io import StringIO\n     from collections import OrderedDict\n \n-    builtin_str = str\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n     str = str\n     bytes = bytes\n     basestring = (str, bytes)\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..a9f9394e 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,6 +13,7 @@ from collections import Mapping\n from datetime import datetime\n \n from .auth import _basic_auth_str\n+\n from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n@@ -375,6 +376,7 @@ class Session(SessionRedirectMixin):\n         )\n         return p\n \n+\n     def request(self, method, url,\n         params=None,\n         data=None,\n@@ -393,6 +395,91 @@ class Session(SessionRedirectMixin):\n         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n         Returns :class:`Response <Response>` object.\n \n+        :param method: method for the new :class:`Request` object.\n+        :param url: URL for the new :class:`Request` object.\n+        :param params: (optional) Dictionary or bytes to be sent in the query\n+            string for the :class:`Request`.\n+        :param data: (optional) Dictionary, bytes, or file-like object to send\n+            in the body of the :class:`Request`.\n+        :param json: (optional) json to send in the body of the\n+            :class:`Request`.\n+        :param headers: (optional) Dictionary of HTTP Headers to send with the\n+            :class:`Request`.\n+        :param cookies: (optional) Dict or CookieJar object to send with the\n+            :class:`Request`.\n+        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n+            for multipart encoding upload.\n+        :param auth: (optional) Auth tuple or callable to enable\n+            Basic/Digest/Custom HTTP Auth.\n+        :param timeout: (optional) How long to wait for the server to send\n+            data before giving up, as a float, or a :ref:`(connect timeout,\n+            read timeout) <timeouts>` tuple.\n+        :type timeout: float or tuple\n+        :param allow_redirects: (optional) Set to True by default.\n+        :type allow_redirects: bool\n+        :param proxies: (optional) Dictionary mapping protocol or protocol and\n+            hostname to the URL of the proxy.\n+        :param stream: (optional) whether to immediately download the response\n+            content. Defaults to ``False``.\n+        :param verify: (optional) whether the SSL cert will be verified.\n+            A CA_BUNDLE path can also be provided. Defaults to ``True``.\n+        :param cert: (optional) if String, path to ssl client cert file (.pem).\n+            If Tuple, ('cert', 'key') pair.\n+        :rtype: requests.Response\n+        \"\"\"\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n+\n+        # Create the Request.\n+        req = Request(\n+            method=method.upper(),\n+            url=url,\n+            headers=headers,\n+            files=files,\n+            data=data or {},\n+            json=json,\n+            params=params or {},\n+            auth=auth,\n+            cookies=cookies,\n+            hooks=hooks,\n+        )\n+        prep = self.prepare_request(req)\n+\n+        proxies = proxies or {}\n+\n+        settings = self.merge_environment_settings(\n+            prep.url, proxies, stream, verify, cert\n+        )\n+\n+        # Send the request.\n+        send_kwargs = {\n+            'timeout': timeout,\n+            'allow_redirects': allow_redirects,\n+        }\n+        send_kwargs.update(settings)\n+        resp = self.send(prep, **send_kwargs)\n+\n+        return resp\n+        params=None,\n+        data=None,\n+        headers=None,\n+        cookies=None,\n+        files=None,\n+        auth=None,\n+        timeout=None,\n+        allow_redirects=True,\n+        proxies=None,\n+        hooks=None,\n+        stream=None,\n+        verify=None,\n+        cert=None,\n+        json=None):\n+        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n+        Returns :class:`Response <Response>` object.\n+\n         :param method: method for the new :class:`Request` object.\n         :param url: URL for the new :class:`Request` object.\n         :param params: (optional) Dictionary or bytes to be sent in the query\n@@ -425,11 +512,21 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n \n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n             url = url,\n             headers = headers,\n             files = files,\n",
    "variant_7": "diff --git a/requests/compat.py b/requests/compat.py\nindex be5a1ed6..49eb7154 100644\n--- a/requests/compat.py\n+++ b/requests/compat.py\n@@ -108,7 +108,12 @@ elif is_py3:\n     from io import StringIO\n     from collections import OrderedDict\n \n-    builtin_str = str\n+\n+    # Handle both string and binary string methods\n+    if isinstance(method, bytes):\n+        method = method.decode('utf-8')\n+    elif not isinstance(method, str):\n+        method = str(method)\n     str = str\n     bytes = bytes\n     basestring = (str, bytes)\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..2ac50b4a 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,6 +13,7 @@ from collections import Mapping\n from datetime import datetime\n \n from .auth import _basic_auth_str\n+\n from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n@@ -375,6 +376,7 @@ class Session(SessionRedirectMixin):\n         )\n         return p\n \n+\n     def request(self, method, url,\n         params=None,\n         data=None,\n@@ -393,6 +395,91 @@ class Session(SessionRedirectMixin):\n         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n         Returns :class:`Response <Response>` object.\n \n+        :param method: method for the new :class:`Request` object.\n+        :param url: URL for the new :class:`Request` object.\n+        :param params: (optional) Dictionary or bytes to be sent in the query\n+            string for the :class:`Request`.\n+        :param data: (optional) Dictionary, bytes, or file-like object to send\n+            in the body of the :class:`Request`.\n+        :param json: (optional) json to send in the body of the\n+            :class:`Request`.\n+        :param headers: (optional) Dictionary of HTTP Headers to send with the\n+            :class:`Request`.\n+        :param cookies: (optional) Dict or CookieJar object to send with the\n+            :class:`Request`.\n+        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n+            for multipart encoding upload.\n+        :param auth: (optional) Auth tuple or callable to enable\n+            Basic/Digest/Custom HTTP Auth.\n+        :param timeout: (optional) How long to wait for the server to send\n+            data before giving up, as a float, or a :ref:`(connect timeout,\n+            read timeout) <timeouts>` tuple.\n+        :type timeout: float or tuple\n+        :param allow_redirects: (optional) Set to True by default.\n+        :type allow_redirects: bool\n+        :param proxies: (optional) Dictionary mapping protocol or protocol and\n+            hostname to the URL of the proxy.\n+        :param stream: (optional) whether to immediately download the response\n+            content. Defaults to ``False``.\n+        :param verify: (optional) whether the SSL cert will be verified.\n+            A CA_BUNDLE path can also be provided. Defaults to ``True``.\n+        :param cert: (optional) if String, path to ssl client cert file (.pem).\n+            If Tuple, ('cert', 'key') pair.\n+        :rtype: requests.Response\n+        \"\"\"\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n+        \n+        # Create the Request.\n+        req = Request(\n+            method=method.upper(),\n+            url=url,\n+            headers=headers,\n+            files=files,\n+            data=data or {},\n+            json=json,\n+            params=params or {},\n+            auth=auth,\n+            cookies=cookies,\n+            hooks=hooks,\n+        )\n+        prep = self.prepare_request(req)\n+\n+        proxies = proxies or {}\n+\n+        settings = self.merge_environment_settings(\n+            prep.url, proxies, stream, verify, cert\n+        )\n+\n+        # Send the request.\n+        send_kwargs = {\n+            'timeout': timeout,\n+            'allow_redirects': allow_redirects,\n+        }\n+        send_kwargs.update(settings)\n+        resp = self.send(prep, **send_kwargs)\n+\n+        return resp\n+        params=None,\n+        data=None,\n+        headers=None,\n+        cookies=None,\n+        files=None,\n+        auth=None,\n+        timeout=None,\n+        allow_redirects=True,\n+        proxies=None,\n+        hooks=None,\n+        stream=None,\n+        verify=None,\n+        cert=None,\n+        json=None):\n+        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n+        Returns :class:`Response <Response>` object.\n+\n         :param method: method for the new :class:`Request` object.\n         :param url: URL for the new :class:`Request` object.\n         :param params: (optional) Dictionary or bytes to be sent in the query\n@@ -425,11 +512,21 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n \n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n             url = url,\n             headers = headers,\n             files = files,\n",
    "variant_8": "diff --git a/requests/compat.py b/requests/compat.py\nindex be5a1ed6..49eb7154 100644\n--- a/requests/compat.py\n+++ b/requests/compat.py\n@@ -108,7 +108,12 @@ elif is_py3:\n     from io import StringIO\n     from collections import OrderedDict\n \n-    builtin_str = str\n+\n+    # Handle both string and binary string methods\n+    if isinstance(method, bytes):\n+        method = method.decode('utf-8')\n+    elif not isinstance(method, str):\n+        method = str(method)\n     str = str\n     bytes = bytes\n     basestring = (str, bytes)\ndiff --git a/requests/sessions.py b/requests/sessions.py\nindex d701ff2e..a9f9394e 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -13,6 +13,7 @@ from collections import Mapping\n from datetime import datetime\n \n from .auth import _basic_auth_str\n+\n from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str\n from .cookies import (\n     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)\n@@ -375,6 +376,7 @@ class Session(SessionRedirectMixin):\n         )\n         return p\n \n+\n     def request(self, method, url,\n         params=None,\n         data=None,\n@@ -393,6 +395,91 @@ class Session(SessionRedirectMixin):\n         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n         Returns :class:`Response <Response>` object.\n \n+        :param method: method for the new :class:`Request` object.\n+        :param url: URL for the new :class:`Request` object.\n+        :param params: (optional) Dictionary or bytes to be sent in the query\n+            string for the :class:`Request`.\n+        :param data: (optional) Dictionary, bytes, or file-like object to send\n+            in the body of the :class:`Request`.\n+        :param json: (optional) json to send in the body of the\n+            :class:`Request`.\n+        :param headers: (optional) Dictionary of HTTP Headers to send with the\n+            :class:`Request`.\n+        :param cookies: (optional) Dict or CookieJar object to send with the\n+            :class:`Request`.\n+        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n+            for multipart encoding upload.\n+        :param auth: (optional) Auth tuple or callable to enable\n+            Basic/Digest/Custom HTTP Auth.\n+        :param timeout: (optional) How long to wait for the server to send\n+            data before giving up, as a float, or a :ref:`(connect timeout,\n+            read timeout) <timeouts>` tuple.\n+        :type timeout: float or tuple\n+        :param allow_redirects: (optional) Set to True by default.\n+        :type allow_redirects: bool\n+        :param proxies: (optional) Dictionary mapping protocol or protocol and\n+            hostname to the URL of the proxy.\n+        :param stream: (optional) whether to immediately download the response\n+            content. Defaults to ``False``.\n+        :param verify: (optional) whether the SSL cert will be verified.\n+            A CA_BUNDLE path can also be provided. Defaults to ``True``.\n+        :param cert: (optional) if String, path to ssl client cert file (.pem).\n+            If Tuple, ('cert', 'key') pair.\n+        :rtype: requests.Response\n+        \"\"\"\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n+\n+        # Create the Request.\n+        req = Request(\n+            method=method.upper(),\n+            url=url,\n+            headers=headers,\n+            files=files,\n+            data=data or {},\n+            json=json,\n+            params=params or {},\n+            auth=auth,\n+            cookies=cookies,\n+            hooks=hooks,\n+        )\n+        prep = self.prepare_request(req)\n+\n+        proxies = proxies or {}\n+\n+        settings = self.merge_environment_settings(\n+            prep.url, proxies, stream, verify, cert\n+        )\n+\n+        # Send the request.\n+        send_kwargs = {\n+            'timeout': timeout,\n+            'allow_redirects': allow_redirects,\n+        }\n+        send_kwargs.update(settings)\n+        resp = self.send(prep, **send_kwargs)\n+\n+        return resp\n+        params=None,\n+        data=None,\n+        headers=None,\n+        cookies=None,\n+        files=None,\n+        auth=None,\n+        timeout=None,\n+        allow_redirects=True,\n+        proxies=None,\n+        hooks=None,\n+        stream=None,\n+        verify=None,\n+        cert=None,\n+        json=None):\n+        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n+        Returns :class:`Response <Response>` object.\n+\n         :param method: method for the new :class:`Request` object.\n         :param url: URL for the new :class:`Request` object.\n         :param params: (optional) Dictionary or bytes to be sent in the query\n@@ -425,11 +512,21 @@ class Session(SessionRedirectMixin):\n             If Tuple, ('cert', 'key') pair.\n         \"\"\"\n \n-        method = builtin_str(method)\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n \n         # Create the Request.\n         req = Request(\n-            method = method.upper(),\n+\n+        # Handle both string and binary string methods\n+        if isinstance(method, bytes):\n+            method = method.decode('utf-8')\n+        elif not isinstance(method, str):\n+            method = str(method)\n             url = url,\n             headers = headers,\n             files = files,\n"
  }
}