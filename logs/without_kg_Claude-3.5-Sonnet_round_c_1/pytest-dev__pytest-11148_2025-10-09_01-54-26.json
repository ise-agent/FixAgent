{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/pytest/src/_pytest/pathlib.py lines 524-540)": "\n    if mode is ImportMode.importlib:\n        module_name = module_name_from_path(path, root)\n\n        for meta_importer in sys.meta_path:\n            spec = meta_importer.find_spec(module_name, [str(path.parent)])\n            if spec is not None:\n                break\n        else:\n            spec = importlib.util.spec_from_file_location(module_name, str(path))\n\n        if spec is None:\n            raise ImportError(f\"Can't find module {module_name} at location {path}\")\n        mod = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = mod\n        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n        insert_missing_modules(sys.modules, module_name)\n        \n        # Also register under canonical name if it's different from the unique path-based name\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            pkg_root = pkg_path.parent\n            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n            if names[-1] == \"__init__\":\n                names.pop()\n            canonical_name = \".\".join(names)\n            if canonical_name != module_name and canonical_name not in sys.modules:\n                sys.modules[canonical_name] = mod\n                insert_missing_modules(sys.modules, canonical_name)\n        \n        return mod\n",
    "Location 2 (/root/hy/projects_1/pytest/src/_pytest/pathlib.py lines 627-666)": "\ndef insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n    \"\"\"\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n\n    When we want to import a module as \"src.tests.test_foo\" for example, we need\n    to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n    otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n    \"\"\"\n    module_parts = module_name.split(\".\")\n    child_module: Union[ModuleType, None] = None\n    module: Union[ModuleType, None] = None\n    child_name: str = \"\"\n    while module_name:\n        if module_name not in modules:\n            try:\n                # If sys.meta_path is empty, calling import_module will issue\n                # a warning and raise ModuleNotFoundError. To avoid the\n                # warning, we check sys.meta_path explicitly and raise the error\n                # ourselves to fall back to creating a dummy module.\n                if not sys.meta_path:\n                    raise ModuleNotFoundError\n                module = importlib.import_module(module_name)\n            except ModuleNotFoundError:\n                module = ModuleType(\n                    module_name,\n                    doc=\"Empty module created by pytest's importmode=importlib.\",\n                )\n        else:\n            module = modules[module_name]\n        if child_module:\n            # Add child attribute to the parent that can reference the child\n            # modules.\n            if not hasattr(module, child_name):\n                setattr(module, child_name, child_module)\n        modules[module_name] = module\n        # Keep track of the child module while moving up the tree.\n        child_module, child_name = module, module_name.rpartition(\".\")[-1]\n        module_parts.pop(-1)\n        module_name = \".\".join(module_parts)\n",
    "Location 3 (/root/hy/projects_1/pytest/src/_pytest/pathlib.py lines 606-624)": "\ndef module_name_from_path(path: Path, root: Path) -> str:\n    \"\"\"\n    Return a dotted module name based on the given path, anchored on root.\n\n    For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n    resulting module name will be \"src.tests.test_foo\".\n    \"\"\"\n    path = path.with_suffix(\"\")\n    try:\n        relative_path = path.relative_to(root)\n    except ValueError:\n        # If we can't get a relative path to root, use the full path, except\n        # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n        path_parts = path.parts[1:]\n    else:\n        # Use the parts for the relative path to the root path.\n        path_parts = relative_path.parts\n\n    return \".\".join(path_parts)\n\n\ndef canonical_module_name_from_path(path: Path) -> Optional[str]:\n    \"\"\"\n    Return the canonical module name that would be used in normal Python imports.\n    This determines the proper package structure by finding __init__.py files.\n    \"\"\"\n    try:\n        pkg_path = resolve_package_path(path)\n        if pkg_path is None:\n            return None\n        \n        # Get the module name relative to the package root\n        relative_path = path.with_suffix(\"\").relative_to(pkg_path.parent)\n        return \".\".join(relative_path.parts)\n    except (ValueError, OSError):\n        return None\n",
    "Location 4 (/root/hy/projects_1/pytest/src/_pytest/pathlib.py lines 542-567)": "\n    pkg_path = resolve_package_path(path)\n    if pkg_path is not None:\n        pkg_root = pkg_path.parent\n        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n        if names[-1] == \"__init__\":\n            names.pop()\n        module_name = \".\".join(names)\n        canonical_name = module_name\n    else:\n        pkg_root = path.parent\n        module_name = path.stem\n        canonical_name = module_name\n\n    # Change sys.path permanently: restoring it at the end of this function would cause surprising\n    # problems because of delayed imports: for example, a conftest.py file imported by this function\n    # might have local imports, which would fail at runtime if we restored sys.path.\n    if mode is ImportMode.append:\n        if str(pkg_root) not in sys.path:\n            sys.path.append(str(pkg_root))\n    elif mode is ImportMode.prepend:\n        if str(pkg_root) != sys.path[0]:\n            sys.path.insert(0, str(pkg_root))\n    else:\n        assert_never(mode)\n\n    importlib.import_module(module_name)\n\n    mod = sys.modules[module_name]\n    \n    # For importlib mode, also register under canonical name if different\n    if canonical_name != module_name and canonical_name not in sys.modules:\n        sys.modules[canonical_name] = mod\n",
    "Location 5 (/root/hy/projects_1/pytest/src/_pytest/pathlib.py lines 668-682)": "\ndef resolve_package_path(path: Path) -> Optional[Path]:\n    \"\"\"Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n\n    Returns None if it can not be determined.\n    \"\"\"\n    result = None\n    for parent in itertools.chain((path,), path.parents):\n        if parent.is_dir():\n            if not parent.joinpath(\"__init__.py\").is_file():\n                break\n            if not parent.name.isidentifier():\n                break\n            result = parent\n    return result\n\n\ndef get_canonical_module_name(path: Path, root: Path) -> Optional[str]:\n    \"\"\"Get the canonical module name that would be used in normal imports.\n    \n    Returns None if the path is not part of a proper Python package.\n    \"\"\"\n    package_path = resolve_package_path(path)\n    if package_path is None:\n        return None\n    \n    # Get the relative path from the package root to the file\n    try:\n        if path.is_file():\n            # For files, use parent directory and stem\n            rel_path = path.parent.relative_to(package_path)\n            module_parts = list(rel_path.parts) + [path.stem]\n        else:\n            # For directories, use the directory itself\n            rel_path = path.relative_to(package_path)\n            module_parts = list(rel_path.parts)\n    except ValueError:\n        return None\n    \n    # Add the package name itself\n    module_parts = [package_path.name] + module_parts\n    \n    # Filter out empty parts and validate identifiers\n    module_parts = [part for part in module_parts if part and part.isidentifier()]\n    \n    if not module_parts:\n        return None\n    \n    return \".\".join(module_parts)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/pytest/src/_pytest/pathlib.py lines 524-540)": [
      "\n    if mode is ImportMode.importlib:\n        module_name = module_name_from_path(path, root)\n\n        for meta_importer in sys.meta_path:\n            spec = meta_importer.find_spec(module_name, [str(path.parent)])\n            if spec is not None:\n                break\n        else:\n            spec = importlib.util.spec_from_file_location(module_name, str(path))\n\n        if spec is None:\n            raise ImportError(f\"Can't find module {module_name} at location {path}\")\n        mod = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = mod\n        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n        insert_missing_modules(sys.modules, module_name)\n        \n        # Also register under canonical name if different from path-based name\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            pkg_root = pkg_path.parent\n            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n            if names[-1] == \"__init__\":\n                names.pop()\n            canonical_name = \".\".join(names)\n            if canonical_name != module_name and canonical_name not in sys.modules:\n                sys.modules[canonical_name] = mod\n                insert_missing_modules(sys.modules, canonical_name)\n        \n        return mod\n",
      "\n    if mode is ImportMode.importlib:\n        module_name = module_name_from_path(path, root)\n\n        for meta_importer in sys.meta_path:\n            spec = meta_importer.find_spec(module_name, [str(path.parent)])\n            if spec is not None:\n                break\n        else:\n            spec = importlib.util.spec_from_file_location(module_name, str(path))\n\n        if spec is None:\n            raise ImportError(f\"Can't find module {module_name} at location {path}\")\n        mod = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = mod\n        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n        insert_missing_modules(sys.modules, module_name)\n        \n        # Also register module under its canonical name if it's part of a package\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            pkg_root = pkg_path.parent\n            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n            if names[-1] == \"__init__\":\n                names.pop()\n            canonical_name = \".\".join(names)\n            if canonical_name != module_name and canonical_name not in sys.modules:\n                sys.modules[canonical_name] = mod\n                insert_missing_modules(sys.modules, canonical_name)\n        \n        return mod\n",
      "\n    if mode is ImportMode.importlib:\n        module_name = module_name_from_path(path, root)\n\n        for meta_importer in sys.meta_path:\n            spec = meta_importer.find_spec(module_name, [str(path.parent)])\n            if spec is not None:\n                break\n        else:\n            spec = importlib.util.spec_from_file_location(module_name, str(path))\n\n        if spec is None:\n            raise ImportError(f\"Can't find module {module_name} at location {path}\")\n        mod = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = mod\n        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n        insert_missing_modules(sys.modules, module_name)\n        \n        # Also register module under its canonical name if it's part of a package\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            pkg_root = pkg_path.parent\n            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n            if names[-1] == \"__init__\":\n                names.pop()\n            canonical_name = \".\".join(names)\n            if canonical_name != module_name and canonical_name not in sys.modules:\n                sys.modules[canonical_name] = mod\n                insert_missing_modules(sys.modules, canonical_name)\n        \n        return mod\n",
      "\n    if mode is ImportMode.importlib:\n        module_name = module_name_from_path(path, root)\n\n        for meta_importer in sys.meta_path:\n            spec = meta_importer.find_spec(module_name, [str(path.parent)])\n            if spec is not None:\n                break\n        else:\n            spec = importlib.util.spec_from_file_location(module_name, str(path))\n\n        if spec is None:\n            raise ImportError(f\"Can't find module {module_name} at location {path}\")\n        mod = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = mod\n        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n        insert_missing_modules(sys.modules, module_name)\n        \n        # Also register under canonical name if different from path-based name\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            pkg_root = pkg_path.parent\n            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n            if names[-1] == \"__init__\":\n                names.pop()\n            canonical_name = \".\".join(names)\n            if canonical_name != module_name and canonical_name not in sys.modules:\n                sys.modules[canonical_name] = mod\n                insert_missing_modules(sys.modules, canonical_name)\n        \n        return mod\n",
      "\n    if mode is ImportMode.importlib:\n        module_name = module_name_from_path(path, root)\n\n        for meta_importer in sys.meta_path:\n            spec = meta_importer.find_spec(module_name, [str(path.parent)])\n            if spec is not None:\n                break\n        else:\n            spec = importlib.util.spec_from_file_location(module_name, str(path))\n\n        if spec is None:\n            raise ImportError(f\"Can't find module {module_name} at location {path}\")\n        mod = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = mod\n        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n        insert_missing_modules(sys.modules, module_name)\n        \n        # Also register under canonical name if it's a package module\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            pkg_root = pkg_path.parent\n            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n            if names[-1] == \"__init__\":\n                names.pop()\n            canonical_name = \".\".join(names)\n            if canonical_name != module_name and canonical_name not in sys.modules:\n                sys.modules[canonical_name] = mod\n                insert_missing_modules(sys.modules, canonical_name)\n        \n        return mod\n",
      "\n    if mode is ImportMode.importlib:\n        module_name = module_name_from_path(path, root)\n\n        for meta_importer in sys.meta_path:\n            spec = meta_importer.find_spec(module_name, [str(path.parent)])\n            if spec is not None:\n                break\n        else:\n            spec = importlib.util.spec_from_file_location(module_name, str(path))\n\n        if spec is None:\n            raise ImportError(f\"Can't find module {module_name} at location {path}\")\n        mod = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = mod\n        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n        insert_missing_modules(sys.modules, module_name)\n        \n        # Also register under canonical name if it exists\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            pkg_root = pkg_path.parent\n            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n            if names[-1] == \"__init__\":\n                names.pop()\n            canonical_name = \".\".join(names)\n            if canonical_name != module_name:\n                sys.modules[canonical_name] = mod\n                insert_missing_modules(sys.modules, canonical_name)\n        \n        return mod\n",
      "\n    if mode is ImportMode.importlib:\n        module_name = module_name_from_path(path, root)\n\n        for meta_importer in sys.meta_path:\n            spec = meta_importer.find_spec(module_name, [str(path.parent)])\n            if spec is not None:\n                break\n        else:\n            spec = importlib.util.spec_from_file_location(module_name, str(path))\n\n        if spec is None:\n            raise ImportError(f\"Can't find module {module_name} at location {path}\")\n        mod = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = mod\n        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n        insert_missing_modules(sys.modules, module_name)\n        \n        # Also register under canonical module name if different\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            pkg_root = pkg_path.parent\n            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n            if names[-1] == \"__init__\":\n                names.pop()\n            canonical_name = \".\".join(names)\n            if canonical_name != module_name and canonical_name not in sys.modules:\n                sys.modules[canonical_name] = mod\n                insert_missing_modules(sys.modules, canonical_name)\n        \n        return mod\n",
      "\n    if mode is ImportMode.importlib:\n        module_name = module_name_from_path(path, root)\n\n        for meta_importer in sys.meta_path:\n            spec = meta_importer.find_spec(module_name, [str(path.parent)])\n            if spec is not None:\n                break\n        else:\n            spec = importlib.util.spec_from_file_location(module_name, str(path))\n\n        if spec is None:\n            raise ImportError(f\"Can't find module {module_name} at location {path}\")\n        mod = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = mod\n        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n        insert_missing_modules(sys.modules, module_name)\n        \n        # Also register module under its canonical name if it's part of a package\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            pkg_root = pkg_path.parent\n            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n            if names[-1] == \"__init__\":\n                names.pop()\n            canonical_module_name = \".\".join(names)\n            # Only register if canonical name differs from unique name\n            if canonical_module_name != module_name:\n                sys.modules[canonical_module_name] = mod\n                insert_missing_modules(sys.modules, canonical_module_name)\n        \n        return mod\n"
    ],
    "Location 2 (/root/hy/projects_1/pytest/src/_pytest/pathlib.py lines 627-666)": [
      "\ndef insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n    \"\"\"\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n\n    When we want to import a module as \"src.tests.test_foo\" for example, we need\n    to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n    otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n    \"\"\"\n    module_parts = module_name.split(\".\")\n    child_module: Union[ModuleType, None] = None\n    module: Union[ModuleType, None] = None\n    child_name: str = \"\"\n    while module_name:\n        if module_name not in modules:\n            try:\n                # If sys.meta_path is empty, calling import_module will issue\n                # a warning and raise ModuleNotFoundError. To avoid the\n                # warning, we check sys.meta_path explicitly and raise the error\n                # ourselves to fall back to creating a dummy module.\n                if not sys.meta_path:\n                    raise ModuleNotFoundError\n                module = importlib.import_module(module_name)\n            except ModuleNotFoundError:\n                module = ModuleType(\n                    module_name,\n                    doc=\"Empty module created by pytest's importmode=importlib.\",\n                )\n        else:\n            module = modules[module_name]\n        if child_module:\n            # Add child attribute to the parent that can reference the child\n            # modules.\n            if not hasattr(module, child_name):\n                setattr(module, child_name, child_module)\n                modules[module_name] = module\n                # Also register in sys.modules to ensure consistency\n                sys.modules[module_name] = module\n        # Keep track of the child module while moving up the tree.\n        child_module, child_name = module, module_name.rpartition(\".\")[-1]\n        module_parts.pop(-1)\n        module_name = \".\".join(module_parts)\n",
      "\ndef insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n    \"\"\"\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n\n    When we want to import a module as \"src.tests.test_foo\" for example, we need\n    to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n    otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n    \"\"\"\n    module_parts = module_name.split(\".\")\n    child_module: Union[ModuleType, None] = None\n    module: Union[ModuleType, None] = None\n    child_name: str = \"\"\n    while module_name:\n        if module_name not in modules:\n            try:\n                # If sys.meta_path is empty, calling import_module will issue\n                # a warning and raise ModuleNotFoundError. To avoid the\n                # warning, we check sys.meta_path explicitly and raise the error\n                # ourselves to fall back to creating a dummy module.\n                if not sys.meta_path:\n                    raise ModuleNotFoundError\n                module = importlib.import_module(module_name)\n            except ModuleNotFoundError:\n                module = ModuleType(\n                    module_name,\n                    doc=\"Empty module created by pytest's importmode=importlib.\",\n                )\n        else:\n            module = modules[module_name]\n        if child_module:\n            # Add child attribute to the parent that can reference the child\n            # modules.\n            if not hasattr(module, child_name):\n                setattr(module, child_name, child_module)\n                modules[module_name] = module\n        # Keep track of the child module while moving up the tree.\n        child_module, child_name = module, module_name.rpartition(\".\")[-1]\n        module_parts.pop(-1)\n        module_name = \".\".join(module_parts)\n",
      "\ndef insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n    \"\"\"\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n\n    When we want to import a module as \"src.tests.test_foo\" for example, we need\n    to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n    otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n    \"\"\"\n    module_parts = module_name.split(\".\")\n    child_module: Union[ModuleType, None] = None\n    module: Union[ModuleType, None] = None\n    child_name: str = \"\"\n    while module_name:\n        if module_name not in modules:\n            try:\n                # If sys.meta_path is empty, calling import_module will issue\n                # a warning and raise ModuleNotFoundError. To avoid the\n                # warning, we check sys.meta_path explicitly and raise the error\n                # ourselves to fall back to creating a dummy module.\n                if not sys.meta_path:\n                    raise ModuleNotFoundError\n                module = importlib.import_module(module_name)\n            except ModuleNotFoundError:\n                module = ModuleType(\n                    module_name,\n                    doc=\"Empty module created by pytest's importmode=importlib.\",\n                )\n        else:\n            module = modules[module_name]\n        if child_module:\n            # Add child attribute to the parent that can reference the child\n            # modules.\n            if not hasattr(module, child_name):\n                setattr(module, child_name, child_module)\n                modules[module_name] = module\n        # Keep track of the child module while moving up the tree.\n        child_module, child_name = module, module_name.rpartition(\".\")[-1]\n        module_parts.pop(-1)\n        module_name = \".\".join(module_parts)\n",
      "\ndef insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n    \"\"\"\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n\n    When we want to import a module as \"src.tests.test_foo\" for example, we need\n    to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n    otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n    \"\"\"\n    module_parts = module_name.split(\".\")\n    child_module: Union[ModuleType, None] = None\n    module: Union[ModuleType, None] = None\n    child_name: str = \"\"\n    while module_name:\n        if module_name not in modules:\n            try:\n                # If sys.meta_path is empty, calling import_module will issue\n                # a warning and raise ModuleNotFoundError. To avoid the\n                # warning, we check sys.meta_path explicitly and raise the error\n                # ourselves to fall back to creating a dummy module.\n                if not sys.meta_path:\n                    raise ModuleNotFoundError\n                module = importlib.import_module(module_name)\n            except ModuleNotFoundError:\n                module = ModuleType(\n                    module_name,\n                    doc=\"Empty module created by pytest's importmode=importlib.\",\n                )\n        else:\n            module = modules[module_name]\n        if child_module:\n            # Add child attribute to the parent that can reference the child\n            # modules.\n            if not hasattr(module, child_name):\n                setattr(module, child_name, child_module)\n                modules[module_name] = module\n                # Also register in sys.modules to ensure consistency\n                sys.modules[module_name] = module\n        # Keep track of the child module while moving up the tree.\n        child_module, child_name = module, module_name.rpartition(\".\")[-1]\n        module_parts.pop(-1)\n        module_name = \".\".join(module_parts)\n",
      "\ndef insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n    \"\"\"\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n\n    When we want to import a module as \"src.tests.test_foo\" for example, we need\n    to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n    otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n    \"\"\"\n    module_parts = module_name.split(\".\")\n    child_module: Union[ModuleType, None] = None\n    module: Union[ModuleType, None] = None\n    child_name: str = \"\"\n    while module_name:\n        if module_name not in modules:\n            try:\n                # If sys.meta_path is empty, calling import_module will issue\n                # a warning and raise ModuleNotFoundError. To avoid the\n                # warning, we check sys.meta_path explicitly and raise the error\n                # ourselves to fall back to creating a dummy module.\n                if not sys.meta_path:\n                    raise ModuleNotFoundError\n                module = importlib.import_module(module_name)\n            except ModuleNotFoundError:\n                module = ModuleType(\n                    module_name,\n                    doc=\"Empty module created by pytest's importmode=importlib.\",\n                )\n        else:\n            module = modules[module_name]\n        if child_module:\n            # Add child attribute to the parent that can reference the child\n            # modules.\n            if not hasattr(module, child_name):\n                setattr(module, child_name, child_module)\n        modules[module_name] = module\n        # Keep track of the child module while moving up the tree.\n        child_module, child_name = module, module_name.rpartition(\".\")[-1]\n        module_parts.pop(-1)\n        module_name = \".\".join(module_parts)\n",
      "\ndef insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n    \"\"\"\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n\n    When we want to import a module as \"src.tests.test_foo\" for example, we need\n    to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n    otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n    \"\"\"\n    module_parts = module_name.split(\".\")\n    child_module: Union[ModuleType, None] = None\n    module: Union[ModuleType, None] = None\n    child_name: str = \"\"\n    while module_name:\n        if module_name not in modules:\n            try:\n                # If sys.meta_path is empty, calling import_module will issue\n                # a warning and raise ModuleNotFoundError. To avoid the\n                # warning, we check sys.meta_path explicitly and raise the error\n                # ourselves to fall back to creating a dummy module.\n                if not sys.meta_path:\n                    raise ModuleNotFoundError\n                module = importlib.import_module(module_name)\n            except ModuleNotFoundError:\n                module = ModuleType(\n                    module_name,\n                    doc=\"Empty module created by pytest's importmode=importlib.\",\n                )\n        else:\n            module = modules[module_name]\n        if child_module:\n            # Add child attribute to the parent that can reference the child\n            # modules.\n            if not hasattr(module, child_name):\n                setattr(module, child_name, child_module)\n        modules[module_name] = module\n        # Keep track of the child module while moving up the tree.\n        child_module, child_name = module, module_name.rpartition(\".\")[-1]\n        module_parts.pop(-1)\n        module_name = \".\".join(module_parts)\n",
      "\ndef insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n    \"\"\"\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n\n    When we want to import a module as \"src.tests.test_foo\" for example, we need\n    to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n    otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n    \"\"\"\n    module_parts = module_name.split(\".\")\n    child_module: Union[ModuleType, None] = None\n    module: Union[ModuleType, None] = None\n    child_name: str = \"\"\n    while module_name:\n        if module_name not in modules:\n            try:\n                # If sys.meta_path is empty, calling import_module will issue\n                # a warning and raise ModuleNotFoundError. To avoid the\n                # warning, we check sys.meta_path explicitly and raise the error\n                # ourselves to fall back to creating a dummy module.\n                if not sys.meta_path:\n                    raise ModuleNotFoundError\n                module = importlib.import_module(module_name)\n            except ModuleNotFoundError:\n                module = ModuleType(\n                    module_name,\n                    doc=\"Empty module created by pytest's importmode=importlib.\",\n                )\n        else:\n            module = modules[module_name]\n        if child_module:\n            # Add child attribute to the parent that can reference the child\n            # modules.\n            if not hasattr(module, child_name):\n                setattr(module, child_name, child_module)\n        modules[module_name] = module\n        # Keep track of the child module while moving up the tree.\n        child_module, child_name = module, module_name.rpartition(\".\")[-1]\n        module_parts.pop(-1)\n        module_name = \".\".join(module_parts)\n",
      "\ndef insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n    \"\"\"\n    Used by ``import_path`` to create intermediate modules when using mode=importlib.\n\n    When we want to import a module as \"src.tests.test_foo\" for example, we need\n    to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n    otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n    \"\"\"\n    module_parts = module_name.split(\".\")\n    child_module: Union[ModuleType, None] = None\n    module: Union[ModuleType, None] = None\n    child_name: str = \"\"\n    while module_name:\n        if module_name not in modules:\n            try:\n                # If sys.meta_path is empty, calling import_module will issue\n                # a warning and raise ModuleNotFoundError. To avoid the\n                # warning, we check sys.meta_path explicitly and raise the error\n                # ourselves to fall back to creating a dummy module.\n                if not sys.meta_path:\n                    raise ModuleNotFoundError\n                module = importlib.import_module(module_name)\n            except ModuleNotFoundError:\n                module = ModuleType(\n                    module_name,\n                    doc=\"Empty module created by pytest's importmode=importlib.\",\n                )\n        else:\n            module = modules[module_name]\n        if child_module:\n            # Add child attribute to the parent that can reference the child\n            # modules.\n            if not hasattr(module, child_name):\n                setattr(module, child_name, child_module)\n        modules[module_name] = module\n        # Keep track of the child module while moving up the tree.\n        child_module, child_name = module, module_name.rpartition(\".\")[-1]\n        module_parts.pop(-1)\n        module_name = \".\".join(module_parts)\n"
    ],
    "Location 3 (/root/hy/projects_1/pytest/src/_pytest/pathlib.py lines 606-624)": [
      "\ndef module_name_from_path(path: Path, root: Path) -> str:\n    \"\"\"\n    Return a dotted module name based on the given path, anchored on root.\n\n    For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n    resulting module name will be \"src.tests.test_foo\".\n    \"\"\"\n    path = path.with_suffix(\"\")\n    try:\n        relative_path = path.relative_to(root)\n    except ValueError:\n        # If we can't get a relative path to root, use the full path, except\n        # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n        path_parts = path.parts[1:]\n    else:\n        # Use the parts for the relative path to the root path.\n        path_parts = relative_path.parts\n\n    return \".\".join(path_parts)\n\n\ndef canonical_module_name_from_path(path: Path) -> Optional[str]:\n    \"\"\"\n    Return the canonical module name that would be used in normal Python imports,\n    based on the package structure determined by __init__.py files.\n    \"\"\"\n    try:\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            # Get the relative path from the package root to the module\n            relative_path = path.with_suffix(\"\").relative_to(pkg_path)\n            return \".\".join(relative_path.parts)\n    except (ValueError, OSError):\n        pass\n    return None\n",
      "\ndef module_name_from_path(path: Path, root: Path) -> str:\n    \"\"\"\n    Return a dotted module name based on the given path, anchored on root.\n\n    For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n    resulting module name will be \"src.tests.test_foo\".\n    \"\"\"\n    path = path.with_suffix(\"\")\n    try:\n        relative_path = path.relative_to(root)\n    except ValueError:\n        # If we can't get a relative path to root, use the full path, except\n        # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n        path_parts = path.parts[1:]\n    else:\n        # Use the parts for the relative path to the root path.\n        path_parts = relative_path.parts\n\n    return \".\".join(path_parts)\n\n\ndef canonical_module_name_from_path(path: Path) -> Optional[str]:\n    \"\"\"\n    Return the canonical module name that would be used in normal Python imports.\n    \n    This determines the proper package structure by finding the Python package\n    containing the module and constructing the canonical import name.\n    \"\"\"\n    try:\n        pkg_path = resolve_package_path(path)\n        if pkg_path is None:\n            return None\n        \n        # Get the relative path from the package root to the module\n        module_path = path.with_suffix(\"\")\n        relative_path = module_path.relative_to(pkg_path.parent)\n        \n        # Convert path parts to dotted module name\n        parts = []\n        if pkg_path.name != \"__init__.py\":\n            parts.append(pkg_path.parent.name)\n        parts.extend(relative_path.parts)\n        \n        return \".\".join(parts)\n    except (ValueError, OSError):\n        return None\n",
      "\ndef module_name_from_path(path: Path, root: Path) -> str:\n    \"\"\"\n    Return a dotted module name based on the given path, anchored on root.\n\n    For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n    resulting module name will be \"src.tests.test_foo\".\n    \"\"\"\n    path = path.with_suffix(\"\")\n    try:\n        relative_path = path.relative_to(root)\n    except ValueError:\n        # If we can't get a relative path to root, use the full path, except\n        # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n        path_parts = path.parts[1:]\n    else:\n        # Use the parts for the relative path to the root path.\n        path_parts = relative_path.parts\n\n    return \".\".join(path_parts)\n\n\ndef canonical_module_name_from_path(path: Path) -> Optional[str]:\n    \"\"\"\n    Return the canonical module name based on Python package structure.\n    \n    This determines what the module name would be in a normal import by finding\n    the package structure using __init__.py files.\n    \"\"\"\n    try:\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            relative_path = path.with_suffix(\"\").relative_to(pkg_path)\n            return \".\".join(relative_path.parts)\n    except (ValueError, OSError):\n        pass\n    return None\n",
      "\ndef module_name_from_path(path: Path, root: Path) -> str:\n    \"\"\"\n    Return a dotted module name based on the given path, anchored on root.\n\n    For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n    resulting module name will be \"src.tests.test_foo\".\n    \"\"\"\n    path = path.with_suffix(\"\")\n    try:\n        relative_path = path.relative_to(root)\n    except ValueError:\n        # If we can't get a relative path to root, use the full path, except\n        # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n        path_parts = path.parts[1:]\n    else:\n        # Use the parts for the relative path to the root path.\n        path_parts = relative_path.parts\n\n    return \".\".join(path_parts)\n\n\ndef canonical_module_name_from_path(path: Path) -> Optional[str]:\n    \"\"\"\n    Return the canonical module name that would be used in normal Python imports,\n    based on the package structure determined by __init__.py files.\n    \"\"\"\n    try:\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            # Get the relative path from the package root to the module\n            relative_path = path.with_suffix(\"\").relative_to(pkg_path.parent)\n            return \".\".join(relative_path.parts)\n    except (ValueError, OSError):\n        pass\n    return None\n",
      "\ndef module_name_from_path(path: Path, root: Path) -> str:\n    \"\"\"\n    Return a dotted module name based on the given path, anchored on root.\n\n    For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n    resulting module name will be \"src.tests.test_foo\".\n    \"\"\"\n    path = path.with_suffix(\"\")\n    try:\n        relative_path = path.relative_to(root)\n    except ValueError:\n        # If we can't get a relative path to root, use the full path, except\n        # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n        path_parts = path.parts[1:]\n    else:\n        # Use the parts for the relative path to the root path.\n        path_parts = relative_path.parts\n\n    return \".\".join(path_parts)\n\n\ndef canonical_module_name_from_path(path: Path, root: Path) -> Optional[str]:\n    \"\"\"\n    Return the canonical dotted module name that would be used in normal imports,\n    based on the Python package structure (presence of __init__.py files).\n    \n    Returns None if the path is not part of a Python package.\n    \"\"\"\n    try:\n        pkg_path = resolve_package_path(path)\n        if pkg_path is None:\n            return None\n        \n        # Get the module path relative to the package root\n        module_path = path.with_suffix(\"\")\n        try:\n            relative_path = module_path.relative_to(pkg_path)\n            return \".\".join(relative_path.parts)\n        except ValueError:\n            return None\n    except Exception:\n        return None\n",
      "\ndef module_name_from_path(path: Path, root: Path) -> str:\n    \"\"\"\n    Return a dotted module name based on the given path, anchored on root.\n\n    For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n    resulting module name will be \"src.tests.test_foo\".\n    \"\"\"\n    path = path.with_suffix(\"\")\n    try:\n        relative_path = path.relative_to(root)\n    except ValueError:\n        # If we can't get a relative path to root, use the full path, except\n        # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n        path_parts = path.parts[1:]\n    else:\n        # Use the parts for the relative path to the root path.\n        path_parts = relative_path.parts\n\n    return \".\".join(path_parts)\n\n\ndef canonical_module_name_from_path(path: Path) -> Optional[str]:\n    \"\"\"\n    Return the canonical module name that would be used in normal Python imports.\n    \n    This determines the proper package structure by finding the Python package\n    hierarchy and constructing the canonical dotted import name.\n    \"\"\"\n    try:\n        # Use resolve_package_path to find the proper package structure\n        pkg_path = resolve_package_path(path)\n        if pkg_path is None:\n            return None\n        \n        # Get the relative path from package root to the module\n        relative_path = path.with_suffix(\"\").relative_to(pkg_path)\n        \n        # Construct the canonical module name\n        parts = [pkg_path.name] + list(relative_path.parts)\n        return \".\".join(parts)\n    except (ValueError, OSError):\n        return None\n",
      "\ndef module_name_from_path(path: Path, root: Path) -> str:\n    \"\"\"\n    Return a dotted module name based on the given path, anchored on root.\n\n    For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n    resulting module name will be \"src.tests.test_foo\".\n    \"\"\"\n    path = path.with_suffix(\"\")\n    try:\n        relative_path = path.relative_to(root)\n    except ValueError:\n        # If we can't get a relative path to root, use the full path, except\n        # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n        path_parts = path.parts[1:]\n    else:\n        # Use the parts for the relative path to the root path.\n        path_parts = relative_path.parts\n\n    return \".\".join(path_parts)\n\n\ndef canonical_module_name_from_path(path: Path, root: Path) -> Optional[str]:\n    \"\"\"\n    Return the canonical dotted module name that would be used in normal imports,\n    based on the given path and package structure determined by __init__.py files.\n    \n    Returns None if the path is not part of a Python package.\n    \"\"\"\n    try:\n        pkg_path = resolve_package_path(path)\n        if pkg_path is None:\n            return None\n        \n        # Get the module path relative to the package root\n        module_path = path.with_suffix(\"\")\n        pkg_relative = module_path.relative_to(pkg_path.parent)\n        \n        # Convert path parts to dotted module name\n        return \".\".join(pkg_relative.parts)\n    except (ValueError, OSError):\n        return None\n",
      "\ndef module_name_from_path(path: Path, root: Path) -> str:\n    \"\"\"\n    Return a dotted module name based on the given path, anchored on root.\n\n    For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n    resulting module name will be \"src.tests.test_foo\".\n    \"\"\"\n    path = path.with_suffix(\"\")\n    try:\n        relative_path = path.relative_to(root)\n    except ValueError:\n        # If we can't get a relative path to root, use the full path, except\n        # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n        path_parts = path.parts[1:]\n    else:\n        # Use the parts for the relative path to the root path.\n        path_parts = relative_path.parts\n\n    return \".\".join(path_parts)\n\n\ndef canonical_module_name_from_path(path: Path) -> Optional[str]:\n    \"\"\"\n    Return the canonical module name that would be used in normal Python imports.\n    \n    This determines the proper package structure by finding the Python package\n    path and deriving the canonical import name.\n    \"\"\"\n    try:\n        pkg_path = resolve_package_path(path)\n        if pkg_path is not None:\n            # Get relative path from package root to the module\n            relative_path = path.with_suffix(\"\").relative_to(pkg_path)\n            if relative_path.parts:\n                return \".\".join(relative_path.parts)\n    except (ValueError, OSError):\n        pass\n    return None\n"
    ],
    "Location 4 (/root/hy/projects_1/pytest/src/_pytest/pathlib.py lines 542-567)": [
      "\n    pkg_path = resolve_package_path(path)\n    if pkg_path is not None:\n        pkg_root = pkg_path.parent\n        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n        if names[-1] == \"__init__\":\n            names.pop()\n        module_name = \".\".join(names)\n        canonical_module_name = module_name\n    else:\n        pkg_root = path.parent\n        module_name = path.stem\n        canonical_module_name = module_name\n\n    # Change sys.path permanently: restoring it at the end of this function would cause surprising\n    # problems because of delayed imports: for example, a conftest.py file imported by this function\n    # might have local imports, which would fail at runtime if we restored sys.path.\n    if mode is ImportMode.append:\n        if str(pkg_root) not in sys.path:\n            sys.path.append(str(pkg_root))\n    elif mode is ImportMode.prepend:\n        if str(pkg_root) != sys.path[0]:\n            sys.path.insert(0, str(pkg_root))\n    else:\n        assert_never(mode)\n\n    importlib.import_module(canonical_module_name)\n\n    mod = sys.modules[canonical_module_name]\n",
      "\n    pkg_path = resolve_package_path(path)\n    if pkg_path is not None:\n        pkg_root = pkg_path.parent\n        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n        if names[-1] == \"__init__\":\n            names.pop()\n        module_name = \".\".join(names)\n        canonical_module_name = module_name\n    else:\n        pkg_root = path.parent\n        module_name = path.stem\n        canonical_module_name = module_name\n\n    # Change sys.path permanently: restoring it at the end of this function would cause surprising\n    # problems because of delayed imports: for example, a conftest.py file imported by this function\n    # might have local imports, which would fail at runtime if we restored sys.path.\n    if mode is ImportMode.append:\n        if str(pkg_root) not in sys.path:\n            sys.path.append(str(pkg_root))\n    elif mode is ImportMode.prepend:\n        if str(pkg_root) != sys.path[0]:\n            sys.path.insert(0, str(pkg_root))\n    else:\n        assert_never(mode)\n\n    importlib.import_module(module_name)\n\n    mod = sys.modules[module_name]\n    # For importlib mode, also register under canonical name to ensure\n    # consistency with normal imports\n    if canonical_module_name != module_name and canonical_module_name not in sys.modules:\n        sys.modules[canonical_module_name] = mod\n",
      "\n    pkg_path = resolve_package_path(path)\n    if pkg_path is not None:\n        pkg_root = pkg_path.parent\n        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n        if names[-1] == \"__init__\":\n            names.pop()\n        module_name = \".\".join(names)\n        canonical_name = module_name\n    else:\n        pkg_root = path.parent\n        module_name = path.stem\n        canonical_name = module_name\n\n    # Change sys.path permanently: restoring it at the end of this function would cause surprising\n    # problems because of delayed imports: for example, a conftest.py file imported by this function\n    # might have local imports, which would fail at runtime if we restored sys.path.\n    if mode is ImportMode.append:\n        if str(pkg_root) not in sys.path:\n            sys.path.append(str(pkg_root))\n    elif mode is ImportMode.prepend:\n        if str(pkg_root) != sys.path[0]:\n            sys.path.insert(0, str(pkg_root))\n    else:\n        assert_never(mode)\n\n    importlib.import_module(module_name)\n\n    mod = sys.modules[module_name]\n    \n    # For importlib mode, also register under canonical name if different\n    unique_name = module_name_from_path(path, root)\n    if unique_name != canonical_name and canonical_name not in sys.modules:\n        sys.modules[canonical_name] = mod\n",
      "\n    pkg_path = resolve_package_path(path)\n    if pkg_path is not None:\n        pkg_root = pkg_path.parent\n        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n        if names[-1] == \"__init__\":\n            names.pop()\n        module_name = \".\".join(names)\n        canonical_module_name = module_name\n    else:\n        pkg_root = path.parent\n        module_name = path.stem\n        canonical_module_name = None\n\n    # Change sys.path permanently: restoring it at the end of this function would cause surprising\n    # problems because of delayed imports: for example, a conftest.py file imported by this function\n    # might have local imports, which would fail at runtime if we restored sys.path.\n    if mode is ImportMode.append:\n        if str(pkg_root) not in sys.path:\n            sys.path.append(str(pkg_root))\n    elif mode is ImportMode.prepend:\n        if str(pkg_root) != sys.path[0]:\n            sys.path.insert(0, str(pkg_root))\n    else:\n        assert_never(mode)\n\n    importlib.import_module(module_name)\n\n    mod = sys.modules[module_name]\n    \n    # For importlib mode, also register under canonical name if it exists\n    if canonical_module_name and canonical_module_name != module_name:\n        sys.modules[canonical_module_name] = mod\n",
      "\n    pkg_path = resolve_package_path(path)\n    if pkg_path is not None:\n        pkg_root = pkg_path.parent\n        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n        if names[-1] == \"__init__\":\n            names.pop()\n        canonical_module_name = \".\".join(names)\n    else:\n        pkg_root = path.parent\n        canonical_module_name = path.stem\n\n    # Change sys.path permanently: restoring it at the end of this function would cause surprising\n    # problems because of delayed imports: for example, a conftest.py file imported by this function\n    # might have local imports, which would fail at runtime if we restored sys.path.\n    if mode is ImportMode.append:\n        if str(pkg_root) not in sys.path:\n            sys.path.append(str(pkg_root))\n    elif mode is ImportMode.prepend:\n        if str(pkg_root) != sys.path[0]:\n            sys.path.insert(0, str(pkg_root))\n    else:\n        assert_never(mode)\n\n    # Import using canonical name if possible, otherwise fall back to unique name\n    try:\n        importlib.import_module(canonical_module_name)\n        mod = sys.modules[canonical_module_name]\n        # Also register under unique name for consistency\n        if canonical_module_name != module_name:\n            sys.modules[module_name] = mod\n    except ImportError:\n        # Fall back to unique name import if canonical import fails\n        importlib.import_module(module_name)\n        mod = sys.modules[module_name]\n        # Also register under canonical name if it's different\n        if canonical_module_name != module_name:\n            sys.modules[canonical_module_name] = mod\n\n    mod = sys.modules[canonical_module_name]\n",
      "\n    pkg_path = resolve_package_path(path)\n    if pkg_path is not None:\n        pkg_root = pkg_path.parent\n        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n        if names[-1] == \"__init__\":\n            names.pop()\n        module_name = \".\".join(names)\n        canonical_name = module_name\n    else:\n        pkg_root = path.parent\n        module_name = path.stem\n        canonical_name = module_name\n\n    # Change sys.path permanently: restoring it at the end of this function would cause surprising\n    # problems because of delayed imports: for example, a conftest.py file imported by this function\n    # might have local imports, which would fail at runtime if we restored sys.path.\n    if mode is ImportMode.append:\n        if str(pkg_root) not in sys.path:\n            sys.path.append(str(pkg_root))\n    elif mode is ImportMode.prepend:\n        if str(pkg_root) != sys.path[0]:\n            sys.path.insert(0, str(pkg_root))\n    else:\n        assert_never(mode)\n\n    importlib.import_module(module_name)\n\n    mod = sys.modules[module_name]\n    \n    # Also register under canonical name if different from module_name\n    unique_module_name = module_name_from_path(path, root)\n    if canonical_name != unique_module_name and canonical_name not in sys.modules:\n        sys.modules[canonical_name] = mod\n",
      "\n    pkg_path = resolve_package_path(path)\n    if pkg_path is not None:\n        pkg_root = pkg_path.parent\n        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n        if names[-1] == \"__init__\":\n            names.pop()\n        canonical_module_name = \".\".join(names)\n    else:\n        pkg_root = path.parent\n        canonical_module_name = path.stem\n\n    # Change sys.path permanently: restoring it at the end of this function would cause surprising\n    # problems because of delayed imports: for example, a conftest.py file imported by this function\n    # might have local imports, which would fail at runtime if we restored sys.path.\n    if mode is ImportMode.append:\n        if str(pkg_root) not in sys.path:\n            sys.path.append(str(pkg_root))\n    elif mode is ImportMode.prepend:\n        if str(pkg_root) != sys.path[0]:\n            sys.path.insert(0, str(pkg_root))\n    else:\n        assert_never(mode)\n\n    # For importlib mode, use the canonical module name for import\n    if canonical_module_name in sys.modules:\n        mod = sys.modules[canonical_module_name]\n    else:\n        importlib.import_module(canonical_module_name)\n        mod = sys.modules[canonical_module_name]\n        \n        # Also register under the unique path-based name for consistency\n        if module_name != canonical_module_name:\n            sys.modules[module_name] = mod\n",
      "\n    pkg_path = resolve_package_path(path)\n    if pkg_path is not None:\n        pkg_root = pkg_path.parent\n        names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n        if names[-1] == \"__init__\":\n            names.pop()\n        module_name = \".\".join(names)\n        canonical_module_name = module_name\n    else:\n        pkg_root = path.parent\n        module_name = path.stem\n        canonical_module_name = module_name\n\n    # Change sys.path permanently: restoring it at the end of this function would cause surprising\n    # problems because of delayed imports: for example, a conftest.py file imported by this function\n    # might have local imports, which would fail at runtime if we restored sys.path.\n    if mode is ImportMode.append:\n        if str(pkg_root) not in sys.path:\n            sys.path.append(str(pkg_root))\n    elif mode is ImportMode.prepend:\n        if str(pkg_root) != sys.path[0]:\n            sys.path.insert(0, str(pkg_root))\n    else:\n        assert_never(mode)\n\n    importlib.import_module(canonical_module_name)\n\n    mod = sys.modules[canonical_module_name]\n"
    ],
    "Location 5 (/root/hy/projects_1/pytest/src/_pytest/pathlib.py lines 668-682)": [
      "\ndef resolve_package_path(path: Path) -> Optional[Path]:\n    \"\"\"Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n\n    Returns None if it can not be determined.\n    \"\"\"\n    result = None\n    for parent in itertools.chain((path,), path.parents):\n        if parent.is_dir():\n            if not parent.joinpath(\"__init__.py\").is_file():\n                break\n            if not parent.name.isidentifier():\n                break\n            result = parent\n    return result\n\n\ndef get_canonical_module_name(path: Path, root: Path) -> Optional[str]:\n    \"\"\"Get the canonical module name that would be used in normal imports.\n    \n    Returns None if the path is not within a Python package structure.\n    \"\"\"\n    package_path = resolve_package_path(path)\n    if package_path is None:\n        return None\n    \n    # Get the relative path from package root to the module\n    try:\n        rel_path = path.relative_to(package_path)\n    except ValueError:\n        return None\n    \n    # Convert path to module name\n    parts = list(rel_path.parts)\n    if parts[-1].endswith('.py'):\n        parts[-1] = parts[-1][:-3]  # Remove .py extension\n    \n    # Remove __init__ if it's the last part\n    if parts[-1] == '__init__':\n        parts.pop()\n    \n    return '.'.join(parts) if parts else package_path.name\n",
      "\ndef resolve_package_path(path: Path) -> Optional[Path]:\n    \"\"\"Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n\n    Returns None if it can not be determined.\n    \"\"\"\n    result = None\n    for parent in itertools.chain((path,), path.parents):\n        if parent.is_dir():\n            if not parent.joinpath(\"__init__.py\").is_file():\n                break\n            if not parent.name.isidentifier():\n                break\n            result = parent\n    return result\n\n\ndef get_canonical_module_name(path: Path, root: Path) -> Optional[str]:\n    \"\"\"Get the canonical module name that would be used in normal imports.\n    \n    Returns None if the path is not part of a Python package.\n    \"\"\"\n    package_path = resolve_package_path(path)\n    if package_path is None:\n        return None\n    \n    # Get the relative path from package root to the file\n    try:\n        rel_path = path.relative_to(package_path)\n    except ValueError:\n        return None\n    \n    # Convert path to module name\n    parts = list(rel_path.parts)\n    if parts[-1].endswith('.py'):\n        parts[-1] = parts[-1][:-3]  # Remove .py extension\n    \n    # Remove __init__ if it's the last part\n    if parts[-1] == '__init__':\n        parts.pop()\n    \n    if not parts:\n        return package_path.name\n    \n    return package_path.name + '.' + '.'.join(parts)\n",
      "\ndef resolve_package_path(path: Path) -> Optional[Path]:\n    \"\"\"Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n\n    Returns None if it can not be determined.\n    \"\"\"\n    result = None\n    for parent in itertools.chain((path,), path.parents):\n        if parent.is_dir():\n            if not parent.joinpath(\"__init__.py\").is_file():\n                break\n            if not parent.name.isidentifier():\n                break\n            result = parent\n    return result\n\n\ndef get_canonical_module_name(path: Path) -> Optional[str]:\n    \"\"\"Get the canonical module name that would be used in normal imports.\n    \n    Returns None if the path is not part of a Python package.\n    \"\"\"\n    package_path = resolve_package_path(path)\n    if package_path is None:\n        return None\n    \n    # Get the relative path from package root to the module\n    try:\n        rel_path = path.relative_to(package_path.parent)\n    except ValueError:\n        return None\n    \n    # Convert path to module name\n    parts = list(rel_path.parts)\n    if parts[-1].endswith('.py'):\n        parts[-1] = parts[-1][:-3]  # Remove .py extension\n    \n    # Filter out non-identifier parts and __init__ modules\n    module_parts = []\n    for part in parts:\n        if part == '__init__':\n            continue\n        if not part.isidentifier():\n            return None\n        module_parts.append(part)\n    \n    return '.'.join(module_parts) if module_parts else None\n",
      "\ndef resolve_package_path(path: Path) -> Optional[Path]:\n    \"\"\"Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n\n    Returns None if it can not be determined.\n    \"\"\"\n    result = None\n    for parent in itertools.chain((path,), path.parents):\n        if parent.is_dir():\n            if not parent.joinpath(\"__init__.py\").is_file():\n                break\n            if not parent.name.isidentifier():\n                break\n            result = parent\n    return result\n\n\ndef get_canonical_module_name(path: Path) -> Optional[str]:\n    \"\"\"Get the canonical module name that would be used in normal imports.\n    \n    Returns None if the path is not part of a proper Python package.\n    \"\"\"\n    package_path = resolve_package_path(path)\n    if package_path is None:\n        return None\n    \n    # Get the relative path from package root to the module\n    try:\n        rel_path = path.relative_to(package_path.parent)\n    except ValueError:\n        return None\n    \n    # Convert path to module name\n    module_parts = list(rel_path.parts)\n    if module_parts[-1].endswith('.py'):\n        module_parts[-1] = module_parts[-1][:-3]\n    \n    # Remove __init__ if it's the last part\n    if module_parts[-1] == '__init__':\n        module_parts.pop()\n    \n    return '.'.join(module_parts)\n",
      "\ndef resolve_package_path(path: Path) -> Optional[Path]:\n    \"\"\"Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n\n    Returns None if it can not be determined.\n    \"\"\"\n    result = None\n    for parent in itertools.chain((path,), path.parents):\n        if parent.is_dir():\n            if not parent.joinpath(\"__init__.py\").is_file():\n                break\n            if not parent.name.isidentifier():\n                break\n            result = parent\n    return result\n\n\ndef get_canonical_module_name(path: Path) -> Optional[str]:\n    \"\"\"Get the canonical module name that would be used in normal imports.\"\"\"\n    package_path = resolve_package_path(path)\n    if package_path is None:\n        return None\n    \n    # Get the relative path from the package root to the module\n    try:\n        relative_path = path.relative_to(package_path.parent)\n    except ValueError:\n        return None\n    \n    # Convert path to module name\n    parts = list(relative_path.parts)\n    if parts[-1].endswith('.py'):\n        parts[-1] = parts[-1][:-3]  # Remove .py extension\n    \n    # Remove __init__ if it's the last part\n    if parts[-1] == '__init__':\n        parts.pop()\n    \n    return '.'.join(parts) if parts else None\n",
      "\ndef resolve_package_path(path: Path) -> Optional[Path]:\n    \"\"\"Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n\n    Returns None if it can not be determined.\n    \"\"\"\n    result = None\n    for parent in itertools.chain((path,), path.parents):\n        if parent.is_dir():\n            if not parent.joinpath(\"__init__.py\").is_file():\n                break\n            if not parent.name.isidentifier():\n                break\n            result = parent\n    return result\n\n\ndef get_canonical_module_name(path: Path, root: Path) -> Optional[str]:\n    \"\"\"Get the canonical module name that would be used in normal imports.\n    \n    Returns None if the path is not part of a Python package.\n    \"\"\"\n    if path.is_file():\n        path = path.parent\n    \n    package_root = resolve_package_path(path)\n    if package_root is None:\n        return None\n    \n    # Get the relative path from package root to the target\n    try:\n        rel_path = path.relative_to(package_root.parent)\n    except ValueError:\n        return None\n    \n    # Convert path to module name\n    parts = list(rel_path.parts)\n    if not all(part.isidentifier() for part in parts):\n        return None\n    \n    return \".\".join(parts)\n",
      "\ndef resolve_package_path(path: Path) -> Optional[Path]:\n    \"\"\"Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n\n    Returns None if it can not be determined.\n    \"\"\"\n    result = None\n    for parent in itertools.chain((path,), path.parents):\n        if parent.is_dir():\n            if not parent.joinpath(\"__init__.py\").is_file():\n                break\n            if not parent.name.isidentifier():\n                break\n            result = parent\n    return result\n\n\ndef get_canonical_module_name(path: Path) -> Optional[str]:\n    \"\"\"Get the canonical module name that would be used in normal imports.\n    \n    Returns None if the path is not part of a Python package.\n    \"\"\"\n    package_path = resolve_package_path(path)\n    if package_path is None:\n        return None\n    \n    # Calculate relative path from package root to the file\n    try:\n        rel_path = path.relative_to(package_path.parent)\n    except ValueError:\n        return None\n    \n    # Convert path to module name\n    parts = list(rel_path.parts)\n    if parts[-1].endswith('.py'):\n        parts[-1] = parts[-1][:-3]  # Remove .py extension\n    \n    # Remove __init__ if it's the last part\n    if parts[-1] == '__init__':\n        parts.pop()\n    \n    return '.'.join(parts) if parts else None\n",
      "\ndef resolve_package_path(path: Path) -> Optional[Path]:\n    \"\"\"Return the Python package path by looking for the last\n    directory upwards which still contains an __init__.py.\n\n    Returns None if it can not be determined.\n    \"\"\"\n    result = None\n    for parent in itertools.chain((path,), path.parents):\n        if parent.is_dir():\n            if not parent.joinpath(\"__init__.py\").is_file():\n                break\n            if not parent.name.isidentifier():\n                break\n            result = parent\n    return result\n\n\ndef get_canonical_module_name(path: Path) -> Optional[str]:\n    \"\"\"Get the canonical module name that would be used in normal imports.\n    \n    Returns None if the path is not part of a Python package.\n    \"\"\"\n    package_path = resolve_package_path(path)\n    if package_path is None:\n        return None\n    \n    # Get the module path relative to the package root\n    try:\n        relative_path = path.relative_to(package_path.parent)\n    except ValueError:\n        return None\n    \n    # Convert path to module name\n    if path.is_file() and path.suffix == \".py\":\n        if path.name == \"__init__.py\":\n            # For __init__.py files, use the parent directory name\n            module_parts = relative_path.parent.parts\n        else:\n            # For regular .py files, include the filename without extension\n            module_parts = relative_path.parent.parts + (path.stem,)\n    else:\n        module_parts = relative_path.parts\n    \n    return \".\".join(module_parts) if module_parts else None\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..5dd4dad2a 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -521,6 +521,7 @@ def import_path(\n     if not path.exists():\n         raise ImportError(path)\n \n+\n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n \n@@ -536,9 +537,22 @@ def import_path(\n         mod = importlib.util.module_from_spec(spec)\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n+        \n+        # Also register the module under its canonical name to prevent duplication\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            pkg_root = pkg_path.parent\n+            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+            if names[-1] == \"__init__\":\n+                names.pop()\n+            canonical_name = \".\".join(names)\n+            if canonical_name != module_name and canonical_name not in sys.modules:\n+                sys.modules[canonical_name] = mod\n+        \n         insert_missing_modules(sys.modules, module_name)\n         return mod\n \n+\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n@@ -603,6 +617,7 @@ else:\n         return os.path.samefile(f1, f2)\n \n \n+\n def module_name_from_path(path: Path, root: Path) -> str:\n     \"\"\"\n     Return a dotted module name based on the given path, anchored on root.\n@@ -624,6 +639,7 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     return \".\".join(path_parts)\n \n \n+\n def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n     \"\"\"\n     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n",
    "variant_0": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..dddb5bfb7 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -521,6 +521,7 @@ def import_path(\n     if not path.exists():\n         raise ImportError(path)\n \n+\n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n \n@@ -537,8 +538,22 @@ def import_path(\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n         insert_missing_modules(sys.modules, module_name)\n+        \n+        # Also register under canonical name if it's different from the unique path-based name\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            pkg_root = pkg_path.parent\n+            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+            if names[-1] == \"__init__\":\n+                names.pop()\n+            canonical_name = \".\".join(names)\n+            if canonical_name != module_name and canonical_name not in sys.modules:\n+                sys.modules[canonical_name] = mod\n+                insert_missing_modules(sys.modules, canonical_name)\n+        \n         return mod\n \n+\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n@@ -546,9 +561,11 @@ def import_path(\n         if names[-1] == \"__init__\":\n             names.pop()\n         module_name = \".\".join(names)\n+        canonical_name = module_name\n     else:\n         pkg_root = path.parent\n         module_name = path.stem\n+        canonical_name = module_name\n \n     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n     # problems because of delayed imports: for example, a conftest.py file imported by this function\n@@ -565,6 +582,10 @@ def import_path(\n     importlib.import_module(module_name)\n \n     mod = sys.modules[module_name]\n+    \n+    # For importlib mode, also register under canonical name if different\n+    if canonical_name != module_name and canonical_name not in sys.modules:\n+        sys.modules[canonical_name] = mod\n     if path.name == \"__init__.py\":\n         return mod\n \n@@ -603,6 +624,7 @@ else:\n         return os.path.samefile(f1, f2)\n \n \n+\n def module_name_from_path(path: Path, root: Path) -> str:\n     \"\"\"\n     Return a dotted module name based on the given path, anchored on root.\n@@ -624,6 +646,24 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     return \".\".join(path_parts)\n \n \n+def canonical_module_name_from_path(path: Path) -> Optional[str]:\n+    \"\"\"\n+    Return the canonical module name that would be used in normal Python imports.\n+    This determines the proper package structure by finding __init__.py files.\n+    \"\"\"\n+    try:\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is None:\n+            return None\n+        \n+        # Get the module name relative to the package root\n+        relative_path = path.with_suffix(\"\").relative_to(pkg_path.parent)\n+        return \".\".join(relative_path.parts)\n+    except (ValueError, OSError):\n+        return None\n+\n+\n+\n def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n     \"\"\"\n     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n@@ -658,7 +698,7 @@ def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) ->\n             # modules.\n             if not hasattr(module, child_name):\n                 setattr(module, child_name, child_module)\n-                modules[module_name] = module\n+        modules[module_name] = module\n         # Keep track of the child module while moving up the tree.\n         child_module, child_name = module, module_name.rpartition(\".\")[-1]\n         module_parts.pop(-1)\n@@ -682,6 +722,40 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n+def get_canonical_module_name(path: Path, root: Path) -> Optional[str]:\n+    \"\"\"Get the canonical module name that would be used in normal imports.\n+    \n+    Returns None if the path is not part of a proper Python package.\n+    \"\"\"\n+    package_path = resolve_package_path(path)\n+    if package_path is None:\n+        return None\n+    \n+    # Get the relative path from the package root to the file\n+    try:\n+        if path.is_file():\n+            # For files, use parent directory and stem\n+            rel_path = path.parent.relative_to(package_path)\n+            module_parts = list(rel_path.parts) + [path.stem]\n+        else:\n+            # For directories, use the directory itself\n+            rel_path = path.relative_to(package_path)\n+            module_parts = list(rel_path.parts)\n+    except ValueError:\n+        return None\n+    \n+    # Add the package name itself\n+    module_parts = [package_path.name] + module_parts\n+    \n+    # Filter out empty parts and validate identifiers\n+    module_parts = [part for part in module_parts if part and part.isidentifier()]\n+    \n+    if not module_parts:\n+        return None\n+    \n+    return \".\".join(module_parts)\n+\n+\n def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n     \"\"\"Scan a directory recursively, in breadth-first order.\n \n",
    "variant_1": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..062834134 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -521,6 +521,7 @@ def import_path(\n     if not path.exists():\n         raise ImportError(path)\n \n+\n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n \n@@ -537,8 +538,22 @@ def import_path(\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n         insert_missing_modules(sys.modules, module_name)\n+        \n+        # Also register under canonical name if different from path-based name\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            pkg_root = pkg_path.parent\n+            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+            if names[-1] == \"__init__\":\n+                names.pop()\n+            canonical_name = \".\".join(names)\n+            if canonical_name != module_name and canonical_name not in sys.modules:\n+                sys.modules[canonical_name] = mod\n+                insert_missing_modules(sys.modules, canonical_name)\n+        \n         return mod\n \n+\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n@@ -546,9 +561,11 @@ def import_path(\n         if names[-1] == \"__init__\":\n             names.pop()\n         module_name = \".\".join(names)\n+        canonical_module_name = module_name\n     else:\n         pkg_root = path.parent\n         module_name = path.stem\n+        canonical_module_name = module_name\n \n     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n     # problems because of delayed imports: for example, a conftest.py file imported by this function\n@@ -562,9 +579,9 @@ def import_path(\n     else:\n         assert_never(mode)\n \n-    importlib.import_module(module_name)\n+    importlib.import_module(canonical_module_name)\n \n-    mod = sys.modules[module_name]\n+    mod = sys.modules[canonical_module_name]\n     if path.name == \"__init__.py\":\n         return mod\n \n@@ -603,6 +620,7 @@ else:\n         return os.path.samefile(f1, f2)\n \n \n+\n def module_name_from_path(path: Path, root: Path) -> str:\n     \"\"\"\n     Return a dotted module name based on the given path, anchored on root.\n@@ -624,6 +642,23 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     return \".\".join(path_parts)\n \n \n+def canonical_module_name_from_path(path: Path) -> Optional[str]:\n+    \"\"\"\n+    Return the canonical module name that would be used in normal Python imports,\n+    based on the package structure determined by __init__.py files.\n+    \"\"\"\n+    try:\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            # Get the relative path from the package root to the module\n+            relative_path = path.with_suffix(\"\").relative_to(pkg_path)\n+            return \".\".join(relative_path.parts)\n+    except (ValueError, OSError):\n+        pass\n+    return None\n+\n+\n+\n def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n     \"\"\"\n     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n@@ -659,6 +694,8 @@ def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) ->\n             if not hasattr(module, child_name):\n                 setattr(module, child_name, child_module)\n                 modules[module_name] = module\n+                # Also register in sys.modules to ensure consistency\n+                sys.modules[module_name] = module\n         # Keep track of the child module while moving up the tree.\n         child_module, child_name = module, module_name.rpartition(\".\")[-1]\n         module_parts.pop(-1)\n@@ -682,6 +719,33 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n+def get_canonical_module_name(path: Path, root: Path) -> Optional[str]:\n+    \"\"\"Get the canonical module name that would be used in normal imports.\n+    \n+    Returns None if the path is not within a Python package structure.\n+    \"\"\"\n+    package_path = resolve_package_path(path)\n+    if package_path is None:\n+        return None\n+    \n+    # Get the relative path from package root to the module\n+    try:\n+        rel_path = path.relative_to(package_path)\n+    except ValueError:\n+        return None\n+    \n+    # Convert path to module name\n+    parts = list(rel_path.parts)\n+    if parts[-1].endswith('.py'):\n+        parts[-1] = parts[-1][:-3]  # Remove .py extension\n+    \n+    # Remove __init__ if it's the last part\n+    if parts[-1] == '__init__':\n+        parts.pop()\n+    \n+    return '.'.join(parts) if parts else package_path.name\n+\n+\n def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n     \"\"\"Scan a directory recursively, in breadth-first order.\n \n",
    "variant_2": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..35e2efb9b 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -521,6 +521,7 @@ def import_path(\n     if not path.exists():\n         raise ImportError(path)\n \n+\n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n \n@@ -537,8 +538,22 @@ def import_path(\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n         insert_missing_modules(sys.modules, module_name)\n+        \n+        # Also register module under its canonical name if it's part of a package\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            pkg_root = pkg_path.parent\n+            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+            if names[-1] == \"__init__\":\n+                names.pop()\n+            canonical_name = \".\".join(names)\n+            if canonical_name != module_name and canonical_name not in sys.modules:\n+                sys.modules[canonical_name] = mod\n+                insert_missing_modules(sys.modules, canonical_name)\n+        \n         return mod\n \n+\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n@@ -546,9 +561,11 @@ def import_path(\n         if names[-1] == \"__init__\":\n             names.pop()\n         module_name = \".\".join(names)\n+        canonical_module_name = module_name\n     else:\n         pkg_root = path.parent\n         module_name = path.stem\n+        canonical_module_name = module_name\n \n     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n     # problems because of delayed imports: for example, a conftest.py file imported by this function\n@@ -565,6 +582,10 @@ def import_path(\n     importlib.import_module(module_name)\n \n     mod = sys.modules[module_name]\n+    # For importlib mode, also register under canonical name to ensure\n+    # consistency with normal imports\n+    if canonical_module_name != module_name and canonical_module_name not in sys.modules:\n+        sys.modules[canonical_module_name] = mod\n     if path.name == \"__init__.py\":\n         return mod\n \n@@ -603,6 +624,7 @@ else:\n         return os.path.samefile(f1, f2)\n \n \n+\n def module_name_from_path(path: Path, root: Path) -> str:\n     \"\"\"\n     Return a dotted module name based on the given path, anchored on root.\n@@ -624,6 +646,34 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     return \".\".join(path_parts)\n \n \n+def canonical_module_name_from_path(path: Path) -> Optional[str]:\n+    \"\"\"\n+    Return the canonical module name that would be used in normal Python imports.\n+    \n+    This determines the proper package structure by finding the Python package\n+    containing the module and constructing the canonical import name.\n+    \"\"\"\n+    try:\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is None:\n+            return None\n+        \n+        # Get the relative path from the package root to the module\n+        module_path = path.with_suffix(\"\")\n+        relative_path = module_path.relative_to(pkg_path.parent)\n+        \n+        # Convert path parts to dotted module name\n+        parts = []\n+        if pkg_path.name != \"__init__.py\":\n+            parts.append(pkg_path.parent.name)\n+        parts.extend(relative_path.parts)\n+        \n+        return \".\".join(parts)\n+    except (ValueError, OSError):\n+        return None\n+\n+\n+\n def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n     \"\"\"\n     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n@@ -682,6 +732,36 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n+def get_canonical_module_name(path: Path, root: Path) -> Optional[str]:\n+    \"\"\"Get the canonical module name that would be used in normal imports.\n+    \n+    Returns None if the path is not part of a Python package.\n+    \"\"\"\n+    package_path = resolve_package_path(path)\n+    if package_path is None:\n+        return None\n+    \n+    # Get the relative path from package root to the file\n+    try:\n+        rel_path = path.relative_to(package_path)\n+    except ValueError:\n+        return None\n+    \n+    # Convert path to module name\n+    parts = list(rel_path.parts)\n+    if parts[-1].endswith('.py'):\n+        parts[-1] = parts[-1][:-3]  # Remove .py extension\n+    \n+    # Remove __init__ if it's the last part\n+    if parts[-1] == '__init__':\n+        parts.pop()\n+    \n+    if not parts:\n+        return package_path.name\n+    \n+    return package_path.name + '.' + '.'.join(parts)\n+\n+\n def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n     \"\"\"Scan a directory recursively, in breadth-first order.\n \n",
    "variant_3": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..cd73eed61 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -521,6 +521,7 @@ def import_path(\n     if not path.exists():\n         raise ImportError(path)\n \n+\n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n \n@@ -537,8 +538,22 @@ def import_path(\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n         insert_missing_modules(sys.modules, module_name)\n+        \n+        # Also register module under its canonical name if it's part of a package\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            pkg_root = pkg_path.parent\n+            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+            if names[-1] == \"__init__\":\n+                names.pop()\n+            canonical_name = \".\".join(names)\n+            if canonical_name != module_name and canonical_name not in sys.modules:\n+                sys.modules[canonical_name] = mod\n+                insert_missing_modules(sys.modules, canonical_name)\n+        \n         return mod\n \n+\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n@@ -546,9 +561,11 @@ def import_path(\n         if names[-1] == \"__init__\":\n             names.pop()\n         module_name = \".\".join(names)\n+        canonical_name = module_name\n     else:\n         pkg_root = path.parent\n         module_name = path.stem\n+        canonical_name = module_name\n \n     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n     # problems because of delayed imports: for example, a conftest.py file imported by this function\n@@ -565,6 +582,11 @@ def import_path(\n     importlib.import_module(module_name)\n \n     mod = sys.modules[module_name]\n+    \n+    # For importlib mode, also register under canonical name if different\n+    unique_name = module_name_from_path(path, root)\n+    if unique_name != canonical_name and canonical_name not in sys.modules:\n+        sys.modules[canonical_name] = mod\n     if path.name == \"__init__.py\":\n         return mod\n \n@@ -603,6 +625,7 @@ else:\n         return os.path.samefile(f1, f2)\n \n \n+\n def module_name_from_path(path: Path, root: Path) -> str:\n     \"\"\"\n     Return a dotted module name based on the given path, anchored on root.\n@@ -624,6 +647,24 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     return \".\".join(path_parts)\n \n \n+def canonical_module_name_from_path(path: Path) -> Optional[str]:\n+    \"\"\"\n+    Return the canonical module name based on Python package structure.\n+    \n+    This determines what the module name would be in a normal import by finding\n+    the package structure using __init__.py files.\n+    \"\"\"\n+    try:\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            relative_path = path.with_suffix(\"\").relative_to(pkg_path)\n+            return \".\".join(relative_path.parts)\n+    except (ValueError, OSError):\n+        pass\n+    return None\n+\n+\n+\n def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n     \"\"\"\n     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n@@ -682,6 +723,38 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n+def get_canonical_module_name(path: Path) -> Optional[str]:\n+    \"\"\"Get the canonical module name that would be used in normal imports.\n+    \n+    Returns None if the path is not part of a Python package.\n+    \"\"\"\n+    package_path = resolve_package_path(path)\n+    if package_path is None:\n+        return None\n+    \n+    # Get the relative path from package root to the module\n+    try:\n+        rel_path = path.relative_to(package_path.parent)\n+    except ValueError:\n+        return None\n+    \n+    # Convert path to module name\n+    parts = list(rel_path.parts)\n+    if parts[-1].endswith('.py'):\n+        parts[-1] = parts[-1][:-3]  # Remove .py extension\n+    \n+    # Filter out non-identifier parts and __init__ modules\n+    module_parts = []\n+    for part in parts:\n+        if part == '__init__':\n+            continue\n+        if not part.isidentifier():\n+            return None\n+        module_parts.append(part)\n+    \n+    return '.'.join(module_parts) if module_parts else None\n+\n+\n def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n     \"\"\"Scan a directory recursively, in breadth-first order.\n \n",
    "variant_4": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..2c0e8873f 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -521,6 +521,7 @@ def import_path(\n     if not path.exists():\n         raise ImportError(path)\n \n+\n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n \n@@ -537,8 +538,22 @@ def import_path(\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n         insert_missing_modules(sys.modules, module_name)\n+        \n+        # Also register under canonical name if different from path-based name\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            pkg_root = pkg_path.parent\n+            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+            if names[-1] == \"__init__\":\n+                names.pop()\n+            canonical_name = \".\".join(names)\n+            if canonical_name != module_name and canonical_name not in sys.modules:\n+                sys.modules[canonical_name] = mod\n+                insert_missing_modules(sys.modules, canonical_name)\n+        \n         return mod\n \n+\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n@@ -546,9 +561,11 @@ def import_path(\n         if names[-1] == \"__init__\":\n             names.pop()\n         module_name = \".\".join(names)\n+        canonical_module_name = module_name\n     else:\n         pkg_root = path.parent\n         module_name = path.stem\n+        canonical_module_name = None\n \n     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n     # problems because of delayed imports: for example, a conftest.py file imported by this function\n@@ -565,6 +582,10 @@ def import_path(\n     importlib.import_module(module_name)\n \n     mod = sys.modules[module_name]\n+    \n+    # For importlib mode, also register under canonical name if it exists\n+    if canonical_module_name and canonical_module_name != module_name:\n+        sys.modules[canonical_module_name] = mod\n     if path.name == \"__init__.py\":\n         return mod\n \n@@ -603,6 +624,7 @@ else:\n         return os.path.samefile(f1, f2)\n \n \n+\n def module_name_from_path(path: Path, root: Path) -> str:\n     \"\"\"\n     Return a dotted module name based on the given path, anchored on root.\n@@ -624,6 +646,23 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     return \".\".join(path_parts)\n \n \n+def canonical_module_name_from_path(path: Path) -> Optional[str]:\n+    \"\"\"\n+    Return the canonical module name that would be used in normal Python imports,\n+    based on the package structure determined by __init__.py files.\n+    \"\"\"\n+    try:\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            # Get the relative path from the package root to the module\n+            relative_path = path.with_suffix(\"\").relative_to(pkg_path.parent)\n+            return \".\".join(relative_path.parts)\n+    except (ValueError, OSError):\n+        pass\n+    return None\n+\n+\n+\n def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n     \"\"\"\n     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n@@ -659,6 +698,8 @@ def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) ->\n             if not hasattr(module, child_name):\n                 setattr(module, child_name, child_module)\n                 modules[module_name] = module\n+                # Also register in sys.modules to ensure consistency\n+                sys.modules[module_name] = module\n         # Keep track of the child module while moving up the tree.\n         child_module, child_name = module, module_name.rpartition(\".\")[-1]\n         module_parts.pop(-1)\n@@ -682,6 +723,33 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n+def get_canonical_module_name(path: Path) -> Optional[str]:\n+    \"\"\"Get the canonical module name that would be used in normal imports.\n+    \n+    Returns None if the path is not part of a proper Python package.\n+    \"\"\"\n+    package_path = resolve_package_path(path)\n+    if package_path is None:\n+        return None\n+    \n+    # Get the relative path from package root to the module\n+    try:\n+        rel_path = path.relative_to(package_path.parent)\n+    except ValueError:\n+        return None\n+    \n+    # Convert path to module name\n+    module_parts = list(rel_path.parts)\n+    if module_parts[-1].endswith('.py'):\n+        module_parts[-1] = module_parts[-1][:-3]\n+    \n+    # Remove __init__ if it's the last part\n+    if module_parts[-1] == '__init__':\n+        module_parts.pop()\n+    \n+    return '.'.join(module_parts)\n+\n+\n def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n     \"\"\"Scan a directory recursively, in breadth-first order.\n \n",
    "variant_5": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..abec9592b 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -521,6 +521,7 @@ def import_path(\n     if not path.exists():\n         raise ImportError(path)\n \n+\n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n \n@@ -537,18 +538,32 @@ def import_path(\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n         insert_missing_modules(sys.modules, module_name)\n+        \n+        # Also register under canonical name if it's a package module\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            pkg_root = pkg_path.parent\n+            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+            if names[-1] == \"__init__\":\n+                names.pop()\n+            canonical_name = \".\".join(names)\n+            if canonical_name != module_name and canonical_name not in sys.modules:\n+                sys.modules[canonical_name] = mod\n+                insert_missing_modules(sys.modules, canonical_name)\n+        \n         return mod\n \n+\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n         names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n         if names[-1] == \"__init__\":\n             names.pop()\n-        module_name = \".\".join(names)\n+        canonical_module_name = \".\".join(names)\n     else:\n         pkg_root = path.parent\n-        module_name = path.stem\n+        canonical_module_name = path.stem\n \n     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n     # problems because of delayed imports: for example, a conftest.py file imported by this function\n@@ -562,9 +577,22 @@ def import_path(\n     else:\n         assert_never(mode)\n \n-    importlib.import_module(module_name)\n-\n-    mod = sys.modules[module_name]\n+    # Import using canonical name if possible, otherwise fall back to unique name\n+    try:\n+        importlib.import_module(canonical_module_name)\n+        mod = sys.modules[canonical_module_name]\n+        # Also register under unique name for consistency\n+        if canonical_module_name != module_name:\n+            sys.modules[module_name] = mod\n+    except ImportError:\n+        # Fall back to unique name import if canonical import fails\n+        importlib.import_module(module_name)\n+        mod = sys.modules[module_name]\n+        # Also register under canonical name if it's different\n+        if canonical_module_name != module_name:\n+            sys.modules[canonical_module_name] = mod\n+\n+    mod = sys.modules[canonical_module_name]\n     if path.name == \"__init__.py\":\n         return mod\n \n@@ -603,6 +631,7 @@ else:\n         return os.path.samefile(f1, f2)\n \n \n+\n def module_name_from_path(path: Path, root: Path) -> str:\n     \"\"\"\n     Return a dotted module name based on the given path, anchored on root.\n@@ -624,6 +653,30 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     return \".\".join(path_parts)\n \n \n+def canonical_module_name_from_path(path: Path, root: Path) -> Optional[str]:\n+    \"\"\"\n+    Return the canonical dotted module name that would be used in normal imports,\n+    based on the Python package structure (presence of __init__.py files).\n+    \n+    Returns None if the path is not part of a Python package.\n+    \"\"\"\n+    try:\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is None:\n+            return None\n+        \n+        # Get the module path relative to the package root\n+        module_path = path.with_suffix(\"\")\n+        try:\n+            relative_path = module_path.relative_to(pkg_path)\n+            return \".\".join(relative_path.parts)\n+        except ValueError:\n+            return None\n+    except Exception:\n+        return None\n+\n+\n+\n def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n     \"\"\"\n     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n@@ -658,7 +711,7 @@ def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) ->\n             # modules.\n             if not hasattr(module, child_name):\n                 setattr(module, child_name, child_module)\n-                modules[module_name] = module\n+        modules[module_name] = module\n         # Keep track of the child module while moving up the tree.\n         child_module, child_name = module, module_name.rpartition(\".\")[-1]\n         module_parts.pop(-1)\n@@ -682,6 +735,30 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n+def get_canonical_module_name(path: Path) -> Optional[str]:\n+    \"\"\"Get the canonical module name that would be used in normal imports.\"\"\"\n+    package_path = resolve_package_path(path)\n+    if package_path is None:\n+        return None\n+    \n+    # Get the relative path from the package root to the module\n+    try:\n+        relative_path = path.relative_to(package_path.parent)\n+    except ValueError:\n+        return None\n+    \n+    # Convert path to module name\n+    parts = list(relative_path.parts)\n+    if parts[-1].endswith('.py'):\n+        parts[-1] = parts[-1][:-3]  # Remove .py extension\n+    \n+    # Remove __init__ if it's the last part\n+    if parts[-1] == '__init__':\n+        parts.pop()\n+    \n+    return '.'.join(parts) if parts else None\n+\n+\n def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n     \"\"\"Scan a directory recursively, in breadth-first order.\n \n",
    "variant_6": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..41604f84c 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -521,6 +521,7 @@ def import_path(\n     if not path.exists():\n         raise ImportError(path)\n \n+\n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n \n@@ -537,8 +538,22 @@ def import_path(\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n         insert_missing_modules(sys.modules, module_name)\n+        \n+        # Also register under canonical name if it exists\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            pkg_root = pkg_path.parent\n+            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+            if names[-1] == \"__init__\":\n+                names.pop()\n+            canonical_name = \".\".join(names)\n+            if canonical_name != module_name:\n+                sys.modules[canonical_name] = mod\n+                insert_missing_modules(sys.modules, canonical_name)\n+        \n         return mod\n \n+\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n@@ -546,9 +561,11 @@ def import_path(\n         if names[-1] == \"__init__\":\n             names.pop()\n         module_name = \".\".join(names)\n+        canonical_name = module_name\n     else:\n         pkg_root = path.parent\n         module_name = path.stem\n+        canonical_name = module_name\n \n     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n     # problems because of delayed imports: for example, a conftest.py file imported by this function\n@@ -565,6 +582,11 @@ def import_path(\n     importlib.import_module(module_name)\n \n     mod = sys.modules[module_name]\n+    \n+    # Also register under canonical name if different from module_name\n+    unique_module_name = module_name_from_path(path, root)\n+    if canonical_name != unique_module_name and canonical_name not in sys.modules:\n+        sys.modules[canonical_name] = mod\n     if path.name == \"__init__.py\":\n         return mod\n \n@@ -603,6 +625,7 @@ else:\n         return os.path.samefile(f1, f2)\n \n \n+\n def module_name_from_path(path: Path, root: Path) -> str:\n     \"\"\"\n     Return a dotted module name based on the given path, anchored on root.\n@@ -624,6 +647,30 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     return \".\".join(path_parts)\n \n \n+def canonical_module_name_from_path(path: Path) -> Optional[str]:\n+    \"\"\"\n+    Return the canonical module name that would be used in normal Python imports.\n+    \n+    This determines the proper package structure by finding the Python package\n+    hierarchy and constructing the canonical dotted import name.\n+    \"\"\"\n+    try:\n+        # Use resolve_package_path to find the proper package structure\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is None:\n+            return None\n+        \n+        # Get the relative path from package root to the module\n+        relative_path = path.with_suffix(\"\").relative_to(pkg_path)\n+        \n+        # Construct the canonical module name\n+        parts = [pkg_path.name] + list(relative_path.parts)\n+        return \".\".join(parts)\n+    except (ValueError, OSError):\n+        return None\n+\n+\n+\n def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n     \"\"\"\n     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n@@ -658,7 +705,7 @@ def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) ->\n             # modules.\n             if not hasattr(module, child_name):\n                 setattr(module, child_name, child_module)\n-                modules[module_name] = module\n+        modules[module_name] = module\n         # Keep track of the child module while moving up the tree.\n         child_module, child_name = module, module_name.rpartition(\".\")[-1]\n         module_parts.pop(-1)\n@@ -682,6 +729,32 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n+def get_canonical_module_name(path: Path, root: Path) -> Optional[str]:\n+    \"\"\"Get the canonical module name that would be used in normal imports.\n+    \n+    Returns None if the path is not part of a Python package.\n+    \"\"\"\n+    if path.is_file():\n+        path = path.parent\n+    \n+    package_root = resolve_package_path(path)\n+    if package_root is None:\n+        return None\n+    \n+    # Get the relative path from package root to the target\n+    try:\n+        rel_path = path.relative_to(package_root.parent)\n+    except ValueError:\n+        return None\n+    \n+    # Convert path to module name\n+    parts = list(rel_path.parts)\n+    if not all(part.isidentifier() for part in parts):\n+        return None\n+    \n+    return \".\".join(parts)\n+\n+\n def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n     \"\"\"Scan a directory recursively, in breadth-first order.\n \n",
    "variant_7": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..d53108740 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -521,6 +521,7 @@ def import_path(\n     if not path.exists():\n         raise ImportError(path)\n \n+\n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n \n@@ -537,18 +538,32 @@ def import_path(\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n         insert_missing_modules(sys.modules, module_name)\n+        \n+        # Also register under canonical module name if different\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            pkg_root = pkg_path.parent\n+            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+            if names[-1] == \"__init__\":\n+                names.pop()\n+            canonical_name = \".\".join(names)\n+            if canonical_name != module_name and canonical_name not in sys.modules:\n+                sys.modules[canonical_name] = mod\n+                insert_missing_modules(sys.modules, canonical_name)\n+        \n         return mod\n \n+\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n         names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n         if names[-1] == \"__init__\":\n             names.pop()\n-        module_name = \".\".join(names)\n+        canonical_module_name = \".\".join(names)\n     else:\n         pkg_root = path.parent\n-        module_name = path.stem\n+        canonical_module_name = path.stem\n \n     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n     # problems because of delayed imports: for example, a conftest.py file imported by this function\n@@ -562,9 +577,16 @@ def import_path(\n     else:\n         assert_never(mode)\n \n-    importlib.import_module(module_name)\n-\n-    mod = sys.modules[module_name]\n+    # For importlib mode, use the canonical module name for import\n+    if canonical_module_name in sys.modules:\n+        mod = sys.modules[canonical_module_name]\n+    else:\n+        importlib.import_module(canonical_module_name)\n+        mod = sys.modules[canonical_module_name]\n+        \n+        # Also register under the unique path-based name for consistency\n+        if module_name != canonical_module_name:\n+            sys.modules[module_name] = mod\n     if path.name == \"__init__.py\":\n         return mod\n \n@@ -603,6 +625,7 @@ else:\n         return os.path.samefile(f1, f2)\n \n \n+\n def module_name_from_path(path: Path, root: Path) -> str:\n     \"\"\"\n     Return a dotted module name based on the given path, anchored on root.\n@@ -624,6 +647,29 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     return \".\".join(path_parts)\n \n \n+def canonical_module_name_from_path(path: Path, root: Path) -> Optional[str]:\n+    \"\"\"\n+    Return the canonical dotted module name that would be used in normal imports,\n+    based on the given path and package structure determined by __init__.py files.\n+    \n+    Returns None if the path is not part of a Python package.\n+    \"\"\"\n+    try:\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is None:\n+            return None\n+        \n+        # Get the module path relative to the package root\n+        module_path = path.with_suffix(\"\")\n+        pkg_relative = module_path.relative_to(pkg_path.parent)\n+        \n+        # Convert path parts to dotted module name\n+        return \".\".join(pkg_relative.parts)\n+    except (ValueError, OSError):\n+        return None\n+\n+\n+\n def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n     \"\"\"\n     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n@@ -658,7 +704,7 @@ def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) ->\n             # modules.\n             if not hasattr(module, child_name):\n                 setattr(module, child_name, child_module)\n-                modules[module_name] = module\n+        modules[module_name] = module\n         # Keep track of the child module while moving up the tree.\n         child_module, child_name = module, module_name.rpartition(\".\")[-1]\n         module_parts.pop(-1)\n@@ -682,6 +728,33 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n+def get_canonical_module_name(path: Path) -> Optional[str]:\n+    \"\"\"Get the canonical module name that would be used in normal imports.\n+    \n+    Returns None if the path is not part of a Python package.\n+    \"\"\"\n+    package_path = resolve_package_path(path)\n+    if package_path is None:\n+        return None\n+    \n+    # Calculate relative path from package root to the file\n+    try:\n+        rel_path = path.relative_to(package_path.parent)\n+    except ValueError:\n+        return None\n+    \n+    # Convert path to module name\n+    parts = list(rel_path.parts)\n+    if parts[-1].endswith('.py'):\n+        parts[-1] = parts[-1][:-3]  # Remove .py extension\n+    \n+    # Remove __init__ if it's the last part\n+    if parts[-1] == '__init__':\n+        parts.pop()\n+    \n+    return '.'.join(parts) if parts else None\n+\n+\n def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n     \"\"\"Scan a directory recursively, in breadth-first order.\n \n",
    "variant_8": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..7f86b3abe 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -521,6 +521,7 @@ def import_path(\n     if not path.exists():\n         raise ImportError(path)\n \n+\n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n \n@@ -537,8 +538,23 @@ def import_path(\n         sys.modules[module_name] = mod\n         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n         insert_missing_modules(sys.modules, module_name)\n+        \n+        # Also register module under its canonical name if it's part of a package\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            pkg_root = pkg_path.parent\n+            names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n+            if names[-1] == \"__init__\":\n+                names.pop()\n+            canonical_module_name = \".\".join(names)\n+            # Only register if canonical name differs from unique name\n+            if canonical_module_name != module_name:\n+                sys.modules[canonical_module_name] = mod\n+                insert_missing_modules(sys.modules, canonical_module_name)\n+        \n         return mod\n \n+\n     pkg_path = resolve_package_path(path)\n     if pkg_path is not None:\n         pkg_root = pkg_path.parent\n@@ -546,9 +562,11 @@ def import_path(\n         if names[-1] == \"__init__\":\n             names.pop()\n         module_name = \".\".join(names)\n+        canonical_module_name = module_name\n     else:\n         pkg_root = path.parent\n         module_name = path.stem\n+        canonical_module_name = module_name\n \n     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n     # problems because of delayed imports: for example, a conftest.py file imported by this function\n@@ -562,9 +580,9 @@ def import_path(\n     else:\n         assert_never(mode)\n \n-    importlib.import_module(module_name)\n+    importlib.import_module(canonical_module_name)\n \n-    mod = sys.modules[module_name]\n+    mod = sys.modules[canonical_module_name]\n     if path.name == \"__init__.py\":\n         return mod\n \n@@ -603,6 +621,7 @@ else:\n         return os.path.samefile(f1, f2)\n \n \n+\n def module_name_from_path(path: Path, root: Path) -> str:\n     \"\"\"\n     Return a dotted module name based on the given path, anchored on root.\n@@ -624,6 +643,26 @@ def module_name_from_path(path: Path, root: Path) -> str:\n     return \".\".join(path_parts)\n \n \n+def canonical_module_name_from_path(path: Path) -> Optional[str]:\n+    \"\"\"\n+    Return the canonical module name that would be used in normal Python imports.\n+    \n+    This determines the proper package structure by finding the Python package\n+    path and deriving the canonical import name.\n+    \"\"\"\n+    try:\n+        pkg_path = resolve_package_path(path)\n+        if pkg_path is not None:\n+            # Get relative path from package root to the module\n+            relative_path = path.with_suffix(\"\").relative_to(pkg_path)\n+            if relative_path.parts:\n+                return \".\".join(relative_path.parts)\n+    except (ValueError, OSError):\n+        pass\n+    return None\n+\n+\n+\n def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n     \"\"\"\n     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n@@ -658,7 +697,7 @@ def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) ->\n             # modules.\n             if not hasattr(module, child_name):\n                 setattr(module, child_name, child_module)\n-                modules[module_name] = module\n+        modules[module_name] = module\n         # Keep track of the child module while moving up the tree.\n         child_module, child_name = module, module_name.rpartition(\".\")[-1]\n         module_parts.pop(-1)\n@@ -682,6 +721,35 @@ def resolve_package_path(path: Path) -> Optional[Path]:\n     return result\n \n \n+def get_canonical_module_name(path: Path) -> Optional[str]:\n+    \"\"\"Get the canonical module name that would be used in normal imports.\n+    \n+    Returns None if the path is not part of a Python package.\n+    \"\"\"\n+    package_path = resolve_package_path(path)\n+    if package_path is None:\n+        return None\n+    \n+    # Get the module path relative to the package root\n+    try:\n+        relative_path = path.relative_to(package_path.parent)\n+    except ValueError:\n+        return None\n+    \n+    # Convert path to module name\n+    if path.is_file() and path.suffix == \".py\":\n+        if path.name == \"__init__.py\":\n+            # For __init__.py files, use the parent directory name\n+            module_parts = relative_path.parent.parts\n+        else:\n+            # For regular .py files, include the filename without extension\n+            module_parts = relative_path.parent.parts + (path.stem,)\n+    else:\n+        module_parts = relative_path.parts\n+    \n+    return \".\".join(module_parts) if module_parts else None\n+\n+\n def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n     \"\"\"Scan a directory recursively, in breadth-first order.\n \n"
  }
}