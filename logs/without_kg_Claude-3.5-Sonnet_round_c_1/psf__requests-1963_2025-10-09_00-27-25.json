{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/requests/requests/sessions.py lines 88-91)": "\n        i = 0\n        # Keep track of the current request state to preserve modifications across redirects\n        current_request = req\n\n        while resp.is_redirect:\n            # Copy from current_request to preserve previous redirect modifications\n            prepared_request = current_request.copy()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/requests/requests/sessions.py lines 88-91)": [
      "\n        i = 0\n        # Track the current request state to preserve modifications across redirects\n        current_request = req\n\n        while resp.is_redirect:\n            # Copy from current request state, not always from original\n            prepared_request = current_request.copy()\n",
      "\n        i = 0\n        # Track the current request state to preserve changes across redirects\n        current_request = req\n\n        while resp.is_redirect:\n            # Copy from current request state, not original request\n            prepared_request = current_request.copy()\n",
      "\n        i = 0\n        # Track the current request state to preserve changes across redirects\n        current_request = req\n\n        while resp.is_redirect:\n            # Copy from current request to preserve accumulated changes\n            prepared_request = current_request.copy()\n",
      "\n        i = 0\n        # Track the current request state to preserve modifications across redirects\n        current_request = req\n\n        while resp.is_redirect:\n            # Copy from current request state, not always from original\n            prepared_request = current_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = req.method\n\n            # Comment out or remove the line that redefines method\n            # method = req.method\n\n            # Handle the various redirect codes.\n            if resp.status_code == codes.moved_permanently:  # 301\n                method = 'GET'\n            elif resp.status_code == codes.found:  # 302\n                method = 'GET'\n            elif resp.status_code == codes.see_other:  # 303\n                method = 'GET'\n            elif resp.status_code == codes.temporary_redirect:  # 307\n                # Preserve method from current request\n                method = prepared_request.method\n            elif resp.status_code == codes.permanent_redirect:  # 308\n                # Preserve method from current request  \n                method = prepared_request.method\n\n            # Remove the body for GET requests\n            if method == 'GET':\n                prepared_request.body = None\n                headers = prepared_request.headers\n                try:\n                    del headers['Content-Length']\n                except KeyError:\n                    pass\n\n            prepared_request.method = method\n            prepared_request.url = url\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Update current_request to preserve state for next iteration\n            current_request = prepared_request\n\n            resp = self.send(\n                prepared_request,\n                stream=stream,\n                timeout=timeout,\n                verify=verify,\n                cert=cert,\n                proxies=proxies,\n                allow_redirects=False,\n            )\n\n            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n            i += 1\n            yield resp\n",
      "\n        i = 0\n        # Track the current request state across redirects\n        current_request = req\n\n        while resp.is_redirect:\n            # Copy from current request state, not original request\n            prepared_request = current_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = req.method\n\n            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n            if resp.status_code == codes.see_other and method != 'HEAD':\n                method = 'GET'\n\n            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n            if resp.status_code == codes.found and method != 'HEAD':\n                method = 'GET'\n\n            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n            if resp.status_code == codes.moved and method != 'HEAD':\n                method = 'GET'\n\n            # Do what the browsers do, despite standards...\n            # First, turn 302s into GETs.\n            if resp.status_code == codes.found and method != 'HEAD':\n                method = 'GET'\n\n            # Second, if a POST is responded to with a 301, turn it into a GET.\n            # This bizarre behaviour is explained in Issue 1704.\n            if resp.status_code == codes.moved and method == 'POST':\n                method = 'GET'\n\n            prepared_request.method = method\n\n            # https://github.com/kennethreitz/requests/issues/1084\n            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n                if 'Content-Length' in prepared_request.headers:\n                    del prepared_request.headers['Content-Length']\n\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            try:\n                del headers['Cookie']\n            except KeyError:\n                pass\n\n            extract_cookies_to_jar(prepared_request._cookies, prepared_request, resp.raw)\n            prepared_request._cookies.update(self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxies information from environment, if needed.\n            proxies = self.rebuild_proxies(prepared_request, proxies)\n            self.rebuild_auth(prepared_request, resp)\n\n            # Override the original request.\n            req = prepared_request\n\n            resp = self.send(\n                req,\n                stream=stream,\n                timeout=timeout,\n                verify=verify,\n                cert=cert,\n                proxies=proxies,\n                allow_redirects=False,\n            )\n\n            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n            i += 1\n            # Update current request for next iteration\n            current_request = prepared_request\n\n            yield resp\n",
      "\n        i = 0\n        \n        # Track the current request state for the redirect chain\n        current_request = req\n\n        while resp.is_redirect:\n            # Copy from the current request (preserving changes from previous redirects)\n            # rather than always copying the original request\n            prepared_request = current_request.copy()\n",
      "\n        i = 0\n        # Track the current request state across redirects\n        current_request = req\n\n        while resp.is_redirect:\n            # Copy from current request state, not always the original\n            prepared_request = current_request.copy()\n",
      "\n        i = 0\n        # Keep track of the current request state across redirects\n        current_request = req\n\n        while resp.is_redirect:\n            # Copy from current request state, not always from original\n            prepared_request = current_request.copy()\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..90be595a 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,11 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            prepared_request = req.copy() if i == 0 else prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_0": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..9a1810a9 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,14 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n+        # Keep track of the current request state to preserve modifications across redirects\n+        current_request = req\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Copy from current_request to preserve previous redirect modifications\n+            prepared_request = current_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_1": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..285341d3 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,14 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n+        # Track the current request state to preserve modifications across redirects\n+        current_request = req\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Copy from current request state, not always from original\n+            prepared_request = current_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_2": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..4c131320 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,14 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n+        # Track the current request state to preserve changes across redirects\n+        current_request = req\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Copy from current request state, not original request\n+            prepared_request = current_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_3": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..81a14904 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,14 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n+        # Track the current request state to preserve changes across redirects\n+        current_request = req\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Copy from current request to preserve accumulated changes\n+            prepared_request = current_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_4": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..d1ea214f 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,73 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n+        # Track the current request state to preserve modifications across redirects\n+        current_request = req\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Copy from current request state, not always from original\n+            prepared_request = current_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+            method = req.method\n+\n+            # Comment out or remove the line that redefines method\n+            # method = req.method\n+\n+            # Handle the various redirect codes.\n+            if resp.status_code == codes.moved_permanently:  # 301\n+                method = 'GET'\n+            elif resp.status_code == codes.found:  # 302\n+                method = 'GET'\n+            elif resp.status_code == codes.see_other:  # 303\n+                method = 'GET'\n+            elif resp.status_code == codes.temporary_redirect:  # 307\n+                # Preserve method from current request\n+                method = prepared_request.method\n+            elif resp.status_code == codes.permanent_redirect:  # 308\n+                # Preserve method from current request  \n+                method = prepared_request.method\n+\n+            # Remove the body for GET requests\n+            if method == 'GET':\n+                prepared_request.body = None\n+                headers = prepared_request.headers\n+                try:\n+                    del headers['Content-Length']\n+                except KeyError:\n+                    pass\n+\n+            prepared_request.method = method\n+            prepared_request.url = url\n+            prepared_request.prepare_cookies(prepared_request._cookies)\n+\n+            # Update current_request to preserve state for next iteration\n+            current_request = prepared_request\n+\n+            resp = self.send(\n+                prepared_request,\n+                stream=stream,\n+                timeout=timeout,\n+                verify=verify,\n+                cert=cert,\n+                proxies=proxies,\n+                allow_redirects=False,\n+            )\n+\n+            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n+\n+            i += 1\n+            yield resp\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_5": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..c5fb2a97 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,91 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n+        # Track the current request state across redirects\n+        current_request = req\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Copy from current request state, not original request\n+            prepared_request = current_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+            method = req.method\n+\n+            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n+            if resp.status_code == codes.see_other and method != 'HEAD':\n+                method = 'GET'\n+\n+            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n+            if resp.status_code == codes.found and method != 'HEAD':\n+                method = 'GET'\n+\n+            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n+            if resp.status_code == codes.moved and method != 'HEAD':\n+                method = 'GET'\n+\n+            # Do what the browsers do, despite standards...\n+            # First, turn 302s into GETs.\n+            if resp.status_code == codes.found and method != 'HEAD':\n+                method = 'GET'\n+\n+            # Second, if a POST is responded to with a 301, turn it into a GET.\n+            # This bizarre behaviour is explained in Issue 1704.\n+            if resp.status_code == codes.moved and method == 'POST':\n+                method = 'GET'\n+\n+            prepared_request.method = method\n+\n+            # https://github.com/kennethreitz/requests/issues/1084\n+            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n+                if 'Content-Length' in prepared_request.headers:\n+                    del prepared_request.headers['Content-Length']\n+\n+                prepared_request.body = None\n+\n+            headers = prepared_request.headers\n+            try:\n+                del headers['Cookie']\n+            except KeyError:\n+                pass\n+\n+            extract_cookies_to_jar(prepared_request._cookies, prepared_request, resp.raw)\n+            prepared_request._cookies.update(self.cookies)\n+            prepared_request.prepare_cookies(prepared_request._cookies)\n+\n+            # Rebuild auth and proxies information from environment, if needed.\n+            proxies = self.rebuild_proxies(prepared_request, proxies)\n+            self.rebuild_auth(prepared_request, resp)\n+\n+            # Override the original request.\n+            req = prepared_request\n+\n+            resp = self.send(\n+                req,\n+                stream=stream,\n+                timeout=timeout,\n+                verify=verify,\n+                cert=cert,\n+                proxies=proxies,\n+                allow_redirects=False,\n+            )\n+\n+            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n+\n+            i += 1\n+            # Update current request for next iteration\n+            current_request = prepared_request\n+\n+            yield resp\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_6": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..ef8df622 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,16 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n+        \n+        # Track the current request state for the redirect chain\n+        current_request = req\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Copy from the current request (preserving changes from previous redirects)\n+            # rather than always copying the original request\n+            prepared_request = current_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_7": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..176c00f6 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,14 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n+        # Track the current request state across redirects\n+        current_request = req\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Copy from current request state, not always the original\n+            prepared_request = current_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_8": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..00dd5a42 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,14 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n+        # Keep track of the current request state across redirects\n+        current_request = req\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Copy from current request state, not always from original\n+            prepared_request = current_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n"
  }
}