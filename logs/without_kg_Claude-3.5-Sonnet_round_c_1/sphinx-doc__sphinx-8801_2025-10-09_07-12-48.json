{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 731-731)": "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
    "Location 2 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 755-758)": "\n                has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
    "Location 3 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 699-702)": "\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
    "Location 4 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 761-769)": "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
    "Location 5 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 720-730)": "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 731-731)": [
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n"
    ],
    "Location 2 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 755-758)": [
      "\n                # mocked module or object\n                pass\n            elif self.options.exclude_members and membername in self.options.exclude_members:\n                # remove members given by exclude-members\n                keep = False\n            elif want_all and special_member_re.match(membername):\n                # special __methods__\n                if self.options.special_members and membername in self.options.special_members:\n                    if membername == '__doc__':\n                        keep = False\n                    elif is_filtered_inherited_member(membername, obj):\n                        keep = False\n                    else:\n                        keep = has_doc or self.options.undoc_members\n                else:\n                    keep = False\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n                has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n"
    ],
    "Location 3 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 699-702)": [
      "\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n"
    ],
    "Location 4 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 761-769)": [
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            # annotation only member in superclass\n            doc = getdoc(value, getattr(self, 'get_attr', None), self.env.config.autodoc_inherit_docstrings, self.parent, self.object_name)\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            doc = getdoc(obj, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                doc = None\n            else:\n                doc = prepare_docstring(doc)\n\n            # if the docstring is from a base class, the module analyzer won't\n            # find the real module name\n            try:\n                analyzer = ModuleAnalyzer.for_module(self.real_modname)\n                # try to also get a source code analyzer for attribute docs\n                analyzer.find_attr_docs()\n            except PycodeError:\n                analyzer = None\n\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            # check for the presence of a docstring\n            doc = getdoc(obj, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         parent, self.object_name)\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n"
    ],
    "Location 5 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/__init__.py lines 720-730)": [
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n",
      "\n            has_doc = bool(doc) or (namespace, membername) in attr_docs\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..680d64abf 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -696,6 +696,7 @@ class Documenter:\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n+\n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n@@ -717,6 +718,7 @@ class Documenter:\n                 doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n+\n             # inherited and therefore not the member's doc\n             cls = self.get_attr(member, '__class__', None)\n             if cls:\n@@ -728,7 +730,7 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -752,12 +754,14 @@ class Documenter:\n                 if self.options.special_members and membername in self.options.special_members:\n                     if membername == '__doc__':\n                         keep = False\n+\n                     elif is_filtered_inherited_member(membername, obj):\n                         keep = False\n                     else:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..a2e0011c0 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -696,6 +696,7 @@ class Documenter:\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n+\n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n@@ -717,18 +718,10 @@ class Documenter:\n                 doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n-            # inherited and therefore not the member's doc\n-            cls = self.get_attr(member, '__class__', None)\n-            if cls:\n-                cls_doc = self.get_attr(cls, '__doc__', None)\n-                if cls_doc == doc:\n-                    doc = None\n \n-            if isinstance(obj, ObjectMember) and obj.docstring:\n-                # hack for ClassDocumenter to inject docstring via ObjectMember\n-                doc = obj.docstring\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -752,21 +745,12 @@ class Documenter:\n                 if self.options.special_members and membername in self.options.special_members:\n                     if membername == '__doc__':\n                         keep = False\n-                    elif is_filtered_inherited_member(membername, obj):\n-                        keep = False\n-                    else:\n-                        keep = has_doc or self.options.undoc_members\n+\n+                has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n-                if want_all and isprivate:\n-                    if self.options.private_members is None:\n-                        keep = False\n-                    else:\n-                        keep = membername in self.options.private_members\n-                else:\n-                    # keep documented attributes\n-                    keep = True\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..49063af28 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -696,6 +696,7 @@ class Documenter:\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n+\n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n@@ -717,18 +718,10 @@ class Documenter:\n                 doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n-            # inherited and therefore not the member's doc\n-            cls = self.get_attr(member, '__class__', None)\n-            if cls:\n-                cls_doc = self.get_attr(cls, '__doc__', None)\n-                if cls_doc == doc:\n-                    doc = None\n \n-            if isinstance(obj, ObjectMember) and obj.docstring:\n-                # hack for ClassDocumenter to inject docstring via ObjectMember\n-                doc = obj.docstring\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -742,6 +735,17 @@ class Documenter:\n \n             keep = False\n             if ismock(member):\n+                # mocked module or object\n+                pass\n+            elif self.options.exclude_members and membername in self.options.exclude_members:\n+                # remove members given by exclude-members\n+                keep = False\n+            elif want_all and special_member_re.match(membername):\n+                # special __methods__\n+                if self.options.special_members and membername in self.options.special_members:\n+                    if membername == '__doc__':\n+                        keep = False\n+\n                 # mocked module or object\n                 pass\n             elif self.options.exclude_members and membername in self.options.exclude_members:\n@@ -766,7 +770,10 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     # keep documented attributes\n-                    keep = True\n+                else:\n+                    keep = False\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..d938a45e4 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -696,6 +696,7 @@ class Documenter:\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n+\n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n@@ -717,18 +718,10 @@ class Documenter:\n                 doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n-            # inherited and therefore not the member's doc\n-            cls = self.get_attr(member, '__class__', None)\n-            if cls:\n-                cls_doc = self.get_attr(cls, '__doc__', None)\n-                if cls_doc == doc:\n-                    doc = None\n \n-            if isinstance(obj, ObjectMember) and obj.docstring:\n-                # hack for ClassDocumenter to inject docstring via ObjectMember\n-                doc = obj.docstring\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -752,21 +745,12 @@ class Documenter:\n                 if self.options.special_members and membername in self.options.special_members:\n                     if membername == '__doc__':\n                         keep = False\n-                    elif is_filtered_inherited_member(membername, obj):\n-                        keep = False\n-                    else:\n-                        keep = has_doc or self.options.undoc_members\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n-                if want_all and isprivate:\n-                    if self.options.private_members is None:\n-                        keep = False\n-                    else:\n-                        keep = membername in self.options.private_members\n-                else:\n-                    # keep documented attributes\n-                    keep = True\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..d938a45e4 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -696,6 +696,7 @@ class Documenter:\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n+\n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n@@ -717,18 +718,10 @@ class Documenter:\n                 doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n-            # inherited and therefore not the member's doc\n-            cls = self.get_attr(member, '__class__', None)\n-            if cls:\n-                cls_doc = self.get_attr(cls, '__doc__', None)\n-                if cls_doc == doc:\n-                    doc = None\n \n-            if isinstance(obj, ObjectMember) and obj.docstring:\n-                # hack for ClassDocumenter to inject docstring via ObjectMember\n-                doc = obj.docstring\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -752,21 +745,12 @@ class Documenter:\n                 if self.options.special_members and membername in self.options.special_members:\n                     if membername == '__doc__':\n                         keep = False\n-                    elif is_filtered_inherited_member(membername, obj):\n-                        keep = False\n-                    else:\n-                        keep = has_doc or self.options.undoc_members\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n-                if want_all and isprivate:\n-                    if self.options.private_members is None:\n-                        keep = False\n-                    else:\n-                        keep = membername in self.options.private_members\n-                else:\n-                    # keep documented attributes\n-                    keep = True\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..d938a45e4 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -696,6 +696,7 @@ class Documenter:\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n+\n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n@@ -717,18 +718,10 @@ class Documenter:\n                 doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n-            # inherited and therefore not the member's doc\n-            cls = self.get_attr(member, '__class__', None)\n-            if cls:\n-                cls_doc = self.get_attr(cls, '__doc__', None)\n-                if cls_doc == doc:\n-                    doc = None\n \n-            if isinstance(obj, ObjectMember) and obj.docstring:\n-                # hack for ClassDocumenter to inject docstring via ObjectMember\n-                doc = obj.docstring\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -752,21 +745,12 @@ class Documenter:\n                 if self.options.special_members and membername in self.options.special_members:\n                     if membername == '__doc__':\n                         keep = False\n-                    elif is_filtered_inherited_member(membername, obj):\n-                        keep = False\n-                    else:\n-                        keep = has_doc or self.options.undoc_members\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n-                if want_all and isprivate:\n-                    if self.options.private_members is None:\n-                        keep = False\n-                    else:\n-                        keep = membername in self.options.private_members\n-                else:\n-                    # keep documented attributes\n-                    keep = True\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..bc828bab6 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -696,6 +696,7 @@ class Documenter:\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n+\n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n@@ -717,18 +718,10 @@ class Documenter:\n                 doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n-            # inherited and therefore not the member's doc\n-            cls = self.get_attr(member, '__class__', None)\n-            if cls:\n-                cls_doc = self.get_attr(cls, '__doc__', None)\n-                if cls_doc == doc:\n-                    doc = None\n \n-            if isinstance(obj, ObjectMember) and obj.docstring:\n-                # hack for ClassDocumenter to inject docstring via ObjectMember\n-                doc = obj.docstring\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -752,21 +745,14 @@ class Documenter:\n                 if self.options.special_members and membername in self.options.special_members:\n                     if membername == '__doc__':\n                         keep = False\n-                    elif is_filtered_inherited_member(membername, obj):\n-                        keep = False\n-                    else:\n-                        keep = has_doc or self.options.undoc_members\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n-                if want_all and isprivate:\n-                    if self.options.private_members is None:\n-                        keep = False\n-                    else:\n-                        keep = membername in self.options.private_members\n-                else:\n-                    # keep documented attributes\n-                    keep = True\n+\n+            # annotation only member in superclass\n+            doc = getdoc(value, getattr(self, 'get_attr', None), self.env.config.autodoc_inherit_docstrings, self.parent, self.object_name)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..a2e0011c0 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -696,6 +696,7 @@ class Documenter:\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n+\n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n@@ -717,18 +718,10 @@ class Documenter:\n                 doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n-            # inherited and therefore not the member's doc\n-            cls = self.get_attr(member, '__class__', None)\n-            if cls:\n-                cls_doc = self.get_attr(cls, '__doc__', None)\n-                if cls_doc == doc:\n-                    doc = None\n \n-            if isinstance(obj, ObjectMember) and obj.docstring:\n-                # hack for ClassDocumenter to inject docstring via ObjectMember\n-                doc = obj.docstring\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -752,21 +745,12 @@ class Documenter:\n                 if self.options.special_members and membername in self.options.special_members:\n                     if membername == '__doc__':\n                         keep = False\n-                    elif is_filtered_inherited_member(membername, obj):\n-                        keep = False\n-                    else:\n-                        keep = has_doc or self.options.undoc_members\n+\n+                has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n-                if want_all and isprivate:\n-                    if self.options.private_members is None:\n-                        keep = False\n-                    else:\n-                        keep = membername in self.options.private_members\n-                else:\n-                    # keep documented attributes\n-                    keep = True\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..fd2ed4126 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -696,6 +696,7 @@ class Documenter:\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n+\n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n@@ -717,18 +718,10 @@ class Documenter:\n                 doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n-            # inherited and therefore not the member's doc\n-            cls = self.get_attr(member, '__class__', None)\n-            if cls:\n-                cls_doc = self.get_attr(cls, '__doc__', None)\n-                if cls_doc == doc:\n-                    doc = None\n \n-            if isinstance(obj, ObjectMember) and obj.docstring:\n-                # hack for ClassDocumenter to inject docstring via ObjectMember\n-                doc = obj.docstring\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -752,21 +745,28 @@ class Documenter:\n                 if self.options.special_members and membername in self.options.special_members:\n                     if membername == '__doc__':\n                         keep = False\n-                    elif is_filtered_inherited_member(membername, obj):\n-                        keep = False\n-                    else:\n-                        keep = has_doc or self.options.undoc_members\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n-                if want_all and isprivate:\n-                    if self.options.private_members is None:\n-                        keep = False\n-                    else:\n-                        keep = membername in self.options.private_members\n-                else:\n-                    # keep documented attributes\n-                    keep = True\n+\n+            doc = getdoc(obj, self.get_attr, self.config.autodoc_inherit_docstrings,\n+                         self.parent, self.object_name)\n+            if not isinstance(doc, str):\n+                doc = None\n+            else:\n+                doc = prepare_docstring(doc)\n+\n+            # if the docstring is from a base class, the module analyzer won't\n+            # find the real module name\n+            try:\n+                analyzer = ModuleAnalyzer.for_module(self.real_modname)\n+                # try to also get a source code analyzer for attribute docs\n+                analyzer.find_attr_docs()\n+            except PycodeError:\n+                analyzer = None\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..b4231f009 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -696,6 +696,7 @@ class Documenter:\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n+\n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n@@ -717,18 +718,10 @@ class Documenter:\n                 doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n-            # inherited and therefore not the member's doc\n-            cls = self.get_attr(member, '__class__', None)\n-            if cls:\n-                cls_doc = self.get_attr(cls, '__doc__', None)\n-                if cls_doc == doc:\n-                    doc = None\n \n-            if isinstance(obj, ObjectMember) and obj.docstring:\n-                # hack for ClassDocumenter to inject docstring via ObjectMember\n-                doc = obj.docstring\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -752,21 +745,15 @@ class Documenter:\n                 if self.options.special_members and membername in self.options.special_members:\n                     if membername == '__doc__':\n                         keep = False\n-                    elif is_filtered_inherited_member(membername, obj):\n-                        keep = False\n-                    else:\n-                        keep = has_doc or self.options.undoc_members\n+\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n-                if want_all and isprivate:\n-                    if self.options.private_members is None:\n-                        keep = False\n-                    else:\n-                        keep = membername in self.options.private_members\n-                else:\n-                    # keep documented attributes\n-                    keep = True\n+\n+            # check for the presence of a docstring\n+            doc = getdoc(obj, self.get_attr, self.config.autodoc_inherit_docstrings,\n+                         parent, self.object_name)\n+            has_doc = bool(doc) or (namespace, membername) in attr_docs\n                 isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n"
  }
}