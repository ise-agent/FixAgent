{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/sphinx/sphinx/ext/viewcode.py lines 181-190)": "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n",
    "Location 2 (/root/hy/projects_1/sphinx/sphinx/ext/viewcode.py lines 59-62)": "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do with the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works with HTML builders)\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]'))\n                + lines[start])\n            lines[end] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        parts = modname.split('.')\n        levels = len(parts)\n        for i in range(levels):\n            level = '.'.join(parts[:i + 1])\n            if level not in stack:\n                stack.append(level)\n                indent = 4 * (i + 1)\n                if should_generate_module_page(app, level):\n                    html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n                        ' ' * indent,\n                        urito('_modules/index',\n                              posixpath.join(OUTPUT_DIRNAME, level.replace('.', '/'))),\n                        level))\n                else:\n                    html.append('%s<li>%s</li>\\n' % (' ' * indent, level))\n                html.append('%s<ul>\\n' % (' ' * indent,))\n                stack.append('')\n        html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n            ' ' * 4 * levels,\n            urito('_modules/index',\n                  posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n            modname))\n        # remove superfluous entries\n        while stack and stack[-1] != modname:\n            stack.pop()\n            html.append('%s</ul>\\n' % (' ' * 4 * len(stack),))\n\n    html.append(' ' * 4 + '</ul>\\n')\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield ('_modules/index', context, 'page.html')\n",
    "Location 3 (/root/hy/projects_1/sphinx/sphinx/ext/viewcode.py lines 197-200)": "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n",
    "Location 4 (/root/hy/projects_1/sphinx/sphinx/ext/viewcode.py lines 280-285)": "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_hover_width = max(len(entry[2]) for entry in tags.values())\n        for i, spans in used.items():\n            line = lines[i]\n            # compute padding needed to show all entries\n            n_entries = len(spans)\n            pad_width = (max_hover_width - n_entries * 4) // n_entries + 1\n            for (start, end), span_id in spans:\n                tag = tags[span_id]\n                backref = urito(pagename, refname) + '#' + refname + '.' + tag[1]\n                line = (line[:start] +\n                        '<span class=\"viewcode-link\" id=\"%s-%s\">' % (\n                            span_id, i) +\n                        '<a href=\"%s\">%s</a></span>' % (backref, tag[0]) +\n                        line[end:])\n                if pad_width > 0:\n                    line = line[:start] + (' ' * pad_width) + line[start:]\n            lines[i] = line\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith('_'):\n            continue\n        parts = modname.split('.')\n        depth = len(parts)\n        if depth > len(stack):\n            stack.extend([''] * (depth - len(stack)))\n        elif depth < len(stack):\n            stack = stack[:depth]\n        level = depth\n        if stack[level - 1]:\n            html.append('</ul>')\n        if not should_generate_module_page(app, modname):\n            continue\n\n        stack[level - 1] = modname\n        indent = (level - 1) * 4\n        if '.' in modname:\n            modpath, modname = modname.rsplit('.', 1)\n            pagename = posixpath.join(OUTPUT_DIRNAME, modpath.replace('.', '/'),\n                                      modname)\n        else:\n            pagename = posixpath.join(OUTPUT_DIRNAME, modname)\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito('index', pagename),\n            modname))\n    html.append('</ul>' * (len(stack) - 1))\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
    "Location 5 (/root/hy/projects_1/sphinx/sphinx/ext/viewcode.py lines 249-255)": "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        linenos = env.config.viewcode_line_numbers\n        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/sphinx/sphinx/ext/viewcode.py lines 181-190)": [
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n"
    ],
    "Location 2 (/root/hy/projects_1/sphinx/sphinx/ext/viewcode.py lines 59-62)": [
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    \n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        maxindex = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname_for_modname(\n                modname, name)\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, maxindex)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        parts = modname.split('.')\n        depths = [len(stack)]\n        for i, part in enumerate(parts):\n            depth = i + 1\n            if depth > depths[-1]:\n                stack.append(part)\n                html.append('<ul>')\n            elif depth == depths[-1]:\n                stack[-1] = part\n            else:\n                stack = stack[:depth] + [part]\n                for _ in range(sum(depths) - depth):\n                    html.append('</ul>')\n                    depths.pop()\n            depths.append(depth)\n            full_name = '.'.join(stack[:depth])\n            if should_generate_module_page(app, full_name):\n                html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n                    urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n                          posixpath.join(OUTPUT_DIRNAME, full_name.replace('.', '/'))),\n                    part))\n            else:\n                html.append('<li>%s</li>' % part)\n        for _ in range(len(depths) - 1):\n            html.append('</ul>')\n            depths.pop()\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    \n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type_, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        parts = modname.split('.')\n        levels = len(parts)\n        for i in range(len(stack), levels):\n            stack.append('')\n        stack = stack[:levels]\n        level = levels - 1\n        if stack[level]:\n            html.append('</ul>')\n        if level < len(stack) - 1:\n            for _ in range(len(stack) - 1, level, -1):\n                html.append('</li></ul>')\n            stack = stack[:level+1]\n        for i in range(len(stack) - 1):\n            if stack[i]:\n                html.append('<li>')\n            if i == len(stack) - 2:\n                html.append('<ul>')\n        stack[level] = modname\n        indent = 4 * (level + 1) * ' '\n        html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n            indent, urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n            modname))\n    for _ in range(len(stack) - 1, 0, -1):\n        html.append('</ul></li>')\n    html.append('</ul>')\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    \n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in {'python3', 'default', 'none'}:\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        parts = modname.split('.')\n        levels = len(parts)\n        for i in range(levels):\n            level = '.'.join(parts[:i + 1])\n            if level not in stack:\n                stack.append(level)\n                indent = 4 * (i + 1)\n                if should_generate_module_page(app, level):\n                    html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n                        ' ' * indent,\n                        urito('_modules/index',\n                              posixpath.join(OUTPUT_DIRNAME, level.replace('.', '/'))),\n                        level))\n                else:\n                    html.append('%s<li>%s</li>\\n' % (' ' * indent, level))\n                html.append('%s<ul>\\n' % (' ' * indent))\n\n        # remove superfluous entries\n        while stack and not modname.startswith(stack[-1]):\n            stack.pop()\n            html.append('%s</ul>\\n' % (' ' * 4 * len(stack)))\n\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': '<h1>%s</h1>\\n<ul>%s</ul>' % (_('All modules for which code is available'),\n                                              ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    \n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        parts = modname.split('.')\n        levels = len(parts)\n        # determine how many <ul> tags we have to add/remove\n        for _ in range(levels, len(stack)):\n            stack.pop()\n            html.append('</ul>')\n        for _ in range(len(stack), levels):\n            stack.append('')\n            html.append('<ul>')\n        # add the entry for the module\n        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito('index', urlpath), modname))\n    for _ in range(1, len(stack)):\n        html.append('</ul>')\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n"
    ],
    "Location 3 (/root/hy/projects_1/sphinx/sphinx/ext/viewcode.py lines 197-200)": [
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n"
    ],
    "Location 4 (/root/hy/projects_1/sphinx/sphinx/ext/viewcode.py lines 280-285)": [
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in {'default', 'none'}:\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        linenos = env.config.html_show_sourcelink and env.config.html_copy_source\n        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME,\n                                                 parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        parts = modname.split('.')\n        levels = len(parts)\n        for level in range(1, levels):\n            if '.'.join(parts[:level]) not in modnames:\n                levels = level\n                break\n        depth = len(stack)\n        if levels > depth:\n            stack.extend([''] * (levels - depth))\n        elif levels < depth:\n            stack = stack[:levels]\n        level = levels - 1\n        if stack[level]:\n            stack[level] += ', '\n        stack[level] += '<a href=\"%s\">%s</a>' % (\n            urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n            modname)\n        if stack[level].count('<a') == 1:\n            if level == 0:\n                html.append('<li><code>%s</code></li>\\n' % stack[level])\n            else:\n                html.append('<li><code>%s</code><ul>\\n' % stack[level])\n        if level < depth - 1:\n            html.extend(['</ul></li>\\n'] * (depth - 1 - level))\n\n    html.extend(['</ul></li>\\n'] * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in {'python3', 'default', 'none'}:\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        stacklevel = stack.index('')\n        stack = stack[:stacklevel + 1]\n        stack.append(modname)\n        indent = len(stack) - 1\n        split_module = modname.split('.')\n        if len(split_module) > indent:\n            # nested submodule, close stack to correct level\n            for _ in range(len(split_module) - indent):\n                stack.append('')\n        # create a relative link from the module index page to the\n        # highlighted source\n        link = urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n                     posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/')))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n\n    html.append('')\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n            modname))\n\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        parts = modname.split('.')\n        depths = [_find_depth(x, parts, modnames) for x in parts]\n        item = '<a href=\"%s\">%s</a>' % (\n            urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n            modname)\n        if len(stack) < depths[-1]:\n            stack.extend([''] * (depths[-1] - len(stack)))\n        elif len(stack) > depths[-1]:\n            stack = stack[:depths[-1]]\n        level = depths[-1]\n        if stack[level - 1]:\n            stack[level - 1] += '</li>'\n        stack[level - 1] += '<li>' + item\n    stack = [s + '</li>' for s in stack if s]\n    for s in reversed(stack):\n        html.append('<ul>')\n        html.append(s)\n        html.append('</ul>')\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    \n    if not should_generate_module_page(app):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith('_'):\n            continue\n        parts = modname.split('.')\n        depths = [_find_depth(x, stack, parts) for x in range(len(parts))]\n        item = '<a href=\"%s\">%s</a>' % (\n            urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n            parts[-1])\n        if depths[-1] == 0:\n            html.append('<ul><li>%s</li></ul>' % item)\n        else:\n            html.append(_indent(item, depths[-1]))\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    \n    if not should_generate_module_page(app):\n        return\n    \n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in {'python3', 'default', 'none'}:\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        link = urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n                     posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/')))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n    html.append('</ul>' * (len(stack) - 1))\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]'))\n                + lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        while not modname.startswith(stack[-1]):\n            stack.pop()\n            html.append('</ul>')\n\n        stack.append(modname + '.')\n        html.append('<ul>')\n\n        modpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), modpath),\n            modname))\n\n    html.append('</ul>' * (len(stack) - 1))\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), urlpath),\n            modname))\n    html.append('</ul>' * (len(stack) - 1))\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n"
    ],
    "Location 5 (/root/hy/projects_1/sphinx/sphinx/ext/viewcode.py lines 249-255)": [
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    \n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        linenos = env.config.viewcode_line_numbers\n        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n",
      "\n    if not env.config.viewcode_include_source:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlight_language = env.config.highlight_language\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in {'python3', 'default', 'none'}:\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        linenos = env.config.viewcode_line_numbers\n        highlighted = app.builder.highlighter.highlight_block(\n            code, lexer, linenos=linenos)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        linenos = env.config.viewcode_line_numbers\n        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname, lineno in used:\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        linenos = env.config.viewcode_line_numbers\n        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n        \n    if not should_generate_module_page(app, env):\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_target_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        linenos = env.config.viewcode_line_numbers\n        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do with the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(posixpath.join(OUTPUT_DIRNAME,\n                                                 parent.replace('.', '/'))),\n                    'title': parent})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env._viewcode_modules:\n        return\n    \n    # Check if viewcode should be disabled for EPUB builders\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in {'python3', 'default', 'none'}:\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        linenos = env.config.viewcode_line_numbers\n        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not env.config.viewcode_enable_epub and app.builder.name.startswith(\"epub\"):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        linenos = env.config.viewcode_line_numbers\n        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do with the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_idx = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_idx)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..4b75f737c 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,6 +56,7 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n \n@@ -178,10 +179,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n@@ -194,6 +198,7 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n             app.verbosity, lambda x: x[0]):\n         if not entry:\n             continue\n+\n         if not should_generate_module_page(app, modname):\n             continue\n \n@@ -246,6 +251,7 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         }\n         yield (pagename, context, 'page.html')\n \n+\n     if not modnames:\n         return\n \n@@ -277,6 +283,7 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n+\n     app.add_config_value('viewcode_import', None, False)\n     app.add_config_value('viewcode_enable_epub', False, False)\n     app.add_config_value('viewcode_follow_imported_members', True, False)\n",
    "variant_0": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..3bb88f3e0 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,10 +56,124 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n \n-    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do with the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works with HTML builders)\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]'))\n+                + lines[start])\n+            lines[end] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        parts = modname.split('.')\n+        levels = len(parts)\n+        for i in range(levels):\n+            level = '.'.join(parts[:i + 1])\n+            if level not in stack:\n+                stack.append(level)\n+                indent = 4 * (i + 1)\n+                if should_generate_module_page(app, level):\n+                    html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n+                        ' ' * indent,\n+                        urito('_modules/index',\n+                              posixpath.join(OUTPUT_DIRNAME, level.replace('.', '/'))),\n+                        level))\n+                else:\n+                    html.append('%s<li>%s</li>\\n' % (' ' * indent, level))\n+                html.append('%s<ul>\\n' % (' ' * indent,))\n+                stack.append('')\n+        html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n+            ' ' * 4 * levels,\n+            urito('_modules/index',\n+                  posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+            modname))\n+        # remove superfluous entries\n+        while stack and stack[-1] != modname:\n+            stack.pop()\n+            html.append('%s</ul>\\n' % (' ' * 4 * len(stack),))\n+\n+    html.append(' ' * 4 + '</ul>\\n')\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield ('_modules/index', context, 'page.html')\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n         if entry is False:\n             return False\n@@ -178,15 +292,42 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n     modnames = set(env._viewcode_modules)  # type: ignore\n \n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n     for modname, entry in status_iterator(\n             sorted(env._viewcode_modules.items()),  # type: ignore\n             __('highlighting module code... '), \"blue\",\n@@ -246,6 +387,81 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         }\n         yield (pagename, context, 'page.html')\n \n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        linenos = env.config.viewcode_line_numbers\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n     if not modnames:\n         return\n \n@@ -277,12 +493,131 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n-    app.add_config_value('viewcode_import', None, False)\n-    app.add_config_value('viewcode_enable_epub', False, False)\n-    app.add_config_value('viewcode_follow_imported_members', True, False)\n-    app.connect('doctree-read', doctree_read)\n-    app.connect('env-merge-info', env_merge_info)\n-    app.connect('html-collect-pages', collect_pages)\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_hover_width = max(len(entry[2]) for entry in tags.values())\n+        for i, spans in used.items():\n+            line = lines[i]\n+            # compute padding needed to show all entries\n+            n_entries = len(spans)\n+            pad_width = (max_hover_width - n_entries * 4) // n_entries + 1\n+            for (start, end), span_id in spans:\n+                tag = tags[span_id]\n+                backref = urito(pagename, refname) + '#' + refname + '.' + tag[1]\n+                line = (line[:start] +\n+                        '<span class=\"viewcode-link\" id=\"%s-%s\">' % (\n+                            span_id, i) +\n+                        '<a href=\"%s\">%s</a></span>' % (backref, tag[0]) +\n+                        line[end:])\n+                if pad_width > 0:\n+                    line = line[:start] + (' ' * pad_width) + line[start:]\n+            lines[i] = line\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith('_'):\n+            continue\n+        parts = modname.split('.')\n+        depth = len(parts)\n+        if depth > len(stack):\n+            stack.extend([''] * (depth - len(stack)))\n+        elif depth < len(stack):\n+            stack = stack[:depth]\n+        level = depth\n+        if stack[level - 1]:\n+            html.append('</ul>')\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        stack[level - 1] = modname\n+        indent = (level - 1) * 4\n+        if '.' in modname:\n+            modpath, modname = modname.rsplit('.', 1)\n+            pagename = posixpath.join(OUTPUT_DIRNAME, modpath.replace('.', '/'),\n+                                      modname)\n+        else:\n+            pagename = posixpath.join(OUTPUT_DIRNAME, modname)\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito('index', pagename),\n+            modname))\n+    html.append('</ul>' * (len(stack) - 1))\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n     app.connect('missing-reference', missing_reference)\n     # app.add_config_value('viewcode_include_modules', [], 'env')\n     # app.add_config_value('viewcode_exclude_modules', [], 'env')\n",
    "variant_1": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..35d084ae4 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,10 +56,18 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n-\n-    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n         if entry is False:\n             return False\n@@ -178,15 +186,42 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n     modnames = set(env._viewcode_modules)  # type: ignore\n \n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n     for modname, entry in status_iterator(\n             sorted(env._viewcode_modules.items()),  # type: ignore\n             __('highlighting module code... '), \"blue\",\n@@ -246,6 +281,78 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         }\n         yield (pagename, context, 'page.html')\n \n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+    \n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        linenos = env.config.viewcode_line_numbers\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n     if not modnames:\n         return\n \n@@ -277,12 +384,127 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n-    app.add_config_value('viewcode_import', None, False)\n-    app.add_config_value('viewcode_enable_epub', False, False)\n-    app.add_config_value('viewcode_follow_imported_members', True, False)\n-    app.connect('doctree-read', doctree_read)\n-    app.connect('env-merge-info', env_merge_info)\n-    app.connect('html-collect-pages', collect_pages)\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in {'default', 'none'}:\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        linenos = env.config.html_show_sourcelink and env.config.html_copy_source\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME,\n+                                                 parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        parts = modname.split('.')\n+        levels = len(parts)\n+        for level in range(1, levels):\n+            if '.'.join(parts[:level]) not in modnames:\n+                levels = level\n+                break\n+        depth = len(stack)\n+        if levels > depth:\n+            stack.extend([''] * (levels - depth))\n+        elif levels < depth:\n+            stack = stack[:levels]\n+        level = levels - 1\n+        if stack[level]:\n+            stack[level] += ', '\n+        stack[level] += '<a href=\"%s\">%s</a>' % (\n+            urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+            modname)\n+        if stack[level].count('<a') == 1:\n+            if level == 0:\n+                html.append('<li><code>%s</code></li>\\n' % stack[level])\n+            else:\n+                html.append('<li><code>%s</code><ul>\\n' % stack[level])\n+        if level < depth - 1:\n+            html.extend(['</ul></li>\\n'] * (depth - 1 - level))\n+\n+    html.extend(['</ul></li>\\n'] * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n     app.connect('missing-reference', missing_reference)\n     # app.add_config_value('viewcode_include_modules', [], 'env')\n     # app.add_config_value('viewcode_exclude_modules', [], 'env')\n",
    "variant_2": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..bf51ebc02 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,10 +56,16 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n-\n-    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n         if entry is False:\n             return False\n@@ -178,15 +184,42 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n     modnames = set(env._viewcode_modules)  # type: ignore\n \n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n     for modname, entry in status_iterator(\n             sorted(env._viewcode_modules.items()),  # type: ignore\n             __('highlighting module code... '), \"blue\",\n@@ -246,6 +279,79 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         }\n         yield (pagename, context, 'page.html')\n \n+\n+    if not env.config.viewcode_include_source:\n+        return\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlight_language = env.config.highlight_language\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in {'python3', 'default', 'none'}:\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        linenos = env.config.viewcode_line_numbers\n+        highlighted = app.builder.highlighter.highlight_block(\n+            code, lexer, linenos=linenos)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n     if not modnames:\n         return\n \n@@ -277,12 +383,116 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n-    app.add_config_value('viewcode_import', None, False)\n-    app.add_config_value('viewcode_enable_epub', False, False)\n-    app.add_config_value('viewcode_follow_imported_members', True, False)\n-    app.connect('doctree-read', doctree_read)\n-    app.connect('env-merge-info', env_merge_info)\n-    app.connect('html-collect-pages', collect_pages)\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in {'python3', 'default', 'none'}:\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        stacklevel = stack.index('')\n+        stack = stack[:stacklevel + 1]\n+        stack.append(modname)\n+        indent = len(stack) - 1\n+        split_module = modname.split('.')\n+        if len(split_module) > indent:\n+            # nested submodule, close stack to correct level\n+            for _ in range(len(split_module) - indent):\n+                stack.append('')\n+        # create a relative link from the module index page to the\n+        # highlighted source\n+        link = urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n+                     posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/')))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n+\n+    html.append('')\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n     app.connect('missing-reference', missing_reference)\n     # app.add_config_value('viewcode_include_modules', [], 'env')\n     # app.add_config_value('viewcode_exclude_modules', [], 'env')\n",
    "variant_3": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..a69b2e796 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,10 +56,126 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    \n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        maxindex = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname_for_modname(\n+                modname, name)\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, maxindex)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n \n-    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        parts = modname.split('.')\n+        depths = [len(stack)]\n+        for i, part in enumerate(parts):\n+            depth = i + 1\n+            if depth > depths[-1]:\n+                stack.append(part)\n+                html.append('<ul>')\n+            elif depth == depths[-1]:\n+                stack[-1] = part\n+            else:\n+                stack = stack[:depth] + [part]\n+                for _ in range(sum(depths) - depth):\n+                    html.append('</ul>')\n+                    depths.pop()\n+            depths.append(depth)\n+            full_name = '.'.join(stack[:depth])\n+            if should_generate_module_page(app, full_name):\n+                html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+                    urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n+                          posixpath.join(OUTPUT_DIRNAME, full_name.replace('.', '/'))),\n+                    part))\n+            else:\n+                html.append('<li>%s</li>' % part)\n+        for _ in range(len(depths) - 1):\n+            html.append('</ul>')\n+            depths.pop()\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n         if entry is False:\n             return False\n@@ -178,15 +294,42 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n     modnames = set(env._viewcode_modules)  # type: ignore\n \n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n     for modname, entry in status_iterator(\n             sorted(env._viewcode_modules.items()),  # type: ignore\n             __('highlighting module code... '), \"blue\",\n@@ -246,6 +389,81 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         }\n         yield (pagename, context, 'page.html')\n \n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        linenos = env.config.viewcode_line_numbers\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname, lineno in used:\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n     if not modnames:\n         return\n \n@@ -277,12 +495,115 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n-    app.add_config_value('viewcode_import', None, False)\n-    app.add_config_value('viewcode_enable_epub', False, False)\n-    app.add_config_value('viewcode_follow_imported_members', True, False)\n-    app.connect('doctree-read', doctree_read)\n-    app.connect('env-merge-info', env_merge_info)\n-    app.connect('html-collect-pages', collect_pages)\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+            modname))\n+\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n     app.connect('missing-reference', missing_reference)\n     # app.add_config_value('viewcode_include_modules', [], 'env')\n     # app.add_config_value('viewcode_exclude_modules', [], 'env')\n",
    "variant_4": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..caffff4e8 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,10 +56,124 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    \n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n \n-    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type_, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        parts = modname.split('.')\n+        levels = len(parts)\n+        for i in range(len(stack), levels):\n+            stack.append('')\n+        stack = stack[:levels]\n+        level = levels - 1\n+        if stack[level]:\n+            html.append('</ul>')\n+        if level < len(stack) - 1:\n+            for _ in range(len(stack) - 1, level, -1):\n+                html.append('</li></ul>')\n+            stack = stack[:level+1]\n+        for i in range(len(stack) - 1):\n+            if stack[i]:\n+                html.append('<li>')\n+            if i == len(stack) - 2:\n+                html.append('<ul>')\n+        stack[level] = modname\n+        indent = 4 * (level + 1) * ' '\n+        html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n+            indent, urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+            modname))\n+    for _ in range(len(stack) - 1, 0, -1):\n+        html.append('</ul></li>')\n+    html.append('</ul>')\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n         if entry is False:\n             return False\n@@ -178,10 +292,38 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n@@ -246,6 +388,81 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         }\n         yield (pagename, context, 'page.html')\n \n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        linenos = env.config.viewcode_line_numbers\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n     if not modnames:\n         return\n \n@@ -277,12 +494,117 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n-    app.add_config_value('viewcode_import', None, False)\n-    app.add_config_value('viewcode_enable_epub', False, False)\n-    app.add_config_value('viewcode_follow_imported_members', True, False)\n-    app.connect('doctree-read', doctree_read)\n-    app.connect('env-merge-info', env_merge_info)\n-    app.connect('html-collect-pages', collect_pages)\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        parts = modname.split('.')\n+        depths = [_find_depth(x, parts, modnames) for x in parts]\n+        item = '<a href=\"%s\">%s</a>' % (\n+            urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+            modname)\n+        if len(stack) < depths[-1]:\n+            stack.extend([''] * (depths[-1] - len(stack)))\n+        elif len(stack) > depths[-1]:\n+            stack = stack[:depths[-1]]\n+        level = depths[-1]\n+        if stack[level - 1]:\n+            stack[level - 1] += '</li>'\n+        stack[level - 1] += '<li>' + item\n+    stack = [s + '</li>' for s in stack if s]\n+    for s in reversed(stack):\n+        html.append('<ul>')\n+        html.append(s)\n+        html.append('</ul>')\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n     app.connect('missing-reference', missing_reference)\n     # app.add_config_value('viewcode_include_modules', [], 'env')\n     # app.add_config_value('viewcode_exclude_modules', [], 'env')\n",
    "variant_5": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..4d7dcf9c9 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,10 +56,121 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    \n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in {'python3', 'default', 'none'}:\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n \n-    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        parts = modname.split('.')\n+        levels = len(parts)\n+        for i in range(levels):\n+            level = '.'.join(parts[:i + 1])\n+            if level not in stack:\n+                stack.append(level)\n+                indent = 4 * (i + 1)\n+                if should_generate_module_page(app, level):\n+                    html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n+                        ' ' * indent,\n+                        urito('_modules/index',\n+                              posixpath.join(OUTPUT_DIRNAME, level.replace('.', '/'))),\n+                        level))\n+                else:\n+                    html.append('%s<li>%s</li>\\n' % (' ' * indent, level))\n+                html.append('%s<ul>\\n' % (' ' * indent))\n+\n+        # remove superfluous entries\n+        while stack and not modname.startswith(stack[-1]):\n+            stack.pop()\n+            html.append('%s</ul>\\n' % (' ' * 4 * len(stack)))\n+\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': '<h1>%s</h1>\\n<ul>%s</ul>' % (_('All modules for which code is available'),\n+                                              ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n         if entry is False:\n             return False\n@@ -178,15 +289,42 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n     modnames = set(env._viewcode_modules)  # type: ignore\n \n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n     for modname, entry in status_iterator(\n             sorted(env._viewcode_modules.items()),  # type: ignore\n             __('highlighting module code... '), \"blue\",\n@@ -246,6 +384,79 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         }\n         yield (pagename, context, 'page.html')\n \n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+        \n+    if not should_generate_module_page(app, env):\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_target_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        linenos = env.config.viewcode_line_numbers\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do with the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(posixpath.join(OUTPUT_DIRNAME,\n+                                                 parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n     if not modnames:\n         return\n \n@@ -277,12 +488,107 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n-    app.add_config_value('viewcode_import', None, False)\n-    app.add_config_value('viewcode_enable_epub', False, False)\n-    app.add_config_value('viewcode_follow_imported_members', True, False)\n-    app.connect('doctree-read', doctree_read)\n-    app.connect('env-merge-info', env_merge_info)\n-    app.connect('html-collect-pages', collect_pages)\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+    \n+    if not should_generate_module_page(app):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith('_'):\n+            continue\n+        parts = modname.split('.')\n+        depths = [_find_depth(x, stack, parts) for x in range(len(parts))]\n+        item = '<a href=\"%s\">%s</a>' % (\n+            urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+            parts[-1])\n+        if depths[-1] == 0:\n+            html.append('<ul><li>%s</li></ul>' % item)\n+        else:\n+            html.append(_indent(item, depths[-1]))\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n     app.connect('missing-reference', missing_reference)\n     # app.add_config_value('viewcode_include_modules', [], 'env')\n     # app.add_config_value('viewcode_exclude_modules', [], 'env')\n",
    "variant_6": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..1b3db2ece 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,10 +56,16 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n-\n-    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n         if entry is False:\n             return False\n@@ -178,15 +184,42 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n     modnames = set(env._viewcode_modules)  # type: ignore\n \n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n     for modname, entry in status_iterator(\n             sorted(env._viewcode_modules.items()),  # type: ignore\n             __('highlighting module code... '), \"blue\",\n@@ -246,6 +279,80 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         }\n         yield (pagename, context, 'page.html')\n \n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n     if not modnames:\n         return\n \n@@ -277,12 +384,110 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n-    app.add_config_value('viewcode_import', None, False)\n-    app.add_config_value('viewcode_enable_epub', False, False)\n-    app.add_config_value('viewcode_follow_imported_members', True, False)\n-    app.connect('doctree-read', doctree_read)\n-    app.connect('env-merge-info', env_merge_info)\n-    app.connect('html-collect-pages', collect_pages)\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+    \n+    if not should_generate_module_page(app):\n+        return\n+    \n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in {'python3', 'default', 'none'}:\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        link = urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n+                     posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/')))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n+    html.append('</ul>' * (len(stack) - 1))\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n     app.connect('missing-reference', missing_reference)\n     # app.add_config_value('viewcode_include_modules', [], 'env')\n     # app.add_config_value('viewcode_exclude_modules', [], 'env')\n",
    "variant_7": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..4431af2c0 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,10 +56,114 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    \n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n \n-    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        parts = modname.split('.')\n+        levels = len(parts)\n+        # determine how many <ul> tags we have to add/remove\n+        for _ in range(levels, len(stack)):\n+            stack.pop()\n+            html.append('</ul>')\n+        for _ in range(len(stack), levels):\n+            stack.append('')\n+            html.append('<ul>')\n+        # add the entry for the module\n+        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito('index', urlpath), modname))\n+    for _ in range(1, len(stack)):\n+        html.append('</ul>')\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n         if entry is False:\n             return False\n@@ -178,15 +282,42 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n     modnames = set(env._viewcode_modules)  # type: ignore\n \n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n     for modname, entry in status_iterator(\n             sorted(env._viewcode_modules.items()),  # type: ignore\n             __('highlighting module code... '), \"blue\",\n@@ -246,6 +377,81 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         }\n         yield (pagename, context, 'page.html')\n \n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in {'python3', 'default', 'none'}:\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        linenos = env.config.viewcode_line_numbers\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n     if not modnames:\n         return\n \n@@ -277,12 +483,113 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n-    app.add_config_value('viewcode_import', None, False)\n-    app.add_config_value('viewcode_enable_epub', False, False)\n-    app.add_config_value('viewcode_follow_imported_members', True, False)\n-    app.connect('doctree-read', doctree_read)\n-    app.connect('env-merge-info', env_merge_info)\n-    app.connect('html-collect-pages', collect_pages)\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]'))\n+                + lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        while not modname.startswith(stack[-1]):\n+            stack.pop()\n+            html.append('</ul>')\n+\n+        stack.append(modname + '.')\n+        html.append('<ul>')\n+\n+        modpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), modpath),\n+            modname))\n+\n+    html.append('</ul>' * (len(stack) - 1))\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n     app.connect('missing-reference', missing_reference)\n     # app.add_config_value('viewcode_include_modules', [], 'env')\n     # app.add_config_value('viewcode_exclude_modules', [], 'env')\n",
    "variant_8": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..9cfb7d933 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,10 +56,18 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n-\n-    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n         if entry is False:\n             return False\n@@ -178,15 +186,42 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n     modnames = set(env._viewcode_modules)  # type: ignore\n \n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    \n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n     for modname, entry in status_iterator(\n             sorted(env._viewcode_modules.items()),  # type: ignore\n             __('highlighting module code... '), \"blue\",\n@@ -246,6 +281,73 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n         }\n         yield (pagename, context, 'page.html')\n \n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env.config.viewcode_enable_epub and app.builder.name.startswith(\"epub\"):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        linenos = env.config.viewcode_line_numbers\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do with the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_idx = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_idx)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n     if not modnames:\n         return\n \n@@ -277,12 +379,112 @@ def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], Non\n \n \n def setup(app: Sphinx) -> Dict[str, Any]:\n-    app.add_config_value('viewcode_import', None, False)\n-    app.add_config_value('viewcode_enable_epub', False, False)\n-    app.add_config_value('viewcode_follow_imported_members', True, False)\n-    app.connect('doctree-read', doctree_read)\n-    app.connect('env-merge-info', env_merge_info)\n-    app.connect('html-collect-pages', collect_pages)\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not env._viewcode_modules:\n+        return\n+    # Check if viewcode should be disabled for EPUB builders\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n+\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), urlpath),\n+            modname))\n+    html.append('</ul>' * (len(stack) - 1))\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n     app.connect('missing-reference', missing_reference)\n     # app.add_config_value('viewcode_include_modules', [], 'env')\n     # app.add_config_value('viewcode_exclude_modules', [], 'env')\n"
  }
}