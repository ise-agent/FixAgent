{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 585-593)": "\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
    "Location 2 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 562-594)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
    "Location 3 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 529-533)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        constraint_name = constraint_names[0]\n        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n",
    "Location 4 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 520-540)": "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    if len(constraint_names) == 0:\n        # Constraint may have been already removed by a previous operation\n        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n        return\n    elif len(constraint_names) != 1:\n        raise ValueError(\n            \"Found wrong number (%s) of constraints for %s(%s)\"\n            % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            )\n        )\n    constraint_name = constraint_names[0]\n    self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n",
    "Location 5 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 1669-1708)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 585-593)": [
      "\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n",
      "\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 562-594)": [
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {\n        constraint.name for constraint in model._meta.constraints\n    }\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model,\n        columns,\n        exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs,\n    )\n    if (\n        constraint_kwargs.get(\"unique\") is True\n        and constraint_names\n        and self.connection.features.allows_multiple_constraints_on_same_fields\n    ):\n        # Constraint matching the unique_together name.\n        default_name = str(\n            self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n        )\n        if default_name in constraint_names:\n            constraint_names = [default_name]\n    if len(constraint_names) == 0:\n        # Constraint may have been already removed by a previous operation\n        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n        return\n    elif len(constraint_names) != 1:\n        raise ValueError(\n            \"Found wrong number (%s) of constraints for %s(%s)\"\n            % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            )\n        )\n    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 529-533)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(sql % {\n            \"table\": self.quote_name(model._meta.db_table),\n            \"name\": self.quote_name(constraint_names[0]),\n        })\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names, **constraint_kwargs\n    )\n    if len(constraint_names) == 0:\n        # Constraint may have been already removed by a previous operation\n        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n        return\n    elif len(constraint_names) != 1:\n        raise ValueError(\n            \"Found wrong number (%s) of constraints for %s(%s)\"\n            % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            )\n        )\n    constraint_name = constraint_names[0]\n    self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    if len(constraint_names) == 0:\n        # Constraint may have been already removed by a previous operation\n        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n        return\n    elif len(constraint_names) != 1:\n        raise ValueError(\n            \"Found wrong number (%s) of constraints for %s(%s)\"\n            % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            )\n        )\n    constraint_name = constraint_names[0]\n    self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 520-540)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        constraint_name = constraint_names[0]\n        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    if len(constraint_names) == 0:\n        # Constraint may have been already removed by a previous operation\n        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n        return\n    elif len(constraint_names) != 1:\n        raise ValueError(\n            \"Found wrong number (%s) of constraints for %s(%s)\"\n            % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            )\n        )\n    constraint_name = constraint_names[0]\n    constraint_sql = sql % {\n        \"table\": self.quote_name(model._meta.db_table),\n        \"name\": self.quote_name(constraint_name),\n    }\n    self.execute(constraint_sql)\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    if len(constraint_names) == 0:\n        # Constraint may have been already removed by a previous operation\n        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n        return\n    elif len(constraint_names) != 1:\n        raise ValueError(\n            \"Found wrong number (%s) of constraints for %s(%s)\"\n            % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            )\n        )\n    constraint_name = constraint_names[0]\n    constraint_sql = sql % {\n        \"table\": self.quote_name(model._meta.db_table),\n        \"name\": self.quote_name(constraint_name),\n    }\n    self.execute(constraint_sql)\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    if len(constraint_names) == 0:\n        # Constraint may have been already removed by a previous operation\n        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n        return\n    elif len(constraint_names) != 1:\n        raise ValueError(\n            \"Found wrong number (%s) of constraints for %s(%s)\"\n            % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            )\n        )\n    constraint_name = constraint_names[0]\n    self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 1669-1708)": [
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    if len(constraint_names) == 0:\n        # Constraint may have been already removed by a previous operation\n        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n        return\n    elif len(constraint_names) != 1:\n        raise ValueError(\n            \"Found wrong number (%s) of constraints for %s(%s)\"\n            % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            )\n        )\n    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        constraint_name = constraint_names[0]\n        # Constraint names from the database introspection aren't the same\n        # format as the ones from get_constraints() which are used by the\n        # migration writer, so we're aiming for the format that will be\n        # expected by the migration writer.\n        if constraint_name in meta_constraint_names:\n            # Core constraint, let Django format the name\n            constraint_name = constraint_name\n        elif constraint_name in meta_index_names:\n            # Core index, let Django format the name\n            constraint_name = constraint_name\n        else:\n            # Autogenerated name\n            constraint_name = self.quote_name(constraint_name)\n        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        constraint_name = constraint_names[0]\n        # Constraint names are unique across indexes and constraints.\n        is_index = constraint_name not in meta_constraint_names\n        if is_index:\n            self.execute(self._delete_index_sql(model, constraint_name))\n        else:\n            self.execute(Statement(sql, table=Table(model._meta.db_table, self.quote_name), name=self.quote_name(constraint_name)))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            # Constraint may have been already removed by a previous operation\n            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n            return\n        elif len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        constraint_name = constraint_names[0]\n        # Constraint names from the database introspection aren't the same\n        # format as the ones from get_constraints() which is\n        # {constraint_name: {columns: [col_name, ...], ...}.\n        # Make sure we have the same format so we can compare them.\n        constraint_name = self.connection.introspection.identifier_converter(\n            constraint_name\n        )\n        if constraint_name in meta_constraint_names:\n            # A constraint will be added later.\n            return\n\n        if constraint_name in meta_index_names:\n            # An index will be added later\n            return\n        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..53e34cdd4e 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,6 +517,7 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n+\n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n@@ -559,6 +560,7 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n@@ -582,7 +584,11 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +597,11 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1666,6 +1677,7 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n+\n     def _constraint_names(\n         self,\n         model,\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..c5f584ee84 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,20 +517,42 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n-        \"\"\"\n-        Deal with a model changing its unique_together. The input\n-        unique_togethers must be doubly-nested, not the single-nested\n-        [\"foo\", \"bar\"] format.\n-        \"\"\"\n-        olds = {tuple(fields) for fields in old_unique_together}\n-        news = {tuple(fields) for fields in new_unique_together}\n-        # Deleted uniques\n-        for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"unique\": True, \"primary_key\": False},\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    if len(constraint_names) == 0:\n+        # Constraint may have been already removed by a previous operation\n+        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+        return\n+    elif len(constraint_names) != 1:\n+        raise ValueError(\n+            \"Found wrong number (%s) of constraints for %s(%s)\"\n+            % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            )\n+        )\n+    constraint_name = constraint_names[0]\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        constraint_name = constraint_names[0]\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n                 self.sql_delete_unique,\n             )\n         # Created uniques\n@@ -559,6 +581,7 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n@@ -582,7 +605,11 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +618,11 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1666,46 +1698,29 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n-    def _constraint_names(\n-        self,\n-        model,\n-        column_names=None,\n-        unique=None,\n-        primary_key=None,\n-        index=None,\n-        foreign_key=None,\n-        check=None,\n-        type_=None,\n-        exclude=None,\n-    ):\n-        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n-        if column_names is not None:\n-            column_names = [\n-                self.connection.introspection.identifier_converter(name)\n-                for name in column_names\n-            ]\n-        with self.connection.cursor() as cursor:\n-            constraints = self.connection.introspection.get_constraints(\n-                cursor, model._meta.db_table\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n             )\n-        result = []\n-        for name, infodict in constraints.items():\n-            if column_names is None or column_names == infodict[\"columns\"]:\n-                if unique is not None and infodict[\"unique\"] != unique:\n-                    continue\n-                if primary_key is not None and infodict[\"primary_key\"] != primary_key:\n-                    continue\n-                if index is not None and infodict[\"index\"] != index:\n-                    continue\n-                if check is not None and infodict[\"check\"] != check:\n-                    continue\n-                if foreign_key is not None and not infodict[\"foreign_key\"]:\n-                    continue\n-                if type_ is not None and infodict[\"type\"] != type_:\n-                    continue\n-                if not exclude or name not in exclude:\n-                    result.append(name)\n-        return result\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def _delete_primary_key(self, model, strict=False):\n         constraint_names = self._constraint_names(model, primary_key=True)\n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..1d4994423e 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,20 +517,37 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n-        \"\"\"\n-        Deal with a model changing its unique_together. The input\n-        unique_togethers must be doubly-nested, not the single-nested\n-        [\"foo\", \"bar\"] format.\n-        \"\"\"\n-        olds = {tuple(fields) for fields in old_unique_together}\n-        news = {tuple(fields) for fields in new_unique_together}\n-        # Deleted uniques\n-        for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"unique\": True, \"primary_key\": False},\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n                 self.sql_delete_unique,\n             )\n         # Created uniques\n@@ -559,34 +576,44 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n-        meta_constraint_names = {\n-            constraint.name for constraint in model._meta.constraints\n-        }\n-        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n-            model,\n-            columns,\n-            exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs,\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {\n+        constraint.name for constraint in model._meta.constraints\n+    }\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model,\n+        columns,\n+        exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs,\n+    )\n+    if (\n+        constraint_kwargs.get(\"unique\") is True\n+        and constraint_names\n+        and self.connection.features.allows_multiple_constraints_on_same_fields\n+    ):\n+        # Constraint matching the unique_together name.\n+        default_name = str(\n+            self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n         )\n-        if (\n-            constraint_kwargs.get(\"unique\") is True\n-            and constraint_names\n-            and self.connection.features.allows_multiple_constraints_on_same_fields\n-        ):\n-            # Constraint matching the unique_together name.\n-            default_name = str(\n-                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+        if default_name in constraint_names:\n+            constraint_names = [default_name]\n+    if len(constraint_names) == 0:\n+        # Constraint may have been already removed by a previous operation\n+        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+        return\n+    elif len(constraint_names) != 1:\n+        raise ValueError(\n+            \"Found wrong number (%s) of constraints for %s(%s)\"\n+            % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n             )\n-            if default_name in constraint_names:\n-                constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n-            raise ValueError(\n-                \"Found wrong number (%s) of constraints for %s(%s)\"\n-                % (\n-                    len(constraint_names),\n+        )\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n                     model._meta.db_table,\n                     \", \".join(columns),\n                 )\n@@ -1666,46 +1693,29 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n-    def _constraint_names(\n-        self,\n-        model,\n-        column_names=None,\n-        unique=None,\n-        primary_key=None,\n-        index=None,\n-        foreign_key=None,\n-        check=None,\n-        type_=None,\n-        exclude=None,\n-    ):\n-        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n-        if column_names is not None:\n-            column_names = [\n-                self.connection.introspection.identifier_converter(name)\n-                for name in column_names\n-            ]\n-        with self.connection.cursor() as cursor:\n-            constraints = self.connection.introspection.get_constraints(\n-                cursor, model._meta.db_table\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    if len(constraint_names) == 0:\n+        # Constraint may have been already removed by a previous operation\n+        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+        return\n+    elif len(constraint_names) != 1:\n+        raise ValueError(\n+            \"Found wrong number (%s) of constraints for %s(%s)\"\n+            % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n             )\n-        result = []\n-        for name, infodict in constraints.items():\n-            if column_names is None or column_names == infodict[\"columns\"]:\n-                if unique is not None and infodict[\"unique\"] != unique:\n-                    continue\n-                if primary_key is not None and infodict[\"primary_key\"] != primary_key:\n-                    continue\n-                if index is not None and infodict[\"index\"] != index:\n-                    continue\n-                if check is not None and infodict[\"check\"] != check:\n-                    continue\n-                if foreign_key is not None and not infodict[\"foreign_key\"]:\n-                    continue\n-                if type_ is not None and infodict[\"type\"] != type_:\n-                    continue\n-                if not exclude or name not in exclude:\n-                    result.append(name)\n-        return result\n+        )\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def _delete_primary_key(self, model, strict=False):\n         constraint_names = self._constraint_names(model, primary_key=True)\n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..14f0cde46b 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,20 +517,41 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n-        \"\"\"\n-        Deal with a model changing its unique_together. The input\n-        unique_togethers must be doubly-nested, not the single-nested\n-        [\"foo\", \"bar\"] format.\n-        \"\"\"\n-        olds = {tuple(fields) for fields in old_unique_together}\n-        news = {tuple(fields) for fields in new_unique_together}\n-        # Deleted uniques\n-        for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"unique\": True, \"primary_key\": False},\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        constraint_name = constraint_names[0]\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n                 self.sql_delete_unique,\n             )\n         # Created uniques\n@@ -559,6 +580,7 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n@@ -582,7 +604,11 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +617,11 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1666,46 +1697,29 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n-    def _constraint_names(\n-        self,\n-        model,\n-        column_names=None,\n-        unique=None,\n-        primary_key=None,\n-        index=None,\n-        foreign_key=None,\n-        check=None,\n-        type_=None,\n-        exclude=None,\n-    ):\n-        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n-        if column_names is not None:\n-            column_names = [\n-                self.connection.introspection.identifier_converter(name)\n-                for name in column_names\n-            ]\n-        with self.connection.cursor() as cursor:\n-            constraints = self.connection.introspection.get_constraints(\n-                cursor, model._meta.db_table\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n             )\n-        result = []\n-        for name, infodict in constraints.items():\n-            if column_names is None or column_names == infodict[\"columns\"]:\n-                if unique is not None and infodict[\"unique\"] != unique:\n-                    continue\n-                if primary_key is not None and infodict[\"primary_key\"] != primary_key:\n-                    continue\n-                if index is not None and infodict[\"index\"] != index:\n-                    continue\n-                if check is not None and infodict[\"check\"] != check:\n-                    continue\n-                if foreign_key is not None and not infodict[\"foreign_key\"]:\n-                    continue\n-                if type_ is not None and infodict[\"type\"] != type_:\n-                    continue\n-                if not exclude or name not in exclude:\n-                    result.append(name)\n-        return result\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def _delete_primary_key(self, model, strict=False):\n         constraint_names = self._constraint_names(model, primary_key=True)\n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..ba7367c297 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,20 +517,40 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n-        \"\"\"\n-        Deal with a model changing its unique_together. The input\n-        unique_togethers must be doubly-nested, not the single-nested\n-        [\"foo\", \"bar\"] format.\n-        \"\"\"\n-        olds = {tuple(fields) for fields in old_unique_together}\n-        news = {tuple(fields) for fields in new_unique_together}\n-        # Deleted uniques\n-        for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"unique\": True, \"primary_key\": False},\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n                 self.sql_delete_unique,\n             )\n         # Created uniques\n@@ -559,6 +579,7 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n@@ -582,7 +603,11 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +616,11 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1666,46 +1696,29 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n-    def _constraint_names(\n-        self,\n-        model,\n-        column_names=None,\n-        unique=None,\n-        primary_key=None,\n-        index=None,\n-        foreign_key=None,\n-        check=None,\n-        type_=None,\n-        exclude=None,\n-    ):\n-        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n-        if column_names is not None:\n-            column_names = [\n-                self.connection.introspection.identifier_converter(name)\n-                for name in column_names\n-            ]\n-        with self.connection.cursor() as cursor:\n-            constraints = self.connection.introspection.get_constraints(\n-                cursor, model._meta.db_table\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n             )\n-        result = []\n-        for name, infodict in constraints.items():\n-            if column_names is None or column_names == infodict[\"columns\"]:\n-                if unique is not None and infodict[\"unique\"] != unique:\n-                    continue\n-                if primary_key is not None and infodict[\"primary_key\"] != primary_key:\n-                    continue\n-                if index is not None and infodict[\"index\"] != index:\n-                    continue\n-                if check is not None and infodict[\"check\"] != check:\n-                    continue\n-                if foreign_key is not None and not infodict[\"foreign_key\"]:\n-                    continue\n-                if type_ is not None and infodict[\"type\"] != type_:\n-                    continue\n-                if not exclude or name not in exclude:\n-                    result.append(name)\n-        return result\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def _delete_primary_key(self, model, strict=False):\n         constraint_names = self._constraint_names(model, primary_key=True)\n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..c2ddbf9c06 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,20 +517,43 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n-        \"\"\"\n-        Deal with a model changing its unique_together. The input\n-        unique_togethers must be doubly-nested, not the single-nested\n-        [\"foo\", \"bar\"] format.\n-        \"\"\"\n-        olds = {tuple(fields) for fields in old_unique_together}\n-        news = {tuple(fields) for fields in new_unique_together}\n-        # Deleted uniques\n-        for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"unique\": True, \"primary_key\": False},\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(sql % {\n+            \"table\": self.quote_name(model._meta.db_table),\n+            \"name\": self.quote_name(constraint_names[0]),\n+        })\n                 self.sql_delete_unique,\n             )\n         # Created uniques\n@@ -559,6 +582,7 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n@@ -582,7 +606,11 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +619,11 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1666,46 +1699,29 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n-    def _constraint_names(\n-        self,\n-        model,\n-        column_names=None,\n-        unique=None,\n-        primary_key=None,\n-        index=None,\n-        foreign_key=None,\n-        check=None,\n-        type_=None,\n-        exclude=None,\n-    ):\n-        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n-        if column_names is not None:\n-            column_names = [\n-                self.connection.introspection.identifier_converter(name)\n-                for name in column_names\n-            ]\n-        with self.connection.cursor() as cursor:\n-            constraints = self.connection.introspection.get_constraints(\n-                cursor, model._meta.db_table\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n             )\n-        result = []\n-        for name, infodict in constraints.items():\n-            if column_names is None or column_names == infodict[\"columns\"]:\n-                if unique is not None and infodict[\"unique\"] != unique:\n-                    continue\n-                if primary_key is not None and infodict[\"primary_key\"] != primary_key:\n-                    continue\n-                if index is not None and infodict[\"index\"] != index:\n-                    continue\n-                if check is not None and infodict[\"check\"] != check:\n-                    continue\n-                if foreign_key is not None and not infodict[\"foreign_key\"]:\n-                    continue\n-                if type_ is not None and infodict[\"type\"] != type_:\n-                    continue\n-                if not exclude or name not in exclude:\n-                    result.append(name)\n-        return result\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def _delete_primary_key(self, model, strict=False):\n         constraint_names = self._constraint_names(model, primary_key=True)\n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..25852f5273 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,20 +517,40 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n-        \"\"\"\n-        Deal with a model changing its unique_together. The input\n-        unique_togethers must be doubly-nested, not the single-nested\n-        [\"foo\", \"bar\"] format.\n-        \"\"\"\n-        olds = {tuple(fields) for fields in old_unique_together}\n-        news = {tuple(fields) for fields in new_unique_together}\n-        # Deleted uniques\n-        for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"unique\": True, \"primary_key\": False},\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+    elif len(constraint_names) != 1:\n+        raise ValueError(\n+            \"Found wrong number (%s) of constraints for %s(%s)\"\n+            % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            )\n+        )\n+    constraint_name = constraint_names[0]\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n                 self.sql_delete_unique,\n             )\n         # Created uniques\n@@ -559,6 +579,7 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n@@ -582,7 +603,11 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +616,11 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1666,46 +1696,42 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n-    def _constraint_names(\n-        self,\n-        model,\n-        column_names=None,\n-        unique=None,\n-        primary_key=None,\n-        index=None,\n-        foreign_key=None,\n-        check=None,\n-        type_=None,\n-        exclude=None,\n-    ):\n-        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n-        if column_names is not None:\n-            column_names = [\n-                self.connection.introspection.identifier_converter(name)\n-                for name in column_names\n-            ]\n-        with self.connection.cursor() as cursor:\n-            constraints = self.connection.introspection.get_constraints(\n-                cursor, model._meta.db_table\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n             )\n-        result = []\n-        for name, infodict in constraints.items():\n-            if column_names is None or column_names == infodict[\"columns\"]:\n-                if unique is not None and infodict[\"unique\"] != unique:\n-                    continue\n-                if primary_key is not None and infodict[\"primary_key\"] != primary_key:\n-                    continue\n-                if index is not None and infodict[\"index\"] != index:\n-                    continue\n-                if check is not None and infodict[\"check\"] != check:\n-                    continue\n-                if foreign_key is not None and not infodict[\"foreign_key\"]:\n-                    continue\n-                if type_ is not None and infodict[\"type\"] != type_:\n-                    continue\n-                if not exclude or name not in exclude:\n-                    result.append(name)\n-        return result\n+        constraint_name = constraint_names[0]\n+        # Constraint names from the database introspection aren't the same\n+        # format as the ones from get_constraints() which are used by the\n+        # migration writer, so we're aiming for the format that will be\n+        # expected by the migration writer.\n+        if constraint_name in meta_constraint_names:\n+            # Core constraint, let Django format the name\n+            constraint_name = constraint_name\n+        elif constraint_name in meta_index_names:\n+            # Core index, let Django format the name\n+            constraint_name = constraint_name\n+        else:\n+            # Autogenerated name\n+            constraint_name = self.quote_name(constraint_name)\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n \n     def _delete_primary_key(self, model, strict=False):\n         constraint_names = self._constraint_names(model, primary_key=True)\n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..be0250da4b 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,20 +517,46 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n-        \"\"\"\n-        Deal with a model changing its unique_together. The input\n-        unique_togethers must be doubly-nested, not the single-nested\n-        [\"foo\", \"bar\"] format.\n-        \"\"\"\n-        olds = {tuple(fields) for fields in old_unique_together}\n-        news = {tuple(fields) for fields in new_unique_together}\n-        # Deleted uniques\n-        for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"unique\": True, \"primary_key\": False},\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    if len(constraint_names) == 0:\n+        # Constraint may have been already removed by a previous operation\n+        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+        return\n+    elif len(constraint_names) != 1:\n+        raise ValueError(\n+            \"Found wrong number (%s) of constraints for %s(%s)\"\n+            % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            )\n+        )\n+    constraint_name = constraint_names[0]\n+    constraint_sql = sql % {\n+        \"table\": self.quote_name(model._meta.db_table),\n+        \"name\": self.quote_name(constraint_name),\n+    }\n+    self.execute(constraint_sql)\n+        return\n+    elif len(constraint_names) != 1:\n+        raise ValueError(\n+            \"Found wrong number (%s) of constraints for %s(%s)\"\n+            % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            )\n+        )\n+    constraint_name = constraint_names[0]\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n                 self.sql_delete_unique,\n             )\n         # Created uniques\n@@ -559,6 +585,7 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n@@ -582,7 +609,11 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +622,11 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1666,46 +1702,34 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n-    def _constraint_names(\n-        self,\n-        model,\n-        column_names=None,\n-        unique=None,\n-        primary_key=None,\n-        index=None,\n-        foreign_key=None,\n-        check=None,\n-        type_=None,\n-        exclude=None,\n-    ):\n-        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n-        if column_names is not None:\n-            column_names = [\n-                self.connection.introspection.identifier_converter(name)\n-                for name in column_names\n-            ]\n-        with self.connection.cursor() as cursor:\n-            constraints = self.connection.introspection.get_constraints(\n-                cursor, model._meta.db_table\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n             )\n-        result = []\n-        for name, infodict in constraints.items():\n-            if column_names is None or column_names == infodict[\"columns\"]:\n-                if unique is not None and infodict[\"unique\"] != unique:\n-                    continue\n-                if primary_key is not None and infodict[\"primary_key\"] != primary_key:\n-                    continue\n-                if index is not None and infodict[\"index\"] != index:\n-                    continue\n-                if check is not None and infodict[\"check\"] != check:\n-                    continue\n-                if foreign_key is not None and not infodict[\"foreign_key\"]:\n-                    continue\n-                if type_ is not None and infodict[\"type\"] != type_:\n-                    continue\n-                if not exclude or name not in exclude:\n-                    result.append(name)\n-        return result\n+        constraint_name = constraint_names[0]\n+        # Constraint names are unique across indexes and constraints.\n+        is_index = constraint_name not in meta_constraint_names\n+        if is_index:\n+            self.execute(self._delete_index_sql(model, constraint_name))\n+        else:\n+            self.execute(Statement(sql, table=Table(model._meta.db_table, self.quote_name), name=self.quote_name(constraint_name)))\n \n     def _delete_primary_key(self, model, strict=False):\n         constraint_names = self._constraint_names(model, primary_key=True)\n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..203d7bb817 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,20 +517,45 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n-        \"\"\"\n-        Deal with a model changing its unique_together. The input\n-        unique_togethers must be doubly-nested, not the single-nested\n-        [\"foo\", \"bar\"] format.\n-        \"\"\"\n-        olds = {tuple(fields) for fields in old_unique_together}\n-        news = {tuple(fields) for fields in new_unique_together}\n-        # Deleted uniques\n-        for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"unique\": True, \"primary_key\": False},\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    if len(constraint_names) == 0:\n+        # Constraint may have been already removed by a previous operation\n+        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+        return\n+    elif len(constraint_names) != 1:\n+        raise ValueError(\n+            \"Found wrong number (%s) of constraints for %s(%s)\"\n+            % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            )\n+        )\n+    constraint_name = constraint_names[0]\n+    constraint_sql = sql % {\n+        \"table\": self.quote_name(model._meta.db_table),\n+        \"name\": self.quote_name(constraint_name),\n+    }\n+    self.execute(constraint_sql)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n                 self.sql_delete_unique,\n             )\n         # Created uniques\n@@ -559,6 +584,7 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n@@ -582,7 +608,11 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +621,11 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1666,46 +1701,29 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n-    def _constraint_names(\n-        self,\n-        model,\n-        column_names=None,\n-        unique=None,\n-        primary_key=None,\n-        index=None,\n-        foreign_key=None,\n-        check=None,\n-        type_=None,\n-        exclude=None,\n-    ):\n-        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n-        if column_names is not None:\n-            column_names = [\n-                self.connection.introspection.identifier_converter(name)\n-                for name in column_names\n-            ]\n-        with self.connection.cursor() as cursor:\n-            constraints = self.connection.introspection.get_constraints(\n-                cursor, model._meta.db_table\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n             )\n-        result = []\n-        for name, infodict in constraints.items():\n-            if column_names is None or column_names == infodict[\"columns\"]:\n-                if unique is not None and infodict[\"unique\"] != unique:\n-                    continue\n-                if primary_key is not None and infodict[\"primary_key\"] != primary_key:\n-                    continue\n-                if index is not None and infodict[\"index\"] != index:\n-                    continue\n-                if check is not None and infodict[\"check\"] != check:\n-                    continue\n-                if foreign_key is not None and not infodict[\"foreign_key\"]:\n-                    continue\n-                if type_ is not None and infodict[\"type\"] != type_:\n-                    continue\n-                if not exclude or name not in exclude:\n-                    result.append(name)\n-        return result\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def _delete_primary_key(self, model, strict=False):\n         constraint_names = self._constraint_names(model, primary_key=True)\n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..ffae19b5e9 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,20 +517,41 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n-        \"\"\"\n-        Deal with a model changing its unique_together. The input\n-        unique_togethers must be doubly-nested, not the single-nested\n-        [\"foo\", \"bar\"] format.\n-        \"\"\"\n-        olds = {tuple(fields) for fields in old_unique_together}\n-        news = {tuple(fields) for fields in new_unique_together}\n-        # Deleted uniques\n-        for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"unique\": True, \"primary_key\": False},\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    if len(constraint_names) == 0:\n+        # Constraint may have been already removed by a previous operation\n+        # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+        return\n+    elif len(constraint_names) != 1:\n+        raise ValueError(\n+            \"Found wrong number (%s) of constraints for %s(%s)\"\n+            % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            )\n+        )\n+    constraint_name = constraint_names[0]\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n                 self.sql_delete_unique,\n             )\n         # Created uniques\n@@ -559,6 +580,7 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n@@ -582,7 +604,11 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +617,11 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1666,46 +1697,43 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n-    def _constraint_names(\n-        self,\n-        model,\n-        column_names=None,\n-        unique=None,\n-        primary_key=None,\n-        index=None,\n-        foreign_key=None,\n-        check=None,\n-        type_=None,\n-        exclude=None,\n-    ):\n-        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n-        if column_names is not None:\n-            column_names = [\n-                self.connection.introspection.identifier_converter(name)\n-                for name in column_names\n-            ]\n-        with self.connection.cursor() as cursor:\n-            constraints = self.connection.introspection.get_constraints(\n-                cursor, model._meta.db_table\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            # Constraint may have been already removed by a previous operation\n+            # (e.g., field deletion during ForeignKey to ManyToManyField conversion)\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n             )\n-        result = []\n-        for name, infodict in constraints.items():\n-            if column_names is None or column_names == infodict[\"columns\"]:\n-                if unique is not None and infodict[\"unique\"] != unique:\n-                    continue\n-                if primary_key is not None and infodict[\"primary_key\"] != primary_key:\n-                    continue\n-                if index is not None and infodict[\"index\"] != index:\n-                    continue\n-                if check is not None and infodict[\"check\"] != check:\n-                    continue\n-                if foreign_key is not None and not infodict[\"foreign_key\"]:\n-                    continue\n-                if type_ is not None and infodict[\"type\"] != type_:\n-                    continue\n-                if not exclude or name not in exclude:\n-                    result.append(name)\n-        return result\n+        constraint_name = constraint_names[0]\n+        # Constraint names from the database introspection aren't the same\n+        # format as the ones from get_constraints() which is\n+        # {constraint_name: {columns: [col_name, ...], ...}.\n+        # Make sure we have the same format so we can compare them.\n+        constraint_name = self.connection.introspection.identifier_converter(\n+            constraint_name\n+        )\n+        if constraint_name in meta_constraint_names:\n+            # A constraint will be added later.\n+            return\n+\n+        if constraint_name in meta_index_names:\n+            # An index will be added later\n+            return\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n \n     def _delete_primary_key(self, model, strict=False):\n         constraint_names = self._constraint_names(model, primary_key=True)\n"
  }
}