{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 775-790)": "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            # Create a proper nested select_mask for the related model\n            nested_select_mask = {}\n            self._get_only_select_mask(\n                related_model._meta, field_mask, nested_select_mask\n            )\n            # Update the field_select_mask with the nested result\n            field_select_mask.update(nested_select_mask)\n    return select_mask\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 792-812)": "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        # Add the primary key to the mask.\n        if opts.pk.attname not in select_mask:\n            select_mask[opts.pk.attname] = {}\n        # Add each field in the mask.\n        for field_name, field_mask in mask.items():\n            try:\n                field = opts.get_field(field_name)\n            except FieldDoesNotExist:\n                raise FieldError(\n                    \"Cannot resolve keyword %r into field. Choices are: %s\"\n                    % (\n                        field_name,\n                        \", \".join([f.name for f in opts.get_fields()]),\n                    )\n                )\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                # Create a new select_mask for the related model that only includes\n                # the primary key and fields specified in field_mask\n                related_select_mask = {}\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, related_select_mask\n                )\n                # Store the restricted select_mask for this field\n                select_mask[field] = related_select_mask\n        return select_mask\n",
    "Location 3 (/root/hy/projects_1/django/django/db/models/sql/compiler.py lines 950-998)": "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        # Only include fields that are mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = {}\n            if field_mask:\n                if field.is_relation:\n                    if field.many_to_many or (\n                        field.one_to_many\n                        and not field.related_model._meta.concrete_model._meta.proxy_for_model\n                    ):\n                        continue\n                    # For related fields, we need to create a select_mask that includes\n                    # only the fields specified in the field_mask, plus the primary key\n                    related_opts = field.related_model._meta\n                    # Always include the primary key\n                    field_select_mask[related_opts.pk] = {}\n                    # Recursively process the field_mask to include only specified fields\n                    field_select_mask = self._get_only_select_mask(\n                        related_opts, field_mask, field_select_mask\n                    )\n                else:\n                    field_select_mask = self._get_only_select_mask(\n                        opts, field_mask, field_select_mask\n                    )\n            select_mask[field] = field_select_mask\n        return select_mask\n",
    "Location 4 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 2330-2352)": "\ndef _get_only_select_mask(self, field_mask, opts, related_klass_infos=None):\n    \"\"\"\n    Return a dict mapping field names to a further mask to apply.\n    \"\"\"\n    select_mask = {}\n    \n    # If using select_related, we need to include the fields that are\n    # used to join between models.\n    if related_klass_infos:\n        for klass_info in related_klass_infos.values():\n            for f in klass_info[\"model\"]._meta.get_fields():\n                select_mask[f.name] = {}\n    \n    # Add the primary key to the mask if not already present\n    pk_name = opts.pk.name\n    if pk_name not in field_mask:\n        select_mask[pk_name] = {}\n    \n    # Process the field mask\n    for field_name, nested_mask in field_mask.items():\n        if field_name == pk_name or LOOKUP_SEP not in field_name:\n            select_mask[field_name] = nested_mask\n        else:\n            # Handle related field like 'secondary__secondary_field_1'\n            parts = field_name.split(LOOKUP_SEP, 1)\n            related_name = parts[0]\n            remaining_field = parts[1]\n            \n            # Get the related field\n            try:\n                related_field = opts.get_field(related_name)\n            except FieldDoesNotExist:\n                continue\n                \n            if hasattr(related_field, 'related_model'):\n                related_model = related_field.related_model\n                related_opts = related_model._meta\n                \n                # Build the field mask for the related model\n                related_field_mask = {remaining_field: {}}\n                \n                # Recursively get the select mask for the related model\n                related_select_mask = self._get_only_select_mask(\n                    related_field_mask, \n                    related_opts, \n                    None\n                )\n                \n                # Ensure the related field is included in our select_mask\n                if related_name not in select_mask:\n                    select_mask[related_name] = {}\n                \n                # Store the related select mask for use in get_default_columns\n                if not hasattr(self, '_related_select_masks'):\n                    self._related_select_masks = {}\n                self._related_select_masks[related_name] = related_select_mask\n    \n    return select_mask\n",
    "Location 5 (/root/hy/projects_1/django/django/db/models/query_utils.py lines 341-350)": "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    \"\"\"\n    Return the fields that should be loaded based on the deferred loading mask\n    and the select_related mask.\n    \"\"\"\n    if select_mask is None:\n        select_mask = {}\n    \n    # Always include the primary key\n    select_mask[opts.pk] = {}\n    \n    # Process each field in the mask\n    for field_name, field_mask in mask.items():\n        try:\n            field = opts.get_field(field_name)\n        except FieldDoesNotExist:\n            continue\n            \n        # If this is a relation field with nested mask\n        if field.is_relation and field_mask:\n            related_opts = field.related_model._meta\n            # Recursively build select_mask for the related model\n            field_select_mask = self._get_only_select_mask(related_opts, field_mask)\n            select_mask[field] = field_select_mask\n        else:\n            # Regular field or relation without nested mask\n            select_mask[field] = {}\n    \n    return select_mask\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 775-790)": [
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            # Recursively build the select mask for the related model\n            # ensuring only specified fields are included\n            self._get_only_select_mask(\n                related_model._meta, field_mask, field_select_mask\n            )\n        else:\n            # For non-relation fields or relations without nested mask,\n            # add an empty dict to indicate the field should be selected\n            field_select_mask.clear()\n    return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            # Ensure the related model's select_mask includes only PK and specified fields\n            related_select_mask = {related_model._meta.pk: {}}\n            self._get_only_select_mask(\n                related_model._meta, field_mask, related_select_mask\n            )\n            # Update field_select_mask with the properly restricted related fields\n            field_select_mask.update(related_select_mask)\n    return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            # For related fields, create a new select_mask that includes only\n            # the primary key and recurse with the field_mask\n            related_select_mask = {}\n            self._get_only_select_mask(\n                related_model._meta, field_mask, related_select_mask\n            )\n            # Update the field_select_mask with the restricted related fields\n            field_select_mask.update(related_select_mask)\n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                # Ensure the related model's select_mask is properly initialized\n                # to include only the primary key before processing the nested mask\n                related_select_mask = {}\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, related_select_mask\n                )\n                # Update the field_select_mask with the properly constructed related_select_mask\n                field_select_mask.update(related_select_mask)\n        return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            # Create a new select_mask for the related model instead of reusing field_select_mask\n            related_select_mask = {}\n            self._get_only_select_mask(\n                related_model._meta, field_mask, related_select_mask\n            )\n            # Update field_select_mask with the properly constructed related_select_mask\n            field_select_mask.update(related_select_mask)\n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                # Ensure the related model's select_mask only includes specified fields\n                related_select_mask = {}\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, related_select_mask\n                )\n                # Only update field_select_mask with the restricted fields\n                field_select_mask.update(related_select_mask)\n        return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            # Create a new select_mask for the related model instead of passing the empty dict\n            related_select_mask = {}\n            self._get_only_select_mask(\n                related_model._meta, field_mask, related_select_mask\n            )\n            # Update field_select_mask with the properly constructed related_select_mask\n            field_select_mask.update(related_select_mask)\n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                # Initialize the field_select_mask with primary key only for related model\n                field_select_mask.setdefault(related_model._meta.pk, {})\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n        return select_mask\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 792-812)": [
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        # Add all primary key fields to the mask.\n        for pk_field_name in opts.pk.get_attname_column():\n            select_mask[pk_field_name[0]] = {}\n\n        # Add all fields specified in the mask.\n        for field_name, field_mask in mask.items():\n            try:\n                field = opts.get_field(field_name)\n            except FieldDoesNotExist:\n                raise FieldError(\n                    \"Cannot resolve keyword %r into field. Choices are: %s\"\n                    % (\n                        field_name,\n                        \", \".join(\n                            [f.name for f in opts.get_fields() if not f.many_to_many]\n                        ),\n                    )\n                )\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                # Create a new select_mask for the related model that only includes\n                # the fields specified in field_mask\n                related_select_mask = {}\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, related_select_mask\n                )\n                # Store the restricted select_mask for this related field\n                field_select_mask.update(related_select_mask)\n        return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Add the primary key to the mask.\n    pk_name = opts.pk.name\n    select_mask[pk_name] = {}\n\n    # Add each field in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            # Pass a new empty dict for the related model's select_mask\n            # and ensure it gets populated with only the specified fields\n            related_select_mask = {}\n            self._get_only_select_mask(\n                related_model._meta, field_mask, related_select_mask\n            )\n            # Set the field_select_mask to the computed related_select_mask\n            select_mask[field] = related_select_mask\n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        \"\"\"\n        Return the dictionary to be used as the select_mask for a model that\n        should only load the fields named in 'mask'.\n        \"\"\"\n        if select_mask is None:\n            select_mask = {}\n        # Add the primary key to the mask.\n        if opts.pk.attname not in mask:\n            select_mask[opts.pk.attname] = {}\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                # Create a new select_mask for the related model that includes\n                # only the primary key and the fields specified in field_mask\n                related_select_mask = {}\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, related_select_mask\n                )\n                field_select_mask.update(related_select_mask)\n        return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Add the primary key to the mask.\n    if opts.pk.attname not in mask:\n        select_mask[opts.pk.attname] = {}\n    for field_name, field_mask in mask.items():\n        try:\n            field = opts.get_field(field_name)\n        except FieldDoesNotExist:\n            raise FieldError(\"Cannot resolve keyword %r into field\" % field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            # Create a new select_mask for the related model that includes only\n            # the primary key and fields specified in field_mask\n            related_select_mask = {}\n            # Always include the primary key for the related model\n            related_select_mask[related_model._meta.pk.attname] = {}\n            self._get_only_select_mask(\n                related_model._meta, field_mask, related_select_mask\n            )\n            # Store the restricted select_mask for this field\n            select_mask[field] = related_select_mask\n        else:\n            # For leaf fields (no nested mask), just mark them as selected\n            select_mask[field] = {}\n    return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Add the primary key to the mask.\n    if opts.pk.attname not in select_mask:\n        select_mask[opts.pk.attname] = {}\n    # Add each field in the mask.\n    for field_name, field_mask in mask.items():\n        try:\n            field = opts.get_field(field_name)\n        except FieldDoesNotExist:\n            raise FieldError(f\"Cannot resolve keyword '{field_name}' into field.\")\n        field_select_mask = select_mask.setdefault(field.attname, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            # Create a restricted select_mask for the related model\n            related_select_mask = {}\n            self._get_only_select_mask(\n                related_model._meta, field_mask, related_select_mask\n            )\n            # Only set the field_select_mask if there are restrictions\n            if related_select_mask:\n                field_select_mask.update(related_select_mask)\n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        # Add the primary key to the mask if it's not already there.\n        if opts.pk.attname not in select_mask:\n            select_mask[opts.pk.attname] = {}\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                # Create a new select_mask that includes only the pk and specified fields\n                related_select_mask = {}\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, related_select_mask\n                )\n                # Update the field_select_mask with the properly restricted related fields\n                field_select_mask.update(related_select_mask)\n        return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        # Add the primary key to the mask.\n        if opts.pk.attname not in mask:\n            select_mask[opts.pk.attname] = {}\n        # Add concrete fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                # Create a new select_mask for the related model that includes only\n                # the primary key and fields specified in field_mask\n                related_select_mask = {}\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, related_select_mask\n                )\n                # Only assign the constructed related_select_mask to field_select_mask\n                field_select_mask.update(related_select_mask)\n        return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Add the primary key to the mask.\n    if opts.pk.attname not in mask:\n        select_mask[opts.pk.attname] = {}\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            # Create a new select_mask for the related model that includes only\n            # the primary key and the fields specified in field_mask\n            related_select_mask = {}\n            self._get_only_select_mask(\n                related_model._meta, field_mask, related_select_mask\n            )\n            # Only assign the restricted mask to field_select_mask\n            field_select_mask.update(related_select_mask)\n    return select_mask\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/models/sql/compiler.py lines 950-998)": [
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    \"\"\"\n    Return a dict mapping each field in a model to True if it should be\n    selected. If select_mask is not None, then it is an existing dict that\n    should be updated with the fields in mask that are common to both\n    select_mask and mask.\n    \"\"\"\n    only_load = {}\n    select_mask = select_mask or {}\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        is_defer = field.many_to_many or field.one_to_many\n        if not is_defer:\n            only_load[field] = field_mask is not None\n        if field_mask and (is_defer or field.related_model):\n            field_select_mask = {}\n            if field.related_model:\n                # For related models, start with just the primary key\n                pk_field = field.related_model._meta.pk\n                field_select_mask[pk_field] = True\n                # Then add only the fields specified in the mask\n                if field_mask:\n                    related_mask = self._get_only_select_mask(\n                        field.related_model._meta, field_mask, field_select_mask\n                    )\n                    field_select_mask.update(related_mask)\n            select_mask[field.related_model] = field_select_mask\n    return only_load\n",
      "\n    def _get_only_select_mask(self, opts, select_mask, start_alias):\n        \"\"\"\n        Return the select_mask for the given opts and select_mask.\n        \"\"\"\n        # If this is the root call or we have no mask, include all concrete fields\n        if select_mask is None:\n            return {f: {} for f in opts.concrete_fields}\n        \n        result = {}\n        # Always include the primary key\n        if opts.pk:\n            result[opts.pk] = {}\n        \n        for field_name, field_mask in select_mask.items():\n            try:\n                field = opts.get_field(field_name)\n            except FieldDoesNotExist:\n                continue\n                \n            if field.many_to_many:\n                raise FieldError(\n                    \"Invalid field name(s) given in select_related: '%s'. \"\n                    \"Choices are: %s\" % (\n                        field_name,\n                        \", \".join(f.name for f in opts.get_fields() if not f.many_to_many)\n                    )\n                )\n            \n            # Add this field to the result\n            result[field] = {}\n            \n            # If this field has a related model and there are nested selections\n            if hasattr(field, 'remote_field') and field.remote_field and field_mask:\n                related_model = field.remote_field.model\n                related_opts = related_model._meta\n                \n                # Build the select mask for the related model\n                # Include only the primary key and the fields specified in field_mask\n                field_select_mask = {}\n                \n                # Always include the primary key of the related model\n                if related_opts.pk:\n                    field_select_mask[related_opts.pk] = {}\n                \n                # Add only the fields that are specified in the nested mask\n                for nested_field_name, nested_mask in field_mask.items():\n                    try:\n                        nested_field = related_opts.get_field(nested_field_name)\n                        field_select_mask[nested_field] = nested_mask\n                    except FieldDoesNotExist:\n                        continue\n                \n                # Store the computed select mask for this related field\n                alias = self.query.join_parent_model(opts, field.model, start_alias, {})\n                if alias not in self.query._filtered_relations:\n                    self.query._filtered_relations[alias] = field_select_mask\n                    \n        return result\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        # Only load the specified fields (but always load pk).\n        field_mask = mask.get(opts.model)\n        if field_mask is None:\n            return select_mask\n        for field_name in field_mask:\n            field = opts.get_field(field_name)\n            if not field.concrete:\n                continue\n            select_mask[field] = field_mask[field_name]\n        # Always load the pk field.\n        pk = opts.pk\n        select_mask[pk] = {}\n\n        # Also always load parents for inheritance cases.\n        for parent in opts.get_parent_list():\n            select_mask.update(\n                self._get_only_select_mask(parent, mask, select_mask.copy())\n            )\n        \n        # Process related fields recursively\n        for field_name, field_mask in mask.get(opts.model, {}).items():\n            if field_mask:  # If there are nested fields to select\n                field = opts.get_field(field_name)\n                if hasattr(field, 'related_model'):\n                    related_opts = field.related_model._meta\n                    # Create a nested mask for the related model containing only the specified fields\n                    related_mask = {related_opts.model: field_mask}\n                    # Recursively get the select mask for the related model\n                    self._get_only_select_mask(related_opts, related_mask, select_mask)\n        \n        return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Only include fields that are mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.remote_field:\n                raise FieldError(\n                    \"Non-relational field given in select_related: '%s'. \"\n                    \"Choices are: %s\"\n                    % (\n                        field_name,\n                        \", \".join(\n                            f.name\n                            for f in opts.get_fields()\n                            if f.remote_field\n                        ),\n                    )\n                )\n            related_opts = field.remote_field.model._meta\n            # Create a restricted select_mask for the related model that includes\n            # only the fields specified in field_mask, plus the primary key\n            related_select_mask = {related_opts.pk: {}}\n            self._get_only_select_mask(related_opts, field_mask, related_select_mask)\n            # Store the restricted select_mask to be used by get_default_columns\n            field_select_mask.update(related_select_mask)\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        # Only include fields that are specified in the mask or are needed\n        # for the query (like pk fields).\n        pk = opts.pk\n        # Always include the primary key\n        select_mask[pk] = {}\n        \n        if not mask:\n            return select_mask\n            \n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            select_mask[field] = {}\n            if field_mask and hasattr(field, 'related_model'):\n                related_model = field.related_model\n                if related_model:\n                    # Create a proper select_mask for the related model that includes\n                    # only the primary key and the fields specified in field_mask\n                    related_opts = related_model._meta\n                    related_select_mask = {}\n                    # Always include the related model's primary key\n                    related_select_mask[related_opts.pk] = {}\n                    # Add only the fields specified in the field_mask\n                    for related_field_name in field_mask:\n                        try:\n                            related_field = related_opts.get_field(related_field_name)\n                            related_select_mask[related_field] = {}\n                        except FieldDoesNotExist:\n                            pass\n                    select_mask[field] = related_select_mask\n        return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Only add fields that are explicitly requested.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                # If the field mask is not empty then the field is looking\n                # for something and we have to be more careful.\n                field_select_mask.clear()\n            else:\n                field_select_mask = self._get_only_select_mask(\n                    field.related_model._meta, field_mask, field_select_mask\n                )\n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            if not field.is_relation:\n                select_mask[field] = field_mask\n            else:\n                next_mask = self._get_only_select_mask(\n                    field.related_model._meta, field_mask, {}\n                )\n                if next_mask:\n                    # Only add the related field if there are fields to select from it\n                    select_mask[field] = next_mask\n        return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        # Only include fields present in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    # Non-relational fields can't have nested masks.\n                    raise FieldError(\n                        \"Non-relational field %r cannot be used in select_related().\"\n                        % field_name\n                    )\n                related_model = field.remote_field.model._meta.concrete_model._meta\n                # For related fields, ensure we include the primary key and recursively\n                # process the nested mask to restrict field selection\n                related_select_mask = {}\n                # Always include the primary key for related models\n                pk_field = related_model.pk\n                related_select_mask[pk_field] = {}\n                # Recursively process the nested mask to include only specified fields\n                self._get_only_select_mask(related_model, field_mask, related_select_mask)\n                field_select_mask.update(related_select_mask)\n        return select_mask\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 2330-2352)": [
      "\ndef _get_only_select_mask(self, field_mask, related_model, opts):\n    \"\"\"\n    Return a dict of field names mapped to nested select masks for related\n    fields.\n    \"\"\"\n    select_mask = {}\n    field_select_mask = {}\n    \n    for field in opts.concrete_fields:\n        field_mask_key = field.name\n        if field_mask_key in field_mask:\n            if field.is_relation:\n                # For related fields, recursively build the select mask\n                nested_field_mask = field_mask[field_mask_key]\n                if nested_field_mask:\n                    # Get the related model's opts\n                    related_opts = field.related_model._meta\n                    # Recursively build the select mask for the related model\n                    nested_select_mask = self._get_only_select_mask(\n                        nested_field_mask, field.related_model, related_opts\n                    )\n                    select_mask[field_mask_key] = nested_select_mask\n                else:\n                    # Empty nested mask means include only the relation field itself\n                    select_mask[field_mask_key] = {}\n            else:\n                # Non-relation field, include it in the select mask\n                select_mask[field_mask_key] = {}\n        elif field.primary_key:\n            # Always include primary key\n            select_mask[field_mask_key] = {}\n    \n    # Handle reverse relations\n    for field in opts.related_objects:\n        field_mask_key = field.get_accessor_name()\n        if field_mask_key in field_mask:\n            nested_field_mask = field_mask[field_mask_key]\n            if nested_field_mask:\n                # Get the related model's opts\n                related_opts = field.related_model._meta\n                # Recursively build the select mask for the related model\n                nested_select_mask = self._get_only_select_mask(\n                    nested_field_mask, field.related_model, related_opts\n                )\n                # For reverse relations, we need to ensure the related model\n                # includes only the specified fields plus its primary key\n                field_select_mask[field_mask_key] = nested_select_mask\n    \n    # Combine both forward and reverse relation masks\n    select_mask.update(field_select_mask)\n    \n    return select_mask\n",
      "\ndef _get_only_select_mask(self, field_mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Traverse the field_mask and populate select_mask for each related model\n    for field_name, field_mask_item in field_mask.items():\n        try:\n            field = self.get_meta().get_field(field_name)\n        except FieldDoesNotExist:\n            continue\n        \n        if field.is_relation:\n            # For related fields, we need to recursively build the select_mask\n            related_model = field.related_model\n            if related_model:\n                # Create a field_select_mask that includes only the pk and specified fields\n                field_select_mask = {}\n                # Always include the primary key\n                pk_name = related_model._meta.pk.name\n                field_select_mask[pk_name] = {}\n                # Recursively add the fields from field_mask_item\n                if field_mask_item:\n                    field_select_mask.update(field_mask_item)\n                \n                # Store the field_select_mask for this related field\n                select_mask[field_name] = self._get_only_select_mask(field_mask_item, field_select_mask)\n        else:\n            # For non-related fields, just add them to the select_mask\n            select_mask[field_name] = {}\n    \n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, select_mask, select_related_descend=True):\n        \"\"\"\n        Return the fields that should be loaded by get_default_columns().\n        \"\"\"\n        field_select_mask = {}\n        for field_name, field_mask in select_mask.items():\n            field = opts.get_field(field_name)\n            if not select_related_descend:\n                continue\n            # Retrieve the field's model to pass to the recursive call.\n            field_model = field.remote_field.model\n            field_opts = field_model._meta\n            # Recursively call _get_only_select_mask() to handle nested only() fields.\n            if field_mask:\n                # If there are specific fields requested for this relation,\n                # pass them to the recursive call\n                nested_mask = self._get_only_select_mask(field_opts, field_mask, select_related_descend)\n            else:\n                # If no specific fields are requested, include all fields\n                nested_mask = None\n            field_select_mask[field_name] = nested_mask\n        return field_select_mask\n",
      "\ndef _get_only_select_mask(self, field_mask, opts=None):\n    \"\"\"\n    Get the select_mask for the given field_mask and options.\n    \"\"\"\n    if opts is None:\n        opts = self.get_meta()\n    \n    select_mask = {}\n    \n    # Always include the primary key\n    select_mask[opts.pk.name] = {}\n    \n    for field_name, submask in field_mask.items():\n        try:\n            field = opts.get_field(field_name)\n        except FieldDoesNotExist:\n            continue\n            \n        select_mask[field_name] = {}\n        \n        if field.is_relation and submask:\n            # For related fields, recursively get the select mask\n            related_opts = field.related_model._meta\n            field_select_mask = self._get_only_select_mask(submask, related_opts)\n            select_mask[field_name] = field_select_mask\n    \n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None, filtered_relation=None):\n        \"\"\"\n        Return the dictionary of field names to be selected based on the\n        'only' fields specified in the query and any filtered relation.\n        \"\"\"\n        if select_mask is None:\n            select_mask = {}\n        select_mask = select_mask.copy()\n        \n        # Always include the primary key\n        if opts.pk.name not in select_mask:\n            select_mask[opts.pk.name] = {}\n            \n        for field_name, field_mask in mask.items():\n            field_select_mask = {}\n            try:\n                field = opts.get_field(field_name)\n            except FieldDoesNotExist:\n                # Annotation.\n                select_mask[field_name] = field_select_mask\n                continue\n            else:\n                if filtered_relation:\n                    field_select_mask = self._get_only_select_mask(\n                        field.related_model._meta, field_mask, field_select_mask,\n                        filtered_relation,\n                    )\n                elif field.is_relation:\n                    related_model = field.related_model\n                    related_opts = related_model._meta\n                    # For related fields, create a proper select_mask that includes only\n                    # the primary key and fields specified in field_mask\n                    related_select_mask = {}\n                    # Always include the primary key of the related model\n                    related_select_mask[related_opts.pk.name] = {}\n                    # Add only the fields specified in the mask\n                    for nested_field_name in field_mask:\n                        related_select_mask[nested_field_name] = field_mask[nested_field_name]\n                    field_select_mask = self._get_only_select_mask(\n                        related_opts, field_mask, related_select_mask\n                    )\n            select_mask[field_name] = field_select_mask\n        return select_mask\n",
      "\ndef _get_only_select_mask(self, field_mask, related_klass_infos):\n    \"\"\"\n    Return a select_mask for related models based on the field_mask.\n    The field_mask is a dict mapping field names to None or a nested\n    field_mask for the related model.\n    \"\"\"\n    select_mask = {}\n    for field_name, nested_mask in field_mask.items():\n        try:\n            field = self.get_meta().get_field(field_name)\n        except FieldDoesNotExist:\n            continue\n        if field.is_relation and field.related_model:\n            related_model = field.related_model\n            if related_model in related_klass_infos:\n                related_select_mask = {}\n                # Always include the primary key\n                pk_name = related_model._meta.pk.name\n                related_select_mask[pk_name] = {}\n                \n                # If there's a nested mask, only include those fields\n                if nested_mask:\n                    related_query = related_model._default_manager.get_queryset().query\n                    related_select_mask.update(related_query._get_only_select_mask(nested_mask, related_klass_infos))\n                \n                select_mask[field_name] = related_select_mask\n        else:\n            select_mask[field_name] = {}\n    return select_mask\n",
      "\ndef _get_only_select_mask(self, field_mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Determine which fields to include in the query.\n    for field_name, field_mask in field_mask.items():\n        field = self.get_meta().get_field(field_name)\n        if not field.is_relation:\n            select_mask[field] = field_mask\n        else:\n            # For related fields, create a select_mask that includes only the\n            # primary key and the fields specified in field_mask\n            related_model = field.related_model\n            if field_mask:\n                # Build select_mask for related model with only specified fields\n                related_select_mask = {}\n                # Always include the primary key\n                pk_field = related_model._meta.pk\n                related_select_mask[pk_field] = {}\n                # Add fields specified in the mask\n                for related_field_name in field_mask:\n                    related_field = related_model._meta.get_field(related_field_name)\n                    related_select_mask[related_field] = field_mask[related_field_name]\n                select_mask[field] = self._get_only_select_mask(\n                    field_mask, related_select_mask\n                )\n            else:\n                # If no specific fields are requested for the relation,\n                # include only the primary key\n                pk_field = related_model._meta.pk\n                select_mask[field] = {pk_field: {}}\n    return select_mask\n",
      "\ndef _get_only_select_mask(self, field_mask, related_klass_infos):\n    \"\"\"\n    Apply a mask of only() field names to the columns in the select clause.\n\n    This is used to implement QuerySet.only(). Return a select_mask that\n    will be used to prune the columns in the SELECT clause.\n\n    The field_mask is a dictionary that maps field names to nested\n    dictionaries that recursively define the field names for related\n    models that should be selected.\n\n    The related_klass_infos is a list of related model infos that are\n    being selected via select_related().\n    \"\"\"\n    select_mask = {}\n    for field_name, field_select_mask in field_mask.items():\n        klass_info = related_klass_infos.get(field_name)\n        if klass_info:\n            # This field is a related field that we're selecting.\n            # We need to recurse into the related field's select mask.\n            if field_select_mask:\n                # Only include the fields specified in the mask for the related model\n                related_select_mask = self._get_only_select_mask(\n                    field_select_mask, klass_info.related_klass_infos\n                )\n                # Add the primary key to ensure the join works correctly\n                pk_name = klass_info.model._meta.pk.name\n                related_select_mask[pk_name] = {}\n                select_mask[field_name] = related_select_mask\n            else:\n                # No specific fields requested for this relation, include only pk\n                pk_name = klass_info.model._meta.pk.name\n                select_mask[field_name] = {pk_name: {}}\n        else:\n            # This is a regular field on the current model\n            select_mask[field_name] = {}\n    return select_mask\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/models/query_utils.py lines 341-350)": [
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Only load the specified fields (white-list)\n    field_mask = mask.get(opts.model)\n    if field_mask is None:\n        return select_mask\n\n    field_dict = {f.name: f for f in opts.concrete_fields}\n    for field_name, field_mask in field_mask.items():\n        field = field_dict.get(field_name)\n        if not field:\n            raise FieldError(\"Cannot resolve keyword %r into field. \"\n                            \"Choices are: %s\" % (field_name,\n                                                [f.name for f in opts.fields]))\n        select_mask[field] = field_mask\n        # Recursively handle related fields\n        if field_mask and hasattr(field, 'remote_field') and field.remote_field:\n            related_model = field.remote_field.model\n            related_opts = related_model._meta\n            # Create a select_mask for the related model that includes only\n            # the primary key and the fields specified in field_mask\n            field_select_mask = {related_opts.pk: {}}\n            # Recursively process the related fields\n            field_select_mask = self._get_only_select_mask(\n                related_opts, {related_model: field_mask}, field_select_mask\n            )\n            select_mask[field] = field_select_mask\n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only add concrete fields that are in the mask\n        for field_name, submask in mask.items():\n            try:\n                field = opts.get_field(field_name)\n            except FieldDoesNotExist:\n                continue\n            if not field.concrete:\n                continue\n            select_mask[field] = {}\n            if submask and field.is_relation:\n                if field.related_model is None:\n                    continue\n                # Create a restricted select_mask for the related model\n                field_select_mask = {}\n                field_select_mask[field.related_model._meta.pk] = {}\n                # Recursively process the submask for the related model\n                self._get_only_select_mask(field.related_model._meta, submask, field_select_mask)\n                self.related_select_mask.setdefault(field.related_model, field_select_mask)\n        return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Only load the specified fields (mask) and their parents.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, field_mask)\n        if field_mask and field.is_relation:\n            if field.many_to_many:\n                continue\n            related_model = field.related_model\n            related_select_mask = self._get_only_select_mask(\n                related_model._meta, field_mask, {}\n            )\n            # Only include the primary key and fields specified in the mask\n            if related_select_mask:\n                # Add primary key field to ensure relation can be established\n                pk_field = related_model._meta.pk\n                related_select_mask[pk_field] = {}\n            field_select_mask.update(related_select_mask)\n    return select_mask\n",
      "\ndef _get_only_select_mask(self, requested, select_mask=None, restricted=True):\n    \"\"\"\n    Return the select_mask that should be used for this query based on the\n    requested fields (from an only() call) and any existing select_mask.\n    \"\"\"\n    if select_mask is None:\n        select_mask = {}\n    \n    for field_name in requested:\n        if LOOKUP_SEP in field_name:\n            # Handle related field lookups\n            parts = field_name.split(LOOKUP_SEP, 1)\n            field_name, remaining = parts\n            field = self.model._meta.get_field(field_name)\n            \n            # Get or create the nested select_mask for this field\n            if field_name not in select_mask:\n                select_mask[field_name] = {}\n            \n            # Recursively process the remaining field path\n            related_model = field.remote_field.model if hasattr(field, 'remote_field') else field.related_model\n            related_query = Query(related_model)\n            \n            # Build the select_mask for the related model with only the requested fields\n            field_select_mask = related_query._get_only_select_mask([remaining], select_mask[field_name], restricted)\n            \n            # Ensure the primary key is always included in the related model's select_mask\n            pk_field = related_model._meta.pk\n            if pk_field.name not in field_select_mask:\n                field_select_mask[pk_field.name] = {}\n            \n            select_mask[field_name] = field_select_mask\n        else:\n            # Direct field on this model\n            select_mask[field_name] = {}\n    \n    return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Only load the specified fields (mask), and only from the specified\n    # tables (select_mask). If select_mask isn't specified, don't use one.\n    if not mask:\n        return {}\n\n    # Build a select_mask if we don't have one.\n    if not select_mask:\n        select_mask = self.get_select_mask()\n\n    # Start with an empty mask and only add the fields we're loading.\n    field_select_mask = {}\n    for field_name, field_mask in mask.items():\n        try:\n            field = opts.get_field(field_name)\n        except FieldDoesNotExist:\n            # Ignore non-existent fields.\n            continue\n        field_select_mask[field] = field_mask\n        if field_mask and field.is_relation:\n            if field.many_to_many:\n                continue\n            related_model = field.related_model\n            if related_model is None:\n                continue\n            if field.reverse:\n                related_opts = related_model._meta\n                related_mask = self._get_only_select_mask(\n                    related_opts, field_mask, select_mask.get(field, {})\n                )\n            else:\n                related_opts = related_model._meta\n                # For forward relations, create a proper select_mask that includes\n                # only the primary key and the fields specified in field_mask\n                related_select_mask = {related_opts.pk: {}}\n                for related_field_name in field_mask:\n                    try:\n                        related_field = related_opts.get_field(related_field_name)\n                        related_select_mask[related_field] = field_mask[related_field_name]\n                    except FieldDoesNotExist:\n                        continue\n                related_mask = self._get_only_select_mask(\n                    related_opts, field_mask, related_select_mask\n                )\n    return field_select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    # Only load the specified fields (mask) and their parents.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        if field.is_relation:\n            if field.many_to_many:\n                continue\n            if field.remote_field.parent_link:\n                continue\n            related_model = field.remote_field.model\n            related_opts = related_model._meta\n            \n            # Create a proper field_select_mask for the related model\n            field_select_mask = {}\n            # Always include the primary key\n            pk_field = related_opts.pk\n            field_select_mask[pk_field] = {}\n            \n            # If there are nested fields specified, include only those\n            if field_mask:\n                field_select_mask.update(\n                    self._get_only_select_mask(related_opts, field_mask)\n                )\n            \n            select_mask[field] = field_select_mask\n        else:\n            select_mask[field] = {}\n    return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, select_mask, restricted=True):\n    \"\"\"\n    Return the dictionary of select_mask for the query, or None if a full\n    query should be done.\n    \"\"\"\n    field_select_mask = {}\n    for field_name, field_mask in select_mask.items():\n        field = opts.get_field(field_name)\n        if field.is_relation:\n            if field_mask is None:\n                # If field_mask is None, we should select all fields of the related model\n                field_select_mask[field] = None\n            else:\n                # Recursively process the related model with the nested field_mask\n                related_select_mask = self._get_only_select_mask(\n                    field.related_model._meta, field_mask, restricted\n                )\n                if related_select_mask is not None:\n                    field_select_mask[field] = related_select_mask\n        else:\n            # For non-relation fields, include them in the mask\n            field_select_mask[field] = field_mask\n\n    return field_select_mask or None\n",
      "\n    def _get_only_select_mask(self, field_mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        # Determine which fields should be loaded based on the query.\n        if field_mask:\n            for field in self.model._meta.concrete_fields:\n                field_mask_key = field.name\n                try:\n                    field_mask[field_mask_key]\n                except KeyError:\n                    select_mask.setdefault(field, False)\n                else:\n                    select_mask.setdefault(field, True)\n        for field, related_model in self.model._meta.concrete_fields:\n            if not field.remote_field:\n                continue\n            field_mask_key = field.name\n            try:\n                field_mask[field_mask_key]\n            except KeyError:\n                continue\n            related_model = field.remote_field.model\n            field_select_mask = {}\n            # Fix: Properly construct the select_mask for the related model\n            # by passing the nested field_mask and ensuring it restricts field selection\n            related_field_mask = field_mask[field_mask_key]\n            related_query = related_model._default_manager.get_queryset()\n            related_query = related_query._get_only_select_mask(related_field_mask, field_select_mask)\n            select_mask[field] = field_select_mask\n        return select_mask\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 78148f76b0..46a3d99b21 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -338,6 +338,7 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n             return False\n     if not restricted and field.null:\n         return False\n+\n     if (\n         restricted\n         and select_mask\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..1a43ed5aa8 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -947,6 +947,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(\n         self, select_mask, start_alias=None, opts=None, from_parent=None\n     ):\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..7f1d88b502 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -789,6 +790,7 @@ class Query(BaseExpression):\n                 )\n         return select_mask\n \n+\n     def get_select_mask(self):\n         \"\"\"\n         Convert the self.deferred_loading data structure to an alternate data\n@@ -2327,6 +2329,7 @@ class Query(BaseExpression):\n                 if new_only := set(field_names).difference(existing):\n                     self.deferred_loading = new_only, True\n \n+\n     def add_immediate_loading(self, field_names):\n         \"\"\"\n         Add the given list of model field names to the set of fields to\n",
    "variant_0": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 78148f76b0..195b4672a6 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -338,16 +338,36 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n             return False\n     if not restricted and field.null:\n         return False\n-    if (\n-        restricted\n-        and select_mask\n-        and field.name in requested\n-        and field not in select_mask\n-    ):\n-        raise FieldError(\n-            f\"Field {field.model._meta.object_name}.{field.name} cannot be both \"\n-            \"deferred and traversed using select_related at the same time.\"\n-        )\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    \"\"\"\n+    Return the fields that should be loaded based on the deferred loading mask\n+    and the select_related mask.\n+    \"\"\"\n+    if select_mask is None:\n+        select_mask = {}\n+    \n+    # Always include the primary key\n+    select_mask[opts.pk] = {}\n+    \n+    # Process each field in the mask\n+    for field_name, field_mask in mask.items():\n+        try:\n+            field = opts.get_field(field_name)\n+        except FieldDoesNotExist:\n+            continue\n+            \n+        # If this is a relation field with nested mask\n+        if field.is_relation and field_mask:\n+            related_opts = field.related_model._meta\n+            # Recursively build select_mask for the related model\n+            field_select_mask = self._get_only_select_mask(related_opts, field_mask)\n+            select_mask[field] = field_select_mask\n+        else:\n+            # Regular field or relation without nested mask\n+            select_mask[field] = {}\n+    \n+    return select_mask\n     return True\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..2c0ccf01f4 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -947,55 +947,36 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n-    def get_default_columns(\n-        self, select_mask, start_alias=None, opts=None, from_parent=None\n-    ):\n-        \"\"\"\n-        Compute the default columns for selecting every field in the base\n-        model. Will sometimes be called to pull in related models (e.g. via\n-        select_related), in which case \"opts\" and \"start_alias\" will be given\n-        to provide a starting point for the traversal.\n-\n-        Return a list of strings, quoted appropriately for use in SQL\n-        directly, as well as a set of aliases used in the select statement (if\n-        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n-        of strings as the first component and None as the second component).\n-        \"\"\"\n-        result = []\n-        if opts is None:\n-            if (opts := self.query.get_meta()) is None:\n-                return result\n-        start_alias = start_alias or self.query.get_initial_alias()\n-        # The 'seen_models' is used to optimize checking the needed parent\n-        # alias for a given field. This also includes None -> start_alias to\n-        # be used by local fields.\n-        seen_models = {None: start_alias}\n-\n-        for field in opts.concrete_fields:\n-            model = field.model._meta.concrete_model\n-            # A proxy model will have a different model and concrete_model. We\n-            # will assign None if the field belongs to this model.\n-            if model == opts.model:\n-                model = None\n-            if (\n-                from_parent\n-                and model is not None\n-                and issubclass(\n-                    from_parent._meta.concrete_model, model._meta.concrete_model\n-                )\n-            ):\n-                # Avoid loading data for already loaded parents.\n-                # We end up here in the case select_related() resolution\n-                # proceeds from parent model to child model. In that case the\n-                # parent model data is already present in the SELECT clause,\n-                # and we want to avoid reloading the same data again.\n-                continue\n-            if select_mask and field not in select_mask:\n-                continue\n-            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n-            column = field.get_col(alias)\n-            result.append(column)\n-        return result\n+\n+    def _get_only_select_mask(self, opts, mask, select_mask=None):\n+        if select_mask is None:\n+            select_mask = {}\n+        # Only include fields that are mentioned in the mask.\n+        for field_name, field_mask in mask.items():\n+            field = opts.get_field(field_name)\n+            field_select_mask = {}\n+            if field_mask:\n+                if field.is_relation:\n+                    if field.many_to_many or (\n+                        field.one_to_many\n+                        and not field.related_model._meta.concrete_model._meta.proxy_for_model\n+                    ):\n+                        continue\n+                    # For related fields, we need to create a select_mask that includes\n+                    # only the fields specified in the field_mask, plus the primary key\n+                    related_opts = field.related_model._meta\n+                    # Always include the primary key\n+                    field_select_mask[related_opts.pk] = {}\n+                    # Recursively process the field_mask to include only specified fields\n+                    field_select_mask = self._get_only_select_mask(\n+                        related_opts, field_mask, field_select_mask\n+                    )\n+                else:\n+                    field_select_mask = self._get_only_select_mask(\n+                        opts, field_mask, field_select_mask\n+                    )\n+            select_mask[field] = field_select_mask\n+        return select_mask\n \n     def get_distinct(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..e6aca3cac3 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,45 +772,62 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            # Create a proper nested select_mask for the related model\n+            nested_select_mask = {}\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, nested_select_mask\n+            )\n+            # Update the field_select_mask with the nested result\n+            field_select_mask.update(nested_select_mask)\n+    return select_mask\n+\n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n+        # Add the primary key to the mask.\n+        if opts.pk.attname not in select_mask:\n+            select_mask[opts.pk.attname] = {}\n+        # Add each field in the mask.\n         for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n+            try:\n+                field = opts.get_field(field_name)\n+            except FieldDoesNotExist:\n+                raise FieldError(\n+                    \"Cannot resolve keyword %r into field. Choices are: %s\"\n+                    % (\n+                        field_name,\n+                        \", \".join([f.name for f in opts.get_fields()]),\n+                    )\n+                )\n             field_select_mask = select_mask.setdefault(field, {})\n             if field_mask:\n                 if not field.is_relation:\n                     raise FieldError(next(iter(field_mask)))\n                 related_model = field.remote_field.model._meta.concrete_model\n+                # Create a new select_mask for the related model that only includes\n+                # the primary key and fields specified in field_mask\n+                related_select_mask = {}\n                 self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n+                    related_model._meta, field_mask, related_select_mask\n                 )\n+                # Store the restricted select_mask for this field\n+                select_mask[field] = related_select_mask\n         return select_mask\n \n-    def get_select_mask(self):\n-        \"\"\"\n-        Convert the self.deferred_loading data structure to an alternate data\n-        structure, describing the field that *will* be loaded. This is used to\n-        compute the columns to select from the database and also by the\n-        QuerySet class to work out which fields are being initialized on each\n-        model. Models that have all their fields included aren't mentioned in\n-        the result, only those that have field restrictions in place.\n-        \"\"\"\n-        field_names, defer = self.deferred_loading\n-        if not field_names:\n-            return {}\n-        mask = {}\n-        for field_name in field_names:\n-            part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n-                part_mask = part_mask.setdefault(part, {})\n-        opts = self.get_meta()\n-        if defer:\n-            return self._get_defer_select_mask(opts, mask)\n-        return self._get_only_select_mask(opts, mask)\n-\n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n         Return a table alias for the given table_name and whether this is a\n@@ -2327,29 +2344,65 @@ class Query(BaseExpression):\n                 if new_only := set(field_names).difference(existing):\n                     self.deferred_loading = new_only, True\n \n-    def add_immediate_loading(self, field_names):\n-        \"\"\"\n-        Add the given list of model field names to the set of fields to\n-        retrieve when the SQL is executed (\"immediate loading\" fields). The\n-        field names replace any existing immediate loading field names. If\n-        there are field names already specified for deferred loading, remove\n-        those names from the new field_names before storing the new names\n-        for immediate loading. (That is, immediate loading overrides any\n-        existing immediate values, but respects existing deferrals.)\n-        \"\"\"\n-        existing, defer = self.deferred_loading\n-        field_names = set(field_names)\n-        if \"pk\" in field_names:\n-            field_names.remove(\"pk\")\n-            field_names.add(self.get_meta().pk.name)\n \n-        if defer:\n-            # Remove any existing deferred names from the current set before\n-            # setting the new names.\n-            self.deferred_loading = field_names.difference(existing), False\n+def _get_only_select_mask(self, field_mask, opts, related_klass_infos=None):\n+    \"\"\"\n+    Return a dict mapping field names to a further mask to apply.\n+    \"\"\"\n+    select_mask = {}\n+    \n+    # If using select_related, we need to include the fields that are\n+    # used to join between models.\n+    if related_klass_infos:\n+        for klass_info in related_klass_infos.values():\n+            for f in klass_info[\"model\"]._meta.get_fields():\n+                select_mask[f.name] = {}\n+    \n+    # Add the primary key to the mask if not already present\n+    pk_name = opts.pk.name\n+    if pk_name not in field_mask:\n+        select_mask[pk_name] = {}\n+    \n+    # Process the field mask\n+    for field_name, nested_mask in field_mask.items():\n+        if field_name == pk_name or LOOKUP_SEP not in field_name:\n+            select_mask[field_name] = nested_mask\n         else:\n-            # Replace any existing \"immediate load\" field names.\n-            self.deferred_loading = frozenset(field_names), False\n+            # Handle related field like 'secondary__secondary_field_1'\n+            parts = field_name.split(LOOKUP_SEP, 1)\n+            related_name = parts[0]\n+            remaining_field = parts[1]\n+            \n+            # Get the related field\n+            try:\n+                related_field = opts.get_field(related_name)\n+            except FieldDoesNotExist:\n+                continue\n+                \n+            if hasattr(related_field, 'related_model'):\n+                related_model = related_field.related_model\n+                related_opts = related_model._meta\n+                \n+                # Build the field mask for the related model\n+                related_field_mask = {remaining_field: {}}\n+                \n+                # Recursively get the select mask for the related model\n+                related_select_mask = self._get_only_select_mask(\n+                    related_field_mask, \n+                    related_opts, \n+                    None\n+                )\n+                \n+                # Ensure the related field is included in our select_mask\n+                if related_name not in select_mask:\n+                    select_mask[related_name] = {}\n+                \n+                # Store the related select mask for use in get_default_columns\n+                if not hasattr(self, '_related_select_masks'):\n+                    self._related_select_masks = {}\n+                self._related_select_masks[related_name] = related_select_mask\n+    \n+    return select_mask\n \n     def set_annotation_mask(self, names):\n         \"\"\"Set the mask of annotations that will be returned by the SELECT.\"\"\"\n",
    "variant_1": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 78148f76b0..23b3c1e5ef 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -338,16 +338,36 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n             return False\n     if not restricted and field.null:\n         return False\n-    if (\n-        restricted\n-        and select_mask\n-        and field.name in requested\n-        and field not in select_mask\n-    ):\n-        raise FieldError(\n-            f\"Field {field.model._meta.object_name}.{field.name} cannot be both \"\n-            \"deferred and traversed using select_related at the same time.\"\n-        )\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Only load the specified fields (white-list)\n+    field_mask = mask.get(opts.model)\n+    if field_mask is None:\n+        return select_mask\n+\n+    field_dict = {f.name: f for f in opts.concrete_fields}\n+    for field_name, field_mask in field_mask.items():\n+        field = field_dict.get(field_name)\n+        if not field:\n+            raise FieldError(\"Cannot resolve keyword %r into field. \"\n+                            \"Choices are: %s\" % (field_name,\n+                                                [f.name for f in opts.fields]))\n+        select_mask[field] = field_mask\n+        # Recursively handle related fields\n+        if field_mask and hasattr(field, 'remote_field') and field.remote_field:\n+            related_model = field.remote_field.model\n+            related_opts = related_model._meta\n+            # Create a select_mask for the related model that includes only\n+            # the primary key and the fields specified in field_mask\n+            field_select_mask = {related_opts.pk: {}}\n+            # Recursively process the related fields\n+            field_select_mask = self._get_only_select_mask(\n+                related_opts, {related_model: field_mask}, field_select_mask\n+            )\n+            select_mask[field] = field_select_mask\n+    return select_mask\n     return True\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..0ebca16bf9 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -947,55 +947,35 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n-    def get_default_columns(\n-        self, select_mask, start_alias=None, opts=None, from_parent=None\n-    ):\n-        \"\"\"\n-        Compute the default columns for selecting every field in the base\n-        model. Will sometimes be called to pull in related models (e.g. via\n-        select_related), in which case \"opts\" and \"start_alias\" will be given\n-        to provide a starting point for the traversal.\n-\n-        Return a list of strings, quoted appropriately for use in SQL\n-        directly, as well as a set of aliases used in the select statement (if\n-        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n-        of strings as the first component and None as the second component).\n-        \"\"\"\n-        result = []\n-        if opts is None:\n-            if (opts := self.query.get_meta()) is None:\n-                return result\n-        start_alias = start_alias or self.query.get_initial_alias()\n-        # The 'seen_models' is used to optimize checking the needed parent\n-        # alias for a given field. This also includes None -> start_alias to\n-        # be used by local fields.\n-        seen_models = {None: start_alias}\n-\n-        for field in opts.concrete_fields:\n-            model = field.model._meta.concrete_model\n-            # A proxy model will have a different model and concrete_model. We\n-            # will assign None if the field belongs to this model.\n-            if model == opts.model:\n-                model = None\n-            if (\n-                from_parent\n-                and model is not None\n-                and issubclass(\n-                    from_parent._meta.concrete_model, model._meta.concrete_model\n-                )\n-            ):\n-                # Avoid loading data for already loaded parents.\n-                # We end up here in the case select_related() resolution\n-                # proceeds from parent model to child model. In that case the\n-                # parent model data is already present in the SELECT clause,\n-                # and we want to avoid reloading the same data again.\n-                continue\n-            if select_mask and field not in select_mask:\n-                continue\n-            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n-            column = field.get_col(alias)\n-            result.append(column)\n-        return result\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    \"\"\"\n+    Return a dict mapping each field in a model to True if it should be\n+    selected. If select_mask is not None, then it is an existing dict that\n+    should be updated with the fields in mask that are common to both\n+    select_mask and mask.\n+    \"\"\"\n+    only_load = {}\n+    select_mask = select_mask or {}\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        is_defer = field.many_to_many or field.one_to_many\n+        if not is_defer:\n+            only_load[field] = field_mask is not None\n+        if field_mask and (is_defer or field.related_model):\n+            field_select_mask = {}\n+            if field.related_model:\n+                # For related models, start with just the primary key\n+                pk_field = field.related_model._meta.pk\n+                field_select_mask[pk_field] = True\n+                # Then add only the fields specified in the mask\n+                if field_mask:\n+                    related_mask = self._get_only_select_mask(\n+                        field.related_model._meta, field_mask, field_select_mask\n+                    )\n+                    field_select_mask.update(related_mask)\n+            select_mask[field.related_model] = field_select_mask\n+    return only_load\n \n     def get_distinct(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..766b471b36 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,45 +772,67 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            # Recursively build the select mask for the related model\n+            # ensuring only specified fields are included\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, field_select_mask\n+            )\n+        else:\n+            # For non-relation fields or relations without nested mask,\n+            # add an empty dict to indicate the field should be selected\n+            field_select_mask.clear()\n+    return select_mask\n+\n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n+        # Add all primary key fields to the mask.\n+        for pk_field_name in opts.pk.get_attname_column():\n+            select_mask[pk_field_name[0]] = {}\n+\n+        # Add all fields specified in the mask.\n         for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n+            try:\n+                field = opts.get_field(field_name)\n+            except FieldDoesNotExist:\n+                raise FieldError(\n+                    \"Cannot resolve keyword %r into field. Choices are: %s\"\n+                    % (\n+                        field_name,\n+                        \", \".join(\n+                            [f.name for f in opts.get_fields() if not f.many_to_many]\n+                        ),\n+                    )\n+                )\n             field_select_mask = select_mask.setdefault(field, {})\n             if field_mask:\n                 if not field.is_relation:\n                     raise FieldError(next(iter(field_mask)))\n                 related_model = field.remote_field.model._meta.concrete_model\n+                # Create a new select_mask for the related model that only includes\n+                # the fields specified in field_mask\n+                related_select_mask = {}\n                 self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n+                    related_model._meta, field_mask, related_select_mask\n                 )\n+                # Store the restricted select_mask for this related field\n+                field_select_mask.update(related_select_mask)\n         return select_mask\n \n-    def get_select_mask(self):\n-        \"\"\"\n-        Convert the self.deferred_loading data structure to an alternate data\n-        structure, describing the field that *will* be loaded. This is used to\n-        compute the columns to select from the database and also by the\n-        QuerySet class to work out which fields are being initialized on each\n-        model. Models that have all their fields included aren't mentioned in\n-        the result, only those that have field restrictions in place.\n-        \"\"\"\n-        field_names, defer = self.deferred_loading\n-        if not field_names:\n-            return {}\n-        mask = {}\n-        for field_name in field_names:\n-            part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n-                part_mask = part_mask.setdefault(part, {})\n-        opts = self.get_meta()\n-        if defer:\n-            return self._get_defer_select_mask(opts, mask)\n-        return self._get_only_select_mask(opts, mask)\n-\n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n         Return a table alias for the given table_name and whether this is a\n@@ -2327,29 +2349,59 @@ class Query(BaseExpression):\n                 if new_only := set(field_names).difference(existing):\n                     self.deferred_loading = new_only, True\n \n-    def add_immediate_loading(self, field_names):\n-        \"\"\"\n-        Add the given list of model field names to the set of fields to\n-        retrieve when the SQL is executed (\"immediate loading\" fields). The\n-        field names replace any existing immediate loading field names. If\n-        there are field names already specified for deferred loading, remove\n-        those names from the new field_names before storing the new names\n-        for immediate loading. (That is, immediate loading overrides any\n-        existing immediate values, but respects existing deferrals.)\n-        \"\"\"\n-        existing, defer = self.deferred_loading\n-        field_names = set(field_names)\n-        if \"pk\" in field_names:\n-            field_names.remove(\"pk\")\n-            field_names.add(self.get_meta().pk.name)\n \n-        if defer:\n-            # Remove any existing deferred names from the current set before\n-            # setting the new names.\n-            self.deferred_loading = field_names.difference(existing), False\n-        else:\n-            # Replace any existing \"immediate load\" field names.\n-            self.deferred_loading = frozenset(field_names), False\n+def _get_only_select_mask(self, field_mask, related_model, opts):\n+    \"\"\"\n+    Return a dict of field names mapped to nested select masks for related\n+    fields.\n+    \"\"\"\n+    select_mask = {}\n+    field_select_mask = {}\n+    \n+    for field in opts.concrete_fields:\n+        field_mask_key = field.name\n+        if field_mask_key in field_mask:\n+            if field.is_relation:\n+                # For related fields, recursively build the select mask\n+                nested_field_mask = field_mask[field_mask_key]\n+                if nested_field_mask:\n+                    # Get the related model's opts\n+                    related_opts = field.related_model._meta\n+                    # Recursively build the select mask for the related model\n+                    nested_select_mask = self._get_only_select_mask(\n+                        nested_field_mask, field.related_model, related_opts\n+                    )\n+                    select_mask[field_mask_key] = nested_select_mask\n+                else:\n+                    # Empty nested mask means include only the relation field itself\n+                    select_mask[field_mask_key] = {}\n+            else:\n+                # Non-relation field, include it in the select mask\n+                select_mask[field_mask_key] = {}\n+        elif field.primary_key:\n+            # Always include primary key\n+            select_mask[field_mask_key] = {}\n+    \n+    # Handle reverse relations\n+    for field in opts.related_objects:\n+        field_mask_key = field.get_accessor_name()\n+        if field_mask_key in field_mask:\n+            nested_field_mask = field_mask[field_mask_key]\n+            if nested_field_mask:\n+                # Get the related model's opts\n+                related_opts = field.related_model._meta\n+                # Recursively build the select mask for the related model\n+                nested_select_mask = self._get_only_select_mask(\n+                    nested_field_mask, field.related_model, related_opts\n+                )\n+                # For reverse relations, we need to ensure the related model\n+                # includes only the specified fields plus its primary key\n+                field_select_mask[field_mask_key] = nested_select_mask\n+    \n+    # Combine both forward and reverse relation masks\n+    select_mask.update(field_select_mask)\n+    \n+    return select_mask\n \n     def set_annotation_mask(self, names):\n         \"\"\"Set the mask of annotations that will be returned by the SELECT.\"\"\"\n",
    "variant_2": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 78148f76b0..f12c29f813 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -338,16 +338,30 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n             return False\n     if not restricted and field.null:\n         return False\n-    if (\n-        restricted\n-        and select_mask\n-        and field.name in requested\n-        and field not in select_mask\n-    ):\n-        raise FieldError(\n-            f\"Field {field.model._meta.object_name}.{field.name} cannot be both \"\n-            \"deferred and traversed using select_related at the same time.\"\n-        )\n+\n+    def _get_only_select_mask(self, opts, mask, select_mask=None):\n+        if select_mask is None:\n+            select_mask = {}\n+        select_mask[opts.pk] = {}\n+        # Only add concrete fields that are in the mask\n+        for field_name, submask in mask.items():\n+            try:\n+                field = opts.get_field(field_name)\n+            except FieldDoesNotExist:\n+                continue\n+            if not field.concrete:\n+                continue\n+            select_mask[field] = {}\n+            if submask and field.is_relation:\n+                if field.related_model is None:\n+                    continue\n+                # Create a restricted select_mask for the related model\n+                field_select_mask = {}\n+                field_select_mask[field.related_model._meta.pk] = {}\n+                # Recursively process the submask for the related model\n+                self._get_only_select_mask(field.related_model._meta, submask, field_select_mask)\n+                self.related_select_mask.setdefault(field.related_model, field_select_mask)\n+        return select_mask\n     return True\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..f593f72e40 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -947,54 +947,64 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n-    def get_default_columns(\n-        self, select_mask, start_alias=None, opts=None, from_parent=None\n-    ):\n+\n+    def _get_only_select_mask(self, opts, select_mask, start_alias):\n         \"\"\"\n-        Compute the default columns for selecting every field in the base\n-        model. Will sometimes be called to pull in related models (e.g. via\n-        select_related), in which case \"opts\" and \"start_alias\" will be given\n-        to provide a starting point for the traversal.\n-\n-        Return a list of strings, quoted appropriately for use in SQL\n-        directly, as well as a set of aliases used in the select statement (if\n-        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n-        of strings as the first component and None as the second component).\n+        Return the select_mask for the given opts and select_mask.\n         \"\"\"\n-        result = []\n-        if opts is None:\n-            if (opts := self.query.get_meta()) is None:\n-                return result\n-        start_alias = start_alias or self.query.get_initial_alias()\n-        # The 'seen_models' is used to optimize checking the needed parent\n-        # alias for a given field. This also includes None -> start_alias to\n-        # be used by local fields.\n-        seen_models = {None: start_alias}\n-\n-        for field in opts.concrete_fields:\n-            model = field.model._meta.concrete_model\n-            # A proxy model will have a different model and concrete_model. We\n-            # will assign None if the field belongs to this model.\n-            if model == opts.model:\n-                model = None\n-            if (\n-                from_parent\n-                and model is not None\n-                and issubclass(\n-                    from_parent._meta.concrete_model, model._meta.concrete_model\n-                )\n-            ):\n-                # Avoid loading data for already loaded parents.\n-                # We end up here in the case select_related() resolution\n-                # proceeds from parent model to child model. In that case the\n-                # parent model data is already present in the SELECT clause,\n-                # and we want to avoid reloading the same data again.\n-                continue\n-            if select_mask and field not in select_mask:\n+        # If this is the root call or we have no mask, include all concrete fields\n+        if select_mask is None:\n+            return {f: {} for f in opts.concrete_fields}\n+        \n+        result = {}\n+        # Always include the primary key\n+        if opts.pk:\n+            result[opts.pk] = {}\n+        \n+        for field_name, field_mask in select_mask.items():\n+            try:\n+                field = opts.get_field(field_name)\n+            except FieldDoesNotExist:\n                 continue\n-            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n-            column = field.get_col(alias)\n-            result.append(column)\n+                \n+            if field.many_to_many:\n+                raise FieldError(\n+                    \"Invalid field name(s) given in select_related: '%s'. \"\n+                    \"Choices are: %s\" % (\n+                        field_name,\n+                        \", \".join(f.name for f in opts.get_fields() if not f.many_to_many)\n+                    )\n+                )\n+            \n+            # Add this field to the result\n+            result[field] = {}\n+            \n+            # If this field has a related model and there are nested selections\n+            if hasattr(field, 'remote_field') and field.remote_field and field_mask:\n+                related_model = field.remote_field.model\n+                related_opts = related_model._meta\n+                \n+                # Build the select mask for the related model\n+                # Include only the primary key and the fields specified in field_mask\n+                field_select_mask = {}\n+                \n+                # Always include the primary key of the related model\n+                if related_opts.pk:\n+                    field_select_mask[related_opts.pk] = {}\n+                \n+                # Add only the fields that are specified in the nested mask\n+                for nested_field_name, nested_mask in field_mask.items():\n+                    try:\n+                        nested_field = related_opts.get_field(nested_field_name)\n+                        field_select_mask[nested_field] = nested_mask\n+                    except FieldDoesNotExist:\n+                        continue\n+                \n+                # Store the computed select mask for this related field\n+                alias = self.query.join_parent_model(opts, field.model, start_alias, {})\n+                if alias not in self.query._filtered_relations:\n+                    self.query._filtered_relations[alias] = field_select_mask\n+                    \n         return result\n \n     def get_distinct(self):\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..6934eec3bc 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,44 +772,53 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n-    def _get_only_select_mask(self, opts, mask, select_mask=None):\n-        if select_mask is None:\n-            select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n-        for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n-            field_select_mask = select_mask.setdefault(field, {})\n-            if field_mask:\n-                if not field.is_relation:\n-                    raise FieldError(next(iter(field_mask)))\n-                related_model = field.remote_field.model._meta.concrete_model\n-                self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n-                )\n-        return select_mask\n \n-    def get_select_mask(self):\n-        \"\"\"\n-        Convert the self.deferred_loading data structure to an alternate data\n-        structure, describing the field that *will* be loaded. This is used to\n-        compute the columns to select from the database and also by the\n-        QuerySet class to work out which fields are being initialized on each\n-        model. Models that have all their fields included aren't mentioned in\n-        the result, only those that have field restrictions in place.\n-        \"\"\"\n-        field_names, defer = self.deferred_loading\n-        if not field_names:\n-            return {}\n-        mask = {}\n-        for field_name in field_names:\n-            part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n-                part_mask = part_mask.setdefault(part, {})\n-        opts = self.get_meta()\n-        if defer:\n-            return self._get_defer_select_mask(opts, mask)\n-        return self._get_only_select_mask(opts, mask)\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            # Ensure the related model's select_mask includes only PK and specified fields\n+            related_select_mask = {related_model._meta.pk: {}}\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, related_select_mask\n+            )\n+            # Update field_select_mask with the properly restricted related fields\n+            field_select_mask.update(related_select_mask)\n+    return select_mask\n+\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Add the primary key to the mask.\n+    pk_name = opts.pk.name\n+    select_mask[pk_name] = {}\n+\n+    # Add each field in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            # Pass a new empty dict for the related model's select_mask\n+            # and ensure it gets populated with only the specified fields\n+            related_select_mask = {}\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, related_select_mask\n+            )\n+            # Set the field_select_mask to the computed related_select_mask\n+            select_mask[field] = related_select_mask\n+    return select_mask\n \n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n@@ -2327,29 +2336,37 @@ class Query(BaseExpression):\n                 if new_only := set(field_names).difference(existing):\n                     self.deferred_loading = new_only, True\n \n-    def add_immediate_loading(self, field_names):\n-        \"\"\"\n-        Add the given list of model field names to the set of fields to\n-        retrieve when the SQL is executed (\"immediate loading\" fields). The\n-        field names replace any existing immediate loading field names. If\n-        there are field names already specified for deferred loading, remove\n-        those names from the new field_names before storing the new names\n-        for immediate loading. (That is, immediate loading overrides any\n-        existing immediate values, but respects existing deferrals.)\n-        \"\"\"\n-        existing, defer = self.deferred_loading\n-        field_names = set(field_names)\n-        if \"pk\" in field_names:\n-            field_names.remove(\"pk\")\n-            field_names.add(self.get_meta().pk.name)\n \n-        if defer:\n-            # Remove any existing deferred names from the current set before\n-            # setting the new names.\n-            self.deferred_loading = field_names.difference(existing), False\n+def _get_only_select_mask(self, field_mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Traverse the field_mask and populate select_mask for each related model\n+    for field_name, field_mask_item in field_mask.items():\n+        try:\n+            field = self.get_meta().get_field(field_name)\n+        except FieldDoesNotExist:\n+            continue\n+        \n+        if field.is_relation:\n+            # For related fields, we need to recursively build the select_mask\n+            related_model = field.related_model\n+            if related_model:\n+                # Create a field_select_mask that includes only the pk and specified fields\n+                field_select_mask = {}\n+                # Always include the primary key\n+                pk_name = related_model._meta.pk.name\n+                field_select_mask[pk_name] = {}\n+                # Recursively add the fields from field_mask_item\n+                if field_mask_item:\n+                    field_select_mask.update(field_mask_item)\n+                \n+                # Store the field_select_mask for this related field\n+                select_mask[field_name] = self._get_only_select_mask(field_mask_item, field_select_mask)\n         else:\n-            # Replace any existing \"immediate load\" field names.\n-            self.deferred_loading = frozenset(field_names), False\n+            # For non-related fields, just add them to the select_mask\n+            select_mask[field_name] = {}\n+    \n+    return select_mask\n \n     def set_annotation_mask(self, names):\n         \"\"\"Set the mask of annotations that will be returned by the SELECT.\"\"\"\n",
    "variant_3": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 78148f76b0..dcf949cdd5 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -338,16 +338,28 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n             return False\n     if not restricted and field.null:\n         return False\n-    if (\n-        restricted\n-        and select_mask\n-        and field.name in requested\n-        and field not in select_mask\n-    ):\n-        raise FieldError(\n-            f\"Field {field.model._meta.object_name}.{field.name} cannot be both \"\n-            \"deferred and traversed using select_related at the same time.\"\n-        )\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Only load the specified fields (mask) and their parents.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, field_mask)\n+        if field_mask and field.is_relation:\n+            if field.many_to_many:\n+                continue\n+            related_model = field.related_model\n+            related_select_mask = self._get_only_select_mask(\n+                related_model._meta, field_mask, {}\n+            )\n+            # Only include the primary key and fields specified in the mask\n+            if related_select_mask:\n+                # Add primary key field to ensure relation can be established\n+                pk_field = related_model._meta.pk\n+                related_select_mask[pk_field] = {}\n+            field_select_mask.update(related_select_mask)\n+    return select_mask\n     return True\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..3da97a9b27 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -947,55 +947,41 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n-    def get_default_columns(\n-        self, select_mask, start_alias=None, opts=None, from_parent=None\n-    ):\n-        \"\"\"\n-        Compute the default columns for selecting every field in the base\n-        model. Will sometimes be called to pull in related models (e.g. via\n-        select_related), in which case \"opts\" and \"start_alias\" will be given\n-        to provide a starting point for the traversal.\n-\n-        Return a list of strings, quoted appropriately for use in SQL\n-        directly, as well as a set of aliases used in the select statement (if\n-        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n-        of strings as the first component and None as the second component).\n-        \"\"\"\n-        result = []\n-        if opts is None:\n-            if (opts := self.query.get_meta()) is None:\n-                return result\n-        start_alias = start_alias or self.query.get_initial_alias()\n-        # The 'seen_models' is used to optimize checking the needed parent\n-        # alias for a given field. This also includes None -> start_alias to\n-        # be used by local fields.\n-        seen_models = {None: start_alias}\n-\n-        for field in opts.concrete_fields:\n-            model = field.model._meta.concrete_model\n-            # A proxy model will have a different model and concrete_model. We\n-            # will assign None if the field belongs to this model.\n-            if model == opts.model:\n-                model = None\n-            if (\n-                from_parent\n-                and model is not None\n-                and issubclass(\n-                    from_parent._meta.concrete_model, model._meta.concrete_model\n-                )\n-            ):\n-                # Avoid loading data for already loaded parents.\n-                # We end up here in the case select_related() resolution\n-                # proceeds from parent model to child model. In that case the\n-                # parent model data is already present in the SELECT clause,\n-                # and we want to avoid reloading the same data again.\n-                continue\n-            if select_mask and field not in select_mask:\n+\n+    def _get_only_select_mask(self, opts, mask, select_mask=None):\n+        if select_mask is None:\n+            select_mask = {}\n+        # Only load the specified fields (but always load pk).\n+        field_mask = mask.get(opts.model)\n+        if field_mask is None:\n+            return select_mask\n+        for field_name in field_mask:\n+            field = opts.get_field(field_name)\n+            if not field.concrete:\n                 continue\n-            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n-            column = field.get_col(alias)\n-            result.append(column)\n-        return result\n+            select_mask[field] = field_mask[field_name]\n+        # Always load the pk field.\n+        pk = opts.pk\n+        select_mask[pk] = {}\n+\n+        # Also always load parents for inheritance cases.\n+        for parent in opts.get_parent_list():\n+            select_mask.update(\n+                self._get_only_select_mask(parent, mask, select_mask.copy())\n+            )\n+        \n+        # Process related fields recursively\n+        for field_name, field_mask in mask.get(opts.model, {}).items():\n+            if field_mask:  # If there are nested fields to select\n+                field = opts.get_field(field_name)\n+                if hasattr(field, 'related_model'):\n+                    related_opts = field.related_model._meta\n+                    # Create a nested mask for the related model containing only the specified fields\n+                    related_mask = {related_opts.model: field_mask}\n+                    # Recursively get the select mask for the related model\n+                    self._get_only_select_mask(related_opts, related_mask, select_mask)\n+        \n+        return select_mask\n \n     def get_distinct(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..a1f22704db 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,11 +772,40 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            # For related fields, create a new select_mask that includes only\n+            # the primary key and recurse with the field_mask\n+            related_select_mask = {}\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, related_select_mask\n+            )\n+            # Update the field_select_mask with the restricted related fields\n+            field_select_mask.update(related_select_mask)\n+    return select_mask\n+\n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n+        \"\"\"\n+        Return the dictionary to be used as the select_mask for a model that\n+        should only load the fields named in 'mask'.\n+        \"\"\"\n         if select_mask is None:\n             select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n+        # Add the primary key to the mask.\n+        if opts.pk.attname not in mask:\n+            select_mask[opts.pk.attname] = {}\n         for field_name, field_mask in mask.items():\n             field = opts.get_field(field_name)\n             field_select_mask = select_mask.setdefault(field, {})\n@@ -784,33 +813,15 @@ class Query(BaseExpression):\n                 if not field.is_relation:\n                     raise FieldError(next(iter(field_mask)))\n                 related_model = field.remote_field.model._meta.concrete_model\n+                # Create a new select_mask for the related model that includes\n+                # only the primary key and the fields specified in field_mask\n+                related_select_mask = {}\n                 self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n+                    related_model._meta, field_mask, related_select_mask\n                 )\n+                field_select_mask.update(related_select_mask)\n         return select_mask\n \n-    def get_select_mask(self):\n-        \"\"\"\n-        Convert the self.deferred_loading data structure to an alternate data\n-        structure, describing the field that *will* be loaded. This is used to\n-        compute the columns to select from the database and also by the\n-        QuerySet class to work out which fields are being initialized on each\n-        model. Models that have all their fields included aren't mentioned in\n-        the result, only those that have field restrictions in place.\n-        \"\"\"\n-        field_names, defer = self.deferred_loading\n-        if not field_names:\n-            return {}\n-        mask = {}\n-        for field_name in field_names:\n-            part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n-                part_mask = part_mask.setdefault(part, {})\n-        opts = self.get_meta()\n-        if defer:\n-            return self._get_defer_select_mask(opts, mask)\n-        return self._get_only_select_mask(opts, mask)\n-\n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n         Return a table alias for the given table_name and whether this is a\n@@ -2327,29 +2338,29 @@ class Query(BaseExpression):\n                 if new_only := set(field_names).difference(existing):\n                     self.deferred_loading = new_only, True\n \n-    def add_immediate_loading(self, field_names):\n+\n+    def _get_only_select_mask(self, opts, select_mask, select_related_descend=True):\n         \"\"\"\n-        Add the given list of model field names to the set of fields to\n-        retrieve when the SQL is executed (\"immediate loading\" fields). The\n-        field names replace any existing immediate loading field names. If\n-        there are field names already specified for deferred loading, remove\n-        those names from the new field_names before storing the new names\n-        for immediate loading. (That is, immediate loading overrides any\n-        existing immediate values, but respects existing deferrals.)\n+        Return the fields that should be loaded by get_default_columns().\n         \"\"\"\n-        existing, defer = self.deferred_loading\n-        field_names = set(field_names)\n-        if \"pk\" in field_names:\n-            field_names.remove(\"pk\")\n-            field_names.add(self.get_meta().pk.name)\n-\n-        if defer:\n-            # Remove any existing deferred names from the current set before\n-            # setting the new names.\n-            self.deferred_loading = field_names.difference(existing), False\n-        else:\n-            # Replace any existing \"immediate load\" field names.\n-            self.deferred_loading = frozenset(field_names), False\n+        field_select_mask = {}\n+        for field_name, field_mask in select_mask.items():\n+            field = opts.get_field(field_name)\n+            if not select_related_descend:\n+                continue\n+            # Retrieve the field's model to pass to the recursive call.\n+            field_model = field.remote_field.model\n+            field_opts = field_model._meta\n+            # Recursively call _get_only_select_mask() to handle nested only() fields.\n+            if field_mask:\n+                # If there are specific fields requested for this relation,\n+                # pass them to the recursive call\n+                nested_mask = self._get_only_select_mask(field_opts, field_mask, select_related_descend)\n+            else:\n+                # If no specific fields are requested, include all fields\n+                nested_mask = None\n+            field_select_mask[field_name] = nested_mask\n+        return field_select_mask\n \n     def set_annotation_mask(self, names):\n         \"\"\"Set the mask of annotations that will be returned by the SELECT.\"\"\"\n",
    "variant_4": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 78148f76b0..34437b4bad 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -338,16 +338,44 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n             return False\n     if not restricted and field.null:\n         return False\n-    if (\n-        restricted\n-        and select_mask\n-        and field.name in requested\n-        and field not in select_mask\n-    ):\n-        raise FieldError(\n-            f\"Field {field.model._meta.object_name}.{field.name} cannot be both \"\n-            \"deferred and traversed using select_related at the same time.\"\n-        )\n+\n+def _get_only_select_mask(self, requested, select_mask=None, restricted=True):\n+    \"\"\"\n+    Return the select_mask that should be used for this query based on the\n+    requested fields (from an only() call) and any existing select_mask.\n+    \"\"\"\n+    if select_mask is None:\n+        select_mask = {}\n+    \n+    for field_name in requested:\n+        if LOOKUP_SEP in field_name:\n+            # Handle related field lookups\n+            parts = field_name.split(LOOKUP_SEP, 1)\n+            field_name, remaining = parts\n+            field = self.model._meta.get_field(field_name)\n+            \n+            # Get or create the nested select_mask for this field\n+            if field_name not in select_mask:\n+                select_mask[field_name] = {}\n+            \n+            # Recursively process the remaining field path\n+            related_model = field.remote_field.model if hasattr(field, 'remote_field') else field.related_model\n+            related_query = Query(related_model)\n+            \n+            # Build the select_mask for the related model with only the requested fields\n+            field_select_mask = related_query._get_only_select_mask([remaining], select_mask[field_name], restricted)\n+            \n+            # Ensure the primary key is always included in the related model's select_mask\n+            pk_field = related_model._meta.pk\n+            if pk_field.name not in field_select_mask:\n+                field_select_mask[pk_field.name] = {}\n+            \n+            select_mask[field_name] = field_select_mask\n+        else:\n+            # Direct field on this model\n+            select_mask[field_name] = {}\n+    \n+    return select_mask\n     return True\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..23a2be6d0e 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -947,55 +947,35 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n-    def get_default_columns(\n-        self, select_mask, start_alias=None, opts=None, from_parent=None\n-    ):\n-        \"\"\"\n-        Compute the default columns for selecting every field in the base\n-        model. Will sometimes be called to pull in related models (e.g. via\n-        select_related), in which case \"opts\" and \"start_alias\" will be given\n-        to provide a starting point for the traversal.\n-\n-        Return a list of strings, quoted appropriately for use in SQL\n-        directly, as well as a set of aliases used in the select statement (if\n-        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n-        of strings as the first component and None as the second component).\n-        \"\"\"\n-        result = []\n-        if opts is None:\n-            if (opts := self.query.get_meta()) is None:\n-                return result\n-        start_alias = start_alias or self.query.get_initial_alias()\n-        # The 'seen_models' is used to optimize checking the needed parent\n-        # alias for a given field. This also includes None -> start_alias to\n-        # be used by local fields.\n-        seen_models = {None: start_alias}\n-\n-        for field in opts.concrete_fields:\n-            model = field.model._meta.concrete_model\n-            # A proxy model will have a different model and concrete_model. We\n-            # will assign None if the field belongs to this model.\n-            if model == opts.model:\n-                model = None\n-            if (\n-                from_parent\n-                and model is not None\n-                and issubclass(\n-                    from_parent._meta.concrete_model, model._meta.concrete_model\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Only include fields that are mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.remote_field:\n+                raise FieldError(\n+                    \"Non-relational field given in select_related: '%s'. \"\n+                    \"Choices are: %s\"\n+                    % (\n+                        field_name,\n+                        \", \".join(\n+                            f.name\n+                            for f in opts.get_fields()\n+                            if f.remote_field\n+                        ),\n+                    )\n                 )\n-            ):\n-                # Avoid loading data for already loaded parents.\n-                # We end up here in the case select_related() resolution\n-                # proceeds from parent model to child model. In that case the\n-                # parent model data is already present in the SELECT clause,\n-                # and we want to avoid reloading the same data again.\n-                continue\n-            if select_mask and field not in select_mask:\n-                continue\n-            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n-            column = field.get_col(alias)\n-            result.append(column)\n-        return result\n+            related_opts = field.remote_field.model._meta\n+            # Create a restricted select_mask for the related model that includes\n+            # only the fields specified in field_mask, plus the primary key\n+            related_select_mask = {related_opts.pk: {}}\n+            self._get_only_select_mask(related_opts, field_mask, related_select_mask)\n+            # Store the restricted select_mask to be used by get_default_columns\n+            field_select_mask.update(related_select_mask)\n \n     def get_distinct(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..3ed4f275c6 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -784,32 +785,47 @@ class Query(BaseExpression):\n                 if not field.is_relation:\n                     raise FieldError(next(iter(field_mask)))\n                 related_model = field.remote_field.model._meta.concrete_model\n+                # Ensure the related model's select_mask is properly initialized\n+                # to include only the primary key before processing the nested mask\n+                related_select_mask = {}\n                 self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n+                    related_model._meta, field_mask, related_select_mask\n                 )\n+                # Update the field_select_mask with the properly constructed related_select_mask\n+                field_select_mask.update(related_select_mask)\n         return select_mask\n \n-    def get_select_mask(self):\n-        \"\"\"\n-        Convert the self.deferred_loading data structure to an alternate data\n-        structure, describing the field that *will* be loaded. This is used to\n-        compute the columns to select from the database and also by the\n-        QuerySet class to work out which fields are being initialized on each\n-        model. Models that have all their fields included aren't mentioned in\n-        the result, only those that have field restrictions in place.\n-        \"\"\"\n-        field_names, defer = self.deferred_loading\n-        if not field_names:\n-            return {}\n-        mask = {}\n-        for field_name in field_names:\n-            part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n-                part_mask = part_mask.setdefault(part, {})\n-        opts = self.get_meta()\n-        if defer:\n-            return self._get_defer_select_mask(opts, mask)\n-        return self._get_only_select_mask(opts, mask)\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Add the primary key to the mask.\n+    if opts.pk.attname not in mask:\n+        select_mask[opts.pk.attname] = {}\n+    for field_name, field_mask in mask.items():\n+        try:\n+            field = opts.get_field(field_name)\n+        except FieldDoesNotExist:\n+            raise FieldError(\"Cannot resolve keyword %r into field\" % field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            # Create a new select_mask for the related model that includes only\n+            # the primary key and fields specified in field_mask\n+            related_select_mask = {}\n+            # Always include the primary key for the related model\n+            related_select_mask[related_model._meta.pk.attname] = {}\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, related_select_mask\n+            )\n+            # Store the restricted select_mask for this field\n+            select_mask[field] = related_select_mask\n+        else:\n+            # For leaf fields (no nested mask), just mark them as selected\n+            select_mask[field] = {}\n+    return select_mask\n \n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n@@ -2327,29 +2343,34 @@ class Query(BaseExpression):\n                 if new_only := set(field_names).difference(existing):\n                     self.deferred_loading = new_only, True\n \n-    def add_immediate_loading(self, field_names):\n-        \"\"\"\n-        Add the given list of model field names to the set of fields to\n-        retrieve when the SQL is executed (\"immediate loading\" fields). The\n-        field names replace any existing immediate loading field names. If\n-        there are field names already specified for deferred loading, remove\n-        those names from the new field_names before storing the new names\n-        for immediate loading. (That is, immediate loading overrides any\n-        existing immediate values, but respects existing deferrals.)\n-        \"\"\"\n-        existing, defer = self.deferred_loading\n-        field_names = set(field_names)\n-        if \"pk\" in field_names:\n-            field_names.remove(\"pk\")\n-            field_names.add(self.get_meta().pk.name)\n \n-        if defer:\n-            # Remove any existing deferred names from the current set before\n-            # setting the new names.\n-            self.deferred_loading = field_names.difference(existing), False\n-        else:\n-            # Replace any existing \"immediate load\" field names.\n-            self.deferred_loading = frozenset(field_names), False\n+def _get_only_select_mask(self, field_mask, opts=None):\n+    \"\"\"\n+    Get the select_mask for the given field_mask and options.\n+    \"\"\"\n+    if opts is None:\n+        opts = self.get_meta()\n+    \n+    select_mask = {}\n+    \n+    # Always include the primary key\n+    select_mask[opts.pk.name] = {}\n+    \n+    for field_name, submask in field_mask.items():\n+        try:\n+            field = opts.get_field(field_name)\n+        except FieldDoesNotExist:\n+            continue\n+            \n+        select_mask[field_name] = {}\n+        \n+        if field.is_relation and submask:\n+            # For related fields, recursively get the select mask\n+            related_opts = field.related_model._meta\n+            field_select_mask = self._get_only_select_mask(submask, related_opts)\n+            select_mask[field_name] = field_select_mask\n+    \n+    return select_mask\n \n     def set_annotation_mask(self, names):\n         \"\"\"Set the mask of annotations that will be returned by the SELECT.\"\"\"\n",
    "variant_5": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 78148f76b0..13ca328230 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -338,16 +338,54 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n             return False\n     if not restricted and field.null:\n         return False\n-    if (\n-        restricted\n-        and select_mask\n-        and field.name in requested\n-        and field not in select_mask\n-    ):\n-        raise FieldError(\n-            f\"Field {field.model._meta.object_name}.{field.name} cannot be both \"\n-            \"deferred and traversed using select_related at the same time.\"\n-        )\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Only load the specified fields (mask), and only from the specified\n+    # tables (select_mask). If select_mask isn't specified, don't use one.\n+    if not mask:\n+        return {}\n+\n+    # Build a select_mask if we don't have one.\n+    if not select_mask:\n+        select_mask = self.get_select_mask()\n+\n+    # Start with an empty mask and only add the fields we're loading.\n+    field_select_mask = {}\n+    for field_name, field_mask in mask.items():\n+        try:\n+            field = opts.get_field(field_name)\n+        except FieldDoesNotExist:\n+            # Ignore non-existent fields.\n+            continue\n+        field_select_mask[field] = field_mask\n+        if field_mask and field.is_relation:\n+            if field.many_to_many:\n+                continue\n+            related_model = field.related_model\n+            if related_model is None:\n+                continue\n+            if field.reverse:\n+                related_opts = related_model._meta\n+                related_mask = self._get_only_select_mask(\n+                    related_opts, field_mask, select_mask.get(field, {})\n+                )\n+            else:\n+                related_opts = related_model._meta\n+                # For forward relations, create a proper select_mask that includes\n+                # only the primary key and the fields specified in field_mask\n+                related_select_mask = {related_opts.pk: {}}\n+                for related_field_name in field_mask:\n+                    try:\n+                        related_field = related_opts.get_field(related_field_name)\n+                        related_select_mask[related_field] = field_mask[related_field_name]\n+                    except FieldDoesNotExist:\n+                        continue\n+                related_mask = self._get_only_select_mask(\n+                    related_opts, field_mask, related_select_mask\n+                )\n+    return field_select_mask\n     return True\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..990f3454b1 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -947,55 +947,40 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n-    def get_default_columns(\n-        self, select_mask, start_alias=None, opts=None, from_parent=None\n-    ):\n-        \"\"\"\n-        Compute the default columns for selecting every field in the base\n-        model. Will sometimes be called to pull in related models (e.g. via\n-        select_related), in which case \"opts\" and \"start_alias\" will be given\n-        to provide a starting point for the traversal.\n-\n-        Return a list of strings, quoted appropriately for use in SQL\n-        directly, as well as a set of aliases used in the select statement (if\n-        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n-        of strings as the first component and None as the second component).\n-        \"\"\"\n-        result = []\n-        if opts is None:\n-            if (opts := self.query.get_meta()) is None:\n-                return result\n-        start_alias = start_alias or self.query.get_initial_alias()\n-        # The 'seen_models' is used to optimize checking the needed parent\n-        # alias for a given field. This also includes None -> start_alias to\n-        # be used by local fields.\n-        seen_models = {None: start_alias}\n-\n-        for field in opts.concrete_fields:\n-            model = field.model._meta.concrete_model\n-            # A proxy model will have a different model and concrete_model. We\n-            # will assign None if the field belongs to this model.\n-            if model == opts.model:\n-                model = None\n-            if (\n-                from_parent\n-                and model is not None\n-                and issubclass(\n-                    from_parent._meta.concrete_model, model._meta.concrete_model\n-                )\n-            ):\n-                # Avoid loading data for already loaded parents.\n-                # We end up here in the case select_related() resolution\n-                # proceeds from parent model to child model. In that case the\n-                # parent model data is already present in the SELECT clause,\n-                # and we want to avoid reloading the same data again.\n-                continue\n-            if select_mask and field not in select_mask:\n-                continue\n-            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n-            column = field.get_col(alias)\n-            result.append(column)\n-        return result\n+\n+    def _get_only_select_mask(self, opts, mask, select_mask=None):\n+        if select_mask is None:\n+            select_mask = {}\n+        # Only include fields that are specified in the mask or are needed\n+        # for the query (like pk fields).\n+        pk = opts.pk\n+        # Always include the primary key\n+        select_mask[pk] = {}\n+        \n+        if not mask:\n+            return select_mask\n+            \n+        for field_name, field_mask in mask.items():\n+            field = opts.get_field(field_name)\n+            select_mask[field] = {}\n+            if field_mask and hasattr(field, 'related_model'):\n+                related_model = field.related_model\n+                if related_model:\n+                    # Create a proper select_mask for the related model that includes\n+                    # only the primary key and the fields specified in field_mask\n+                    related_opts = related_model._meta\n+                    related_select_mask = {}\n+                    # Always include the related model's primary key\n+                    related_select_mask[related_opts.pk] = {}\n+                    # Add only the fields specified in the field_mask\n+                    for related_field_name in field_mask:\n+                        try:\n+                            related_field = related_opts.get_field(related_field_name)\n+                            related_select_mask[related_field] = {}\n+                        except FieldDoesNotExist:\n+                            pass\n+                    select_mask[field] = related_select_mask\n+        return select_mask\n \n     def get_distinct(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..dd2cc90e58 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,44 +772,55 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n-    def _get_only_select_mask(self, opts, mask, select_mask=None):\n-        if select_mask is None:\n-            select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n-        for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n-            field_select_mask = select_mask.setdefault(field, {})\n-            if field_mask:\n-                if not field.is_relation:\n-                    raise FieldError(next(iter(field_mask)))\n-                related_model = field.remote_field.model._meta.concrete_model\n-                self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n-                )\n-        return select_mask\n \n-    def get_select_mask(self):\n-        \"\"\"\n-        Convert the self.deferred_loading data structure to an alternate data\n-        structure, describing the field that *will* be loaded. This is used to\n-        compute the columns to select from the database and also by the\n-        QuerySet class to work out which fields are being initialized on each\n-        model. Models that have all their fields included aren't mentioned in\n-        the result, only those that have field restrictions in place.\n-        \"\"\"\n-        field_names, defer = self.deferred_loading\n-        if not field_names:\n-            return {}\n-        mask = {}\n-        for field_name in field_names:\n-            part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n-                part_mask = part_mask.setdefault(part, {})\n-        opts = self.get_meta()\n-        if defer:\n-            return self._get_defer_select_mask(opts, mask)\n-        return self._get_only_select_mask(opts, mask)\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            # Create a new select_mask for the related model instead of reusing field_select_mask\n+            related_select_mask = {}\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, related_select_mask\n+            )\n+            # Update field_select_mask with the properly constructed related_select_mask\n+            field_select_mask.update(related_select_mask)\n+    return select_mask\n+\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Add the primary key to the mask.\n+    if opts.pk.attname not in select_mask:\n+        select_mask[opts.pk.attname] = {}\n+    # Add each field in the mask.\n+    for field_name, field_mask in mask.items():\n+        try:\n+            field = opts.get_field(field_name)\n+        except FieldDoesNotExist:\n+            raise FieldError(f\"Cannot resolve keyword '{field_name}' into field.\")\n+        field_select_mask = select_mask.setdefault(field.attname, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            # Create a restricted select_mask for the related model\n+            related_select_mask = {}\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, related_select_mask\n+            )\n+            # Only set the field_select_mask if there are restrictions\n+            if related_select_mask:\n+                field_select_mask.update(related_select_mask)\n+    return select_mask\n \n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n@@ -2327,29 +2338,50 @@ class Query(BaseExpression):\n                 if new_only := set(field_names).difference(existing):\n                     self.deferred_loading = new_only, True\n \n-    def add_immediate_loading(self, field_names):\n+\n+    def _get_only_select_mask(self, opts, mask, select_mask=None, filtered_relation=None):\n         \"\"\"\n-        Add the given list of model field names to the set of fields to\n-        retrieve when the SQL is executed (\"immediate loading\" fields). The\n-        field names replace any existing immediate loading field names. If\n-        there are field names already specified for deferred loading, remove\n-        those names from the new field_names before storing the new names\n-        for immediate loading. (That is, immediate loading overrides any\n-        existing immediate values, but respects existing deferrals.)\n+        Return the dictionary of field names to be selected based on the\n+        'only' fields specified in the query and any filtered relation.\n         \"\"\"\n-        existing, defer = self.deferred_loading\n-        field_names = set(field_names)\n-        if \"pk\" in field_names:\n-            field_names.remove(\"pk\")\n-            field_names.add(self.get_meta().pk.name)\n-\n-        if defer:\n-            # Remove any existing deferred names from the current set before\n-            # setting the new names.\n-            self.deferred_loading = field_names.difference(existing), False\n-        else:\n-            # Replace any existing \"immediate load\" field names.\n-            self.deferred_loading = frozenset(field_names), False\n+        if select_mask is None:\n+            select_mask = {}\n+        select_mask = select_mask.copy()\n+        \n+        # Always include the primary key\n+        if opts.pk.name not in select_mask:\n+            select_mask[opts.pk.name] = {}\n+            \n+        for field_name, field_mask in mask.items():\n+            field_select_mask = {}\n+            try:\n+                field = opts.get_field(field_name)\n+            except FieldDoesNotExist:\n+                # Annotation.\n+                select_mask[field_name] = field_select_mask\n+                continue\n+            else:\n+                if filtered_relation:\n+                    field_select_mask = self._get_only_select_mask(\n+                        field.related_model._meta, field_mask, field_select_mask,\n+                        filtered_relation,\n+                    )\n+                elif field.is_relation:\n+                    related_model = field.related_model\n+                    related_opts = related_model._meta\n+                    # For related fields, create a proper select_mask that includes only\n+                    # the primary key and fields specified in field_mask\n+                    related_select_mask = {}\n+                    # Always include the primary key of the related model\n+                    related_select_mask[related_opts.pk.name] = {}\n+                    # Add only the fields specified in the mask\n+                    for nested_field_name in field_mask:\n+                        related_select_mask[nested_field_name] = field_mask[nested_field_name]\n+                    field_select_mask = self._get_only_select_mask(\n+                        related_opts, field_mask, related_select_mask\n+                    )\n+            select_mask[field_name] = field_select_mask\n+        return select_mask\n \n     def set_annotation_mask(self, names):\n         \"\"\"Set the mask of annotations that will be returned by the SELECT.\"\"\"\n",
    "variant_6": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 78148f76b0..0e27076aa8 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -338,16 +338,37 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n             return False\n     if not restricted and field.null:\n         return False\n-    if (\n-        restricted\n-        and select_mask\n-        and field.name in requested\n-        and field not in select_mask\n-    ):\n-        raise FieldError(\n-            f\"Field {field.model._meta.object_name}.{field.name} cannot be both \"\n-            \"deferred and traversed using select_related at the same time.\"\n-        )\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Only load the specified fields (mask) and their parents.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        if field.is_relation:\n+            if field.many_to_many:\n+                continue\n+            if field.remote_field.parent_link:\n+                continue\n+            related_model = field.remote_field.model\n+            related_opts = related_model._meta\n+            \n+            # Create a proper field_select_mask for the related model\n+            field_select_mask = {}\n+            # Always include the primary key\n+            pk_field = related_opts.pk\n+            field_select_mask[pk_field] = {}\n+            \n+            # If there are nested fields specified, include only those\n+            if field_mask:\n+                field_select_mask.update(\n+                    self._get_only_select_mask(related_opts, field_mask)\n+                )\n+            \n+            select_mask[field] = field_select_mask\n+        else:\n+            select_mask[field] = {}\n+    return select_mask\n     return True\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..b6c5f11ae9 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -947,55 +947,24 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n-    def get_default_columns(\n-        self, select_mask, start_alias=None, opts=None, from_parent=None\n-    ):\n-        \"\"\"\n-        Compute the default columns for selecting every field in the base\n-        model. Will sometimes be called to pull in related models (e.g. via\n-        select_related), in which case \"opts\" and \"start_alias\" will be given\n-        to provide a starting point for the traversal.\n-\n-        Return a list of strings, quoted appropriately for use in SQL\n-        directly, as well as a set of aliases used in the select statement (if\n-        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n-        of strings as the first component and None as the second component).\n-        \"\"\"\n-        result = []\n-        if opts is None:\n-            if (opts := self.query.get_meta()) is None:\n-                return result\n-        start_alias = start_alias or self.query.get_initial_alias()\n-        # The 'seen_models' is used to optimize checking the needed parent\n-        # alias for a given field. This also includes None -> start_alias to\n-        # be used by local fields.\n-        seen_models = {None: start_alias}\n-\n-        for field in opts.concrete_fields:\n-            model = field.model._meta.concrete_model\n-            # A proxy model will have a different model and concrete_model. We\n-            # will assign None if the field belongs to this model.\n-            if model == opts.model:\n-                model = None\n-            if (\n-                from_parent\n-                and model is not None\n-                and issubclass(\n-                    from_parent._meta.concrete_model, model._meta.concrete_model\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Only add fields that are explicitly requested.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                # If the field mask is not empty then the field is looking\n+                # for something and we have to be more careful.\n+                field_select_mask.clear()\n+            else:\n+                field_select_mask = self._get_only_select_mask(\n+                    field.related_model._meta, field_mask, field_select_mask\n                 )\n-            ):\n-                # Avoid loading data for already loaded parents.\n-                # We end up here in the case select_related() resolution\n-                # proceeds from parent model to child model. In that case the\n-                # parent model data is already present in the SELECT clause,\n-                # and we want to avoid reloading the same data again.\n-                continue\n-            if select_mask and field not in select_mask:\n-                continue\n-            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n-            column = field.get_col(alias)\n-            result.append(column)\n-        return result\n+    return select_mask\n \n     def get_distinct(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..f17db0c38a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -784,32 +785,37 @@ class Query(BaseExpression):\n                 if not field.is_relation:\n                     raise FieldError(next(iter(field_mask)))\n                 related_model = field.remote_field.model._meta.concrete_model\n+                # Ensure the related model's select_mask only includes specified fields\n+                related_select_mask = {}\n                 self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n+                    related_model._meta, field_mask, related_select_mask\n                 )\n+                # Only update field_select_mask with the restricted fields\n+                field_select_mask.update(related_select_mask)\n         return select_mask\n \n-    def get_select_mask(self):\n-        \"\"\"\n-        Convert the self.deferred_loading data structure to an alternate data\n-        structure, describing the field that *will* be loaded. This is used to\n-        compute the columns to select from the database and also by the\n-        QuerySet class to work out which fields are being initialized on each\n-        model. Models that have all their fields included aren't mentioned in\n-        the result, only those that have field restrictions in place.\n-        \"\"\"\n-        field_names, defer = self.deferred_loading\n-        if not field_names:\n-            return {}\n-        mask = {}\n-        for field_name in field_names:\n-            part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n-                part_mask = part_mask.setdefault(part, {})\n-        opts = self.get_meta()\n-        if defer:\n-            return self._get_defer_select_mask(opts, mask)\n-        return self._get_only_select_mask(opts, mask)\n+\n+    def _get_only_select_mask(self, opts, mask, select_mask=None):\n+        if select_mask is None:\n+            select_mask = {}\n+        # Add the primary key to the mask if it's not already there.\n+        if opts.pk.attname not in select_mask:\n+            select_mask[opts.pk.attname] = {}\n+        for field_name, field_mask in mask.items():\n+            field = opts.get_field(field_name)\n+            field_select_mask = select_mask.setdefault(field, {})\n+            if field_mask:\n+                if not field.is_relation:\n+                    raise FieldError(next(iter(field_mask)))\n+                related_model = field.remote_field.model._meta.concrete_model\n+                # Create a new select_mask that includes only the pk and specified fields\n+                related_select_mask = {}\n+                self._get_only_select_mask(\n+                    related_model._meta, field_mask, related_select_mask\n+                )\n+                # Update the field_select_mask with the properly restricted related fields\n+                field_select_mask.update(related_select_mask)\n+        return select_mask\n \n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n@@ -2327,29 +2333,36 @@ class Query(BaseExpression):\n                 if new_only := set(field_names).difference(existing):\n                     self.deferred_loading = new_only, True\n \n-    def add_immediate_loading(self, field_names):\n-        \"\"\"\n-        Add the given list of model field names to the set of fields to\n-        retrieve when the SQL is executed (\"immediate loading\" fields). The\n-        field names replace any existing immediate loading field names. If\n-        there are field names already specified for deferred loading, remove\n-        those names from the new field_names before storing the new names\n-        for immediate loading. (That is, immediate loading overrides any\n-        existing immediate values, but respects existing deferrals.)\n-        \"\"\"\n-        existing, defer = self.deferred_loading\n-        field_names = set(field_names)\n-        if \"pk\" in field_names:\n-            field_names.remove(\"pk\")\n-            field_names.add(self.get_meta().pk.name)\n \n-        if defer:\n-            # Remove any existing deferred names from the current set before\n-            # setting the new names.\n-            self.deferred_loading = field_names.difference(existing), False\n+def _get_only_select_mask(self, field_mask, related_klass_infos):\n+    \"\"\"\n+    Return a select_mask for related models based on the field_mask.\n+    The field_mask is a dict mapping field names to None or a nested\n+    field_mask for the related model.\n+    \"\"\"\n+    select_mask = {}\n+    for field_name, nested_mask in field_mask.items():\n+        try:\n+            field = self.get_meta().get_field(field_name)\n+        except FieldDoesNotExist:\n+            continue\n+        if field.is_relation and field.related_model:\n+            related_model = field.related_model\n+            if related_model in related_klass_infos:\n+                related_select_mask = {}\n+                # Always include the primary key\n+                pk_name = related_model._meta.pk.name\n+                related_select_mask[pk_name] = {}\n+                \n+                # If there's a nested mask, only include those fields\n+                if nested_mask:\n+                    related_query = related_model._default_manager.get_queryset().query\n+                    related_select_mask.update(related_query._get_only_select_mask(nested_mask, related_klass_infos))\n+                \n+                select_mask[field_name] = related_select_mask\n         else:\n-            # Replace any existing \"immediate load\" field names.\n-            self.deferred_loading = frozenset(field_names), False\n+            select_mask[field_name] = {}\n+    return select_mask\n \n     def set_annotation_mask(self, names):\n         \"\"\"Set the mask of annotations that will be returned by the SELECT.\"\"\"\n",
    "variant_7": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 78148f76b0..889d5294f2 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -338,16 +338,31 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n             return False\n     if not restricted and field.null:\n         return False\n-    if (\n-        restricted\n-        and select_mask\n-        and field.name in requested\n-        and field not in select_mask\n-    ):\n-        raise FieldError(\n-            f\"Field {field.model._meta.object_name}.{field.name} cannot be both \"\n-            \"deferred and traversed using select_related at the same time.\"\n-        )\n+\n+def _get_only_select_mask(self, opts, select_mask, restricted=True):\n+    \"\"\"\n+    Return the dictionary of select_mask for the query, or None if a full\n+    query should be done.\n+    \"\"\"\n+    field_select_mask = {}\n+    for field_name, field_mask in select_mask.items():\n+        field = opts.get_field(field_name)\n+        if field.is_relation:\n+            if field_mask is None:\n+                # If field_mask is None, we should select all fields of the related model\n+                field_select_mask[field] = None\n+            else:\n+                # Recursively process the related model with the nested field_mask\n+                related_select_mask = self._get_only_select_mask(\n+                    field.related_model._meta, field_mask, restricted\n+                )\n+                if related_select_mask is not None:\n+                    field_select_mask[field] = related_select_mask\n+        else:\n+            # For non-relation fields, include them in the mask\n+            field_select_mask[field] = field_mask\n+\n+    return field_select_mask or None\n     return True\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..a3dcf80d67 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -947,55 +947,22 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n-    def get_default_columns(\n-        self, select_mask, start_alias=None, opts=None, from_parent=None\n-    ):\n-        \"\"\"\n-        Compute the default columns for selecting every field in the base\n-        model. Will sometimes be called to pull in related models (e.g. via\n-        select_related), in which case \"opts\" and \"start_alias\" will be given\n-        to provide a starting point for the traversal.\n-\n-        Return a list of strings, quoted appropriately for use in SQL\n-        directly, as well as a set of aliases used in the select statement (if\n-        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n-        of strings as the first component and None as the second component).\n-        \"\"\"\n-        result = []\n-        if opts is None:\n-            if (opts := self.query.get_meta()) is None:\n-                return result\n-        start_alias = start_alias or self.query.get_initial_alias()\n-        # The 'seen_models' is used to optimize checking the needed parent\n-        # alias for a given field. This also includes None -> start_alias to\n-        # be used by local fields.\n-        seen_models = {None: start_alias}\n-\n-        for field in opts.concrete_fields:\n-            model = field.model._meta.concrete_model\n-            # A proxy model will have a different model and concrete_model. We\n-            # will assign None if the field belongs to this model.\n-            if model == opts.model:\n-                model = None\n-            if (\n-                from_parent\n-                and model is not None\n-                and issubclass(\n-                    from_parent._meta.concrete_model, model._meta.concrete_model\n+\n+    def _get_only_select_mask(self, opts, mask, select_mask=None):\n+        if select_mask is None:\n+            select_mask = {}\n+        for field_name, field_mask in mask.items():\n+            field = opts.get_field(field_name)\n+            if not field.is_relation:\n+                select_mask[field] = field_mask\n+            else:\n+                next_mask = self._get_only_select_mask(\n+                    field.related_model._meta, field_mask, {}\n                 )\n-            ):\n-                # Avoid loading data for already loaded parents.\n-                # We end up here in the case select_related() resolution\n-                # proceeds from parent model to child model. In that case the\n-                # parent model data is already present in the SELECT clause,\n-                # and we want to avoid reloading the same data again.\n-                continue\n-            if select_mask and field not in select_mask:\n-                continue\n-            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n-            column = field.get_col(alias)\n-            result.append(column)\n-        return result\n+                if next_mask:\n+                    # Only add the related field if there are fields to select from it\n+                    select_mask[field] = next_mask\n+        return select_mask\n \n     def get_distinct(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..a6fd04ca79 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,11 +772,36 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            # Create a new select_mask for the related model instead of passing the empty dict\n+            related_select_mask = {}\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, related_select_mask\n+            )\n+            # Update field_select_mask with the properly constructed related_select_mask\n+            field_select_mask.update(related_select_mask)\n+    return select_mask\n+\n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n+        # Add the primary key to the mask.\n+        if opts.pk.attname not in mask:\n+            select_mask[opts.pk.attname] = {}\n+        # Add concrete fields mentioned in the mask.\n         for field_name, field_mask in mask.items():\n             field = opts.get_field(field_name)\n             field_select_mask = select_mask.setdefault(field, {})\n@@ -784,33 +809,16 @@ class Query(BaseExpression):\n                 if not field.is_relation:\n                     raise FieldError(next(iter(field_mask)))\n                 related_model = field.remote_field.model._meta.concrete_model\n+                # Create a new select_mask for the related model that includes only\n+                # the primary key and fields specified in field_mask\n+                related_select_mask = {}\n                 self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n+                    related_model._meta, field_mask, related_select_mask\n                 )\n+                # Only assign the constructed related_select_mask to field_select_mask\n+                field_select_mask.update(related_select_mask)\n         return select_mask\n \n-    def get_select_mask(self):\n-        \"\"\"\n-        Convert the self.deferred_loading data structure to an alternate data\n-        structure, describing the field that *will* be loaded. This is used to\n-        compute the columns to select from the database and also by the\n-        QuerySet class to work out which fields are being initialized on each\n-        model. Models that have all their fields included aren't mentioned in\n-        the result, only those that have field restrictions in place.\n-        \"\"\"\n-        field_names, defer = self.deferred_loading\n-        if not field_names:\n-            return {}\n-        mask = {}\n-        for field_name in field_names:\n-            part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n-                part_mask = part_mask.setdefault(part, {})\n-        opts = self.get_meta()\n-        if defer:\n-            return self._get_defer_select_mask(opts, mask)\n-        return self._get_only_select_mask(opts, mask)\n-\n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n         Return a table alias for the given table_name and whether this is a\n@@ -2327,29 +2335,38 @@ class Query(BaseExpression):\n                 if new_only := set(field_names).difference(existing):\n                     self.deferred_loading = new_only, True\n \n-    def add_immediate_loading(self, field_names):\n-        \"\"\"\n-        Add the given list of model field names to the set of fields to\n-        retrieve when the SQL is executed (\"immediate loading\" fields). The\n-        field names replace any existing immediate loading field names. If\n-        there are field names already specified for deferred loading, remove\n-        those names from the new field_names before storing the new names\n-        for immediate loading. (That is, immediate loading overrides any\n-        existing immediate values, but respects existing deferrals.)\n-        \"\"\"\n-        existing, defer = self.deferred_loading\n-        field_names = set(field_names)\n-        if \"pk\" in field_names:\n-            field_names.remove(\"pk\")\n-            field_names.add(self.get_meta().pk.name)\n \n-        if defer:\n-            # Remove any existing deferred names from the current set before\n-            # setting the new names.\n-            self.deferred_loading = field_names.difference(existing), False\n+def _get_only_select_mask(self, field_mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Determine which fields to include in the query.\n+    for field_name, field_mask in field_mask.items():\n+        field = self.get_meta().get_field(field_name)\n+        if not field.is_relation:\n+            select_mask[field] = field_mask\n         else:\n-            # Replace any existing \"immediate load\" field names.\n-            self.deferred_loading = frozenset(field_names), False\n+            # For related fields, create a select_mask that includes only the\n+            # primary key and the fields specified in field_mask\n+            related_model = field.related_model\n+            if field_mask:\n+                # Build select_mask for related model with only specified fields\n+                related_select_mask = {}\n+                # Always include the primary key\n+                pk_field = related_model._meta.pk\n+                related_select_mask[pk_field] = {}\n+                # Add fields specified in the mask\n+                for related_field_name in field_mask:\n+                    related_field = related_model._meta.get_field(related_field_name)\n+                    related_select_mask[related_field] = field_mask[related_field_name]\n+                select_mask[field] = self._get_only_select_mask(\n+                    field_mask, related_select_mask\n+                )\n+            else:\n+                # If no specific fields are requested for the relation,\n+                # include only the primary key\n+                pk_field = related_model._meta.pk\n+                select_mask[field] = {pk_field: {}}\n+    return select_mask\n \n     def set_annotation_mask(self, names):\n         \"\"\"Set the mask of annotations that will be returned by the SELECT.\"\"\"\n",
    "variant_8": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 78148f76b0..cd1cdc86fa 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -338,16 +338,37 @@ def select_related_descend(field, restricted, requested, select_mask, reverse=Fa\n             return False\n     if not restricted and field.null:\n         return False\n-    if (\n-        restricted\n-        and select_mask\n-        and field.name in requested\n-        and field not in select_mask\n-    ):\n-        raise FieldError(\n-            f\"Field {field.model._meta.object_name}.{field.name} cannot be both \"\n-            \"deferred and traversed using select_related at the same time.\"\n-        )\n+\n+    def _get_only_select_mask(self, field_mask, select_mask=None):\n+        if select_mask is None:\n+            select_mask = {}\n+        # Determine which fields should be loaded based on the query.\n+        if field_mask:\n+            for field in self.model._meta.concrete_fields:\n+                field_mask_key = field.name\n+                try:\n+                    field_mask[field_mask_key]\n+                except KeyError:\n+                    select_mask.setdefault(field, False)\n+                else:\n+                    select_mask.setdefault(field, True)\n+        for field, related_model in self.model._meta.concrete_fields:\n+            if not field.remote_field:\n+                continue\n+            field_mask_key = field.name\n+            try:\n+                field_mask[field_mask_key]\n+            except KeyError:\n+                continue\n+            related_model = field.remote_field.model\n+            field_select_mask = {}\n+            # Fix: Properly construct the select_mask for the related model\n+            # by passing the nested field_mask and ensuring it restricts field selection\n+            related_field_mask = field_mask[field_mask_key]\n+            related_query = related_model._default_manager.get_queryset()\n+            related_query = related_query._get_only_select_mask(related_field_mask, field_select_mask)\n+            select_mask[field] = field_select_mask\n+        return select_mask\n     return True\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..63c03d57e2 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -947,55 +947,32 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n-    def get_default_columns(\n-        self, select_mask, start_alias=None, opts=None, from_parent=None\n-    ):\n-        \"\"\"\n-        Compute the default columns for selecting every field in the base\n-        model. Will sometimes be called to pull in related models (e.g. via\n-        select_related), in which case \"opts\" and \"start_alias\" will be given\n-        to provide a starting point for the traversal.\n-\n-        Return a list of strings, quoted appropriately for use in SQL\n-        directly, as well as a set of aliases used in the select statement (if\n-        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n-        of strings as the first component and None as the second component).\n-        \"\"\"\n-        result = []\n-        if opts is None:\n-            if (opts := self.query.get_meta()) is None:\n-                return result\n-        start_alias = start_alias or self.query.get_initial_alias()\n-        # The 'seen_models' is used to optimize checking the needed parent\n-        # alias for a given field. This also includes None -> start_alias to\n-        # be used by local fields.\n-        seen_models = {None: start_alias}\n-\n-        for field in opts.concrete_fields:\n-            model = field.model._meta.concrete_model\n-            # A proxy model will have a different model and concrete_model. We\n-            # will assign None if the field belongs to this model.\n-            if model == opts.model:\n-                model = None\n-            if (\n-                from_parent\n-                and model is not None\n-                and issubclass(\n-                    from_parent._meta.concrete_model, model._meta.concrete_model\n-                )\n-            ):\n-                # Avoid loading data for already loaded parents.\n-                # We end up here in the case select_related() resolution\n-                # proceeds from parent model to child model. In that case the\n-                # parent model data is already present in the SELECT clause,\n-                # and we want to avoid reloading the same data again.\n-                continue\n-            if select_mask and field not in select_mask:\n-                continue\n-            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n-            column = field.get_col(alias)\n-            result.append(column)\n-        return result\n+\n+    def _get_only_select_mask(self, opts, mask, select_mask=None):\n+        if select_mask is None:\n+            select_mask = {}\n+        # Only include fields present in the mask.\n+        for field_name, field_mask in mask.items():\n+            field = opts.get_field(field_name)\n+            field_select_mask = select_mask.setdefault(field, {})\n+            if field_mask:\n+                if not field.is_relation:\n+                    # Non-relational fields can't have nested masks.\n+                    raise FieldError(\n+                        \"Non-relational field %r cannot be used in select_related().\"\n+                        % field_name\n+                    )\n+                related_model = field.remote_field.model._meta.concrete_model._meta\n+                # For related fields, ensure we include the primary key and recursively\n+                # process the nested mask to restrict field selection\n+                related_select_mask = {}\n+                # Always include the primary key for related models\n+                pk_field = related_model.pk\n+                related_select_mask[pk_field] = {}\n+                # Recursively process the nested mask to include only specified fields\n+                self._get_only_select_mask(related_model, field_mask, related_select_mask)\n+                field_select_mask.update(related_select_mask)\n+        return select_mask\n \n     def get_distinct(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..b7b0d54b4f 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -784,32 +785,36 @@ class Query(BaseExpression):\n                 if not field.is_relation:\n                     raise FieldError(next(iter(field_mask)))\n                 related_model = field.remote_field.model._meta.concrete_model\n+                # Initialize the field_select_mask with primary key only for related model\n+                field_select_mask.setdefault(related_model._meta.pk, {})\n                 self._get_only_select_mask(\n                     related_model._meta, field_mask, field_select_mask\n                 )\n         return select_mask\n \n-    def get_select_mask(self):\n-        \"\"\"\n-        Convert the self.deferred_loading data structure to an alternate data\n-        structure, describing the field that *will* be loaded. This is used to\n-        compute the columns to select from the database and also by the\n-        QuerySet class to work out which fields are being initialized on each\n-        model. Models that have all their fields included aren't mentioned in\n-        the result, only those that have field restrictions in place.\n-        \"\"\"\n-        field_names, defer = self.deferred_loading\n-        if not field_names:\n-            return {}\n-        mask = {}\n-        for field_name in field_names:\n-            part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n-                part_mask = part_mask.setdefault(part, {})\n-        opts = self.get_meta()\n-        if defer:\n-            return self._get_defer_select_mask(opts, mask)\n-        return self._get_only_select_mask(opts, mask)\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    # Add the primary key to the mask.\n+    if opts.pk.attname not in mask:\n+        select_mask[opts.pk.attname] = {}\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            # Create a new select_mask for the related model that includes only\n+            # the primary key and the fields specified in field_mask\n+            related_select_mask = {}\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, related_select_mask\n+            )\n+            # Only assign the restricted mask to field_select_mask\n+            field_select_mask.update(related_select_mask)\n+    return select_mask\n \n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n@@ -2327,29 +2332,44 @@ class Query(BaseExpression):\n                 if new_only := set(field_names).difference(existing):\n                     self.deferred_loading = new_only, True\n \n-    def add_immediate_loading(self, field_names):\n-        \"\"\"\n-        Add the given list of model field names to the set of fields to\n-        retrieve when the SQL is executed (\"immediate loading\" fields). The\n-        field names replace any existing immediate loading field names. If\n-        there are field names already specified for deferred loading, remove\n-        those names from the new field_names before storing the new names\n-        for immediate loading. (That is, immediate loading overrides any\n-        existing immediate values, but respects existing deferrals.)\n-        \"\"\"\n-        existing, defer = self.deferred_loading\n-        field_names = set(field_names)\n-        if \"pk\" in field_names:\n-            field_names.remove(\"pk\")\n-            field_names.add(self.get_meta().pk.name)\n \n-        if defer:\n-            # Remove any existing deferred names from the current set before\n-            # setting the new names.\n-            self.deferred_loading = field_names.difference(existing), False\n+def _get_only_select_mask(self, field_mask, related_klass_infos):\n+    \"\"\"\n+    Apply a mask of only() field names to the columns in the select clause.\n+\n+    This is used to implement QuerySet.only(). Return a select_mask that\n+    will be used to prune the columns in the SELECT clause.\n+\n+    The field_mask is a dictionary that maps field names to nested\n+    dictionaries that recursively define the field names for related\n+    models that should be selected.\n+\n+    The related_klass_infos is a list of related model infos that are\n+    being selected via select_related().\n+    \"\"\"\n+    select_mask = {}\n+    for field_name, field_select_mask in field_mask.items():\n+        klass_info = related_klass_infos.get(field_name)\n+        if klass_info:\n+            # This field is a related field that we're selecting.\n+            # We need to recurse into the related field's select mask.\n+            if field_select_mask:\n+                # Only include the fields specified in the mask for the related model\n+                related_select_mask = self._get_only_select_mask(\n+                    field_select_mask, klass_info.related_klass_infos\n+                )\n+                # Add the primary key to ensure the join works correctly\n+                pk_name = klass_info.model._meta.pk.name\n+                related_select_mask[pk_name] = {}\n+                select_mask[field_name] = related_select_mask\n+            else:\n+                # No specific fields requested for this relation, include only pk\n+                pk_name = klass_info.model._meta.pk.name\n+                select_mask[field_name] = {pk_name: {}}\n         else:\n-            # Replace any existing \"immediate load\" field names.\n-            self.deferred_loading = frozenset(field_names), False\n+            # This is a regular field on the current model\n+            select_mask[field_name] = {}\n+    return select_mask\n \n     def set_annotation_mask(self, names):\n         \"\"\"Set the mask of annotations that will be returned by the SELECT.\"\"\"\n"
  }
}