{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/query_utils.py lines 64-66)": "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/query_utils.py lines 43-44)": "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
    "Location 3 (/root/hy/projects_1/django/django/db/models/expressions.py lines 92-95)": "\n    def __and__(self, other):\n        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n            return Q(self) & Q(other)\n        raise NotImplementedError(\n            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n        )\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
    "Location 4 (/root/hy/projects_1/django/django/db/models/expressions.py lines 139-142)": "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/query_utils.py lines 64-66)": [
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/query_utils.py lines 43-44)": [
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/models/expressions.py lines 92-95)": [
      "\n    def __and__(self, other):\n        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n            return Q(self) & Q(other)\n        raise NotImplementedError(\n            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n        )\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n            return Q(self) & Q(other)\n        raise NotImplementedError(\n            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n        )\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n            return Q(self) & Q(other)\n        raise NotImplementedError(\n            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n        )\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n            return Q(self) & Q(other)\n        raise NotImplementedError(\n            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n        )\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n            return Q(self) & Q(other)\n        raise NotImplementedError(\n            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n        )\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n            return Q(self) & Q(other)\n        raise NotImplementedError(\n            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n        )\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n            return Q(self) & Q(other)\n        raise NotImplementedError(\n            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n        )\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __and__(self, other):\n        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n            return Q(self) & Q(other)\n        raise NotImplementedError(\n            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n        )\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/models/expressions.py lines 139-142)": [
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..133c091989 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,12 +89,15 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\n         raise NotImplementedError(\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n \n     def bitand(self, other):\n         return self._combine(other, self.BITAND, False)\n@@ -136,6 +139,7 @@ class Combinable:\n     def __rpow__(self, other):\n         return self._combine(other, self.POW, True)\n \n+\n     def __rand__(self, other):\n         raise NotImplementedError(\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..417519522b 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,6 +40,7 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n+\n         if not isinstance(other, Q):\n             raise TypeError(other)\n \n@@ -61,9 +62,14 @@ class Q(tree.Node):\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n \n+\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n",
    "variant_0": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..fc2ea85162 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,6 +89,7 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\n@@ -96,6 +97,13 @@ class Combinable:\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n     def bitand(self, other):\n         return self._combine(other, self.BITAND, False)\n \n@@ -136,10 +144,11 @@ class Combinable:\n     def __rpow__(self, other):\n         return self._combine(other, self.POW, True)\n \n+\n     def __rand__(self, other):\n-        raise NotImplementedError(\n-            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n-        )\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n     def __ror__(self, other):\n         raise NotImplementedError(\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..e4f6926f8f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,8 +40,17 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n-            raise TypeError(other)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n@@ -61,9 +70,14 @@ class Q(tree.Node):\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n \n+\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n",
    "variant_1": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..fc2ea85162 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,6 +89,7 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\n@@ -96,6 +97,13 @@ class Combinable:\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n     def bitand(self, other):\n         return self._combine(other, self.BITAND, False)\n \n@@ -136,10 +144,11 @@ class Combinable:\n     def __rpow__(self, other):\n         return self._combine(other, self.POW, True)\n \n+\n     def __rand__(self, other):\n-        raise NotImplementedError(\n-            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n-        )\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n     def __ror__(self, other):\n         raise NotImplementedError(\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..d8ddbdd96a 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,8 +40,11 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n-            raise TypeError(other)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n@@ -61,9 +64,14 @@ class Q(tree.Node):\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n \n+\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n",
    "variant_2": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..fc2ea85162 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,6 +89,7 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\n@@ -96,6 +97,13 @@ class Combinable:\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n     def bitand(self, other):\n         return self._combine(other, self.BITAND, False)\n \n@@ -136,10 +144,11 @@ class Combinable:\n     def __rpow__(self, other):\n         return self._combine(other, self.POW, True)\n \n+\n     def __rand__(self, other):\n-        raise NotImplementedError(\n-            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n-        )\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n     def __ror__(self, other):\n         raise NotImplementedError(\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..e4f6926f8f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,8 +40,17 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n-            raise TypeError(other)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n@@ -61,9 +70,14 @@ class Q(tree.Node):\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n \n+\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n",
    "variant_3": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..fc2ea85162 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,6 +89,7 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\n@@ -96,6 +97,13 @@ class Combinable:\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n     def bitand(self, other):\n         return self._combine(other, self.BITAND, False)\n \n@@ -136,10 +144,11 @@ class Combinable:\n     def __rpow__(self, other):\n         return self._combine(other, self.POW, True)\n \n+\n     def __rand__(self, other):\n-        raise NotImplementedError(\n-            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n-        )\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n     def __ror__(self, other):\n         raise NotImplementedError(\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..e4f6926f8f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,8 +40,17 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n-            raise TypeError(other)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n@@ -61,9 +70,14 @@ class Q(tree.Node):\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n \n+\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n",
    "variant_4": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..fc2ea85162 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,6 +89,7 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\n@@ -96,6 +97,13 @@ class Combinable:\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n     def bitand(self, other):\n         return self._combine(other, self.BITAND, False)\n \n@@ -136,10 +144,11 @@ class Combinable:\n     def __rpow__(self, other):\n         return self._combine(other, self.POW, True)\n \n+\n     def __rand__(self, other):\n-        raise NotImplementedError(\n-            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n-        )\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n     def __ror__(self, other):\n         raise NotImplementedError(\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..d8ddbdd96a 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,8 +40,11 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n-            raise TypeError(other)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n@@ -61,9 +64,14 @@ class Q(tree.Node):\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n \n+\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n",
    "variant_5": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..fc2ea85162 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,6 +89,7 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\n@@ -96,6 +97,13 @@ class Combinable:\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n     def bitand(self, other):\n         return self._combine(other, self.BITAND, False)\n \n@@ -136,10 +144,11 @@ class Combinable:\n     def __rpow__(self, other):\n         return self._combine(other, self.POW, True)\n \n+\n     def __rand__(self, other):\n-        raise NotImplementedError(\n-            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n-        )\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n     def __ror__(self, other):\n         raise NotImplementedError(\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..e4f6926f8f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,8 +40,17 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n-            raise TypeError(other)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n@@ -61,9 +70,14 @@ class Q(tree.Node):\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n \n+\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n",
    "variant_6": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..fc2ea85162 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,6 +89,7 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\n@@ -96,6 +97,13 @@ class Combinable:\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n     def bitand(self, other):\n         return self._combine(other, self.BITAND, False)\n \n@@ -136,10 +144,11 @@ class Combinable:\n     def __rpow__(self, other):\n         return self._combine(other, self.POW, True)\n \n+\n     def __rand__(self, other):\n-        raise NotImplementedError(\n-            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n-        )\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n     def __ror__(self, other):\n         raise NotImplementedError(\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..e4f6926f8f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,8 +40,17 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n-            raise TypeError(other)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n@@ -61,9 +70,14 @@ class Q(tree.Node):\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n \n+\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n",
    "variant_7": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..fc2ea85162 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,6 +89,7 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\n@@ -96,6 +97,13 @@ class Combinable:\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n     def bitand(self, other):\n         return self._combine(other, self.BITAND, False)\n \n@@ -136,10 +144,11 @@ class Combinable:\n     def __rpow__(self, other):\n         return self._combine(other, self.POW, True)\n \n+\n     def __rand__(self, other):\n-        raise NotImplementedError(\n-            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n-        )\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n     def __ror__(self, other):\n         raise NotImplementedError(\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..e4f6926f8f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,8 +40,17 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n-            raise TypeError(other)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n@@ -61,9 +70,14 @@ class Q(tree.Node):\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n \n+\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n",
    "variant_8": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..fc2ea85162 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,6 +89,7 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\n@@ -96,6 +97,13 @@ class Combinable:\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n     def bitand(self, other):\n         return self._combine(other, self.BITAND, False)\n \n@@ -136,10 +144,11 @@ class Combinable:\n     def __rpow__(self, other):\n         return self._combine(other, self.POW, True)\n \n+\n     def __rand__(self, other):\n-        raise NotImplementedError(\n-            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n-        )\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n \n     def __ror__(self, other):\n         raise NotImplementedError(\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..e4f6926f8f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,8 +40,17 @@ class Q(tree.Node):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n-            raise TypeError(other)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n \n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n@@ -61,9 +70,14 @@ class Q(tree.Node):\n     def __or__(self, other):\n         return self._combine(other, self.OR)\n \n+\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\n"
  }
}