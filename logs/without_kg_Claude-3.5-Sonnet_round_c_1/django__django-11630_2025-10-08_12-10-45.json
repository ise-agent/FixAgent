{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/core/checks/model_checks.py lines 38-47)": "\n    # Group models by (db_table, database) instead of just db_table\n    from django.db import router\n    \n    db_table_models = defaultdict(list)\n    indexes = defaultdict(list)\n    constraints = defaultdict(list)\n    for model in apps.get_models():\n        if model._meta.managed and not model._meta.proxy:\n            db_table = model._meta.db_table\n            database = router.db_for_write(model)\n            db_table_models[(db_table, database)].append(model._meta.label)\n        if not inspect.ismethod(model.check):\n            errors.append(\n                Error(\n                    \"The '%s.check()' class method is currently overridden by %r.\"\n                    % (model.__name__, model.check),\n                    obj=model,\n                    id='models.E020'\n                )\n            )\n        else:\n            errors.extend(model.check(**kwargs))\n        for model_index in model._meta.indexes:\n            indexes[model_index.name].append(model._meta.label)\n        for model_constraint in model._meta.constraints:\n            constraints[model_constraint.name].append(model._meta.label)\n    for (db_table, database), model_labels in db_table_models.items():\n        if len(model_labels) != 1:\n            errors.append(\n                Error(\n                    \"db_table '%s' is used by multiple models: %s.\"\n                    % (db_table, ', '.join(model_labels)),\n                    obj=db_table,\n                    id='models.E028',\n                )\n            )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/core/checks/model_checks.py lines 38-47)": [
      "\n    # Group models by (db_table, database) instead of just db_table\n    from django.db import router\n    \n    db_table_database_models = defaultdict(list)\n    for model in all_models:\n        if not inspect.isclass(model):\n            continue\n        if model._meta.managed and not model._meta.proxy:\n            db_name = router.db_for_write(model)\n            db_table_database_models[(model._meta.db_table, db_name)].append(model._meta.label)\n        try:\n            errors.extend(model.check(**kwargs))\n        except AttributeError:\n            errors.append(\n                Error(\n                    \"The '%s' model has been swapped out for '%s' \"\n                    \"which has not been installed or is abstract.\" % (\n                        model.__name__, model._meta.swapped\n                    ),\n                    obj=model,\n                    id='models.E020'\n                )\n            )\n        else:\n            errors.extend(model.check(**kwargs))\n        for model_index in model._meta.indexes:\n            indexes[model_index.name].append(model._meta.label)\n        for model_constraint in model._meta.constraints:\n            constraints[model_constraint.name].append(model._meta.label)\n    \n    # Check for duplicate table names within the same database\n    for (db_table, db_name), model_labels in db_table_database_models.items():\n        if len(model_labels) != 1:\n            errors.append(\n                Error(\n                    \"db_table '%s' is used by multiple models: %s.\"\n                    % (db_table, ', '.join(model_labels)),\n                    obj=db_table,\n                    id='models.E028',\n                )\n            )\n",
      "\n    # Group models by (db_table, database) instead of just db_table\n    from django.db import router\n    \n    db_table_database_models = defaultdict(list)\n    for model in all_models:\n        if not inspect.isclass(model) or not hasattr(model, '_meta'):\n            errors.append(\n                Error(\n                    \"All 'models' must be a model class, received %r.\"\n                    % model,\n                    obj=model,\n                    id='models.E020'\n                )\n            )\n        else:\n            errors.extend(model.check(**kwargs))\n        \n        # Get the database for this model using router\n        db_name = router.db_for_write(model)\n        db_table = model._meta.db_table\n        db_table_database_models[(db_table, db_name)].append(model._meta.label)\n        \n        for model_index in model._meta.indexes:\n            indexes[model_index.name].append(model._meta.label)\n        for model_constraint in model._meta.constraints:\n            constraints[model_constraint.name].append(model._meta.label)\n    \n    # Check for duplicate table names only within the same database\n    for (db_table, db_name), model_labels in db_table_database_models.items():\n        if len(model_labels) != 1:\n            errors.append(\n                Error(\n                    \"db_table '%s' is used by multiple models: %s.\"\n                    % (db_table, ', '.join(model_labels)),\n                    obj=db_table,\n                    id='models.E028',\n                )\n            )\n",
      "\nfrom django.db import router\n\n# ... existing code ...\n\n    db_table_models = defaultdict(list)\n    indexes = defaultdict(list)\n    constraints = defaultdict(list)\n    for model in all_models:\n        if model._meta.managed and not model._meta.proxy:\n            db_table = model._meta.db_table\n            database = router.db_for_write(model)\n            db_table_models[(db_table, database)].append(model._meta.label)\n        if not inspect.ismethod(model.check):\n            errors.append(\n                Error(\n                    \"The '%s.check()' class method is currently overridden by %r.\"\n                    % (model.__name__, model.check),\n                    obj=model,\n                    id='models.E020'\n                )\n            )\n        else:\n            errors.extend(model.check(**kwargs))\n        for model_index in model._meta.indexes:\n            indexes[model_index.name].append(model._meta.label)\n        for model_constraint in model._meta.constraints:\n            constraints[model_constraint.name].append(model._meta.label)\n    for (db_table, database), model_labels in db_table_models.items():\n        if len(model_labels) != 1:\n            errors.append(\n                Error(\n                    \"db_table '%s' is used by multiple models: %s.\"\n                    % (db_table, ', '.join(model_labels)),\n                    obj=db_table,\n                    id='models.E028',\n                )\n            )\n",
      "\n    # Group models by (db_table, database) instead of just db_table\n    from django.db import router\n    \n    db_table_models = defaultdict(list)\n    for model in all_models:\n        if not model._meta.managed or model._meta.proxy:\n            continue\n        db_table = model._meta.db_table\n        database = router.db_for_write(model)\n        db_table_models[(db_table, database)].append(model._meta.label)\n    \n    # Check for duplicate table names within the same database\n    for (db_table, database), model_labels in db_table_models.items():\n        if len(model_labels) > 1:\n            errors.append(\n                Error(\n                    \"db_table '%s' is used by multiple models: %s.\"\n                    % (db_table, ', '.join(model_labels)),\n                    obj=db_table,\n                    id='models.E028',\n                )\n            )\n",
      "\n    # Group models by (db_table, database) tuple instead of just db_table\n    from django.db import router\n    \n    db_table_database_models = defaultdict(list)\n    for model in all_models:\n        if not inspect.isclass(model) or not hasattr(model, '_meta'):\n            continue\n        if model._meta.managed and not model._meta.proxy:\n            db_name = router.db_for_write(model)\n            db_table_database_models[(model._meta.db_table, db_name)].append(model._meta.label)\n    \n    for (db_table, db_name), model_labels in db_table_database_models.items():\n        if len(model_labels) != 1:\n            errors.append(\n                Error(\n                    \"db_table '%s' is used by multiple models in database '%s': %s.\"\n                    % (db_table, db_name, ', '.join(model_labels)),\n                    obj=db_table,\n                    id='models.E028',\n                )\n            )\n",
      "\n    # Group models by both db_table and database to avoid false positives\n    # when models use the same table name but different databases\n    from django.db import router\n    \n    db_table_database_models = defaultdict(list)\n    for model in all_models:\n        if not inspect.isclass(model) or not model._meta.managed or model._meta.proxy:\n            continue\n        if model._meta.swapped:\n            errors.append(\n                Error(\n                    \"%s has been swapped out for '%s' which has not been \"\n                    \"installed or is abstract.\" % (\n                        model._meta.label, model._meta.swapped\n                    ),\n                    obj=model,\n                    id='models.E020'\n                )\n            )\n        else:\n            errors.extend(model.check(**kwargs))\n        \n        # Get the database for this model\n        db_for_model = router.db_for_write(model)\n        db_table_database_key = (model._meta.db_table, db_for_model)\n        db_table_database_models[db_table_database_key].append(model._meta.label)\n        \n        for model_index in model._meta.indexes:\n            indexes[model_index.name].append(model._meta.label)\n        for model_constraint in model._meta.constraints:\n            constraints[model_constraint.name].append(model._meta.label)\n    \n    # Check for duplicate table names within the same database\n    for (db_table, database), model_labels in db_table_database_models.items():\n        if len(model_labels) != 1:\n            errors.append(\n                Error(\n                    \"db_table '%s' is used by multiple models: %s.\"\n                    % (db_table, ', '.join(model_labels)),\n                    obj=db_table,\n                    id='models.E028',\n                )\n            )\n",
      "\n    # Group models by (db_table, database) instead of just db_table\n    from django.db import router\n    \n    db_table_database_models = defaultdict(list)\n    for model in all_models:\n        if not inspect.isclass(model) or not model._meta.managed or model._meta.proxy:\n            continue\n        if model._meta.swapped:\n            errors.append(\n                Error(\n                    \"%s has been swapped out for '%s' which has not been installed or is abstract.\" % (\n                        model._meta.label, model._meta.swapped\n                    ),\n                    obj=model,\n                    id='models.E021'\n                )\n            )\n        if model._meta.db_table:\n            database = router.db_for_write(model)\n            db_table_database_models[(model._meta.db_table, database)].append(model._meta.label)\n        else:\n            errors.extend(model.check(**kwargs))\n        for model_index in model._meta.indexes:\n            indexes[model_index.name].append(model._meta.label)\n        for model_constraint in model._meta.constraints:\n            constraints[model_constraint.name].append(model._meta.label)\n    \n    for (db_table, database), model_labels in db_table_database_models.items():\n        if len(model_labels) != 1:\n            errors.append(\n                Error(\n                    \"db_table '%s' is used by multiple models: %s.\"\n                    % (db_table, ', '.join(model_labels)),\n                    obj=db_table,\n                    id='models.E028',\n                )\n            )\n",
      "\n    # Group models by (db_table, database) tuple instead of just db_table\n    from django.db import router\n    \n    db_table_database_models = defaultdict(list)\n    for model in all_models:\n        if not model._meta.managed or model._meta.proxy:\n            continue\n        if model._meta.swapped:\n            continue\n        # Get the database this model writes to\n        database = router.db_for_write(model)\n        db_table_database_models[(model._meta.db_table, database)].append(model._meta.label)\n    \n    # Check for duplicate table names within the same database\n    for (db_table, database), model_labels in db_table_database_models.items():\n        if len(model_labels) > 1:\n            errors.append(\n                Error(\n                    \"db_table '%s' is used by multiple models: %s.\"\n                    % (db_table, ', '.join(model_labels)),\n                    obj=db_table,\n                    id='models.E028',\n                )\n            )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..6d463ca9cc 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -35,16 +35,44 @@ def check_all_models(app_configs=None, **kwargs):\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n+\n+    # Group models by database and table name to only flag conflicts within the same database\n+    from django.db import router\n+    \n+    # Reorganize db_table_models to group by (database, table_name)\n+    db_conflicts = defaultdict(lambda: defaultdict(list))\n+    \n+    # Re-examine the collected models and group them by database\n     for db_table, model_labels in db_table_models.items():\n-        if len(model_labels) != 1:\n-            errors.append(\n-                Error(\n-                    \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n-                    obj=db_table,\n-                    id='models.E028',\n+        if len(model_labels) > 1:\n+            # Get the actual model classes to determine their databases\n+            models_for_table = []\n+            for model_label in model_labels:\n+                try:\n+                    app_label, model_name = model_label.split('.')\n+                    model_class = apps.get_model(app_label, model_name)\n+                    models_for_table.append((model_class, model_label))\n+                except (ValueError, LookupError):\n+                    # If we can't find the model, skip it\n+                    continue\n+            \n+            # Group by database\n+            for model_class, model_label in models_for_table:\n+                database = router.db_for_write(model_class)\n+                db_conflicts[database][db_table].append(model_label)\n+    \n+    # Only flag conflicts when multiple models use the same database and table\n+    for database, tables in db_conflicts.items():\n+        for db_table, model_labels in tables.items():\n+            if len(model_labels) > 1:\n+                errors.append(\n+                    Error(\n+                        \"db_table '%s' is used by multiple models: %s.\"\n+                        % (db_table, ', '.join(model_labels)),\n+                        obj=db_table,\n+                        id='models.E028',\n+                    )\n                 )\n-            )\n     for index_name, model_labels in indexes.items():\n         if len(model_labels) > 1:\n             model_labels = set(model_labels)\n",
    "variant_0": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..623a9aab9e 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -35,12 +35,39 @@ def check_all_models(app_configs=None, **kwargs):\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n-    for db_table, model_labels in db_table_models.items():\n+\n+    # Group models by (db_table, database) instead of just db_table\n+    from django.db import router\n+    \n+    db_table_models = defaultdict(list)\n+    indexes = defaultdict(list)\n+    constraints = defaultdict(list)\n+    for model in apps.get_models():\n+        if model._meta.managed and not model._meta.proxy:\n+            db_table = model._meta.db_table\n+            database = router.db_for_write(model)\n+            db_table_models[(db_table, database)].append(model._meta.label)\n+        if not inspect.ismethod(model.check):\n+            errors.append(\n+                Error(\n+                    \"The '%s.check()' class method is currently overridden by %r.\"\n+                    % (model.__name__, model.check),\n+                    obj=model,\n+                    id='models.E020'\n+                )\n+            )\n+        else:\n+            errors.extend(model.check(**kwargs))\n+        for model_index in model._meta.indexes:\n+            indexes[model_index.name].append(model._meta.label)\n+        for model_constraint in model._meta.constraints:\n+            constraints[model_constraint.name].append(model._meta.label)\n+    for (db_table, database), model_labels in db_table_models.items():\n         if len(model_labels) != 1:\n             errors.append(\n                 Error(\n                     \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n+                    % (db_table, ', '.join(model_labels)),\n                     obj=db_table,\n                     id='models.E028',\n                 )\n",
    "variant_1": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..8cddc683e1 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -35,12 +35,44 @@ def check_all_models(app_configs=None, **kwargs):\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n-    for db_table, model_labels in db_table_models.items():\n+\n+    # Group models by (db_table, database) instead of just db_table\n+    from django.db import router\n+    \n+    db_table_database_models = defaultdict(list)\n+    for model in all_models:\n+        if not inspect.isclass(model):\n+            continue\n+        if model._meta.managed and not model._meta.proxy:\n+            db_name = router.db_for_write(model)\n+            db_table_database_models[(model._meta.db_table, db_name)].append(model._meta.label)\n+        try:\n+            errors.extend(model.check(**kwargs))\n+        except AttributeError:\n+            errors.append(\n+                Error(\n+                    \"The '%s' model has been swapped out for '%s' \"\n+                    \"which has not been installed or is abstract.\" % (\n+                        model.__name__, model._meta.swapped\n+                    ),\n+                    obj=model,\n+                    id='models.E020'\n+                )\n+            )\n+        else:\n+            errors.extend(model.check(**kwargs))\n+        for model_index in model._meta.indexes:\n+            indexes[model_index.name].append(model._meta.label)\n+        for model_constraint in model._meta.constraints:\n+            constraints[model_constraint.name].append(model._meta.label)\n+    \n+    # Check for duplicate table names within the same database\n+    for (db_table, db_name), model_labels in db_table_database_models.items():\n         if len(model_labels) != 1:\n             errors.append(\n                 Error(\n                     \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n+                    % (db_table, ', '.join(model_labels)),\n                     obj=db_table,\n                     id='models.E028',\n                 )\n",
    "variant_2": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..0a07ca3d51 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -35,12 +35,41 @@ def check_all_models(app_configs=None, **kwargs):\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n-    for db_table, model_labels in db_table_models.items():\n+\n+    # Group models by (db_table, database) instead of just db_table\n+    from django.db import router\n+    \n+    db_table_database_models = defaultdict(list)\n+    for model in all_models:\n+        if not inspect.isclass(model) or not hasattr(model, '_meta'):\n+            errors.append(\n+                Error(\n+                    \"All 'models' must be a model class, received %r.\"\n+                    % model,\n+                    obj=model,\n+                    id='models.E020'\n+                )\n+            )\n+        else:\n+            errors.extend(model.check(**kwargs))\n+        \n+        # Get the database for this model using router\n+        db_name = router.db_for_write(model)\n+        db_table = model._meta.db_table\n+        db_table_database_models[(db_table, db_name)].append(model._meta.label)\n+        \n+        for model_index in model._meta.indexes:\n+            indexes[model_index.name].append(model._meta.label)\n+        for model_constraint in model._meta.constraints:\n+            constraints[model_constraint.name].append(model._meta.label)\n+    \n+    # Check for duplicate table names only within the same database\n+    for (db_table, db_name), model_labels in db_table_database_models.items():\n         if len(model_labels) != 1:\n             errors.append(\n                 Error(\n                     \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n+                    % (db_table, ', '.join(model_labels)),\n                     obj=db_table,\n                     id='models.E028',\n                 )\n",
    "variant_3": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..2e22a09267 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -35,12 +35,40 @@ def check_all_models(app_configs=None, **kwargs):\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n-    for db_table, model_labels in db_table_models.items():\n+\n+from django.db import router\n+\n+# ... existing code ...\n+\n+    db_table_models = defaultdict(list)\n+    indexes = defaultdict(list)\n+    constraints = defaultdict(list)\n+    for model in all_models:\n+        if model._meta.managed and not model._meta.proxy:\n+            db_table = model._meta.db_table\n+            database = router.db_for_write(model)\n+            db_table_models[(db_table, database)].append(model._meta.label)\n+        if not inspect.ismethod(model.check):\n+            errors.append(\n+                Error(\n+                    \"The '%s.check()' class method is currently overridden by %r.\"\n+                    % (model.__name__, model.check),\n+                    obj=model,\n+                    id='models.E020'\n+                )\n+            )\n+        else:\n+            errors.extend(model.check(**kwargs))\n+        for model_index in model._meta.indexes:\n+            indexes[model_index.name].append(model._meta.label)\n+        for model_constraint in model._meta.constraints:\n+            constraints[model_constraint.name].append(model._meta.label)\n+    for (db_table, database), model_labels in db_table_models.items():\n         if len(model_labels) != 1:\n             errors.append(\n                 Error(\n                     \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n+                    % (db_table, ', '.join(model_labels)),\n                     obj=db_table,\n                     id='models.E028',\n                 )\n",
    "variant_4": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..bcbcc2d4ab 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -35,12 +35,25 @@ def check_all_models(app_configs=None, **kwargs):\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n-    for db_table, model_labels in db_table_models.items():\n-        if len(model_labels) != 1:\n+\n+    # Group models by (db_table, database) instead of just db_table\n+    from django.db import router\n+    \n+    db_table_models = defaultdict(list)\n+    for model in all_models:\n+        if not model._meta.managed or model._meta.proxy:\n+            continue\n+        db_table = model._meta.db_table\n+        database = router.db_for_write(model)\n+        db_table_models[(db_table, database)].append(model._meta.label)\n+    \n+    # Check for duplicate table names within the same database\n+    for (db_table, database), model_labels in db_table_models.items():\n+        if len(model_labels) > 1:\n             errors.append(\n                 Error(\n                     \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n+                    % (db_table, ', '.join(model_labels)),\n                     obj=db_table,\n                     id='models.E028',\n                 )\n",
    "variant_5": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..bce683f60f 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -35,12 +35,24 @@ def check_all_models(app_configs=None, **kwargs):\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n-    for db_table, model_labels in db_table_models.items():\n+\n+    # Group models by (db_table, database) tuple instead of just db_table\n+    from django.db import router\n+    \n+    db_table_database_models = defaultdict(list)\n+    for model in all_models:\n+        if not inspect.isclass(model) or not hasattr(model, '_meta'):\n+            continue\n+        if model._meta.managed and not model._meta.proxy:\n+            db_name = router.db_for_write(model)\n+            db_table_database_models[(model._meta.db_table, db_name)].append(model._meta.label)\n+    \n+    for (db_table, db_name), model_labels in db_table_database_models.items():\n         if len(model_labels) != 1:\n             errors.append(\n                 Error(\n-                    \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n+                    \"db_table '%s' is used by multiple models in database '%s': %s.\"\n+                    % (db_table, db_name, ', '.join(model_labels)),\n                     obj=db_table,\n                     id='models.E028',\n                 )\n",
    "variant_6": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..560266923f 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -35,12 +35,46 @@ def check_all_models(app_configs=None, **kwargs):\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n-    for db_table, model_labels in db_table_models.items():\n+\n+    # Group models by both db_table and database to avoid false positives\n+    # when models use the same table name but different databases\n+    from django.db import router\n+    \n+    db_table_database_models = defaultdict(list)\n+    for model in all_models:\n+        if not inspect.isclass(model) or not model._meta.managed or model._meta.proxy:\n+            continue\n+        if model._meta.swapped:\n+            errors.append(\n+                Error(\n+                    \"%s has been swapped out for '%s' which has not been \"\n+                    \"installed or is abstract.\" % (\n+                        model._meta.label, model._meta.swapped\n+                    ),\n+                    obj=model,\n+                    id='models.E020'\n+                )\n+            )\n+        else:\n+            errors.extend(model.check(**kwargs))\n+        \n+        # Get the database for this model\n+        db_for_model = router.db_for_write(model)\n+        db_table_database_key = (model._meta.db_table, db_for_model)\n+        db_table_database_models[db_table_database_key].append(model._meta.label)\n+        \n+        for model_index in model._meta.indexes:\n+            indexes[model_index.name].append(model._meta.label)\n+        for model_constraint in model._meta.constraints:\n+            constraints[model_constraint.name].append(model._meta.label)\n+    \n+    # Check for duplicate table names within the same database\n+    for (db_table, database), model_labels in db_table_database_models.items():\n         if len(model_labels) != 1:\n             errors.append(\n                 Error(\n                     \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n+                    % (db_table, ', '.join(model_labels)),\n                     obj=db_table,\n                     id='models.E028',\n                 )\n",
    "variant_7": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..e3a8fbbc14 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -35,12 +35,40 @@ def check_all_models(app_configs=None, **kwargs):\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n-    for db_table, model_labels in db_table_models.items():\n+\n+    # Group models by (db_table, database) instead of just db_table\n+    from django.db import router\n+    \n+    db_table_database_models = defaultdict(list)\n+    for model in all_models:\n+        if not inspect.isclass(model) or not model._meta.managed or model._meta.proxy:\n+            continue\n+        if model._meta.swapped:\n+            errors.append(\n+                Error(\n+                    \"%s has been swapped out for '%s' which has not been installed or is abstract.\" % (\n+                        model._meta.label, model._meta.swapped\n+                    ),\n+                    obj=model,\n+                    id='models.E021'\n+                )\n+            )\n+        if model._meta.db_table:\n+            database = router.db_for_write(model)\n+            db_table_database_models[(model._meta.db_table, database)].append(model._meta.label)\n+        else:\n+            errors.extend(model.check(**kwargs))\n+        for model_index in model._meta.indexes:\n+            indexes[model_index.name].append(model._meta.label)\n+        for model_constraint in model._meta.constraints:\n+            constraints[model_constraint.name].append(model._meta.label)\n+    \n+    for (db_table, database), model_labels in db_table_database_models.items():\n         if len(model_labels) != 1:\n             errors.append(\n                 Error(\n                     \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n+                    % (db_table, ', '.join(model_labels)),\n                     obj=db_table,\n                     id='models.E028',\n                 )\n",
    "variant_8": "diff --git a/django/core/checks/model_checks.py b/django/core/checks/model_checks.py\nindex 5c2266ca1d..1c92546c42 100644\n--- a/django/core/checks/model_checks.py\n+++ b/django/core/checks/model_checks.py\n@@ -35,12 +35,27 @@ def check_all_models(app_configs=None, **kwargs):\n             indexes[model_index.name].append(model._meta.label)\n         for model_constraint in model._meta.constraints:\n             constraints[model_constraint.name].append(model._meta.label)\n-    for db_table, model_labels in db_table_models.items():\n-        if len(model_labels) != 1:\n+\n+    # Group models by (db_table, database) tuple instead of just db_table\n+    from django.db import router\n+    \n+    db_table_database_models = defaultdict(list)\n+    for model in all_models:\n+        if not model._meta.managed or model._meta.proxy:\n+            continue\n+        if model._meta.swapped:\n+            continue\n+        # Get the database this model writes to\n+        database = router.db_for_write(model)\n+        db_table_database_models[(model._meta.db_table, database)].append(model._meta.label)\n+    \n+    # Check for duplicate table names within the same database\n+    for (db_table, database), model_labels in db_table_database_models.items():\n+        if len(model_labels) > 1:\n             errors.append(\n                 Error(\n                     \"db_table '%s' is used by multiple models: %s.\"\n-                    % (db_table, ', '.join(db_table_models[db_table])),\n+                    % (db_table, ', '.join(model_labels)),\n                     obj=db_table,\n                     id='models.E028',\n                 )\n"
  }
}