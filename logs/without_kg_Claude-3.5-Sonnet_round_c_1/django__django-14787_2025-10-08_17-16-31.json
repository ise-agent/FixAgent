{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/utils/decorators.py lines 40-40)": "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in the order they appear in the iterable.\n        decorators = tuple(decorators)\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of using partial\n        # This ensures decorators that use @wraps can access function attributes\n        def bound_method(*args, **kwargs):\n            return method.__get__(self, type(self))(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', '<lambda>')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__qualname__ = getattr(method, '__qualname__', None)\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
    "Location 2 (/root/hy/projects_1/django/django/utils/decorators.py lines 35-43)": "\ndef _wrapper(self, *args, **kwargs):\n    # bound_method has the signature that 'decorator' expects i.e. no\n    # 'self' argument, but it's a closure over self so it can call\n    # 'func'. Also, wrap method.__get__() in a function because new\n    # attributes can't be set on bound method objects, only on functions.\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy essential attributes from the original method\n    bound_method.__name__ = getattr(method, '__name__', '')\n    bound_method.__module__ = getattr(method, '__module__', '')\n    bound_method.__doc__ = getattr(method, '__doc__', '')\n    bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    bound_method.__qualname__ = getattr(method, '__qualname__', '')\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
    "Location 3 (/root/hy/projects_1/django/django/utils/decorators.py lines 13-21)": "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Apply decorator to a dummy function to get the proper attributes\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    # Copy all relevant attributes from the decorated dummy to the wrapper\n    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n        try:\n            value = getattr(dummy, attr)\n            setattr(_wrapper, attr, value)\n        except AttributeError:\n            pass\n    # Copy __dict__ if it exists\n    if hasattr(dummy, '__dict__'):\n        _wrapper.__dict__.update(getattr(dummy, '__dict__', {}))\n\n\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of using partial\n        def bound_method(*args, **kwargs):\n            return method.__get__(self, type(self))(*args, **kwargs)\n        \n        # Copy essential attributes from the original method to make it decorator-friendly\n        for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n            try:\n                value = getattr(method, attr)\n                setattr(bound_method, attr, value)\n            except AttributeError:\n                pass\n        \n        # Apply decorators to the bound method\n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy over any function attributes from the original method\n    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n        try:\n            value = getattr(method, attr)\n            setattr(_wrapper, attr, value)\n        except AttributeError:\n            pass\n    _wrapper.__dict__.update(getattr(method, '__dict__', {}))\n    _wrapper.__wrapped__ = method\n    \n    # Update wrapper attributes for each decorator\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    return _wrapper\n",
    "Location 4 (/root/hy/projects_1/django/django/utils/decorators.py lines 46-47)": "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they're applied in the order\n        # they appear in the list.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, create a proper function wrapper instead of partial\n        # so it has the attributes decorators expect.\n        bound_method = method.__get__(self, type(self))\n        \n        def wrapper_func(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential function attributes that decorators expect\n        try:\n            wrapper_func.__name__ = method.__name__\n        except AttributeError:\n            pass\n        try:\n            wrapper_func.__module__ = method.__module__\n        except AttributeError:\n            pass\n        try:\n            wrapper_func.__doc__ = method.__doc__\n        except AttributeError:\n            pass\n        try:\n            wrapper_func.__annotations__ = method.__annotations__\n        except AttributeError:\n            pass\n        try:\n            wrapper_func.__qualname__ = method.__qualname__\n        except AttributeError:\n            pass\n            \n        for dec in decorators:\n            wrapper_func = dec(wrapper_func)\n        return wrapper_func(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
    "Location 5 (/root/hy/projects_1/django/django/utils/decorators.py lines 22-50)": "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of using partial directly\n        # This ensures decorators using @wraps can access function attributes\n        bound_method = method.__get__(self, type(self))\n        \n        def bound_func(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        bound_func.__name__ = getattr(method, '__name__', 'bound_method')\n        bound_func.__doc__ = getattr(method, '__doc__', None)\n        bound_func.__module__ = getattr(method, '__module__', None)\n        bound_func.__qualname__ = getattr(method, '__qualname__', None)\n        bound_func.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_func = dec(bound_func)\n        return bound_func(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/utils/decorators.py lines 40-40)": [
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in the order they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of using partial\n        # This ensures decorators using @wraps can access __name__, __module__, etc.\n        def bound_method(*args, **kwargs):\n            return method(self, *args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # bound_method has the signature that 'decorator' expects i.e. no\n    # 'self' argument, but it's a closure over self so it can call\n    # 'func'. Also, wrap method.__get__() in a function because new\n    # attributes can't be set on bound method objects, only on functions.\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy function attributes from the original method\n    bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__dict__.update(getattr(method, '__dict__', {}))\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # bound_method has the signature that 'decorator' expects i.e. no\n    # 'self' argument, but it's a closure over self so it can call\n    # 'func'. Also, wrap method.__get__() in a function because new\n    # attributes can't be set on bound method objects, only on functions.\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy function attributes from the original method to make it decorator-friendly\n    bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in the order they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of using partial\n        # This ensures decorators using @wraps can access __name__, __module__, etc.\n        def bound_method(*method_args, **method_kwargs):\n            return method.__get__(self, type(self))(*method_args, **method_kwargs)\n        \n        # Copy essential attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', 'method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # bound_method has the signature that 'decorator' expects i.e. no\n    # 'self' argument, but it's a closure over self so it can call\n    # 'func'. Also, wrap method.__get__() in a function because new\n    # attributes can't be set on bound method objects, only on functions.\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy essential function attributes from the original method\n    bound_method.__name__ = getattr(method, '__name__', '<lambda>')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in the order they appear in the iterable.\n        decorators = tuple(decorators)\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of partial\n        def bound_method(*args, **kwargs):\n            return method(self, *args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', '<method>')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', None)\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # bound_method has the signature that 'decorator' expects i.e. no\n    # 'self' argument, but it's a closure over self so it can call\n    # 'func'. Create a proper function wrapper instead of partial to\n    # ensure decorators using @wraps can access function attributes.\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy essential function attributes from the original method\n    bound_method.__name__ = getattr(method, '__name__', 'method')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # bound_method has the signature that 'decorator' expects i.e. no\n    # 'self' argument, but it's a closure over self so it can call\n    # 'func'. Also, wrap method.__get__() in a function because new\n    # attributes can't be set on bound method objects, only on functions.\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy function attributes from the original method to make it decorator-friendly\n    try:\n        bound_method.__name__ = method.__name__\n    except AttributeError:\n        pass\n    try:\n        bound_method.__module__ = method.__module__\n    except AttributeError:\n        pass\n    try:\n        bound_method.__qualname__ = method.__qualname__\n    except AttributeError:\n        pass\n    try:\n        bound_method.__doc__ = method.__doc__\n    except AttributeError:\n        pass\n    try:\n        bound_method.__annotations__ = method.__annotations__\n    except AttributeError:\n        pass\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/utils/decorators.py lines 35-43)": [
      "\ndef _wrapper(self, *args, **kwargs):\n    # bound_method has the signature that 'decorator' expects i.e. no\n    # 'self' argument, but it's a closure over self so it can call\n    # 'func'. Also, wrap method.__get__() in a function because new\n    # attributes can't be set on bound method objects, only on functions.\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy essential attributes from the original method to make it decorator-friendly\n    bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    bound_method.__qualname__ = getattr(method, '__qualname__', 'bound_method')\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # Create a proper function wrapper instead of using partial directly\n    # This ensures decorators using @wraps can access function attributes\n    bound_method = method.__get__(self, type(self))\n    \n    def wrapper_func(*args, **kwargs):\n        return bound_method(*args, **kwargs)\n    \n    # Copy essential function attributes from the original method\n    wrapper_func.__name__ = getattr(method, '__name__', '<lambda>')\n    wrapper_func.__module__ = getattr(method, '__module__', None)\n    wrapper_func.__doc__ = getattr(method, '__doc__', None)\n    wrapper_func.__annotations__ = getattr(method, '__annotations__', {})\n    wrapper_func.__qualname__ = getattr(method, '__qualname__', wrapper_func.__name__)\n    \n    # Apply decorators to the function wrapper\n    for dec in decorators:\n        wrapper_func = dec(wrapper_func)\n    return wrapper_func(*args, **kwargs)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # bound_method has the signature that 'decorator' expects i.e. no\n    # 'self' argument, but it's a closure over self so it can call\n    # 'func'. Create a proper function wrapper instead of partial\n    # to ensure decorators using @wraps can access function attributes.\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy essential function attributes from the original method\n    bound_method.__name__ = getattr(method, '__name__', 'method')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    bound_method.__qualname__ = getattr(method, '__qualname__', None)\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of using partial directly\n        # This ensures decorators using @wraps can access function attributes\n        bound_method = method.__get__(self, type(self))\n        \n        def method_wrapper(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        method_wrapper.__name__ = getattr(method, '__name__', '<unknown>')\n        method_wrapper.__module__ = getattr(method, '__module__', None)\n        method_wrapper.__doc__ = getattr(method, '__doc__', None)\n        method_wrapper.__dict__ = getattr(method, '__dict__', {}).copy()\n        method_wrapper.__annotations__ = getattr(method, '__annotations__', {})\n        \n        # Apply decorators to the proper function wrapper\n        for dec in decorators:\n            method_wrapper = dec(method_wrapper)\n        return method_wrapper(*args, **kwargs)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # Create a proper function wrapper instead of using partial directly\n    # This ensures decorators using @wraps can access function attributes\n    def bound_method(*inner_args, **inner_kwargs):\n        return method.__get__(self, type(self))(*inner_args, **inner_kwargs)\n    \n    # Copy essential attributes from the original method\n    bound_method.__name__ = getattr(method, '__name__', 'method')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__dict__.update(getattr(method, '__dict__', {}))\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # bound_method has the signature that 'decorator' expects i.e. no\n    # 'self' argument, but it's a closure over self so it can call\n    # 'func'. Create a proper function wrapper instead of partial\n    # to ensure decorators using @wraps can access function attributes.\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy essential attributes from the original method\n    bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__dict__.update(getattr(method, '__dict__', {}))\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # Create a proper function wrapper instead of using partial\n    # This ensures decorators using @wraps can access function attributes\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy essential attributes from the original method\n    bound_method.__name__ = getattr(method, '__name__', 'decorated_method')\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__qualname__ = getattr(method, '__qualname__', None)\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # Create a proper function wrapper instead of using partial\n    # This ensures decorators using @wraps can access function attributes\n    bound_method = method.__get__(self, type(self))\n    \n    def wrapper_func(*args, **kwargs):\n        return bound_method(*args, **kwargs)\n    \n    # Copy essential attributes from the original method\n    wrapper_func.__name__ = getattr(method, '__name__', 'method')\n    wrapper_func.__module__ = getattr(method, '__module__', None)\n    wrapper_func.__doc__ = getattr(method, '__doc__', None)\n    wrapper_func.__qualname__ = getattr(method, '__qualname__', None)\n    wrapper_func.__annotations__ = getattr(method, '__annotations__', {})\n    \n    # Apply decorators to the function wrapper\n    for dec in decorators:\n        wrapper_func = dec(wrapper_func)\n    return wrapper_func(*args, **kwargs)\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/utils/decorators.py lines 13-21)": [
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Create a proper function wrapper that has the attributes decorators expect\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    \n    # Copy all the standard function attributes that @wraps expects\n    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n        try:\n            value = getattr(dummy, attr)\n            setattr(_wrapper, attr, value)\n        except AttributeError:\n            pass\n    \n    # Also copy __dict__ if it exists\n    if hasattr(dummy, '__dict__'):\n        _wrapper.__dict__.update(dummy.__dict__)\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Create a proper function wrapper that has the necessary attributes\n    # for decorators that use @wraps()\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    \n    # Copy attributes from the decorated dummy to our wrapper\n    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n        try:\n            setattr(_wrapper, attr, getattr(dummy, attr))\n        except AttributeError:\n            pass\n    \n    # Copy __dict__ if it exists and is not empty\n    if hasattr(dummy, '__dict__'):\n        _wrapper.__dict__.update(dummy.__dict__)\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Create a proper function wrapper that decorators can introspect\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    \n    # Copy attributes from the decorated dummy to our wrapper\n    for attr in ('__name__', '__module__', '__doc__', '__qualname__', '__annotations__'):\n        try:\n            setattr(_wrapper, attr, getattr(dummy, attr))\n        except AttributeError:\n            pass\n    \n    # Copy any additional attributes that update_wrapper would handle\n    try:\n        _wrapper.__wrapped__ = dummy.__wrapped__\n    except AttributeError:\n        _wrapper.__wrapped__ = dummy\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n    # using it on a dummy function.\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    update_wrapper(_wrapper, dummy)\n\n\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of partial\n        def bound_method(*bound_args, **bound_kwargs):\n            return method.__get__(self, type(self))(*bound_args, **bound_kwargs)\n        \n        # Copy function attributes from the original method\n        bound_method.__name__ = method.__name__\n        bound_method.__module__ = method.__module__\n        bound_method.__doc__ = method.__doc__\n        bound_method.__dict__ = getattr(method, '__dict__', {})\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', method.__name__)\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy over any attributes that have been applied to the original method\n    update_wrapper(_wrapper, method)\n    # Apply the same decorators to the wrapper for consistency\n    _update_method_wrapper(_wrapper, decorators[-1] if decorators else lambda x: x)\n    return _wrapper\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Create a proper function wrapper that has the necessary attributes\n    # for decorators that use @wraps to function correctly\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    \n    # Copy all relevant attributes from the decorated dummy to our wrapper\n    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n        try:\n            value = getattr(dummy, attr)\n            setattr(_wrapper, attr, value)\n        except AttributeError:\n            pass\n    \n    # Copy __dict__ if it exists and is not empty\n    if hasattr(dummy, '__dict__'):\n        _wrapper.__dict__.update(dummy.__dict__)\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n    # using it on a dummy function.\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    update_wrapper(_wrapper, dummy)\n\n\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of a partial object\n        def bound_method(*args, **kwargs):\n            return method.__get__(self, type(self))(*args, **kwargs)\n        \n        # Copy function attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', 'method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that the decorator may have set.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    return _wrapper\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Apply the decorator to a dummy function to get its attributes\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    # Copy all function attributes from the decorated dummy to our wrapper\n    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n        try:\n            value = getattr(dummy, attr)\n            setattr(_wrapper, attr, value)\n        except AttributeError:\n            pass\n    # Copy __dict__ if it exists\n    if hasattr(dummy, '__dict__'):\n        _wrapper.__dict__.update(getattr(dummy, '__dict__', {}))\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Apply decorator to a dummy function to get proper attributes\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    # Copy attributes from the decorated dummy to our wrapper\n    for attr in ('__name__', '__module__', '__doc__', '__qualname__', '__annotations__'):\n        try:\n            setattr(_wrapper, attr, getattr(dummy, attr))\n        except AttributeError:\n            pass\n    # Copy any additional attributes that functools.update_wrapper would handle\n    try:\n        _wrapper.__dict__.update(dummy.__dict__)\n    except AttributeError:\n        pass\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/utils/decorators.py lines 46-47)": [
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they're applied in the order\n        # they appear in the source.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, wrap method.__get__() in a function because new\n        # attributes can't be set on bound method objects, only on functions.\n        bound_method = method.__get__(self, type(self))\n        \n        # Create a proper function wrapper instead of using partial\n        def method_wrapper(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        try:\n            method_wrapper.__name__ = method.__name__\n        except AttributeError:\n            pass\n        try:\n            method_wrapper.__module__ = method.__module__\n        except AttributeError:\n            pass\n        try:\n            method_wrapper.__doc__ = method.__doc__\n        except AttributeError:\n            pass\n        try:\n            method_wrapper.__dict__.update(getattr(method, '__dict__', {}))\n        except AttributeError:\n            pass\n        try:\n            method_wrapper.__annotations__ = getattr(method, '__annotations__', {})\n        except AttributeError:\n            pass\n        try:\n            method_wrapper.__qualname__ = method.__qualname__\n        except AttributeError:\n            pass\n        \n        for dec in decorators:\n            method_wrapper = dec(method_wrapper)\n        return method_wrapper(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they appear in the order\n        # they were defined when viewed from the outside.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, create a proper function wrapper instead of using\n        # partial to ensure decorators can access function attributes.\n        def bound_method(*args, **kwargs):\n            return method(self, *args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they end up in the order\n        # they appear in the source.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, wrap method.__get__() in a function because new\n        # attributes can't be set on bound method objects, only on functions.\n        bound_method = method.__get__(self, type(self))\n        \n        # Create a proper function wrapper instead of using partial\n        def func_wrapper(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential function attributes from the original method\n        func_wrapper.__name__ = getattr(method, '__name__', 'wrapped_method')\n        func_wrapper.__module__ = getattr(method, '__module__', None)\n        func_wrapper.__doc__ = getattr(method, '__doc__', None)\n        func_wrapper.__dict__.update(getattr(method, '__dict__', {}))\n        func_wrapper.__annotations__ = getattr(method, '__annotations__', {})\n        func_wrapper.__qualname__ = getattr(method, '__qualname__', func_wrapper.__name__)\n        \n        for dec in decorators:\n            func_wrapper = dec(func_wrapper)\n        return func_wrapper(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they're applied in the order\n        # they appear in the source.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, wrap method.__get__() in a function because new\n        # attributes can't be set on bound method objects, only on functions.\n        bound_method = method.__get__(self, type(self))\n        \n        # Create a proper function wrapper instead of using partial\n        def method_wrapper(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        try:\n            method_wrapper.__name__ = method.__name__\n        except AttributeError:\n            pass\n        try:\n            method_wrapper.__module__ = method.__module__\n        except AttributeError:\n            pass\n        try:\n            method_wrapper.__qualname__ = method.__qualname__\n        except AttributeError:\n            pass\n        try:\n            method_wrapper.__doc__ = method.__doc__\n        except AttributeError:\n            pass\n        try:\n            method_wrapper.__annotations__ = method.__annotations__\n        except AttributeError:\n            pass\n            \n        for dec in decorators:\n            method_wrapper = dec(method_wrapper)\n        return method_wrapper(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they're applied in the order\n        # they appear in the source.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, create a proper function wrapper instead of using\n        # partial to ensure decorators using @wraps can access function attributes.\n        bound_method = method.__get__(self, type(self))\n        \n        def wrapper_func(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential function attributes from the original method\n        wrapper_func.__name__ = getattr(method, '__name__', '<lambda>')\n        wrapper_func.__module__ = getattr(method, '__module__', None)\n        wrapper_func.__doc__ = getattr(method, '__doc__', None)\n        wrapper_func.__dict__.update(getattr(method, '__dict__', {}))\n        wrapper_func.__annotations__ = getattr(method, '__annotations__', {})\n        wrapper_func.__qualname__ = getattr(method, '__qualname__', wrapper_func.__name__)\n        \n        for dec in decorators:\n            wrapper_func = dec(wrapper_func)\n        return wrapper_func(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they end up in the expected order.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, wrap method.__get__() in a function because new\n        # attributes can't be set on bound method objects, only on functions.\n        bound_method = method.__get__(self, type(self))\n        \n        # Create a proper function wrapper instead of using partial\n        def wrapper_func(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        wrapper_func.__name__ = getattr(method, '__name__', 'wrapper')\n        wrapper_func.__module__ = getattr(method, '__module__', None)\n        wrapper_func.__doc__ = getattr(method, '__doc__', None)\n        wrapper_func.__annotations__ = getattr(method, '__annotations__', {})\n        wrapper_func.__qualname__ = getattr(method, '__qualname__', wrapper_func.__name__)\n        wrapper_func.__dict__.update(getattr(method, '__dict__', {}))\n        \n        for dec in decorators:\n            wrapper_func = dec(wrapper_func)\n        return wrapper_func(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they're applied in the order\n        # they appear in the source.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, wrap method.__get__() in a function because new\n        # attributes can't be set on bound method objects, only on functions.\n        bound_method = method.__get__(self, type(self))\n        \n        # Create a proper function wrapper instead of using partial\n        def wrapper_func(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        wrapper_func.__name__ = getattr(method, '__name__', '<lambda>')\n        wrapper_func.__module__ = getattr(method, '__module__', None)\n        wrapper_func.__doc__ = getattr(method, '__doc__', None)\n        wrapper_func.__qualname__ = getattr(method, '__qualname__', wrapper_func.__name__)\n        wrapper_func.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            wrapper_func = dec(wrapper_func)\n        return wrapper_func(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they're applied in the order\n        # they appear in the list.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, create a proper function wrapper instead of using\n        # partial to ensure decorators can access function attributes.\n        def bound_method(*args, **kwargs):\n            return method(self, *args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', '<unknown>')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/utils/decorators.py lines 22-50)": [
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of using partial\n        # This ensures decorators that use @wraps can access __name__, __module__, etc.\n        bound_method = method.__get__(self, type(self))\n        \n        def method_wrapper(*inner_args, **inner_kwargs):\n            return bound_method(*inner_args, **inner_kwargs)\n        \n        # Copy essential attributes from the original method\n        method_wrapper.__name__ = getattr(method, '__name__', 'method')\n        method_wrapper.__module__ = getattr(method, '__module__', None)\n        method_wrapper.__doc__ = getattr(method, '__doc__', None)\n        method_wrapper.__qualname__ = getattr(method, '__qualname__', method_wrapper.__name__)\n        method_wrapper.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            method_wrapper = dec(method_wrapper)\n        return method_wrapper(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of using partial directly\n        # This ensures decorators using @wraps can access __name__, __module__, etc.\n        bound_method = method.__get__(self, type(self))\n        \n        def method_wrapper(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        method_wrapper.__name__ = getattr(method, '__name__', 'wrapped_method')\n        method_wrapper.__module__ = getattr(method, '__module__', None)\n        method_wrapper.__doc__ = getattr(method, '__doc__', None)\n        method_wrapper.__dict__.update(getattr(method, '__dict__', {}))\n        method_wrapper.__annotations__ = getattr(method, '__annotations__', {})\n        \n        # Apply decorators to the function wrapper\n        decorated_method = method_wrapper\n        for dec in decorators:\n            decorated_method = dec(decorated_method)\n        return decorated_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Create a proper function wrapper instead of using partial\n        # to ensure decorators using @wraps can access function attributes.\n        bound_method_partial = partial(method.__get__(self, type(self)))\n        \n        def bound_method(*args, **kwargs):\n            return bound_method_partial(*args, **kwargs)\n        \n        # Copy essential function attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__qualname__ = getattr(method, '__qualname__', None)\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Create a proper function wrapper instead of partial\n        # to ensure decorators using @wraps can access function attributes.\n        bound_method_partial = partial(method.__get__(self, type(self)))\n        \n        def bound_method(*args, **kwargs):\n            return bound_method_partial(*args, **kwargs)\n        \n        # Copy essential function attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', 'decorated_method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Create a proper function wrapper instead of partial\n        # to ensure decorators using @wraps can access function attributes.\n        bound_method_partial = partial(method.__get__(self, type(self)))\n        \n        def bound_method(*args, **kwargs):\n            return bound_method_partial(*args, **kwargs)\n        \n        # Copy essential function attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', 'method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Create a proper function wrapper instead of partial\n        # to ensure decorators using @wraps can access function attributes.\n        bound_method_partial = partial(method.__get__(self, type(self)))\n        \n        def bound_method(*args, **kwargs):\n            return bound_method_partial(*args, **kwargs)\n        \n        # Copy essential function attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of partial to ensure\n        # it has the necessary attributes for decorators using @wraps\n        def bound_method(*args, **kwargs):\n            return method.__get__(self, type(self))(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n        # functions are applied so that the call order is the same as the\n        # order in which they appear in the iterable.\n        decorators = decorators[::-1]\n    else:\n        decorators = [decorators]\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Create a proper function wrapper instead of using partial\n        # to ensure it has the attributes decorators expect.\n        bound_method_partial = partial(method.__get__(self, type(self)))\n        \n        def bound_method(*args, **kwargs):\n            return bound_method_partial(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', 'bound_method')\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..1f2ec53896 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,6 +10,7 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n     # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n     # using it on a dummy function.\n@@ -18,7 +19,6 @@ def _update_method_wrapper(_wrapper, decorator):\n         pass\n     update_wrapper(_wrapper, dummy)\n \n-\n def _multi_decorate(decorators, method):\n     \"\"\"\n     Decorate `method` with one or more function decorators. `decorators` can be\n@@ -37,12 +37,39 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        # Copy function attributes from the original method to make bound_method\n+        # compatible with decorators that use @wraps(func)\n+        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n \n     # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+        # compatible with decorators that use @wraps(func)\n+        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n     for dec in decorators:\n         _update_method_wrapper(_wrapper, dec)\n     # Preserve any existing attributes of 'method', including the name.\n",
    "variant_0": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..253d82fe92 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,13 +10,22 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Apply decorator to a dummy function to get the proper attributes\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n-    update_wrapper(_wrapper, dummy)\n+    # Copy all relevant attributes from the decorated dummy to the wrapper\n+    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n+        try:\n+            value = getattr(dummy, attr)\n+            setattr(_wrapper, attr, value)\n+        except AttributeError:\n+            pass\n+    # Copy __dict__ if it exists\n+    if hasattr(dummy, '__dict__'):\n+        _wrapper.__dict__.update(getattr(dummy, '__dict__', {}))\n \n \n def _multi_decorate(decorators, method):\n@@ -33,11 +42,101 @@ def _multi_decorate(decorators, method):\n         decorators = [decorators]\n \n     def _wrapper(self, *args, **kwargs):\n-        # bound_method has the signature that 'decorator' expects i.e. no\n-        # 'self' argument, but it's a closure over self so it can call\n-        # 'func'. Also, wrap method.__get__() in a function because new\n-        # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        # Create a proper function wrapper instead of using partial\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method to make it decorator-friendly\n+        for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n+            try:\n+                value = getattr(method, attr)\n+                setattr(bound_method, attr, value)\n+            except AttributeError:\n+                pass\n+        \n+        # Apply decorators to the bound method\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy over any function attributes from the original method\n+    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n+        try:\n+            value = getattr(method, attr)\n+            setattr(_wrapper, attr, value)\n+        except AttributeError:\n+            pass\n+    _wrapper.__dict__.update(getattr(method, '__dict__', {}))\n+    _wrapper.__wrapped__ = method\n+    \n+    # Update wrapper attributes for each decorator\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    return _wrapper\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n+        # functions are applied so that the call order is the same as the\n+        # order in which they appear in the iterable.\n+        decorators = decorators[::-1]\n+    else:\n+        decorators = [decorators]\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of using partial directly\n+        # This ensures decorators using @wraps can access function attributes\n+        bound_method = method.__get__(self, type(self))\n+        \n+        def bound_func(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        bound_func.__name__ = getattr(method, '__name__', 'bound_method')\n+        bound_func.__doc__ = getattr(method, '__doc__', None)\n+        bound_func.__module__ = getattr(method, '__module__', None)\n+        bound_func.__qualname__ = getattr(method, '__qualname__', None)\n+        bound_func.__annotations__ = getattr(method, '__annotations__', {})\n+        \n+        for dec in decorators:\n+            bound_func = dec(bound_func)\n+        return bound_func(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+    \n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in the order they appear in the iterable.\n+        decorators = tuple(decorators)\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of using partial\n+        # This ensures decorators that use @wraps can access function attributes\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', '<lambda>')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__qualname__ = getattr(method, '__qualname__', None)\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n@@ -48,6 +147,69 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they're applied in the order\n+        # they appear in the list.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # bound_method has the signature that 'decorator' expects i.e. no\n+        # 'self' argument, but it's a closure over self so it can call\n+        # 'func'. Also, create a proper function wrapper instead of partial\n+        # so it has the attributes decorators expect.\n+        bound_method = method.__get__(self, type(self))\n+        \n+        def wrapper_func(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Copy essential function attributes that decorators expect\n+        try:\n+            wrapper_func.__name__ = method.__name__\n+        except AttributeError:\n+            pass\n+        try:\n+            wrapper_func.__module__ = method.__module__\n+        except AttributeError:\n+            pass\n+        try:\n+            wrapper_func.__doc__ = method.__doc__\n+        except AttributeError:\n+            pass\n+        try:\n+            wrapper_func.__annotations__ = method.__annotations__\n+        except AttributeError:\n+            pass\n+        try:\n+            wrapper_func.__qualname__ = method.__qualname__\n+        except AttributeError:\n+            pass\n+            \n+        for dec in decorators:\n+            wrapper_func = dec(wrapper_func)\n+        return wrapper_func(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_1": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..b7ec85c471 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,14 +10,24 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Create a proper function wrapper that has the attributes decorators expect\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n-    update_wrapper(_wrapper, dummy)\n-\n+    \n+    # Copy all the standard function attributes that @wraps expects\n+    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n+        try:\n+            value = getattr(dummy, attr)\n+            setattr(_wrapper, attr, value)\n+        except AttributeError:\n+            pass\n+    \n+    # Also copy __dict__ if it exists\n+    if hasattr(dummy, '__dict__'):\n+        _wrapper.__dict__.update(dummy.__dict__)\n \n def _multi_decorate(decorators, method):\n     \"\"\"\n@@ -32,15 +42,123 @@ def _multi_decorate(decorators, method):\n     else:\n         decorators = [decorators]\n \n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of using partial\n+        # This ensures decorators that use @wraps can access __name__, __module__, etc.\n+        bound_method = method.__get__(self, type(self))\n+        \n+        def method_wrapper(*inner_args, **inner_kwargs):\n+            return bound_method(*inner_args, **inner_kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        method_wrapper.__name__ = getattr(method, '__name__', 'method')\n+        method_wrapper.__module__ = getattr(method, '__module__', None)\n+        method_wrapper.__doc__ = getattr(method, '__doc__', None)\n+        method_wrapper.__qualname__ = getattr(method, '__qualname__', method_wrapper.__name__)\n+        method_wrapper.__annotations__ = getattr(method, '__annotations__', {})\n+        \n+        for dec in decorators:\n+            method_wrapper = dec(method_wrapper)\n+        return method_wrapper(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in the order they appear in the iterable.\n+        decorators = decorators[::-1]\n+    else:\n+        decorators = [decorators]\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of using partial\n+        # This ensures decorators using @wraps can access __name__, __module__, etc.\n+        def bound_method(*args, **kwargs):\n+            return method(self, *args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they're applied in the order\n+        # they appear in the source.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n     def _wrapper(self, *args, **kwargs):\n         # bound_method has the signature that 'decorator' expects i.e. no\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        bound_method = method.__get__(self, type(self))\n+        \n+        # Create a proper function wrapper instead of using partial\n+        def method_wrapper(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        try:\n+            method_wrapper.__name__ = method.__name__\n+        except AttributeError:\n+            pass\n+        try:\n+            method_wrapper.__module__ = method.__module__\n+        except AttributeError:\n+            pass\n+        try:\n+            method_wrapper.__doc__ = method.__doc__\n+        except AttributeError:\n+            pass\n+        try:\n+            method_wrapper.__dict__.update(getattr(method, '__dict__', {}))\n+        except AttributeError:\n+            pass\n+        try:\n+            method_wrapper.__annotations__ = getattr(method, '__annotations__', {})\n+        except AttributeError:\n+            pass\n+        try:\n+            method_wrapper.__qualname__ = method.__qualname__\n+        except AttributeError:\n+            pass\n+        \n         for dec in decorators:\n-            bound_method = dec(bound_method)\n-        return bound_method(*args, **kwargs)\n+            method_wrapper = dec(method_wrapper)\n+        return method_wrapper(*args, **kwargs)\n \n     # Copy any attributes that a decorator adds to the function it decorates.\n     for dec in decorators:\n@@ -48,6 +166,9 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_2": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..7a1120c802 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,14 +10,24 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Create a proper function wrapper that has the necessary attributes\n+    # for decorators that use @wraps()\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n-    update_wrapper(_wrapper, dummy)\n-\n+    \n+    # Copy attributes from the decorated dummy to our wrapper\n+    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n+        try:\n+            setattr(_wrapper, attr, getattr(dummy, attr))\n+        except AttributeError:\n+            pass\n+    \n+    # Copy __dict__ if it exists and is not empty\n+    if hasattr(dummy, '__dict__'):\n+        _wrapper.__dict__.update(dummy.__dict__)\n \n def _multi_decorate(decorators, method):\n     \"\"\"\n@@ -32,12 +42,87 @@ def _multi_decorate(decorators, method):\n     else:\n         decorators = [decorators]\n \n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of using partial directly\n+        # This ensures decorators using @wraps can access __name__, __module__, etc.\n+        bound_method = method.__get__(self, type(self))\n+        \n+        def method_wrapper(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        method_wrapper.__name__ = getattr(method, '__name__', 'wrapped_method')\n+        method_wrapper.__module__ = getattr(method, '__module__', None)\n+        method_wrapper.__doc__ = getattr(method, '__doc__', None)\n+        method_wrapper.__dict__.update(getattr(method, '__dict__', {}))\n+        method_wrapper.__annotations__ = getattr(method, '__annotations__', {})\n+        \n+        # Apply decorators to the function wrapper\n+        decorated_method = method_wrapper\n+        for dec in decorators:\n+            decorated_method = dec(decorated_method)\n+        return decorated_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+    # Apply decorators to the function wrapper\n+    for dec in decorators:\n+        wrapper_func = dec(wrapper_func)\n+    return wrapper_func(*args, **kwargs)\n+    # 'func'. Also, wrap method.__get__() in a function because new\n+    # attributes can't be set on bound method objects, only on functions.\n+    def bound_method(*args, **kwargs):\n+        return method.__get__(self, type(self))(*args, **kwargs)\n+    \n+    # Copy function attributes from the original method\n+    bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n+    bound_method.__module__ = getattr(method, '__module__', None)\n+    bound_method.__doc__ = getattr(method, '__doc__', None)\n+    bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+    \n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they appear in the order\n+        # they were defined when viewed from the outside.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n     def _wrapper(self, *args, **kwargs):\n         # bound_method has the signature that 'decorator' expects i.e. no\n         # 'self' argument, but it's a closure over self so it can call\n-        # 'func'. Also, wrap method.__get__() in a function because new\n-        # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        # 'func'. Also, create a proper function wrapper instead of using\n+        # partial to ensure decorators can access function attributes.\n+        def bound_method(*args, **kwargs):\n+            return method(self, *args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n@@ -48,6 +133,9 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_3": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..ec8664d9a6 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,14 +10,25 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Create a proper function wrapper that decorators can introspect\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n-    update_wrapper(_wrapper, dummy)\n-\n+    \n+    # Copy attributes from the decorated dummy to our wrapper\n+    for attr in ('__name__', '__module__', '__doc__', '__qualname__', '__annotations__'):\n+        try:\n+            setattr(_wrapper, attr, getattr(dummy, attr))\n+        except AttributeError:\n+            pass\n+    \n+    # Copy any additional attributes that update_wrapper would handle\n+    try:\n+        _wrapper.__wrapped__ = dummy.__wrapped__\n+    except AttributeError:\n+        _wrapper.__wrapped__ = dummy\n \n def _multi_decorate(decorators, method):\n     \"\"\"\n@@ -35,19 +46,100 @@ def _multi_decorate(decorators, method):\n     def _wrapper(self, *args, **kwargs):\n         # bound_method has the signature that 'decorator' expects i.e. no\n         # 'self' argument, but it's a closure over self so it can call\n-        # 'func'. Also, wrap method.__get__() in a function because new\n-        # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        # 'func'. Create a proper function wrapper instead of using partial\n+        # to ensure decorators using @wraps can access function attributes.\n+        bound_method_partial = partial(method.__get__(self, type(self)))\n+        \n+        def bound_method(*args, **kwargs):\n+            return bound_method_partial(*args, **kwargs)\n+        \n+        # Copy essential function attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__qualname__ = getattr(method, '__qualname__', None)\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+    \n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n+    # 'func'. Also, wrap method.__get__() in a function because new\n+    # attributes can't be set on bound method objects, only on functions.\n+    def bound_method(*args, **kwargs):\n+        return method.__get__(self, type(self))(*args, **kwargs)\n+    \n+    # Copy function attributes from the original method to make it decorator-friendly\n+    bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n+    bound_method.__module__ = getattr(method, '__module__', None)\n+    bound_method.__doc__ = getattr(method, '__doc__', None)\n+    bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n+    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+    \n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n \n     # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they end up in the order\n+        # they appear in the source.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # bound_method has the signature that 'decorator' expects i.e. no\n+        # 'self' argument, but it's a closure over self so it can call\n+        # 'func'. Also, wrap method.__get__() in a function because new\n+        # attributes can't be set on bound method objects, only on functions.\n+        bound_method = method.__get__(self, type(self))\n+        \n+        # Create a proper function wrapper instead of using partial\n+        def func_wrapper(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Copy essential function attributes from the original method\n+        func_wrapper.__name__ = getattr(method, '__name__', 'wrapped_method')\n+        func_wrapper.__module__ = getattr(method, '__module__', None)\n+        func_wrapper.__doc__ = getattr(method, '__doc__', None)\n+        func_wrapper.__dict__.update(getattr(method, '__dict__', {}))\n+        func_wrapper.__annotations__ = getattr(method, '__annotations__', {})\n+        func_wrapper.__qualname__ = getattr(method, '__qualname__', func_wrapper.__name__)\n+        \n+        for dec in decorators:\n+            func_wrapper = dec(func_wrapper)\n+        return func_wrapper(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n     for dec in decorators:\n         _update_method_wrapper(_wrapper, dec)\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_4": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..ee8dd68f63 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,6 +10,7 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n     # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n     # using it on a dummy function.\n@@ -19,6 +20,42 @@ def _update_method_wrapper(_wrapper, decorator):\n     update_wrapper(_wrapper, dummy)\n \n \n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n+        # functions are applied so that the call order is the same as the\n+        # order in which they appear in the iterable.\n+        decorators = decorators[::-1]\n+    else:\n+        decorators = [decorators]\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of partial\n+        def bound_method(*bound_args, **bound_kwargs):\n+            return method.__get__(self, type(self))(*bound_args, **bound_kwargs)\n+        \n+        # Copy function attributes from the original method\n+        bound_method.__name__ = method.__name__\n+        bound_method.__module__ = method.__module__\n+        bound_method.__doc__ = method.__doc__\n+        bound_method.__dict__ = getattr(method, '__dict__', {})\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', method.__name__)\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy over any attributes that have been applied to the original method\n+    update_wrapper(_wrapper, method)\n+    # Apply the same decorators to the wrapper for consistency\n+    _update_method_wrapper(_wrapper, decorators[-1] if decorators else lambda x: x)\n+    return _wrapper\n+\n def _multi_decorate(decorators, method):\n     \"\"\"\n     Decorate `method` with one or more function decorators. `decorators` can be\n@@ -35,9 +72,20 @@ def _multi_decorate(decorators, method):\n     def _wrapper(self, *args, **kwargs):\n         # bound_method has the signature that 'decorator' expects i.e. no\n         # 'self' argument, but it's a closure over self so it can call\n-        # 'func'. Also, wrap method.__get__() in a function because new\n-        # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        # 'func'. Create a proper function wrapper instead of partial\n+        # to ensure decorators using @wraps can access function attributes.\n+        bound_method_partial = partial(method.__get__(self, type(self)))\n+        \n+        def bound_method(*args, **kwargs):\n+            return bound_method_partial(*args, **kwargs)\n+        \n+        # Copy essential function attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', 'decorated_method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n@@ -48,6 +96,105 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+        # Apply decorators to the proper function wrapper\n+        for dec in decorators:\n+            method_wrapper = dec(method_wrapper)\n+        return method_wrapper(*args, **kwargs)\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in the order they appear in the iterable.\n+        decorators = decorators[::-1]\n+    else:\n+        decorators = [decorators]\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of using partial\n+        # This ensures decorators using @wraps can access __name__, __module__, etc.\n+        def bound_method(*method_args, **method_kwargs):\n+            return method.__get__(self, type(self))(*method_args, **method_kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', 'method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they're applied in the order\n+        # they appear in the source.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # bound_method has the signature that 'decorator' expects i.e. no\n+        # 'self' argument, but it's a closure over self so it can call\n+        # 'func'. Also, wrap method.__get__() in a function because new\n+        # attributes can't be set on bound method objects, only on functions.\n+        bound_method = method.__get__(self, type(self))\n+        \n+        # Create a proper function wrapper instead of using partial\n+        def method_wrapper(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        try:\n+            method_wrapper.__name__ = method.__name__\n+        except AttributeError:\n+            pass\n+        try:\n+            method_wrapper.__module__ = method.__module__\n+        except AttributeError:\n+            pass\n+        try:\n+            method_wrapper.__qualname__ = method.__qualname__\n+        except AttributeError:\n+            pass\n+        try:\n+            method_wrapper.__doc__ = method.__doc__\n+        except AttributeError:\n+            pass\n+        try:\n+            method_wrapper.__annotations__ = method.__annotations__\n+        except AttributeError:\n+            pass\n+            \n+        for dec in decorators:\n+            method_wrapper = dec(method_wrapper)\n+        return method_wrapper(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_5": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..139582b942 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,14 +10,25 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Create a proper function wrapper that has the necessary attributes\n+    # for decorators that use @wraps to function correctly\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n-    update_wrapper(_wrapper, dummy)\n-\n+    \n+    # Copy all relevant attributes from the decorated dummy to our wrapper\n+    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n+        try:\n+            value = getattr(dummy, attr)\n+            setattr(_wrapper, attr, value)\n+        except AttributeError:\n+            pass\n+    \n+    # Copy __dict__ if it exists and is not empty\n+    if hasattr(dummy, '__dict__'):\n+        _wrapper.__dict__.update(dummy.__dict__)\n \n def _multi_decorate(decorators, method):\n     \"\"\"\n@@ -35,9 +46,21 @@ def _multi_decorate(decorators, method):\n     def _wrapper(self, *args, **kwargs):\n         # bound_method has the signature that 'decorator' expects i.e. no\n         # 'self' argument, but it's a closure over self so it can call\n-        # 'func'. Also, wrap method.__get__() in a function because new\n-        # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        # 'func'. Create a proper function wrapper instead of partial\n+        # to ensure decorators using @wraps can access function attributes.\n+        bound_method_partial = partial(method.__get__(self, type(self)))\n+        \n+        def bound_method(*args, **kwargs):\n+            return bound_method_partial(*args, **kwargs)\n+        \n+        # Copy essential function attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', 'method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n@@ -48,6 +71,72 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    return bound_method(*args, **kwargs)\n+    # 'func'. Also, wrap method.__get__() in a function because new\n+    # attributes can't be set on bound method objects, only on functions.\n+    def bound_method(*args, **kwargs):\n+        return method.__get__(self, type(self))(*args, **kwargs)\n+    \n+    # Copy essential function attributes from the original method\n+    bound_method.__name__ = getattr(method, '__name__', '<lambda>')\n+    bound_method.__module__ = getattr(method, '__module__', None)\n+    bound_method.__doc__ = getattr(method, '__doc__', None)\n+    bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n+    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+    \n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they're applied in the order\n+        # they appear in the source.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # bound_method has the signature that 'decorator' expects i.e. no\n+        # 'self' argument, but it's a closure over self so it can call\n+        # 'func'. Also, create a proper function wrapper instead of using\n+        # partial to ensure decorators using @wraps can access function attributes.\n+        bound_method = method.__get__(self, type(self))\n+        \n+        def wrapper_func(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Copy essential function attributes from the original method\n+        wrapper_func.__name__ = getattr(method, '__name__', '<lambda>')\n+        wrapper_func.__module__ = getattr(method, '__module__', None)\n+        wrapper_func.__doc__ = getattr(method, '__doc__', None)\n+        wrapper_func.__dict__.update(getattr(method, '__dict__', {}))\n+        wrapper_func.__annotations__ = getattr(method, '__annotations__', {})\n+        wrapper_func.__qualname__ = getattr(method, '__qualname__', wrapper_func.__name__)\n+        \n+        for dec in decorators:\n+            wrapper_func = dec(wrapper_func)\n+        return wrapper_func(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_6": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..2693537985 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,6 +10,7 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n     # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n     # using it on a dummy function.\n@@ -19,6 +20,41 @@ def _update_method_wrapper(_wrapper, decorator):\n     update_wrapper(_wrapper, dummy)\n \n \n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n+        # functions are applied so that the call order is the same as the\n+        # order in which they appear in the iterable.\n+        decorators = decorators[::-1]\n+    else:\n+        decorators = [decorators]\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of a partial object\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        \n+        # Copy function attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', 'method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that the decorator may have set.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    return _wrapper\n+\n def _multi_decorate(decorators, method):\n     \"\"\"\n     Decorate `method` with one or more function decorators. `decorators` can be\n@@ -35,19 +71,112 @@ def _multi_decorate(decorators, method):\n     def _wrapper(self, *args, **kwargs):\n         # bound_method has the signature that 'decorator' expects i.e. no\n         # 'self' argument, but it's a closure over self so it can call\n-        # 'func'. Also, wrap method.__get__() in a function because new\n-        # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        # 'func'. Create a proper function wrapper instead of partial\n+        # to ensure decorators using @wraps can access function attributes.\n+        bound_method_partial = partial(method.__get__(self, type(self)))\n+        \n+        def bound_method(*args, **kwargs):\n+            return bound_method_partial(*args, **kwargs)\n+        \n+        # Copy essential function attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in the order they appear in the iterable.\n+        decorators = tuple(decorators)\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of partial\n+        def bound_method(*args, **kwargs):\n+            return method(self, *args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', '<method>')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', None)\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n \n     # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they end up in the expected order.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # bound_method has the signature that 'decorator' expects i.e. no\n+        # 'self' argument, but it's a closure over self so it can call\n+        # 'func'. Also, wrap method.__get__() in a function because new\n+        # attributes can't be set on bound method objects, only on functions.\n+        bound_method = method.__get__(self, type(self))\n+        \n+        # Create a proper function wrapper instead of using partial\n+        def wrapper_func(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        wrapper_func.__name__ = getattr(method, '__name__', 'wrapper')\n+        wrapper_func.__module__ = getattr(method, '__module__', None)\n+        wrapper_func.__doc__ = getattr(method, '__doc__', None)\n+        wrapper_func.__annotations__ = getattr(method, '__annotations__', {})\n+        wrapper_func.__qualname__ = getattr(method, '__qualname__', wrapper_func.__name__)\n+        wrapper_func.__dict__.update(getattr(method, '__dict__', {}))\n+        \n+        for dec in decorators:\n+            wrapper_func = dec(wrapper_func)\n+        return wrapper_func(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n     for dec in decorators:\n         _update_method_wrapper(_wrapper, dec)\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_7": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..a54ff8ad0e 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,14 +10,22 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Apply the decorator to a dummy function to get its attributes\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n-    update_wrapper(_wrapper, dummy)\n-\n+    # Copy all function attributes from the decorated dummy to our wrapper\n+    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n+        try:\n+            value = getattr(dummy, attr)\n+            setattr(_wrapper, attr, value)\n+        except AttributeError:\n+            pass\n+    # Copy __dict__ if it exists\n+    if hasattr(dummy, '__dict__'):\n+        _wrapper.__dict__.update(getattr(dummy, '__dict__', {}))\n \n def _multi_decorate(decorators, method):\n     \"\"\"\n@@ -32,15 +40,84 @@ def _multi_decorate(decorators, method):\n     else:\n         decorators = [decorators]\n \n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of partial to ensure\n+        # it has the necessary attributes for decorators using @wraps\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+    return bound_method(*args, **kwargs)\n+    # 'func'. Create a proper function wrapper instead of partial to\n+    # ensure decorators using @wraps can access function attributes.\n+    def bound_method(*args, **kwargs):\n+        return method.__get__(self, type(self))(*args, **kwargs)\n+    \n+    # Copy essential function attributes from the original method\n+    bound_method.__name__ = getattr(method, '__name__', 'method')\n+    bound_method.__module__ = getattr(method, '__module__', None)\n+    bound_method.__doc__ = getattr(method, '__doc__', None)\n+    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+    \n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they're applied in the order\n+        # they appear in the source.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n     def _wrapper(self, *args, **kwargs):\n         # bound_method has the signature that 'decorator' expects i.e. no\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        bound_method = method.__get__(self, type(self))\n+        \n+        # Create a proper function wrapper instead of using partial\n+        def wrapper_func(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        wrapper_func.__name__ = getattr(method, '__name__', '<lambda>')\n+        wrapper_func.__module__ = getattr(method, '__module__', None)\n+        wrapper_func.__doc__ = getattr(method, '__doc__', None)\n+        wrapper_func.__qualname__ = getattr(method, '__qualname__', wrapper_func.__name__)\n+        wrapper_func.__annotations__ = getattr(method, '__annotations__', {})\n+        \n         for dec in decorators:\n-            bound_method = dec(bound_method)\n-        return bound_method(*args, **kwargs)\n+            wrapper_func = dec(wrapper_func)\n+        return wrapper_func(*args, **kwargs)\n \n     # Copy any attributes that a decorator adds to the function it decorates.\n     for dec in decorators:\n@@ -48,6 +125,9 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_8": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..eb1a66c67c 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,14 +10,23 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Apply decorator to a dummy function to get proper attributes\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n-    update_wrapper(_wrapper, dummy)\n-\n+    # Copy attributes from the decorated dummy to our wrapper\n+    for attr in ('__name__', '__module__', '__doc__', '__qualname__', '__annotations__'):\n+        try:\n+            setattr(_wrapper, attr, getattr(dummy, attr))\n+        except AttributeError:\n+            pass\n+    # Copy any additional attributes that functools.update_wrapper would handle\n+    try:\n+        _wrapper.__dict__.update(dummy.__dict__)\n+    except AttributeError:\n+        pass\n \n def _multi_decorate(decorators, method):\n     \"\"\"\n@@ -35,9 +44,98 @@ def _multi_decorate(decorators, method):\n     def _wrapper(self, *args, **kwargs):\n         # bound_method has the signature that 'decorator' expects i.e. no\n         # 'self' argument, but it's a closure over self so it can call\n-        # 'func'. Also, wrap method.__get__() in a function because new\n-        # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        # 'func'. Create a proper function wrapper instead of using partial\n+        # to ensure it has the attributes decorators expect.\n+        bound_method_partial = partial(method.__get__(self, type(self)))\n+        \n+        def bound_method(*args, **kwargs):\n+            return bound_method_partial(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', 'bound_method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', 'bound_method')\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+    for dec in decorators:\n+        _update_method_wrapper(_wrapper, dec)\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n+    # Apply decorators to the function wrapper\n+    for dec in decorators:\n+        wrapper_func = dec(wrapper_func)\n+    return wrapper_func(*args, **kwargs)\n+    # 'func'. Also, wrap method.__get__() in a function because new\n+    # attributes can't be set on bound method objects, only on functions.\n+    def bound_method(*args, **kwargs):\n+        return method.__get__(self, type(self))(*args, **kwargs)\n+    \n+    # Copy function attributes from the original method to make it decorator-friendly\n+    try:\n+        bound_method.__name__ = method.__name__\n+    except AttributeError:\n+        pass\n+    try:\n+        bound_method.__module__ = method.__module__\n+    except AttributeError:\n+        pass\n+    try:\n+        bound_method.__qualname__ = method.__qualname__\n+    except AttributeError:\n+        pass\n+    try:\n+        bound_method.__doc__ = method.__doc__\n+    except AttributeError:\n+        pass\n+    try:\n+        bound_method.__annotations__ = method.__annotations__\n+    except AttributeError:\n+        pass\n+    \n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they're applied in the order\n+        # they appear in the list.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # bound_method has the signature that 'decorator' expects i.e. no\n+        # 'self' argument, but it's a closure over self so it can call\n+        # 'func'. Also, create a proper function wrapper instead of using\n+        # partial to ensure decorators can access function attributes.\n+        def bound_method(*args, **kwargs):\n+            return method(self, *args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', '<unknown>')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n@@ -48,6 +146,9 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n"
  }
}