{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/typehints.py lines 114-128)": "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Normalize parameter name to match documentation format\n        doc_name = name\n        if name == 'args':\n            doc_name = '*args'\n        elif name == 'kwargs':\n            doc_name = '**kwargs'\n\n        arg = arguments.get(doc_name, {})\n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
    "Location 2 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/typehints.py lines 169-177)": "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Normalize parameter names for matching\n        # Check if annotation name matches a documented parameter (with asterisks)\n        documented_name = name\n        if name == 'args' and '*args' in has_description:\n            documented_name = '*args'\n        elif name == 'kwargs' and '**kwargs' in has_description:\n            documented_name = '**kwargs'\n        \n        if documented_name in has_description and documented_name not in has_type:\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + documented_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
    "Location 3 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/typehints.py lines 102-106)": "\n        elif parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
    "Location 4 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/typehints.py lines 152-160)": "\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for *args/**kwargs matching\n                if param_name.startswith('*'):\n                    normalized_name = param_name.lstrip('*')\n                    has_description.add(normalized_name)\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized name for *args/**kwargs matching\n                if name.startswith('*'):\n                    normalized_name = name.lstrip('*')\n                    has_description.add(normalized_name)\n                    has_type.add(normalized_name)\n",
    "Location 5 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/typehints.py lines 118-123)": "\n        arg = arguments.get(name, {})\n        # Also check for the parameter with asterisk prefixes for varargs/kwargs\n        if not arg and name in ['args', 'kwargs']:\n            asterisk_name = '*' + name if name == 'args' else '**' + name\n            arg = arguments.get(asterisk_name, {})\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/typehints.py lines 114-128)": [
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Normalize parameter names to handle *args/**kwargs matching\n        normalized_name = name\n        if name == 'args':\n            # Check if *args exists in arguments (from docstring)\n            if '*args' in arguments:\n                normalized_name = '*args'\n        elif name == 'kwargs':\n            # Check if **kwargs exists in arguments (from docstring)\n            if '**kwargs' in arguments:\n                normalized_name = '**kwargs'\n\n        arg = arguments.get(normalized_name, {})\n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + normalized_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + normalized_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Normalize parameter name to match documentation format\n        # Convert 'args' -> '*args' and 'kwargs' -> '**kwargs'\n        doc_name = name\n        if name == 'args':\n            doc_name = '*args'\n        elif name == 'kwargs':\n            doc_name = '**kwargs'\n\n        arg = arguments.get(doc_name, {})\n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Normalize parameter name to match documentation format\n        doc_name = name\n        if name == 'args':\n            doc_name = '*args'\n        elif name == 'kwargs':\n            doc_name = '**kwargs'\n\n        arg = arguments.get(doc_name, {})\n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Normalize parameter name to match documentation format\n        doc_name = name\n        if name == 'args':\n            doc_name = '*args'\n        elif name == 'kwargs':\n            doc_name = '**kwargs'\n        \n        # Check both original and normalized names\n        arg = arguments.get(doc_name, arguments.get(name, {}))\n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Normalize parameter name to match documentation format\n        normalized_name = name\n        if name == 'args':\n            normalized_name = '*args'\n        elif name == 'kwargs':\n            normalized_name = '**kwargs'\n\n        arg = arguments.get(normalized_name, {})\n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + normalized_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + normalized_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Normalize parameter name to match documentation format\n        normalized_name = name\n        if name == 'args':\n            normalized_name = '*args'\n        elif name == 'kwargs':\n            normalized_name = '**kwargs'\n\n        # Check both original and normalized names for existing documentation\n        arg = arguments.get(normalized_name, arguments.get(name, {}))\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + normalized_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + normalized_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Normalize parameter name to match documentation format\n        # Convert 'args' -> '*args' and 'kwargs' -> '**kwargs'\n        doc_name = name\n        if name == 'args':\n            doc_name = '*args'\n        elif name == 'kwargs':\n            doc_name = '**kwargs'\n        \n        # Check both original name and normalized name for existing documentation\n        arg = arguments.get(doc_name, arguments.get(name, {}))\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Normalize parameter name to match documentation format\n        # Convert 'args' -> '*args' and 'kwargs' -> '**kwargs'\n        doc_name = name\n        if name == 'args':\n            doc_name = '*args'\n        elif name == 'kwargs':\n            doc_name = '**kwargs'\n\n        arg = arguments.get(doc_name, {})\n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n"
    ],
    "Location 2 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/typehints.py lines 169-177)": [
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Normalize parameter names to handle *args/**kwargs matching\n        # Check both the original name and with asterisk prefixes\n        param_variants = [name]\n        if name == 'args':\n            param_variants.append('*args')\n        elif name == 'kwargs':\n            param_variants.append('**kwargs')\n        \n        # Check if any variant has description but no type\n        has_desc = any(variant in has_description for variant in param_variants)\n        has_typ = any(variant in has_type for variant in param_variants)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Check both the original name and with asterisk prefixes\n        param_name = name\n        prefixed_name = None\n        if name == 'args':\n            prefixed_name = '*args'\n        elif name == 'kwargs':\n            prefixed_name = '**kwargs'\n        \n        # Check if parameter has description (with or without asterisk prefix)\n        has_desc = (param_name in has_description or \n                   (prefixed_name and prefixed_name in has_description))\n        has_typ = (param_name in has_type or \n                  (prefixed_name and prefixed_name in has_type))\n        \n        if has_desc and not has_typ:\n            # Use the prefixed name if it exists in descriptions, otherwise use original\n            display_name = prefixed_name if prefixed_name and prefixed_name in has_description else param_name\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Check if this annotation name matches a documented parameter\n        # Handle *args/**kwargs mapping: args -> *args, kwargs -> **kwargs\n        doc_name = name\n        if name == 'args' and '*args' in has_description:\n            doc_name = '*args'\n        elif name == 'kwargs' and '**kwargs' in has_description:\n            doc_name = '**kwargs'\n        \n        if doc_name in has_description and doc_name not in has_type:\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Handle asterisk prefixes for varargs and kwargs matching\n        documented_name = name\n        if name == 'args' and '*args' in has_description:\n            documented_name = '*args'\n        elif name == 'kwargs' and '**kwargs' in has_description:\n            documented_name = '**kwargs'\n        \n        if documented_name in has_description and documented_name not in has_type:\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + documented_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Check if this annotation corresponds to a documented parameter\n        # Handle *args/**kwargs mapping: args -> *args, kwargs -> **kwargs\n        doc_name = name\n        if name == 'args' and '*args' in has_description:\n            doc_name = '*args'\n        elif name == 'kwargs' and '**kwargs' in has_description:\n            doc_name = '**kwargs'\n        \n        if doc_name in has_description and doc_name not in has_type:\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + doc_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Normalize parameter names for matching\n        # Check if annotation name matches any documented parameter (with or without asterisks)\n        documented_name = None\n        if name in has_description:\n            documented_name = name\n        elif '*' + name in has_description:\n            documented_name = '*' + name\n        elif '**' + name in has_description:\n            documented_name = '**' + name\n        \n        if documented_name and name not in has_type:\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + documented_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Check both the exact name and with asterisk prefixes for *args/**kwargs\n        param_variants = [name]\n        if name == 'args':\n            param_variants.append('*args')\n        elif name == 'kwargs':\n            param_variants.append('**kwargs')\n        \n        # Check if any variant has a description but no type\n        has_desc = any(variant in has_description for variant in param_variants)\n        has_typ = any(variant in has_type for variant in param_variants)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            # Use the documented parameter name format if it exists\n            display_name = name\n            for variant in param_variants:\n                if variant in has_description:\n                    display_name = variant\n                    break\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Normalize parameter names for matching\n        # Check both the annotation name and its asterisk-prefixed versions\n        param_variants = [name]\n        if name == 'args':\n            param_variants.append('*args')\n        elif name == 'kwargs':\n            param_variants.append('**kwargs')\n        \n        # Check if any variant has description but no type\n        has_desc = any(variant in has_description for variant in param_variants)\n        has_typ = any(variant in has_type for variant in param_variants)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            # Use the original parameter name from documentation if it exists with asterisks\n            display_name = name\n            for variant in param_variants:\n                if variant in has_description:\n                    display_name = variant\n                    break\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n"
    ],
    "Location 3 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/typehints.py lines 102-106)": [
      "\n        elif parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\n        elif parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\n        elif parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\n        elif parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\n        elif parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                # Store with original name for proper lookup\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n                # Also store normalized name for annotation matching\n                if name.startswith('**'):\n                    normalized_name = name[2:]\n                    arguments.setdefault(normalized_name, arg)\n                elif name.startswith('*'):\n                    normalized_name = name[1:]\n                    arguments.setdefault(normalized_name, arg)\n",
      "\n        elif parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\n        elif parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n"
    ],
    "Location 4 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/typehints.py lines 152-160)": [
      "\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for *args/**kwargs matching\n                if param_name.startswith('*'):\n                    normalized_name = param_name.lstrip('*')\n                    has_description.add(normalized_name)\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized name for *args/**kwargs matching\n                if name.startswith('*'):\n                    normalized_name = name.lstrip('*')\n                    has_description.add(normalized_name)\n                    has_type.add(normalized_name)\n",
      "\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized version for matching with annotations\n                if param_name.startswith('*'):\n                    has_description.add(param_name.lstrip('*'))\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized version for matching with annotations\n                if name.startswith('*'):\n                    has_description.add(name.lstrip('*'))\n                    has_type.add(name.lstrip('*'))\n",
      "\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized version for *args/**kwargs matching\n                if param_name.startswith('*'):\n                    normalized_name = param_name.lstrip('*')\n                    has_description.add(normalized_name)\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized version for *args/**kwargs matching\n                if name.startswith('*'):\n                    normalized_name = name.lstrip('*')\n                    has_description.add(normalized_name)\n                    has_type.add(normalized_name)\n",
      "\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized name for *args/**kwargs matching\n                if name.startswith('*'):\n                    normalized_name = name.lstrip('*')\n                    has_description.add(normalized_name)\n                    has_type.add(normalized_name)\n",
      "\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n",
      "\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                has_description.add(parts[1])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n",
      "\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n    force_rtype: bool\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized version for matching with annotations\n                if param_name.startswith('*'):\n                    normalized_name = param_name.lstrip('*')\n                    has_description.add(normalized_name)\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                param_name = ' '.join(parts[2:])\n                has_description.add(param_name)\n                has_type.add(param_name)\n                # Also add normalized version for matching with annotations\n                if param_name.startswith('*'):\n                    normalized_name = param_name.lstrip('*')\n                    has_description.add(normalized_name)\n                    has_type.add(normalized_name)\n",
      "\ndef augment_descriptions_with_types(\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n    force_rtype: bool\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                name = parts[1]\n                has_description.add(name)\n                # Also add normalized version for matching with annotations\n                if name.startswith('**'):\n                    has_description.add(name[2:])\n                elif name.startswith('*'):\n                    has_description.add(name[1:])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized version for matching with annotations\n                if name.startswith('**'):\n                    has_description.add(name[2:])\n                    has_type.add(name[2:])\n                elif name.startswith('*'):\n                    has_description.add(name[1:])\n                    has_type.add(name[1:])\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            has_type.add(name)\n        elif parts[0] in ('return', 'returns'):\n            has_description.add('return')\n        elif parts[0] == 'rtype':\n            has_type.add('return')\n\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n"
    ],
    "Location 5 (/root/hy/projects_1/sphinx/sphinx/ext/autodoc/typehints.py lines 118-123)": [
      "\n        arg = arguments.get(name, {})\n        # Also check for parameter names with asterisk prefixes for *args/**kwargs\n        if not arg and name in ['args', 'kwargs']:\n            if name == 'args':\n                arg = arguments.get('*args', {})\n            elif name == 'kwargs':\n                arg = arguments.get('**kwargs', {})\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            # Use the documented parameter name (with asterisks) if it exists\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n",
      "\n        arg = arguments.get(name, {})\n        # Also check for parameter names with asterisk prefixes\n        if not arg and name in ['args', 'kwargs']:\n            if name == 'args':\n                arg = arguments.get('*args', {})\n            elif name == 'kwargs':\n                arg = arguments.get('**kwargs', {})\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n",
      "\n        arg = arguments.get(name, {})\n        # Also check for asterisk-prefixed versions for varargs/kwargs\n        if not arg and name in ('args', 'kwargs'):\n            prefixed_name = '*' + name if name == 'args' else '**' + name\n            arg = arguments.get(prefixed_name, {})\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n",
      "\n        arg = arguments.get(name, {})\n        # Also check for parameter names with asterisk prefixes\n        if not arg and name in ['args', 'kwargs']:\n            if name == 'args':\n                arg = arguments.get('*args', {})\n            elif name == 'kwargs':\n                arg = arguments.get('**kwargs', {})\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n",
      "\n        arg = arguments.get(name, {})\n        # Also check for asterisk-prefixed versions of the parameter name\n        if not arg and name in ('args', 'kwargs'):\n            asterisk_name = '*' + name if name == 'args' else '**' + name\n            arg = arguments.get(asterisk_name, {})\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n",
      "\n        arg = arguments.get(name, {})\n        # Also check for parameter names with asterisk prefixes\n        if not arg and name in ['args', 'kwargs']:\n            if name == 'args':\n                arg = arguments.get('*args', {})\n            elif name == 'kwargs':\n                arg = arguments.get('**kwargs', {})\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n",
      "\n        arg = arguments.get(name, {})\n        # Also check for the parameter with asterisk prefix for *args/**kwargs\n        if not arg and name in ['args', 'kwargs']:\n            asterisk_name = '*' + name if name == 'args' else '**' + name\n            arg = arguments.get(asterisk_name, {})\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n",
      "\n        arg = arguments.get(name, {})\n        # Also check for parameter names with asterisk prefixes for *args/**kwargs\n        if not arg and name == 'args':\n            arg = arguments.get('*args', {})\n        elif not arg and name == 'kwargs':\n            arg = arguments.get('**kwargs', {})\n            \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..c639a16a3 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -99,6 +99,7 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                 arg = arguments.setdefault(parts[1], {})\n                 arg['param'] = True\n             elif len(parts) > 2:\n+\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 arg = arguments.setdefault(name, {})\n@@ -111,14 +112,51 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n+        # Try to find the documented parameter by checking multiple name variations\n+        # to handle *args and **kwargs properly\n         arg = arguments.get(name, {})\n+        if not arg and name == 'args':\n+            arg = arguments.get('*args', {})\n+        elif not arg and name == 'kwargs':\n+            arg = arguments.get('**kwargs', {})\n+        \n         if not arg.get('type'):\n+            # Use the documented parameter name (with asterisks) if it exists\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            # Use the documented parameter name (with asterisks) if it exists\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n         if not arg.get('param'):\n@@ -149,6 +187,7 @@ def augment_descriptions_with_types(\n     for field in fields:\n         field_name = field[0].astext()\n         parts = re.split(' +', field_name)\n+\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -166,13 +205,36 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Check if parameter has description, handling *args and **kwargs variations\n+        has_desc = name in has_description\n+        if not has_desc and name == 'args':\n+            has_desc = '*args' in has_description\n+        elif not has_desc and name == 'kwargs':\n+            has_desc = '**kwargs' in has_description\n+        \n+        # Check if parameter has type, handling *args and **kwargs variations\n+        has_typ = name in has_type\n+        if not has_typ and name == 'args':\n+            has_typ = '*args' in has_type\n+        elif not has_typ and name == 'kwargs':\n+            has_typ = '**kwargs' in has_type\n+        \n+        if has_desc and not has_typ:\n+            # Use the documented parameter name (with asterisks) if it exists\n+            display_name = name\n+            if name == 'args' and '*args' in has_description:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in has_description:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..059aa25be 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -99,6 +99,13 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                 arg = arguments.setdefault(parts[1], {})\n                 arg['param'] = True\n             elif len(parts) > 2:\n+\n+        elif parts[0] == 'param':\n+            if len(parts) == 2:\n+                # :param xxx:\n+                arg = arguments.setdefault(parts[1], {})\n+                arg['param'] = True\n+            elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 arg = arguments.setdefault(name, {})\n@@ -111,16 +118,30 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Normalize parameter name to match documentation format\n+        doc_name = name\n+        if name == 'args':\n+            doc_name = '*args'\n+        elif name == 'kwargs':\n+            doc_name = '**kwargs'\n+\n+        arg = arguments.get(doc_name, {})\n         if not arg.get('type'):\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + doc_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + doc_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+            node += field\n         if not arg.get('param'):\n             field = nodes.field()\n             field += nodes.field_name('', 'param ' + name)\n@@ -149,15 +170,26 @@ def augment_descriptions_with_types(\n     for field in fields:\n         field_name = field[0].astext()\n         parts = re.split(' +', field_name)\n+\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for *args/**kwargs matching\n+                if param_name.startswith('*'):\n+                    normalized_name = param_name.lstrip('*')\n+                    has_description.add(normalized_name)\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for *args/**kwargs matching\n+                if name.startswith('*'):\n+                    normalized_name = name.lstrip('*')\n+                    has_description.add(normalized_name)\n+                    has_type.add(normalized_name)\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,13 +198,23 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Normalize parameter names for matching\n+        # Check if annotation name matches a documented parameter (with asterisks)\n+        documented_name = name\n+        if name == 'args' and '*args' in has_description:\n+            documented_name = '*args'\n+        elif name == 'kwargs' and '**kwargs' in has_description:\n+            documented_name = '**kwargs'\n+        \n+        if documented_name in has_description and documented_name not in has_type:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + documented_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..3c1dcf677 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -99,6 +99,13 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                 arg = arguments.setdefault(parts[1], {})\n                 arg['param'] = True\n             elif len(parts) > 2:\n+\n+        elif parts[0] == 'param':\n+            if len(parts) == 2:\n+                # :param xxx:\n+                arg = arguments.setdefault(parts[1], {})\n+                arg['param'] = True\n+            elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 arg = arguments.setdefault(name, {})\n@@ -111,14 +118,41 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Normalize parameter names to handle *args/**kwargs matching\n+        normalized_name = name\n+        if name == 'args':\n+            # Check if *args exists in arguments (from docstring)\n+            if '*args' in arguments:\n+                normalized_name = '*args'\n+        elif name == 'kwargs':\n+            # Check if **kwargs exists in arguments (from docstring)\n+            if '**kwargs' in arguments:\n+                normalized_name = '**kwargs'\n+\n+        arg = arguments.get(normalized_name, {})\n         if not arg.get('type'):\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + normalized_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + normalized_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+            # Use the documented parameter name (with asterisks) if it exists\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n         if not arg.get('param'):\n@@ -149,15 +183,26 @@ def augment_descriptions_with_types(\n     for field in fields:\n         field_name = field[0].astext()\n         parts = re.split(' +', field_name)\n+\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for *args/**kwargs matching\n+                if param_name.startswith('*'):\n+                    normalized_name = param_name.lstrip('*')\n+                    has_description.add(normalized_name)\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for *args/**kwargs matching\n+                if name.startswith('*'):\n+                    normalized_name = name.lstrip('*')\n+                    has_description.add(normalized_name)\n+                    has_type.add(normalized_name)\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,11 +211,25 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Normalize parameter names to handle *args/**kwargs matching\n+        # Check both the original name and with asterisk prefixes\n+        param_variants = [name]\n+        if name == 'args':\n+            param_variants.append('*args')\n+        elif name == 'kwargs':\n+            param_variants.append('**kwargs')\n+        \n+        # Check if any variant has description but no type\n+        has_desc = any(variant in has_description for variant in param_variants)\n+        has_typ = any(variant in has_type for variant in param_variants)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n             field += nodes.field_name('', 'type ' + name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..de286b18b 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -99,6 +99,13 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                 arg = arguments.setdefault(parts[1], {})\n                 arg['param'] = True\n             elif len(parts) > 2:\n+\n+        elif parts[0] == 'param':\n+            if len(parts) == 2:\n+                # :param xxx:\n+                arg = arguments.setdefault(parts[1], {})\n+                arg['param'] = True\n+            elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 arg = arguments.setdefault(name, {})\n@@ -111,13 +118,30 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Normalize parameter name to match documentation format\n+        # Convert 'args' -> '*args' and 'kwargs' -> '**kwargs'\n+        doc_name = name\n+        if name == 'args':\n+            doc_name = '*args'\n+        elif name == 'kwargs':\n+            doc_name = '**kwargs'\n+\n+        arg = arguments.get(doc_name, {})\n         if not arg.get('type'):\n             field = nodes.field()\n+            field += nodes.field_name('', 'type ' + doc_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + doc_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n             field += nodes.field_name('', 'type ' + name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n@@ -143,6 +167,13 @@ def augment_descriptions_with_types(\n     annotations: Dict[str, str],\n     force_rtype: bool\n ) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     fields = cast(Iterable[nodes.field], node)\n     has_description = set()  # type: Set[str]\n     has_type = set()  # type: Set[str]\n@@ -152,12 +183,20 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized version for matching with annotations\n+                if param_name.startswith('*'):\n+                    has_description.add(param_name.lstrip('*'))\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized version for matching with annotations\n+                if name.startswith('*'):\n+                    has_description.add(name.lstrip('*'))\n+                    has_type.add(name.lstrip('*'))\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,13 +205,31 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Check both the original name and with asterisk prefixes\n+        param_name = name\n+        prefixed_name = None\n+        if name == 'args':\n+            prefixed_name = '*args'\n+        elif name == 'kwargs':\n+            prefixed_name = '**kwargs'\n+        \n+        # Check if parameter has description (with or without asterisk prefix)\n+        has_desc = (param_name in has_description or \n+                   (prefixed_name and prefixed_name in has_description))\n+        has_typ = (param_name in has_type or \n+                  (prefixed_name and prefixed_name in has_type))\n+        \n+        if has_desc and not has_typ:\n+            # Use the prefixed name if it exists in descriptions, otherwise use original\n+            display_name = prefixed_name if prefixed_name and prefixed_name in has_description else param_name\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..838e014ba 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -99,6 +99,13 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                 arg = arguments.setdefault(parts[1], {})\n                 arg['param'] = True\n             elif len(parts) > 2:\n+\n+        elif parts[0] == 'param':\n+            if len(parts) == 2:\n+                # :param xxx:\n+                arg = arguments.setdefault(parts[1], {})\n+                arg['param'] = True\n+            elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 arg = arguments.setdefault(name, {})\n@@ -111,16 +118,30 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Normalize parameter name to match documentation format\n+        doc_name = name\n+        if name == 'args':\n+            doc_name = '*args'\n+        elif name == 'kwargs':\n+            doc_name = '**kwargs'\n+\n+        arg = arguments.get(doc_name, {})\n         if not arg.get('type'):\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + doc_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + doc_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+            node += field\n         if not arg.get('param'):\n             field = nodes.field()\n             field += nodes.field_name('', 'param ' + name)\n@@ -149,15 +170,26 @@ def augment_descriptions_with_types(\n     for field in fields:\n         field_name = field[0].astext()\n         parts = re.split(' +', field_name)\n+\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized version for *args/**kwargs matching\n+                if param_name.startswith('*'):\n+                    normalized_name = param_name.lstrip('*')\n+                    has_description.add(normalized_name)\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized version for *args/**kwargs matching\n+                if name.startswith('*'):\n+                    normalized_name = name.lstrip('*')\n+                    has_description.add(normalized_name)\n+                    has_type.add(normalized_name)\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,13 +198,23 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Check if this annotation name matches a documented parameter\n+        # Handle *args/**kwargs mapping: args -> *args, kwargs -> **kwargs\n+        doc_name = name\n+        if name == 'args' and '*args' in has_description:\n+            doc_name = '*args'\n+        elif name == 'kwargs' and '**kwargs' in has_description:\n+            doc_name = '**kwargs'\n+        \n+        if doc_name in has_description and doc_name not in has_type:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + doc_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..a678fe6b6 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -99,6 +99,13 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                 arg = arguments.setdefault(parts[1], {})\n                 arg['param'] = True\n             elif len(parts) > 2:\n+\n+        elif parts[0] == 'param':\n+            if len(parts) == 2:\n+                # :param xxx:\n+                arg = arguments.setdefault(parts[1], {})\n+                arg['param'] = True\n+            elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 arg = arguments.setdefault(name, {})\n@@ -111,13 +118,30 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Normalize parameter name to match documentation format\n+        doc_name = name\n+        if name == 'args':\n+            doc_name = '*args'\n+        elif name == 'kwargs':\n+            doc_name = '**kwargs'\n+        \n+        # Check both original and normalized names\n+        arg = arguments.get(doc_name, arguments.get(name, {}))\n         if not arg.get('type'):\n             field = nodes.field()\n+            field += nodes.field_name('', 'type ' + doc_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + doc_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n             field += nodes.field_name('', 'type ' + name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n@@ -149,6 +173,7 @@ def augment_descriptions_with_types(\n     for field in fields:\n         field_name = field[0].astext()\n         parts = re.split(' +', field_name)\n+\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -158,6 +183,11 @@ def augment_descriptions_with_types(\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for *args/**kwargs matching\n+                if name.startswith('*'):\n+                    normalized_name = name.lstrip('*')\n+                    has_description.add(normalized_name)\n+                    has_type.add(normalized_name)\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,13 +196,22 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Handle asterisk prefixes for varargs and kwargs matching\n+        documented_name = name\n+        if name == 'args' and '*args' in has_description:\n+            documented_name = '*args'\n+        elif name == 'kwargs' and '**kwargs' in has_description:\n+            documented_name = '**kwargs'\n+        \n+        if documented_name in has_description and documented_name not in has_type:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + documented_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..840d10cbc 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -99,6 +99,13 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                 arg = arguments.setdefault(parts[1], {})\n                 arg['param'] = True\n             elif len(parts) > 2:\n+\n+        elif parts[0] == 'param':\n+            if len(parts) == 2:\n+                # :param xxx:\n+                arg = arguments.setdefault(parts[1], {})\n+                arg['param'] = True\n+            elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 arg = arguments.setdefault(name, {})\n@@ -111,16 +118,30 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Normalize parameter name to match documentation format\n+        normalized_name = name\n+        if name == 'args':\n+            normalized_name = '*args'\n+        elif name == 'kwargs':\n+            normalized_name = '**kwargs'\n+\n+        arg = arguments.get(normalized_name, {})\n         if not arg.get('type'):\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + normalized_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + normalized_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+            node += field\n         if not arg.get('param'):\n             field = nodes.field()\n             field += nodes.field_name('', 'param ' + name)\n@@ -149,6 +170,7 @@ def augment_descriptions_with_types(\n     for field in fields:\n         field_name = field[0].astext()\n         parts = re.split(' +', field_name)\n+\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -166,13 +188,23 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Check if this annotation corresponds to a documented parameter\n+        # Handle *args/**kwargs mapping: args -> *args, kwargs -> **kwargs\n+        doc_name = name\n+        if name == 'args' and '*args' in has_description:\n+            doc_name = '*args'\n+        elif name == 'kwargs' and '**kwargs' in has_description:\n+            doc_name = '**kwargs'\n+        \n+        if doc_name in has_description and doc_name not in has_type:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + doc_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..526acb64d 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -98,12 +98,22 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                 # :param xxx:\n                 arg = arguments.setdefault(parts[1], {})\n                 arg['param'] = True\n+            elif len(parts) > 2:\n+\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n+                # Store with original name for proper lookup\n                 arg = arguments.setdefault(name, {})\n                 arg['param'] = True\n                 arg['type'] = True\n+                # Also store normalized name for annotation matching\n+                if name.startswith('**'):\n+                    normalized_name = name[2:]\n+                    arguments.setdefault(normalized_name, arg)\n+                elif name.startswith('*'):\n+                    normalized_name = name[1:]\n+                    arguments.setdefault(normalized_name, arg)\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             arg = arguments.setdefault(name, {})\n@@ -111,13 +121,31 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Normalize parameter name to match documentation format\n+        normalized_name = name\n+        if name == 'args':\n+            normalized_name = '*args'\n+        elif name == 'kwargs':\n+            normalized_name = '**kwargs'\n+\n+        # Check both original and normalized names for existing documentation\n+        arg = arguments.get(normalized_name, arguments.get(name, {}))\n+        \n         if not arg.get('type'):\n             field = nodes.field()\n+            field += nodes.field_name('', 'type ' + normalized_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + normalized_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n             field += nodes.field_name('', 'type ' + name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n@@ -149,6 +177,7 @@ def augment_descriptions_with_types(\n     for field in fields:\n         field_name = field[0].astext()\n         parts = re.split(' +', field_name)\n+\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n@@ -166,13 +195,25 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Normalize parameter names for matching\n+        # Check if annotation name matches any documented parameter (with or without asterisks)\n+        documented_name = None\n+        if name in has_description:\n+            documented_name = name\n+        elif '*' + name in has_description:\n+            documented_name = '*' + name\n+        elif '**' + name in has_description:\n+            documented_name = '**' + name\n+        \n+        if documented_name and name not in has_type:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + documented_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..e5caf63f7 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -99,6 +99,13 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                 arg = arguments.setdefault(parts[1], {})\n                 arg['param'] = True\n             elif len(parts) > 2:\n+\n+        elif parts[0] == 'param':\n+            if len(parts) == 2:\n+                # :param xxx:\n+                arg = arguments.setdefault(parts[1], {})\n+                arg['param'] = True\n+            elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 arg = arguments.setdefault(name, {})\n@@ -111,16 +118,33 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Normalize parameter name to match documentation format\n+        # Convert 'args' -> '*args' and 'kwargs' -> '**kwargs'\n+        doc_name = name\n+        if name == 'args':\n+            doc_name = '*args'\n+        elif name == 'kwargs':\n+            doc_name = '**kwargs'\n+        \n+        # Check both original name and normalized name for existing documentation\n+        arg = arguments.get(doc_name, arguments.get(name, {}))\n+        \n         if not arg.get('type'):\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + doc_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + doc_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+            node += field\n         if not arg.get('param'):\n             field = nodes.field()\n             field += nodes.field_name('', 'param ' + name)\n@@ -139,6 +163,17 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n \n \n def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+    force_rtype: bool\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     node: nodes.field_list,\n     annotations: Dict[str, str],\n     force_rtype: bool\n@@ -152,12 +187,22 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized version for matching with annotations\n+                if param_name.startswith('*'):\n+                    normalized_name = param_name.lstrip('*')\n+                    has_description.add(normalized_name)\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n-                name = ' '.join(parts[2:])\n-                has_description.add(name)\n-                has_type.add(name)\n+                param_name = ' '.join(parts[2:])\n+                has_description.add(param_name)\n+                has_type.add(param_name)\n+                # Also add normalized version for matching with annotations\n+                if param_name.startswith('*'):\n+                    normalized_name = param_name.lstrip('*')\n+                    has_description.add(normalized_name)\n+                    has_type.add(normalized_name)\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,13 +211,32 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Check both the exact name and with asterisk prefixes for *args/**kwargs\n+        param_variants = [name]\n+        if name == 'args':\n+            param_variants.append('*args')\n+        elif name == 'kwargs':\n+            param_variants.append('**kwargs')\n+        \n+        # Check if any variant has a description but no type\n+        has_desc = any(variant in has_description for variant in param_variants)\n+        has_typ = any(variant in has_type for variant in param_variants)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            # Use the documented parameter name format if it exists\n+            display_name = name\n+            for variant in param_variants:\n+                if variant in has_description:\n+                    display_name = variant\n+                    break\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..ec93ea67c 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -99,6 +99,13 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                 arg = arguments.setdefault(parts[1], {})\n                 arg['param'] = True\n             elif len(parts) > 2:\n+\n+        elif parts[0] == 'param':\n+            if len(parts) == 2:\n+                # :param xxx:\n+                arg = arguments.setdefault(parts[1], {})\n+                arg['param'] = True\n+            elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 arg = arguments.setdefault(name, {})\n@@ -111,14 +118,30 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Normalize parameter name to match documentation format\n+        # Convert 'args' -> '*args' and 'kwargs' -> '**kwargs'\n+        doc_name = name\n+        if name == 'args':\n+            doc_name = '*args'\n+        elif name == 'kwargs':\n+            doc_name = '**kwargs'\n+\n+        arg = arguments.get(doc_name, {})\n         if not arg.get('type'):\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + doc_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + doc_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n         if not arg.get('param'):\n@@ -138,6 +161,18 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         node += field\n \n \n+def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+    force_rtype: bool\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n def augment_descriptions_with_types(\n     node: nodes.field_list,\n     annotations: Dict[str, str],\n@@ -152,12 +187,25 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                name = parts[1]\n+                has_description.add(name)\n+                # Also add normalized version for matching with annotations\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized version for matching with annotations\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                    has_type.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n+                    has_type.add(name[1:])\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,13 +214,43 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+    # Add 'type' for parameters with a description but no declared type.\n+    for name in annotations:\n+        elif parts[0] == 'type':\n+            name = ' '.join(parts[1:])\n+            has_type.add(name)\n+        elif parts[0] in ('return', 'returns'):\n+            has_description.add('return')\n+        elif parts[0] == 'rtype':\n+            has_type.add('return')\n+\n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Normalize parameter names for matching\n+        # Check both the annotation name and its asterisk-prefixed versions\n+        param_variants = [name]\n+        if name == 'args':\n+            param_variants.append('*args')\n+        elif name == 'kwargs':\n+            param_variants.append('**kwargs')\n+        \n+        # Check if any variant has description but no type\n+        has_desc = any(variant in has_description for variant in param_variants)\n+        has_typ = any(variant in has_type for variant in param_variants)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            # Use the original parameter name from documentation if it exists with asterisks\n+            display_name = name\n+            for variant in param_variants:\n+                if variant in has_description:\n+                    display_name = variant\n+                    break\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n"
  }
}