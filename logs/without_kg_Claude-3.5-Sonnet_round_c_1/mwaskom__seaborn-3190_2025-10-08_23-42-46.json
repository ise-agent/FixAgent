{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/seaborn/seaborn/_core/scales.py lines 350-351)": "\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n            axis.convert_units,\n            forward,\n",
    "Location 2 (/root/hy/projects_1/seaborn/seaborn/_core/scales.py lines 346-349)": "\n        if axis is None:\n            axis = PseudoAxis(mpl_scale)\n            axis.update_units(data)\n\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n",
    "Location 3 (/root/hy/projects_1/seaborn/seaborn/_core/scales.py lines 353-354)": "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                elif isinstance(x, (bool, np.bool_)):\n                    x = float(x)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n            axis.convert_units,\n            forward,\n            normalize,\n            prop.get_mapping(new, data)\n        ]\n",
    "Location 4 (/root/hy/projects_1/seaborn/seaborn/_core/scales.py lines 403-404)": "\ndef _get_transform(self):\n\n    arg = self.trans\n\n    def get_param(method, default):\n        if arg == method:\n            return default\n        return float(arg[len(method):])\n\n    if arg is None:\n        return _make_identity_transforms()\n    elif isinstance(arg, tuple):\n        return arg\n    elif isinstance(arg, str):\n        if arg == \"ln\":\n            return _make_log_transforms()\n        elif arg == \"logit\":\n            base = get_param(\"logit\", 10)\n            return _make_logit_transforms(base)\n        elif arg.startswith(\"log\"):\n            base = get_param(\"log\", 10)\n",
    "Location 5 (/root/hy/projects_1/seaborn/seaborn/_core/scales.py lines 901-906)": "\ndef _make_identity_transforms() -> TransFuncs:\n\n    def identity(x):\n        # Convert boolean to float for arithmetic compatibility\n        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n        return x\n\n    return identity, identity\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/seaborn/seaborn/_core/scales.py lines 350-351)": [
      "\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n            axis.convert_units,\n            forward,\n",
      "\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n            axis.convert_units,\n            forward,\n",
      "\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n            axis.convert_units,\n            forward,\n",
      "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n",
      "\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n            axis.convert_units,\n            forward,\n",
      "\n        vmin, vmax = axis.convert_units((vmin, vmax))\n        # Convert boolean values to numeric before arithmetic operations\n        a = forward(vmin)\n        if isinstance(a, (bool, np.bool_)):\n            a = float(a)\n            b = float(forward(vmax)) - a\n        else:\n            b = forward(vmax) - forward(vmin)\n",
      "\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n",
      "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before arithmetic operations\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                elif isinstance(x, (bool, np.bool_)):\n                    x = float(x)\n                return (x - a) / b\n"
    ],
    "Location 2 (/root/hy/projects_1/seaborn/seaborn/_core/scales.py lines 346-349)": [
      "\n        if axis is None:\n            axis = PseudoAxis(mpl_scale)\n            axis.update_units(data)\n\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n",
      "\n        if axis is None:\n            axis = PseudoAxis(mpl_scale)\n            axis.update_units(data)\n\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n",
      "\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n",
      "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n",
      "\n        if axis is None:\n            axis = PseudoAxis(mpl_scale)\n            axis.update_units(data)\n\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n",
      "\n        if axis is None:\n            axis = PseudoAxis(mpl_scale)\n            axis.update_units(data)\n\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n",
      "\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric values\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n",
      "\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n                # Handle boolean data by converting to numeric range\n                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n"
    ],
    "Location 3 (/root/hy/projects_1/seaborn/seaborn/_core/scales.py lines 353-354)": [
      "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n            axis.convert_units,\n            forward,\n            normalize,\n            prop.get_mapping(new, data)\n        ]\n",
      "\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                elif isinstance(x, (bool, np.bool_)):\n                    x = float(x)\n                return (x - a) / b\n",
      "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n",
      "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                return (x - a) / b\n",
      "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                elif isinstance(x, (bool, np.bool_)):\n                    x = float(x)\n                return (x - a) / b\n",
      "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                elif isinstance(x, (bool, np.bool_)):\n                    x = float(x)\n                return (x - a) / b\n",
      "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before arithmetic operations\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                elif isinstance(x, (bool, np.bool_)):\n                    x = float(x)\n                return (x - a) / b\n",
      "\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            # Convert boolean values to numeric before subtraction\n            if isinstance(a, (bool, np.bool_)):\n                a = float(a)\n                b = float(forward(vmax)) - a\n            else:\n                b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                # Convert boolean arrays to float for arithmetic operations\n                if hasattr(x, 'dtype') and x.dtype == bool:\n                    x = x.astype(float)\n                elif isinstance(x, (bool, np.bool_)):\n                    x = float(x)\n                return (x - a) / b\n"
    ],
    "Location 4 (/root/hy/projects_1/seaborn/seaborn/_core/scales.py lines 403-404)": [
      "\n        if arg is None:\n            # For boolean data, we still use identity transform but the normalization\n            # will handle the boolean-to-float conversion in _setup()\n            return _make_identity_transforms()\n",
      "\n    def _get_transform(self):\n\n        arg = self.trans\n\n        def get_param(method, default):\n            if arg == method:\n                return default\n            return float(arg[len(method):])\n\n        if arg is None:\n            # Return identity transforms that handle boolean conversion\n            def forward_identity(x):\n                if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n                    return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n                return x\n            return forward_identity, forward_identity\n",
      "\n        if arg is None:\n            # Check if we're dealing with boolean data and need numeric transforms\n            return _make_identity_transforms()\n",
      "\n    def _get_transform(self):\n\n        arg = self.trans\n\n        def get_param(method, default):\n            if arg == method:\n                return default\n            return float(arg[len(method):])\n\n        if arg is None:\n            # Create identity transforms that handle boolean data\n            def identity_forward(x):\n                if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n                    return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n                return x\n            \n            def identity_inverse(x):\n                return x\n            \n            return identity_forward, identity_inverse\n        elif isinstance(arg, tuple):\n            return arg\n        elif isinstance(arg, str):\n            if arg == \"ln\":\n                return _make_log_transforms()\n            elif arg == \"logit\":\n                base = get_param(\"logit\", 10)\n                return _make_logit_transforms(base)\n            elif arg.startswith(\"log\"):\n                base = get_param(\"log\", 10)\n",
      "\ndef _get_transform(self):\n\n    arg = self.trans\n\n    def get_param(method, default):\n        if arg == method:\n            return default\n        return float(arg[len(method):])\n\n    if arg is None:\n        return _make_identity_transforms()\n    elif isinstance(arg, tuple):\n        return arg\n    elif isinstance(arg, str):\n        if arg == \"ln\":\n            return _make_log_transforms()\n        elif arg == \"logit\":\n            base = get_param(\"logit\", 10)\n            return _make_logit_transforms(base)\n        elif arg.startswith(\"log\"):\n            base = get_param(\"log\", 10)\n",
      "\n        if arg is None:\n            return _make_identity_transforms()\n        elif isinstance(arg, tuple):\n            return arg\n        elif isinstance(arg, str):\n            if arg == \"ln\":\n                return _make_log_transforms()\n            elif arg == \"logit\":\n                base = get_param(\"logit\", 10)\n                return _make_logit_transforms(base)\n            elif arg.startswith(\"log\"):\n                base = get_param(\"log\", 10)\n",
      "\n    def _get_transform(self):\n\n        arg = self.trans\n\n        def get_param(method, default):\n            if arg == method:\n                return default\n            return float(arg[len(method):])\n\n        if arg is None:\n            return _make_identity_transforms()\n",
      "\n    def _get_transform(self):\n\n        arg = self.trans\n\n        def get_param(method, default):\n            if arg == method:\n                return default\n            return float(arg[len(method):])\n\n        if arg is None:\n            # Check if we need boolean-aware identity transforms\n            return _make_identity_transforms()\n        elif isinstance(arg, tuple):\n            return arg\n        elif isinstance(arg, str):\n            if arg == \"ln\":\n                return _make_log_transforms()\n            elif arg == \"logit\":\n                base = get_param(\"logit\", 10)\n                return _make_logit_transforms(base)\n            elif arg.startswith(\"log\"):\n                base = get_param(\"log\", 10)\n"
    ],
    "Location 5 (/root/hy/projects_1/seaborn/seaborn/_core/scales.py lines 901-906)": [
      "\ndef _make_identity_transforms() -> TransFuncs:\n\n    def identity(x):\n        # Convert boolean to float for arithmetic compatibility\n        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n        return x\n\n    return identity, identity\n",
      "\ndef _make_identity_transforms() -> TransFuncs:\n\n    def identity(x):\n        # Convert boolean to float for arithmetic compatibility\n        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n        return x\n\n    return identity, identity\n",
      "\ndef _make_identity_transforms() -> TransFuncs:\n\n    def identity(x):\n        # Convert boolean to float for arithmetic compatibility\n        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n        return x\n\n    return identity, identity\n",
      "\ndef _make_identity_transforms() -> TransFuncs:\n\n    def identity(x):\n        # Convert boolean to float for arithmetic compatibility in continuous scales\n        if isinstance(x, (bool, np.bool_)):\n            return float(x)\n        elif hasattr(x, 'dtype') and x.dtype == bool:\n            return x.astype(float)\n        return x\n\n    return identity, identity\n",
      "\ndef _make_identity_transforms() -> TransFuncs:\n\n    def identity(x):\n        # Convert boolean to float for arithmetic compatibility\n        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n        return x\n\n    return identity, identity\n",
      "\ndef _make_identity_transforms() -> TransFuncs:\n\n    def identity(x):\n        # Convert boolean to float for arithmetic compatibility\n        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n        return x\n\n    return identity, identity\n",
      "\ndef _make_identity_transforms() -> TransFuncs:\n\n    def identity(x):\n        # Convert boolean to float for arithmetic compatibility\n        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n        return x\n\n    return identity, identity\n",
      "\ndef _make_identity_transforms() -> TransFuncs:\n\n    def identity(x):\n        # Convert boolean to float for arithmetic compatibility\n        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n        return x\n\n    return identity, identity\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 6c9ecbc9..d4c79fca 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -343,14 +343,28 @@ class ContinuousBase(Scale):\n         normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n         if prop.normed:\n             if new.norm is None:\n+\n                 vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n             else:\n                 vmin, vmax = new.norm\n             vmin, vmax = axis.convert_units((vmin, vmax))\n+\n             a = forward(vmin)\n-            b = forward(vmax) - forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n \n             def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n                 return (x - a) / b\n \n         else:\n@@ -400,6 +414,7 @@ class ContinuousBase(Scale):\n                 return default\n             return float(arg[len(method):])\n \n+\n         if arg is None:\n             return _make_identity_transforms()\n         elif isinstance(arg, tuple):\n@@ -898,9 +913,13 @@ class PseudoAxis:\n # Transform function creation\n \n \n+\n def _make_identity_transforms() -> TransFuncs:\n \n     def identity(x):\n+        # Convert boolean to float for arithmetic compatibility\n+        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n         return x\n \n     return identity, identity\n",
    "variant_0": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 6c9ecbc9..e9010ecb 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -340,17 +340,102 @@ class ContinuousBase(Scale):\n         mpl_scale.set_default_locators_and_formatters(axis)\n         new._matplotlib_scale = mpl_scale\n \n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            axis.update_units(data)\n+\n+        mpl_scale.set_default_locators_and_formatters(axis)\n+        new._matplotlib_scale = mpl_scale\n+\n         normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n         if prop.normed:\n             if new.norm is None:\n                 vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n             else:\n                 vmin, vmax = new.norm\n             vmin, vmax = axis.convert_units((vmin, vmax))\n             a = forward(vmin)\n-            b = forward(vmax) - forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n \n             def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+\n+        mpl_scale.set_default_locators_and_formatters(axis)\n+        new._matplotlib_scale = mpl_scale\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+            axis.convert_units,\n+            forward,\n+\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                elif isinstance(x, (bool, np.bool_)):\n+                    x = float(x)\n                 return (x - a) / b\n \n         else:\n@@ -363,6 +448,16 @@ class ContinuousBase(Scale):\n             prop.get_mapping(new, data)\n         ]\n \n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+            axis.convert_units,\n+            forward,\n+            normalize,\n+            prop.get_mapping(new, data)\n+        ]\n+\n         def spacer(x):\n             x = x.dropna().unique()\n             if len(x) < 2:\n@@ -400,8 +495,28 @@ class ContinuousBase(Scale):\n                 return default\n             return float(arg[len(method):])\n \n-        if arg is None:\n-            return _make_identity_transforms()\n+\n+def _get_transform(self):\n+\n+    arg = self.trans\n+\n+    def get_param(method, default):\n+        if arg == method:\n+            return default\n+        return float(arg[len(method):])\n+\n+    if arg is None:\n+        return _make_identity_transforms()\n+    elif isinstance(arg, tuple):\n+        return arg\n+    elif isinstance(arg, str):\n+        if arg == \"ln\":\n+            return _make_log_transforms()\n+        elif arg == \"logit\":\n+            base = get_param(\"logit\", 10)\n+            return _make_logit_transforms(base)\n+        elif arg.startswith(\"log\"):\n+            base = get_param(\"log\", 10)\n         elif isinstance(arg, tuple):\n             return arg\n         elif isinstance(arg, str):\n@@ -898,9 +1013,13 @@ class PseudoAxis:\n # Transform function creation\n \n \n+\n def _make_identity_transforms() -> TransFuncs:\n \n     def identity(x):\n+        # Convert boolean to float for arithmetic compatibility\n+        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n         return x\n \n     return identity, identity\n",
    "variant_1": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 6c9ecbc9..3eed0c87 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -340,6 +340,81 @@ class ContinuousBase(Scale):\n         mpl_scale.set_default_locators_and_formatters(axis)\n         new._matplotlib_scale = mpl_scale\n \n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            axis.update_units(data)\n+\n+        mpl_scale.set_default_locators_and_formatters(axis)\n+        new._matplotlib_scale = mpl_scale\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+\n+        mpl_scale.set_default_locators_and_formatters(axis)\n+        new._matplotlib_scale = mpl_scale\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+            axis.convert_units,\n+            forward,\n+\n+\n         normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n         if prop.normed:\n             if new.norm is None:\n@@ -348,9 +423,17 @@ class ContinuousBase(Scale):\n                 vmin, vmax = new.norm\n             vmin, vmax = axis.convert_units((vmin, vmax))\n             a = forward(vmin)\n-            b = forward(vmax) - forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n \n             def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n                 return (x - a) / b\n \n         else:\n@@ -363,6 +446,16 @@ class ContinuousBase(Scale):\n             prop.get_mapping(new, data)\n         ]\n \n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+            axis.convert_units,\n+            forward,\n+            normalize,\n+            prop.get_mapping(new, data)\n+        ]\n+\n         def spacer(x):\n             x = x.dropna().unique()\n             if len(x) < 2:\n@@ -400,7 +493,10 @@ class ContinuousBase(Scale):\n                 return default\n             return float(arg[len(method):])\n \n+\n         if arg is None:\n+            # For boolean data, we still use identity transform but the normalization\n+            # will handle the boolean-to-float conversion in _setup()\n             return _make_identity_transforms()\n         elif isinstance(arg, tuple):\n             return arg\n@@ -898,9 +994,13 @@ class PseudoAxis:\n # Transform function creation\n \n \n+\n def _make_identity_transforms() -> TransFuncs:\n \n     def identity(x):\n+        # Convert boolean to float for arithmetic compatibility\n+        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n         return x\n \n     return identity, identity\n",
    "variant_2": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 6c9ecbc9..b6566e8d 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -340,17 +340,96 @@ class ContinuousBase(Scale):\n         mpl_scale.set_default_locators_and_formatters(axis)\n         new._matplotlib_scale = mpl_scale\n \n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            axis.update_units(data)\n+\n+        mpl_scale.set_default_locators_and_formatters(axis)\n+        new._matplotlib_scale = mpl_scale\n+\n         normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n         if prop.normed:\n             if new.norm is None:\n                 vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)\n             else:\n                 vmin, vmax = new.norm\n             vmin, vmax = axis.convert_units((vmin, vmax))\n             a = forward(vmin)\n-            b = forward(vmax) - forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n \n             def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+\n+        mpl_scale.set_default_locators_and_formatters(axis)\n+        new._matplotlib_scale = mpl_scale\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+            axis.convert_units,\n+            forward,\n+\n+\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                elif isinstance(x, (bool, np.bool_)):\n+                    x = float(x)\n                 return (x - a) / b\n \n         else:\n@@ -391,6 +470,16 @@ class ContinuousBase(Scale):\n \n         return new\n \n+    def _get_transform(self):\n+\n+        arg = self.trans\n+\n+        def get_param(method, default):\n+            if arg == method:\n+                return default\n+            return float(arg[len(method):])\n+\n+\n     def _get_transform(self):\n \n         arg = self.trans\n@@ -401,7 +490,12 @@ class ContinuousBase(Scale):\n             return float(arg[len(method):])\n \n         if arg is None:\n-            return _make_identity_transforms()\n+            # Return identity transforms that handle boolean conversion\n+            def forward_identity(x):\n+                if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+                    return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n+                return x\n+            return forward_identity, forward_identity\n         elif isinstance(arg, tuple):\n             return arg\n         elif isinstance(arg, str):\n@@ -898,9 +992,13 @@ class PseudoAxis:\n # Transform function creation\n \n \n+\n def _make_identity_transforms() -> TransFuncs:\n \n     def identity(x):\n+        # Convert boolean to float for arithmetic compatibility\n+        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n         return x\n \n     return identity, identity\n",
    "variant_3": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 6c9ecbc9..0b5e95f1 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -340,17 +340,87 @@ class ContinuousBase(Scale):\n         mpl_scale.set_default_locators_and_formatters(axis)\n         new._matplotlib_scale = mpl_scale\n \n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        mpl_scale.set_default_locators_and_formatters(axis)\n+        new._matplotlib_scale = mpl_scale\n+\n         normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n         if prop.normed:\n             if new.norm is None:\n                 vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n             else:\n                 vmin, vmax = new.norm\n             vmin, vmax = axis.convert_units((vmin, vmax))\n             a = forward(vmin)\n-            b = forward(vmax) - forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n \n             def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+            axis.convert_units,\n+            forward,\n+\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n                 return (x - a) / b\n \n         else:\n@@ -400,7 +470,9 @@ class ContinuousBase(Scale):\n                 return default\n             return float(arg[len(method):])\n \n+\n         if arg is None:\n+            # Check if we're dealing with boolean data and need numeric transforms\n             return _make_identity_transforms()\n         elif isinstance(arg, tuple):\n             return arg\n@@ -898,9 +970,13 @@ class PseudoAxis:\n # Transform function creation\n \n \n+\n def _make_identity_transforms() -> TransFuncs:\n \n     def identity(x):\n+        # Convert boolean to float for arithmetic compatibility\n+        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n         return x\n \n     return identity, identity\n",
    "variant_4": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 6c9ecbc9..ad697297 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -340,17 +340,75 @@ class ContinuousBase(Scale):\n         mpl_scale.set_default_locators_and_formatters(axis)\n         new._matplotlib_scale = mpl_scale\n \n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+\n         normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n         if prop.normed:\n             if new.norm is None:\n                 vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n             else:\n                 vmin, vmax = new.norm\n             vmin, vmax = axis.convert_units((vmin, vmax))\n             a = forward(vmin)\n-            b = forward(vmax) - forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n \n             def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n                 return (x - a) / b\n \n         else:\n@@ -391,6 +449,16 @@ class ContinuousBase(Scale):\n \n         return new\n \n+    def _get_transform(self):\n+\n+        arg = self.trans\n+\n+        def get_param(method, default):\n+            if arg == method:\n+                return default\n+            return float(arg[len(method):])\n+\n+\n     def _get_transform(self):\n \n         arg = self.trans\n@@ -401,7 +469,26 @@ class ContinuousBase(Scale):\n             return float(arg[len(method):])\n \n         if arg is None:\n-            return _make_identity_transforms()\n+            # Create identity transforms that handle boolean data\n+            def identity_forward(x):\n+                if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+                    return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n+                return x\n+            \n+            def identity_inverse(x):\n+                return x\n+            \n+            return identity_forward, identity_inverse\n+        elif isinstance(arg, tuple):\n+            return arg\n+        elif isinstance(arg, str):\n+            if arg == \"ln\":\n+                return _make_log_transforms()\n+            elif arg == \"logit\":\n+                base = get_param(\"logit\", 10)\n+                return _make_logit_transforms(base)\n+            elif arg.startswith(\"log\"):\n+                base = get_param(\"log\", 10)\n         elif isinstance(arg, tuple):\n             return arg\n         elif isinstance(arg, str):\n@@ -898,9 +985,15 @@ class PseudoAxis:\n # Transform function creation\n \n \n+\n def _make_identity_transforms() -> TransFuncs:\n \n     def identity(x):\n+        # Convert boolean to float for arithmetic compatibility in continuous scales\n+        if isinstance(x, (bool, np.bool_)):\n+            return float(x)\n+        elif hasattr(x, 'dtype') and x.dtype == bool:\n+            return x.astype(float)\n         return x\n \n     return identity, identity\n",
    "variant_5": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 6c9ecbc9..fb27a068 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -340,17 +340,102 @@ class ContinuousBase(Scale):\n         mpl_scale.set_default_locators_and_formatters(axis)\n         new._matplotlib_scale = mpl_scale\n \n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            axis.update_units(data)\n+\n+        mpl_scale.set_default_locators_and_formatters(axis)\n+        new._matplotlib_scale = mpl_scale\n+\n         normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n         if prop.normed:\n             if new.norm is None:\n                 vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n             else:\n                 vmin, vmax = new.norm\n             vmin, vmax = axis.convert_units((vmin, vmax))\n             a = forward(vmin)\n-            b = forward(vmax) - forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n \n             def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+\n+        mpl_scale.set_default_locators_and_formatters(axis)\n+        new._matplotlib_scale = mpl_scale\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+            axis.convert_units,\n+            forward,\n+\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                elif isinstance(x, (bool, np.bool_)):\n+                    x = float(x)\n                 return (x - a) / b\n \n         else:\n@@ -400,8 +485,28 @@ class ContinuousBase(Scale):\n                 return default\n             return float(arg[len(method):])\n \n-        if arg is None:\n-            return _make_identity_transforms()\n+\n+def _get_transform(self):\n+\n+    arg = self.trans\n+\n+    def get_param(method, default):\n+        if arg == method:\n+            return default\n+        return float(arg[len(method):])\n+\n+    if arg is None:\n+        return _make_identity_transforms()\n+    elif isinstance(arg, tuple):\n+        return arg\n+    elif isinstance(arg, str):\n+        if arg == \"ln\":\n+            return _make_log_transforms()\n+        elif arg == \"logit\":\n+            base = get_param(\"logit\", 10)\n+            return _make_logit_transforms(base)\n+        elif arg.startswith(\"log\"):\n+            base = get_param(\"log\", 10)\n         elif isinstance(arg, tuple):\n             return arg\n         elif isinstance(arg, str):\n@@ -898,9 +1003,13 @@ class PseudoAxis:\n # Transform function creation\n \n \n+\n def _make_identity_transforms() -> TransFuncs:\n \n     def identity(x):\n+        # Convert boolean to float for arithmetic compatibility\n+        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n         return x\n \n     return identity, identity\n",
    "variant_6": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 6c9ecbc9..33f6baca 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -340,17 +340,77 @@ class ContinuousBase(Scale):\n         mpl_scale.set_default_locators_and_formatters(axis)\n         new._matplotlib_scale = mpl_scale\n \n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+\n+        if axis is None:\n+            axis = PseudoAxis(mpl_scale)\n+            axis.update_units(data)\n+\n+        mpl_scale.set_default_locators_and_formatters(axis)\n+        new._matplotlib_scale = mpl_scale\n+\n         normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n         if prop.normed:\n             if new.norm is None:\n                 vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n             else:\n                 vmin, vmax = new.norm\n             vmin, vmax = axis.convert_units((vmin, vmax))\n             a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        else:\n+            normalize = vmin = vmax = None\n+\n+        new._pipeline = [\n+\n+        vmin, vmax = axis.convert_units((vmin, vmax))\n+        # Convert boolean values to numeric before arithmetic operations\n+        a = forward(vmin)\n+        if isinstance(a, (bool, np.bool_)):\n+            a = float(a)\n+            b = float(forward(vmax)) - a\n+        else:\n             b = forward(vmax) - forward(vmin)\n \n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n             def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                elif isinstance(x, (bool, np.bool_)):\n+                    x = float(x)\n                 return (x - a) / b\n \n         else:\n@@ -400,10 +460,21 @@ class ContinuousBase(Scale):\n                 return default\n             return float(arg[len(method):])\n \n+\n         if arg is None:\n             return _make_identity_transforms()\n         elif isinstance(arg, tuple):\n             return arg\n+        elif isinstance(arg, str):\n+            if arg == \"ln\":\n+                return _make_log_transforms()\n+            elif arg == \"logit\":\n+                base = get_param(\"logit\", 10)\n+                return _make_logit_transforms(base)\n+            elif arg.startswith(\"log\"):\n+                base = get_param(\"log\", 10)\n+        elif isinstance(arg, tuple):\n+            return arg\n         elif isinstance(arg, str):\n             if arg == \"ln\":\n                 return _make_log_transforms()\n@@ -898,9 +969,13 @@ class PseudoAxis:\n # Transform function creation\n \n \n+\n def _make_identity_transforms() -> TransFuncs:\n \n     def identity(x):\n+        # Convert boolean to float for arithmetic compatibility\n+        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n         return x\n \n     return identity, identity\n",
    "variant_7": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 6c9ecbc9..72013fe3 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -341,16 +341,77 @@ class ContinuousBase(Scale):\n         new._matplotlib_scale = mpl_scale\n \n         normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+\n         if prop.normed:\n             if new.norm is None:\n                 vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric values\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)\n             else:\n                 vmin, vmax = new.norm\n             vmin, vmax = axis.convert_units((vmin, vmax))\n             a = forward(vmin)\n-            b = forward(vmax) - forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n \n             def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before arithmetic operations\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                elif isinstance(x, (bool, np.bool_)):\n+                    x = float(x)\n                 return (x - a) / b\n \n         else:\n@@ -391,6 +452,16 @@ class ContinuousBase(Scale):\n \n         return new\n \n+    def _get_transform(self):\n+\n+        arg = self.trans\n+\n+        def get_param(method, default):\n+            if arg == method:\n+                return default\n+            return float(arg[len(method):])\n+\n+\n     def _get_transform(self):\n \n         arg = self.trans\n@@ -898,9 +969,13 @@ class PseudoAxis:\n # Transform function creation\n \n \n+\n def _make_identity_transforms() -> TransFuncs:\n \n     def identity(x):\n+        # Convert boolean to float for arithmetic compatibility\n+        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n         return x\n \n     return identity, identity\n",
    "variant_8": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 6c9ecbc9..e877853a 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -340,6 +340,57 @@ class ContinuousBase(Scale):\n         mpl_scale.set_default_locators_and_formatters(axis)\n         new._matplotlib_scale = mpl_scale\n \n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+                # Handle boolean data by converting to numeric range\n+                if isinstance(vmin, (bool, np.bool_)) or isinstance(vmax, (bool, np.bool_)):\n+                    vmin, vmax = float(vmin), float(vmax)  # False->0.0, True->1.0\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                return (x - a) / b\n+\n+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n+        if prop.normed:\n+            if new.norm is None:\n+                vmin, vmax = data.min(), data.max()\n+            else:\n+                vmin, vmax = new.norm\n+            vmin, vmax = axis.convert_units((vmin, vmax))\n+            a = forward(vmin)\n+            # Convert boolean values to numeric before arithmetic operations\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n+\n+            def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                elif isinstance(x, (bool, np.bool_)):\n+                    x = float(x)\n+                return (x - a) / b\n+\n+\n         normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n         if prop.normed:\n             if new.norm is None:\n@@ -348,9 +399,19 @@ class ContinuousBase(Scale):\n                 vmin, vmax = new.norm\n             vmin, vmax = axis.convert_units((vmin, vmax))\n             a = forward(vmin)\n-            b = forward(vmax) - forward(vmin)\n+            # Convert boolean values to numeric before subtraction\n+            if isinstance(a, (bool, np.bool_)):\n+                a = float(a)\n+                b = float(forward(vmax)) - a\n+            else:\n+                b = forward(vmax) - forward(vmin)\n \n             def normalize(x):\n+                # Convert boolean arrays to float for arithmetic operations\n+                if hasattr(x, 'dtype') and x.dtype == bool:\n+                    x = x.astype(float)\n+                elif isinstance(x, (bool, np.bool_)):\n+                    x = float(x)\n                 return (x - a) / b\n \n         else:\n@@ -391,6 +452,16 @@ class ContinuousBase(Scale):\n \n         return new\n \n+    def _get_transform(self):\n+\n+        arg = self.trans\n+\n+        def get_param(method, default):\n+            if arg == method:\n+                return default\n+            return float(arg[len(method):])\n+\n+\n     def _get_transform(self):\n \n         arg = self.trans\n@@ -401,9 +472,20 @@ class ContinuousBase(Scale):\n             return float(arg[len(method):])\n \n         if arg is None:\n+            # Check if we need boolean-aware identity transforms\n             return _make_identity_transforms()\n         elif isinstance(arg, tuple):\n             return arg\n+        elif isinstance(arg, str):\n+            if arg == \"ln\":\n+                return _make_log_transforms()\n+            elif arg == \"logit\":\n+                base = get_param(\"logit\", 10)\n+                return _make_logit_transforms(base)\n+            elif arg.startswith(\"log\"):\n+                base = get_param(\"log\", 10)\n+        elif isinstance(arg, tuple):\n+            return arg\n         elif isinstance(arg, str):\n             if arg == \"ln\":\n                 return _make_log_transforms()\n@@ -898,9 +980,13 @@ class PseudoAxis:\n # Transform function creation\n \n \n+\n def _make_identity_transforms() -> TransFuncs:\n \n     def identity(x):\n+        # Convert boolean to float for arithmetic compatibility\n+        if isinstance(x, (bool, np.bool_)) or (hasattr(x, 'dtype') and x.dtype == bool):\n+            return float(x) if isinstance(x, (bool, np.bool_)) else x.astype(float)\n         return x\n \n     return identity, identity\n"
  }
}