{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/urls/resolvers.py lines 48-53)": "\n        # Handle functools.partial objects\n        if isinstance(func, functools.partial):\n            # Extract the underlying function\n            underlying_func = func.func\n            \n            # Build partial info for the path\n            partial_args = []\n            if func.args:\n                partial_args.extend(repr(arg) for arg in func.args)\n            if func.keywords:\n                partial_args.extend(f\"{k}={repr(v)}\" for k, v in func.keywords.items())\n            partial_info = f\"({', '.join(partial_args)})\" if partial_args else \"()\"\n            \n            if not hasattr(underlying_func, '__name__'):\n                # A class-based view wrapped in partial\n                self._func_path = f\"functools.partial({underlying_func.__class__.__module__}.{underlying_func.__class__.__name__}, {partial_info[1:-1]})\"\n            else:\n                # A function-based view wrapped in partial\n                self._func_path = f\"functools.partial({underlying_func.__module__}.{underlying_func.__name__}, {partial_info[1:-1]})\"\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/urls/resolvers.py lines 48-53)": [
      "\n        # Handle functools.partial objects\n        if isinstance(func, functools.partial):\n            # Get the underlying function\n            underlying_func = func.func\n            \n            # Build argument representation\n            partial_info = []\n            if func.args:\n                partial_info.append(f\"args={func.args!r}\")\n            if func.keywords:\n                partial_info.append(f\"kwargs={func.keywords!r}\")\n            \n            # Determine the underlying function path\n            if not hasattr(underlying_func, '__name__'):\n                # A class-based view\n                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n            else:\n                # A function-based view\n                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n            \n            # Combine function path with partial information\n            if partial_info:\n                self._func_path = f\"functools.partial({func_path}, {', '.join(partial_info)})\"\n            else:\n                self._func_path = f\"functools.partial({func_path})\"\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n",
      "\n        # Handle functools.partial objects\n        if isinstance(func, functools.partial):\n            # Get the underlying function\n            underlying_func = func.func\n            # Create a descriptive path that includes partial info\n            if not hasattr(underlying_func, '__name__'):\n                # A class-based view wrapped in partial\n                base_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n            else:\n                # A function-based view wrapped in partial\n                base_path = underlying_func.__module__ + '.' + underlying_func.__name__\n            \n            # Add partial argument information\n            partial_info = []\n            if func.args:\n                partial_info.append(f\"args={func.args}\")\n            if func.keywords:\n                partial_info.append(f\"kwargs={func.keywords}\")\n            \n            if partial_info:\n                self._func_path = f\"functools.partial({base_path}, {', '.join(partial_info)})\"\n            else:\n                self._func_path = f\"functools.partial({base_path})\"\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n",
      "\n        # Handle functools.partial objects\n        if isinstance(func, functools.partial):\n            # Get the underlying function\n            underlying_func = func.func\n            \n            # Build the function path from the underlying function\n            if not hasattr(underlying_func, '__name__'):\n                # A class-based view wrapped in partial\n                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n            else:\n                # A function-based view wrapped in partial\n                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n            \n            # Add partial information\n            partial_info = []\n            if func.args:\n                partial_info.append(f\"args={func.args}\")\n            if func.keywords:\n                partial_info.append(f\"kwargs={func.keywords}\")\n            \n            if partial_info:\n                self._func_path = f\"functools.partial({func_path}, {', '.join(partial_info)})\"\n            else:\n                self._func_path = f\"functools.partial({func_path})\"\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n",
      "\n        # Handle functools.partial objects\n        if isinstance(func, functools.partial):\n            # Extract the underlying function\n            underlying_func = func.func\n            \n            # Get the path of the underlying function\n            if not hasattr(underlying_func, '__name__'):\n                # A class-based view wrapped in partial\n                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n            else:\n                # A function-based view wrapped in partial\n                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n            \n            # Add partial information\n            partial_info = []\n            if func.args:\n                partial_info.append('args=' + repr(func.args))\n            if func.keywords:\n                partial_info.append('kwargs=' + repr(func.keywords))\n            \n            if partial_info:\n                self._func_path = 'functools.partial(' + func_path + ', ' + ', '.join(partial_info) + ')'\n            else:\n                self._func_path = 'functools.partial(' + func_path + ')'\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n",
      "\n        # Handle functools.partial objects\n        if isinstance(func, functools.partial):\n            # Unwrap the partial to get the underlying function\n            underlying_func = func.func\n            partial_args = func.args\n            partial_kwargs = func.keywords\n            \n            if not hasattr(underlying_func, '__name__'):\n                # A class-based view wrapped in partial\n                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n            else:\n                # A function-based view wrapped in partial\n                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n            \n            # Include partial information in the path\n            partial_info = []\n            if partial_args:\n                partial_info.append('args=%r' % (partial_args,))\n            if partial_kwargs:\n                partial_info.append('kwargs=%r' % (partial_kwargs,))\n            \n            if partial_info:\n                self._func_path = 'functools.partial(%s, %s)' % (func_path, ', '.join(partial_info))\n            else:\n                self._func_path = 'functools.partial(%s)' % func_path\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n",
      "\n        # Handle functools.partial objects\n        if isinstance(func, functools.partial):\n            # Unwrap the partial to get the underlying function\n            underlying_func = func.func\n            partial_args = func.args\n            partial_kwargs = func.keywords\n            \n            if not hasattr(underlying_func, '__name__'):\n                # A class-based view wrapped in partial\n                base_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n            else:\n                # A function-based view wrapped in partial\n                base_path = underlying_func.__module__ + '.' + underlying_func.__name__\n            \n            # Include partial information in the path\n            partial_info = []\n            if partial_args:\n                partial_info.append('args=' + repr(partial_args))\n            if partial_kwargs:\n                partial_info.append('kwargs=' + repr(partial_kwargs))\n            \n            if partial_info:\n                self._func_path = 'functools.partial(%s, %s)' % (base_path, ', '.join(partial_info))\n            else:\n                self._func_path = 'functools.partial(%s)' % base_path\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n",
      "\n        # Handle functools.partial objects\n        if isinstance(func, functools.partial):\n            # Get the underlying function\n            underlying_func = func.func\n            \n            # Build the function path from the underlying function\n            if not hasattr(underlying_func, '__name__'):\n                # A class-based view wrapped in partial\n                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n            else:\n                # A function-based view wrapped in partial\n                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n            \n            # Include partial information\n            partial_info = []\n            if func.args:\n                partial_info.append(f\"args={func.args!r}\")\n            if func.keywords:\n                partial_info.append(f\"kwargs={func.keywords!r}\")\n            \n            if partial_info:\n                self._func_path = f\"functools.partial({func_path}, {', '.join(partial_info)})\"\n            else:\n                self._func_path = f\"functools.partial({func_path})\"\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n",
      "\n        # Handle functools.partial objects\n        if isinstance(func, functools.partial):\n            # Unwrap the partial to get the underlying function\n            underlying_func = func.func\n            partial_args = func.args\n            partial_kwargs = func.keywords\n            \n            if not hasattr(underlying_func, '__name__'):\n                # A class-based view wrapped in partial\n                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n            else:\n                # A function-based view wrapped in partial\n                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n            \n            # Add partial information to the path\n            partial_info = []\n            if partial_args:\n                partial_info.append('args=' + repr(partial_args))\n            if partial_kwargs:\n                partial_info.append('kwargs=' + repr(partial_kwargs))\n            \n            if partial_info:\n                self._func_path = 'functools.partial(' + func_path + ', ' + ', '.join(partial_info) + ')'\n            else:\n                self._func_path = 'functools.partial(' + func_path + ')'\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..13abb84ccf 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,30 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects by unwrapping them\n+        if isinstance(func, functools.partial):\n+            # Extract the underlying function and build a meaningful representation\n+            underlying_func = func.func\n+            if not hasattr(underlying_func, '__name__'):\n+                # A class-based view wrapped in partial\n+                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n+            else:\n+                # A function-based view wrapped in partial\n+                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n+            \n+            # Include information about pre-applied arguments\n+            partial_info = []\n+            if func.args:\n+                partial_info.append('args=%r' % (func.args,))\n+            if func.keywords:\n+                partial_info.append('kwargs=%r' % (func.keywords,))\n+            \n+            if partial_info:\n+                self._func_path = 'functools.partial(%s, %s)' % (func_path, ', '.join(partial_info))\n+            else:\n+                self._func_path = 'functools.partial(%s)' % func_path\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\n",
    "variant_0": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..63e07ed8a7 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,27 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects\n+        if isinstance(func, functools.partial):\n+            # Extract the underlying function\n+            underlying_func = func.func\n+            \n+            # Build partial info for the path\n+            partial_args = []\n+            if func.args:\n+                partial_args.extend(repr(arg) for arg in func.args)\n+            if func.keywords:\n+                partial_args.extend(f\"{k}={repr(v)}\" for k, v in func.keywords.items())\n+            partial_info = f\"({', '.join(partial_args)})\" if partial_args else \"()\"\n+            \n+            if not hasattr(underlying_func, '__name__'):\n+                # A class-based view wrapped in partial\n+                self._func_path = f\"functools.partial({underlying_func.__class__.__module__}.{underlying_func.__class__.__name__}, {partial_info[1:-1]})\"\n+            else:\n+                # A function-based view wrapped in partial\n+                self._func_path = f\"functools.partial({underlying_func.__module__}.{underlying_func.__name__}, {partial_info[1:-1]})\"\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\n",
    "variant_1": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..8d3e47b8b3 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,33 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects\n+        if isinstance(func, functools.partial):\n+            # Get the underlying function\n+            underlying_func = func.func\n+            \n+            # Build argument representation\n+            partial_info = []\n+            if func.args:\n+                partial_info.append(f\"args={func.args!r}\")\n+            if func.keywords:\n+                partial_info.append(f\"kwargs={func.keywords!r}\")\n+            \n+            # Determine the underlying function path\n+            if not hasattr(underlying_func, '__name__'):\n+                # A class-based view\n+                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n+            else:\n+                # A function-based view\n+                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n+            \n+            # Combine function path with partial information\n+            if partial_info:\n+                self._func_path = f\"functools.partial({func_path}, {', '.join(partial_info)})\"\n+            else:\n+                self._func_path = f\"functools.partial({func_path})\"\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\n",
    "variant_2": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..32e4d55e83 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,31 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects\n+        if isinstance(func, functools.partial):\n+            # Get the underlying function\n+            underlying_func = func.func\n+            # Create a descriptive path that includes partial info\n+            if not hasattr(underlying_func, '__name__'):\n+                # A class-based view wrapped in partial\n+                base_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n+            else:\n+                # A function-based view wrapped in partial\n+                base_path = underlying_func.__module__ + '.' + underlying_func.__name__\n+            \n+            # Add partial argument information\n+            partial_info = []\n+            if func.args:\n+                partial_info.append(f\"args={func.args}\")\n+            if func.keywords:\n+                partial_info.append(f\"kwargs={func.keywords}\")\n+            \n+            if partial_info:\n+                self._func_path = f\"functools.partial({base_path}, {', '.join(partial_info)})\"\n+            else:\n+                self._func_path = f\"functools.partial({base_path})\"\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\n",
    "variant_3": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..976d91c486 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,32 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects\n+        if isinstance(func, functools.partial):\n+            # Get the underlying function\n+            underlying_func = func.func\n+            \n+            # Build the function path from the underlying function\n+            if not hasattr(underlying_func, '__name__'):\n+                # A class-based view wrapped in partial\n+                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n+            else:\n+                # A function-based view wrapped in partial\n+                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n+            \n+            # Add partial information\n+            partial_info = []\n+            if func.args:\n+                partial_info.append(f\"args={func.args}\")\n+            if func.keywords:\n+                partial_info.append(f\"kwargs={func.keywords}\")\n+            \n+            if partial_info:\n+                self._func_path = f\"functools.partial({func_path}, {', '.join(partial_info)})\"\n+            else:\n+                self._func_path = f\"functools.partial({func_path})\"\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\n",
    "variant_4": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..a21ed71cb4 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,32 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects\n+        if isinstance(func, functools.partial):\n+            # Extract the underlying function\n+            underlying_func = func.func\n+            \n+            # Get the path of the underlying function\n+            if not hasattr(underlying_func, '__name__'):\n+                # A class-based view wrapped in partial\n+                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n+            else:\n+                # A function-based view wrapped in partial\n+                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n+            \n+            # Add partial information\n+            partial_info = []\n+            if func.args:\n+                partial_info.append('args=' + repr(func.args))\n+            if func.keywords:\n+                partial_info.append('kwargs=' + repr(func.keywords))\n+            \n+            if partial_info:\n+                self._func_path = 'functools.partial(' + func_path + ', ' + ', '.join(partial_info) + ')'\n+            else:\n+                self._func_path = 'functools.partial(' + func_path + ')'\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\n",
    "variant_5": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..76aba9ceb2 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,33 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects\n+        if isinstance(func, functools.partial):\n+            # Unwrap the partial to get the underlying function\n+            underlying_func = func.func\n+            partial_args = func.args\n+            partial_kwargs = func.keywords\n+            \n+            if not hasattr(underlying_func, '__name__'):\n+                # A class-based view wrapped in partial\n+                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n+            else:\n+                # A function-based view wrapped in partial\n+                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n+            \n+            # Include partial information in the path\n+            partial_info = []\n+            if partial_args:\n+                partial_info.append('args=%r' % (partial_args,))\n+            if partial_kwargs:\n+                partial_info.append('kwargs=%r' % (partial_kwargs,))\n+            \n+            if partial_info:\n+                self._func_path = 'functools.partial(%s, %s)' % (func_path, ', '.join(partial_info))\n+            else:\n+                self._func_path = 'functools.partial(%s)' % func_path\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\n",
    "variant_6": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..d76fa3a3bd 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,33 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects\n+        if isinstance(func, functools.partial):\n+            # Unwrap the partial to get the underlying function\n+            underlying_func = func.func\n+            partial_args = func.args\n+            partial_kwargs = func.keywords\n+            \n+            if not hasattr(underlying_func, '__name__'):\n+                # A class-based view wrapped in partial\n+                base_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n+            else:\n+                # A function-based view wrapped in partial\n+                base_path = underlying_func.__module__ + '.' + underlying_func.__name__\n+            \n+            # Include partial information in the path\n+            partial_info = []\n+            if partial_args:\n+                partial_info.append('args=' + repr(partial_args))\n+            if partial_kwargs:\n+                partial_info.append('kwargs=' + repr(partial_kwargs))\n+            \n+            if partial_info:\n+                self._func_path = 'functools.partial(%s, %s)' % (base_path, ', '.join(partial_info))\n+            else:\n+                self._func_path = 'functools.partial(%s)' % base_path\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\n",
    "variant_7": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..f3a3cbc9e4 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,32 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects\n+        if isinstance(func, functools.partial):\n+            # Get the underlying function\n+            underlying_func = func.func\n+            \n+            # Build the function path from the underlying function\n+            if not hasattr(underlying_func, '__name__'):\n+                # A class-based view wrapped in partial\n+                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n+            else:\n+                # A function-based view wrapped in partial\n+                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n+            \n+            # Include partial information\n+            partial_info = []\n+            if func.args:\n+                partial_info.append(f\"args={func.args!r}\")\n+            if func.keywords:\n+                partial_info.append(f\"kwargs={func.keywords!r}\")\n+            \n+            if partial_info:\n+                self._func_path = f\"functools.partial({func_path}, {', '.join(partial_info)})\"\n+            else:\n+                self._func_path = f\"functools.partial({func_path})\"\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\n",
    "variant_8": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..1f9b5313b3 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,33 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects\n+        if isinstance(func, functools.partial):\n+            # Unwrap the partial to get the underlying function\n+            underlying_func = func.func\n+            partial_args = func.args\n+            partial_kwargs = func.keywords\n+            \n+            if not hasattr(underlying_func, '__name__'):\n+                # A class-based view wrapped in partial\n+                func_path = underlying_func.__class__.__module__ + '.' + underlying_func.__class__.__name__\n+            else:\n+                # A function-based view wrapped in partial\n+                func_path = underlying_func.__module__ + '.' + underlying_func.__name__\n+            \n+            # Add partial information to the path\n+            partial_info = []\n+            if partial_args:\n+                partial_info.append('args=' + repr(partial_args))\n+            if partial_kwargs:\n+                partial_info.append('kwargs=' + repr(partial_kwargs))\n+            \n+            if partial_info:\n+                self._func_path = 'functools.partial(' + func_path + ', ' + ', '.join(partial_info) + ')'\n+            else:\n+                self._func_path = 'functools.partial(' + func_path + ')'\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\n"
  }
}