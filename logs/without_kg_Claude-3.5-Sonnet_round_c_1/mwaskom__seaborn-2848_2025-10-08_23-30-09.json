{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/seaborn/seaborn/_core/rules.py lines 143-144)": "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Input data to find the unique values for, provided in one of the\n        allowed formats.\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values present in the specified order\n        # This restores pre-0.11 behavior where points not in hue_order are excluded\n        if hasattr(vector, 'isin'):\n            filtered_vector = vector[vector.isin(order)]\n        else:\n            filtered_vector = pd.Series(vector)[pd.Series(vector).isin(order)]\n        \n        # Return only the values from order that are actually present in the data\n        if len(filtered_vector) > 0:\n            present_values = set(filtered_vector.dropna().unique())\n            return [val for val in order if val in present_values]\n        else:\n            return []\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
    "Location 2 (/root/hy/projects_1/seaborn/seaborn/_core/rules.py lines 86-87)": "\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore',\n            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n        )\n        # Only apply boolean check to numeric-compatible data\n        if hasattr(vector, 'dtype') and np.issubdtype(vector.dtype, np.number):\n            if np.isin(vector, [0, 1, np.nan]).all():\n                return VarType(boolean_type)\n        elif not hasattr(vector, 'dtype'):\n            # For non-array types, try the check but catch any errors\n            try:\n                if np.isin(vector, [0, 1, np.nan]).all():\n                    return VarType(boolean_type)\n            except (TypeError, ValueError):\n                pass\n",
    "Location 3 (/root/hy/projects_1/seaborn/seaborn/_core/rules.py lines 149-151)": "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Input data.\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values present in the specified order\n        # This restores the pre-0.11 behavior where data not in order is excluded\n        if hasattr(vector, 'isin'):\n            # For pandas Series\n            filtered_vector = vector[vector.isin(order)]\n        else:\n            # For numpy arrays and lists\n            vector_array = np.asarray(vector)\n            mask = np.isin(vector_array, order)\n            filtered_vector = vector_array[mask]\n        \n        # Return only the intersection of order and actual values present\n        if hasattr(filtered_vector, 'unique'):\n            present_values = set(filtered_vector.unique())\n        else:\n            present_values = set(np.unique(filtered_vector))\n        \n        # Filter out null values from present values\n        present_values = {val for val in present_values if pd.notnull(val)}\n        \n        # Return order filtered to only include values actually present\n        return [val for val in order if val in present_values]\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
    "Location 4 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1281-1281)": "\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            \n            # Filter data to only include rows where hue value is in hue_order\n            if hue_order is not None:\n                mask = data[hue].isin(hue_order)\n                data = data[mask]\n",
    "Location 5 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 2085-2087)": "\n    # Set up the PairGrid\n    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n    \n    # Filter data when hue_order is provided to restore pre-0.11 behavior\n    if hue is not None and hue_order is not None:\n        # Get the hue column data\n        if isinstance(data, pd.DataFrame):\n            hue_data = data[hue] if isinstance(hue, str) else hue\n        else:\n            hue_data = hue\n        \n        # Create mask for rows where hue value is in hue_order\n        mask = pd.Series(hue_data).isin(hue_order)\n        \n        # Filter the data to only include rows with hue values in hue_order\n        if isinstance(data, pd.DataFrame):\n            filtered_data = data[mask]\n        else:\n            # If data is not a DataFrame, we can't filter it here\n            filtered_data = data\n    else:\n        filtered_data = data\n    \n    grid = PairGrid(filtered_data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                    hue_order=hue_order, palette=palette, corner=corner,\n                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/seaborn/seaborn/_core/rules.py lines 143-144)": [
      "\n    if order is not None:\n        # Filter the vector to only include values present in the provided order\n        # This restores pre-0.11 behavior where data not in hue_order was excluded\n        if hasattr(vector, 'isin'):\n            mask = vector.isin(order)\n            filtered_vector = vector[mask]\n        else:\n            # Handle non-pandas arrays\n            mask = np.isin(vector, order)\n            filtered_vector = vector[mask]\n        \n        # Return only the order values that are actually present in the data\n        if len(filtered_vector) > 0:\n            present_values = set(filtered_vector.dropna() if hasattr(filtered_vector, 'dropna') \n                               else filtered_vector[pd.notnull(filtered_vector)])\n            return [val for val in order if val in present_values]\n        else:\n            return []\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique levels in `vector`, optionally limited to those\n    appearing in `order`.\n\n    Parameters\n    ----------\n    vector : list, array, Categorical, or Series\n        Vector of \"categorical\" values whose order will be determined.\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter to only include values that are actually present in the data\n        if vector.dtype.name == \"category\":\n            present_values = set(vector.cat.categories)\n        else:\n            present_values = set(filter(pd.notnull, vector.unique()))\n        \n        # Return intersection of requested order and actually present values\n        return [level for level in order if level in present_values]\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\n    if order is not None:\n        # Filter vector to only include values present in the provided order\n        # This restores pre-0.11 behavior where hue_order subsets would exclude non-matching points\n        if hasattr(vector, 'isin'):\n            # For pandas Series\n            mask = vector.isin(order)\n            filtered_vector = vector[mask]\n        else:\n            # For numpy arrays or other array-like objects\n            mask = np.isin(vector, order)\n            filtered_vector = vector[mask] if hasattr(vector, '__getitem__') else np.array(vector)[mask]\n        \n        # Return intersection of provided order and actual values in filtered data\n        if len(filtered_vector) > 0:\n            actual_values = set(pd.unique(filtered_vector))\n            return [val for val in order if val in actual_values]\n        else:\n            return []\n",
      "\n    if order is not None:\n        # Filter vector to only include values present in the provided order\n        # This restores pre-0.11 behavior where points not in hue_order are excluded\n        if hasattr(vector, 'isin'):\n            # For pandas Series\n            mask = vector.isin(order)\n            vector = vector[mask]\n        else:\n            # For numpy arrays or other array-like objects\n            vector = vector[np.isin(vector, order)]\n        return order\n",
      "\n    if order is not None:\n        # Filter the vector to only include values present in the provided order\n        # This restores pre-0.11 behavior where points not in hue_order are excluded\n        mask = vector.isin(order)\n        filtered_vector = vector[mask]\n        if len(filtered_vector) == 0:\n            return order\n        # Return only the order values that are actually present in the data\n        present_values = filtered_vector.unique()\n        return [val for val in order if val in present_values]\n",
      "\n    if order is not None:\n        # Filter vector to only include values that are in the provided order\n        # This restores pre-0.11 behavior where points not in hue_order are excluded\n        mask = vector.isin(order)\n        filtered_vector = vector[mask]\n        if len(filtered_vector) == 0:\n            return []\n        # Return only the order values that are actually present in the data\n        present_values = set(filtered_vector.dropna().unique())\n        return [val for val in order if val in present_values]\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique levels in ``vector``, using the order specified\n    in ``order`` when possible.\n\n    Parameters\n    ----------\n    vector : list, array, Categorical, or Series\n        Vector of \"categorical\" values whose order will be determined.\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values that are in the specified order\n        if hasattr(vector, 'isin'):\n            mask = vector.isin(order)\n        else:\n            mask = pd.Series(vector).isin(order)\n        \n        # Return only the values from order that are actually present in the filtered data\n        if hasattr(vector, 'iloc'):\n            present_values = set(vector[mask].dropna().unique())\n        else:\n            present_values = set(pd.Series(vector)[mask].dropna().unique())\n        \n        return [val for val in order if val in present_values]\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values that are in the provided order\n        if hasattr(vector, 'isin'):\n            # For pandas Series\n            filtered_vector = vector[vector.isin(order)]\n        else:\n            # For arrays/lists\n            filtered_vector = [x for x in vector if x in order]\n        \n        # Return only the order items that actually exist in the data\n        if len(filtered_vector) > 0:\n            if hasattr(filtered_vector, 'unique'):\n                existing_values = set(filtered_vector.unique())\n            else:\n                existing_values = set(filtered_vector)\n            return [x for x in order if x in existing_values]\n        else:\n            return []\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n"
    ],
    "Location 2 (/root/hy/projects_1/seaborn/seaborn/_core/rules.py lines 86-87)": [
      "\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore',\n            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n        )\n        # Only check for boolean values if the vector is numeric-compatible\n        if pd.api.types.is_numeric_dtype(vector) or pd.api.types.is_bool_dtype(vector):\n            if np.isin(vector, [0, 1, np.nan]).all():\n                return VarType(boolean_type)\n",
      "\n    # Check for boolean-ish numeric data\n    # This is a heuristic to identify data that should be treated as boolean,\n    # even if it comes in as numeric. We require that all values are 0, 1, or NaN\n    # to preserve the behavior of allowing float data that looks boolean-ish.\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore',\n            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n        )\n        # Only check for boolean values if vector is numeric to avoid TypeError\n        if pd.api.types.is_numeric_dtype(vector) and np.isin(vector, [0, 1, np.nan]).all():\n            return VarType(boolean_type)\n",
      "\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore',\n            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n        )\n        # Only check for boolean pattern if vector contains numeric-compatible data\n        if pd.api.types.is_numeric_dtype(vector) or pd.api.types.is_bool_dtype(vector):\n            if np.isin(vector, [0, 1, np.nan]).all():\n                return VarType(boolean_type)\n",
      "\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore',\n            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n        )\n        # Check if vector is numeric-compatible before applying np.isin with np.nan\n        if pd.api.types.is_numeric_dtype(vector) and np.isin(vector, [0, 1, np.nan]).all():\n            return VarType(boolean_type)\n",
      "\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore',\n            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n        )\n        # Only check for boolean values if vector contains numeric-compatible data\n        if pd.api.types.is_numeric_dtype(vector):\n            if np.isin(vector, [0, 1, np.nan]).all():\n                return VarType(boolean_type)\n",
      "\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore',\n            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n        )\n        # Only check for boolean values if vector contains numeric-compatible data\n        if pd.api.types.is_numeric_dtype(vector) or pd.api.types.is_bool_dtype(vector):\n            if np.isin(vector, [0, 1, np.nan]).all():\n                return VarType(boolean_type)\n",
      "\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore',\n            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n        )\n        # Check if vector contains numeric-compatible data before applying np.isin with np.nan\n        if pd.api.types.is_numeric_dtype(vector) and np.isin(vector, [0, 1, np.nan]).all():\n            return VarType(boolean_type)\n",
      "\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore',\n            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n        )\n        # Only check for boolean type if vector contains numeric-compatible data\n        if pd.api.types.is_numeric_dtype(vector) or pd.api.types.is_bool_dtype(vector):\n            if np.isin(vector, [0, 1, np.nan]).all():\n                return VarType(boolean_type)\n"
    ],
    "Location 3 (/root/hy/projects_1/seaborn/seaborn/_core/rules.py lines 149-151)": [
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique levels in a categorical variable.\n\n    The order is determined by the original data unless specified otherwise\n    in the `order` argument. This function assumes that the vector contains\n    some form of categorical data. That includes a pandas Categorical or\n    a variable that contains a finite number of unique values.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Input data.\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values present in the specified order\n        if hasattr(vector, 'isin'):\n            # For pandas Series\n            mask = vector.isin(order)\n            filtered_vector = vector[mask]\n        else:\n            # For numpy arrays or lists\n            mask = np.isin(vector, order)\n            filtered_vector = np.array(vector)[mask]\n        \n        # Return only the order values that are actually present in the data\n        if len(filtered_vector) > 0:\n            present_values = set(filtered_vector)\n            return [val for val in order if val in present_values]\n        else:\n            return []\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values that are in the provided order\n        # This restores pre-0.11 behavior where points not in hue_order are excluded\n        if hasattr(vector, 'isin'):\n            # For pandas Series\n            mask = vector.isin(order) | vector.isnull()\n            filtered_vector = vector[mask]\n        else:\n            # For numpy arrays or lists\n            vector_array = np.asarray(vector)\n            mask = np.isin(vector_array, order) | pd.isnull(vector_array)\n            filtered_vector = vector_array[mask]\n        \n        # Return intersection of order and actual values present in filtered data\n        if hasattr(filtered_vector, 'unique'):\n            present_values = set(filtered_vector.unique())\n        else:\n            present_values = set(np.unique(filtered_vector))\n        present_values.discard(None)  # Remove None if present\n        present_values = {v for v in present_values if pd.notnull(v)}  # Remove NaN values\n        \n        # Return order filtered to only include values actually present\n        return [val for val in order if val in present_values]\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Input data.\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values present in the provided order\n        # This restores pre-0.11 behavior where data not in hue_order is excluded\n        if hasattr(vector, 'isin'):\n            # For pandas Series\n            filtered_vector = vector[vector.isin(order)]\n        else:\n            # For numpy arrays or lists\n            filtered_vector = [x for x in vector if x in order]\n        \n        # Return only the order values that are actually present in the data\n        if hasattr(vector, 'isin'):\n            present_values = set(filtered_vector.dropna())\n        else:\n            present_values = set(x for x in filtered_vector if pd.notnull(x))\n        \n        return [x for x in order if x in present_values]\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Determine an ordered list of levels in ``data``.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter the vector to only include values that are in the provided order\n        filtered_vector = vector[vector.isin(order)] if hasattr(vector, 'isin') else vector\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique levels in a categorical variable.\n\n    The order of the returned levels follows these rules:\n\n    1. If the `order` parameter is given, use it as-is.\n    2. Otherwise, if the variable has a \"category\" dtype, use `categories`.\n    3. Otherwise, use the order of appearance in the data.\n\n    The `order` parameter is useful when you need a specific ordering that\n    may be different from what the data would imply. It can also be used\n    to subset the data (either by passing fewer levels than are present\n    in the data, or by passing levels that do not appear in the data).\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Input data.\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values that are in the provided order\n        # This restores the pre-0.11 behavior where data gets filtered to match hue_order\n        if hasattr(vector, 'isin'):\n            # For pandas Series\n            mask = vector.isin(order) | vector.isnull()\n            filtered_vector = vector[mask]\n        else:\n            # For array-like objects\n            vector_array = np.asarray(vector)\n            mask = np.isin(vector_array, order) | pd.isnull(vector_array)\n            filtered_vector = vector_array[mask]\n        \n        # Return only the levels from order that actually appear in the filtered data\n        if hasattr(filtered_vector, 'unique'):\n            present_values = set(filtered_vector.unique())\n        else:\n            present_values = set(np.unique(filtered_vector))\n        \n        # Remove null values from present_values\n        present_values = {val for val in present_values if pd.notnull(val)}\n        \n        # Return order filtered to only include values that are actually present\n        return [level for level in order if level in present_values]\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    The ordering rules are:\n    - If the data have a categorical dtype, use the category order\n    - Otherwise, use the order of appearance in the data\n\n    The `order` parameter is used to override this default behavior or\n    to filter the data to only include values present in both the data\n    and the specified order.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Input data.\n    order : list\n        Desired order of category levels to override the order determined\n        from the data object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values that are in the specified order\n        # This restores the pre-0.11 behavior where data not in hue_order was excluded\n        if hasattr(vector, 'isin'):\n            vector = vector[vector.isin(order)]\n        else:\n            vector = pd.Series(vector)\n            vector = vector[vector.isin(order)]\n        \n        # Return only the intersection of order and actual values present in filtered data\n        if len(vector) == 0:\n            return []\n        \n        # Get unique values from filtered vector while preserving order\n        present_values = set(vector.dropna().unique()) if hasattr(vector, 'dropna') else set(pd.Series(vector).dropna().unique())\n        return [val for val in order if val in present_values]\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Input data.\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values present in the specified order\n        # This restores pre-0.11 behavior where data not in hue_order is excluded\n        if hasattr(vector, 'isin'):\n            # For pandas Series\n            filtered_vector = vector[vector.isin(order)]\n        else:\n            # For numpy arrays or lists\n            vector_array = np.asarray(vector)\n            mask = np.isin(vector_array, order)\n            filtered_vector = vector_array[mask]\n        \n        # Return only the intersection of order and actual values present\n        if len(filtered_vector) > 0:\n            if hasattr(filtered_vector, 'unique'):\n                present_values = set(filtered_vector.unique())\n            else:\n                present_values = set(np.unique(filtered_vector))\n            return [x for x in order if x in present_values]\n        else:\n            return []\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Input data.\n    order : list\n        Desired order of category levels. If not provided, this will be the\n        order that the unique values appear in the data.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter vector to only include values present in the provided order\n        # This restores the pre-0.11 behavior where data not in hue_order is excluded\n        mask = pd.Series(vector).isin(order)\n        filtered_vector = pd.Series(vector)[mask]\n        # Return only the values from order that are actually present in the data\n        return [val for val in order if val in filtered_vector.values]\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n"
    ],
    "Location 4 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 1281-1281)": [
      "\n        if order is not None:\n            # When order is provided, filter the vector to only include values present in order\n            if vector is not None:\n                # Create a mask for values that are in the order\n                mask = pd.Series(vector).isin(order)\n                # Filter vector to only include values present in order\n                filtered_vector = pd.Series(vector)[mask]\n                # Return the intersection of order and actual values present in filtered data\n                present_values = filtered_vector.dropna().unique()\n                return [x for x in order if x in present_values]\n            else:\n                return order\n",
      "\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if hue_order is not None:\n                # Filter data to only include rows where hue value is in hue_order\n                mask = data[hue].isin(hue_order)\n                data = data[mask]\n",
      "\n            # If an explicit order is given, respect it. Otherwise, try to use the\n            # order that was passed in originally, and failing that, use the order\n            # of appearance in the vector. But filter the vector to only include\n            # values present in the order when order is provided.\n            if order is not None:\n                # Filter vector to only include values present in order\n                if vector is not None:\n                    mask = pd.Series(vector).isin(order)\n                    filtered_vector = pd.Series(vector)[mask]\n                    # Return intersection of order and filtered values, maintaining order\n                    return [x for x in order if x in filtered_vector.values]\n                else:\n                    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector, dtype=\"category\").cat.categories\n    elif pd.api.types.is_list_like(order):\n        # Filter vector to only include values present in the provided order\n        # This restores pre-0.11 behavior where points not in hue_order are excluded\n        if hasattr(vector, 'loc'):\n            # Handle pandas Series/DataFrame\n            mask = vector.isin(order)\n            vector = vector[mask]\n        else:\n            # Handle numpy arrays and lists\n            vector = np.array(vector)\n            mask = np.isin(vector, order)\n            vector = vector[mask]\n        \n        # Return the intersection of order and actual values present in filtered data\n        present_values = pd.Series(vector, dtype=\"category\").cat.categories\n        order = [val for val in order if val in present_values]\n    else:\n        err = \"Provided `order` is not list-like\"\n        raise TypeError(err)\n    return list(filter(pd.notnull, order))\n",
      "\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if hue_order is not None:\n                # Filter data to only include rows where hue value is in hue_order\n                # This restores pre-0.11 behavior of excluding points not in hue_order\n                mask = data[hue].isin(hue_order)\n                data = data.loc[mask]\n",
      "\n        if order is not None:\n            # Filter the vector to only include values present in the order\n            if vector is not None:\n                mask = pd.Series(vector).isin(order)\n                filtered_vector = pd.Series(vector)[mask]\n                # Return only the values from order that are actually present in the filtered data\n                present_values = filtered_vector.unique()\n                return [val for val in order if val in present_values]\n            else:\n                return order\n",
      "\n        if order is not None:\n            # Filter the vector to only include values that are in the provided order\n            if pd.api.types.is_categorical_dtype(vector):\n                # For categorical data, filter based on categories\n                mask = vector.isin(order)\n                filtered_vector = vector[mask]\n            else:\n                # For non-categorical data, filter based on values\n                mask = pd.Series(vector).isin(order)\n                filtered_vector = pd.Series(vector)[mask]\n            \n            # Return the intersection of order and actual values present in filtered data\n            present_values = pd.Series(filtered_vector).dropna().unique()\n            return [x for x in order if x in present_values]\n",
      "\n        if order is not None:\n            # Filter the vector to only include values that are in the provided order\n            if vector is not None and len(vector) > 0:\n                mask = pd.Series(vector).isin(order)\n                filtered_vector = pd.Series(vector)[mask]\n                # Return only the order values that are actually present in the filtered data\n                present_values = pd.Series(order)[pd.Series(order).isin(filtered_vector)]\n                return present_values.tolist() if len(present_values) > 0 else order\n            return order\n"
    ],
    "Location 5 (/root/hy/projects_1/seaborn/seaborn/axisgrid.py lines 2085-2087)": [
      "\n    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                    hue_order=hue_order, palette=palette, corner=corner,\n                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = list(filter(pd.notnull, pd.unique(vector)))\n        if variable_type(vector) == \"numeric\":\n            order.sort()\n    else:\n        # Filter vector to only include values present in the provided order\n        # This restores pre-0.11 behavior where data not in hue_order is excluded\n        if hasattr(vector, 'isin'):\n            # For pandas Series\n            mask = vector.isin(order)\n            filtered_vector = vector[mask]\n        else:\n            # For numpy arrays and lists\n            vector_array = np.asarray(vector)\n            mask = np.isin(vector_array, order)\n            filtered_vector = vector_array[mask]\n        \n        # Return intersection of provided order and values actually present in filtered data\n        present_values = set(filter(pd.notnull, pd.unique(filtered_vector)))\n        order = [x for x in order if x in present_values]\n\n    return order\n",
      "\n    # Resolve \"auto\" diag kind\n    if diag_kind == \"auto\":\n        if hue is None:\n            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n        else:\n            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n\n    # Filter data based on hue_order if provided\n    if hue is not None and hue_order is not None:\n        # Get the hue column from data\n        hue_values = data[hue] if isinstance(data, pd.DataFrame) else data.get(hue)\n        if hue_values is not None:\n            # Filter data to only include rows where hue value is in hue_order\n            mask = hue_values.isin(hue_order)\n            data = data[mask] if isinstance(data, pd.DataFrame) else data.loc[mask]\n\n    # Set up the PairGrid\n    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                    hue_order=hue_order, palette=palette, corner=corner,\n                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n",
      "\n    # Resolve \"auto\" diag kind\n    if diag_kind == \"auto\":\n        if hue is None:\n            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n        else:\n            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n\n    # Filter data based on hue_order if provided\n    if hue is not None and hue_order is not None:\n        # Get the hue column data\n        hue_data = data[hue] if isinstance(data, pd.DataFrame) else data\n        # Filter data to only include rows where hue value is in hue_order\n        if isinstance(data, pd.DataFrame):\n            mask = data[hue].isin(hue_order)\n            data = data[mask]\n        else:\n            # Handle case where data might be a different format\n            mask = pd.Series(hue_data).isin(hue_order)\n            if hasattr(data, 'loc'):\n                data = data.loc[mask]\n\n    # Set up the PairGrid\n    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                    hue_order=hue_order, palette=palette, corner=corner,\n                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n",
      "\n    # Set up the PairGrid\n    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n    \n    # Filter data to match hue_order if provided to restore pre-0.11 behavior\n    if hue is not None and hue_order is not None:\n        # Get the hue column from data\n        hue_col = data[hue] if isinstance(data, pd.DataFrame) else data.get(hue)\n        if hue_col is not None:\n            # Filter data to only include rows where hue value is in hue_order\n            mask = hue_col.isin(hue_order)\n            data = data[mask] if isinstance(data, pd.DataFrame) else data.loc[mask]\n    \n    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                    hue_order=hue_order, palette=palette, corner=corner,\n                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n",
      "\n    # Resolve \"auto\" diag kind\n    if diag_kind == \"auto\":\n        if hue is None:\n            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n        else:\n            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n\n    # Filter data when hue_order is provided to maintain pre-0.11 behavior\n    if hue is not None and hue_order is not None:\n        # Only keep rows where hue value is in hue_order\n        hue_mask = data[hue].isin(hue_order)\n        data = data[hue_mask]\n\n    # Set up the PairGrid\n    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                    hue_order=hue_order, palette=palette, corner=corner,\n                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n",
      "\n    # Set up the PairGrid\n    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n    \n    # Filter data when hue_order is provided to match pre-0.11 behavior\n    if hue is not None and hue_order is not None:\n        # Get the hue column data\n        hue_data = data[hue] if isinstance(data, pd.DataFrame) else data.get(hue)\n        if hue_data is not None:\n            # Create mask for rows where hue value is in hue_order\n            mask = hue_data.isin(hue_order)\n            # Filter the data to only include rows with hue values in hue_order\n            if isinstance(data, pd.DataFrame):\n                data = data[mask]\n            else:\n                # Handle dict-like data\n                filtered_data = {}\n                for key, values in data.items():\n                    if hasattr(values, '__len__') and len(values) == len(mask):\n                        filtered_data[key] = np.array(values)[mask]\n                    else:\n                        filtered_data[key] = values\n                data = filtered_data\n    \n    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                    hue_order=hue_order, palette=palette, corner=corner,\n                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n",
      "\n    # Resolve \"auto\" diag kind\n    if diag_kind == \"auto\":\n        if hue is None:\n            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n        else:\n            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n\n    # Filter data when hue_order is provided to restore pre-0.11 behavior\n    if hue is not None and hue_order is not None:\n        # Get the hue column from data\n        if isinstance(data, pd.DataFrame):\n            if hue in data.columns:\n                # Filter data to only include rows where hue value is in hue_order\n                data = data[data[hue].isin(hue_order)]\n\n    # Set up the PairGrid\n    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                    hue_order=hue_order, palette=palette, corner=corner,\n                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..c2acd3b2 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -83,8 +83,14 @@ def variable_type(\n             action='ignore',\n             category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n         )\n-        if np.isin(vector, [0, 1, np.nan]).all():\n-            return VarType(boolean_type)\n+\n+        # Add type checking to prevent TypeError with string data\n+        try:\n+            if np.isin(vector, [0, 1, np.nan]).all():\n+                return VarType(boolean_type)\n+        except TypeError:\n+            # If np.isin fails with string data, skip boolean check\n+            pass\n \n     # Defer to positive pandas tests\n     if pd.api.types.is_numeric_dtype(vector):\n@@ -140,12 +146,18 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n         Ordered list of category levels not including null values.\n \n     \"\"\"\n+\n     if order is not None:\n-        return order\n+        # Filter the vector to only include values present in the provided order\n+        # This restores the pre-0.11 behavior where points not in hue_order are excluded\n+        filtered_values = [val for val in vector.unique() if val in order and pd.notnull(val)]\n+        # Return only the values from order that are actually present in the data\n+        return [val for val in order if val in filtered_values]\n \n     if vector.dtype.name == \"category\":\n         order = list(vector.cat.categories)\n     else:\n+\n         order = list(filter(pd.notnull, vector.unique()))\n         if variable_type(order) == \"numeric\":\n             order.sort()\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..fdef04dc 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1278,6 +1278,7 @@ class PairGrid(Grid):\n             # (and was originally written exclusively that way) but now can delegate\n             # to the axes-level functions, while always handling legend creation.\n             # See GH2307\n+\n             hue_names = hue_order = categorical_order(data[hue], hue_order)\n             if dropna:\n                 # Filter NA from the list of unique hue names\n@@ -2082,6 +2083,7 @@ def pairplot(\n \n     # Set up the PairGrid\n     grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+\n     grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                     hue_order=hue_order, palette=palette, corner=corner,\n                     height=height, aspect=aspect, dropna=dropna, **grid_kws)\n",
    "variant_0": "diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..07b7d2ab 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -83,8 +83,28 @@ def variable_type(\n             action='ignore',\n             category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n         )\n-        if np.isin(vector, [0, 1, np.nan]).all():\n-            return VarType(boolean_type)\n+\n+    # Because we reduce with .all(), we are agnostic about whether the\n+    # comparison returns a scalar or vector, so we will ignore the warning.\n+    # It triggers a separate DeprecationWarning when the vector has datetimes:\n+    # https://github.com/numpy/numpy/issues/13548\n+    # This is considered a bug by numpy and will likely go away.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\n+            action='ignore',\n+            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n+        )\n+        # Only apply boolean check to numeric-compatible data\n+        if hasattr(vector, 'dtype') and np.issubdtype(vector.dtype, np.number):\n+            if np.isin(vector, [0, 1, np.nan]).all():\n+                return VarType(boolean_type)\n+        elif not hasattr(vector, 'dtype'):\n+            # For non-array types, try the check but catch any errors\n+            try:\n+                if np.isin(vector, [0, 1, np.nan]).all():\n+                    return VarType(boolean_type)\n+            except (TypeError, ValueError):\n+                pass\n \n     # Defer to positive pandas tests\n     if pd.api.types.is_numeric_dtype(vector):\n@@ -140,8 +160,40 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n         Ordered list of category levels not including null values.\n \n     \"\"\"\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Input data to find the unique values for, provided in one of the\n+        allowed formats.\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n     if order is not None:\n-        return order\n+        # Filter vector to only include values present in the specified order\n+        # This restores pre-0.11 behavior where points not in hue_order are excluded\n+        if hasattr(vector, 'isin'):\n+            filtered_vector = vector[vector.isin(order)]\n+        else:\n+            filtered_vector = pd.Series(vector)[pd.Series(vector).isin(order)]\n+        \n+        # Return only the values from order that are actually present in the data\n+        if len(filtered_vector) > 0:\n+            present_values = set(filtered_vector.dropna().unique())\n+            return [val for val in order if val in present_values]\n+        else:\n+            return []\n \n     if vector.dtype.name == \"category\":\n         order = list(vector.cat.categories)\n@@ -151,3 +203,60 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n             order.sort()\n \n     return order\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Input data.\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Filter vector to only include values present in the specified order\n+        # This restores the pre-0.11 behavior where data not in order is excluded\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series\n+            filtered_vector = vector[vector.isin(order)]\n+        else:\n+            # For numpy arrays and lists\n+            vector_array = np.asarray(vector)\n+            mask = np.isin(vector_array, order)\n+            filtered_vector = vector_array[mask]\n+        \n+        # Return only the intersection of order and actual values present\n+        if hasattr(filtered_vector, 'unique'):\n+            present_values = set(filtered_vector.unique())\n+        else:\n+            present_values = set(np.unique(filtered_vector))\n+        \n+        # Filter out null values from present values\n+        present_values = {val for val in present_values if pd.notnull(val)}\n+        \n+        # Return order filtered to only include values actually present\n+        return [val for val in order if val in present_values]\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+        order = list(filter(pd.notnull, vector.unique()))\n+        if variable_type(order) == \"numeric\":\n+            order.sort()\n+\n+    return order\n+\n+    return order\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..0b8cc3bc 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1278,7 +1278,13 @@ class PairGrid(Grid):\n             # (and was originally written exclusively that way) but now can delegate\n             # to the axes-level functions, while always handling legend creation.\n             # See GH2307\n+\n             hue_names = hue_order = categorical_order(data[hue], hue_order)\n+            \n+            # Filter data to only include rows where hue value is in hue_order\n+            if hue_order is not None:\n+                mask = data[hue].isin(hue_order)\n+                data = data[mask]\n             if dropna:\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n@@ -2082,7 +2088,31 @@ def pairplot(\n \n     # Set up the PairGrid\n     grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n-    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n+\n+    # Set up the PairGrid\n+    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+    \n+    # Filter data when hue_order is provided to restore pre-0.11 behavior\n+    if hue is not None and hue_order is not None:\n+        # Get the hue column data\n+        if isinstance(data, pd.DataFrame):\n+            hue_data = data[hue] if isinstance(hue, str) else hue\n+        else:\n+            hue_data = hue\n+        \n+        # Create mask for rows where hue value is in hue_order\n+        mask = pd.Series(hue_data).isin(hue_order)\n+        \n+        # Filter the data to only include rows with hue values in hue_order\n+        if isinstance(data, pd.DataFrame):\n+            filtered_data = data[mask]\n+        else:\n+            # If data is not a DataFrame, we can't filter it here\n+            filtered_data = data\n+    else:\n+        filtered_data = data\n+    \n+    grid = PairGrid(filtered_data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                     hue_order=hue_order, palette=palette, corner=corner,\n                     height=height, aspect=aspect, dropna=dropna, **grid_kws)\n \n",
    "variant_1": "diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..b875c568 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -83,8 +83,21 @@ def variable_type(\n             action='ignore',\n             category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n         )\n-        if np.isin(vector, [0, 1, np.nan]).all():\n-            return VarType(boolean_type)\n+\n+    # Because we reduce with .all(), we are agnostic about whether the\n+    # comparison returns a scalar or vector, so we will ignore the warning.\n+    # It triggers a separate DeprecationWarning when the vector has datetimes:\n+    # https://github.com/numpy/numpy/issues/13548\n+    # This is considered a bug by numpy and will likely go away.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\n+            action='ignore',\n+            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n+        )\n+        # Only check for boolean values if the vector is numeric-compatible\n+        if pd.api.types.is_numeric_dtype(vector) or pd.api.types.is_bool_dtype(vector):\n+            if np.isin(vector, [0, 1, np.nan]).all():\n+                return VarType(boolean_type)\n \n     # Defer to positive pandas tests\n     if pd.api.types.is_numeric_dtype(vector):\n@@ -140,8 +153,70 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n         Ordered list of category levels not including null values.\n \n     \"\"\"\n+\n     if order is not None:\n-        return order\n+        # Filter the vector to only include values present in the provided order\n+        # This restores pre-0.11 behavior where data not in hue_order was excluded\n+        if hasattr(vector, 'isin'):\n+            mask = vector.isin(order)\n+            filtered_vector = vector[mask]\n+        else:\n+            # Handle non-pandas arrays\n+            mask = np.isin(vector, order)\n+            filtered_vector = vector[mask]\n+        \n+        # Return only the order values that are actually present in the data\n+        if len(filtered_vector) > 0:\n+            present_values = set(filtered_vector.dropna() if hasattr(filtered_vector, 'dropna') \n+                               else filtered_vector[pd.notnull(filtered_vector)])\n+            return [val for val in order if val in present_values]\n+        else:\n+            return []\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique levels in a categorical variable.\n+\n+    The order is determined by the original data unless specified otherwise\n+    in the `order` argument. This function assumes that the vector contains\n+    some form of categorical data. That includes a pandas Categorical or\n+    a variable that contains a finite number of unique values.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Input data.\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Filter vector to only include values present in the specified order\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series\n+            mask = vector.isin(order)\n+            filtered_vector = vector[mask]\n+        else:\n+            # For numpy arrays or lists\n+            mask = np.isin(vector, order)\n+            filtered_vector = np.array(vector)[mask]\n+        \n+        # Return only the order values that are actually present in the data\n+        if len(filtered_vector) > 0:\n+            present_values = set(filtered_vector)\n+            return [val for val in order if val in present_values]\n+        else:\n+            return []\n \n     if vector.dtype.name == \"category\":\n         order = list(vector.cat.categories)\n@@ -151,3 +226,5 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n             order.sort()\n \n     return order\n+\n+    return order\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..294cfa65 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1278,7 +1278,19 @@ class PairGrid(Grid):\n             # (and was originally written exclusively that way) but now can delegate\n             # to the axes-level functions, while always handling legend creation.\n             # See GH2307\n-            hue_names = hue_order = categorical_order(data[hue], hue_order)\n+\n+        if order is not None:\n+            # When order is provided, filter the vector to only include values present in order\n+            if vector is not None:\n+                # Create a mask for values that are in the order\n+                mask = pd.Series(vector).isin(order)\n+                # Filter vector to only include values present in order\n+                filtered_vector = pd.Series(vector)[mask]\n+                # Return the intersection of order and actual values present in filtered data\n+                present_values = filtered_vector.dropna().unique()\n+                return [x for x in order if x in present_values]\n+            else:\n+                return order\n             if dropna:\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n@@ -2082,6 +2094,7 @@ def pairplot(\n \n     # Set up the PairGrid\n     grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+\n     grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                     hue_order=hue_order, palette=palette, corner=corner,\n                     height=height, aspect=aspect, dropna=dropna, **grid_kws)\n",
    "variant_2": "diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..00403da8 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -83,7 +83,23 @@ def variable_type(\n             action='ignore',\n             category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n         )\n-        if np.isin(vector, [0, 1, np.nan]).all():\n+\n+    # Check for boolean-ish numeric data\n+    # This is a heuristic to identify data that should be treated as boolean,\n+    # even if it comes in as numeric. We require that all values are 0, 1, or NaN\n+    # to preserve the behavior of allowing float data that looks boolean-ish.\n+    # Because we reduce with .all(), we are agnostic about whether the\n+    # comparison returns a scalar or vector, so we will ignore the warning.\n+    # It triggers a separate DeprecationWarning when the vector has datetimes:\n+    # https://github.com/numpy/numpy/issues/13548\n+    # This is considered a bug by numpy and will likely go away.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\n+            action='ignore',\n+            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n+        )\n+        # Only check for boolean values if vector is numeric to avoid TypeError\n+        if pd.api.types.is_numeric_dtype(vector) and np.isin(vector, [0, 1, np.nan]).all():\n             return VarType(boolean_type)\n \n     # Defer to positive pandas tests\n@@ -140,8 +156,90 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n         Ordered list of category levels not including null values.\n \n     \"\"\"\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique levels in `vector`, optionally limited to those\n+    appearing in `order`.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, Categorical, or Series\n+        Vector of \"categorical\" values whose order will be determined.\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Filter to only include values that are actually present in the data\n+        if vector.dtype.name == \"category\":\n+            present_values = set(vector.cat.categories)\n+        else:\n+            present_values = set(filter(pd.notnull, vector.unique()))\n+        \n+        # Return intersection of requested order and actually present values\n+        return [level for level in order if level in present_values]\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+        order = list(filter(pd.notnull, vector.unique()))\n+        if variable_type(order) == \"numeric\":\n+            order.sort()\n+\n+    return order\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n     if order is not None:\n-        return order\n+        # Filter vector to only include values that are in the provided order\n+        # This restores pre-0.11 behavior where points not in hue_order are excluded\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series\n+            mask = vector.isin(order) | vector.isnull()\n+            filtered_vector = vector[mask]\n+        else:\n+            # For numpy arrays or lists\n+            vector_array = np.asarray(vector)\n+            mask = np.isin(vector_array, order) | pd.isnull(vector_array)\n+            filtered_vector = vector_array[mask]\n+        \n+        # Return intersection of order and actual values present in filtered data\n+        if hasattr(filtered_vector, 'unique'):\n+            present_values = set(filtered_vector.unique())\n+        else:\n+            present_values = set(np.unique(filtered_vector))\n+        present_values.discard(None)  # Remove None if present\n+        present_values = {v for v in present_values if pd.notnull(v)}  # Remove NaN values\n+        \n+        # Return order filtered to only include values actually present\n+        return [val for val in order if val in present_values]\n \n     if vector.dtype.name == \"category\":\n         order = list(vector.cat.categories)\n@@ -151,3 +249,5 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n             order.sort()\n \n     return order\n+\n+    return order\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..f4f703a3 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1278,7 +1278,12 @@ class PairGrid(Grid):\n             # (and was originally written exclusively that way) but now can delegate\n             # to the axes-level functions, while always handling legend creation.\n             # See GH2307\n+\n             hue_names = hue_order = categorical_order(data[hue], hue_order)\n+            if hue_order is not None:\n+                # Filter data to only include rows where hue value is in hue_order\n+                mask = data[hue].isin(hue_order)\n+                data = data[mask]\n             if dropna:\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n@@ -2082,9 +2087,47 @@ def pairplot(\n \n     # Set up the PairGrid\n     grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n-    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n-                    hue_order=hue_order, palette=palette, corner=corner,\n-                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = list(filter(pd.notnull, pd.unique(vector)))\n+        if variable_type(vector) == \"numeric\":\n+            order.sort()\n+    else:\n+        # Filter vector to only include values present in the provided order\n+        # This restores pre-0.11 behavior where data not in hue_order is excluded\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series\n+            mask = vector.isin(order)\n+            filtered_vector = vector[mask]\n+        else:\n+            # For numpy arrays and lists\n+            vector_array = np.asarray(vector)\n+            mask = np.isin(vector_array, order)\n+            filtered_vector = vector_array[mask]\n+        \n+        # Return intersection of provided order and values actually present in filtered data\n+        present_values = set(filter(pd.notnull, pd.unique(filtered_vector)))\n+        order = [x for x in order if x in present_values]\n+\n+    return order\n \n     # Add the markers here as PairGrid has figured out how many levels of the\n     # hue variable are needed and we don't want to duplicate that process\n",
    "variant_3": "diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..7f34c4fb 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -83,8 +83,21 @@ def variable_type(\n             action='ignore',\n             category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n         )\n-        if np.isin(vector, [0, 1, np.nan]).all():\n-            return VarType(boolean_type)\n+\n+    # Because we reduce with .all(), we are agnostic about whether the\n+    # comparison returns a scalar or vector, so we will ignore the warning.\n+    # It triggers a separate DeprecationWarning when the vector has datetimes:\n+    # https://github.com/numpy/numpy/issues/13548\n+    # This is considered a bug by numpy and will likely go away.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\n+            action='ignore',\n+            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n+        )\n+        # Only check for boolean pattern if vector contains numeric-compatible data\n+        if pd.api.types.is_numeric_dtype(vector) or pd.api.types.is_bool_dtype(vector):\n+            if np.isin(vector, [0, 1, np.nan]).all():\n+                return VarType(boolean_type)\n \n     # Defer to positive pandas tests\n     if pd.api.types.is_numeric_dtype(vector):\n@@ -140,8 +153,65 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n         Ordered list of category levels not including null values.\n \n     \"\"\"\n+\n     if order is not None:\n-        return order\n+        # Filter vector to only include values present in the provided order\n+        # This restores pre-0.11 behavior where hue_order subsets would exclude non-matching points\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series\n+            mask = vector.isin(order)\n+            filtered_vector = vector[mask]\n+        else:\n+            # For numpy arrays or other array-like objects\n+            mask = np.isin(vector, order)\n+            filtered_vector = vector[mask] if hasattr(vector, '__getitem__') else np.array(vector)[mask]\n+        \n+        # Return intersection of provided order and actual values in filtered data\n+        if len(filtered_vector) > 0:\n+            actual_values = set(pd.unique(filtered_vector))\n+            return [val for val in order if val in actual_values]\n+        else:\n+            return []\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Input data.\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Filter vector to only include values present in the provided order\n+        # This restores pre-0.11 behavior where data not in hue_order is excluded\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series\n+            filtered_vector = vector[vector.isin(order)]\n+        else:\n+            # For numpy arrays or lists\n+            filtered_vector = [x for x in vector if x in order]\n+        \n+        # Return only the order values that are actually present in the data\n+        if hasattr(vector, 'isin'):\n+            present_values = set(filtered_vector.dropna())\n+        else:\n+            present_values = set(x for x in filtered_vector if pd.notnull(x))\n+        \n+        return [x for x in order if x in present_values]\n \n     if vector.dtype.name == \"category\":\n         order = list(vector.cat.categories)\n@@ -151,3 +221,5 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n             order.sort()\n \n     return order\n+\n+    return order\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..5ca4a712 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1278,7 +1278,20 @@ class PairGrid(Grid):\n             # (and was originally written exclusively that way) but now can delegate\n             # to the axes-level functions, while always handling legend creation.\n             # See GH2307\n-            hue_names = hue_order = categorical_order(data[hue], hue_order)\n+\n+            # If an explicit order is given, respect it. Otherwise, try to use the\n+            # order that was passed in originally, and failing that, use the order\n+            # of appearance in the vector. But filter the vector to only include\n+            # values present in the order when order is provided.\n+            if order is not None:\n+                # Filter vector to only include values present in order\n+                if vector is not None:\n+                    mask = pd.Series(vector).isin(order)\n+                    filtered_vector = pd.Series(vector)[mask]\n+                    # Return intersection of order and filtered values, maintaining order\n+                    return [x for x in order if x in filtered_vector.values]\n+                else:\n+                    return order\n             if dropna:\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n@@ -2080,6 +2093,25 @@ def pairplot(\n         else:\n             diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n \n+    # Set up the PairGrid\n+    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+\n+    # Resolve \"auto\" diag kind\n+    if diag_kind == \"auto\":\n+        if hue is None:\n+            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n+        else:\n+            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n+\n+    # Filter data based on hue_order if provided\n+    if hue is not None and hue_order is not None:\n+        # Get the hue column from data\n+        hue_values = data[hue] if isinstance(data, pd.DataFrame) else data.get(hue)\n+        if hue_values is not None:\n+            # Filter data to only include rows where hue value is in hue_order\n+            mask = hue_values.isin(hue_order)\n+            data = data[mask] if isinstance(data, pd.DataFrame) else data.loc[mask]\n+\n     # Set up the PairGrid\n     grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n     grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n",
    "variant_4": "diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..2065db38 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -83,7 +83,19 @@ def variable_type(\n             action='ignore',\n             category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n         )\n-        if np.isin(vector, [0, 1, np.nan]).all():\n+\n+    # Because we reduce with .all(), we are agnostic about whether the\n+    # comparison returns a scalar or vector, so we will ignore the warning.\n+    # It triggers a separate DeprecationWarning when the vector has datetimes:\n+    # https://github.com/numpy/numpy/issues/13548\n+    # This is considered a bug by numpy and will likely go away.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\n+            action='ignore',\n+            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n+        )\n+        # Check if vector is numeric-compatible before applying np.isin with np.nan\n+        if pd.api.types.is_numeric_dtype(vector) and np.isin(vector, [0, 1, np.nan]).all():\n             return VarType(boolean_type)\n \n     # Defer to positive pandas tests\n@@ -140,7 +152,46 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n         Ordered list of category levels not including null values.\n \n     \"\"\"\n+\n     if order is not None:\n+        # Filter vector to only include values present in the provided order\n+        # This restores pre-0.11 behavior where points not in hue_order are excluded\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series\n+            mask = vector.isin(order)\n+            vector = vector[mask]\n+        else:\n+            # For numpy arrays or other array-like objects\n+            vector = vector[np.isin(vector, order)]\n+        return order\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Determine an ordered list of levels in ``data``.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Filter the vector to only include values that are in the provided order\n+        filtered_vector = vector[vector.isin(order)] if hasattr(vector, 'isin') else vector\n         return order\n \n     if vector.dtype.name == \"category\":\n@@ -151,3 +202,5 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n             order.sort()\n \n     return order\n+\n+    return order\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..bc407322 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1278,7 +1278,47 @@ class PairGrid(Grid):\n             # (and was originally written exclusively that way) but now can delegate\n             # to the axes-level functions, while always handling legend creation.\n             # See GH2307\n-            hue_names = hue_order = categorical_order(data[hue], hue_order)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector, dtype=\"category\").cat.categories\n+    elif pd.api.types.is_list_like(order):\n+        # Filter vector to only include values present in the provided order\n+        # This restores pre-0.11 behavior where points not in hue_order are excluded\n+        if hasattr(vector, 'loc'):\n+            # Handle pandas Series/DataFrame\n+            mask = vector.isin(order)\n+            vector = vector[mask]\n+        else:\n+            # Handle numpy arrays and lists\n+            vector = np.array(vector)\n+            mask = np.isin(vector, order)\n+            vector = vector[mask]\n+        \n+        # Return the intersection of order and actual values present in filtered data\n+        present_values = pd.Series(vector, dtype=\"category\").cat.categories\n+        order = [val for val in order if val in present_values]\n+    else:\n+        err = \"Provided `order` is not list-like\"\n+        raise TypeError(err)\n+    return list(filter(pd.notnull, order))\n             if dropna:\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n@@ -2080,6 +2120,30 @@ def pairplot(\n         else:\n             diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n \n+    # Set up the PairGrid\n+    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+\n+    # Resolve \"auto\" diag kind\n+    if diag_kind == \"auto\":\n+        if hue is None:\n+            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n+        else:\n+            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n+\n+    # Filter data based on hue_order if provided\n+    if hue is not None and hue_order is not None:\n+        # Get the hue column data\n+        hue_data = data[hue] if isinstance(data, pd.DataFrame) else data\n+        # Filter data to only include rows where hue value is in hue_order\n+        if isinstance(data, pd.DataFrame):\n+            mask = data[hue].isin(hue_order)\n+            data = data[mask]\n+        else:\n+            # Handle case where data might be a different format\n+            mask = pd.Series(hue_data).isin(hue_order)\n+            if hasattr(data, 'loc'):\n+                data = data.loc[mask]\n+\n     # Set up the PairGrid\n     grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n     grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n",
    "variant_5": "diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..cdad0818 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -83,8 +83,21 @@ def variable_type(\n             action='ignore',\n             category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n         )\n-        if np.isin(vector, [0, 1, np.nan]).all():\n-            return VarType(boolean_type)\n+\n+    # Because we reduce with .all(), we are agnostic about whether the\n+    # comparison returns a scalar or vector, so we will ignore the warning.\n+    # It triggers a separate DeprecationWarning when the vector has datetimes:\n+    # https://github.com/numpy/numpy/issues/13548\n+    # This is considered a bug by numpy and will likely go away.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\n+            action='ignore',\n+            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n+        )\n+        # Only check for boolean values if vector contains numeric-compatible data\n+        if pd.api.types.is_numeric_dtype(vector):\n+            if np.isin(vector, [0, 1, np.nan]).all():\n+                return VarType(boolean_type)\n \n     # Defer to positive pandas tests\n     if pd.api.types.is_numeric_dtype(vector):\n@@ -139,9 +152,76 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n     order : list\n         Ordered list of category levels not including null values.\n \n+    \"\"\"\n+\n+    if order is not None:\n+        # Filter the vector to only include values present in the provided order\n+        # This restores pre-0.11 behavior where points not in hue_order are excluded\n+        mask = vector.isin(order)\n+        filtered_vector = vector[mask]\n+        if len(filtered_vector) == 0:\n+            return order\n+        # Return only the order values that are actually present in the data\n+        present_values = filtered_vector.unique()\n+        return [val for val in order if val in present_values]\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique levels in a categorical variable.\n+\n+    The order of the returned levels follows these rules:\n+\n+    1. If the `order` parameter is given, use it as-is.\n+    2. Otherwise, if the variable has a \"category\" dtype, use `categories`.\n+    3. Otherwise, use the order of appearance in the data.\n+\n+    The `order` parameter is useful when you need a specific ordering that\n+    may be different from what the data would imply. It can also be used\n+    to subset the data (either by passing fewer levels than are present\n+    in the data, or by passing levels that do not appear in the data).\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Input data.\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n     \"\"\"\n     if order is not None:\n-        return order\n+        # Filter vector to only include values that are in the provided order\n+        # This restores the pre-0.11 behavior where data gets filtered to match hue_order\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series\n+            mask = vector.isin(order) | vector.isnull()\n+            filtered_vector = vector[mask]\n+        else:\n+            # For array-like objects\n+            vector_array = np.asarray(vector)\n+            mask = np.isin(vector_array, order) | pd.isnull(vector_array)\n+            filtered_vector = vector_array[mask]\n+        \n+        # Return only the levels from order that actually appear in the filtered data\n+        if hasattr(filtered_vector, 'unique'):\n+            present_values = set(filtered_vector.unique())\n+        else:\n+            present_values = set(np.unique(filtered_vector))\n+        \n+        # Remove null values from present_values\n+        present_values = {val for val in present_values if pd.notnull(val)}\n+        \n+        # Return order filtered to only include values that are actually present\n+        return [level for level in order if level in present_values]\n \n     if vector.dtype.name == \"category\":\n         order = list(vector.cat.categories)\n@@ -151,3 +231,5 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n             order.sort()\n \n     return order\n+\n+    return order\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..3bf9e3d1 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1278,7 +1278,13 @@ class PairGrid(Grid):\n             # (and was originally written exclusively that way) but now can delegate\n             # to the axes-level functions, while always handling legend creation.\n             # See GH2307\n+\n             hue_names = hue_order = categorical_order(data[hue], hue_order)\n+            if hue_order is not None:\n+                # Filter data to only include rows where hue value is in hue_order\n+                # This restores pre-0.11 behavior of excluding points not in hue_order\n+                mask = data[hue].isin(hue_order)\n+                data = data.loc[mask]\n             if dropna:\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n@@ -2082,6 +2088,19 @@ def pairplot(\n \n     # Set up the PairGrid\n     grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+\n+    # Set up the PairGrid\n+    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+    \n+    # Filter data to match hue_order if provided to restore pre-0.11 behavior\n+    if hue is not None and hue_order is not None:\n+        # Get the hue column from data\n+        hue_col = data[hue] if isinstance(data, pd.DataFrame) else data.get(hue)\n+        if hue_col is not None:\n+            # Filter data to only include rows where hue value is in hue_order\n+            mask = hue_col.isin(hue_order)\n+            data = data[mask] if isinstance(data, pd.DataFrame) else data.loc[mask]\n+    \n     grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                     hue_order=hue_order, palette=palette, corner=corner,\n                     height=height, aspect=aspect, dropna=dropna, **grid_kws)\n",
    "variant_6": "diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..b1e35ece 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -83,8 +83,21 @@ def variable_type(\n             action='ignore',\n             category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n         )\n-        if np.isin(vector, [0, 1, np.nan]).all():\n-            return VarType(boolean_type)\n+\n+    # Because we reduce with .all(), we are agnostic about whether the\n+    # comparison returns a scalar or vector, so we will ignore the warning.\n+    # It triggers a separate DeprecationWarning when the vector has datetimes:\n+    # https://github.com/numpy/numpy/issues/13548\n+    # This is considered a bug by numpy and will likely go away.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\n+            action='ignore',\n+            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n+        )\n+        # Only check for boolean values if vector contains numeric-compatible data\n+        if pd.api.types.is_numeric_dtype(vector) or pd.api.types.is_bool_dtype(vector):\n+            if np.isin(vector, [0, 1, np.nan]).all():\n+                return VarType(boolean_type)\n \n     # Defer to positive pandas tests\n     if pd.api.types.is_numeric_dtype(vector):\n@@ -139,9 +152,65 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n     order : list\n         Ordered list of category levels not including null values.\n \n+    \"\"\"\n+\n+    if order is not None:\n+        # Filter vector to only include values that are in the provided order\n+        # This restores pre-0.11 behavior where points not in hue_order are excluded\n+        mask = vector.isin(order)\n+        filtered_vector = vector[mask]\n+        if len(filtered_vector) == 0:\n+            return []\n+        # Return only the order values that are actually present in the data\n+        present_values = set(filtered_vector.dropna().unique())\n+        return [val for val in order if val in present_values]\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    The ordering rules are:\n+    - If the data have a categorical dtype, use the category order\n+    - Otherwise, use the order of appearance in the data\n+\n+    The `order` parameter is used to override this default behavior or\n+    to filter the data to only include values present in both the data\n+    and the specified order.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Input data.\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the data object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n     \"\"\"\n     if order is not None:\n-        return order\n+        # Filter vector to only include values that are in the specified order\n+        # This restores the pre-0.11 behavior where data not in hue_order was excluded\n+        if hasattr(vector, 'isin'):\n+            vector = vector[vector.isin(order)]\n+        else:\n+            vector = pd.Series(vector)\n+            vector = vector[vector.isin(order)]\n+        \n+        # Return only the intersection of order and actual values present in filtered data\n+        if len(vector) == 0:\n+            return []\n+        \n+        # Get unique values from filtered vector while preserving order\n+        present_values = set(vector.dropna().unique()) if hasattr(vector, 'dropna') else set(pd.Series(vector).dropna().unique())\n+        return [val for val in order if val in present_values]\n \n     if vector.dtype.name == \"category\":\n         order = list(vector.cat.categories)\n@@ -151,3 +220,5 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n             order.sort()\n \n     return order\n+\n+    return order\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..3d75b2e9 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1278,7 +1278,17 @@ class PairGrid(Grid):\n             # (and was originally written exclusively that way) but now can delegate\n             # to the axes-level functions, while always handling legend creation.\n             # See GH2307\n-            hue_names = hue_order = categorical_order(data[hue], hue_order)\n+\n+        if order is not None:\n+            # Filter the vector to only include values present in the order\n+            if vector is not None:\n+                mask = pd.Series(vector).isin(order)\n+                filtered_vector = pd.Series(vector)[mask]\n+                # Return only the values from order that are actually present in the filtered data\n+                present_values = filtered_vector.unique()\n+                return [val for val in order if val in present_values]\n+            else:\n+                return order\n             if dropna:\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n@@ -2080,6 +2090,22 @@ def pairplot(\n         else:\n             diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n \n+    # Set up the PairGrid\n+    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+\n+    # Resolve \"auto\" diag kind\n+    if diag_kind == \"auto\":\n+        if hue is None:\n+            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n+        else:\n+            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n+\n+    # Filter data when hue_order is provided to maintain pre-0.11 behavior\n+    if hue is not None and hue_order is not None:\n+        # Only keep rows where hue value is in hue_order\n+        hue_mask = data[hue].isin(hue_order)\n+        data = data[hue_mask]\n+\n     # Set up the PairGrid\n     grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n     grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n",
    "variant_7": "diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..9b365f68 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -83,7 +83,19 @@ def variable_type(\n             action='ignore',\n             category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n         )\n-        if np.isin(vector, [0, 1, np.nan]).all():\n+\n+    # Because we reduce with .all(), we are agnostic about whether the\n+    # comparison returns a scalar or vector, so we will ignore the warning.\n+    # It triggers a separate DeprecationWarning when the vector has datetimes:\n+    # https://github.com/numpy/numpy/issues/13548\n+    # This is considered a bug by numpy and will likely go away.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\n+            action='ignore',\n+            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n+        )\n+        # Check if vector contains numeric-compatible data before applying np.isin with np.nan\n+        if pd.api.types.is_numeric_dtype(vector) and np.isin(vector, [0, 1, np.nan]).all():\n             return VarType(boolean_type)\n \n     # Defer to positive pandas tests\n@@ -140,8 +152,93 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n         Ordered list of category levels not including null values.\n \n     \"\"\"\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique levels in ``vector``, using the order specified\n+    in ``order`` when possible.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, Categorical, or Series\n+        Vector of \"categorical\" values whose order will be determined.\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Filter vector to only include values that are in the specified order\n+        if hasattr(vector, 'isin'):\n+            mask = vector.isin(order)\n+        else:\n+            mask = pd.Series(vector).isin(order)\n+        \n+        # Return only the values from order that are actually present in the filtered data\n+        if hasattr(vector, 'iloc'):\n+            present_values = set(vector[mask].dropna().unique())\n+        else:\n+            present_values = set(pd.Series(vector)[mask].dropna().unique())\n+        \n+        return [val for val in order if val in present_values]\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+        order = list(filter(pd.notnull, vector.unique()))\n+        if variable_type(order) == \"numeric\":\n+            order.sort()\n+\n+    return order\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Input data.\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n     if order is not None:\n-        return order\n+        # Filter vector to only include values present in the specified order\n+        # This restores pre-0.11 behavior where data not in hue_order is excluded\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series\n+            filtered_vector = vector[vector.isin(order)]\n+        else:\n+            # For numpy arrays or lists\n+            vector_array = np.asarray(vector)\n+            mask = np.isin(vector_array, order)\n+            filtered_vector = vector_array[mask]\n+        \n+        # Return only the intersection of order and actual values present\n+        if len(filtered_vector) > 0:\n+            if hasattr(filtered_vector, 'unique'):\n+                present_values = set(filtered_vector.unique())\n+            else:\n+                present_values = set(np.unique(filtered_vector))\n+            return [x for x in order if x in present_values]\n+        else:\n+            return []\n \n     if vector.dtype.name == \"category\":\n         order = list(vector.cat.categories)\n@@ -151,3 +248,5 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n             order.sort()\n \n     return order\n+\n+    return order\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..f9de8d9d 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1278,7 +1278,21 @@ class PairGrid(Grid):\n             # (and was originally written exclusively that way) but now can delegate\n             # to the axes-level functions, while always handling legend creation.\n             # See GH2307\n-            hue_names = hue_order = categorical_order(data[hue], hue_order)\n+\n+        if order is not None:\n+            # Filter the vector to only include values that are in the provided order\n+            if pd.api.types.is_categorical_dtype(vector):\n+                # For categorical data, filter based on categories\n+                mask = vector.isin(order)\n+                filtered_vector = vector[mask]\n+            else:\n+                # For non-categorical data, filter based on values\n+                mask = pd.Series(vector).isin(order)\n+                filtered_vector = pd.Series(vector)[mask]\n+            \n+            # Return the intersection of order and actual values present in filtered data\n+            present_values = pd.Series(filtered_vector).dropna().unique()\n+            return [x for x in order if x in present_values]\n             if dropna:\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n@@ -2082,6 +2096,30 @@ def pairplot(\n \n     # Set up the PairGrid\n     grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+\n+    # Set up the PairGrid\n+    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+    \n+    # Filter data when hue_order is provided to match pre-0.11 behavior\n+    if hue is not None and hue_order is not None:\n+        # Get the hue column data\n+        hue_data = data[hue] if isinstance(data, pd.DataFrame) else data.get(hue)\n+        if hue_data is not None:\n+            # Create mask for rows where hue value is in hue_order\n+            mask = hue_data.isin(hue_order)\n+            # Filter the data to only include rows with hue values in hue_order\n+            if isinstance(data, pd.DataFrame):\n+                data = data[mask]\n+            else:\n+                # Handle dict-like data\n+                filtered_data = {}\n+                for key, values in data.items():\n+                    if hasattr(values, '__len__') and len(values) == len(mask):\n+                        filtered_data[key] = np.array(values)[mask]\n+                    else:\n+                        filtered_data[key] = values\n+                data = filtered_data\n+    \n     grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                     hue_order=hue_order, palette=palette, corner=corner,\n                     height=height, aspect=aspect, dropna=dropna, **grid_kws)\n",
    "variant_8": "diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..48db1806 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -83,8 +83,21 @@ def variable_type(\n             action='ignore',\n             category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n         )\n-        if np.isin(vector, [0, 1, np.nan]).all():\n-            return VarType(boolean_type)\n+\n+    # Because we reduce with .all(), we are agnostic about whether the\n+    # comparison returns a scalar or vector, so we will ignore the warning.\n+    # It triggers a separate DeprecationWarning when the vector has datetimes:\n+    # https://github.com/numpy/numpy/issues/13548\n+    # This is considered a bug by numpy and will likely go away.\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\n+            action='ignore',\n+            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n+        )\n+        # Only check for boolean type if vector contains numeric-compatible data\n+        if pd.api.types.is_numeric_dtype(vector) or pd.api.types.is_bool_dtype(vector):\n+            if np.isin(vector, [0, 1, np.nan]).all():\n+                return VarType(boolean_type)\n \n     # Defer to positive pandas tests\n     if pd.api.types.is_numeric_dtype(vector):\n@@ -140,8 +153,82 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n         Ordered list of category levels not including null values.\n \n     \"\"\"\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Vector of \"categorical\" values\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Filter vector to only include values that are in the provided order\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series\n+            filtered_vector = vector[vector.isin(order)]\n+        else:\n+            # For arrays/lists\n+            filtered_vector = [x for x in vector if x in order]\n+        \n+        # Return only the order items that actually exist in the data\n+        if len(filtered_vector) > 0:\n+            if hasattr(filtered_vector, 'unique'):\n+                existing_values = set(filtered_vector.unique())\n+            else:\n+                existing_values = set(filtered_vector)\n+            return [x for x in order if x in existing_values]\n+        else:\n+            return []\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+        order = list(filter(pd.notnull, vector.unique()))\n+        if variable_type(order) == \"numeric\":\n+            order.sort()\n+\n+    return order\n+\n+    if vector.dtype.name == \"category\":\n+        order = list(vector.cat.categories)\n+    else:\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Input data.\n+    order : list\n+        Desired order of category levels. If not provided, this will be the\n+        order that the unique values appear in the data.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n     if order is not None:\n-        return order\n+        # Filter vector to only include values present in the provided order\n+        # This restores the pre-0.11 behavior where data not in hue_order is excluded\n+        mask = pd.Series(vector).isin(order)\n+        filtered_vector = pd.Series(vector)[mask]\n+        # Return only the values from order that are actually present in the data\n+        return [val for val in order if val in filtered_vector.values]\n \n     if vector.dtype.name == \"category\":\n         order = list(vector.cat.categories)\n@@ -151,3 +238,5 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n             order.sort()\n \n     return order\n+\n+    return order\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..fc0ee636 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1278,7 +1278,16 @@ class PairGrid(Grid):\n             # (and was originally written exclusively that way) but now can delegate\n             # to the axes-level functions, while always handling legend creation.\n             # See GH2307\n-            hue_names = hue_order = categorical_order(data[hue], hue_order)\n+\n+        if order is not None:\n+            # Filter the vector to only include values that are in the provided order\n+            if vector is not None and len(vector) > 0:\n+                mask = pd.Series(vector).isin(order)\n+                filtered_vector = pd.Series(vector)[mask]\n+                # Return only the order values that are actually present in the filtered data\n+                present_values = pd.Series(order)[pd.Series(order).isin(filtered_vector)]\n+                return present_values.tolist() if len(present_values) > 0 else order\n+            return order\n             if dropna:\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n@@ -2080,6 +2089,24 @@ def pairplot(\n         else:\n             diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n \n+    # Set up the PairGrid\n+    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n+\n+    # Resolve \"auto\" diag kind\n+    if diag_kind == \"auto\":\n+        if hue is None:\n+            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n+        else:\n+            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n+\n+    # Filter data when hue_order is provided to restore pre-0.11 behavior\n+    if hue is not None and hue_order is not None:\n+        # Get the hue column from data\n+        if isinstance(data, pd.DataFrame):\n+            if hue in data.columns:\n+                # Filter data to only include rows where hue value is in hue_order\n+                data = data[data[hue].isin(hue_order)]\n+\n     # Set up the PairGrid\n     grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n     grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n"
  }
}