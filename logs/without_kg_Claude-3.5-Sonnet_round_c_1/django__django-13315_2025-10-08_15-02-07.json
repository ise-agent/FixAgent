{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/forms/models.py lines 1154-1162)": "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
    "Location 2 (/root/hy/projects_1/django/django/forms/models.py lines 1211-1219)": "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        \n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        limit_choices_to = self.field.get_limit_choices_to()\n        if limit_choices_to:\n            queryset = queryset.complex_filter(limit_choices_to)\n        \n        # Ensure the queryset is ordered.\n        if queryset._result_cache is not None and not queryset.ordered:\n            queryset = queryset.order_by()\n        for obj in queryset:\n            yield self.choice(obj)\n",
    "Location 3 (/root/hy/projects_1/django/django/forms/models.py lines 98-103)": "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n",
    "Location 4 (/root/hy/projects_1/django/django/forms/models.py lines 1247-1260)": "\n    def _get_choices(self):\n        # If self._choices is set, then somebody must have manually set\n        # the property self.choices. In this case, just return self._choices.\n        if hasattr(self, '_choices'):\n            return self._choices\n\n        # Otherwise, execute the QuerySet in self.queryset to determine the\n        # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n        # time _get_choices() is called (and, thus, each time self.choices is\n        # accessed) so that we can ensure the QuerySet has not been consumed. This\n        # construct might look complicated but it allows for lazy evaluation of\n        # the queryset.\n        queryset = self.queryset\n        if hasattr(self, 'get_limit_choices_to'):\n            limit_choices_to = self.get_limit_choices_to()\n            if limit_choices_to:\n                queryset = queryset.complex_filter(limit_choices_to)\n        return self.iterator(self.__class__(queryset=queryset))\n",
    "Location 5 (/root/hy/projects_1/django/django/db/models/fields/related.py lines 984-995)": "\ndef formfield(self, *, using=None, **kwargs):\n    if isinstance(self.remote_field.model, str):\n        raise ValueError(\"Cannot create form field for %r yet, because \"\n                         \"its related model %r has not been loaded yet\" %\n                         (self.name, self.remote_field.model))\n    defaults = {\n        'form_class': forms.ModelChoiceField,\n        'queryset': self.remote_field.model._default_manager.using(using),\n        'to_field_name': self.remote_field.field_name,\n        'blank': self.blank,\n    }\n    defaults.update(kwargs)\n    return super().formfield(**defaults)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/forms/models.py lines 1154-1162)": [
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.sql.query import Q\n            limit_choices_to = self.field.limit_choices_to\n            if isinstance(limit_choices_to, Q):\n                queryset = queryset.filter(limit_choices_to)\n            elif isinstance(limit_choices_to, dict):\n                queryset = queryset.filter(**limit_choices_to)\n            else:\n                # Handle callable limit_choices_to\n                if callable(limit_choices_to):\n                    limit_choices_to = limit_choices_to()\n                if isinstance(limit_choices_to, Q):\n                    queryset = queryset.filter(limit_choices_to)\n                elif isinstance(limit_choices_to, dict):\n                    queryset = queryset.filter(**limit_choices_to)\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.sql.query import Q\n            from django.db.models.query_utils import Q as QueryQ\n            \n            limit_choices_to = self.field.limit_choices_to\n            if isinstance(limit_choices_to, (Q, QueryQ)):\n                queryset = queryset.filter(limit_choices_to)\n            elif isinstance(limit_choices_to, dict):\n                queryset = queryset.filter(**limit_choices_to)\n            else:\n                queryset = queryset.complex_filter(limit_choices_to)\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/forms/models.py lines 1211-1219)": [
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to if it exists\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            limit_choices_to = self.field.get_limit_choices_to()\n            queryset = queryset.complex_filter(limit_choices_to)\n        # Ensure iterator is evaluated in a consistent manner\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        \n        # Apply limit_choices_to filtering if present\n        queryset = self.queryset\n        if hasattr(self.field, 'limit_choices_to'):\n            limit_choices_to = self.field.get_limit_choices_to()\n            if limit_choices_to:\n                queryset = queryset.complex_filter(limit_choices_to)\n        \n        queryset = queryset.distinct() if queryset is not None else self.queryset\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        \n        queryset = self.queryset\n        \n        # Apply limit_choices_to filtering if present\n        limit_choices_to = self.field.get_limit_choices_to()\n        if limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(limit_choices_to)\n        \n        # Prefetch the objects into a list to avoid issues with nested database queries\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if present\n        limit_choices_to = self.field.get_limit_choices_to()\n        if limit_choices_to:\n            queryset = queryset.complex_filter(limit_choices_to)\n        # Ensure queryset is distinct to avoid duplicates from joins\n        if limit_choices_to:\n            queryset = queryset.distinct()\n        if self.field.cache_choices:\n            if self.field.choice_cache is None:\n                self.field.choice_cache = [\n                    self.choice(obj) for obj in queryset\n                ]\n            for choice in self.field.choice_cache:\n                yield choice\n        else:\n            for obj in queryset:\n                yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if present\n        limit_choices_to = self.field.get_limit_choices_to()\n        if limit_choices_to:\n            queryset = queryset.complex_filter(limit_choices_to)\n        # Only check for duplicates if we have a to_field_name\n        if self.field.to_field_name:\n            queryset = queryset.distinct()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if it exists\n        if hasattr(self.field, 'limit_choices_to'):\n            limit_choices_to = self.field.get_limit_choices_to()\n            if limit_choices_to:\n                queryset = queryset.complex_filter(limit_choices_to)\n        # Ensure queryset is evaluated only once and is ordered.\n        queryset = queryset.order_by().distinct()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        \n        queryset = self.queryset\n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to'):\n            limit_choices_to = self.field.get_limit_choices_to()\n            if limit_choices_to:\n                queryset = queryset.complex_filter(limit_choices_to)\n        \n        # Prefetch the objects into a list to avoid database hits\n        # during yield.\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to'):\n            limit_choices_to = self.field.get_limit_choices_to()\n            if limit_choices_to:\n                queryset = queryset.complex_filter(limit_choices_to)\n        # Ensure queryset is distinct to avoid duplicates from joins\n        queryset = queryset.distinct()\n        if self.field.to_field_name:\n            to_field_name = self.field.to_field_name\n        else:\n            to_field_name = queryset.model._meta.pk.attname\n        for obj in queryset:\n            yield (getattr(obj, to_field_name), self.field.label_from_instance(obj))\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/forms/models.py lines 98-103)": [
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n",
      "\ndef __iter__(self):\n    if self.field.empty_label is not None:\n        yield (\"\", self.field.empty_label)\n    queryset = self.queryset\n    # Apply limit_choices_to filtering if it exists\n    if hasattr(self.field, 'get_limit_choices_to'):\n        limit_choices_to = self.field.get_limit_choices_to()\n        if limit_choices_to is not None:\n            queryset = queryset.complex_filter(limit_choices_to)\n    # Ensure queryset is evaluated to prevent caching issues\n    queryset = queryset.all()\n    for obj in queryset:\n        yield self.choice(obj)\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n",
      "\ndef __iter__(self):\n    if self.field.empty_label is not None:\n        yield (\"\", self.field.empty_label)\n    \n    # Apply limit_choices_to filtering if available\n    queryset = self.queryset\n    if hasattr(self.field, 'get_limit_choices_to'):\n        limit_choices_to = self.field.get_limit_choices_to()\n        if limit_choices_to is not None:\n            queryset = queryset.complex_filter(limit_choices_to)\n    \n    queryset = queryset.all()\n    # Prevent a second database query when the queryset is evaluated.\n    queryset._result_cache = None\n    for obj in queryset:\n        yield self.choice(obj)\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/forms/models.py lines 1247-1260)": [
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if it exists\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            limit_choices_to = self.field.limit_choices_to\n            if isinstance(limit_choices_to, Q):\n                queryset = queryset.filter(limit_choices_to)\n            elif isinstance(limit_choices_to, dict):\n                queryset = queryset.filter(**limit_choices_to)\n        # Ensure the queryset is evaluated only once.\n        queryset = queryset.iterator() if queryset._result_cache is None else iter(queryset)\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if it exists\n        if hasattr(self.field, 'get_limit_choices_to'):\n            limit_choices_to = self.field.get_limit_choices_to()\n            if limit_choices_to:\n                queryset = queryset.complex_filter(limit_choices_to)\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        \n        queryset = self.queryset\n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'get_limit_choices_to'):\n            limit_choices_to = self.field.get_limit_choices_to()\n            if limit_choices_to:\n                queryset = queryset.complex_filter(limit_choices_to)\n        \n        # Ensure the queryset is evaluated at this point. This is a performance\n        # optimization that prevents multiple database calls when rendering\n        # this field in a template.\n        if queryset._result_cache is None:\n            queryset._fetch_all()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def _get_choices(self):\n        # If self._choices is set, then somebody must have manually set\n        # the property self.choices. In this case, just return self._choices.\n        if hasattr(self, '_choices'):\n            return self._choices\n\n        # Otherwise, execute the QuerySet in self.queryset to determine the\n        # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n        # time _get_choices() is called (and, thus, each time self.choices is\n        # accessed) so that we can ensure the QuerySet has not been consumed. This\n        # construct might look complicated but it allows for lazy evaluation of\n        # the queryset.\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if present\n        limit_choices_to = self.get_limit_choices_to()\n        if limit_choices_to:\n            queryset = queryset.complex_filter(limit_choices_to)\n        \n        # Create iterator with the filtered queryset\n        iterator = self.iterator.__new__(self.iterator)\n        iterator.field = self\n        iterator.queryset = queryset\n        return iterator\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if it exists\n        limit_choices_to = self.field.get_limit_choices_to()\n        if limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            if isinstance(limit_choices_to, Q):\n                queryset = queryset.filter(limit_choices_to)\n            else:\n                queryset = queryset.complex_filter(limit_choices_to)\n        # Ensure the queryset is evaluated only once\n        if queryset._result_cache is not None:\n            yield from self.choice(obj) for obj in queryset._result_cache\n        else:\n            yield from (self.choice(obj) for obj in queryset.iterator())\n",
      "\ndef _get_choices(self):\n    # If self._choices is set, then somebody must have manually set\n    # the property self.choices. In this case, just return self._choices.\n    if hasattr(self, '_choices'):\n        return self._choices\n\n    # Otherwise, execute the QuerySet in self.queryset to determine the\n    # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n    # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n    # time _get_choices() is called (and, thus, each time self.choices is\n    # accessed) so that we can ensure the QuerySet has not been consumed. This\n    # construct might look complicated but it allows for lazy evaluation of\n    # the queryset.\n    queryset = self.queryset\n    # Apply limit_choices_to filtering if present\n    limit_choices_to = self.get_limit_choices_to()\n    if limit_choices_to:\n        queryset = queryset.complex_filter(limit_choices_to)\n    return self.iterator(self)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if it exists\n        if hasattr(self.field, 'get_limit_choices_to'):\n            limit_choices_to = self.field.get_limit_choices_to()\n            if limit_choices_to:\n                from django.db.models.sql.query import Query\n                queryset = queryset.complex_filter(limit_choices_to)\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering to prevent duplicates from joins\n        limit_choices_to = self.field.get_limit_choices_to()\n        if limit_choices_to:\n            queryset = queryset.complex_filter(limit_choices_to)\n        # Ensure the queryset is distinct to handle any remaining duplicates\n        queryset = queryset.distinct()\n        for obj in queryset:\n            yield self.choice(obj)\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/models/fields/related.py lines 984-995)": [
      "\n    def formfield(self, *, using=None, **kwargs):\n        if isinstance(self.remote_field.model, str):\n            raise ValueError(\"Cannot create form field for %r yet, because \"\n                             \"its related model %r has not been loaded yet\" %\n                             (self.name, self.remote_field.model))\n        \n        # Get the base queryset\n        queryset = self.remote_field.model._default_manager.using(using)\n        \n        # Apply limit_choices_to filtering if present\n        limit_choices_to = self.get_limit_choices_to()\n        if limit_choices_to:\n            from django.db.models.query_utils import Q\n            complex_filter = limit_choices_to\n            if not isinstance(complex_filter, Q):\n                complex_filter = Q(**complex_filter)\n            queryset = queryset.filter(complex_filter)\n        \n        return super().formfield(**{\n            'form_class': forms.ModelChoiceField,\n            'queryset': queryset,\n            'to_field_name': self.remote_field.field_name,\n            **kwargs,\n            'blank': self.blank,\n        })\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            if self.field.limit_choices_to:\n                complex_filter = self.field.limit_choices_to\n                if complex_filter:\n                    queryset = queryset.complex_filter(complex_filter)\n        # Ensure queryset is evaluated only once\n        yield from self.choice_func(queryset)\n",
      "\ndef formfield(self, *, using=None, **kwargs):\n    if isinstance(self.remote_field.model, str):\n        raise ValueError(\"Cannot create form field for %r yet, because \"\n                         \"its related model %r has not been loaded yet\" %\n                         (self.name, self.remote_field.model))\n    \n    # Get the base queryset\n    queryset = self.remote_field.model._default_manager.using(using)\n    \n    # Apply limit_choices_to filtering if present\n    limit_choices_to = self.get_limit_choices_to()\n    if limit_choices_to:\n        queryset = queryset.complex_filter(limit_choices_to)\n    \n    return super().formfield(**{\n        'form_class': forms.ModelChoiceField,\n        'queryset': queryset,\n        'to_field_name': self.remote_field.field_name,\n        **kwargs,\n        'blank': self.blank,\n    })\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Apply limit_choices_to filtering if it exists\n        if hasattr(self.field, 'get_limit_choices_to'):\n            limit_choices_to = self.field.get_limit_choices_to()\n            if limit_choices_to:\n                from django.db.models.query_utils import Q\n                from django.db.models.sql.query import Query\n                if isinstance(limit_choices_to, Q):\n                    queryset = queryset.filter(limit_choices_to)\n                elif isinstance(limit_choices_to, dict):\n                    queryset = queryset.filter(**limit_choices_to)\n        # Use distinct() to eliminate any potential duplicates from joins\n        queryset = queryset.distinct()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\ndef __iter__(self):\n    if self.field.empty_label is not None:\n        yield (\"\", self.field.empty_label)\n    queryset = self.queryset\n    # Apply limit_choices_to filtering if present\n    if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n        from django.db.models.query_utils import Q\n        from django.db.models.sql.query import Query\n        \n        limit_choices_to = self.field.limit_choices_to\n        if isinstance(limit_choices_to, Q):\n            queryset = queryset.filter(limit_choices_to)\n        elif isinstance(limit_choices_to, dict):\n            queryset = queryset.filter(**limit_choices_to)\n        else:\n            # Handle other types that might be callable\n            if callable(limit_choices_to):\n                limit_choices_to = limit_choices_to()\n            queryset = queryset.complex_filter(limit_choices_to)\n    \n    # Ensure distinct results to avoid duplicates from joins\n    queryset = queryset.distinct()\n    \n    for obj in queryset:\n        yield self.choice(obj)\n",
      "\n    def formfield(self, *, using=None, **kwargs):\n        if isinstance(self.remote_field.model, str):\n            raise ValueError(\"Cannot create form field for %r yet, because \"\n                             \"its related model %r has not been loaded yet\" %\n                             (self.name, self.remote_field.model))\n        \n        # Get the base queryset\n        queryset = self.remote_field.model._default_manager.using(using)\n        \n        # Apply limit_choices_to filtering if present\n        limit_choices_to = self.get_limit_choices_to()\n        if limit_choices_to:\n            queryset = queryset.complex_filter(limit_choices_to)\n        \n        return super().formfield(**{\n            'form_class': forms.ModelChoiceField,\n            'queryset': queryset,\n            'to_field_name': self.remote_field.field_name,\n            **kwargs,\n            'blank': self.blank,\n        })\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        # Ensure that the queryset is evaluated.\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\ndef formfield(self, *, using=None, **kwargs):\n    if isinstance(self.remote_field.model, str):\n        raise ValueError(\"Cannot create form field for %r yet, because \"\n                         \"its related model %r has not been loaded yet\" %\n                         (self.name, self.remote_field.model))\n    \n    # Get base queryset\n    queryset = self.remote_field.model._default_manager.using(using)\n    \n    # Apply limit_choices_to filtering if present\n    limit_choices_to = self.get_limit_choices_to()\n    if limit_choices_to:\n        queryset = queryset.complex_filter(limit_choices_to)\n    \n    return super().formfield(**{\n        'form_class': forms.ModelChoiceField,\n        'queryset': queryset,\n        'to_field_name': self.remote_field.field_name,\n        **kwargs,\n        'blank': self.blank,\n    })\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..6829e9eb1b 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -981,6 +981,7 @@ class ForeignKey(ForeignObject):\n         if self.remote_field.field_name is None:\n             self.remote_field.field_name = cls._meta.pk.name\n \n+\n     def formfield(self, *, using=None, **kwargs):\n         if isinstance(self.remote_field.model, str):\n             raise ValueError(\"Cannot create form field for %r yet, because \"\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..5aab7e6d14 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -95,6 +95,7 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n@@ -1151,10 +1152,16 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        # Apply limit_choices_to filtering if it exists\n+        if hasattr(self.field, 'get_limit_choices_to'):\n+            limit_choices_to = self.field.get_limit_choices_to()\n+            if limit_choices_to is not None:\n+                queryset = queryset.complex_filter(limit_choices_to)\n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n@@ -1208,6 +1215,7 @@ class ModelChoiceField(ChoiceField):\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n \n+\n     def get_limit_choices_to(self):\n         \"\"\"\n         Return ``limit_choices_to`` for this form field.\n@@ -1244,6 +1252,7 @@ class ModelChoiceField(ChoiceField):\n         \"\"\"\n         return str(obj)\n \n+\n     def _get_choices(self):\n         # If self._choices is set, then somebody must have manually set\n         # the property self.choices. In this case, just return self._choices.\n",
    "variant_0": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..aea1eff20e 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -981,18 +981,20 @@ class ForeignKey(ForeignObject):\n         if self.remote_field.field_name is None:\n             self.remote_field.field_name = cls._meta.pk.name\n \n-    def formfield(self, *, using=None, **kwargs):\n-        if isinstance(self.remote_field.model, str):\n-            raise ValueError(\"Cannot create form field for %r yet, because \"\n-                             \"its related model %r has not been loaded yet\" %\n-                             (self.name, self.remote_field.model))\n-        return super().formfield(**{\n-            'form_class': forms.ModelChoiceField,\n-            'queryset': self.remote_field.model._default_manager.using(using),\n-            'to_field_name': self.remote_field.field_name,\n-            **kwargs,\n-            'blank': self.blank,\n-        })\n+\n+def formfield(self, *, using=None, **kwargs):\n+    if isinstance(self.remote_field.model, str):\n+        raise ValueError(\"Cannot create form field for %r yet, because \"\n+                         \"its related model %r has not been loaded yet\" %\n+                         (self.name, self.remote_field.model))\n+    defaults = {\n+        'form_class': forms.ModelChoiceField,\n+        'queryset': self.remote_field.model._default_manager.using(using),\n+        'to_field_name': self.remote_field.field_name,\n+        'blank': self.blank,\n+    }\n+    defaults.update(kwargs)\n+    return super().formfield(**defaults)\n \n     def db_check(self, connection):\n         return []\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..0cb50f6e8a 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -95,6 +95,7 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n@@ -1151,10 +1152,17 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n@@ -1208,15 +1216,23 @@ class ModelChoiceField(ChoiceField):\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this form field.\n \n-        If it is a callable, invoke it and return the result.\n-        \"\"\"\n-        if callable(self.limit_choices_to):\n-            return self.limit_choices_to()\n-        return self.limit_choices_to\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        \n+        queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        limit_choices_to = self.field.get_limit_choices_to()\n+        if limit_choices_to:\n+            queryset = queryset.complex_filter(limit_choices_to)\n+        \n+        # Ensure the queryset is ordered.\n+        if queryset._result_cache is not None and not queryset.ordered:\n+            queryset = queryset.order_by()\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     def __deepcopy__(self, memo):\n         result = super(ChoiceField, self).__deepcopy__(memo)\n@@ -1244,6 +1260,7 @@ class ModelChoiceField(ChoiceField):\n         \"\"\"\n         return str(obj)\n \n+\n     def _get_choices(self):\n         # If self._choices is set, then somebody must have manually set\n         # the property self.choices. In this case, just return self._choices.\n@@ -1257,7 +1274,12 @@ class ModelChoiceField(ChoiceField):\n         # accessed) so that we can ensure the QuerySet has not been consumed. This\n         # construct might look complicated but it allows for lazy evaluation of\n         # the queryset.\n-        return self.iterator(self)\n+        queryset = self.queryset\n+        if hasattr(self, 'get_limit_choices_to'):\n+            limit_choices_to = self.get_limit_choices_to()\n+            if limit_choices_to:\n+                queryset = queryset.complex_filter(limit_choices_to)\n+        return self.iterator(self.__class__(queryset=queryset))\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n \n",
    "variant_1": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..1779b13a97 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -981,14 +981,28 @@ class ForeignKey(ForeignObject):\n         if self.remote_field.field_name is None:\n             self.remote_field.field_name = cls._meta.pk.name\n \n+\n     def formfield(self, *, using=None, **kwargs):\n         if isinstance(self.remote_field.model, str):\n             raise ValueError(\"Cannot create form field for %r yet, because \"\n                              \"its related model %r has not been loaded yet\" %\n                              (self.name, self.remote_field.model))\n+        \n+        # Get the base queryset\n+        queryset = self.remote_field.model._default_manager.using(using)\n+        \n+        # Apply limit_choices_to filtering if present\n+        limit_choices_to = self.get_limit_choices_to()\n+        if limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            complex_filter = limit_choices_to\n+            if not isinstance(complex_filter, Q):\n+                complex_filter = Q(**complex_filter)\n+            queryset = queryset.filter(complex_filter)\n+        \n         return super().formfield(**{\n             'form_class': forms.ModelChoiceField,\n-            'queryset': self.remote_field.model._default_manager.using(using),\n+            'queryset': queryset,\n             'to_field_name': self.remote_field.field_name,\n             **kwargs,\n             'blank': self.blank,\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..f746230dc7 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -95,6 +95,7 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n@@ -1151,10 +1152,17 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n@@ -1208,15 +1216,18 @@ class ModelChoiceField(ChoiceField):\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this form field.\n \n-        If it is a callable, invoke it and return the result.\n-        \"\"\"\n-        if callable(self.limit_choices_to):\n-            return self.limit_choices_to()\n-        return self.limit_choices_to\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to if it exists\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            limit_choices_to = self.field.get_limit_choices_to()\n+            queryset = queryset.complex_filter(limit_choices_to)\n+        # Ensure iterator is evaluated in a consistent manner\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     def __deepcopy__(self, memo):\n         result = super(ChoiceField, self).__deepcopy__(memo)\n@@ -1244,20 +1255,24 @@ class ModelChoiceField(ChoiceField):\n         \"\"\"\n         return str(obj)\n \n-    def _get_choices(self):\n-        # If self._choices is set, then somebody must have manually set\n-        # the property self.choices. In this case, just return self._choices.\n-        if hasattr(self, '_choices'):\n-            return self._choices\n-\n-        # Otherwise, execute the QuerySet in self.queryset to determine the\n-        # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n-        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n-        # time _get_choices() is called (and, thus, each time self.choices is\n-        # accessed) so that we can ensure the QuerySet has not been consumed. This\n-        # construct might look complicated but it allows for lazy evaluation of\n-        # the queryset.\n-        return self.iterator(self)\n+\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if it exists\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            limit_choices_to = self.field.limit_choices_to\n+            if isinstance(limit_choices_to, Q):\n+                queryset = queryset.filter(limit_choices_to)\n+            elif isinstance(limit_choices_to, dict):\n+                queryset = queryset.filter(**limit_choices_to)\n+        # Ensure the queryset is evaluated only once.\n+        queryset = queryset.iterator() if queryset._result_cache is None else iter(queryset)\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n \n",
    "variant_2": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..b39ef3c4ba 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -981,18 +981,19 @@ class ForeignKey(ForeignObject):\n         if self.remote_field.field_name is None:\n             self.remote_field.field_name = cls._meta.pk.name\n \n-    def formfield(self, *, using=None, **kwargs):\n-        if isinstance(self.remote_field.model, str):\n-            raise ValueError(\"Cannot create form field for %r yet, because \"\n-                             \"its related model %r has not been loaded yet\" %\n-                             (self.name, self.remote_field.model))\n-        return super().formfield(**{\n-            'form_class': forms.ModelChoiceField,\n-            'queryset': self.remote_field.model._default_manager.using(using),\n-            'to_field_name': self.remote_field.field_name,\n-            **kwargs,\n-            'blank': self.blank,\n-        })\n+\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            if self.field.limit_choices_to:\n+                complex_filter = self.field.limit_choices_to\n+                if complex_filter:\n+                    queryset = queryset.complex_filter(complex_filter)\n+        # Ensure queryset is evaluated only once\n+        yield from self.choice_func(queryset)\n \n     def db_check(self, connection):\n         return []\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..7029684702 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -95,6 +95,7 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n@@ -1151,10 +1152,17 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n@@ -1208,15 +1216,21 @@ class ModelChoiceField(ChoiceField):\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this form field.\n \n-        If it is a callable, invoke it and return the result.\n-        \"\"\"\n-        if callable(self.limit_choices_to):\n-            return self.limit_choices_to()\n-        return self.limit_choices_to\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        \n+        # Apply limit_choices_to filtering if present\n+        queryset = self.queryset\n+        if hasattr(self.field, 'limit_choices_to'):\n+            limit_choices_to = self.field.get_limit_choices_to()\n+            if limit_choices_to:\n+                queryset = queryset.complex_filter(limit_choices_to)\n+        \n+        queryset = queryset.distinct() if queryset is not None else self.queryset\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     def __deepcopy__(self, memo):\n         result = super(ChoiceField, self).__deepcopy__(memo)\n@@ -1244,20 +1258,18 @@ class ModelChoiceField(ChoiceField):\n         \"\"\"\n         return str(obj)\n \n-    def _get_choices(self):\n-        # If self._choices is set, then somebody must have manually set\n-        # the property self.choices. In this case, just return self._choices.\n-        if hasattr(self, '_choices'):\n-            return self._choices\n-\n-        # Otherwise, execute the QuerySet in self.queryset to determine the\n-        # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n-        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n-        # time _get_choices() is called (and, thus, each time self.choices is\n-        # accessed) so that we can ensure the QuerySet has not been consumed. This\n-        # construct might look complicated but it allows for lazy evaluation of\n-        # the queryset.\n-        return self.iterator(self)\n+\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if it exists\n+        if hasattr(self.field, 'get_limit_choices_to'):\n+            limit_choices_to = self.field.get_limit_choices_to()\n+            if limit_choices_to:\n+                queryset = queryset.complex_filter(limit_choices_to)\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n \n",
    "variant_3": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..bc4347f061 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -981,18 +981,28 @@ class ForeignKey(ForeignObject):\n         if self.remote_field.field_name is None:\n             self.remote_field.field_name = cls._meta.pk.name\n \n-    def formfield(self, *, using=None, **kwargs):\n-        if isinstance(self.remote_field.model, str):\n-            raise ValueError(\"Cannot create form field for %r yet, because \"\n-                             \"its related model %r has not been loaded yet\" %\n-                             (self.name, self.remote_field.model))\n-        return super().formfield(**{\n-            'form_class': forms.ModelChoiceField,\n-            'queryset': self.remote_field.model._default_manager.using(using),\n-            'to_field_name': self.remote_field.field_name,\n-            **kwargs,\n-            'blank': self.blank,\n-        })\n+\n+def formfield(self, *, using=None, **kwargs):\n+    if isinstance(self.remote_field.model, str):\n+        raise ValueError(\"Cannot create form field for %r yet, because \"\n+                         \"its related model %r has not been loaded yet\" %\n+                         (self.name, self.remote_field.model))\n+    \n+    # Get the base queryset\n+    queryset = self.remote_field.model._default_manager.using(using)\n+    \n+    # Apply limit_choices_to filtering if present\n+    limit_choices_to = self.get_limit_choices_to()\n+    if limit_choices_to:\n+        queryset = queryset.complex_filter(limit_choices_to)\n+    \n+    return super().formfield(**{\n+        'form_class': forms.ModelChoiceField,\n+        'queryset': queryset,\n+        'to_field_name': self.remote_field.field_name,\n+        **kwargs,\n+        'blank': self.blank,\n+    })\n \n     def db_check(self, connection):\n         return []\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..37e00bbe48 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -95,12 +95,20 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n-def apply_limit_choices_to_to_formfield(formfield):\n-    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n-    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n-        limit_choices_to = formfield.get_limit_choices_to()\n+\n+def __iter__(self):\n+    if self.field.empty_label is not None:\n+        yield (\"\", self.field.empty_label)\n+    queryset = self.queryset\n+    # Apply limit_choices_to filtering if it exists\n+    if hasattr(self.field, 'get_limit_choices_to'):\n+        limit_choices_to = self.field.get_limit_choices_to()\n         if limit_choices_to is not None:\n-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            queryset = queryset.complex_filter(limit_choices_to)\n+    # Ensure queryset is evaluated to prevent caching issues\n+    queryset = queryset.all()\n+    for obj in queryset:\n+        yield self.choice(obj)\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n@@ -1151,10 +1159,29 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.sql.query import Q\n+            limit_choices_to = self.field.limit_choices_to\n+            if isinstance(limit_choices_to, Q):\n+                queryset = queryset.filter(limit_choices_to)\n+            elif isinstance(limit_choices_to, dict):\n+                queryset = queryset.filter(**limit_choices_to)\n+            else:\n+                # Handle callable limit_choices_to\n+                if callable(limit_choices_to):\n+                    limit_choices_to = limit_choices_to()\n+                if isinstance(limit_choices_to, Q):\n+                    queryset = queryset.filter(limit_choices_to)\n+                elif isinstance(limit_choices_to, dict):\n+                    queryset = queryset.filter(**limit_choices_to)\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n@@ -1208,15 +1235,22 @@ class ModelChoiceField(ChoiceField):\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this form field.\n \n-        If it is a callable, invoke it and return the result.\n-        \"\"\"\n-        if callable(self.limit_choices_to):\n-            return self.limit_choices_to()\n-        return self.limit_choices_to\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        \n+        queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        limit_choices_to = self.field.get_limit_choices_to()\n+        if limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(limit_choices_to)\n+        \n+        # Prefetch the objects into a list to avoid issues with nested database queries\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     def __deepcopy__(self, memo):\n         result = super(ChoiceField, self).__deepcopy__(memo)\n@@ -1244,20 +1278,25 @@ class ModelChoiceField(ChoiceField):\n         \"\"\"\n         return str(obj)\n \n-    def _get_choices(self):\n-        # If self._choices is set, then somebody must have manually set\n-        # the property self.choices. In this case, just return self._choices.\n-        if hasattr(self, '_choices'):\n-            return self._choices\n-\n-        # Otherwise, execute the QuerySet in self.queryset to determine the\n-        # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n-        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n-        # time _get_choices() is called (and, thus, each time self.choices is\n-        # accessed) so that we can ensure the QuerySet has not been consumed. This\n-        # construct might look complicated but it allows for lazy evaluation of\n-        # the queryset.\n-        return self.iterator(self)\n+\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        \n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'get_limit_choices_to'):\n+            limit_choices_to = self.field.get_limit_choices_to()\n+            if limit_choices_to:\n+                queryset = queryset.complex_filter(limit_choices_to)\n+        \n+        # Ensure the queryset is evaluated at this point. This is a performance\n+        # optimization that prevents multiple database calls when rendering\n+        # this field in a template.\n+        if queryset._result_cache is None:\n+            queryset._fetch_all()\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n \n",
    "variant_4": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..193f6f1e2b 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -981,18 +981,25 @@ class ForeignKey(ForeignObject):\n         if self.remote_field.field_name is None:\n             self.remote_field.field_name = cls._meta.pk.name\n \n-    def formfield(self, *, using=None, **kwargs):\n-        if isinstance(self.remote_field.model, str):\n-            raise ValueError(\"Cannot create form field for %r yet, because \"\n-                             \"its related model %r has not been loaded yet\" %\n-                             (self.name, self.remote_field.model))\n-        return super().formfield(**{\n-            'form_class': forms.ModelChoiceField,\n-            'queryset': self.remote_field.model._default_manager.using(using),\n-            'to_field_name': self.remote_field.field_name,\n-            **kwargs,\n-            'blank': self.blank,\n-        })\n+\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if it exists\n+        if hasattr(self.field, 'get_limit_choices_to'):\n+            limit_choices_to = self.field.get_limit_choices_to()\n+            if limit_choices_to:\n+                from django.db.models.query_utils import Q\n+                from django.db.models.sql.query import Query\n+                if isinstance(limit_choices_to, Q):\n+                    queryset = queryset.filter(limit_choices_to)\n+                elif isinstance(limit_choices_to, dict):\n+                    queryset = queryset.filter(**limit_choices_to)\n+        # Use distinct() to eliminate any potential duplicates from joins\n+        queryset = queryset.distinct()\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     def db_check(self, connection):\n         return []\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..60eafa56e4 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -95,6 +95,7 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n@@ -1151,10 +1152,25 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.sql.query import Q\n+            from django.db.models.query_utils import Q as QueryQ\n+            \n+            limit_choices_to = self.field.limit_choices_to\n+            if isinstance(limit_choices_to, (Q, QueryQ)):\n+                queryset = queryset.filter(limit_choices_to)\n+            elif isinstance(limit_choices_to, dict):\n+                queryset = queryset.filter(**limit_choices_to)\n+            else:\n+                queryset = queryset.complex_filter(limit_choices_to)\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n@@ -1208,15 +1224,28 @@ class ModelChoiceField(ChoiceField):\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this form field.\n \n-        If it is a callable, invoke it and return the result.\n-        \"\"\"\n-        if callable(self.limit_choices_to):\n-            return self.limit_choices_to()\n-        return self.limit_choices_to\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if present\n+        limit_choices_to = self.field.get_limit_choices_to()\n+        if limit_choices_to:\n+            queryset = queryset.complex_filter(limit_choices_to)\n+        # Ensure queryset is distinct to avoid duplicates from joins\n+        if limit_choices_to:\n+            queryset = queryset.distinct()\n+        if self.field.cache_choices:\n+            if self.field.choice_cache is None:\n+                self.field.choice_cache = [\n+                    self.choice(obj) for obj in queryset\n+                ]\n+            for choice in self.field.choice_cache:\n+                yield choice\n+        else:\n+            for obj in queryset:\n+                yield self.choice(obj)\n \n     def __deepcopy__(self, memo):\n         result = super(ChoiceField, self).__deepcopy__(memo)\n@@ -1244,6 +1273,7 @@ class ModelChoiceField(ChoiceField):\n         \"\"\"\n         return str(obj)\n \n+\n     def _get_choices(self):\n         # If self._choices is set, then somebody must have manually set\n         # the property self.choices. In this case, just return self._choices.\n@@ -1257,7 +1287,17 @@ class ModelChoiceField(ChoiceField):\n         # accessed) so that we can ensure the QuerySet has not been consumed. This\n         # construct might look complicated but it allows for lazy evaluation of\n         # the queryset.\n-        return self.iterator(self)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if present\n+        limit_choices_to = self.get_limit_choices_to()\n+        if limit_choices_to:\n+            queryset = queryset.complex_filter(limit_choices_to)\n+        \n+        # Create iterator with the filtered queryset\n+        iterator = self.iterator.__new__(self.iterator)\n+        iterator.field = self\n+        iterator.queryset = queryset\n+        return iterator\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n \n",
    "variant_5": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..3f27c479f5 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -981,18 +981,32 @@ class ForeignKey(ForeignObject):\n         if self.remote_field.field_name is None:\n             self.remote_field.field_name = cls._meta.pk.name\n \n-    def formfield(self, *, using=None, **kwargs):\n-        if isinstance(self.remote_field.model, str):\n-            raise ValueError(\"Cannot create form field for %r yet, because \"\n-                             \"its related model %r has not been loaded yet\" %\n-                             (self.name, self.remote_field.model))\n-        return super().formfield(**{\n-            'form_class': forms.ModelChoiceField,\n-            'queryset': self.remote_field.model._default_manager.using(using),\n-            'to_field_name': self.remote_field.field_name,\n-            **kwargs,\n-            'blank': self.blank,\n-        })\n+\n+def __iter__(self):\n+    if self.field.empty_label is not None:\n+        yield (\"\", self.field.empty_label)\n+    queryset = self.queryset\n+    # Apply limit_choices_to filtering if present\n+    if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+        from django.db.models.query_utils import Q\n+        from django.db.models.sql.query import Query\n+        \n+        limit_choices_to = self.field.limit_choices_to\n+        if isinstance(limit_choices_to, Q):\n+            queryset = queryset.filter(limit_choices_to)\n+        elif isinstance(limit_choices_to, dict):\n+            queryset = queryset.filter(**limit_choices_to)\n+        else:\n+            # Handle other types that might be callable\n+            if callable(limit_choices_to):\n+                limit_choices_to = limit_choices_to()\n+            queryset = queryset.complex_filter(limit_choices_to)\n+    \n+    # Ensure distinct results to avoid duplicates from joins\n+    queryset = queryset.distinct()\n+    \n+    for obj in queryset:\n+        yield self.choice(obj)\n \n     def db_check(self, connection):\n         return []\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..6740a0c71a 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -95,6 +95,7 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n@@ -1151,10 +1152,17 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n@@ -1208,15 +1216,20 @@ class ModelChoiceField(ChoiceField):\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this form field.\n \n-        If it is a callable, invoke it and return the result.\n-        \"\"\"\n-        if callable(self.limit_choices_to):\n-            return self.limit_choices_to()\n-        return self.limit_choices_to\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if present\n+        limit_choices_to = self.field.get_limit_choices_to()\n+        if limit_choices_to:\n+            queryset = queryset.complex_filter(limit_choices_to)\n+        # Only check for duplicates if we have a to_field_name\n+        if self.field.to_field_name:\n+            queryset = queryset.distinct()\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     def __deepcopy__(self, memo):\n         result = super(ChoiceField, self).__deepcopy__(memo)\n@@ -1244,20 +1257,25 @@ class ModelChoiceField(ChoiceField):\n         \"\"\"\n         return str(obj)\n \n-    def _get_choices(self):\n-        # If self._choices is set, then somebody must have manually set\n-        # the property self.choices. In this case, just return self._choices.\n-        if hasattr(self, '_choices'):\n-            return self._choices\n-\n-        # Otherwise, execute the QuerySet in self.queryset to determine the\n-        # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n-        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n-        # time _get_choices() is called (and, thus, each time self.choices is\n-        # accessed) so that we can ensure the QuerySet has not been consumed. This\n-        # construct might look complicated but it allows for lazy evaluation of\n-        # the queryset.\n-        return self.iterator(self)\n+\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if it exists\n+        limit_choices_to = self.field.get_limit_choices_to()\n+        if limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            if isinstance(limit_choices_to, Q):\n+                queryset = queryset.filter(limit_choices_to)\n+            else:\n+                queryset = queryset.complex_filter(limit_choices_to)\n+        # Ensure the queryset is evaluated only once\n+        if queryset._result_cache is not None:\n+            yield from self.choice(obj) for obj in queryset._result_cache\n+        else:\n+            yield from (self.choice(obj) for obj in queryset.iterator())\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n \n",
    "variant_6": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..a618f71722 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -981,14 +981,24 @@ class ForeignKey(ForeignObject):\n         if self.remote_field.field_name is None:\n             self.remote_field.field_name = cls._meta.pk.name\n \n+\n     def formfield(self, *, using=None, **kwargs):\n         if isinstance(self.remote_field.model, str):\n             raise ValueError(\"Cannot create form field for %r yet, because \"\n                              \"its related model %r has not been loaded yet\" %\n                              (self.name, self.remote_field.model))\n+        \n+        # Get the base queryset\n+        queryset = self.remote_field.model._default_manager.using(using)\n+        \n+        # Apply limit_choices_to filtering if present\n+        limit_choices_to = self.get_limit_choices_to()\n+        if limit_choices_to:\n+            queryset = queryset.complex_filter(limit_choices_to)\n+        \n         return super().formfield(**{\n             'form_class': forms.ModelChoiceField,\n-            'queryset': self.remote_field.model._default_manager.using(using),\n+            'queryset': queryset,\n             'to_field_name': self.remote_field.field_name,\n             **kwargs,\n             'blank': self.blank,\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..27679b1301 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -95,6 +95,7 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n@@ -1151,10 +1152,17 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n@@ -1208,15 +1216,20 @@ class ModelChoiceField(ChoiceField):\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this form field.\n \n-        If it is a callable, invoke it and return the result.\n-        \"\"\"\n-        if callable(self.limit_choices_to):\n-            return self.limit_choices_to()\n-        return self.limit_choices_to\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if it exists\n+        if hasattr(self.field, 'limit_choices_to'):\n+            limit_choices_to = self.field.get_limit_choices_to()\n+            if limit_choices_to:\n+                queryset = queryset.complex_filter(limit_choices_to)\n+        # Ensure queryset is evaluated only once and is ordered.\n+        queryset = queryset.order_by().distinct()\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     def __deepcopy__(self, memo):\n         result = super(ChoiceField, self).__deepcopy__(memo)\n@@ -1244,20 +1257,26 @@ class ModelChoiceField(ChoiceField):\n         \"\"\"\n         return str(obj)\n \n-    def _get_choices(self):\n-        # If self._choices is set, then somebody must have manually set\n-        # the property self.choices. In this case, just return self._choices.\n-        if hasattr(self, '_choices'):\n-            return self._choices\n-\n-        # Otherwise, execute the QuerySet in self.queryset to determine the\n-        # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n-        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n-        # time _get_choices() is called (and, thus, each time self.choices is\n-        # accessed) so that we can ensure the QuerySet has not been consumed. This\n-        # construct might look complicated but it allows for lazy evaluation of\n-        # the queryset.\n-        return self.iterator(self)\n+\n+def _get_choices(self):\n+    # If self._choices is set, then somebody must have manually set\n+    # the property self.choices. In this case, just return self._choices.\n+    if hasattr(self, '_choices'):\n+        return self._choices\n+\n+    # Otherwise, execute the QuerySet in self.queryset to determine the\n+    # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n+    # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n+    # time _get_choices() is called (and, thus, each time self.choices is\n+    # accessed) so that we can ensure the QuerySet has not been consumed. This\n+    # construct might look complicated but it allows for lazy evaluation of\n+    # the queryset.\n+    queryset = self.queryset\n+    # Apply limit_choices_to filtering if present\n+    limit_choices_to = self.get_limit_choices_to()\n+    if limit_choices_to:\n+        queryset = queryset.complex_filter(limit_choices_to)\n+    return self.iterator(self)\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n \n",
    "variant_7": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..c9d1a0ca32 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -981,18 +981,14 @@ class ForeignKey(ForeignObject):\n         if self.remote_field.field_name is None:\n             self.remote_field.field_name = cls._meta.pk.name\n \n-    def formfield(self, *, using=None, **kwargs):\n-        if isinstance(self.remote_field.model, str):\n-            raise ValueError(\"Cannot create form field for %r yet, because \"\n-                             \"its related model %r has not been loaded yet\" %\n-                             (self.name, self.remote_field.model))\n-        return super().formfield(**{\n-            'form_class': forms.ModelChoiceField,\n-            'queryset': self.remote_field.model._default_manager.using(using),\n-            'to_field_name': self.remote_field.field_name,\n-            **kwargs,\n-            'blank': self.blank,\n-        })\n+\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Ensure that the queryset is evaluated.\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     def db_check(self, connection):\n         return []\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..894992dd2a 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -95,6 +95,7 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n@@ -1151,10 +1152,17 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n@@ -1208,15 +1216,22 @@ class ModelChoiceField(ChoiceField):\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this form field.\n \n-        If it is a callable, invoke it and return the result.\n-        \"\"\"\n-        if callable(self.limit_choices_to):\n-            return self.limit_choices_to()\n-        return self.limit_choices_to\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        \n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to'):\n+            limit_choices_to = self.field.get_limit_choices_to()\n+            if limit_choices_to:\n+                queryset = queryset.complex_filter(limit_choices_to)\n+        \n+        # Prefetch the objects into a list to avoid database hits\n+        # during yield.\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     def __deepcopy__(self, memo):\n         result = super(ChoiceField, self).__deepcopy__(memo)\n@@ -1244,20 +1259,19 @@ class ModelChoiceField(ChoiceField):\n         \"\"\"\n         return str(obj)\n \n-    def _get_choices(self):\n-        # If self._choices is set, then somebody must have manually set\n-        # the property self.choices. In this case, just return self._choices.\n-        if hasattr(self, '_choices'):\n-            return self._choices\n-\n-        # Otherwise, execute the QuerySet in self.queryset to determine the\n-        # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n-        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n-        # time _get_choices() is called (and, thus, each time self.choices is\n-        # accessed) so that we can ensure the QuerySet has not been consumed. This\n-        # construct might look complicated but it allows for lazy evaluation of\n-        # the queryset.\n-        return self.iterator(self)\n+\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if it exists\n+        if hasattr(self.field, 'get_limit_choices_to'):\n+            limit_choices_to = self.field.get_limit_choices_to()\n+            if limit_choices_to:\n+                from django.db.models.sql.query import Query\n+                queryset = queryset.complex_filter(limit_choices_to)\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n \n",
    "variant_8": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..4e70666c5e 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -981,18 +981,28 @@ class ForeignKey(ForeignObject):\n         if self.remote_field.field_name is None:\n             self.remote_field.field_name = cls._meta.pk.name\n \n-    def formfield(self, *, using=None, **kwargs):\n-        if isinstance(self.remote_field.model, str):\n-            raise ValueError(\"Cannot create form field for %r yet, because \"\n-                             \"its related model %r has not been loaded yet\" %\n-                             (self.name, self.remote_field.model))\n-        return super().formfield(**{\n-            'form_class': forms.ModelChoiceField,\n-            'queryset': self.remote_field.model._default_manager.using(using),\n-            'to_field_name': self.remote_field.field_name,\n-            **kwargs,\n-            'blank': self.blank,\n-        })\n+\n+def formfield(self, *, using=None, **kwargs):\n+    if isinstance(self.remote_field.model, str):\n+        raise ValueError(\"Cannot create form field for %r yet, because \"\n+                         \"its related model %r has not been loaded yet\" %\n+                         (self.name, self.remote_field.model))\n+    \n+    # Get base queryset\n+    queryset = self.remote_field.model._default_manager.using(using)\n+    \n+    # Apply limit_choices_to filtering if present\n+    limit_choices_to = self.get_limit_choices_to()\n+    if limit_choices_to:\n+        queryset = queryset.complex_filter(limit_choices_to)\n+    \n+    return super().formfield(**{\n+        'form_class': forms.ModelChoiceField,\n+        'queryset': queryset,\n+        'to_field_name': self.remote_field.field_name,\n+        **kwargs,\n+        'blank': self.blank,\n+    })\n \n     def db_check(self, connection):\n         return []\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..566b548065 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -95,12 +95,23 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n-def apply_limit_choices_to_to_formfield(formfield):\n-    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n-    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n-        limit_choices_to = formfield.get_limit_choices_to()\n+\n+def __iter__(self):\n+    if self.field.empty_label is not None:\n+        yield (\"\", self.field.empty_label)\n+    \n+    # Apply limit_choices_to filtering if available\n+    queryset = self.queryset\n+    if hasattr(self.field, 'get_limit_choices_to'):\n+        limit_choices_to = self.field.get_limit_choices_to()\n         if limit_choices_to is not None:\n-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            queryset = queryset.complex_filter(limit_choices_to)\n+    \n+    queryset = queryset.all()\n+    # Prevent a second database query when the queryset is evaluated.\n+    queryset._result_cache = None\n+    for obj in queryset:\n+        yield self.choice(obj)\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n@@ -1151,10 +1162,17 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        \n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n@@ -1208,15 +1226,24 @@ class ModelChoiceField(ChoiceField):\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this form field.\n \n-        If it is a callable, invoke it and return the result.\n-        \"\"\"\n-        if callable(self.limit_choices_to):\n-            return self.limit_choices_to()\n-        return self.limit_choices_to\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering if present\n+        if hasattr(self.field, 'limit_choices_to'):\n+            limit_choices_to = self.field.get_limit_choices_to()\n+            if limit_choices_to:\n+                queryset = queryset.complex_filter(limit_choices_to)\n+        # Ensure queryset is distinct to avoid duplicates from joins\n+        queryset = queryset.distinct()\n+        if self.field.to_field_name:\n+            to_field_name = self.field.to_field_name\n+        else:\n+            to_field_name = queryset.model._meta.pk.attname\n+        for obj in queryset:\n+            yield (getattr(obj, to_field_name), self.field.label_from_instance(obj))\n \n     def __deepcopy__(self, memo):\n         result = super(ChoiceField, self).__deepcopy__(memo)\n@@ -1244,20 +1271,19 @@ class ModelChoiceField(ChoiceField):\n         \"\"\"\n         return str(obj)\n \n-    def _get_choices(self):\n-        # If self._choices is set, then somebody must have manually set\n-        # the property self.choices. In this case, just return self._choices.\n-        if hasattr(self, '_choices'):\n-            return self._choices\n-\n-        # Otherwise, execute the QuerySet in self.queryset to determine the\n-        # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n-        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n-        # time _get_choices() is called (and, thus, each time self.choices is\n-        # accessed) so that we can ensure the QuerySet has not been consumed. This\n-        # construct might look complicated but it allows for lazy evaluation of\n-        # the queryset.\n-        return self.iterator(self)\n+\n+    def __iter__(self):\n+        if self.field.empty_label is not None:\n+            yield (\"\", self.field.empty_label)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filtering to prevent duplicates from joins\n+        limit_choices_to = self.field.get_limit_choices_to()\n+        if limit_choices_to:\n+            queryset = queryset.complex_filter(limit_choices_to)\n+        # Ensure the queryset is distinct to handle any remaining duplicates\n+        queryset = queryset.distinct()\n+        for obj in queryset:\n+            yield self.choice(obj)\n \n     choices = property(_get_choices, ChoiceField._set_choices)\n \n"
  }
}