{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/pylint/pylint/lint/expand_modules.py lines 93-96)": "\n            if os.path.isdir(something):\n                # Check if directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
    "Location 2 (/root/hy/projects_1/pylint/pylint/lint/expand_modules.py lines 134-138)": "\n        has_init = (\n            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n            and os.path.basename(filepath) == \"__init__.py\"\n            and os.path.exists(filepath)\n        )\n",
    "Location 3 (/root/hy/projects_1/pylint/pylint/lint/expand_modules.py lines 26-42)": "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path by finding the directory that should be added to sys.path.\n    \n    This function walks up the directory tree to find the appropriate parent directory\n    that should be added to the Python path, handling both traditional packages\n    (with __init__.py) and namespace packages (without __init__.py).\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    \n    # Walk up the directory tree while we find Python packages\n    while True:\n        parent_dirname = os.path.dirname(dirname)\n        \n        # If we've reached the root directory, return current directory\n        if parent_dirname == dirname:\n            return dirname\n        \n        # Check if the parent directory looks like a Python package\n        # Either it has __init__.py (traditional package) or it contains .py files (namespace package)\n        has_init = os.path.exists(os.path.join(parent_dirname, \"__init__.py\"))\n        has_py_files = any(f.endswith('.py') for f in os.listdir(parent_dirname) if os.path.isfile(os.path.join(parent_dirname, f)))\n        \n        # If parent doesn't look like a package, return current directory\n        if not (has_init or has_py_files):\n            return dirname\n            \n        dirname = parent_dirname\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/pylint/pylint/lint/expand_modules.py lines 93-96)": [
      "\n            if os.path.isdir(something):\n                # Check if directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                init_py = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_py):\n                    filepath = init_py\n                else:\n                    # Directory exists but is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                init_py_path = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_py_path):\n                    filepath = init_py_path\n                else:\n                    # Directory exists but is not a package, skip it\n                    continue\n            else:\n                filepath = something\n"
    ],
    "Location 2 (/root/hy/projects_1/pylint/pylint/lint/expand_modules.py lines 134-138)": [
      "\n        has_init = (\n            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n            and os.path.isdir(filepath)\n            and os.path.exists(os.path.join(filepath, \"__init__.py\"))\n        )\n",
      "\n        has_init = (\n            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n            and os.path.basename(filepath) == \"__init__.py\"\n            and os.path.exists(filepath)\n        )\n",
      "\n        has_init = (\n            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n            and os.path.isdir(filepath)\n            and os.path.exists(os.path.join(filepath, \"__init__.py\"))\n        )\n",
      "\n        has_init = (\n            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n            and os.path.basename(filepath) == \"__init__.py\"\n            and os.path.exists(filepath)\n        )\n",
      "\n        has_init = (\n            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n            and os.path.basename(filepath) == \"__init__.py\"\n            and os.path.exists(filepath)\n        )\n",
      "\n        has_init = (\n            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n            and os.path.basename(filepath) == \"__init__.py\"\n            and os.path.exists(filepath)\n        )\n",
      "\n        has_init = (\n            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n            and os.path.basename(filepath) == \"__init__.py\"\n            and os.path.exists(filepath)\n        )\n",
      "\n        has_init = (\n            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n            and os.path.basename(filepath) == \"__init__.py\"\n            and os.path.exists(filepath)\n        )\n"
    ],
    "Location 3 (/root/hy/projects_1/pylint/pylint/lint/expand_modules.py lines 26-42)": [
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path for a given filepath.\n    \n    Returns the directory that should be added to sys.path to make the module\n    importable. For regular packages, this walks up until it finds a directory\n    without __init__.py. For namespace packages (PEP 420), this may need to\n    walk up further based on the module structure.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    \n    # Walk up the directory tree to find the root of the package hierarchy\n    while True:\n        # Check if this directory has __init__.py (regular package)\n        init_file = os.path.join(dirname, \"__init__.py\")\n        if not os.path.exists(init_file):\n            # No __init__.py found, this could be:\n            # 1. The root directory we're looking for\n            # 2. A namespace package directory\n            # For now, return this directory as the python path\n            return dirname\n            \n        # Move up one level\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        \n        # Prevent infinite loop at filesystem root\n        if old_dirname == dirname:\n            return os.getcwd()\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path by finding the root directory that should be in sys.path.\n    \n    This function walks up the directory tree to find the appropriate root directory\n    for Python module resolution, handling both traditional packages (with __init__.py)\n    and namespace packages (PEP 420).\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    \n    # Walk up the directory tree\n    while True:\n        parent_dirname = os.path.dirname(dirname)\n        \n        # If we've reached the root or can't go higher, return current directory\n        if parent_dirname == dirname:\n            return dirname\n        \n        # Check if parent contains __init__.py (traditional package)\n        parent_init = os.path.join(parent_dirname, \"__init__.py\")\n        if os.path.exists(parent_init):\n            dirname = parent_dirname\n            continue\n        \n        # Check if parent could be a namespace package by looking for Python files\n        # or subdirectories that look like Python modules\n        has_python_content = False\n        try:\n            for item in os.listdir(parent_dirname):\n                item_path = os.path.join(parent_dirname, item)\n                if (item.endswith('.py') or \n                    (os.path.isdir(item_path) and \n                     (os.path.exists(os.path.join(item_path, \"__init__.py\")) or\n                      any(f.endswith('.py') for f in os.listdir(item_path) if os.path.isfile(os.path.join(item_path, f)))))):\n                    has_python_content = True\n                    break\n        except (OSError, PermissionError):\n            # If we can't read the directory, assume it's not a Python package\n            has_python_content = False\n        \n        if has_python_content:\n            dirname = parent_dirname\n            continue\n        \n        # No indication this is a Python package, return current directory\n        return dirname\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path for a given filepath.\n    \n    This function finds the appropriate directory to add to sys.path by walking\n    up the directory tree until it finds a directory that doesn't contain an\n    __init__.py file (indicating it's not part of a package).\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    \n    # Walk up the directory tree to find the root of the package structure\n    while True:\n        init_file = os.path.join(dirname, \"__init__.py\")\n        # Check if this directory contains __init__.py OR if it's a namespace package\n        # by checking if any Python files exist in the directory\n        if not os.path.exists(init_file):\n            # Also check if this directory contains any .py files to determine\n            # if it could be a namespace package\n            has_py_files = any(\n                f.endswith('.py') for f in os.listdir(dirname) \n                if os.path.isfile(os.path.join(dirname, f))\n            )\n            # If no __init__.py and no .py files, or if we're at a reasonable stopping point\n            if not has_py_files or dirname == os.path.dirname(dirname):\n                return dirname\n        \n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        # Prevent infinite loop at filesystem root\n        if old_dirname == dirname:\n            return os.getcwd()\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path by finding the topmost directory that should be \n    added to sys.path. This handles both traditional packages (with __init__.py)\n    and namespace packages (PEP 420).\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    \n    # For namespace packages, we need to find the parent directory that\n    # contains the namespace package structure\n    original_dirname = dirname\n    while True:\n        parent_dirname = os.path.dirname(dirname)\n        if parent_dirname == dirname:  # reached root\n            return dirname\n            \n        # Check if parent contains an __init__.py (traditional package)\n        # or if it's a valid namespace package parent\n        if os.path.exists(os.path.join(parent_dirname, \"__init__.py\")):\n            dirname = parent_dirname\n            continue\n            \n        # Check if this could be a namespace package structure\n        # by seeing if there are other Python modules/packages at this level\n        try:\n            siblings = [item for item in os.listdir(parent_dirname) \n                       if os.path.isdir(os.path.join(parent_dirname, item)) \n                       or item.endswith('.py')]\n            if len(siblings) > 1:  # Multiple items suggest this is a package level\n                dirname = parent_dirname\n                continue\n        except (OSError, PermissionError):\n            pass\n            \n        # If we can't go further up, return current directory\n        return dirname\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path, handling both regular packages and namespace packages.\n    \n    This function finds the appropriate Python path by traversing up the directory\n    tree until it finds a directory that is not part of a Python package.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    \n    while True:\n        # Check if current directory has __init__.py (regular package)\n        has_init = os.path.exists(os.path.join(dirname, \"__init__.py\"))\n        \n        # Check if current directory contains Python files (potential namespace package)\n        has_python_files = False\n        if os.path.isdir(dirname):\n            try:\n                for item in os.listdir(dirname):\n                    if item.endswith('.py') and os.path.isfile(os.path.join(dirname, item)):\n                        has_python_files = True\n                        break\n            except (OSError, PermissionError):\n                pass\n        \n        # If no __init__.py and no Python files, this is not a package directory\n        if not has_init and not has_python_files:\n            return dirname\n            \n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n            return os.getcwd()\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path by finding the root directory that should be added to sys.path.\n    \n    This function finds the topmost directory that contains Python modules/packages\n    by walking up the directory tree and checking for package indicators.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    \n    # Walk up the directory tree to find the root of the Python package structure\n    last_python_dir = dirname\n    while True:\n        parent_dir = os.path.dirname(dirname)\n        if parent_dir == dirname:  # Reached filesystem root\n            break\n            \n        # Check if parent directory contains Python files or is a namespace package\n        has_python_files = any(\n            f.endswith('.py') for f in os.listdir(parent_dir) \n            if os.path.isfile(os.path.join(parent_dir, f))\n        )\n        has_init = os.path.exists(os.path.join(parent_dir, \"__init__.py\"))\n        \n        # If parent has Python content, continue up; otherwise stop here\n        if has_python_files or has_init:\n            last_python_dir = parent_dir\n            dirname = parent_dir\n        else:\n            break\n    \n    return last_python_dir\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path for a given filepath.\n    \n    This function handles both regular packages (with __init__.py) and \n    namespace packages (without __init__.py) introduced in Python 3.3.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    \n    # Find the topmost directory that could be a Python package\n    while True:\n        parent_dirname = os.path.dirname(dirname)\n        if parent_dirname == dirname:  # reached filesystem root\n            return os.getcwd()\n            \n        # Check if parent contains Python files or subdirectories with Python files\n        # This indicates it could be a namespace package\n        has_python_content = False\n        try:\n            for item in os.listdir(parent_dirname):\n                item_path = os.path.join(parent_dirname, item)\n                if item.endswith('.py'):\n                    has_python_content = True\n                    break\n                elif os.path.isdir(item_path) and item != dirname.split(os.sep)[-1]:\n                    # Check if this sibling directory has Python content\n                    try:\n                        for subitem in os.listdir(item_path):\n                            if subitem.endswith('.py') or subitem == '__init__.py':\n                                has_python_content = True\n                                break\n                    except (OSError, PermissionError):\n                        continue\n                    if has_python_content:\n                        break\n        except (OSError, PermissionError):\n            return dirname\n            \n        if not has_python_content:\n            return dirname\n            \n        dirname = parent_dirname\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path by finding the root directory that should be added to sys.path.\n    \n    This function traverses up the directory tree to find the appropriate root directory.\n    It handles both traditional packages (with __init__.py) and namespace packages.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    \n    # Start from the current directory and work upwards\n    current_dir = dirname\n    while True:\n        parent_dir = os.path.dirname(current_dir)\n        \n        # If we've reached the filesystem root, return current directory\n        if current_dir == parent_dir:\n            return current_dir\n            \n        # Check if parent directory contains __init__.py (traditional package)\n        # or if it's a namespace package that should be included\n        if os.path.exists(os.path.join(parent_dir, \"__init__.py\")):\n            # Parent is a package, continue traversing up\n            current_dir = parent_dir\n        else:\n            # Parent is not a package, current_dir is the root we want\n            return current_dir\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..38c2cef93 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -23,11 +23,12 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path by finding the topmost directory that is not a package.\n+    \n+    Updated to handle modern Python namespace packages correctly (Python 3.3+).\n+    No longer assumes __init__.py always exists.\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -40,7 +41,6 @@ def get_python_path(filepath: str) -> str:\n         if old_dirname == dirname:\n             return os.getcwd()\n \n-\n def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n     \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n     return any(file_pattern.match(element) for file_pattern in ignore_list_re)\n@@ -90,8 +90,16 @@ def expand_modules(\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if the directory actually contains an __init__.py file\n+                # Only treat it as a package if __init__.py exists\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory without __init__.py - treat as namespace or regular directory\n+                    filepath = something\n             else:\n                 filepath = something\n         else:\n@@ -131,9 +139,11 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n             and os.path.basename(filepath) == \"__init__.py\"\n+            and os.path.exists(filepath)\n         )\n         if has_init or is_namespace or is_directory:\n             for subfilepath in modutils.get_module_files(\n",
    "variant_0": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..99da45f85 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -23,23 +23,36 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path by finding the directory that should be added to sys.path.\n+    \n+    This function walks up the directory tree to find the appropriate parent directory\n+    that should be added to the Python path, handling both traditional packages\n+    (with __init__.py) and namespace packages (without __init__.py).\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n         dirname = os.path.dirname(dirname)\n+    \n+    # Walk up the directory tree while we find Python packages\n     while True:\n-        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+        parent_dirname = os.path.dirname(dirname)\n+        \n+        # If we've reached the root directory, return current directory\n+        if parent_dirname == dirname:\n             return dirname\n-        old_dirname = dirname\n-        dirname = os.path.dirname(dirname)\n-        if old_dirname == dirname:\n-            return os.getcwd()\n-\n+        \n+        # Check if the parent directory looks like a Python package\n+        # Either it has __init__.py (traditional package) or it contains .py files (namespace package)\n+        has_init = os.path.exists(os.path.join(parent_dirname, \"__init__.py\"))\n+        has_py_files = any(f.endswith('.py') for f in os.listdir(parent_dirname) if os.path.isfile(os.path.join(parent_dirname, f)))\n+        \n+        # If parent doesn't look like a package, return current directory\n+        if not (has_init or has_py_files):\n+            return dirname\n+            \n+        dirname = parent_dirname\n \n def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n     \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n@@ -90,8 +103,15 @@ def expand_modules(\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +151,12 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n             and os.path.basename(filepath) == \"__init__.py\"\n+            and os.path.exists(filepath)\n         )\n-        if has_init or is_namespace or is_directory:\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_1": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..dc7195bb7 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -23,24 +23,38 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for a given filepath.\n+    \n+    Returns the directory that should be added to sys.path to make the module\n+    importable. For regular packages, this walks up until it finds a directory\n+    without __init__.py. For namespace packages (PEP 420), this may need to\n+    walk up further based on the module structure.\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n         dirname = os.path.dirname(dirname)\n+    \n+    # Walk up the directory tree to find the root of the package hierarchy\n     while True:\n-        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+        # Check if this directory has __init__.py (regular package)\n+        init_file = os.path.join(dirname, \"__init__.py\")\n+        if not os.path.exists(init_file):\n+            # No __init__.py found, this could be:\n+            # 1. The root directory we're looking for\n+            # 2. A namespace package directory\n+            # For now, return this directory as the python path\n             return dirname\n+            \n+        # Move up one level\n         old_dirname = dirname\n         dirname = os.path.dirname(dirname)\n+        \n+        # Prevent infinite loop at filesystem root\n         if old_dirname == dirname:\n             return os.getcwd()\n \n-\n def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n     \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n     return any(file_pattern.match(element) for file_pattern in ignore_list_re)\n@@ -90,8 +104,15 @@ def expand_modules(\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +152,12 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n+            and os.path.isdir(filepath)\n+            and os.path.exists(os.path.join(filepath, \"__init__.py\"))\n         )\n-        if has_init or is_namespace or is_directory:\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_2": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..8a9da7880 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -23,23 +23,54 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path by finding the root directory that should be in sys.path.\n+    \n+    This function walks up the directory tree to find the appropriate root directory\n+    for Python module resolution, handling both traditional packages (with __init__.py)\n+    and namespace packages (PEP 420).\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n         dirname = os.path.dirname(dirname)\n+    \n+    # Walk up the directory tree\n     while True:\n-        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+        parent_dirname = os.path.dirname(dirname)\n+        \n+        # If we've reached the root or can't go higher, return current directory\n+        if parent_dirname == dirname:\n             return dirname\n-        old_dirname = dirname\n-        dirname = os.path.dirname(dirname)\n-        if old_dirname == dirname:\n-            return os.getcwd()\n-\n+        \n+        # Check if parent contains __init__.py (traditional package)\n+        parent_init = os.path.join(parent_dirname, \"__init__.py\")\n+        if os.path.exists(parent_init):\n+            dirname = parent_dirname\n+            continue\n+        \n+        # Check if parent could be a namespace package by looking for Python files\n+        # or subdirectories that look like Python modules\n+        has_python_content = False\n+        try:\n+            for item in os.listdir(parent_dirname):\n+                item_path = os.path.join(parent_dirname, item)\n+                if (item.endswith('.py') or \n+                    (os.path.isdir(item_path) and \n+                     (os.path.exists(os.path.join(item_path, \"__init__.py\")) or\n+                      any(f.endswith('.py') for f in os.listdir(item_path) if os.path.isfile(os.path.join(item_path, f)))))):\n+                    has_python_content = True\n+                    break\n+        except (OSError, PermissionError):\n+            # If we can't read the directory, assume it's not a Python package\n+            has_python_content = False\n+        \n+        if has_python_content:\n+            dirname = parent_dirname\n+            continue\n+        \n+        # No indication this is a Python package, return current directory\n+        return dirname\n \n def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n     \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n@@ -90,8 +121,15 @@ def expand_modules(\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if this directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +169,12 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n             and os.path.basename(filepath) == \"__init__.py\"\n+            and os.path.exists(filepath)\n         )\n-        if has_init or is_namespace or is_directory:\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_3": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..ffe3789d7 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -23,24 +23,40 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for a given filepath.\n+    \n+    This function finds the appropriate directory to add to sys.path by walking\n+    up the directory tree until it finds a directory that doesn't contain an\n+    __init__.py file (indicating it's not part of a package).\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n         dirname = os.path.dirname(dirname)\n+    \n+    # Walk up the directory tree to find the root of the package structure\n     while True:\n-        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n-            return dirname\n+        init_file = os.path.join(dirname, \"__init__.py\")\n+        # Check if this directory contains __init__.py OR if it's a namespace package\n+        # by checking if any Python files exist in the directory\n+        if not os.path.exists(init_file):\n+            # Also check if this directory contains any .py files to determine\n+            # if it could be a namespace package\n+            has_py_files = any(\n+                f.endswith('.py') for f in os.listdir(dirname) \n+                if os.path.isfile(os.path.join(dirname, f))\n+            )\n+            # If no __init__.py and no .py files, or if we're at a reasonable stopping point\n+            if not has_py_files or dirname == os.path.dirname(dirname):\n+                return dirname\n+        \n         old_dirname = dirname\n         dirname = os.path.dirname(dirname)\n+        # Prevent infinite loop at filesystem root\n         if old_dirname == dirname:\n             return os.getcwd()\n \n-\n def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n     \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n     return any(file_pattern.match(element) for file_pattern in ignore_list_re)\n@@ -90,8 +106,15 @@ def expand_modules(\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +154,12 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n+            and os.path.isdir(filepath)\n+            and os.path.exists(os.path.join(filepath, \"__init__.py\"))\n         )\n-        if has_init or is_namespace or is_directory:\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_4": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..e89ee51be 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -23,23 +23,44 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path by finding the topmost directory that should be \n+    added to sys.path. This handles both traditional packages (with __init__.py)\n+    and namespace packages (PEP 420).\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n         dirname = os.path.dirname(dirname)\n+    \n+    # For namespace packages, we need to find the parent directory that\n+    # contains the namespace package structure\n+    original_dirname = dirname\n     while True:\n-        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+        parent_dirname = os.path.dirname(dirname)\n+        if parent_dirname == dirname:  # reached root\n             return dirname\n-        old_dirname = dirname\n-        dirname = os.path.dirname(dirname)\n-        if old_dirname == dirname:\n-            return os.getcwd()\n-\n+            \n+        # Check if parent contains an __init__.py (traditional package)\n+        # or if it's a valid namespace package parent\n+        if os.path.exists(os.path.join(parent_dirname, \"__init__.py\")):\n+            dirname = parent_dirname\n+            continue\n+            \n+        # Check if this could be a namespace package structure\n+        # by seeing if there are other Python modules/packages at this level\n+        try:\n+            siblings = [item for item in os.listdir(parent_dirname) \n+                       if os.path.isdir(os.path.join(parent_dirname, item)) \n+                       or item.endswith('.py')]\n+            if len(siblings) > 1:  # Multiple items suggest this is a package level\n+                dirname = parent_dirname\n+                continue\n+        except (OSError, PermissionError):\n+            pass\n+            \n+        # If we can't go further up, return current directory\n+        return dirname\n \n def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n     \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n@@ -90,8 +111,15 @@ def expand_modules(\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if this directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +159,12 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n             and os.path.basename(filepath) == \"__init__.py\"\n+            and os.path.exists(filepath)\n         )\n-        if has_init or is_namespace or is_directory:\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_5": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..818660675 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -23,24 +23,41 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path, handling both regular packages and namespace packages.\n+    \n+    This function finds the appropriate Python path by traversing up the directory\n+    tree until it finds a directory that is not part of a Python package.\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n         dirname = os.path.dirname(dirname)\n+    \n     while True:\n-        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+        # Check if current directory has __init__.py (regular package)\n+        has_init = os.path.exists(os.path.join(dirname, \"__init__.py\"))\n+        \n+        # Check if current directory contains Python files (potential namespace package)\n+        has_python_files = False\n+        if os.path.isdir(dirname):\n+            try:\n+                for item in os.listdir(dirname):\n+                    if item.endswith('.py') and os.path.isfile(os.path.join(dirname, item)):\n+                        has_python_files = True\n+                        break\n+            except (OSError, PermissionError):\n+                pass\n+        \n+        # If no __init__.py and no Python files, this is not a package directory\n+        if not has_init and not has_python_files:\n             return dirname\n+            \n         old_dirname = dirname\n         dirname = os.path.dirname(dirname)\n         if old_dirname == dirname:\n             return os.getcwd()\n \n-\n def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n     \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n     return any(file_pattern.match(element) for file_pattern in ignore_list_re)\n@@ -90,8 +107,15 @@ def expand_modules(\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if this directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +155,12 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n             and os.path.basename(filepath) == \"__init__.py\"\n+            and os.path.exists(filepath)\n         )\n-        if has_init or is_namespace or is_directory:\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_6": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..d8f279d3a 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -23,23 +23,39 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path by finding the root directory that should be added to sys.path.\n+    \n+    This function finds the topmost directory that contains Python modules/packages\n+    by walking up the directory tree and checking for package indicators.\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n         dirname = os.path.dirname(dirname)\n+    \n+    # Walk up the directory tree to find the root of the Python package structure\n+    last_python_dir = dirname\n     while True:\n-        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n-            return dirname\n-        old_dirname = dirname\n-        dirname = os.path.dirname(dirname)\n-        if old_dirname == dirname:\n-            return os.getcwd()\n-\n+        parent_dir = os.path.dirname(dirname)\n+        if parent_dir == dirname:  # Reached filesystem root\n+            break\n+            \n+        # Check if parent directory contains Python files or is a namespace package\n+        has_python_files = any(\n+            f.endswith('.py') for f in os.listdir(parent_dir) \n+            if os.path.isfile(os.path.join(parent_dir, f))\n+        )\n+        has_init = os.path.exists(os.path.join(parent_dir, \"__init__.py\"))\n+        \n+        # If parent has Python content, continue up; otherwise stop here\n+        if has_python_files or has_init:\n+            last_python_dir = parent_dir\n+            dirname = parent_dir\n+        else:\n+            break\n+    \n+    return last_python_dir\n \n def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n     \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n@@ -90,8 +106,14 @@ def expand_modules(\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                init_py = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_py):\n+                    filepath = init_py\n+                else:\n+                    # Directory exists but is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +153,12 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n             and os.path.basename(filepath) == \"__init__.py\"\n+            and os.path.exists(filepath)\n         )\n-        if has_init or is_namespace or is_directory:\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_7": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..ab5f642d5 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -23,23 +23,50 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for a given filepath.\n+    \n+    This function handles both regular packages (with __init__.py) and \n+    namespace packages (without __init__.py) introduced in Python 3.3.\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n         dirname = os.path.dirname(dirname)\n+    \n+    # Find the topmost directory that could be a Python package\n     while True:\n-        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n-            return dirname\n-        old_dirname = dirname\n-        dirname = os.path.dirname(dirname)\n-        if old_dirname == dirname:\n+        parent_dirname = os.path.dirname(dirname)\n+        if parent_dirname == dirname:  # reached filesystem root\n             return os.getcwd()\n-\n+            \n+        # Check if parent contains Python files or subdirectories with Python files\n+        # This indicates it could be a namespace package\n+        has_python_content = False\n+        try:\n+            for item in os.listdir(parent_dirname):\n+                item_path = os.path.join(parent_dirname, item)\n+                if item.endswith('.py'):\n+                    has_python_content = True\n+                    break\n+                elif os.path.isdir(item_path) and item != dirname.split(os.sep)[-1]:\n+                    # Check if this sibling directory has Python content\n+                    try:\n+                        for subitem in os.listdir(item_path):\n+                            if subitem.endswith('.py') or subitem == '__init__.py':\n+                                has_python_content = True\n+                                break\n+                    except (OSError, PermissionError):\n+                        continue\n+                    if has_python_content:\n+                        break\n+        except (OSError, PermissionError):\n+            return dirname\n+            \n+        if not has_python_content:\n+            return dirname\n+            \n+        dirname = parent_dirname\n \n def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n     \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n@@ -90,8 +117,15 @@ def expand_modules(\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if this directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +165,12 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n             and os.path.basename(filepath) == \"__init__.py\"\n+            and os.path.exists(filepath)\n         )\n-        if has_init or is_namespace or is_directory:\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_8": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..01e013c42 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -23,23 +23,34 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path by finding the root directory that should be added to sys.path.\n+    \n+    This function traverses up the directory tree to find the appropriate root directory.\n+    It handles both traditional packages (with __init__.py) and namespace packages.\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n         dirname = os.path.dirname(dirname)\n+    \n+    # Start from the current directory and work upwards\n+    current_dir = dirname\n     while True:\n-        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n-            return dirname\n-        old_dirname = dirname\n-        dirname = os.path.dirname(dirname)\n-        if old_dirname == dirname:\n-            return os.getcwd()\n-\n+        parent_dir = os.path.dirname(current_dir)\n+        \n+        # If we've reached the filesystem root, return current directory\n+        if current_dir == parent_dir:\n+            return current_dir\n+            \n+        # Check if parent directory contains __init__.py (traditional package)\n+        # or if it's a namespace package that should be included\n+        if os.path.exists(os.path.join(parent_dir, \"__init__.py\")):\n+            # Parent is a package, continue traversing up\n+            current_dir = parent_dir\n+        else:\n+            # Parent is not a package, current_dir is the root we want\n+            return current_dir\n \n def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -> bool:\n     \"\"\"Determines if the element is matched in a regex ignore-list.\"\"\"\n@@ -90,8 +101,15 @@ def expand_modules(\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if this directory is actually a Python package\n+                init_py_path = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_py_path):\n+                    filepath = init_py_path\n+                else:\n+                    # Directory exists but is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +149,12 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n             and os.path.basename(filepath) == \"__init__.py\"\n+            and os.path.exists(filepath)\n         )\n-        if has_init or is_namespace or is_directory:\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n"
  }
}