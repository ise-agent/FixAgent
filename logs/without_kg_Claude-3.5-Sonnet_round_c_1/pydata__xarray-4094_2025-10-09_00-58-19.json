{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/xarray/xarray/core/dataarray.py lines 1964-1964)": "\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
    "Location 2 (/root/hy/projects_1/xarray/xarray/core/dataarray.py lines 1961-1967)": "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            selected = self.sel({variable_dim: k}).squeeze(drop=True)\n            # Explicitly drop the variable dimension coordinate to avoid conflicts\n            if variable_dim in selected.coords:\n                selected = selected.drop_vars(variable_dim, errors='ignore')\n            data_dict[k] = selected\n\n        # unstacked dataset\n        return Dataset(data_dict)\n",
    "Location 3 (/root/hy/projects_1/xarray/xarray/core/dataset.py lines 3478-3483)": "\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/xarray/xarray/core/dataarray.py lines 1964-1964)": [
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n"
    ],
    "Location 2 (/root/hy/projects_1/xarray/xarray/core/dataarray.py lines 1961-1967)": [
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            selected = self.sel({variable_dim: k}).squeeze(drop=True)\n            # Drop the variable dimension coordinate to avoid conflicts\n            if variable_dim in selected.coords:\n                selected = selected.drop_vars(variable_dim)\n            data_dict[k] = selected\n\n        # unstacked dataset\n        return Dataset(data_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n\n        # unstacked dataset\n        return Dataset(data_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n\n        # unstacked dataset\n        return Dataset(data_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n\n        # unstacked dataset\n        return Dataset(data_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n\n        # unstacked dataset\n        return Dataset(data_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            selected = self.sel({variable_dim: k}).squeeze(drop=True)\n            # Explicitly drop the variable dimension coordinate to avoid conflicts\n            if variable_dim in selected.coords:\n                selected = selected.drop_vars(variable_dim)\n            data_dict[k] = selected\n\n        # unstacked dataset\n        return Dataset(data_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n\n        # unstacked dataset\n        return Dataset(data_dict)\n",
      "\n        # pull variables out of datarray\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n\n        # unstacked dataset\n        return Dataset(data_dict)\n"
    ],
    "Location 3 (/root/hy/projects_1/xarray/xarray/core/dataset.py lines 3478-3483)": [
      "\n                # to_stacked_array creates a variable dimension coordinate with\n                # the same name as the variable dimension for single-dimension variables.\n                # We need to drop this coordinate to avoid MergeError during Dataset creation.\n                data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n        data_dict = {}\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n        for k in self.data_vars:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n            # Use drop_vars to explicitly remove the variable_dim coordinate\n            # This prevents coordinate conflicts when the variable has only one dimension\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n        for k in self.data_vars:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n            coords_dict[k] = OrderedDict(data_dict[k].coords)\n",
      "\n        for k in variables:\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n",
      "\n            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..6a190d8a 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,15 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         # unstacked dataset\n         return Dataset(data_dict)\n+        return Dataset(data_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex a024324b..fbe3dda0 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3475,6 +3475,7 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         # coerce the levels of the MultiIndex to have the same type as the\n         # input dimensions. This code is messy, so it might be better to just\n         # input a dummy value for the singleton dimension.\n+\n         idx = data_array.indexes[new_dim]\n         levels = [idx.levels[0]] + [\n             level.astype(self[level.name].dtype) for level in idx.levels[1:]\n",
    "variant_0": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..bb986743 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,19 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            selected = self.sel({variable_dim: k}).squeeze(drop=True)\n+            # Explicitly drop the variable dimension coordinate to avoid conflicts\n+            if variable_dim in selected.coords:\n+                selected = selected.drop_vars(variable_dim, errors='ignore')\n+            data_dict[k] = selected\n \n         # unstacked dataset\n         return Dataset(data_dict)\n+        return Dataset(data_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex a024324b..ee4d2630 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3475,12 +3475,9 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         # coerce the levels of the MultiIndex to have the same type as the\n         # input dimensions. This code is messy, so it might be better to just\n         # input a dummy value for the singleton dimension.\n-        idx = data_array.indexes[new_dim]\n-        levels = [idx.levels[0]] + [\n-            level.astype(self[level.name].dtype) for level in idx.levels[1:]\n-        ]\n-        new_idx = idx.set_levels(levels)\n-        data_array[new_dim] = IndexVariable(new_dim, new_idx)\n+\n+        for k in variables:\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         if name is not None:\n             data_array.name = name\n",
    "variant_1": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..14e80f79 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,10 +1958,19 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            selected = self.sel({variable_dim: k}).squeeze(drop=True)\n+            # Drop the variable dimension coordinate to avoid conflicts\n+            if variable_dim in selected.coords:\n+                selected = selected.drop_vars(variable_dim)\n+            data_dict[k] = selected\n+\n+        # unstacked dataset\n+        return Dataset(data_dict)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         # unstacked dataset\n         return Dataset(data_dict)\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex a024324b..4ac988d1 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3475,12 +3475,11 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         # coerce the levels of the MultiIndex to have the same type as the\n         # input dimensions. This code is messy, so it might be better to just\n         # input a dummy value for the singleton dimension.\n-        idx = data_array.indexes[new_dim]\n-        levels = [idx.levels[0]] + [\n-            level.astype(self[level.name].dtype) for level in idx.levels[1:]\n-        ]\n-        new_idx = idx.set_levels(levels)\n-        data_array[new_dim] = IndexVariable(new_dim, new_idx)\n+\n+                # to_stacked_array creates a variable dimension coordinate with\n+                # the same name as the variable dimension for single-dimension variables.\n+                # We need to drop this coordinate to avoid MergeError during Dataset creation.\n+                data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         if name is not None:\n             data_array.name = name\n",
    "variant_2": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..4e1eb7d1 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,10 +1958,15 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n+\n+        # unstacked dataset\n+        return Dataset(data_dict)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         # unstacked dataset\n         return Dataset(data_dict)\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex a024324b..9ecf862b 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3475,12 +3475,10 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         # coerce the levels of the MultiIndex to have the same type as the\n         # input dimensions. This code is messy, so it might be better to just\n         # input a dummy value for the singleton dimension.\n-        idx = data_array.indexes[new_dim]\n-        levels = [idx.levels[0]] + [\n-            level.astype(self[level.name].dtype) for level in idx.levels[1:]\n-        ]\n-        new_idx = idx.set_levels(levels)\n-        data_array[new_dim] = IndexVariable(new_dim, new_idx)\n+\n+        data_dict = {}\n+        for k in variables:\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         if name is not None:\n             data_array.name = name\n",
    "variant_3": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..6a190d8a 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,15 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         # unstacked dataset\n         return Dataset(data_dict)\n+        return Dataset(data_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex a024324b..78e2fc04 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3475,12 +3475,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         # coerce the levels of the MultiIndex to have the same type as the\n         # input dimensions. This code is messy, so it might be better to just\n         # input a dummy value for the singleton dimension.\n-        idx = data_array.indexes[new_dim]\n-        levels = [idx.levels[0]] + [\n-            level.astype(self[level.name].dtype) for level in idx.levels[1:]\n-        ]\n-        new_idx = idx.set_levels(levels)\n-        data_array[new_dim] = IndexVariable(new_dim, new_idx)\n+\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         if name is not None:\n             data_array.name = name\n",
    "variant_4": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..6a190d8a 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,15 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         # unstacked dataset\n         return Dataset(data_dict)\n+        return Dataset(data_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex a024324b..280c9f76 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3475,12 +3475,9 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         # coerce the levels of the MultiIndex to have the same type as the\n         # input dimensions. This code is messy, so it might be better to just\n         # input a dummy value for the singleton dimension.\n-        idx = data_array.indexes[new_dim]\n-        levels = [idx.levels[0]] + [\n-            level.astype(self[level.name].dtype) for level in idx.levels[1:]\n-        ]\n-        new_idx = idx.set_levels(levels)\n-        data_array[new_dim] = IndexVariable(new_dim, new_idx)\n+\n+        for k in self.data_vars:\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         if name is not None:\n             data_array.name = name\n",
    "variant_5": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..4e1eb7d1 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,10 +1958,15 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n+\n+        # unstacked dataset\n+        return Dataset(data_dict)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         # unstacked dataset\n         return Dataset(data_dict)\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex a024324b..902621f8 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3475,12 +3475,10 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         # coerce the levels of the MultiIndex to have the same type as the\n         # input dimensions. This code is messy, so it might be better to just\n         # input a dummy value for the singleton dimension.\n-        idx = data_array.indexes[new_dim]\n-        levels = [idx.levels[0]] + [\n-            level.astype(self[level.name].dtype) for level in idx.levels[1:]\n-        ]\n-        new_idx = idx.set_levels(levels)\n-        data_array[new_dim] = IndexVariable(new_dim, new_idx)\n+\n+            # Use drop_vars to explicitly remove the variable_dim coordinate\n+            # This prevents coordinate conflicts when the variable has only one dimension\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         if name is not None:\n             data_array.name = name\n",
    "variant_6": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..9eae8b0a 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,10 +1958,19 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            selected = self.sel({variable_dim: k}).squeeze(drop=True)\n+            # Explicitly drop the variable dimension coordinate to avoid conflicts\n+            if variable_dim in selected.coords:\n+                selected = selected.drop_vars(variable_dim)\n+            data_dict[k] = selected\n+\n+        # unstacked dataset\n+        return Dataset(data_dict)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         # unstacked dataset\n         return Dataset(data_dict)\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex a024324b..a8c53966 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3475,12 +3475,10 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         # coerce the levels of the MultiIndex to have the same type as the\n         # input dimensions. This code is messy, so it might be better to just\n         # input a dummy value for the singleton dimension.\n-        idx = data_array.indexes[new_dim]\n-        levels = [idx.levels[0]] + [\n-            level.astype(self[level.name].dtype) for level in idx.levels[1:]\n-        ]\n-        new_idx = idx.set_levels(levels)\n-        data_array[new_dim] = IndexVariable(new_dim, new_idx)\n+\n+        for k in self.data_vars:\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n+            coords_dict[k] = OrderedDict(data_dict[k].coords)\n \n         if name is not None:\n             data_array.name = name\n",
    "variant_7": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..4e1eb7d1 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,10 +1958,15 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n+\n+        # unstacked dataset\n+        return Dataset(data_dict)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         # unstacked dataset\n         return Dataset(data_dict)\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex a024324b..ee4d2630 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3475,12 +3475,9 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         # coerce the levels of the MultiIndex to have the same type as the\n         # input dimensions. This code is messy, so it might be better to just\n         # input a dummy value for the singleton dimension.\n-        idx = data_array.indexes[new_dim]\n-        levels = [idx.levels[0]] + [\n-            level.astype(self[level.name].dtype) for level in idx.levels[1:]\n-        ]\n-        new_idx = idx.set_levels(levels)\n-        data_array[new_dim] = IndexVariable(new_dim, new_idx)\n+\n+        for k in variables:\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         if name is not None:\n             data_array.name = name\n",
    "variant_8": "diff --git a/xarray/core/dataarray.py b/xarray/core/dataarray.py\nindex b0df8749..6a190d8a 100644\n--- a/xarray/core/dataarray.py\n+++ b/xarray/core/dataarray.py\n@@ -1958,13 +1958,15 @@ class DataArray(AbstractArray, DataWithCoords):\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n \n+\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n-            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True)\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         # unstacked dataset\n         return Dataset(data_dict)\n+        return Dataset(data_dict)\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex a024324b..78e2fc04 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -3475,12 +3475,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         # coerce the levels of the MultiIndex to have the same type as the\n         # input dimensions. This code is messy, so it might be better to just\n         # input a dummy value for the singleton dimension.\n-        idx = data_array.indexes[new_dim]\n-        levels = [idx.levels[0]] + [\n-            level.astype(self[level.name].dtype) for level in idx.levels[1:]\n-        ]\n-        new_idx = idx.set_levels(levels)\n-        data_array[new_dim] = IndexVariable(new_dim, new_idx)\n+\n+            data_dict[k] = self.sel({variable_dim: k}).squeeze(drop=True).drop_vars(variable_dim, errors='ignore')\n \n         if name is not None:\n             data_array.name = name\n"
  }
}