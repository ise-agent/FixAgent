{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 410-415)": "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    if len(constraint_names) != 1:\n        # If we found multiple constraints and we're looking for an index,\n        # try to filter out unique constraints to find the pure index constraint\n        if constraint_kwargs.get('index', False) and len(constraint_names) > 1:\n            # Get constraint info to filter out unique constraints\n            non_unique_constraints = []\n            for constraint_name in constraint_names:\n                constraint_info = self._constraint_names(\n                    model, columns, exclude=meta_constraint_names | meta_index_names,\n                    unique=False, index=True\n                )\n                if constraint_name in constraint_info:\n                    non_unique_constraints.append(constraint_name)\n            \n            if len(non_unique_constraints) == 1:\n                constraint_names = non_unique_constraints\n        \n        # If we still don't have exactly one constraint, raise the error\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
    "Location 2 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 406-409)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When deleting index_together constraints, exclude unique constraints\n        # to avoid conflicts when both unique_together and index_together exist\n        # on the same fields\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') is True:\n            # For index deletion, also exclude unique constraints\n            unique_constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                unique=True\n            )\n            exclude_names = exclude_names | set(unique_constraint_names)\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=exclude_names,\n            **constraint_kwargs\n        )\n",
    "Location 3 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 1160-1161)": "\n                if index is not None and infodict['index'] != index:\n                    # When filtering for non-index constraints (index=False), skip if this is an index\n                    # When filtering for index constraints (index=True), include both regular indexes and unique indexes\n                    if not index or not infodict['index']:\n                        continue\n",
    "Location 4 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 396-397)": "\ndef alter_index_together(self, model, old_index_together, new_index_together):\n    \"\"\"\n    Deal with a model changing its index_together. The input\n    index_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_index_together}\n    news = {tuple(fields) for fields in new_index_together}\n    # Deleted indexes\n    for fields in olds.difference(news):\n        self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n    # Created indexes\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
    "Location 5 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 402-403)": "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    \n    # If we're looking for index constraints and found multiple, filter out unique constraints\n    if constraint_kwargs.get('index') and len(constraint_names) > 1:\n        # Get all constraints for these columns\n        all_constraints = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names\n        )\n        # Filter out unique constraints when looking for regular indexes\n        filtered_names = []\n        for name in constraint_names:\n            # Check if this constraint is unique by looking at unique constraints on same columns\n            unique_constraints = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                unique=True\n            )\n            if name not in unique_constraints:\n                filtered_names.append(name)\n        \n        # Use filtered list if we found non-unique constraints\n        if filtered_names:\n            constraint_names = filtered_names\n    \n    if len(constraint_names) != 1:\n        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n            len(constraint_names),\n            model._meta.db_table,\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 410-415)": [
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    if len(constraint_names) != 1:\n        # If we're looking for an index constraint and found multiple constraints,\n        # filter out unique constraints to avoid conflicts with unique_together\n        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n            # Get constraint info to filter out unique constraints\n            all_constraints = self.connection.introspection.get_constraints(\n                self.connection.cursor(), model._meta.db_table\n            )\n            # Filter constraint_names to exclude unique constraints\n            non_unique_constraints = []\n            for name in constraint_names:\n                if name in all_constraints and not all_constraints[name].get('unique', False):\n                    non_unique_constraints.append(name)\n            \n            if len(non_unique_constraints) == 1:\n                constraint_names = non_unique_constraints\n            elif len(non_unique_constraints) == 0:\n                # If no non-unique constraints found, this might be expected behavior\n                # when unique_together creates the only index\n                return\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we're deleting an index and find multiple constraints, filter for non-unique ones\n        if len(constraint_names) > 1 and constraint_kwargs.get('index') is True:\n            # Get constraint info to filter out unique constraints\n            all_constraints = self.connection.introspection.get_constraints(\n                self.connection.cursor(), model._meta.db_table\n            )\n            non_unique_constraints = [\n                name for name in constraint_names\n                if name in all_constraints and not all_constraints[name].get('unique', False)\n            ]\n            if len(non_unique_constraints) == 1:\n                constraint_names = non_unique_constraints\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) > 1:\n            # If multiple constraints exist, filter to find the right type\n            # When deleting index_together, we want non-unique indexes only\n            if constraint_kwargs.get('index') is True:\n                # Filter out unique constraints when looking for index constraints\n                filtered_names = []\n                for name in constraint_names:\n                    # Check if this constraint is a unique constraint\n                    unique_constraint_names = self._constraint_names(\n                        model, columns, exclude=meta_constraint_names | meta_index_names,\n                        unique=True\n                    )\n                    if name not in unique_constraint_names:\n                        filtered_names.append(name)\n                constraint_names = filtered_names\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    if len(constraint_names) == 0:\n        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n            len(constraint_names),\n            model._meta.db_table,\n            \", \".join(columns),\n        ))\n    elif len(constraint_names) > 1:\n        # When multiple constraints exist on the same columns, prioritize based on type\n        # For index deletion, prefer non-unique index constraints over unique ones\n        if constraint_kwargs.get('index', False):\n            # Filter out unique constraints when deleting index constraints\n            filtered_names = []\n            for name in constraint_names:\n                # Check if this is a unique constraint by looking for '_uniq' suffix\n                # or by checking constraint properties\n                if not name.endswith('_uniq'):\n                    filtered_names.append(name)\n            if len(filtered_names) == 1:\n                constraint_names = filtered_names\n            elif len(filtered_names) == 0:\n                # No non-unique constraints found, this might be an error condition\n                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                ))\n            else:\n                # Multiple non-unique constraints, still ambiguous\n                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                    len(filtered_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                ))\n        else:\n            # For non-index constraints, maintain existing behavior\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    if len(constraint_names) != 1:\n        # If we're looking for an index constraint and found multiple constraints,\n        # filter to find non-unique index constraints to avoid conflicts with unique_together\n        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n            # Get constraint info to filter out unique constraints\n            all_constraints = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names\n            )\n            # Filter for non-unique index constraints by checking constraint details\n            filtered_names = []\n            for name in constraint_names:\n                constraint_info = None\n                for info in self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table).values():\n                    if info.get('index') and not info.get('unique', False):\n                        # Check if this constraint matches our columns\n                        if set(info['columns']) == set(columns):\n                            filtered_names.append(name)\n                            break\n            if len(filtered_names) == 1:\n                constraint_names = filtered_names\n            elif len(filtered_names) == 0:\n                # If no non-unique index found, fall back to original behavior\n                pass\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) == 0:\n            raise ValueError(\"Found no constraints for %s(%s)\" % (\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        elif len(constraint_names) > 1:\n            # If we have multiple constraints on the same columns, filter by type\n            if constraint_kwargs.get('index') is True:\n                # When deleting an index, prefer non-unique indexes over unique ones\n                filtered_names = []\n                for name in constraint_names:\n                    # Check if this constraint is unique by examining database metadata\n                    constraint_info = self.connection.introspection.get_constraints(\n                        self.connection.cursor(), model._meta.db_table\n                    )\n                    if name in constraint_info and not constraint_info[name].get('unique', False):\n                        filtered_names.append(name)\n                \n                # If we found non-unique indexes, use those; otherwise fall back to all matches\n                if filtered_names:\n                    constraint_names = filtered_names\n            \n            # If we still have multiple matches, raise an error\n            if len(constraint_names) != 1:\n                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                ))\n        \n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) != 1:\n            # If we're looking for an index constraint and found multiple constraints,\n            # try to filter out unique constraints to find the pure index constraint\n            if constraint_kwargs.get('index') and len(constraint_names) > 1:\n                # Get all constraints on these columns\n                all_constraints = self._constraint_names(\n                    model, columns, exclude=meta_constraint_names | meta_index_names\n                )\n                # Filter to find non-unique index constraints\n                non_unique_constraints = []\n                for constraint_name in all_constraints:\n                    constraint_info = self._constraint_info(model, constraint_name)\n                    if constraint_info and constraint_info.get('index') and not constraint_info.get('unique'):\n                        non_unique_constraints.append(constraint_name)\n                \n                if len(non_unique_constraints) == 1:\n                    constraint_names = non_unique_constraints\n                else:\n                    # If we still have multiple or no non-unique constraints,\n                    # fall back to the original error\n                    raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                        len(constraint_names),\n                        model._meta.db_table,\n                        \", \".join(columns),\n                    ))\n            else:\n                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) != 1:\n            # If we're looking for an index constraint and found multiple constraints,\n            # filter out unique constraints to avoid conflicts with unique_together\n            if constraint_kwargs.get('index') and len(constraint_names) > 1:\n                # Get constraint info to filter out unique constraints\n                all_constraints = self._constraint_names(\n                    model, columns, exclude=meta_constraint_names | meta_index_names\n                )\n                non_unique_constraints = []\n                for constraint_name in constraint_names:\n                    # Check if this is a non-unique index by examining constraint info\n                    constraint_info = None\n                    for info in self.connection.introspection.get_constraints(\n                        self.connection.cursor(), model._meta.db_table\n                    ).values():\n                        if info.get('columns') == columns and not info.get('unique', False):\n                            if constraint_name in str(info):\n                                non_unique_constraints.append(constraint_name)\n                                break\n                \n                # If we found non-unique constraints, use those\n                if non_unique_constraints:\n                    constraint_names = non_unique_constraints\n            \n            # If we still don't have exactly one constraint, raise the error\n            if len(constraint_names) != 1:\n                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 406-409)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When deleting index constraints, exclude unique constraints to avoid conflicts\n        exclude_set = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n            # For non-unique index deletion, also exclude unique constraints\n            constraint_kwargs = constraint_kwargs.copy()\n            constraint_kwargs['unique'] = False\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=exclude_set,\n            **constraint_kwargs\n        )\n        \n        # If we still find multiple constraints, filter more specifically\n        if len(constraint_names) > 1 and constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n            # Try to find non-unique index constraints only\n            filtered_names = []\n            for name in constraint_names:\n                # Check if this constraint is unique by examining its properties\n                constraint_info = self._get_constraint_info(model, name)\n                if constraint_info and not constraint_info.get('unique', False):\n                    filtered_names.append(name)\n            if len(filtered_names) == 1:\n                constraint_names = filtered_names\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When deleting index_together, exclude unique constraints to avoid conflicts\n        if constraint_kwargs.get('index') is True:\n            constraint_kwargs = constraint_kwargs.copy()\n            constraint_kwargs['unique'] = False\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When looking for index constraints, exclude unique constraints to avoid conflicts\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique', True):\n            # For non-unique indexes, also exclude unique constraints on the same columns\n            unique_constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                unique=True\n            )\n            exclude_names = exclude_names | set(unique_constraint_names)\n        \n        constraint_names = self._constraint_names(\n            model, columns, exclude=exclude_names,\n            **constraint_kwargs\n        )\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Get all matching constraints\n        all_constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we're looking for index constraints and found multiple, filter out unique constraints\n        if constraint_kwargs.get('index') and len(all_constraint_names) > 1:\n            # Try to find non-unique index constraints by excluding those that are also unique\n            unique_constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                unique=True\n            )\n            constraint_names = [name for name in all_constraint_names if name not in unique_constraint_names]\n            \n            # If we still have multiple or no constraints, fall back to the original list\n            if len(constraint_names) != 1:\n                constraint_names = all_constraint_names\n        else:\n            constraint_names = all_constraint_names\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # First try to find constraints with the exact criteria\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we're looking for index constraints and found multiple,\n        # filter out unique constraints to avoid conflicts with unique_together\n        if len(constraint_names) > 1 and constraint_kwargs.get('index'):\n            # Get all constraints on these columns\n            all_constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names\n            )\n            # Filter to find non-unique index constraints only\n            filtered_names = []\n            for name in constraint_names:\n                # Check if this constraint is unique by looking for it in unique constraints\n                unique_constraint_names = self._constraint_names(\n                    model, columns, exclude=meta_constraint_names | meta_index_names,\n                    unique=True\n                )\n                if name not in unique_constraint_names:\n                    filtered_names.append(name)\n            \n            # Use filtered list if we found non-unique constraints\n            if filtered_names:\n                constraint_names = filtered_names\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When deleting index_together constraints, exclude unique constraints\n        # to avoid conflicts with unique_together on the same fields\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n            # For index deletion, also exclude unique constraints\n            unique_constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                unique=True\n            )\n            exclude_names = exclude_names | set(unique_constraint_names)\n        \n        constraint_names = self._constraint_names(\n            model, columns, exclude=exclude_names,\n            **constraint_kwargs\n        )\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Get all matching constraint names\n        all_constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we're looking for index constraints and found multiple, \n        # filter out unique constraints to avoid conflicts with unique_together\n        if constraint_kwargs.get('index') and len(all_constraint_names) > 1:\n            # Filter out unique constraints when deleting index_together\n            constraint_names = []\n            for name in all_constraint_names:\n                # Get constraint info to check if it's unique\n                constraint_info = self._constraint_names(\n                    model, columns, exclude=meta_constraint_names | meta_index_names,\n                    unique=True\n                )\n                if name not in constraint_info:\n                    constraint_names.append(name)\n            \n            # If we still have multiple non-unique constraints, fall back to original behavior\n            if len(constraint_names) != 1:\n                constraint_names = all_constraint_names\n        else:\n            constraint_names = all_constraint_names\n            \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we're looking for index constraints and found multiple, filter out unique constraints\n        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n            # Get all constraint info to filter by type\n            all_constraints = self._get_constraint_names(model, columns, exclude=meta_constraint_names | meta_index_names)\n            non_unique_constraints = []\n            for name in constraint_names:\n                constraint_info = all_constraints.get(name, {})\n                # Only include non-unique index constraints\n                if constraint_info.get('index') and not constraint_info.get('unique'):\n                    non_unique_constraints.append(name)\n            \n            # Use non-unique constraints if we found any, otherwise keep original list\n            if non_unique_constraints:\n                constraint_names = non_unique_constraints\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 1160-1161)": [
      "\n                if index is not None and infodict['index'] != index:\n                    # Skip if this is a unique constraint when we're looking for a non-unique index\n                    if index is True and infodict.get('unique', False):\n                        continue\n                    # Skip if this doesn't match the index requirement\n                    if infodict['index'] != index:\n                        continue\n                else:\n                    continue\n",
      "\n                if index is not None and infodict['index'] != index:\n                    # Skip unique constraints when looking for non-unique indexes\n                    if index is True and infodict.get('unique', False):\n                        continue\n                    continue\n",
      "\n                if index is not None and infodict['index'] != index:\n                    # Skip if this constraint doesn't match the index requirement\n                    # but allow unique constraints to be considered as indexes when index=True\n                    if not (index is True and infodict['unique'] and infodict['index']):\n                        continue\n",
      "\n                if index is not None and infodict['index'] != index:\n                    # When filtering for index constraints, also consider if this is a unique constraint\n                    # to avoid conflicts when both unique_together and index_together exist on same fields\n                    if index and infodict['unique'] and not infodict.get('primary_key', False):\n                        # This is a unique constraint that also acts as an index\n                        # Skip it when specifically looking for non-unique index constraints\n                        continue\n                    elif not index and not infodict['index']:\n                        # When looking for non-index constraints, skip if it's not an index\n                        continue\n                    else:\n                        continue\n",
      "\n                if index is not None and infodict['index'] != index:\n                    # Skip if index constraint type doesn't match, but allow unique constraints\n                    # to also be considered as indexes when index=True is requested\n                    if not (index is True and infodict['unique'] is True):\n                        continue\n",
      "\n                if index is not None and infodict['index'] != index:\n                    # Skip unique constraints when looking for regular indexes\n                    if index is True and infodict.get('unique', False):\n                        continue\n                    continue\n",
      "\n                if index is not None and infodict['index'] != index:\n                    # When filtering for index=True, exclude unique constraints to avoid conflicts\n                    # with unique_together constraints that are also indexes\n                    if index is True and infodict.get('unique', False):\n                        continue\n                    # When filtering for index=False, include unique constraints\n                    if index is False and infodict.get('unique', False):\n                        pass\n                    elif infodict['index'] != index:\n                        continue\n",
      "\n                if index is not None and infodict['index'] != index:\n                    # When filtering for non-index constraints (index=False), skip unique constraints\n                    # that are also indexes to avoid conflicts with index_together operations\n                    if not index and infodict['unique'] and infodict['index']:\n                        continue\n                    # When filtering for index constraints (index=True), prefer non-unique indexes\n                    # over unique indexes when both exist on the same columns\n                    if index and infodict['unique'] and unique is None:\n                        continue\n                    # Standard index filtering\n                    continue\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 396-397)": [
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n        # Created indexes\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
      "\ndef alter_index_together(self, model, old_index_together, new_index_together):\n    \"\"\"\n    Deal with a model changing its index_together. The input\n    index_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_index_together}\n    news = {tuple(fields) for fields in new_index_together}\n    # Deleted indexes\n    for fields in olds.difference(news):\n        self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n    # Created indexes\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n        # Created indexes\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
      "\ndef alter_index_together(self, model, old_index_together, new_index_together):\n    \"\"\"\n    Deal with a model changing its index_together. The input\n    index_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_index_together}\n    news = {tuple(fields) for fields in new_index_together}\n    # Deleted indexes\n    for fields in olds.difference(news):\n        self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n    # Created indexes\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
      "\ndef alter_index_together(self, model, old_index_together, new_index_together):\n    \"\"\"\n    Deal with a model changing its index_together. The input\n    index_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_index_together}\n    news = {tuple(fields) for fields in new_index_together}\n    # Deleted indexes\n    for fields in olds.difference(news):\n        self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n    # Created indexes\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
      "\ndef alter_index_together(self, model, old_index_together, new_index_together):\n    \"\"\"\n    Deal with a model changing its index_together. The input\n    index_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_index_together}\n    news = {tuple(fields) for fields in new_index_together}\n    # Deleted indexes\n    for fields in olds.difference(news):\n        self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n    # Created indexes\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n        # Created indexes\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n        # Created indexes\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/backends/base/schema.py lines 402-403)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Get all constraint names matching the columns\n        all_constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we're looking for index constraints specifically and found multiple,\n        # filter out unique constraints to avoid conflicts with unique_together\n        if constraint_kwargs.get('index') and len(all_constraint_names) > 1:\n            # Get constraint info to filter out unique constraints\n            constraint_names = []\n            for constraint_name in all_constraint_names:\n                constraint_info = None\n                with self.connection.cursor() as cursor:\n                    for info in self.connection.introspection.get_constraints(cursor, model._meta.db_table).values():\n                        if info.get('columns') == columns:\n                            if constraint_name in [info.get('name', '')]:\n                                constraint_info = info\n                                break\n                \n                # Only include non-unique index constraints\n                if constraint_info and constraint_info.get('index') and not constraint_info.get('unique'):\n                    constraint_names.append(constraint_name)\n            \n            # If we still have multiple or no constraints, fall back to original behavior\n            if len(constraint_names) != 1:\n                constraint_names = all_constraint_names\n        else:\n            constraint_names = all_constraint_names\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we're looking for index constraints and found multiple, filter out unique constraints\n        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n            # Get constraint info to filter out unique constraints\n            filtered_names = []\n            for name in constraint_names:\n                constraints = self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table)\n                constraint_info = constraints.get(name, {})\n                # Only include non-unique index constraints when deleting index_together\n                if constraint_info.get('index') and not constraint_info.get('unique'):\n                    filtered_names.append(name)\n            constraint_names = filtered_names\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we're looking for an index constraint and found multiple constraints,\n        # filter out unique constraints to avoid conflicts with unique_together\n        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n            # Get constraint info to filter out unique constraints\n            filtered_names = []\n            for name in constraint_names:\n                # Check if this constraint is unique by examining database introspection\n                constraints = self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table)\n                constraint_info = constraints.get(name, {})\n                # Only include non-unique index constraints\n                if constraint_info.get('index') and not constraint_info.get('unique'):\n                    filtered_names.append(name)\n            constraint_names = filtered_names\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we found multiple constraints and we're looking for an index,\n        # filter out unique constraints to avoid conflicts\n        if len(constraint_names) > 1 and constraint_kwargs.get('index'):\n            # Get constraint info to filter out unique constraints\n            unique_constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                unique=True, index=True\n            )\n            # Remove unique constraints from the list, keeping only pure indexes\n            constraint_names = [name for name in constraint_names if name not in unique_constraint_names]\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    \n    # If we're looking for index constraints and found multiple constraints,\n    # filter out unique constraints to avoid conflicts with unique_together\n    if constraint_kwargs.get('index') and len(constraint_names) > 1:\n        # Get all constraints for these columns\n        all_constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names\n        )\n        # Filter to keep only non-unique index constraints\n        filtered_names = []\n        for name in constraint_names:\n            # Check if this constraint is unique by looking at unique constraints\n            unique_constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                unique=True\n            )\n            if name not in unique_constraint_names:\n                filtered_names.append(name)\n        \n        # Use filtered names if we found any, otherwise fall back to original\n        if filtered_names:\n            constraint_names = filtered_names\n    \n    if len(constraint_names) != 1:\n        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n            len(constraint_names),\n            model._meta.db_table,\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we found multiple constraints and we're looking for an index,\n        # filter out unique constraints to avoid conflicts with unique_together\n        if len(constraint_names) > 1 and constraint_kwargs.get('index'):\n            # Get constraint info to filter out unique constraints\n            filtered_names = []\n            for name in constraint_names:\n                constraints = self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table)\n                constraint_info = constraints.get(name, {})\n                # Only include non-unique index constraints\n                if constraint_info.get('index') and not constraint_info.get('unique'):\n                    filtered_names.append(name)\n            constraint_names = filtered_names\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # If we found multiple constraints and we're specifically looking for an index,\n        # filter out unique constraints to avoid conflicts with unique_together\n        if len(constraint_names) > 1 and constraint_kwargs.get('index'):\n            # Get constraint info to filter out unique constraints\n            filtered_names = []\n            for name in constraint_names:\n                constraint_info = self.introspection.get_constraints(\n                    self.connection.cursor(), model._meta.db_table\n                ).get(name, {})\n                # Only include non-unique index constraints when deleting index_together\n                if constraint_info.get('index') and not constraint_info.get('unique'):\n                    filtered_names.append(name)\n            constraint_names = filtered_names\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                columns,\n            ))\n        self.execute(sql % {\n            'table': self.quote_name(model._meta.db_table),\n            'name': self.quote_name(constraint_names[0]),\n        })\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    \n    # If we're looking for an index constraint and found multiple constraints,\n    # filter to exclude unique constraints to avoid conflicts\n    if len(constraint_names) > 1 and constraint_kwargs.get('index'):\n        # Get all constraint info to filter by uniqueness\n        all_constraints = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names\n        )\n        # Filter out unique constraints when looking for regular indexes\n        non_unique_constraints = []\n        for name in constraint_names:\n            constraint_info = self._get_constraint_info(model, name)\n            if not constraint_info.get('unique', False):\n                non_unique_constraints.append(name)\n        \n        if non_unique_constraints:\n            constraint_names = non_unique_constraints\n    \n    if len(constraint_names) != 1:\n        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n            len(constraint_names),\n            model._meta.db_table,\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..feab78429d 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,20 +393,28 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n+\n             self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+\n+        # When looking for index constraints to delete, exclude unique constraints\n+        # to avoid conflicts when both unique_together and index_together exist on same fields\n+        if constraint_kwargs.get('index') is True:\n+            constraint_kwargs = dict(constraint_kwargs, unique=False)\n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n@@ -1157,6 +1165,7 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != primary_key:\n                     continue\n+\n                 if index is not None and infodict['index'] != index:\n                     continue\n                 if check is not None and infodict['check'] != check:\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..9505d9c4d3 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,26 +393,119 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n-        # Created indexes\n+\n+def alter_index_together(self, model, old_index_together, new_index_together):\n+    \"\"\"\n+    Deal with a model changing its index_together. The input\n+    index_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_index_together}\n+    news = {tuple(fields) for fields in new_index_together}\n+    # Deleted indexes\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n+    # Created indexes\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    \n+    # If we're looking for index constraints and found multiple, filter out unique constraints\n+    if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+        # Get all constraints for these columns\n+        all_constraints = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names\n+        )\n+        # Filter out unique constraints when looking for regular indexes\n+        filtered_names = []\n+        for name in constraint_names:\n+            # Check if this constraint is unique by looking at unique constraints on same columns\n+            unique_constraints = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n+            )\n+            if name not in unique_constraints:\n+                filtered_names.append(name)\n+        \n+        # Use filtered list if we found non-unique constraints\n+        if filtered_names:\n+            constraint_names = filtered_names\n+    \n+    if len(constraint_names) != 1:\n+        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+            len(constraint_names),\n+            model._meta.db_table,\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # When deleting index_together constraints, exclude unique constraints\n+        # to avoid conflicts when both unique_together and index_together exist\n+        # on the same fields\n+        exclude_names = meta_constraint_names | meta_index_names\n+        if constraint_kwargs.get('index') is True:\n+            # For index deletion, also exclude unique constraints\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n+            )\n+            exclude_names = exclude_names | set(unique_constraint_names)\n+            \n         constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            model, columns, exclude=exclude_names,\n             **constraint_kwargs\n         )\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    if len(constraint_names) != 1:\n+        # If we found multiple constraints and we're looking for an index,\n+        # try to filter out unique constraints to find the pure index constraint\n+        if constraint_kwargs.get('index', False) and len(constraint_names) > 1:\n+            # Get constraint info to filter out unique constraints\n+            non_unique_constraints = []\n+            for constraint_name in constraint_names:\n+                constraint_info = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=False, index=True\n+                )\n+                if constraint_name in constraint_info:\n+                    non_unique_constraints.append(constraint_name)\n+            \n+            if len(non_unique_constraints) == 1:\n+                constraint_names = non_unique_constraints\n+        \n+        # If we still don't have exactly one constraint, raise the error\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n                 model._meta.db_table,\n                 \", \".join(columns),\n             ))\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1157,8 +1250,12 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != primary_key:\n                     continue\n+\n                 if index is not None and infodict['index'] != index:\n-                    continue\n+                    # When filtering for non-index constraints (index=False), skip if this is an index\n+                    # When filtering for index constraints (index=True), include both regular indexes and unique indexes\n+                    if not index or not infodict['index']:\n+                        continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n                 if foreign_key is not None and not infodict['foreign_key']:\n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..0b72c6382a 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,20 +393,98 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+\n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+        # Deleted indexes\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n+\n \n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n+        \n+        # Get all constraint names matching the columns\n+        all_constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we're looking for index constraints specifically and found multiple,\n+        # filter out unique constraints to avoid conflicts with unique_together\n+        if constraint_kwargs.get('index') and len(all_constraint_names) > 1:\n+            # Get constraint info to filter out unique constraints\n+            constraint_names = []\n+            for constraint_name in all_constraint_names:\n+                constraint_info = None\n+                with self.connection.cursor() as cursor:\n+                    for info in self.connection.introspection.get_constraints(cursor, model._meta.db_table).values():\n+                        if info.get('columns') == columns:\n+                            if constraint_name in [info.get('name', '')]:\n+                                constraint_info = info\n+                                break\n+                \n+                # Only include non-unique index constraints\n+                if constraint_info and constraint_info.get('index') and not constraint_info.get('unique'):\n+                    constraint_names.append(constraint_name)\n+            \n+            # If we still have multiple or no constraints, fall back to original behavior\n+            if len(constraint_names) != 1:\n+                constraint_names = all_constraint_names\n+        else:\n+            constraint_names = all_constraint_names\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # When deleting index constraints, exclude unique constraints to avoid conflicts\n+        exclude_set = meta_constraint_names | meta_index_names\n+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n+            # For non-unique index deletion, also exclude unique constraints\n+            constraint_kwargs = constraint_kwargs.copy()\n+            constraint_kwargs['unique'] = False\n+            \n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=exclude_set,\n+            **constraint_kwargs\n+        )\n+        \n+        # If we still find multiple constraints, filter more specifically\n+        if len(constraint_names) > 1 and constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n+            # Try to find non-unique index constraints only\n+            filtered_names = []\n+            for name in constraint_names:\n+                # Check if this constraint is unique by examining its properties\n+                constraint_info = self._get_constraint_info(model, name)\n+                if constraint_info and not constraint_info.get('unique', False):\n+                    filtered_names.append(name)\n+            if len(filtered_names) == 1:\n+                constraint_names = filtered_names\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n@@ -415,6 +493,44 @@ class BaseDatabaseSchemaEditor:\n             ))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    if len(constraint_names) != 1:\n+        # If we're looking for an index constraint and found multiple constraints,\n+        # filter out unique constraints to avoid conflicts with unique_together\n+        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+            # Get constraint info to filter out unique constraints\n+            all_constraints = self.connection.introspection.get_constraints(\n+                self.connection.cursor(), model._meta.db_table\n+            )\n+            # Filter constraint_names to exclude unique constraints\n+            non_unique_constraints = []\n+            for name in constraint_names:\n+                if name in all_constraints and not all_constraints[name].get('unique', False):\n+                    non_unique_constraints.append(name)\n+            \n+            if len(non_unique_constraints) == 1:\n+                constraint_names = non_unique_constraints\n+            elif len(non_unique_constraints) == 0:\n+                # If no non-unique constraints found, this might be expected behavior\n+                # when unique_together creates the only index\n+                return\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n         if (old_db_table == new_db_table or\n@@ -1157,7 +1273,15 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != primary_key:\n                     continue\n+\n                 if index is not None and infodict['index'] != index:\n+                    # Skip if this is a unique constraint when we're looking for a non-unique index\n+                    if index is True and infodict.get('unique', False):\n+                        continue\n+                    # Skip if this doesn't match the index requirement\n+                    if infodict['index'] != index:\n+                        continue\n+                else:\n                     continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..c2d078a600 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,16 +393,65 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n-        # Created indexes\n+\n+def alter_index_together(self, model, old_index_together, new_index_together):\n+    \"\"\"\n+    Deal with a model changing its index_together. The input\n+    index_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_index_together}\n+    news = {tuple(fields) for fields in new_index_together}\n+    # Deleted indexes\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n+    # Created indexes\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        \n+        # If we're looking for index constraints and found multiple, filter out unique constraints\n+        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+            # Get constraint info to filter out unique constraints\n+            filtered_names = []\n+            for name in constraint_names:\n+                constraints = self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table)\n+                constraint_info = constraints.get(name, {})\n+                # Only include non-unique index constraints when deleting index_together\n+                if constraint_info.get('index') and not constraint_info.get('unique'):\n+                    filtered_names.append(name)\n+            constraint_names = filtered_names\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # When deleting index_together, exclude unique constraints to avoid conflicts\n+        if constraint_kwargs.get('index') is True:\n+            constraint_kwargs = constraint_kwargs.copy()\n+            constraint_kwargs['unique'] = False\n+            \n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n@@ -415,6 +464,37 @@ class BaseDatabaseSchemaEditor:\n             ))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        \n+        # If we're deleting an index and find multiple constraints, filter for non-unique ones\n+        if len(constraint_names) > 1 and constraint_kwargs.get('index') is True:\n+            # Get constraint info to filter out unique constraints\n+            all_constraints = self.connection.introspection.get_constraints(\n+                self.connection.cursor(), model._meta.db_table\n+            )\n+            non_unique_constraints = [\n+                name for name in constraint_names\n+                if name in all_constraints and not all_constraints[name].get('unique', False)\n+            ]\n+            if len(non_unique_constraints) == 1:\n+                constraint_names = non_unique_constraints\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n         if (old_db_table == new_db_table or\n@@ -1157,7 +1237,11 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != primary_key:\n                     continue\n+\n                 if index is not None and infodict['index'] != index:\n+                    # Skip unique constraints when looking for non-unique indexes\n+                    if index is True and infodict.get('unique', False):\n+                        continue\n                     continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..f0fc147c08 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,11 +393,76 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+\n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+        # Deleted indexes\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n+\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        \n+        # If we're looking for an index constraint and found multiple constraints,\n+        # filter out unique constraints to avoid conflicts with unique_together\n+        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+            # Get constraint info to filter out unique constraints\n+            filtered_names = []\n+            for name in constraint_names:\n+                # Check if this constraint is unique by examining database introspection\n+                constraints = self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table)\n+                constraint_info = constraints.get(name, {})\n+                # Only include non-unique index constraints\n+                if constraint_info.get('index') and not constraint_info.get('unique'):\n+                    filtered_names.append(name)\n+            constraint_names = filtered_names\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # When looking for index constraints, exclude unique constraints to avoid conflicts\n+        exclude_names = meta_constraint_names | meta_index_names\n+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique', True):\n+            # For non-unique indexes, also exclude unique constraints on the same columns\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n+            )\n+            exclude_names = exclude_names | set(unique_constraint_names)\n+        \n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=exclude_names,\n+            **constraint_kwargs\n+        )\n \n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n@@ -407,6 +472,22 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        if len(constraint_names) > 1:\n+            # If multiple constraints exist, filter to find the right type\n+            # When deleting index_together, we want non-unique indexes only\n+            if constraint_kwargs.get('index') is True:\n+                # Filter out unique constraints when looking for index constraints\n+                filtered_names = []\n+                for name in constraint_names:\n+                    # Check if this constraint is a unique constraint\n+                    unique_constraint_names = self._constraint_names(\n+                        model, columns, exclude=meta_constraint_names | meta_index_names,\n+                        unique=True\n+                    )\n+                    if name not in unique_constraint_names:\n+                        filtered_names.append(name)\n+                constraint_names = filtered_names\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n@@ -1157,8 +1238,12 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != primary_key:\n                     continue\n+\n                 if index is not None and infodict['index'] != index:\n-                    continue\n+                    # Skip if this constraint doesn't match the index requirement\n+                    # but allow unique constraints to be considered as indexes when index=True\n+                    if not (index is True and infodict['unique'] and infodict['index']):\n+                        continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n                 if foreign_key is not None and not infodict['foreign_key']:\n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..25ec3e4e63 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,12 +393,27 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n-        # Created indexes\n+\n+def alter_index_together(self, model, old_index_together, new_index_together):\n+    \"\"\"\n+    Deal with a model changing its index_together. The input\n+    index_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_index_together}\n+    news = {tuple(fields) for fields in new_index_together}\n+    # Deleted indexes\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n+    # Created indexes\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n@@ -407,12 +422,100 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we found multiple constraints and we're looking for an index,\n+        # filter out unique constraints to avoid conflicts\n+        if len(constraint_names) > 1 and constraint_kwargs.get('index'):\n+            # Get constraint info to filter out unique constraints\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True, index=True\n+            )\n+            # Remove unique constraints from the list, keeping only pure indexes\n+            constraint_names = [name for name in constraint_names if name not in unique_constraint_names]\n+        \n         if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Get all matching constraints\n+        all_constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        \n+        # If we're looking for index constraints and found multiple, filter out unique constraints\n+        if constraint_kwargs.get('index') and len(all_constraint_names) > 1:\n+            # Try to find non-unique index constraints by excluding those that are also unique\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n+            )\n+            constraint_names = [name for name in all_constraint_names if name not in unique_constraint_names]\n+            \n+            # If we still have multiple or no constraints, fall back to the original list\n+            if len(constraint_names) != 1:\n+                constraint_names = all_constraint_names\n+        else:\n+            constraint_names = all_constraint_names\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    if len(constraint_names) == 0:\n+        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+            len(constraint_names),\n+            model._meta.db_table,\n+            \", \".join(columns),\n+        ))\n+    elif len(constraint_names) > 1:\n+        # When multiple constraints exist on the same columns, prioritize based on type\n+        # For index deletion, prefer non-unique index constraints over unique ones\n+        if constraint_kwargs.get('index', False):\n+            # Filter out unique constraints when deleting index constraints\n+            filtered_names = []\n+            for name in constraint_names:\n+                # Check if this is a unique constraint by looking for '_uniq' suffix\n+                # or by checking constraint properties\n+                if not name.endswith('_uniq'):\n+                    filtered_names.append(name)\n+            if len(filtered_names) == 1:\n+                constraint_names = filtered_names\n+            elif len(filtered_names) == 0:\n+                # No non-unique constraints found, this might be an error condition\n+                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                ))\n+            else:\n+                # Multiple non-unique constraints, still ambiguous\n+                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                    len(filtered_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                ))\n+        else:\n+            # For non-index constraints, maintain existing behavior\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n                 model._meta.db_table,\n                 \", \".join(columns),\n             ))\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1157,8 +1260,19 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != primary_key:\n                     continue\n+\n                 if index is not None and infodict['index'] != index:\n-                    continue\n+                    # When filtering for index constraints, also consider if this is a unique constraint\n+                    # to avoid conflicts when both unique_together and index_together exist on same fields\n+                    if index and infodict['unique'] and not infodict.get('primary_key', False):\n+                        # This is a unique constraint that also acts as an index\n+                        # Skip it when specifically looking for non-unique index constraints\n+                        continue\n+                    elif not index and not infodict['index']:\n+                        # When looking for non-index constraints, skip if it's not an index\n+                        continue\n+                    else:\n+                        continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n                 if foreign_key is not None and not infodict['foreign_key']:\n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..30cd0fdec5 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,26 +393,137 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n-        # Created indexes\n+\n+def alter_index_together(self, model, old_index_together, new_index_together):\n+    \"\"\"\n+    Deal with a model changing its index_together. The input\n+    index_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_index_together}\n+    news = {tuple(fields) for fields in new_index_together}\n+    # Deleted indexes\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n+    # Created indexes\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    \n+    # If we're looking for index constraints and found multiple constraints,\n+    # filter out unique constraints to avoid conflicts with unique_together\n+    if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+        # Get all constraints for these columns\n+        all_constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names\n+        )\n+        # Filter to keep only non-unique index constraints\n+        filtered_names = []\n+        for name in constraint_names:\n+            # Check if this constraint is unique by looking at unique constraints\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n+            )\n+            if name not in unique_constraint_names:\n+                filtered_names.append(name)\n+        \n+        # Use filtered names if we found any, otherwise fall back to original\n+        if filtered_names:\n+            constraint_names = filtered_names\n+    \n+    if len(constraint_names) != 1:\n+        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+            len(constraint_names),\n+            model._meta.db_table,\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # First try to find constraints with the exact criteria\n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we're looking for index constraints and found multiple,\n+        # filter out unique constraints to avoid conflicts with unique_together\n+        if len(constraint_names) > 1 and constraint_kwargs.get('index'):\n+            # Get all constraints on these columns\n+            all_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names\n+            )\n+            # Filter to find non-unique index constraints only\n+            filtered_names = []\n+            for name in constraint_names:\n+                # Check if this constraint is unique by looking for it in unique constraints\n+                unique_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                if name not in unique_constraint_names:\n+                    filtered_names.append(name)\n+            \n+            # Use filtered list if we found non-unique constraints\n+            if filtered_names:\n+                constraint_names = filtered_names\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    if len(constraint_names) != 1:\n+        # If we're looking for an index constraint and found multiple constraints,\n+        # filter to find non-unique index constraints to avoid conflicts with unique_together\n+        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+            # Get constraint info to filter out unique constraints\n+            all_constraints = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names\n+            )\n+            # Filter for non-unique index constraints by checking constraint details\n+            filtered_names = []\n+            for name in constraint_names:\n+                constraint_info = None\n+                for info in self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table).values():\n+                    if info.get('index') and not info.get('unique', False):\n+                        # Check if this constraint matches our columns\n+                        if set(info['columns']) == set(columns):\n+                            filtered_names.append(name)\n+                            break\n+            if len(filtered_names) == 1:\n+                constraint_names = filtered_names\n+            elif len(filtered_names) == 0:\n+                # If no non-unique index found, fall back to original behavior\n+                pass\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n                 model._meta.db_table,\n                 \", \".join(columns),\n             ))\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1157,8 +1268,12 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != primary_key:\n                     continue\n+\n                 if index is not None and infodict['index'] != index:\n-                    continue\n+                    # Skip if index constraint type doesn't match, but allow unique constraints\n+                    # to also be considered as indexes when index=True is requested\n+                    if not (index is True and infodict['unique'] is True):\n+                        continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n                 if foreign_key is not None and not infodict['foreign_key']:\n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..13c5e4f3ae 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,12 +393,27 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n-        # Created indexes\n+\n+def alter_index_together(self, model, old_index_together, new_index_together):\n+    \"\"\"\n+    Deal with a model changing its index_together. The input\n+    index_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_index_together}\n+    news = {tuple(fields) for fields in new_index_together}\n+    # Deleted indexes\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n+    # Created indexes\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n@@ -407,12 +422,87 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we found multiple constraints and we're looking for an index,\n+        # filter out unique constraints to avoid conflicts with unique_together\n+        if len(constraint_names) > 1 and constraint_kwargs.get('index'):\n+            # Get constraint info to filter out unique constraints\n+            filtered_names = []\n+            for name in constraint_names:\n+                constraints = self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table)\n+                constraint_info = constraints.get(name, {})\n+                # Only include non-unique index constraints\n+                if constraint_info.get('index') and not constraint_info.get('unique'):\n+                    filtered_names.append(name)\n+            constraint_names = filtered_names\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n                 model._meta.db_table,\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # When deleting index_together constraints, exclude unique constraints\n+        # to avoid conflicts with unique_together on the same fields\n+        exclude_names = meta_constraint_names | meta_index_names\n+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n+            # For index deletion, also exclude unique constraints\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n+            )\n+            exclude_names = exclude_names | set(unique_constraint_names)\n+        \n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=exclude_names,\n+            **constraint_kwargs\n+        )\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) == 0:\n+            raise ValueError(\"Found no constraints for %s(%s)\" % (\n+                model._meta.db_table,\n                 \", \".join(columns),\n             ))\n+        elif len(constraint_names) > 1:\n+            # If we have multiple constraints on the same columns, filter by type\n+            if constraint_kwargs.get('index') is True:\n+                # When deleting an index, prefer non-unique indexes over unique ones\n+                filtered_names = []\n+                for name in constraint_names:\n+                    # Check if this constraint is unique by examining database metadata\n+                    constraint_info = self.connection.introspection.get_constraints(\n+                        self.connection.cursor(), model._meta.db_table\n+                    )\n+                    if name in constraint_info and not constraint_info[name].get('unique', False):\n+                        filtered_names.append(name)\n+                \n+                # If we found non-unique indexes, use those; otherwise fall back to all matches\n+                if filtered_names:\n+                    constraint_names = filtered_names\n+            \n+            # If we still have multiple matches, raise an error\n+            if len(constraint_names) != 1:\n+                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                ))\n+        \n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n@@ -1157,7 +1247,11 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != primary_key:\n                     continue\n+\n                 if index is not None and infodict['index'] != index:\n+                    # Skip unique constraints when looking for regular indexes\n+                    if index is True and infodict.get('unique', False):\n+                        continue\n                     continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..acfbe85d83 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,11 +393,26 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+\n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+        # Deleted indexes\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n+\n \n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n@@ -407,6 +422,65 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we found multiple constraints and we're specifically looking for an index,\n+        # filter out unique constraints to avoid conflicts with unique_together\n+        if len(constraint_names) > 1 and constraint_kwargs.get('index'):\n+            # Get constraint info to filter out unique constraints\n+            filtered_names = []\n+            for name in constraint_names:\n+                constraint_info = self.introspection.get_constraints(\n+                    self.connection.cursor(), model._meta.db_table\n+                ).get(name, {})\n+                # Only include non-unique index constraints when deleting index_together\n+                if constraint_info.get('index') and not constraint_info.get('unique'):\n+                    filtered_names.append(name)\n+            constraint_names = filtered_names\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                columns,\n+            ))\n+        self.execute(sql % {\n+            'table': self.quote_name(model._meta.db_table),\n+            'name': self.quote_name(constraint_names[0]),\n+        })\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Get all matching constraint names\n+        all_constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        \n+        # If we're looking for index constraints and found multiple, \n+        # filter out unique constraints to avoid conflicts with unique_together\n+        if constraint_kwargs.get('index') and len(all_constraint_names) > 1:\n+            # Filter out unique constraints when deleting index_together\n+            constraint_names = []\n+            for name in all_constraint_names:\n+                # Get constraint info to check if it's unique\n+                constraint_info = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                if name not in constraint_info:\n+                    constraint_names.append(name)\n+            \n+            # If we still have multiple non-unique constraints, fall back to original behavior\n+            if len(constraint_names) != 1:\n+                constraint_names = all_constraint_names\n+        else:\n+            constraint_names = all_constraint_names\n+            \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n@@ -415,6 +489,48 @@ class BaseDatabaseSchemaEditor:\n             ))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) != 1:\n+            # If we're looking for an index constraint and found multiple constraints,\n+            # try to filter out unique constraints to find the pure index constraint\n+            if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+                # Get all constraints on these columns\n+                all_constraints = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names\n+                )\n+                # Filter to find non-unique index constraints\n+                non_unique_constraints = []\n+                for constraint_name in all_constraints:\n+                    constraint_info = self._constraint_info(model, constraint_name)\n+                    if constraint_info and constraint_info.get('index') and not constraint_info.get('unique'):\n+                        non_unique_constraints.append(constraint_name)\n+                \n+                if len(non_unique_constraints) == 1:\n+                    constraint_names = non_unique_constraints\n+                else:\n+                    # If we still have multiple or no non-unique constraints,\n+                    # fall back to the original error\n+                    raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                        len(constraint_names),\n+                        model._meta.db_table,\n+                        \", \".join(columns),\n+                    ))\n+            else:\n+                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n         if (old_db_table == new_db_table or\n@@ -1157,8 +1273,17 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != primary_key:\n                     continue\n+\n                 if index is not None and infodict['index'] != index:\n-                    continue\n+                    # When filtering for index=True, exclude unique constraints to avoid conflicts\n+                    # with unique_together constraints that are also indexes\n+                    if index is True and infodict.get('unique', False):\n+                        continue\n+                    # When filtering for index=False, include unique constraints\n+                    if index is False and infodict.get('unique', False):\n+                        pass\n+                    elif infodict['index'] != index:\n+                        continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n                 if foreign_key is not None and not infodict['foreign_key']:\n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..12bfffd539 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,11 +393,59 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+\n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+        # Deleted indexes\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n+\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    \n+    # If we're looking for an index constraint and found multiple constraints,\n+    # filter to exclude unique constraints to avoid conflicts\n+    if len(constraint_names) > 1 and constraint_kwargs.get('index'):\n+        # Get all constraint info to filter by uniqueness\n+        all_constraints = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names\n+        )\n+        # Filter out unique constraints when looking for regular indexes\n+        non_unique_constraints = []\n+        for name in constraint_names:\n+            constraint_info = self._get_constraint_info(model, name)\n+            if not constraint_info.get('unique', False):\n+                non_unique_constraints.append(name)\n+        \n+        if non_unique_constraints:\n+            constraint_names = non_unique_constraints\n+    \n+    if len(constraint_names) != 1:\n+        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+            len(constraint_names),\n+            model._meta.db_table,\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n \n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n@@ -407,6 +455,22 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we're looking for index constraints and found multiple, filter out unique constraints\n+        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+            # Get all constraint info to filter by type\n+            all_constraints = self._get_constraint_names(model, columns, exclude=meta_constraint_names | meta_index_names)\n+            non_unique_constraints = []\n+            for name in constraint_names:\n+                constraint_info = all_constraints.get(name, {})\n+                # Only include non-unique index constraints\n+                if constraint_info.get('index') and not constraint_info.get('unique'):\n+                    non_unique_constraints.append(name)\n+            \n+            # Use non-unique constraints if we found any, otherwise keep original list\n+            if non_unique_constraints:\n+                constraint_names = non_unique_constraints\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n@@ -415,6 +479,48 @@ class BaseDatabaseSchemaEditor:\n             ))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) != 1:\n+            # If we're looking for an index constraint and found multiple constraints,\n+            # filter out unique constraints to avoid conflicts with unique_together\n+            if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+                # Get constraint info to filter out unique constraints\n+                all_constraints = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names\n+                )\n+                non_unique_constraints = []\n+                for constraint_name in constraint_names:\n+                    # Check if this is a non-unique index by examining constraint info\n+                    constraint_info = None\n+                    for info in self.connection.introspection.get_constraints(\n+                        self.connection.cursor(), model._meta.db_table\n+                    ).values():\n+                        if info.get('columns') == columns and not info.get('unique', False):\n+                            if constraint_name in str(info):\n+                                non_unique_constraints.append(constraint_name)\n+                                break\n+                \n+                # If we found non-unique constraints, use those\n+                if non_unique_constraints:\n+                    constraint_names = non_unique_constraints\n+            \n+            # If we still don't have exactly one constraint, raise the error\n+            if len(constraint_names) != 1:\n+                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n         if (old_db_table == new_db_table or\n@@ -1157,7 +1263,17 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != primary_key:\n                     continue\n+\n                 if index is not None and infodict['index'] != index:\n+                    # When filtering for non-index constraints (index=False), skip unique constraints\n+                    # that are also indexes to avoid conflicts with index_together operations\n+                    if not index and infodict['unique'] and infodict['index']:\n+                        continue\n+                    # When filtering for index constraints (index=True), prefer non-unique indexes\n+                    # over unique indexes when both exist on the same columns\n+                    if index and infodict['unique'] and unique is None:\n+                        continue\n+                    # Standard index filtering\n                     continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n"
  }
}