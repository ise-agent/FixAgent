{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 751-751)": "\n            opts = cur_model._meta.concrete_model._meta\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 758-763)": "\n                opts = cur_model._meta.concrete_model._meta\n",
    "Location 3 (/root/hy/projects_1/django/django/db/models/query.py lines 2599-2599)": "\ndef deferred_to_data(self, target, callback):\n    \"\"\"\n    Convert the self.deferred_loading data structure to mapping of table names\n    to sets of column names which are to be loaded. Then call the callback with\n    each table and its columns and store the return value in the self.deferred_to_data\n    structure. If the callback returns None, then the data will not be loaded.\n    \"\"\"\n    for table, columns in self.deferred_loading[0].items():\n        # Check if any of the columns are deferred\n        if columns:\n            # Find the model class for this table\n            for alias, model_cls in self.alias_map.items():\n                if alias == table or (hasattr(model_cls, '_meta') and model_cls._meta.db_table == table):\n                    cur_model = model_cls\n                    break\n            else:\n                # If we can't find the model, skip this table\n                continue\n            \n            # Use concrete model's metadata for proxy models\n            opts = cur_model._meta.concrete_model._meta\n            \n            # Convert field names to column names\n            only_load = set()\n            for field_name in columns:\n                try:\n                    field = opts.get_field(field_name)\n                    only_load.add(field.column)\n                except FieldDoesNotExist:\n                    # Field might be a related field or virtual field\n                    only_load.add(field_name)\n            \n            # Call the callback with the table and its columns\n            result = callback(table, only_load)\n            if result is not None:\n                if table not in target:\n                    target[table] = set()\n                target[table].update(result)\n",
    "Location 4 (/root/hy/projects_1/django/django/db/models/query.py lines 2588-2593)": "\n        # The current model in the chain.\n        cur_model = model\n        # Build the list of field names to defer.\n        for field_name in field_names:\n            parts = field_name.split(LOOKUP_SEP)\n            cur_model = model\n            opts = cur_model._meta.concrete_model._meta\n            for name in parts[:-1]:\n                if name in self._filtered_relations:\n                    name = self._filtered_relations[name].relation_name\n                mti_direct, field = opts.get_field(name)\n                if mti_direct:\n                    # XXX: need to assign to field.model._meta.concrete_model._meta?\n                    opts = field.remote_field.model._meta\n                    cur_model = field.remote_field.model\n                else:\n                    opts = field.model._meta\n                    cur_model = field.model\n            if len(parts) == 1:\n                if len([f for f in opts.concrete_fields if f.name == parts[0]]) == 0:\n                    raise FieldError(\"Cannot resolve keyword %r into field. \"\n                                     \"Join on '%s' not permitted.\" % (parts[0], cur_model._meta.object_name))\n            else:\n                field = opts.get_field(parts[-1])\n                if field.many_to_many:\n                    raise FieldError(\"Cannot call only() or defer() on %r, which is a \"\n                                     \"ManyToManyField.\" % name)\n\n            # Add the field to the deferred list.\n            existing, defer = self.deferred_loading\n            if defer:\n                # If we're deferring, add the field to the set of fields to defer.\n                if field_name not in existing:\n                    self.deferred_loading = existing.union([field_name]), True\n            else:\n                # If we're not deferring, remove the field from the set of fields\n                # to defer (i.e., add it to the set of fields to load immediately).\n                self.deferred_loading = existing.difference([field_name]), False\n",
    "Location 5 (/root/hy/projects_1/django/django/db/models/query.py lines 2585-2587)": "\n        # Walk the lookup to the concrete model\n        for part in parts[:-1]:\n            try:\n                field = opts.get_field(part)\n            except FieldDoesNotExist:\n                return None\n            if hasattr(field, 'remote_field'):\n                cur_model = field.remote_field.model\n                opts = cur_model._meta.concrete_model._meta\n            else:\n                cur_model = None\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 751-751)": [
      "\nopts = cur_model._meta.concrete_model._meta\n",
      "\n            opts = cur_model._meta.concrete_model._meta\n",
      "\n            opts = orig_opts\n            for name in parts[:-1]:\n                old_model = cur_model\n                if name in self._filtered_relations:\n                    name = self._filtered_relations[name].relation_name\n                source = opts.get_field(name)\n                if is_reverse_o2o(source):\n                    cur_model = source.related_model\n                else:\n                    cur_model = source.remote_field.model\n                opts = cur_model._meta.concrete_model._meta\n                # Even if we're \"just passing through\" this model, we must add\n                # both the current model's pk and the related reference field\n                # (if it's not a reverse relation) to the things we select.\n                if not is_reverse_o2o(source):\n                    must_include[old_model].add(source)\n                add_to_dict(must_include, cur_model, opts.pk)\n            field = opts.get_field(parts[-1])\n            is_reverse_object = field.auto_created and not field.concrete\n            model = field.related_model if is_reverse_object else field.model\n            model = model._meta.concrete_model\n",
      "\n            opts = cur_model._meta.concrete_model._meta\n",
      "\n            opts = orig_opts\n            for name in parts[:-1]:\n                old_model = cur_model\n                if name in self._filtered_relations:\n                    name = self._filtered_relations[name].relation_name\n                source = opts.get_field(name)\n                if is_reverse_o2o(source):\n                    cur_model = source.related_model\n                else:\n                    cur_model = source.remote_field.model\n                opts = cur_model._meta.concrete_model._meta\n                # Even if we're \"just passing through\" this model, we must add\n                # both the current model's pk and the related reference field\n                # (if it's not a reverse relation) to the things we select.\n                if not is_reverse_o2o(source):\n                    must_include[old_model].add(source)\n                add_to_dict(must_include, cur_model, opts.pk)\n",
      "\n            opts = cur_model._meta.concrete_model._meta\n",
      "\nopts = cur_model._meta.concrete_model._meta\n",
      "\n            opts = cur_model._meta.concrete_model._meta\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/sql/query.py lines 758-763)": [
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                    cur_model = source.related_model\n                else:\n                    cur_model = source.remote_field.model\n                opts = cur_model._meta.concrete_model._meta\n                # Even if we're \"just passing through\" this model, we must add\n                # both the current model's pk and the related reference field\n                # (if it's not a reverse relation) to the things we select.\n                if not is_reverse_o2o(source):\n                    must_include[old_model].add(source)\n                add_to_dict(must_include, cur_model, opts.pk)\n            field = opts.get_field(parts[-1])\n            is_reverse_object = field.auto_created and not field.concrete\n            model = field.related_model if is_reverse_object else field.model\n            model = model._meta.concrete_model\n            if model == opts.model:\n                model = cur_model\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                cur_model = source.related_model\n            else:\n                cur_model = source.remote_field.model\n            opts = cur_model._meta.concrete_model._meta\n            # Even if we're \"just passing through\" this model, we must add\n            # both the current model's pk and the related reference field\n            # (if it's not a reverse relation) to the things we select.\n            if not is_reverse_o2o(source):\n                must_include[old_model].add(source)\n            add_to_dict(must_include, cur_model, opts.pk)\n        field = opts.get_field(parts[-1])\n        is_reverse_object = field.auto_created and not field.concrete\n        model = field.related_model if is_reverse_object else field.model\n        model = model._meta.concrete_model\n        if model == opts.model:\n            model = cur_model\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/models/query.py lines 2599-2599)": [
      "\n            opts = cur_model._meta.concrete_model._meta\n",
      "\n        # Walk the reverse of the select_related chain, starting from the\n        # outermost model, to avoid creating duplicate joins.\n        for prefix, cur_model in reversed(related_klass_infos):\n            if prefix:\n                field_names = prefix.split(LOOKUP_SEP)\n            else:\n                field_names = []\n\n            # Build the list of fields that will be selected.\n            field_names.extend(only_load)\n\n            # Load all fields for the related model if none were specified.\n            if not field_names:\n                field_names = [\n                    f.attname for f in cur_model._meta.concrete_fields\n                    if f.column not in skip\n                ]\n\n            # Iterate over each field name to setup deferred loading.\n            for field_name in field_names:\n                try:\n                    parts = field_name.split(LOOKUP_SEP)\n                    opts = cur_model._meta.concrete_model._meta\n                    for part in parts[:-1]:\n                        rel = opts.get_field(part).remote_field\n                        if rel is None:\n                            continue\n                        opts = rel.model._meta\n\n                    field = opts.get_field(parts[-1])\n                    model = field.model\n                    model._meta.add_deferred_field(field)\n                except FieldDoesNotExist:\n                    continue\n",
      "\n            opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\ndef deferred_to_data(self, target, callback):\n    \"\"\"\n    Convert the self.deferred_loading data structure to mapping of table names\n    to sets of column names which are to be loaded. Then call the callback with\n    each table name and set of columns.\n    \"\"\"\n    table_names = set()\n    for field, model in self.deferred_loading[1].items():\n        opts = model._meta.concrete_model._meta\n        table_names.add(opts.db_table)\n    for table in table_names:\n        columns = set()\n        for field, model in self.deferred_loading[1].items():\n            opts = model._meta.concrete_model._meta\n            if opts.db_table == table:\n                columns.add(opts.get_field(field).column)\n        callback(target, (table, columns))\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/models/query.py lines 2588-2593)": [
      "\n            opts = cur_model._meta.concrete_model._meta\n",
      "\n        # Walk the lookup path to find the field.\n        opts = cur_model._meta.concrete_model._meta\n        for name in parts[:-1]:\n            old_model = cur_model\n            if name in only_load:\n                only_load = only_load[name]\n                if not isinstance(only_load, dict):\n                    # If we have a field like 'foo' in only_load and\n                    # we're looking for 'foo__bar' then foo isn't a\n                    # ForeignKey so we can't continue.\n                    break\n            else:\n                only_load = {}\n            source = opts.get_field(name)\n            if not source.is_relation:\n                # If we have a field like 'foo' in only_load and\n                # we're looking for 'foo__bar' then foo isn't a\n                # ForeignKey so we can't continue.\n                break\n            cur_model = source.remote_field.model\n            opts = cur_model._meta.concrete_model._meta\n        else:\n            # We didn't break out of the loop, so the remainder of the parts\n            # refer to a field on the final model. Recurse with that model\n            # set up.\n            field = opts.get_field(parts[-1])\n            if hasattr(field, \"get_col\"):\n                # It's a concrete field, so it's in the select already.\n                continue\n            if not field.is_relation:\n                # It's a reverse relation, so it's not in the select.\n                continue\n            model = field.remote_field.model._state.db == self.db\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n            opts = cur_model._meta.concrete_model._meta\n",
      "\n        for field, model in reversed(lookup_parts):\n            # For lookups spanning multiple tables, pick the last model and\n            # proxy to its _meta.\n            if model:\n                cur_model = model\n        opts = cur_model._meta.concrete_model._meta\n        # The \"concrete\" field must correspond to a field on the model.\n        # Proxy models inherit fields from their concrete model, so we must\n        # use the concrete model's _meta.\n        if field in opts.fields_map:\n            field_names = field_names.union(\n                chain.from_iterable(\n                    f.get_col(klass_info[\"table\"], f.column).output_field.get_deferred_group_columns()\n                    for f in opts.get_field(field).get_path_info()[-1].target_fields\n                )\n            )\n        else:\n            # Relations are reverse-FK relations, so we must use the\n            # model's _meta.\n            field_names = field_names.union(\n                chain.from_iterable(\n                    f.get_col(klass_info[\"table\"], f.column).output_field.get_deferred_group_columns()\n                    for f in opts.get_field(parts[-1]).get_path_info()[-1].target_fields\n                )\n            )\n",
      "\n            opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n        for field, model in zip(field_names, models):\n            if model is None:\n                break\n            # Proxy models have the same fields as their concrete model.\n            if model._meta.proxy:\n                model = model._meta.concrete_model\n            opts = model._meta.concrete_model._meta\n            # The \"through\" of an m2m field is not a model, it's a compiler-\n            # generated class. But we can treat it like a model for the purposes\n            # of this iteration.\n            try:\n                if field in opts.fields_map:\n                    if f is None:\n                        f = opts.fields_map[field]\n                    if not f.many_to_many and not f.one_to_many:\n                        cur_model = f.remote_field.model\n                else:\n                    cur_model = opts.get_field(field).remote_field.model\n            except FieldDoesNotExist:\n                cur_model = None\n\n        if f is None:\n            # The field doesn't exist on this model -- we are looking at\n            # something like ContentType.objects.defer('model_class'), where\n            # model_class isn't a field on ContentType.\n            raise FieldDoesNotExist(\n                \"%s has no field named '%s'\" % (model._meta.object_name, field_names[0])\n            )\n\n        model = f.model._meta.concrete_model\n        opts = model._meta\n\n        # The \"concrete\" field of the proxy model has the same \"attname\" as\n        # its underlying concrete model.\n        target_field = f.target if f.is_relation else f\n        if target_field in only_load and target_field.attname not in defers:\n            # A reverse foreign key or reverse one-to-one has been passed to\n            # only(). The behavior here is undefined and currently crashes.\n            # Reverse fkeys should be added to the related_query_name(), not\n            # to the only() call.\n            raise FieldError(\n                \"Cannot resolve keyword %r into field. \"\n                \"Choices are: %s\" % (parts[-1], \", \".join(sorted(opts.fields_map.keys())))\n            )\n\n        # We add the field to the defers set, regardless of whether it's\n        # already there or not. The field might be added multiple times if\n        # we have multiple calls to defer() and only().\n        if target_field.attname not in only_load:\n            defers.add(target_field.attname)\n        try:\n            opts.get_field(parts[-1])\n        except FieldDoesNotExist as err:\n            raise FieldError(\n                \"Cannot resolve keyword %r into field. \"\n                \"Choices are: %s\" % (parts[-1], \", \".join(sorted(opts.fields_map.keys())))\n            ) from err\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/models/query.py lines 2585-2587)": [
      "\n        for field, model in opts.get_path_info(parts[:-1]):\n            if field.is_relation:\n                cur_model = field.related_model\n                opts = cur_model._meta.concrete_model._meta\n            else:\n                cur_model = model\n        field = opts.get_field(parts[-1])\n",
      "\n                # Use concrete model metadata for proxy models to ensure field consistency\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n",
      "\n                opts = cur_model._meta.concrete_model._meta\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..6b27f9d78c 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2582,9 +2582,11 @@ class RelatedPopulator:\n             ]\n             self.reorder_for_init = None\n         else:\n+\n             attname_indexes = {\n                 select[idx][0].target.attname: idx for idx in select_fields\n             }\n+\n             model_init_attnames = (\n                 f.attname for f in klass_info[\"model\"]._meta.concrete_fields\n             )\n@@ -2596,6 +2598,7 @@ class RelatedPopulator:\n             )\n \n         self.model_cls = klass_info[\"model\"]\n+\n         self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n         self.related_populators = get_related_populators(klass_info, select, self.db)\n         self.local_setter = klass_info[\"local_setter\"]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..3bfd75bf52 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,13 +748,15 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+\n+                opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n                 if not is_reverse_o2o(source):\n                     must_include[old_model].add(source)\n                 add_to_dict(must_include, cur_model, opts.pk)\n+\n             field = opts.get_field(parts[-1])\n             is_reverse_object = field.auto_created and not field.concrete\n             model = field.related_model if is_reverse_object else field.model\n",
    "variant_0": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..4c494f6ab7 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2582,21 +2582,101 @@ class RelatedPopulator:\n             ]\n             self.reorder_for_init = None\n         else:\n-            attname_indexes = {\n-                select[idx][0].target.attname: idx for idx in select_fields\n-            }\n-            model_init_attnames = (\n-                f.attname for f in klass_info[\"model\"]._meta.concrete_fields\n-            )\n-            self.init_list = [\n-                attname for attname in model_init_attnames if attname in attname_indexes\n-            ]\n+\n+        # Walk the lookup to the concrete model\n+        for part in parts[:-1]:\n+            try:\n+                field = opts.get_field(part)\n+            except FieldDoesNotExist:\n+                return None\n+            if hasattr(field, 'remote_field'):\n+                cur_model = field.remote_field.model\n+                opts = cur_model._meta.concrete_model._meta\n+            else:\n+                cur_model = None\n+\n+        # The current model in the chain.\n+        cur_model = model\n+        # Build the list of field names to defer.\n+        for field_name in field_names:\n+            parts = field_name.split(LOOKUP_SEP)\n+            cur_model = model\n+            opts = cur_model._meta.concrete_model._meta\n+            for name in parts[:-1]:\n+                if name in self._filtered_relations:\n+                    name = self._filtered_relations[name].relation_name\n+                mti_direct, field = opts.get_field(name)\n+                if mti_direct:\n+                    # XXX: need to assign to field.model._meta.concrete_model._meta?\n+                    opts = field.remote_field.model._meta\n+                    cur_model = field.remote_field.model\n+                else:\n+                    opts = field.model._meta\n+                    cur_model = field.model\n+            if len(parts) == 1:\n+                if len([f for f in opts.concrete_fields if f.name == parts[0]]) == 0:\n+                    raise FieldError(\"Cannot resolve keyword %r into field. \"\n+                                     \"Join on '%s' not permitted.\" % (parts[0], cur_model._meta.object_name))\n+            else:\n+                field = opts.get_field(parts[-1])\n+                if field.many_to_many:\n+                    raise FieldError(\"Cannot call only() or defer() on %r, which is a \"\n+                                     \"ManyToManyField.\" % name)\n+\n+            # Add the field to the deferred list.\n+            existing, defer = self.deferred_loading\n+            if defer:\n+                # If we're deferring, add the field to the set of fields to defer.\n+                if field_name not in existing:\n+                    self.deferred_loading = existing.union([field_name]), True\n+            else:\n+                # If we're not deferring, remove the field from the set of fields\n+                # to defer (i.e., add it to the set of fields to load immediately).\n+                self.deferred_loading = existing.difference([field_name]), False\n             self.reorder_for_init = operator.itemgetter(\n                 *[attname_indexes[attname] for attname in self.init_list]\n             )\n \n         self.model_cls = klass_info[\"model\"]\n-        self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n+\n+def deferred_to_data(self, target, callback):\n+    \"\"\"\n+    Convert the self.deferred_loading data structure to mapping of table names\n+    to sets of column names which are to be loaded. Then call the callback with\n+    each table and its columns and store the return value in the self.deferred_to_data\n+    structure. If the callback returns None, then the data will not be loaded.\n+    \"\"\"\n+    for table, columns in self.deferred_loading[0].items():\n+        # Check if any of the columns are deferred\n+        if columns:\n+            # Find the model class for this table\n+            for alias, model_cls in self.alias_map.items():\n+                if alias == table or (hasattr(model_cls, '_meta') and model_cls._meta.db_table == table):\n+                    cur_model = model_cls\n+                    break\n+            else:\n+                # If we can't find the model, skip this table\n+                continue\n+            \n+            # Use concrete model's metadata for proxy models\n+            opts = cur_model._meta.concrete_model._meta\n+            \n+            # Convert field names to column names\n+            only_load = set()\n+            for field_name in columns:\n+                try:\n+                    field = opts.get_field(field_name)\n+                    only_load.add(field.column)\n+                except FieldDoesNotExist:\n+                    # Field might be a related field or virtual field\n+                    only_load.add(field_name)\n+            \n+            # Call the callback with the table and its columns\n+            result = callback(table, only_load)\n+            if result is not None:\n+                if table not in target:\n+                    target[table] = set()\n+                target[table].update(result)\n         self.related_populators = get_related_populators(klass_info, select, self.db)\n         self.local_setter = klass_info[\"local_setter\"]\n         self.remote_setter = klass_info[\"remote_setter\"]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..b089f39b5f 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,19 +748,16 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+\n+            opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n                 if not is_reverse_o2o(source):\n                     must_include[old_model].add(source)\n                 add_to_dict(must_include, cur_model, opts.pk)\n-            field = opts.get_field(parts[-1])\n-            is_reverse_object = field.auto_created and not field.concrete\n-            model = field.related_model if is_reverse_object else field.model\n-            model = model._meta.concrete_model\n-            if model == opts.model:\n-                model = cur_model\n+\n+                opts = cur_model._meta.concrete_model._meta\n             if not is_reverse_o2o(field):\n                 add_to_dict(seen, model, field)\n \n",
    "variant_1": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..7e235f756b 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2582,21 +2582,23 @@ class RelatedPopulator:\n             ]\n             self.reorder_for_init = None\n         else:\n-            attname_indexes = {\n-                select[idx][0].target.attname: idx for idx in select_fields\n-            }\n-            model_init_attnames = (\n-                f.attname for f in klass_info[\"model\"]._meta.concrete_fields\n-            )\n-            self.init_list = [\n-                attname for attname in model_init_attnames if attname in attname_indexes\n-            ]\n+\n+        for field, model in opts.get_path_info(parts[:-1]):\n+            if field.is_relation:\n+                cur_model = field.related_model\n+                opts = cur_model._meta.concrete_model._meta\n+            else:\n+                cur_model = model\n+        field = opts.get_field(parts[-1])\n+\n+            opts = cur_model._meta.concrete_model._meta\n             self.reorder_for_init = operator.itemgetter(\n                 *[attname_indexes[attname] for attname in self.init_list]\n             )\n \n         self.model_cls = klass_info[\"model\"]\n-        self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n+\n+            opts = cur_model._meta.concrete_model._meta\n         self.related_populators = get_related_populators(klass_info, select, self.db)\n         self.local_setter = klass_info[\"local_setter\"]\n         self.remote_setter = klass_info[\"remote_setter\"]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..e31685f57a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,19 +748,16 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+\n+opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n                 if not is_reverse_o2o(source):\n                     must_include[old_model].add(source)\n                 add_to_dict(must_include, cur_model, opts.pk)\n-            field = opts.get_field(parts[-1])\n-            is_reverse_object = field.auto_created and not field.concrete\n-            model = field.related_model if is_reverse_object else field.model\n-            model = model._meta.concrete_model\n-            if model == opts.model:\n-                model = cur_model\n+\n+                opts = cur_model._meta.concrete_model._meta\n             if not is_reverse_o2o(field):\n                 add_to_dict(seen, model, field)\n \n",
    "variant_2": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..3c0a42a589 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2582,21 +2582,83 @@ class RelatedPopulator:\n             ]\n             self.reorder_for_init = None\n         else:\n-            attname_indexes = {\n-                select[idx][0].target.attname: idx for idx in select_fields\n-            }\n-            model_init_attnames = (\n-                f.attname for f in klass_info[\"model\"]._meta.concrete_fields\n-            )\n-            self.init_list = [\n-                attname for attname in model_init_attnames if attname in attname_indexes\n-            ]\n+\n+                # Use concrete model metadata for proxy models to ensure field consistency\n+                opts = cur_model._meta.concrete_model._meta\n+\n+        # Walk the lookup path to find the field.\n+        opts = cur_model._meta.concrete_model._meta\n+        for name in parts[:-1]:\n+            old_model = cur_model\n+            if name in only_load:\n+                only_load = only_load[name]\n+                if not isinstance(only_load, dict):\n+                    # If we have a field like 'foo' in only_load and\n+                    # we're looking for 'foo__bar' then foo isn't a\n+                    # ForeignKey so we can't continue.\n+                    break\n+            else:\n+                only_load = {}\n+            source = opts.get_field(name)\n+            if not source.is_relation:\n+                # If we have a field like 'foo' in only_load and\n+                # we're looking for 'foo__bar' then foo isn't a\n+                # ForeignKey so we can't continue.\n+                break\n+            cur_model = source.remote_field.model\n+            opts = cur_model._meta.concrete_model._meta\n+        else:\n+            # We didn't break out of the loop, so the remainder of the parts\n+            # refer to a field on the final model. Recurse with that model\n+            # set up.\n+            field = opts.get_field(parts[-1])\n+            if hasattr(field, \"get_col\"):\n+                # It's a concrete field, so it's in the select already.\n+                continue\n+            if not field.is_relation:\n+                # It's a reverse relation, so it's not in the select.\n+                continue\n+            model = field.remote_field.model._state.db == self.db\n             self.reorder_for_init = operator.itemgetter(\n                 *[attname_indexes[attname] for attname in self.init_list]\n             )\n \n         self.model_cls = klass_info[\"model\"]\n-        self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n+\n+        # Walk the reverse of the select_related chain, starting from the\n+        # outermost model, to avoid creating duplicate joins.\n+        for prefix, cur_model in reversed(related_klass_infos):\n+            if prefix:\n+                field_names = prefix.split(LOOKUP_SEP)\n+            else:\n+                field_names = []\n+\n+            # Build the list of fields that will be selected.\n+            field_names.extend(only_load)\n+\n+            # Load all fields for the related model if none were specified.\n+            if not field_names:\n+                field_names = [\n+                    f.attname for f in cur_model._meta.concrete_fields\n+                    if f.column not in skip\n+                ]\n+\n+            # Iterate over each field name to setup deferred loading.\n+            for field_name in field_names:\n+                try:\n+                    parts = field_name.split(LOOKUP_SEP)\n+                    opts = cur_model._meta.concrete_model._meta\n+                    for part in parts[:-1]:\n+                        rel = opts.get_field(part).remote_field\n+                        if rel is None:\n+                            continue\n+                        opts = rel.model._meta\n+\n+                    field = opts.get_field(parts[-1])\n+                    model = field.model\n+                    model._meta.add_deferred_field(field)\n+                except FieldDoesNotExist:\n+                    continue\n         self.related_populators = get_related_populators(klass_info, select, self.db)\n         self.local_setter = klass_info[\"local_setter\"]\n         self.remote_setter = klass_info[\"remote_setter\"]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..b089f39b5f 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,19 +748,16 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+\n+            opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n                 if not is_reverse_o2o(source):\n                     must_include[old_model].add(source)\n                 add_to_dict(must_include, cur_model, opts.pk)\n-            field = opts.get_field(parts[-1])\n-            is_reverse_object = field.auto_created and not field.concrete\n-            model = field.related_model if is_reverse_object else field.model\n-            model = model._meta.concrete_model\n-            if model == opts.model:\n-                model = cur_model\n+\n+                opts = cur_model._meta.concrete_model._meta\n             if not is_reverse_o2o(field):\n                 add_to_dict(seen, model, field)\n \n",
    "variant_3": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..480bae26e5 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2582,21 +2582,17 @@ class RelatedPopulator:\n             ]\n             self.reorder_for_init = None\n         else:\n-            attname_indexes = {\n-                select[idx][0].target.attname: idx for idx in select_fields\n-            }\n-            model_init_attnames = (\n-                f.attname for f in klass_info[\"model\"]._meta.concrete_fields\n-            )\n-            self.init_list = [\n-                attname for attname in model_init_attnames if attname in attname_indexes\n-            ]\n+\n+                opts = cur_model._meta.concrete_model._meta\n+\n+                opts = cur_model._meta.concrete_model._meta\n             self.reorder_for_init = operator.itemgetter(\n                 *[attname_indexes[attname] for attname in self.init_list]\n             )\n \n         self.model_cls = klass_info[\"model\"]\n-        self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n+\n+            opts = cur_model._meta.concrete_model._meta\n         self.related_populators = get_related_populators(klass_info, select, self.db)\n         self.local_setter = klass_info[\"local_setter\"]\n         self.remote_setter = klass_info[\"remote_setter\"]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..f1fe780703 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,7 +748,18 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+\n+            opts = orig_opts\n+            for name in parts[:-1]:\n+                old_model = cur_model\n+                if name in self._filtered_relations:\n+                    name = self._filtered_relations[name].relation_name\n+                source = opts.get_field(name)\n+                if is_reverse_o2o(source):\n+                    cur_model = source.related_model\n+                else:\n+                    cur_model = source.remote_field.model\n+                opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n@@ -759,8 +770,14 @@ class Query(BaseExpression):\n             is_reverse_object = field.auto_created and not field.concrete\n             model = field.related_model if is_reverse_object else field.model\n             model = model._meta.concrete_model\n-            if model == opts.model:\n-                model = cur_model\n+                # Even if we're \"just passing through\" this model, we must add\n+                # both the current model's pk and the related reference field\n+                # (if it's not a reverse relation) to the things we select.\n+                if not is_reverse_o2o(source):\n+                    must_include[old_model].add(source)\n+                add_to_dict(must_include, cur_model, opts.pk)\n+\n+                opts = cur_model._meta.concrete_model._meta\n             if not is_reverse_o2o(field):\n                 add_to_dict(seen, model, field)\n \n",
    "variant_4": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..3dafdd10ef 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2582,21 +2582,17 @@ class RelatedPopulator:\n             ]\n             self.reorder_for_init = None\n         else:\n-            attname_indexes = {\n-                select[idx][0].target.attname: idx for idx in select_fields\n-            }\n-            model_init_attnames = (\n-                f.attname for f in klass_info[\"model\"]._meta.concrete_fields\n-            )\n-            self.init_list = [\n-                attname for attname in model_init_attnames if attname in attname_indexes\n-            ]\n+\n+                opts = cur_model._meta.concrete_model._meta\n+\n+            opts = cur_model._meta.concrete_model._meta\n             self.reorder_for_init = operator.itemgetter(\n                 *[attname_indexes[attname] for attname in self.init_list]\n             )\n \n         self.model_cls = klass_info[\"model\"]\n-        self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n+\n+                opts = cur_model._meta.concrete_model._meta\n         self.related_populators = get_related_populators(klass_info, select, self.db)\n         self.local_setter = klass_info[\"local_setter\"]\n         self.remote_setter = klass_info[\"remote_setter\"]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..b089f39b5f 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,19 +748,16 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+\n+            opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n                 if not is_reverse_o2o(source):\n                     must_include[old_model].add(source)\n                 add_to_dict(must_include, cur_model, opts.pk)\n-            field = opts.get_field(parts[-1])\n-            is_reverse_object = field.auto_created and not field.concrete\n-            model = field.related_model if is_reverse_object else field.model\n-            model = model._meta.concrete_model\n-            if model == opts.model:\n-                model = cur_model\n+\n+                opts = cur_model._meta.concrete_model._meta\n             if not is_reverse_o2o(field):\n                 add_to_dict(seen, model, field)\n \n",
    "variant_5": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..96e371bbd8 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2582,21 +2582,41 @@ class RelatedPopulator:\n             ]\n             self.reorder_for_init = None\n         else:\n-            attname_indexes = {\n-                select[idx][0].target.attname: idx for idx in select_fields\n-            }\n-            model_init_attnames = (\n-                f.attname for f in klass_info[\"model\"]._meta.concrete_fields\n+\n+                opts = cur_model._meta.concrete_model._meta\n+\n+        for field, model in reversed(lookup_parts):\n+            # For lookups spanning multiple tables, pick the last model and\n+            # proxy to its _meta.\n+            if model:\n+                cur_model = model\n+        opts = cur_model._meta.concrete_model._meta\n+        # The \"concrete\" field must correspond to a field on the model.\n+        # Proxy models inherit fields from their concrete model, so we must\n+        # use the concrete model's _meta.\n+        if field in opts.fields_map:\n+            field_names = field_names.union(\n+                chain.from_iterable(\n+                    f.get_col(klass_info[\"table\"], f.column).output_field.get_deferred_group_columns()\n+                    for f in opts.get_field(field).get_path_info()[-1].target_fields\n+                )\n+            )\n+        else:\n+            # Relations are reverse-FK relations, so we must use the\n+            # model's _meta.\n+            field_names = field_names.union(\n+                chain.from_iterable(\n+                    f.get_col(klass_info[\"table\"], f.column).output_field.get_deferred_group_columns()\n+                    for f in opts.get_field(parts[-1]).get_path_info()[-1].target_fields\n+                )\n             )\n-            self.init_list = [\n-                attname for attname in model_init_attnames if attname in attname_indexes\n-            ]\n             self.reorder_for_init = operator.itemgetter(\n                 *[attname_indexes[attname] for attname in self.init_list]\n             )\n \n         self.model_cls = klass_info[\"model\"]\n-        self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n+\n+                opts = cur_model._meta.concrete_model._meta\n         self.related_populators = get_related_populators(klass_info, select, self.db)\n         self.local_setter = klass_info[\"local_setter\"]\n         self.remote_setter = klass_info[\"remote_setter\"]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..3e9135acf2 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,19 +748,32 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+\n+            opts = orig_opts\n+            for name in parts[:-1]:\n+                old_model = cur_model\n+                if name in self._filtered_relations:\n+                    name = self._filtered_relations[name].relation_name\n+                source = opts.get_field(name)\n+                if is_reverse_o2o(source):\n+                    cur_model = source.related_model\n+                else:\n+                    cur_model = source.remote_field.model\n+                opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n                 if not is_reverse_o2o(source):\n                     must_include[old_model].add(source)\n                 add_to_dict(must_include, cur_model, opts.pk)\n-            field = opts.get_field(parts[-1])\n-            is_reverse_object = field.auto_created and not field.concrete\n-            model = field.related_model if is_reverse_object else field.model\n-            model = model._meta.concrete_model\n-            if model == opts.model:\n-                model = cur_model\n+                # Even if we're \"just passing through\" this model, we must add\n+                # both the current model's pk and the related reference field\n+                # (if it's not a reverse relation) to the things we select.\n+                if not is_reverse_o2o(source):\n+                    must_include[old_model].add(source)\n+                add_to_dict(must_include, cur_model, opts.pk)\n+\n+                opts = cur_model._meta.concrete_model._meta\n             if not is_reverse_o2o(field):\n                 add_to_dict(seen, model, field)\n \n",
    "variant_6": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..ed5d3f109b 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2582,21 +2582,33 @@ class RelatedPopulator:\n             ]\n             self.reorder_for_init = None\n         else:\n-            attname_indexes = {\n-                select[idx][0].target.attname: idx for idx in select_fields\n-            }\n-            model_init_attnames = (\n-                f.attname for f in klass_info[\"model\"]._meta.concrete_fields\n-            )\n-            self.init_list = [\n-                attname for attname in model_init_attnames if attname in attname_indexes\n-            ]\n+\n+                opts = cur_model._meta.concrete_model._meta\n+\n+            opts = cur_model._meta.concrete_model._meta\n             self.reorder_for_init = operator.itemgetter(\n                 *[attname_indexes[attname] for attname in self.init_list]\n             )\n \n         self.model_cls = klass_info[\"model\"]\n-        self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n+\n+def deferred_to_data(self, target, callback):\n+    \"\"\"\n+    Convert the self.deferred_loading data structure to mapping of table names\n+    to sets of column names which are to be loaded. Then call the callback with\n+    each table name and set of columns.\n+    \"\"\"\n+    table_names = set()\n+    for field, model in self.deferred_loading[1].items():\n+        opts = model._meta.concrete_model._meta\n+        table_names.add(opts.db_table)\n+    for table in table_names:\n+        columns = set()\n+        for field, model in self.deferred_loading[1].items():\n+            opts = model._meta.concrete_model._meta\n+            if opts.db_table == table:\n+                columns.add(opts.get_field(field).column)\n+        callback(target, (table, columns))\n         self.related_populators = get_related_populators(klass_info, select, self.db)\n         self.local_setter = klass_info[\"local_setter\"]\n         self.remote_setter = klass_info[\"remote_setter\"]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..128d31f8cf 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,7 +748,19 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+\n+            opts = cur_model._meta.concrete_model._meta\n+                # Even if we're \"just passing through\" this model, we must add\n+                # both the current model's pk and the related reference field\n+                # (if it's not a reverse relation) to the things we select.\n+                if not is_reverse_o2o(source):\n+                    must_include[old_model].add(source)\n+                add_to_dict(must_include, cur_model, opts.pk)\n+\n+                    cur_model = source.related_model\n+                else:\n+                    cur_model = source.remote_field.model\n+                opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n",
    "variant_7": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..86151193da 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2582,21 +2582,17 @@ class RelatedPopulator:\n             ]\n             self.reorder_for_init = None\n         else:\n-            attname_indexes = {\n-                select[idx][0].target.attname: idx for idx in select_fields\n-            }\n-            model_init_attnames = (\n-                f.attname for f in klass_info[\"model\"]._meta.concrete_fields\n-            )\n-            self.init_list = [\n-                attname for attname in model_init_attnames if attname in attname_indexes\n-            ]\n+\n+                opts = cur_model._meta.concrete_model._meta\n+\n+                opts = cur_model._meta.concrete_model._meta\n             self.reorder_for_init = operator.itemgetter(\n                 *[attname_indexes[attname] for attname in self.init_list]\n             )\n \n         self.model_cls = klass_info[\"model\"]\n-        self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n+\n+                opts = cur_model._meta.concrete_model._meta\n         self.related_populators = get_related_populators(klass_info, select, self.db)\n         self.local_setter = klass_info[\"local_setter\"]\n         self.remote_setter = klass_info[\"remote_setter\"]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..e31685f57a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,19 +748,16 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+\n+opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n                 if not is_reverse_o2o(source):\n                     must_include[old_model].add(source)\n                 add_to_dict(must_include, cur_model, opts.pk)\n-            field = opts.get_field(parts[-1])\n-            is_reverse_object = field.auto_created and not field.concrete\n-            model = field.related_model if is_reverse_object else field.model\n-            model = model._meta.concrete_model\n-            if model == opts.model:\n-                model = cur_model\n+\n+                opts = cur_model._meta.concrete_model._meta\n             if not is_reverse_o2o(field):\n                 add_to_dict(seen, model, field)\n \n",
    "variant_8": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..cca059d1a3 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2582,21 +2582,73 @@ class RelatedPopulator:\n             ]\n             self.reorder_for_init = None\n         else:\n-            attname_indexes = {\n-                select[idx][0].target.attname: idx for idx in select_fields\n-            }\n-            model_init_attnames = (\n-                f.attname for f in klass_info[\"model\"]._meta.concrete_fields\n+\n+                opts = cur_model._meta.concrete_model._meta\n+\n+        for field, model in zip(field_names, models):\n+            if model is None:\n+                break\n+            # Proxy models have the same fields as their concrete model.\n+            if model._meta.proxy:\n+                model = model._meta.concrete_model\n+            opts = model._meta.concrete_model._meta\n+            # The \"through\" of an m2m field is not a model, it's a compiler-\n+            # generated class. But we can treat it like a model for the purposes\n+            # of this iteration.\n+            try:\n+                if field in opts.fields_map:\n+                    if f is None:\n+                        f = opts.fields_map[field]\n+                    if not f.many_to_many and not f.one_to_many:\n+                        cur_model = f.remote_field.model\n+                else:\n+                    cur_model = opts.get_field(field).remote_field.model\n+            except FieldDoesNotExist:\n+                cur_model = None\n+\n+        if f is None:\n+            # The field doesn't exist on this model -- we are looking at\n+            # something like ContentType.objects.defer('model_class'), where\n+            # model_class isn't a field on ContentType.\n+            raise FieldDoesNotExist(\n+                \"%s has no field named '%s'\" % (model._meta.object_name, field_names[0])\n             )\n-            self.init_list = [\n-                attname for attname in model_init_attnames if attname in attname_indexes\n-            ]\n+\n+        model = f.model._meta.concrete_model\n+        opts = model._meta\n+\n+        # The \"concrete\" field of the proxy model has the same \"attname\" as\n+        # its underlying concrete model.\n+        target_field = f.target if f.is_relation else f\n+        if target_field in only_load and target_field.attname not in defers:\n+            # A reverse foreign key or reverse one-to-one has been passed to\n+            # only(). The behavior here is undefined and currently crashes.\n+            # Reverse fkeys should be added to the related_query_name(), not\n+            # to the only() call.\n+            raise FieldError(\n+                \"Cannot resolve keyword %r into field. \"\n+                \"Choices are: %s\" % (parts[-1], \", \".join(sorted(opts.fields_map.keys())))\n+            )\n+\n+        # We add the field to the defers set, regardless of whether it's\n+        # already there or not. The field might be added multiple times if\n+        # we have multiple calls to defer() and only().\n+        if target_field.attname not in only_load:\n+            defers.add(target_field.attname)\n+        try:\n+            opts.get_field(parts[-1])\n+        except FieldDoesNotExist as err:\n+            raise FieldError(\n+                \"Cannot resolve keyword %r into field. \"\n+                \"Choices are: %s\" % (parts[-1], \", \".join(sorted(opts.fields_map.keys())))\n+            ) from err\n             self.reorder_for_init = operator.itemgetter(\n                 *[attname_indexes[attname] for attname in self.init_list]\n             )\n \n         self.model_cls = klass_info[\"model\"]\n-        self.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\n+\n+                opts = cur_model._meta.concrete_model._meta\n         self.related_populators = get_related_populators(klass_info, select, self.db)\n         self.local_setter = klass_info[\"local_setter\"]\n         self.remote_setter = klass_info[\"remote_setter\"]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..f39e1dd1f9 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,19 +748,31 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+\n+            opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\n                 if not is_reverse_o2o(source):\n                     must_include[old_model].add(source)\n                 add_to_dict(must_include, cur_model, opts.pk)\n-            field = opts.get_field(parts[-1])\n-            is_reverse_object = field.auto_created and not field.concrete\n-            model = field.related_model if is_reverse_object else field.model\n-            model = model._meta.concrete_model\n-            if model == opts.model:\n-                model = cur_model\n+\n+                cur_model = source.related_model\n+            else:\n+                cur_model = source.remote_field.model\n+            opts = cur_model._meta.concrete_model._meta\n+            # Even if we're \"just passing through\" this model, we must add\n+            # both the current model's pk and the related reference field\n+            # (if it's not a reverse relation) to the things we select.\n+            if not is_reverse_o2o(source):\n+                must_include[old_model].add(source)\n+            add_to_dict(must_include, cur_model, opts.pk)\n+        field = opts.get_field(parts[-1])\n+        is_reverse_object = field.auto_created and not field.concrete\n+        model = field.related_model if is_reverse_object else field.model\n+        model = model._meta.concrete_model\n+        if model == opts.model:\n+            model = cur_model\n             if not is_reverse_o2o(field):\n                 add_to_dict(seen, model, field)\n \n"
  }
}