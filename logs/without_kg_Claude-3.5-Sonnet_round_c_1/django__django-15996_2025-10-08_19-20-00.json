{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/migrations/serializer.py lines 125-131)": "\ndef serialize(self):\n    enum_class = self.value.__class__\n    module = enum_class.__module__\n    \n    # Try to get the name for single enum values (backward compatibility)\n    if hasattr(self.value, 'name') and self.value.name is not None:\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n    else:\n        # Handle combined flags using enum._decompose\n        try:\n            # Use _decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_names = [flag.name for flag in decomposed[1]]\n                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return (flag_expression, {\"import %s\" % module})\n        except (AttributeError, ValueError):\n            pass\n        \n        # Fallback to original behavior if decomposition fails\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n            {\"import %s\" % module},\n        )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/migrations/serializer.py lines 125-131)": [
      "\ndef serialize(self):\n    enum_class = self.value.__class__\n    module = enum_class.__module__\n    \n    # Try to get the name for single enum values (backward compatibility)\n    if hasattr(self.value, 'name') and self.value.name is not None:\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n    else:\n        # Handle combined flags using enum._decompose\n        try:\n            # Use _decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_names = [flag.name for flag in decomposed[1]]\n                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return (flag_expression, {\"import %s\" % module})\n        except (AttributeError, ValueError):\n            pass\n        \n        # Fallback to original behavior if decomposition fails\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n            {\"import %s\" % module},\n        )\n",
      "\ndef serialize(self):\n    enum_class = self.value.__class__\n    module = enum_class.__module__\n    \n    # Try to get the name for single enum values (backward compatibility)\n    if hasattr(self.value, 'name') and self.value.name is not None:\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n    else:\n        # Handle combined flags using enum._decompose\n        try:\n            # Use _decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_names = [flag.name for flag in decomposed[1]]\n                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return (flag_expression, {\"import %s\" % module})\n        except (AttributeError, ValueError):\n            pass\n        \n        # Fallback to original behavior if decomposition fails\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n            {\"import %s\" % module},\n        )\n",
      "\ndef serialize(self):\n    enum_class = self.value.__class__\n    module = enum_class.__module__\n    \n    # Try to get the name for single enum values (backward compatibility)\n    if hasattr(self.value, 'name') and self.value.name is not None:\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n    else:\n        # Handle combined flags using enum._decompose\n        try:\n            # Use _decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_names = [flag.name for flag in decomposed[1]]\n                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return (flag_expression, {\"import %s\" % module})\n        except (AttributeError, ValueError):\n            pass\n        \n        # Fallback to original behavior if decomposition fails\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n            {\"import %s\" % module},\n        )\n",
      "\ndef serialize(self):\n    enum_class = self.value.__class__\n    module = enum_class.__module__\n    \n    # Try to get the name for single enum values (backward compatibility)\n    if hasattr(self.value, 'name') and self.value.name is not None:\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n    else:\n        # Handle combined flags using enum._decompose\n        try:\n            # Use _decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_names = [flag.name for flag in decomposed[1]]\n                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return (flag_expression, {\"import %s\" % module})\n        except (AttributeError, ValueError):\n            pass\n        \n        # Fallback to original behavior if decomposition fails\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n            {\"import %s\" % module},\n        )\n",
      "\ndef serialize(self):\n    enum_class = self.value.__class__\n    module = enum_class.__module__\n    \n    # Try to get the name for single enum values (backward compatibility)\n    if hasattr(self.value, 'name') and self.value.name is not None:\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n    else:\n        # Handle combined flags using enum._decompose\n        try:\n            # Use _decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_names = [flag.name for flag in decomposed[1]]\n                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return (flag_expression, {\"import %s\" % module})\n        except (AttributeError, ValueError):\n            pass\n        \n        # Fallback to original behavior if decomposition fails\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n            {\"import %s\" % module},\n        )\n",
      "\ndef serialize(self):\n    enum_class = self.value.__class__\n    module = enum_class.__module__\n    \n    # Try to get the name for single enum values (backward compatibility)\n    if hasattr(self.value, 'name') and self.value.name is not None:\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n    else:\n        # Handle combined flags using enum._decompose\n        try:\n            # Use _decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_names = [flag.name for flag in decomposed[1]]\n                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return (flag_expression, {\"import %s\" % module})\n        except (AttributeError, ValueError):\n            pass\n        \n        # Fallback to original behavior if decomposition fails\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n            {\"import %s\" % module},\n        )\n",
      "\ndef serialize(self):\n    enum_class = self.value.__class__\n    module = enum_class.__module__\n    \n    # Try to get the name for single enum values (backward compatibility)\n    if hasattr(self.value, 'name') and self.value.name is not None:\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n    else:\n        # Handle combined flags using enum._decompose\n        try:\n            # Use _decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_names = [flag.name for flag in decomposed[1]]\n                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return (flag_expression, {\"import %s\" % module})\n        except (AttributeError, ValueError):\n            pass\n        \n        # Fallback to original behavior if decomposition fails\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n            {\"import %s\" % module},\n        )\n",
      "\ndef serialize(self):\n    enum_class = self.value.__class__\n    module = enum_class.__module__\n    \n    # Try to get the name for single enum values (backward compatibility)\n    if hasattr(self.value, 'name') and self.value.name is not None:\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n    else:\n        # Handle combined flags using enum._decompose\n        try:\n            # Use _decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_names = [flag.name for flag in decomposed[1]]\n                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return (flag_expression, {\"import %s\" % module})\n        except (AttributeError, ValueError):\n            pass\n        \n        # Fallback to original behavior if decomposition fails\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n            {\"import %s\" % module},\n        )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..919ed396d1 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -122,13 +122,34 @@ class DictionarySerializer(BaseSerializer):\n \n \n class EnumSerializer(BaseSerializer):\n+\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        return (\n-            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n-            {\"import %s\" % module},\n-        )\n+        \n+        # Try to get the name for single enum values (backward compatibility)\n+        if hasattr(self.value, 'name') and self.value.name is not None:\n+            return (\n+                \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n+                {\"import %s\" % module},\n+            )\n+        else:\n+            # Handle combined flags using enum._decompose\n+            try:\n+                # Use _decompose to get individual flag components\n+                decomposed = enum._decompose(enum_class, self.value)\n+                if decomposed[1]:  # If there are individual flags\n+                    flag_names = [flag.name for flag in decomposed[1]]\n+                    flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                    return (flag_expression, {\"import %s\" % module})\n+            except (AttributeError, ValueError):\n+                pass\n+            \n+            # Fallback to original behavior if decomposition fails\n+            return (\n+                \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n+                {\"import %s\" % module},\n+            )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_0": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..8ae52435b8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -122,13 +122,34 @@ class DictionarySerializer(BaseSerializer):\n \n \n class EnumSerializer(BaseSerializer):\n-    def serialize(self):\n-        enum_class = self.value.__class__\n-        module = enum_class.__module__\n+\n+def serialize(self):\n+    enum_class = self.value.__class__\n+    module = enum_class.__module__\n+    \n+    # Try to get the name for single enum values (backward compatibility)\n+    if hasattr(self.value, 'name') and self.value.name is not None:\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n         )\n+    else:\n+        # Handle combined flags using enum._decompose\n+        try:\n+            # Use _decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_names = [flag.name for flag in decomposed[1]]\n+                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return (flag_expression, {\"import %s\" % module})\n+        except (AttributeError, ValueError):\n+            pass\n+        \n+        # Fallback to original behavior if decomposition fails\n+        return (\n+            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n+            {\"import %s\" % module},\n+        )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_1": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..8ae52435b8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -122,13 +122,34 @@ class DictionarySerializer(BaseSerializer):\n \n \n class EnumSerializer(BaseSerializer):\n-    def serialize(self):\n-        enum_class = self.value.__class__\n-        module = enum_class.__module__\n+\n+def serialize(self):\n+    enum_class = self.value.__class__\n+    module = enum_class.__module__\n+    \n+    # Try to get the name for single enum values (backward compatibility)\n+    if hasattr(self.value, 'name') and self.value.name is not None:\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n         )\n+    else:\n+        # Handle combined flags using enum._decompose\n+        try:\n+            # Use _decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_names = [flag.name for flag in decomposed[1]]\n+                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return (flag_expression, {\"import %s\" % module})\n+        except (AttributeError, ValueError):\n+            pass\n+        \n+        # Fallback to original behavior if decomposition fails\n+        return (\n+            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n+            {\"import %s\" % module},\n+        )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_2": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..8ae52435b8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -122,13 +122,34 @@ class DictionarySerializer(BaseSerializer):\n \n \n class EnumSerializer(BaseSerializer):\n-    def serialize(self):\n-        enum_class = self.value.__class__\n-        module = enum_class.__module__\n+\n+def serialize(self):\n+    enum_class = self.value.__class__\n+    module = enum_class.__module__\n+    \n+    # Try to get the name for single enum values (backward compatibility)\n+    if hasattr(self.value, 'name') and self.value.name is not None:\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n         )\n+    else:\n+        # Handle combined flags using enum._decompose\n+        try:\n+            # Use _decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_names = [flag.name for flag in decomposed[1]]\n+                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return (flag_expression, {\"import %s\" % module})\n+        except (AttributeError, ValueError):\n+            pass\n+        \n+        # Fallback to original behavior if decomposition fails\n+        return (\n+            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n+            {\"import %s\" % module},\n+        )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_3": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..8ae52435b8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -122,13 +122,34 @@ class DictionarySerializer(BaseSerializer):\n \n \n class EnumSerializer(BaseSerializer):\n-    def serialize(self):\n-        enum_class = self.value.__class__\n-        module = enum_class.__module__\n+\n+def serialize(self):\n+    enum_class = self.value.__class__\n+    module = enum_class.__module__\n+    \n+    # Try to get the name for single enum values (backward compatibility)\n+    if hasattr(self.value, 'name') and self.value.name is not None:\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n         )\n+    else:\n+        # Handle combined flags using enum._decompose\n+        try:\n+            # Use _decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_names = [flag.name for flag in decomposed[1]]\n+                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return (flag_expression, {\"import %s\" % module})\n+        except (AttributeError, ValueError):\n+            pass\n+        \n+        # Fallback to original behavior if decomposition fails\n+        return (\n+            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n+            {\"import %s\" % module},\n+        )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_4": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..8ae52435b8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -122,13 +122,34 @@ class DictionarySerializer(BaseSerializer):\n \n \n class EnumSerializer(BaseSerializer):\n-    def serialize(self):\n-        enum_class = self.value.__class__\n-        module = enum_class.__module__\n+\n+def serialize(self):\n+    enum_class = self.value.__class__\n+    module = enum_class.__module__\n+    \n+    # Try to get the name for single enum values (backward compatibility)\n+    if hasattr(self.value, 'name') and self.value.name is not None:\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n         )\n+    else:\n+        # Handle combined flags using enum._decompose\n+        try:\n+            # Use _decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_names = [flag.name for flag in decomposed[1]]\n+                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return (flag_expression, {\"import %s\" % module})\n+        except (AttributeError, ValueError):\n+            pass\n+        \n+        # Fallback to original behavior if decomposition fails\n+        return (\n+            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n+            {\"import %s\" % module},\n+        )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_5": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..8ae52435b8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -122,13 +122,34 @@ class DictionarySerializer(BaseSerializer):\n \n \n class EnumSerializer(BaseSerializer):\n-    def serialize(self):\n-        enum_class = self.value.__class__\n-        module = enum_class.__module__\n+\n+def serialize(self):\n+    enum_class = self.value.__class__\n+    module = enum_class.__module__\n+    \n+    # Try to get the name for single enum values (backward compatibility)\n+    if hasattr(self.value, 'name') and self.value.name is not None:\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n         )\n+    else:\n+        # Handle combined flags using enum._decompose\n+        try:\n+            # Use _decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_names = [flag.name for flag in decomposed[1]]\n+                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return (flag_expression, {\"import %s\" % module})\n+        except (AttributeError, ValueError):\n+            pass\n+        \n+        # Fallback to original behavior if decomposition fails\n+        return (\n+            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n+            {\"import %s\" % module},\n+        )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_6": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..8ae52435b8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -122,13 +122,34 @@ class DictionarySerializer(BaseSerializer):\n \n \n class EnumSerializer(BaseSerializer):\n-    def serialize(self):\n-        enum_class = self.value.__class__\n-        module = enum_class.__module__\n+\n+def serialize(self):\n+    enum_class = self.value.__class__\n+    module = enum_class.__module__\n+    \n+    # Try to get the name for single enum values (backward compatibility)\n+    if hasattr(self.value, 'name') and self.value.name is not None:\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n         )\n+    else:\n+        # Handle combined flags using enum._decompose\n+        try:\n+            # Use _decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_names = [flag.name for flag in decomposed[1]]\n+                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return (flag_expression, {\"import %s\" % module})\n+        except (AttributeError, ValueError):\n+            pass\n+        \n+        # Fallback to original behavior if decomposition fails\n+        return (\n+            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n+            {\"import %s\" % module},\n+        )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_7": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..8ae52435b8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -122,13 +122,34 @@ class DictionarySerializer(BaseSerializer):\n \n \n class EnumSerializer(BaseSerializer):\n-    def serialize(self):\n-        enum_class = self.value.__class__\n-        module = enum_class.__module__\n+\n+def serialize(self):\n+    enum_class = self.value.__class__\n+    module = enum_class.__module__\n+    \n+    # Try to get the name for single enum values (backward compatibility)\n+    if hasattr(self.value, 'name') and self.value.name is not None:\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n         )\n+    else:\n+        # Handle combined flags using enum._decompose\n+        try:\n+            # Use _decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_names = [flag.name for flag in decomposed[1]]\n+                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return (flag_expression, {\"import %s\" % module})\n+        except (AttributeError, ValueError):\n+            pass\n+        \n+        # Fallback to original behavior if decomposition fails\n+        return (\n+            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n+            {\"import %s\" % module},\n+        )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_8": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..8ae52435b8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -122,13 +122,34 @@ class DictionarySerializer(BaseSerializer):\n \n \n class EnumSerializer(BaseSerializer):\n-    def serialize(self):\n-        enum_class = self.value.__class__\n-        module = enum_class.__module__\n+\n+def serialize(self):\n+    enum_class = self.value.__class__\n+    module = enum_class.__module__\n+    \n+    # Try to get the name for single enum values (backward compatibility)\n+    if hasattr(self.value, 'name') and self.value.name is not None:\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n         )\n+    else:\n+        # Handle combined flags using enum._decompose\n+        try:\n+            # Use _decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_names = [flag.name for flag in decomposed[1]]\n+                flag_expression = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return (flag_expression, {\"import %s\" % module})\n+        except (AttributeError, ValueError):\n+            pass\n+        \n+        # Fallback to original behavior if decomposition fails\n+        return (\n+            \"%s.%s[%r]\" % (module, enum_class.__qualname__, getattr(self.value, 'name', None)),\n+            {\"import %s\" % module},\n+        )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n"
  }
}