{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/fields/related_descriptors.py lines 256-257)": "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key field if the related object has a valid primary key\n                # This prevents setting empty string or None values that would cause constraint violations\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Mark the field for deferred assignment when the related object gets a valid PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n",
    "Location 2 (/root/hy/projects_1/django/django/db/models/fields/related_descriptors.py lines 251-252)": "\n        # Set the value of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Defer the assignment by setting up a callback to update when the related object gets a valid PK\n                    def update_fk_on_save(sender, instance_inner=instance, **kwargs):\n                        if hasattr(instance_inner, lh_field.attname):\n                            related_obj = self.field.get_cached_value(instance_inner, default=None)\n                            if related_obj is not None:\n                                new_pk = getattr(related_obj, rh_field.attname)\n                                if new_pk is not None and new_pk != '':\n                                    setattr(instance_inner, lh_field.attname, new_pk)\n                                    signals.post_save.disconnect(update_fk_on_save, sender=value.__class__)\n                    \n                    # Connect the signal to update FK when the related object is saved\n                    signals.post_save.connect(update_fk_on_save, sender=value.__class__, weak=False)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
    "Location 3 (/root/hy/projects_1/django/django/db/models/fields/related_descriptors.py lines 254-261)": "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Defer assignment - mark the field as needing update when related object gets PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
    "Location 4 (/root/hy/projects_1/django/django/db/models/fields/related_descriptors.py lines 266-267)": "\n        else:\n            # Set the concrete foreign key attribute on the model.\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the related object's primary key value\n                related_pk_value = getattr(value, rh_field.attname)\n                \n                # Only set the foreign key if the related object has a valid primary key\n                # For unsaved objects with empty/None PKs, we'll defer the assignment\n                if related_pk_value is not None and related_pk_value != '':\n                    setattr(instance, lh_field.attname, related_pk_value)\n                else:\n                    # For unsaved related objects, we need to defer the FK assignment\n                    # Store a reference to update the FK when the related object is saved\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
    "Location 5 (/root/hy/projects_1/django/django/db/models/fields/related_descriptors.py lines 203-268)": "\ndef __set__(self, instance, value):\n    \"\"\"\n    Set the related instance through the forward relation.\n\n    With the example above, when setting ``child.parent = parent``:\n\n    - ``self`` is the descriptor managing the ``parent`` attribute\n    - ``instance`` is the ``child`` instance\n    - ``value`` is the ``parent`` instance on the right of the equal sign\n    \"\"\"\n    # An object must be an instance of the related class.\n    if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n        raise ValueError(\n            'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                value,\n                instance._meta.object_name,\n                self.field.name,\n                self.field.remote_field.model._meta.object_name,\n            )\n        )\n    elif value is not None:\n        if instance._state.db is None:\n            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n        if value._state.db is None:\n            value._state.db = router.db_for_write(value.__class__, instance=instance)\n        if not router.allow_relation(value, instance):\n            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n    remote_field = self.field.remote_field\n    # If we're setting the value of a OneToOneField to None, we need to clear\n    # out the cache on any old related object. Otherwise, deleting the\n    # previously-related object will also cause this object to be deleted,\n    # which is wrong.\n    if value is None:\n        # Look up the previously-related object, which may still be available\n        # since we've not yet cleared out the related field.\n        # Use the cache directly, instead of the accessor; if we haven't\n        # populated the cache, then we don't care - we're only accessing\n        # the object to invalidate the accessor cache, so there's no\n        # need to populate the cache just to expire it again.\n        related = self.field.get_cached_value(instance, default=None)\n\n        # If we've got an old related object, we need to clear out its\n        # cache. This cache also might not exist if the related object\n        # hasn't been accessed yet.\n        if related is not None:\n            remote_field.set_cached_value(related, None)\n\n        for lh_field, rh_field in self.field.related_fields:\n            setattr(instance, lh_field.attname, None)\n\n    # Set the values of the related field.\n    else:\n        for lh_field, rh_field in self.field.related_fields:\n            rh_value = getattr(value, rh_field.attname)\n            # Only set the foreign key field if the related object has a valid primary key\n            # For empty string primary keys, defer assignment until the related object is saved\n            if rh_value is not None and rh_value != '':\n                setattr(instance, lh_field.attname, rh_value)\n            else:\n                # Clear the foreign key field to avoid stale values\n                setattr(instance, lh_field.attname, None)\n\n    # Set the related instance cache used by __get__ to avoid an SQL query\n    # when accessing the attribute we just set.\n    self.field.set_cached_value(instance, value)\n\n    # If this is a one-to-one relation, set the reverse accessor cache on\n    # the related object to the current instance to avoid an extra SQL\n    # query if it's accessed later on.\n    if value is not None and not remote_field.multiple:\n        remote_field.set_cached_value(value, instance)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/django/django/db/models/fields/related_descriptors.py lines 256-257)": [
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key field if the related object has a valid primary key\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Mark this field for deferred assignment when the related object gets a valid PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                \n                # Only set the foreign key field if the related object has a valid primary key\n                # This prevents setting empty string/None values that would cause constraint violations\n                if pk_value is not None and pk_value != '':\n                    setattr(instance, lh_field.attname, pk_value)\n                else:\n                    # If the related object doesn't have a valid PK yet, we need to defer\n                    # the foreign key assignment. For now, we'll store a reference to update later.\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the foreign key value from the related object\n                fk_value = getattr(value, rh_field.attname)\n                \n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents setting empty string/None values that would cause data loss\n                if fk_value is not None and fk_value != '':\n                    setattr(instance, lh_field.attname, fk_value)\n                else:\n                    # If the related object doesn't have a valid PK yet, store a reference\n                    # to update the FK later when the related object gets a PK\n                    if not hasattr(instance, '_deferred_fk_updates'):\n                        instance._deferred_fk_updates = {}\n                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # If the related object's primary key is empty/None, defer the assignment\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Store the related object for deferred assignment\n                    # We'll need to update the foreign key when the related object gets a valid PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the value from the related object's primary key field\n                rh_value = getattr(value, rh_field.attname)\n                \n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents setting empty string or None values that would be overwritten\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid PK yet, we need to defer\n                    # the foreign key assignment. We'll set up a callback to update it\n                    # when the related object gets a primary key value.\n                    def update_fk_callback():\n                        current_related = self.field.get_cached_value(instance, default=None)\n                        if current_related is value:  # Make sure it's still the same object\n                            new_rh_value = getattr(value, rh_field.attname)\n                            if new_rh_value is not None and new_rh_value != '':\n                                setattr(instance, lh_field.attname, new_rh_value)\n                    \n                    # Store the callback on the related object so it can be called later\n                    if not hasattr(value, '_pending_fk_updates'):\n                        value._pending_fk_updates = []\n                    value._pending_fk_updates.append(update_fk_callback)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents setting empty string/None values that cause data loss\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # For unsaved related objects, we need to defer the FK assignment\n                    # Set up a callback to update the FK when the related object is saved\n                    def update_fk_on_save(sender, instance_inner=instance, lh_field_inner=lh_field, value_inner=value, rh_field_inner=rh_field, **kwargs):\n                        if hasattr(value_inner, rh_field_inner.attname):\n                            rh_value_inner = getattr(value_inner, rh_field_inner.attname)\n                            if rh_value_inner is not None and rh_value_inner != '':\n                                setattr(instance_inner, lh_field_inner.attname, rh_value_inner)\n                    \n                    # Connect the signal to update FK when related object is saved\n                    signals.post_save.connect(update_fk_on_save, sender=value.__class__, weak=False)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                \n                # Only set the foreign key if the related object has a valid primary key\n                # For new objects with empty string or None primary keys, defer assignment\n                if pk_value not in (None, ''):\n                    setattr(instance, lh_field.attname, pk_value)\n                else:\n                    # Mark that we need to update this field when the related object gets a PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Defer foreign key assignment until the related object gets a valid PK\n                    # Store a reference to update the FK later\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = []\n                    instance._deferred_fk_assignments.append((lh_field, value, rh_field))\n"
    ],
    "Location 2 (/root/hy/projects_1/django/django/db/models/fields/related_descriptors.py lines 251-252)": [
      "\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # Set the values of the related field, but only if the related object\n        # has a valid primary key. If not, defer the assignment.\n        if value is not None:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key field if the related object has a valid primary key\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # we need to defer the foreign key assignment. For now, we'll\n                    # set up a callback to update the foreign key when the related\n                    # object gets a primary key.\n                    def update_fk_callback():\n                        current_value = self.field.get_cached_value(instance, default=None)\n                        if current_value is value:  # Only update if relationship still exists\n                            new_rh_value = getattr(value, rh_field.attname)\n                            if new_rh_value is not None and new_rh_value != '':\n                                setattr(instance, lh_field.attname, new_rh_value)\n                    \n                    # Store the callback on the related object for later execution\n                    if not hasattr(value, '_fk_update_callbacks'):\n                        value._fk_update_callbacks = []\n                    value._fk_update_callbacks.append((instance, lh_field, rh_field, update_fk_callback))\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key field if the related object has a valid primary key\n                # If the related object's primary key is empty/None, defer the assignment\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Mark the foreign key field as needing deferred assignment\n                    # by storing a reference to the related object\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n                    # Set to None for now to avoid constraint violations\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the related object(s)\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared the related field.\n            # Use the cache directly, not the accessor; if we haven't populated\n            # the cache, then we don't care if we have to look up the related\n            # object again later.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the related object's primary key value\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # Otherwise, defer the assignment until the related object is saved\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Mark the field as needing deferred assignment\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the value of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key field if the related object has a valid primary key\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Store a reference to update the foreign key later when the related object gets a valid PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Clear the cached foreign key value.\n        if value is None:\n            # Invalidate the cache, if it exists\n            # We don't want to force an SQL query if the relationship was\n            # not accessed yet, which would happen if we simply tried to\n            # delete the object. Instead, set it to None and let the field\n            # generate a new query if needed.\n            self.field.set_cached_value(instance, None)\n\n            # Clear the cache on the related object too. It's possible that\n            # we assigned None or a different manager; regardless, we're no\n            # longer related.\n            remote_field = self.field.remote_field\n            if remote_field.is_cached(instance):\n                getattr(instance, self.field.get_cache_name()).clear(bulk=False)\n\n            # If we're setting the value to None, we don't need to add any\n            # additional logic since Django will handle this case correctly\n            # by clearing the foreign key field.\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            # Check if the related object has a valid primary key\n            has_valid_pk = True\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                if rh_value is None or rh_value == '':\n                    has_valid_pk = False\n                    break\n            \n            if has_valid_pk:\n                # Set foreign key fields immediately if related object has valid PK\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n            else:\n                # Defer foreign key field assignment - set up a callback to update\n                # the foreign key fields when the related object gets a valid PK\n                def update_fk_fields():\n                    for lh_field, rh_field in self.field.related_fields:\n                        rh_value = getattr(value, rh_field.attname)\n                        if rh_value is not None and rh_value != '':\n                            setattr(instance, lh_field.attname, rh_value)\n                \n                # Store the callback on the related object to be called when it's saved\n                if not hasattr(value, '_pending_fk_updates'):\n                    value._pending_fk_updates = []\n                value._pending_fk_updates.append(update_fk_fields)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the related object(s)\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, don't go back to the database.\n            # The reverse accessor should also set the cache, but we need\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the related object's primary key value\n                rh_value = getattr(value, rh_field.attname)\n                \n                # Only set the foreign key field if the related object has a valid primary key\n                # For empty/default primary keys (empty string, None), defer the assignment\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Store a reference to update the foreign key later when the related object gets a valid pk\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Clear the cached foreign key value.\n        if value is None:\n            # Unless it gets restored by the second branch below, clearing the\n            # object also clears the cache. So there's no point in getting\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            # Check if the related object has a valid primary key\n            has_valid_pk = True\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                if pk_value is None or pk_value == '':\n                    has_valid_pk = False\n                    break\n            \n            if has_valid_pk:\n                # Related object has valid primary key, set foreign key fields immediately\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n            else:\n                # Related object doesn't have valid primary key, defer assignment\n                # Clear existing foreign key values\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, None)\n                \n                # Mark instance as having deferred foreign key assignment\n                if not hasattr(instance, '_deferred_fk_assignments'):\n                    instance._deferred_fk_assignments = {}\n                instance._deferred_fk_assignments[self.field.name] = value\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # If the related object's PK is empty/None, defer the assignment\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Mark that we need to update this field later when the related object gets a PK\n                    if not hasattr(instance, '_deferred_fk_updates'):\n                        instance._deferred_fk_updates = {}\n                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n                    # Don't set the foreign key field to empty value\n                    # Leave it as is (could be None or existing value)\n"
    ],
    "Location 3 (/root/hy/projects_1/django/django/db/models/fields/related_descriptors.py lines 254-261)": [
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents setting empty string/None values that would be overwritten\n                if pk_value is not None and pk_value != '':\n                    setattr(instance, lh_field.attname, pk_value)\n                else:\n                    # If the related object doesn't have a valid PK yet, we need to defer\n                    # the foreign key assignment. We'll store a reference to update later.\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the related object's primary key value\n                pk_value = getattr(value, rh_field.attname)\n                \n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents setting empty string or None values that would cause\n                # foreign key constraint violations\n                if pk_value not in (None, ''):\n                    setattr(instance, lh_field.attname, pk_value)\n                else:\n                    # If the related object doesn't have a valid PK yet, we need to\n                    # defer the FK assignment. We'll store a reference to update later.\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # Otherwise, defer the assignment to avoid capturing empty/None values\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Store the related object for deferred assignment\n                    # This will be handled when the related object gets a valid PK\n                    setattr(instance, lh_field.attname, None)\n                    # Set a flag to track that this field needs deferred assignment\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key field if the related object has a valid primary key\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Defer the assignment by storing a reference to update later\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # Empty string or None indicates the related object hasn't been saved yet\n                if pk_value not in (None, ''):\n                    setattr(instance, lh_field.attname, pk_value)\n                else:\n                    # Clear the foreign key field when related object has no valid PK\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # If the related object's PK is empty/None, defer assignment until later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Set up deferred assignment by storing the related object\n                    # The foreign key will be set when the related object gets a valid PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n                    # Don't set the foreign key field yet, leave it as is\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # Otherwise, defer the assignment to maintain object relationship\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field for now - it will be set when the\n                    # related object gets a valid primary key\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                \n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents setting empty string/None values that would cause data loss\n                if pk_value is not None and pk_value != '':\n                    setattr(instance, lh_field.attname, pk_value)\n                else:\n                    # If the related object doesn't have a valid PK yet, we need to\n                    # defer the foreign key assignment. For now, we'll set it to None\n                    # to avoid constraint violations, and rely on save() logic to\n                    # handle the relationship properly when the related object gets a PK\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n"
    ],
    "Location 4 (/root/hy/projects_1/django/django/db/models/fields/related_descriptors.py lines 266-267)": [
      "\n        else:\n            # Set the concrete foreign key attribute on the model.\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents setting empty string/None values that would cause constraint violations\n                if rh_value not in (None, ''):\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # For unsaved related objects, defer the foreign key assignment\n                    # Store the related object so we can set the FK when it gets a PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n        else:\n            # Set the concrete foreign key attribute on the model.\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # or if we're explicitly setting it to None/empty\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                elif not hasattr(value, '_deferred_fk_assignments'):\n                    # Store deferred assignment info on the related object\n                    value._deferred_fk_assignments = []\n                if rh_value is None or rh_value == '':\n                    # Store the assignment for later when the related object gets a valid PK\n                    if not hasattr(value, '_deferred_fk_assignments'):\n                        value._deferred_fk_assignments = []\n                    value._deferred_fk_assignments.append((instance, lh_field))\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n        else:\n            # Set the concrete foreign key on the source object\n            for lh_field, rh_field in self.field.related_fields:\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents setting empty/None values that would cause constraint violations\n                related_pk_value = getattr(value, rh_field.attname)\n                if related_pk_value is not None and related_pk_value != '':\n                    setattr(instance, lh_field.attname, related_pk_value)\n                else:\n                    # Store the related object for deferred FK assignment\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n        else:\n            # Set the concrete foreign key values on the model instance.\n            for lh_field, rh_field in self.field.related_fields:\n                # Check if the related object has a valid primary key value\n                rh_value = getattr(value, rh_field.attname)\n                if rh_value is not None and rh_value != '':\n                    # Related object has a valid PK, set it immediately\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Related object doesn't have a valid PK yet, defer the assignment\n                    # by storing a reference to update later\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n                    # Clear any existing foreign key value\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=instance)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=value)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value to None, clear the foreign key fields.\n        if value is None:\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n        else:\n            # Check if the related object has a valid primary key\n            has_valid_pk = True\n            for lh_field, rh_field in self.field.related_fields:\n                pk_val = getattr(value, rh_field.attname)\n                if pk_val is None or pk_val == '':\n                    has_valid_pk = False\n                    break\n            \n            if has_valid_pk:\n                # Set foreign key fields immediately if related object has valid PK\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n            else:\n                # Defer foreign key assignment - store a reference to update later\n                if not hasattr(instance, '_deferred_fk_assignments'):\n                    instance._deferred_fk_assignments = {}\n                instance._deferred_fk_assignments[self.field.name] = value\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n        else:\n            # Set the concrete foreign key attribute on the model.\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # or if we're explicitly setting it to None/empty\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                elif not hasattr(value, '_state') or value._state.adding:\n                    # For new unsaved objects, store a reference to update the FK later\n                    if not hasattr(instance, '_pending_fk_updates'):\n                        instance._pending_fk_updates = {}\n                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n                else:\n                    setattr(instance, lh_field.attname, rh_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=instance)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=value)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value to None, clear the cache and set the\n        # fk to None.\n        if value is None:\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Only set the foreign key field if the related object has a valid primary key\n                rh_value = getattr(value, rh_field.attname)\n                if rh_value is not None and rh_value != \"\":\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If related object doesn't have a valid PK yet, defer the assignment\n                    # by storing a reference to update later\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n        else:\n            # Set the concrete foreign key attribute on the model.\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Defer foreign key assignment - store the related object for later resolution\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n"
    ],
    "Location 5 (/root/hy/projects_1/django/django/db/models/fields/related_descriptors.py lines 203-268)": [
      "\ndef __set__(self, instance, value):\n    \"\"\"\n    Set the related instance through the forward relation.\n\n    With the example above, when setting ``child.parent = parent``:\n\n    - ``self`` is the descriptor managing the ``parent`` attribute\n    - ``instance`` is the ``child`` instance\n    - ``value`` is the ``parent`` instance on the right of the equal sign\n    \"\"\"\n    # An object must be an instance of the related class.\n    if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n        raise ValueError(\n            'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                value,\n                instance._meta.object_name,\n                self.field.name,\n                self.field.remote_field.model._meta.object_name,\n            )\n        )\n    elif value is not None:\n        if instance._state.db is None:\n            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n        if value._state.db is None:\n            value._state.db = router.db_for_write(value.__class__, instance=instance)\n        if not router.allow_relation(value, instance):\n            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n    remote_field = self.field.remote_field\n    # If we're setting the value of a OneToOneField to None, we need to clear\n    # out the cache on any old related object. Otherwise, deleting the\n    # previously-related object will also cause this object to be deleted,\n    # which is wrong.\n    if value is None:\n        # Look up the previously-related object, which may still be available\n        # since we've not yet cleared out the related field.\n        # Use the cache directly, instead of the accessor; if we haven't\n        # populated the cache, then we don't care - we're only accessing\n        # the object to invalidate the accessor cache, so there's no\n        # need to populate the cache just to expire it again.\n        related = self.field.get_cached_value(instance, default=None)\n\n        # If we've got an old related object, we need to clear out its\n        # cache. This cache also might not exist if the related object\n        # hasn't been accessed yet.\n        if related is not None:\n            remote_field.set_cached_value(related, None)\n\n        for lh_field, rh_field in self.field.related_fields:\n            setattr(instance, lh_field.attname, None)\n\n    # Set the values of the related field.\n    else:\n        for lh_field, rh_field in self.field.related_fields:\n            rh_value = getattr(value, rh_field.attname)\n            # Only set the foreign key field if the related object has a valid primary key\n            # Otherwise, defer assignment until the related object is saved\n            if rh_value is not None and rh_value != '':\n                setattr(instance, lh_field.attname, rh_value)\n            else:\n                # Clear the foreign key field and set up deferred assignment\n                setattr(instance, lh_field.attname, None)\n                # Store a reference for later assignment when the related object gets a PK\n                if not hasattr(instance, '_deferred_fk_assignments'):\n                    instance._deferred_fk_assignments = {}\n                instance._deferred_fk_assignments[self.field.name] = (lh_field, rh_field, value)\n\n    # Set the related instance cache used by __get__ to avoid an SQL query\n    # when accessing the attribute we just set.\n    self.field.set_cached_value(instance, value)\n\n    # If this is a one-to-one relation, set the reverse accessor cache on\n    # the related object to the current instance to avoid an extra SQL\n    # query if it's accessed later on.\n    if value is not None and not remote_field.multiple:\n        remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the related field value\n                related_value = getattr(value, rh_field.attname)\n                # Only set the foreign key field if the related object has a valid primary key\n                # This prevents setting empty string/None values that would be overwritten later\n                if related_value is not None and related_value != '':\n                    setattr(instance, lh_field.attname, related_value)\n                else:\n                    # Set up a deferred assignment - store the related object reference\n                    # so the foreign key can be set when the related object gets a valid PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                # Only set the foreign key field if the related object has a valid primary key\n                # This prevents setting empty string or None when the related object is unsaved\n                if pk_value is not None and pk_value != '':\n                    setattr(instance, lh_field.attname, pk_value)\n                else:\n                    # Store a reference to update the foreign key later when the related object gets a primary key\n                    if not hasattr(instance, '_pending_fk_updates'):\n                        instance._pending_fk_updates = {}\n                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\ndef __set__(self, instance, value):\n    \"\"\"\n    Set the related instance through the forward relation.\n\n    With the example above, when setting ``child.parent = parent``:\n\n    - ``self`` is the descriptor managing the ``parent`` attribute\n    - ``instance`` is the ``child`` instance\n    - ``value`` is the ``parent`` instance on the right of the equal sign\n    \"\"\"\n    # An object must be an instance of the related class.\n    if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n        raise ValueError(\n            'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                value,\n                instance._meta.object_name,\n                self.field.name,\n                self.field.remote_field.model._meta.object_name,\n            )\n        )\n    elif value is not None:\n        if instance._state.db is None:\n            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n        if value._state.db is None:\n            value._state.db = router.db_for_write(value.__class__, instance=instance)\n        if not router.allow_relation(value, instance):\n            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n    remote_field = self.field.remote_field\n    # If we're setting the value of a OneToOneField to None, we need to clear\n    # out the cache on any old related object. Otherwise, deleting the\n    # previously-related object will also cause this object to be deleted,\n    # which is wrong.\n    if value is None:\n        # Look up the previously-related object, which may still be available\n        # since we've not yet cleared out the related field.\n        # Use the cache directly, instead of the accessor; if we haven't\n        # populated the cache, then we don't care - we're only accessing\n        # the object to invalidate the accessor cache, so there's no\n        # need to populate the cache just to expire it again.\n        related = self.field.get_cached_value(instance, default=None)\n\n        # If we've got an old related object, we need to clear out its\n        # cache. This cache also might not exist if the related object\n        # hasn't been accessed yet.\n        if related is not None:\n            remote_field.set_cached_value(related, None)\n\n        for lh_field, rh_field in self.field.related_fields:\n            setattr(instance, lh_field.attname, None)\n\n    # Set the values of the related field.\n    else:\n        for lh_field, rh_field in self.field.related_fields:\n            rh_value = getattr(value, rh_field.attname)\n            # Only set the foreign key field if the related object has a valid primary key\n            # For auto-incrementing fields, None or empty string indicates unsaved object\n            if rh_value is not None and rh_value != '':\n                setattr(instance, lh_field.attname, rh_value)\n            else:\n                # Clear the foreign key field for unsaved related objects\n                setattr(instance, lh_field.attname, None)\n\n    # Set the related instance cache used by __get__ to avoid an SQL query\n    # when accessing the attribute we just set.\n    self.field.set_cached_value(instance, value)\n\n    # If this is a one-to-one relation, set the reverse accessor cache on\n    # the related object to the current instance to avoid an extra SQL\n    # query if it's accessed later on.\n    if value is not None and not remote_field.multiple:\n        remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the related field value\n                related_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents setting empty/None values that cause constraint violations\n                if related_value is not None and related_value != '':\n                    setattr(instance, lh_field.attname, related_value)\n                else:\n                    # If the related object doesn't have a valid PK yet, clear the FK field\n                    # The FK will be set later when the related object gets a valid PK\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_val = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                if pk_val is not None and pk_val != '':\n                    setattr(instance, lh_field.attname, pk_val)\n                else:\n                    # Clear the foreign key field and set up deferred assignment\n                    setattr(instance, lh_field.attname, None)\n                    # Store reference for deferred assignment when related object gets a valid PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the related field value\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # For new objects with empty/None primary keys, defer the assignment\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Store a reference to update the foreign key later when the related object gets a primary key\n                    if not hasattr(instance, '_deferred_fk_updates'):\n                        instance._deferred_fk_updates = {}\n                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set foreign key if the related object has a valid primary key\n                # This prevents setting empty string or None as foreign key value\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Store a reference to update the foreign key later when the related object gets a valid pk\n                    if not hasattr(instance, '_deferred_fk_updates'):\n                        instance._deferred_fk_updates = {}\n                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..351a9706f1 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,7 +255,21 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                pk_val = getattr(value, rh_field.attname)\n+                # Only set the foreign key field if the related object has a valid primary key\n+                # This prevents setting empty string or None values that would cause constraint violations\n+                if pk_val not in (None, ''):\n+                    setattr(instance, lh_field.attname, pk_val)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n@@ -263,6 +278,7 @@ class ForwardManyToOneDescriptor:\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n+\n         if value is not None and not remote_field.multiple:\n             remote_field.set_cached_value(value, instance)\n \n",
    "variant_0": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..f592425540 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,61 +200,137 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n-    def __set__(self, instance, value):\n-        \"\"\"\n-        Set the related instance through the forward relation.\n \n-        With the example above, when setting ``child.parent = parent``:\n+def __set__(self, instance, value):\n+    \"\"\"\n+    Set the related instance through the forward relation.\n \n-        - ``self`` is the descriptor managing the ``parent`` attribute\n-        - ``instance`` is the ``child`` instance\n-        - ``value`` is the ``parent`` instance on the right of the equal sign\n-        \"\"\"\n-        # An object must be an instance of the related class.\n-        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n-            raise ValueError(\n-                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n-                    value,\n-                    instance._meta.object_name,\n-                    self.field.name,\n-                    self.field.remote_field.model._meta.object_name,\n-                )\n+    With the example above, when setting ``child.parent = parent``:\n+\n+    - ``self`` is the descriptor managing the ``parent`` attribute\n+    - ``instance`` is the ``child`` instance\n+    - ``value`` is the ``parent`` instance on the right of the equal sign\n+    \"\"\"\n+    # An object must be an instance of the related class.\n+    if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n+        raise ValueError(\n+            'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n+                value,\n+                instance._meta.object_name,\n+                self.field.name,\n+                self.field.remote_field.model._meta.object_name,\n             )\n-        elif value is not None:\n-            if instance._state.db is None:\n-                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n-            if value._state.db is None:\n-                value._state.db = router.db_for_write(value.__class__, instance=instance)\n-            if not router.allow_relation(value, instance):\n-                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+        )\n+    elif value is not None:\n+        if instance._state.db is None:\n+            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n+        if value._state.db is None:\n+            value._state.db = router.db_for_write(value.__class__, instance=instance)\n+        if not router.allow_relation(value, instance):\n+            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+\n+    remote_field = self.field.remote_field\n+    # If we're setting the value of a OneToOneField to None, we need to clear\n+    # out the cache on any old related object. Otherwise, deleting the\n+    # previously-related object will also cause this object to be deleted,\n+    # which is wrong.\n+    if value is None:\n+        # Look up the previously-related object, which may still be available\n+        # since we've not yet cleared out the related field.\n+        # Use the cache directly, instead of the accessor; if we haven't\n+        # populated the cache, then we don't care - we're only accessing\n+        # the object to invalidate the accessor cache, so there's no\n+        # need to populate the cache just to expire it again.\n+        related = self.field.get_cached_value(instance, default=None)\n+\n+        # If we've got an old related object, we need to clear out its\n+        # cache. This cache also might not exist if the related object\n+        # hasn't been accessed yet.\n+        if related is not None:\n+            remote_field.set_cached_value(related, None)\n+\n+        for lh_field, rh_field in self.field.related_fields:\n+            setattr(instance, lh_field.attname, None)\n+\n+    # Set the values of the related field.\n+    else:\n+        for lh_field, rh_field in self.field.related_fields:\n+            rh_value = getattr(value, rh_field.attname)\n+            # Only set the foreign key field if the related object has a valid primary key\n+            # For empty string primary keys, defer assignment until the related object is saved\n+            if rh_value is not None and rh_value != '':\n+                setattr(instance, lh_field.attname, rh_value)\n+            else:\n+                # Clear the foreign key field to avoid stale values\n+                setattr(instance, lh_field.attname, None)\n \n-        remote_field = self.field.remote_field\n-        # If we're setting the value of a OneToOneField to None, we need to clear\n-        # out the cache on any old related object. Otherwise, deleting the\n-        # previously-related object will also cause this object to be deleted,\n-        # which is wrong.\n-        if value is None:\n-            # Look up the previously-related object, which may still be available\n-            # since we've not yet cleared out the related field.\n-            # Use the cache directly, instead of the accessor; if we haven't\n-            # populated the cache, then we don't care - we're only accessing\n-            # the object to invalidate the accessor cache, so there's no\n-            # need to populate the cache just to expire it again.\n-            related = self.field.get_cached_value(instance, default=None)\n-\n-            # If we've got an old related object, we need to clear out its\n-            # cache. This cache also might not exist if the related object\n-            # hasn't been accessed yet.\n-            if related is not None:\n-                remote_field.set_cached_value(related, None)\n+    # Set the related instance cache used by __get__ to avoid an SQL query\n+    # when accessing the attribute we just set.\n+    self.field.set_cached_value(instance, value)\n+\n+    # If this is a one-to-one relation, set the reverse accessor cache on\n+    # the related object to the current instance to avoid an extra SQL\n+    # query if it's accessed later on.\n+    if value is not None and not remote_field.multiple:\n+        remote_field.set_cached_value(value, instance)\n+                    \n+                    # Connect the signal to update FK when the related object is saved\n+                    signals.post_save.connect(update_fk_on_save, sender=value.__class__, weak=False)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n \n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Defer assignment - mark the field as needing update when related object gets PK\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+                # This prevents setting empty string or None values that would cause constraint violations\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Mark the field for deferred assignment when the related object gets a valid PK\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        else:\n+            # Set the concrete foreign key attribute on the model.\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Get the related object's primary key value\n+                related_pk_value = getattr(value, rh_field.attname)\n+                \n+                # Only set the foreign key if the related object has a valid primary key\n+                # For unsaved objects with empty/None PKs, we'll defer the assignment\n+                if related_pk_value is not None and related_pk_value != '':\n+                    setattr(instance, lh_field.attname, related_pk_value)\n+                else:\n+                    # For unsaved related objects, we need to defer the FK assignment\n+                    # Store a reference to update the FK when the related object is saved\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n",
    "variant_1": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..a40a004f15 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,61 +200,145 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n-    def __set__(self, instance, value):\n-        \"\"\"\n-        Set the related instance through the forward relation.\n \n-        With the example above, when setting ``child.parent = parent``:\n+def __set__(self, instance, value):\n+    \"\"\"\n+    Set the related instance through the forward relation.\n \n-        - ``self`` is the descriptor managing the ``parent`` attribute\n-        - ``instance`` is the ``child`` instance\n-        - ``value`` is the ``parent`` instance on the right of the equal sign\n-        \"\"\"\n-        # An object must be an instance of the related class.\n-        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n-            raise ValueError(\n-                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n-                    value,\n-                    instance._meta.object_name,\n-                    self.field.name,\n-                    self.field.remote_field.model._meta.object_name,\n-                )\n+    With the example above, when setting ``child.parent = parent``:\n+\n+    - ``self`` is the descriptor managing the ``parent`` attribute\n+    - ``instance`` is the ``child`` instance\n+    - ``value`` is the ``parent`` instance on the right of the equal sign\n+    \"\"\"\n+    # An object must be an instance of the related class.\n+    if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n+        raise ValueError(\n+            'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n+                value,\n+                instance._meta.object_name,\n+                self.field.name,\n+                self.field.remote_field.model._meta.object_name,\n             )\n-        elif value is not None:\n-            if instance._state.db is None:\n-                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n-            if value._state.db is None:\n-                value._state.db = router.db_for_write(value.__class__, instance=instance)\n-            if not router.allow_relation(value, instance):\n-                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+        )\n+    elif value is not None:\n+        if instance._state.db is None:\n+            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n+        if value._state.db is None:\n+            value._state.db = router.db_for_write(value.__class__, instance=instance)\n+        if not router.allow_relation(value, instance):\n+            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+\n+    remote_field = self.field.remote_field\n+    # If we're setting the value of a OneToOneField to None, we need to clear\n+    # out the cache on any old related object. Otherwise, deleting the\n+    # previously-related object will also cause this object to be deleted,\n+    # which is wrong.\n+    if value is None:\n+        # Look up the previously-related object, which may still be available\n+        # since we've not yet cleared out the related field.\n+        # Use the cache directly, instead of the accessor; if we haven't\n+        # populated the cache, then we don't care - we're only accessing\n+        # the object to invalidate the accessor cache, so there's no\n+        # need to populate the cache just to expire it again.\n+        related = self.field.get_cached_value(instance, default=None)\n+\n+        # If we've got an old related object, we need to clear out its\n+        # cache. This cache also might not exist if the related object\n+        # hasn't been accessed yet.\n+        if related is not None:\n+            remote_field.set_cached_value(related, None)\n+\n+        for lh_field, rh_field in self.field.related_fields:\n+            setattr(instance, lh_field.attname, None)\n+\n+    # Set the values of the related field.\n+    else:\n+        for lh_field, rh_field in self.field.related_fields:\n+            rh_value = getattr(value, rh_field.attname)\n+            # Only set the foreign key field if the related object has a valid primary key\n+            # Otherwise, defer assignment until the related object is saved\n+            if rh_value is not None and rh_value != '':\n+                setattr(instance, lh_field.attname, rh_value)\n+            else:\n+                # Clear the foreign key field and set up deferred assignment\n+                setattr(instance, lh_field.attname, None)\n+                # Store a reference for later assignment when the related object gets a PK\n+                if not hasattr(instance, '_deferred_fk_assignments'):\n+                    instance._deferred_fk_assignments = {}\n+                instance._deferred_fk_assignments[self.field.name] = (lh_field, rh_field, value)\n+\n+    # Set the related instance cache used by __get__ to avoid an SQL query\n+    # when accessing the attribute we just set.\n+    self.field.set_cached_value(instance, value)\n+\n+    # If this is a one-to-one relation, set the reverse accessor cache on\n+    # the related object to the current instance to avoid an extra SQL\n+    # query if it's accessed later on.\n+    if value is not None and not remote_field.multiple:\n+        remote_field.set_cached_value(value, instance)\n+                    def update_fk_callback():\n+                        current_value = self.field.get_cached_value(instance, default=None)\n+                        if current_value is value:  # Only update if relationship still exists\n+                            new_rh_value = getattr(value, rh_field.attname)\n+                            if new_rh_value is not None and new_rh_value != '':\n+                                setattr(instance, lh_field.attname, new_rh_value)\n+                    \n+                    # Store the callback on the related object for later execution\n+                    if not hasattr(value, '_fk_update_callbacks'):\n+                        value._fk_update_callbacks = []\n+                    value._fk_update_callbacks.append((instance, lh_field, rh_field, update_fk_callback))\n \n-        remote_field = self.field.remote_field\n-        # If we're setting the value of a OneToOneField to None, we need to clear\n-        # out the cache on any old related object. Otherwise, deleting the\n-        # previously-related object will also cause this object to be deleted,\n-        # which is wrong.\n-        if value is None:\n-            # Look up the previously-related object, which may still be available\n-            # since we've not yet cleared out the related field.\n-            # Use the cache directly, instead of the accessor; if we haven't\n-            # populated the cache, then we don't care - we're only accessing\n-            # the object to invalidate the accessor cache, so there's no\n-            # need to populate the cache just to expire it again.\n-            related = self.field.get_cached_value(instance, default=None)\n-\n-            # If we've got an old related object, we need to clear out its\n-            # cache. This cache also might not exist if the related object\n-            # hasn't been accessed yet.\n-            if related is not None:\n-                remote_field.set_cached_value(related, None)\n \n+        # Set the values of the related field.\n+        else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+                # Get the primary key value from the related object\n+                pk_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents setting empty string/None values that would be overwritten\n+                if pk_value is not None and pk_value != '':\n+                    setattr(instance, lh_field.attname, pk_value)\n+                else:\n+                    # If the related object doesn't have a valid PK yet, we need to defer\n+                    # the foreign key assignment. We'll store a reference to update later.\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Mark this field for deferred assignment when the related object gets a valid PK\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n \n-        # Set the values of the related field.\n         else:\n+            # Set the concrete foreign key attribute on the model.\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents setting empty string/None values that would cause constraint violations\n+                if rh_value not in (None, ''):\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # For unsaved related objects, defer the foreign key assignment\n+                    # Store the related object so we can set the FK when it gets a PK\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n",
    "variant_2": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..1608bad291 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,7 +255,90 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                # Get the related field value\n+                related_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key field if the related object has a valid primary key\n+                # This prevents setting empty string/None values that would be overwritten later\n+                if related_value is not None and related_value != '':\n+                    setattr(instance, lh_field.attname, related_value)\n+                else:\n+                    # Set up a deferred assignment - store the related object reference\n+                    # so the foreign key can be set when the related object gets a valid PK\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Get the related object's primary key value\n+                pk_value = getattr(value, rh_field.attname)\n+                \n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents setting empty string or None values that would cause\n+                # foreign key constraint violations\n+                if pk_value not in (None, ''):\n+                    setattr(instance, lh_field.attname, pk_value)\n+                else:\n+                    # If the related object doesn't have a valid PK yet, we need to\n+                    # defer the FK assignment. We'll store a reference to update later.\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+                \n+                # Only set the foreign key field if the related object has a valid primary key\n+                # This prevents setting empty string/None values that would cause constraint violations\n+                if pk_value is not None and pk_value != '':\n+                    setattr(instance, lh_field.attname, pk_value)\n+                else:\n+                    # If the related object doesn't have a valid PK yet, we need to defer\n+                    # the foreign key assignment. For now, we'll store a reference to update later.\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        else:\n+            # Set the concrete foreign key attribute on the model.\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # or if we're explicitly setting it to None/empty\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                elif not hasattr(value, '_deferred_fk_assignments'):\n+                    # Store deferred assignment info on the related object\n+                    value._deferred_fk_assignments = []\n+                if rh_value is None or rh_value == '':\n+                    # Store the assignment for later when the related object gets a valid PK\n+                    if not hasattr(value, '_deferred_fk_assignments'):\n+                        value._deferred_fk_assignments = []\n+                    value._deferred_fk_assignments.append((instance, lh_field))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n",
    "variant_3": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..cd36e980f6 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,7 +255,101 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                # Get the primary key value from the related object\n+                pk_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key field if the related object has a valid primary key\n+                # This prevents setting empty string or None when the related object is unsaved\n+                if pk_value is not None and pk_value != '':\n+                    setattr(instance, lh_field.attname, pk_value)\n+                else:\n+                    # Store a reference to update the foreign key later when the related object gets a primary key\n+                    if not hasattr(instance, '_pending_fk_updates'):\n+                        instance._pending_fk_updates = {}\n+                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Get the related object's primary key value\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # Otherwise, defer the assignment until the related object is saved\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Mark the field as needing deferred assignment\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # Otherwise, defer the assignment to avoid capturing empty/None values\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Store the related object for deferred assignment\n+                    # This will be handled when the related object gets a valid PK\n+                    setattr(instance, lh_field.attname, None)\n+                    # Set a flag to track that this field needs deferred assignment\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+                \n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents setting empty string/None values that would cause data loss\n+                if fk_value is not None and fk_value != '':\n+                    setattr(instance, lh_field.attname, fk_value)\n+                else:\n+                    # If the related object doesn't have a valid PK yet, store a reference\n+                    # to update the FK later when the related object gets a PK\n+                    if not hasattr(instance, '_deferred_fk_updates'):\n+                        instance._deferred_fk_updates = {}\n+                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        else:\n+            # Set the concrete foreign key on the source object\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents setting empty/None values that would cause constraint violations\n+                related_pk_value = getattr(value, rh_field.attname)\n+                if related_pk_value is not None and related_pk_value != '':\n+                    setattr(instance, lh_field.attname, related_pk_value)\n+                else:\n+                    # Store the related object for deferred FK assignment\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n",
    "variant_4": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..fc97032055 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,61 +200,130 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n-    def __set__(self, instance, value):\n-        \"\"\"\n-        Set the related instance through the forward relation.\n \n-        With the example above, when setting ``child.parent = parent``:\n+def __set__(self, instance, value):\n+    \"\"\"\n+    Set the related instance through the forward relation.\n \n-        - ``self`` is the descriptor managing the ``parent`` attribute\n-        - ``instance`` is the ``child`` instance\n-        - ``value`` is the ``parent`` instance on the right of the equal sign\n-        \"\"\"\n-        # An object must be an instance of the related class.\n-        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n-            raise ValueError(\n-                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n-                    value,\n-                    instance._meta.object_name,\n-                    self.field.name,\n-                    self.field.remote_field.model._meta.object_name,\n-                )\n+    With the example above, when setting ``child.parent = parent``:\n+\n+    - ``self`` is the descriptor managing the ``parent`` attribute\n+    - ``instance`` is the ``child`` instance\n+    - ``value`` is the ``parent`` instance on the right of the equal sign\n+    \"\"\"\n+    # An object must be an instance of the related class.\n+    if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n+        raise ValueError(\n+            'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n+                value,\n+                instance._meta.object_name,\n+                self.field.name,\n+                self.field.remote_field.model._meta.object_name,\n             )\n-        elif value is not None:\n-            if instance._state.db is None:\n-                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n-            if value._state.db is None:\n-                value._state.db = router.db_for_write(value.__class__, instance=instance)\n-            if not router.allow_relation(value, instance):\n-                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+        )\n+    elif value is not None:\n+        if instance._state.db is None:\n+            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n+        if value._state.db is None:\n+            value._state.db = router.db_for_write(value.__class__, instance=instance)\n+        if not router.allow_relation(value, instance):\n+            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+\n+    remote_field = self.field.remote_field\n+    # If we're setting the value of a OneToOneField to None, we need to clear\n+    # out the cache on any old related object. Otherwise, deleting the\n+    # previously-related object will also cause this object to be deleted,\n+    # which is wrong.\n+    if value is None:\n+        # Look up the previously-related object, which may still be available\n+        # since we've not yet cleared out the related field.\n+        # Use the cache directly, instead of the accessor; if we haven't\n+        # populated the cache, then we don't care - we're only accessing\n+        # the object to invalidate the accessor cache, so there's no\n+        # need to populate the cache just to expire it again.\n+        related = self.field.get_cached_value(instance, default=None)\n+\n+        # If we've got an old related object, we need to clear out its\n+        # cache. This cache also might not exist if the related object\n+        # hasn't been accessed yet.\n+        if related is not None:\n+            remote_field.set_cached_value(related, None)\n+\n+        for lh_field, rh_field in self.field.related_fields:\n+            setattr(instance, lh_field.attname, None)\n+\n+    # Set the values of the related field.\n+    else:\n+        for lh_field, rh_field in self.field.related_fields:\n+            rh_value = getattr(value, rh_field.attname)\n+            # Only set the foreign key field if the related object has a valid primary key\n+            # For auto-incrementing fields, None or empty string indicates unsaved object\n+            if rh_value is not None and rh_value != '':\n+                setattr(instance, lh_field.attname, rh_value)\n+            else:\n+                # Clear the foreign key field for unsaved related objects\n+                setattr(instance, lh_field.attname, None)\n \n-        remote_field = self.field.remote_field\n-        # If we're setting the value of a OneToOneField to None, we need to clear\n-        # out the cache on any old related object. Otherwise, deleting the\n-        # previously-related object will also cause this object to be deleted,\n-        # which is wrong.\n-        if value is None:\n-            # Look up the previously-related object, which may still be available\n-            # since we've not yet cleared out the related field.\n-            # Use the cache directly, instead of the accessor; if we haven't\n-            # populated the cache, then we don't care - we're only accessing\n-            # the object to invalidate the accessor cache, so there's no\n-            # need to populate the cache just to expire it again.\n-            related = self.field.get_cached_value(instance, default=None)\n-\n-            # If we've got an old related object, we need to clear out its\n-            # cache. This cache also might not exist if the related object\n-            # hasn't been accessed yet.\n-            if related is not None:\n-                remote_field.set_cached_value(related, None)\n+    # Set the related instance cache used by __get__ to avoid an SQL query\n+    # when accessing the attribute we just set.\n+    self.field.set_cached_value(instance, value)\n \n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+    # If this is a one-to-one relation, set the reverse accessor cache on\n+    # the related object to the current instance to avoid an extra SQL\n+    # query if it's accessed later on.\n+    if value is not None and not remote_field.multiple:\n+        remote_field.set_cached_value(value, instance)\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key field if the related object has a valid primary key\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Defer the assignment by storing a reference to update later\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+                # If the related object's primary key is empty/None, defer the assignment\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Store the related object for deferred assignment\n+                    # We'll need to update the foreign key when the related object gets a valid PK\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        else:\n+            # Set the concrete foreign key values on the model instance.\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Check if the related object has a valid primary key value\n+                rh_value = getattr(value, rh_field.attname)\n+                if rh_value is not None and rh_value != '':\n+                    # Related object has a valid PK, set it immediately\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Related object doesn't have a valid PK yet, defer the assignment\n+                    # by storing a reference to update later\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+                    # Clear any existing foreign key value\n+                    setattr(instance, lh_field.attname, None)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n",
    "variant_5": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..0625b6ae6c 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,7 +255,151 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                # Get the related field value\n+                related_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents setting empty/None values that cause constraint violations\n+                if related_value is not None and related_value != '':\n+                    setattr(instance, lh_field.attname, related_value)\n+                else:\n+                    # If the related object doesn't have a valid PK yet, clear the FK field\n+                    # The FK will be set later when the related object gets a valid PK\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+            # additional logic since Django will handle this case correctly\n+            # by clearing the foreign key field.\n+            for lh_field, rh_field in self.field.related_fields:\n+                setattr(instance, lh_field.attname, None)\n+\n+        # Set the values of the related field.\n+        else:\n+            # Check if the related object has a valid primary key\n+            has_valid_pk = True\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                if rh_value is None or rh_value == '':\n+                    has_valid_pk = False\n+                    break\n+            \n+            if has_valid_pk:\n+                # Set foreign key fields immediately if related object has valid PK\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            else:\n+                # Defer foreign key field assignment - set up a callback to update\n+                # the foreign key fields when the related object gets a valid PK\n+                def update_fk_fields():\n+                    for lh_field, rh_field in self.field.related_fields:\n+                        rh_value = getattr(value, rh_field.attname)\n+                        if rh_value is not None and rh_value != '':\n+                            setattr(instance, lh_field.attname, rh_value)\n+                \n+                # Store the callback on the related object to be called when it's saved\n+                if not hasattr(value, '_pending_fk_updates'):\n+                    value._pending_fk_updates = []\n+                value._pending_fk_updates.append(update_fk_fields)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Get the primary key value from the related object\n+                pk_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # Empty string or None indicates the related object hasn't been saved yet\n+                if pk_value not in (None, ''):\n+                    setattr(instance, lh_field.attname, pk_value)\n+                else:\n+                    # Clear the foreign key field when related object has no valid PK\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+                \n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents setting empty string or None values that would be overwritten\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If the related object doesn't have a valid PK yet, we need to defer\n+                    # the foreign key assignment. We'll set up a callback to update it\n+                    # when the related object gets a primary key value.\n+                    def update_fk_callback():\n+                        current_related = self.field.get_cached_value(instance, default=None)\n+                        if current_related is value:  # Make sure it's still the same object\n+                            new_rh_value = getattr(value, rh_field.attname)\n+                            if new_rh_value is not None and new_rh_value != '':\n+                                setattr(instance, lh_field.attname, new_rh_value)\n+                    \n+                    # Store the callback on the related object so it can be called later\n+                    if not hasattr(value, '_pending_fk_updates'):\n+                        value._pending_fk_updates = []\n+                    value._pending_fk_updates.append(update_fk_callback)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+    def __set__(self, instance, value):\n+        # An object must be an instance of the related class.\n+        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n+            raise ValueError(\n+                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n+                    value,\n+                    instance._meta.object_name,\n+                    self.field.name,\n+                    self.field.remote_field.model._meta.object_name,\n+                )\n+            )\n+        elif value is not None:\n+            if instance._state.db is None:\n+                instance._state.db = router.db_for_write(instance.__class__, instance=instance)\n+            if value._state.db is None:\n+                value._state.db = router.db_for_write(value.__class__, instance=value)\n+            if not router.allow_relation(value, instance):\n+                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+\n+        remote_field = self.field.remote_field\n+        # If we're setting the value to None, clear the foreign key fields.\n+        if value is None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                setattr(instance, lh_field.attname, None)\n+        else:\n+            # Check if the related object has a valid primary key\n+            has_valid_pk = True\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_val = getattr(value, rh_field.attname)\n+                if pk_val is None or pk_val == '':\n+                    has_valid_pk = False\n+                    break\n+            \n+            if has_valid_pk:\n+                # Set foreign key fields immediately if related object has valid PK\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            else:\n+                # Defer foreign key assignment - store a reference to update later\n+                if not hasattr(instance, '_deferred_fk_assignments'):\n+                    instance._deferred_fk_assignments = {}\n+                instance._deferred_fk_assignments[self.field.name] = value\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n",
    "variant_6": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..a1d48de21b 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,7 +255,107 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                pk_val = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                if pk_val is not None and pk_val != '':\n+                    setattr(instance, lh_field.attname, pk_val)\n+                else:\n+                    # Clear the foreign key field and set up deferred assignment\n+                    setattr(instance, lh_field.attname, None)\n+                    # Store reference for deferred assignment when related object gets a valid PK\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+                setattr(instance, lh_field.attname, None)\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Get the related object's primary key value\n+                rh_value = getattr(value, rh_field.attname)\n+                \n+                # Only set the foreign key field if the related object has a valid primary key\n+                # For empty/default primary keys (empty string, None), defer the assignment\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Store a reference to update the foreign key later when the related object gets a valid pk\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # If the related object's PK is empty/None, defer assignment until later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Set up deferred assignment by storing the related object\n+                    # The foreign key will be set when the related object gets a valid PK\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+                    # Don't set the foreign key field yet, leave it as is\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+                # This prevents setting empty string/None values that cause data loss\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # For unsaved related objects, we need to defer the FK assignment\n+                    # Set up a callback to update the FK when the related object is saved\n+                    def update_fk_on_save(sender, instance_inner=instance, lh_field_inner=lh_field, value_inner=value, rh_field_inner=rh_field, **kwargs):\n+                        if hasattr(value_inner, rh_field_inner.attname):\n+                            rh_value_inner = getattr(value_inner, rh_field_inner.attname)\n+                            if rh_value_inner is not None and rh_value_inner != '':\n+                                setattr(instance_inner, lh_field_inner.attname, rh_value_inner)\n+                    \n+                    # Connect the signal to update FK when related object is saved\n+                    signals.post_save.connect(update_fk_on_save, sender=value.__class__, weak=False)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        else:\n+            # Set the concrete foreign key attribute on the model.\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # or if we're explicitly setting it to None/empty\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                elif not hasattr(value, '_state') or value._state.adding:\n+                    # For new unsaved objects, store a reference to update the FK later\n+                    if not hasattr(instance, '_pending_fk_updates'):\n+                        instance._pending_fk_updates = {}\n+                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n+                else:\n+                    setattr(instance, lh_field.attname, rh_value)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n",
    "variant_7": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..695e7e8d16 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,7 +255,129 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                # Get the related field value\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # For new objects with empty/None primary keys, defer the assignment\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Store a reference to update the foreign key later when the related object gets a primary key\n+                    if not hasattr(instance, '_deferred_fk_updates'):\n+                        instance._deferred_fk_updates = {}\n+                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+        # Set the values of the related field.\n+        else:\n+            # Check if the related object has a valid primary key\n+            has_valid_pk = True\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_value = getattr(value, rh_field.attname)\n+                if pk_value is None or pk_value == '':\n+                    has_valid_pk = False\n+                    break\n+            \n+            if has_valid_pk:\n+                # Related object has valid primary key, set foreign key fields immediately\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            else:\n+                # Related object doesn't have valid primary key, defer assignment\n+                # Clear existing foreign key values\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, None)\n+                \n+                # Mark instance as having deferred foreign key assignment\n+                if not hasattr(instance, '_deferred_fk_assignments'):\n+                    instance._deferred_fk_assignments = {}\n+                instance._deferred_fk_assignments[self.field.name] = value\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # Otherwise, defer the assignment to maintain object relationship\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field for now - it will be set when the\n+                    # related object gets a valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+                \n+                # Only set the foreign key if the related object has a valid primary key\n+                # For new objects with empty string or None primary keys, defer assignment\n+                if pk_value not in (None, ''):\n+                    setattr(instance, lh_field.attname, pk_value)\n+                else:\n+                    # Mark that we need to update this field when the related object gets a PK\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+    def __set__(self, instance, value):\n+        # An object must be an instance of the related class.\n+        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n+            raise ValueError(\n+                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n+                    value,\n+                    instance._meta.object_name,\n+                    self.field.name,\n+                    self.field.remote_field.model._meta.object_name,\n+                )\n+            )\n+        elif value is not None:\n+            if instance._state.db is None:\n+                instance._state.db = router.db_for_write(instance.__class__, instance=instance)\n+            if value._state.db is None:\n+                value._state.db = router.db_for_write(value.__class__, instance=value)\n+            if not router.allow_relation(value, instance):\n+                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+\n+        remote_field = self.field.remote_field\n+        # If we're setting the value to None, clear the cache and set the\n+        # fk to None.\n+        if value is None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                setattr(instance, lh_field.attname, None)\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Only set the foreign key field if the related object has a valid primary key\n+                rh_value = getattr(value, rh_field.attname)\n+                if rh_value is not None and rh_value != \"\":\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If related object doesn't have a valid PK yet, defer the assignment\n+                    # by storing a reference to update later\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n",
    "variant_8": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..f97d882330 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,7 +255,75 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set foreign key if the related object has a valid primary key\n+                # This prevents setting empty string or None as foreign key value\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Store a reference to update the foreign key later when the related object gets a valid pk\n+                    if not hasattr(instance, '_deferred_fk_updates'):\n+                        instance._deferred_fk_updates = {}\n+                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Get the primary key value from the related object\n+                pk_value = getattr(value, rh_field.attname)\n+                \n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents setting empty string/None values that would cause data loss\n+                if pk_value is not None and pk_value != '':\n+                    setattr(instance, lh_field.attname, pk_value)\n+                else:\n+                    # If the related object doesn't have a valid PK yet, we need to\n+                    # defer the foreign key assignment. For now, we'll set it to None\n+                    # to avoid constraint violations, and rely on save() logic to\n+                    # handle the relationship properly when the related object gets a PK\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Defer foreign key assignment until the related object gets a valid PK\n+                    # Store a reference to update the FK later\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = []\n+                    instance._deferred_fk_assignments.append((lh_field, value, rh_field))\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        else:\n+            # Set the concrete foreign key attribute on the model.\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Defer foreign key assignment - store the related object for later resolution\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n"
  }
}