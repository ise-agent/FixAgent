{
  "zero_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 727-732)": "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        else:\n            # Ensure xa can hold special index values (N, N+1, N+2)\n            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 673-675)": "\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 727-732)": [
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        else:\n            # Ensure xa can hold special index values (N, N+1, N+2)\n            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        else:\n            # Ensure xa can hold special index values (N, N+1, N+2)\n            if xa.dtype.itemsize < np.dtype(int).itemsize or xa.dtype.kind == 'u':\n                xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        else:\n            # Ensure xa can hold special index values (N, N+1, N+2)\n            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        else:\n            # Ensure xa can hold special index values (N, N+1, N+2)\n            if xa.dtype == np.uint8 or xa.dtype.itemsize < 4:\n                xa = xa.astype(np.intp)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        else:\n            # Ensure xa can hold special index values (self.N, self.N+1, self.N+2)\n            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        else:\n            # Ensure xa can hold special index values (self.N, self.N+1, self.N+2)\n            # before assigning them to avoid NumPy 1.24 deprecation warnings\n            xa = xa.astype(np.intp)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        else:\n            # Ensure xa can hold special index values (self.N, self.N+1, self.N+2)\n            # that may be larger than the original dtype can accommodate\n            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        else:\n            # Ensure xa can hold special index values (N, N+1, N+2)\n            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n"
    ],
    "Location 2 (/root/hy/projects_1/matplotlib/lib/matplotlib/colors.py lines 673-675)": [
      "\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n",
      "\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n",
      "\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n",
      "\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n",
      "\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n",
      "\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n",
      "\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n",
      "\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..53615dd71a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -670,6 +670,7 @@ class Colormap:\n         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n         self._rgba_under = None\n         self._rgba_over = None\n+\n         self._i_under = self.N\n         self._i_over = self.N + 1\n         self._i_bad = self.N + 2\n@@ -724,6 +725,12 @@ class Colormap:\n                 xa[xa == self.N] = self.N - 1\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n+\n+                xa = xa.astype(int)\n+        else:\n+            # For non-float dtypes, ensure xa can hold special index values\n+            # that may be larger than the original dtype's range (e.g., uint8)\n+            if xa.dtype.kind in 'ui' and xa.dtype.itemsize < np.dtype(int).itemsize:\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n",
    "variant_0": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..f2a4ca3e9a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -670,6 +670,7 @@ class Colormap:\n         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n         self._rgba_under = None\n         self._rgba_over = None\n+\n         self._i_under = self.N\n         self._i_over = self.N + 1\n         self._i_bad = self.N + 2\n@@ -724,6 +725,21 @@ class Colormap:\n                 xa[xa == self.N] = self.N - 1\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n+\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+                xa = xa.astype(int)\n+        else:\n+            # Ensure xa can hold special index values (N, N+1, N+2)\n+            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n",
    "variant_1": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..5a1721936d 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -667,6 +667,10 @@ class Colormap:\n         \"\"\"\n         self.name = name\n         self.N = int(N)  # ensure that N is always int\n+        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n+        self._rgba_under = None\n+        self._rgba_over = None\n+\n         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n         self._rgba_under = None\n         self._rgba_over = None\n@@ -724,6 +728,21 @@ class Colormap:\n                 xa[xa == self.N] = self.N - 1\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n+\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+                xa = xa.astype(int)\n+        else:\n+            # Ensure xa can hold special index values (N, N+1, N+2)\n+            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n",
    "variant_2": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..2d34df5b0f 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -670,6 +670,7 @@ class Colormap:\n         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n         self._rgba_under = None\n         self._rgba_over = None\n+\n         self._i_under = self.N\n         self._i_over = self.N + 1\n         self._i_bad = self.N + 2\n@@ -724,6 +725,21 @@ class Colormap:\n                 xa[xa == self.N] = self.N - 1\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n+\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+                xa = xa.astype(int)\n+        else:\n+            # Ensure xa can hold special index values (N, N+1, N+2)\n+            if xa.dtype.itemsize < np.dtype(int).itemsize or xa.dtype.kind == 'u':\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n",
    "variant_3": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..f2a4ca3e9a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -670,6 +670,7 @@ class Colormap:\n         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n         self._rgba_under = None\n         self._rgba_over = None\n+\n         self._i_under = self.N\n         self._i_over = self.N + 1\n         self._i_bad = self.N + 2\n@@ -724,6 +725,21 @@ class Colormap:\n                 xa[xa == self.N] = self.N - 1\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n+\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+                xa = xa.astype(int)\n+        else:\n+            # Ensure xa can hold special index values (N, N+1, N+2)\n+            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n",
    "variant_4": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..e6fe62b981 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -670,6 +670,7 @@ class Colormap:\n         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n         self._rgba_under = None\n         self._rgba_over = None\n+\n         self._i_under = self.N\n         self._i_over = self.N + 1\n         self._i_bad = self.N + 2\n@@ -714,6 +715,17 @@ class Colormap:\n             mask_bad = np.isnan(xa)\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+\n         if xa.dtype.kind == \"f\":\n             with np.errstate(invalid=\"ignore\"):\n                 xa *= self.N\n@@ -725,6 +737,10 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        else:\n+            # Ensure xa can hold special index values (N, N+1, N+2)\n+            if xa.dtype == np.uint8 or xa.dtype.itemsize < 4:\n+                xa = xa.astype(np.intp)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n",
    "variant_5": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..ab7e1e2527 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -670,6 +670,7 @@ class Colormap:\n         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n         self._rgba_under = None\n         self._rgba_over = None\n+\n         self._i_under = self.N\n         self._i_over = self.N + 1\n         self._i_bad = self.N + 2\n@@ -724,6 +725,21 @@ class Colormap:\n                 xa[xa == self.N] = self.N - 1\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n+\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+                xa = xa.astype(int)\n+        else:\n+            # Ensure xa can hold special index values (self.N, self.N+1, self.N+2)\n+            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n",
    "variant_6": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..d5250e5806 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -670,6 +670,7 @@ class Colormap:\n         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n         self._rgba_under = None\n         self._rgba_over = None\n+\n         self._i_under = self.N\n         self._i_over = self.N + 1\n         self._i_bad = self.N + 2\n@@ -714,6 +715,17 @@ class Colormap:\n             mask_bad = np.isnan(xa)\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+\n         if xa.dtype.kind == \"f\":\n             with np.errstate(invalid=\"ignore\"):\n                 xa *= self.N\n@@ -725,6 +737,10 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        else:\n+            # Ensure xa can hold special index values (self.N, self.N+1, self.N+2)\n+            # before assigning them to avoid NumPy 1.24 deprecation warnings\n+            xa = xa.astype(np.intp)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n",
    "variant_7": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..d1a12702d9 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -670,6 +670,7 @@ class Colormap:\n         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n         self._rgba_under = None\n         self._rgba_over = None\n+\n         self._i_under = self.N\n         self._i_over = self.N + 1\n         self._i_bad = self.N + 2\n@@ -724,6 +725,22 @@ class Colormap:\n                 xa[xa == self.N] = self.N - 1\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n+\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+                xa = xa.astype(int)\n+        else:\n+            # Ensure xa can hold special index values (self.N, self.N+1, self.N+2)\n+            # that may be larger than the original dtype can accommodate\n+            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n",
    "variant_8": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..f2a4ca3e9a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -670,6 +670,7 @@ class Colormap:\n         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n         self._rgba_under = None\n         self._rgba_over = None\n+\n         self._i_under = self.N\n         self._i_over = self.N + 1\n         self._i_bad = self.N + 2\n@@ -724,6 +725,21 @@ class Colormap:\n                 xa[xa == self.N] = self.N - 1\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n+\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+                xa = xa.astype(int)\n+        else:\n+            # Ensure xa can hold special index values (N, N+1, N+2)\n+            if xa.dtype.itemsize < np.dtype(int).itemsize:\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n"
  }
}