{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/related_descriptors.py lines 256-257)": "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                \n                # Check if we're dealing with an empty string for a field that doesn't allow them\n                if (pk_value == '' and hasattr(lh_field, 'empty_strings_allowed') and \n                    not lh_field.empty_strings_allowed):\n                    # Store a reference to the related object for lazy evaluation\n                    # We'll capture the actual PK value when it's needed (during save)\n                    setattr(instance, f'_deferred_{lh_field.attname}', value)\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, pk_value)\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/fields/related_descriptors.py lines 203-268)": "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                # Check if primary key is empty and field doesn't allow empty strings\n                if (pk_value == '' and hasattr(lh_field, 'empty_strings_allowed') and \n                    not lh_field.empty_strings_allowed):\n                    # Store a deferred reference to get the pk value later\n                    setattr(instance, lh_field.attname + '_deferred_obj', value)\n                    setattr(instance, lh_field.attname + '_deferred_attr', rh_field.attname)\n                    # Set to None for now to avoid empty string storage\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, pk_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/related_descriptors.py lines 75-79)": "\nclass ForeignKeyDeferredAttribute(DeferredAttribute):\n    def __set__(self, instance, value):\n        # Check if the value is an empty string and the field doesn't allow empty strings\n        if value == '' and hasattr(self.field, 'empty_strings_allowed') and not self.field.empty_strings_allowed:\n            value = None\n        \n        if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n            self.field.delete_cached_value(instance)\n        instance.__dict__[self.field.attname] = value\n",
    "Location 4 (/root/hy/projects_4/django/django/db/models/fields/related_descriptors.py lines 259-261)": "\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n        \n        # If the related object has an empty primary key, set up a callback\n        # to update the foreign key field when the primary key is set\n        if value is not None:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                if pk_value == '' and not rh_field.empty_strings_allowed:\n                    # Store reference to update foreign key when primary key is set\n                    if not hasattr(instance, '_pending_fk_updates'):\n                        instance._pending_fk_updates = {}\n                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n",
    "Location 5 (/root/hy/projects_4/django/django/db/models/fields/related.py lines 771-788)": "\nclass ForeignKey(ForeignObject):\n    \"\"\"\n    Provide a many-to-one relation by adding a column to the local model\n    to hold the remote value.\n\n    By default ForeignKey will target the pk of the remote model but this\n    behavior can be changed by using the ``to_field`` argument.\n    \"\"\"\n    descriptor_class = ForeignKeyDeferredAttribute\n    # Field flags\n    many_to_many = False\n    many_to_one = True\n    one_to_many = False\n    one_to_one = False\n\n    rel_class = ManyToOneRel\n\n    empty_strings_allowed = False\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/related_descriptors.py lines 256-257)": [
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                \n                # If the primary key is empty and not allowed, defer assignment\n                if (pk_value == '' and not lh_field.empty_strings_allowed) or pk_value is None:\n                    # Store a reference to the related object for lazy evaluation\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n                else:\n                    setattr(instance, lh_field.attname, pk_value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the foreign key value from the related object\n                fk_value = getattr(value, rh_field.attname)\n                \n                # If the foreign key value is an empty string and the field doesn't allow empty strings,\n                # defer the assignment by storing a reference to the related object instead\n                if (fk_value == '' and hasattr(lh_field, 'empty_strings_allowed') and \n                    not lh_field.empty_strings_allowed):\n                    # Store a deferred assignment marker that will be resolved later\n                    setattr(instance, f'_{lh_field.attname}_deferred_object', value)\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, fk_value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                \n                # Check if the primary key is empty and shouldn't be allowed\n                if (pk_value == '' and hasattr(lh_field, 'empty_strings_allowed') \n                    and not lh_field.empty_strings_allowed):\n                    # Store a reference to the related object for lazy evaluation\n                    # The actual foreign key value will be captured during save\n                    setattr(instance, f'_deferred_{lh_field.attname}_object', value)\n                    # Set foreign key to None temporarily to avoid storing empty string\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, pk_value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                \n                # If the primary key is empty and empty strings are not allowed,\n                # defer the assignment by storing a reference to the related object\n                if (pk_value == '' and not getattr(lh_field, 'empty_strings_allowed', True)) or pk_value is None:\n                    # Store a deferred assignment marker that will be resolved later\n                    setattr(instance, f'_deferred_{lh_field.attname}', value)\n                    # Set the foreign key field to None for now\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    # Normal assignment when primary key has a valid value\n                    setattr(instance, lh_field.attname, pk_value)\n                    # Clear any deferred assignment marker\n                    if hasattr(instance, f'_deferred_{lh_field.attname}'):\n                        delattr(instance, f'_deferred_{lh_field.attname}')\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Check if we're trying to assign an empty string to a field that doesn't allow it\n                if (rh_value == '' and hasattr(lh_field, 'empty_strings_allowed') and \n                    not lh_field.empty_strings_allowed):\n                    # Store a reference to the related object for lazy evaluation\n                    setattr(instance, '_deferred_fk_' + lh_field.attname, value)\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, rh_value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                \n                # If the primary key is empty and the field doesn't allow empty strings,\n                # defer the assignment by storing a reference to track the related object\n                if (pk_value == '' and hasattr(lh_field, 'empty_strings_allowed') and \n                    not lh_field.empty_strings_allowed):\n                    # Store a deferred assignment marker that will be resolved later\n                    setattr(instance, f'_deferred_fk_{lh_field.attname}', value)\n                else:\n                    setattr(instance, lh_field.attname, pk_value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                \n                # Check if we're dealing with an empty primary key that might be set later\n                if (pk_value == '' and not lh_field.empty_strings_allowed) or pk_value is None:\n                    # Store a reference to the related object for lazy evaluation\n                    # This allows the primary key to be captured when the object is saved\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n                    # Set current value as placeholder\n                    setattr(instance, lh_field.attname, pk_value)\n                else:\n                    # Primary key is valid, set it normally\n                    setattr(instance, lh_field.attname, pk_value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the related field value\n                rh_value = getattr(value, rh_field.attname)\n                \n                # Check if the related field has empty_strings_allowed = False\n                # and the value is an empty string\n                if (hasattr(rh_field, 'empty_strings_allowed') and \n                    not rh_field.empty_strings_allowed and \n                    rh_value == ''):\n                    # Store a reference to the related object instead of the empty value\n                    # This will be resolved later when the foreign key is actually needed\n                    setattr(instance, lh_field.attname + '_deferred_object', value)\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, rh_value)\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/fields/related_descriptors.py lines 203-268)": [
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the foreign key value from the related object\n                fk_value = getattr(value, rh_field.attname)\n                \n                # Check if the foreign key value is empty and shouldn't be allowed\n                if (fk_value == '' and not getattr(lh_field, 'empty_strings_allowed', True)):\n                    # Store a reference to the related object instead of the empty value\n                    # This allows lazy evaluation of the foreign key when needed\n                    setattr(instance, '_deferred_fk_' + lh_field.attname, value)\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, fk_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Don't set empty string values for foreign keys that don't allow them\n                if (rh_value == '' and hasattr(lh_field, 'empty_strings_allowed') and \n                    not lh_field.empty_strings_allowed):\n                    # Store a reference to the related object for lazy evaluation\n                    if not hasattr(instance, '_deferred_fk_updates'):\n                        instance._deferred_fk_updates = {}\n                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n                else:\n                    setattr(instance, lh_field.attname, rh_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                # Don't set empty string values for foreign keys that don't allow them\n                if (pk_value == '' and \n                    hasattr(lh_field, 'empty_strings_allowed') and \n                    not lh_field.empty_strings_allowed):\n                    # Store a reference to the related object for lazy evaluation\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = value\n                else:\n                    setattr(instance, lh_field.attname, pk_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\ndef __set__(self, instance, value):\n    \"\"\"\n    Set the related instance through the forward relation.\n\n    With the example above, when setting ``child.parent = parent``:\n\n    - ``self`` is the descriptor managing the ``parent`` attribute\n    - ``instance`` is the ``child`` instance\n    - ``value`` is the ``parent`` instance on the right of the equal sign\n    \"\"\"\n    # An object must be an instance of the related class.\n    if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n        raise ValueError(\n            'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                value,\n                instance._meta.object_name,\n                self.field.name,\n                self.field.remote_field.model._meta.object_name,\n            )\n        )\n    elif value is not None:\n        if instance._state.db is None:\n            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n        if value._state.db is None:\n            value._state.db = router.db_for_write(value.__class__, instance=instance)\n        if not router.allow_relation(value, instance):\n            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n    remote_field = self.field.remote_field\n    # If we're setting the value of a OneToOneField to None, we need to clear\n    # out the cache on any old related object. Otherwise, deleting the\n    # previously-related object will also cause this object to be deleted,\n    # which is wrong.\n    if value is None:\n        # Look up the previously-related object, which may still be available\n        # since we've not yet cleared out the related field.\n        # Use the cache directly, instead of the accessor; if we haven't\n        # populated the cache, then we don't care - we're only accessing\n        # the object to invalidate the accessor cache, so there's no\n        # need to populate the cache just to expire it again.\n        related = self.field.get_cached_value(instance, default=None)\n\n        # If we've got an old related object, we need to clear out its\n        # cache. This cache also might not exist if the related object\n        # hasn't been accessed yet.\n        if related is not None:\n            remote_field.set_cached_value(related, None)\n\n        for lh_field, rh_field in self.field.related_fields:\n            setattr(instance, lh_field.attname, None)\n\n    # Set the values of the related field.\n    else:\n        for lh_field, rh_field in self.field.related_fields:\n            pk_value = getattr(value, rh_field.attname)\n            # Only set the foreign key value if it's not empty or if empty strings are allowed\n            if pk_value or pk_value == 0 or lh_field.empty_strings_allowed:\n                setattr(instance, lh_field.attname, pk_value)\n            else:\n                # For non-empty-string fields with empty values, store a reference\n                # to the related object so we can get the PK value later\n                if not hasattr(instance, '_deferred_fk_updates'):\n                    instance._deferred_fk_updates = {}\n                instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n\n    # Set the related instance cache used by __get__ to avoid an SQL query\n    # when accessing the attribute we just set.\n    self.field.set_cached_value(instance, value)\n\n    # If this is a one-to-one relation, set the reverse accessor cache on\n    # the related object to the current instance to avoid an extra SQL\n    # query if it's accessed later on.\n    if value is not None and not remote_field.multiple:\n        remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                # Don't set empty string values for foreign keys that don't allow them\n                if pk_value == '' and not lh_field.empty_strings_allowed:\n                    # Store a reference to the related object for lazy evaluation\n                    if not hasattr(instance, '_pending_fk_updates'):\n                        instance._pending_fk_updates = {}\n                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n                else:\n                    setattr(instance, lh_field.attname, pk_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\ndef __set__(self, instance, value):\n    \"\"\"\n    Set the related instance through the forward relation.\n\n    With the example above, when setting ``child.parent = parent``:\n\n    - ``self`` is the descriptor managing the ``parent`` attribute\n    - ``instance`` is the ``child`` instance\n    - ``value`` is the ``parent`` instance on the right of the equal sign\n    \"\"\"\n    # An object must be an instance of the related class.\n    if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n        raise ValueError(\n            'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                value,\n                instance._meta.object_name,\n                self.field.name,\n                self.field.remote_field.model._meta.object_name,\n            )\n        )\n    elif value is not None:\n        if instance._state.db is None:\n            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n        if value._state.db is None:\n            value._state.db = router.db_for_write(value.__class__, instance=instance)\n        if not router.allow_relation(value, instance):\n            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n    remote_field = self.field.remote_field\n    # If we're setting the value of a OneToOneField to None, we need to clear\n    # out the cache on any old related object. Otherwise, deleting the\n    # previously-related object will also cause this object to be deleted,\n    # which is wrong.\n    if value is None:\n        # Look up the previously-related object, which may still be available\n        # since we've not yet cleared out the related field.\n        # Use the cache directly, instead of the accessor; if we haven't\n        # populated the cache, then we don't care - we're only accessing\n        # the object to invalidate the accessor cache, so there's no\n        # need to populate the cache just to expire it again.\n        related = self.field.get_cached_value(instance, default=None)\n\n        # If we've got an old related object, we need to clear out its\n        # cache. This cache also might not exist if the related object\n        # hasn't been accessed yet.\n        if related is not None:\n            remote_field.set_cached_value(related, None)\n\n        for lh_field, rh_field in self.field.related_fields:\n            setattr(instance, lh_field.attname, None)\n\n    # Set the values of the related field.\n    else:\n        for lh_field, rh_field in self.field.related_fields:\n            rh_value = getattr(value, rh_field.attname)\n            # Don't set empty string values for fields that don't allow them\n            if rh_value == '' and not lh_field.empty_strings_allowed:\n                # Store a reference to the related object for lazy evaluation\n                setattr(instance, '_lazy_' + lh_field.attname, value)\n                setattr(instance, lh_field.attname, None)\n            else:\n                setattr(instance, lh_field.attname, rh_value)\n                # Clear any lazy reference since we have a valid value\n                if hasattr(instance, '_lazy_' + lh_field.attname):\n                    delattr(instance, '_lazy_' + lh_field.attname)\n\n    # Set the related instance cache used by __get__ to avoid an SQL query\n    # when accessing the attribute we just set.\n    self.field.set_cached_value(instance, value)\n\n    # If this is a one-to-one relation, set the reverse accessor cache on\n    # the related object to the current instance to avoid an extra SQL\n    # query if it's accessed later on.\n    if value is not None and not remote_field.multiple:\n        remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Check if the primary key is empty and field doesn't allow empty strings\n                if (rh_value == '' and hasattr(lh_field, 'empty_strings_allowed') and \n                    not lh_field.empty_strings_allowed):\n                    # Store a reference to the related object for lazy evaluation\n                    setattr(instance, '_' + lh_field.attname + '_deferred_obj', value)\n                    # Set the field to None temporarily\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, rh_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n        elif value is not None:\n            if instance._state.db is None:\n                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n            if value._state.db is None:\n                value._state.db = router.db_for_write(value.__class__, instance=instance)\n            if not router.allow_relation(value, instance):\n                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n\n        remote_field = self.field.remote_field\n        # If we're setting the value of a OneToOneField to None, we need to clear\n        # out the cache on any old related object. Otherwise, deleting the\n        # previously-related object will also cause this object to be deleted,\n        # which is wrong.\n        if value is None:\n            # Look up the previously-related object, which may still be available\n            # since we've not yet cleared out the related field.\n            # Use the cache directly, instead of the accessor; if we haven't\n            # populated the cache, then we don't care - we're only accessing\n            # the object to invalidate the accessor cache, so there's no\n            # need to populate the cache just to expire it again.\n            related = self.field.get_cached_value(instance, default=None)\n\n            # If we've got an old related object, we need to clear out its\n            # cache. This cache also might not exist if the related object\n            # hasn't been accessed yet.\n            if related is not None:\n                remote_field.set_cached_value(related, None)\n\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                # Check if the primary key is empty and field doesn't allow empty strings\n                if (pk_value == '' and hasattr(lh_field, 'empty_strings_allowed') \n                    and not lh_field.empty_strings_allowed):\n                    # Store a reference to update the FK later when PK becomes available\n                    if not hasattr(instance, '_pending_fk_updates'):\n                        instance._pending_fk_updates = {}\n                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n                    # Set to None for now to avoid storing empty string\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, pk_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/related_descriptors.py lines 75-79)": [
      "\nclass ForeignKeyDeferredAttribute(DeferredAttribute):\n    def __set__(self, instance, value):\n        # Check if the value is an empty string and field doesn't allow empty strings\n        if value == '' and hasattr(self.field, 'empty_strings_allowed') and not self.field.empty_strings_allowed:\n            value = None\n        \n        if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n            self.field.delete_cached_value(instance)\n        instance.__dict__[self.field.attname] = value\n",
      "\nclass ForeignKeyDeferredAttribute(DeferredAttribute):\n    def __set__(self, instance, value):\n        # Check if the field doesn't allow empty strings and value is an empty string\n        if not self.field.empty_strings_allowed and value == '':\n            raise ValueError(f\"Field '{self.field.name}' cannot be an empty string\")\n        \n        if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n            self.field.delete_cached_value(instance)\n        instance.__dict__[self.field.attname] = value\n",
      "\nclass ForeignKeyDeferredAttribute(DeferredAttribute):\n    def __set__(self, instance, value):\n        # Check if the value is an empty string and the field doesn't allow empty strings\n        if value == '' and hasattr(self.field, 'empty_strings_allowed') and not self.field.empty_strings_allowed:\n            value = None\n        \n        if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n            self.field.delete_cached_value(instance)\n        instance.__dict__[self.field.attname] = value\n",
      "\nclass ForeignKeyDeferredAttribute(DeferredAttribute):\n    def __set__(self, instance, value):\n        # Check if the value is an empty string and field doesn't allow empty strings\n        if (value == '' and hasattr(self.field, 'empty_strings_allowed') and \n            not self.field.empty_strings_allowed):\n            value = None\n            \n        if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n            self.field.delete_cached_value(instance)\n        instance.__dict__[self.field.attname] = value\n",
      "\nclass ForeignKeyDeferredAttribute(DeferredAttribute):\n    def __set__(self, instance, value):\n        # Check if the field doesn't allow empty strings and value is empty string\n        if (hasattr(self.field, 'empty_strings_allowed') and \n            not self.field.empty_strings_allowed and value == ''):\n            # Don't store empty string, let it remain None/unset\n            if self.field.is_cached(instance):\n                self.field.delete_cached_value(instance)\n            return\n            \n        if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n            self.field.delete_cached_value(instance)\n        instance.__dict__[self.field.attname] = value\n",
      "\nclass ForeignKeyDeferredAttribute(DeferredAttribute):\n    def __set__(self, instance, value):\n        # Check if the value is an empty string and the field doesn't allow empty strings\n        if (value == '' and hasattr(self.field, 'empty_strings_allowed') and \n            not self.field.empty_strings_allowed):\n            value = None\n            \n        if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n            self.field.delete_cached_value(instance)\n        instance.__dict__[self.field.attname] = value\n",
      "\nclass ForeignKeyDeferredAttribute(DeferredAttribute):\n    def __set__(self, instance, value):\n        # Check if the value is an empty string and the field doesn't allow empty strings\n        if value == '' and not getattr(self.field, 'empty_strings_allowed', True):\n            # Convert empty string to None for fields that don't allow empty strings\n            value = None\n        \n        if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n            self.field.delete_cached_value(instance)\n        instance.__dict__[self.field.attname] = value\n",
      "\nclass ForeignKeyDeferredAttribute(DeferredAttribute):\n    def __set__(self, instance, value):\n        # Check if the field doesn't allow empty strings and value is an empty string\n        if not getattr(self.field, 'empty_strings_allowed', True) and value == '':\n            raise ValueError(f\"Empty string not allowed for field '{self.field.name}'\")\n        \n        if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n            self.field.delete_cached_value(instance)\n        instance.__dict__[self.field.attname] = value\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/db/models/fields/related_descriptors.py lines 259-261)": [
      "\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n        \n        # If the related object's primary key is empty and we just set foreign key values,\n        # establish a callback to update the foreign key when the primary key is set\n        if value is not None and hasattr(value, '_state') and not value._state.adding:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                if pk_value == '' and not rh_field.empty_strings_allowed:\n                    # Store reference to update foreign key when primary key is set\n                    if not hasattr(instance, '_deferred_fk_updates'):\n                        instance._deferred_fk_updates = {}\n                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n",
      "\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n        \n        # If the related object's primary key is empty and we just assigned it,\n        # we need to ensure the foreign key field gets updated when the PK is set\n        if value is not None:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                # If primary key is empty, set up a callback to update foreign key\n                # when the primary key is assigned\n                if not pk_value or (isinstance(pk_value, str) and pk_value == ''):\n                    # Store reference to instance and field for later update\n                    if not hasattr(value, '_pending_fk_updates'):\n                        value._pending_fk_updates = []\n                    value._pending_fk_updates.append((instance, lh_field))\n",
      "\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n        \n        # If the related object's primary key is empty and might be set later,\n        # establish a callback to update the foreign key field when it changes\n        if value is not None:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                if pk_value == '' and not rh_field.empty_strings_allowed:\n                    # Store a reference to update the FK when the PK is set\n                    if not hasattr(instance, '_pending_fk_updates'):\n                        instance._pending_fk_updates = {}\n                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n",
      "\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n        \n        # If the related object's primary key changes later, we need to update\n        # the foreign key field to maintain consistency\n        if value is not None and hasattr(value, '_state') and not value._state.adding:\n            # For existing objects, check if we need to update the FK field\n            for lh_field, rh_field in self.field.related_fields:\n                current_fk_value = getattr(instance, lh_field.attname)\n                actual_pk_value = getattr(value, rh_field.attname)\n                if current_fk_value != actual_pk_value and actual_pk_value:\n                    setattr(instance, lh_field.attname, actual_pk_value)\n",
      "\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n        \n        # If the related object's primary key is empty and might change later,\n        # set up a callback to update the foreign key field when it does\n        if value is not None:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                if pk_value == '' and not rh_field.empty_strings_allowed:\n                    # Store a reference to update the FK when the PK is set\n                    def update_fk_callback(sender, instance=value, **kwargs):\n                        for lh_f, rh_f in self.field.related_fields:\n                            new_pk = getattr(instance, rh_f.attname)\n                            if new_pk != '':\n                                setattr(instance._state.fields_cache.get(self.field.name + '_instance', instance), lh_f.attname, new_pk)\n                    \n                    # Connect to the related object's save signal to update FK\n                    if not hasattr(value, '_fk_update_callbacks'):\n                        value._fk_update_callbacks = []\n                    value._fk_update_callbacks.append((instance, self.field, update_fk_callback))\n",
      "\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n        \n        # If the related object's primary key is None or empty string, establish\n        # a deferred update mechanism to capture the PK value when it's set\n        if value is not None:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                if pk_value == '' and not rh_field.empty_strings_allowed:\n                    # Store a reference to update the FK when the related object's PK is set\n                    if not hasattr(instance, '_deferred_fk_updates'):\n                        instance._deferred_fk_updates = {}\n                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n",
      "\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n        \n        # If the related object's primary key might change later, set up a callback\n        # to update the foreign key field when that happens\n        if value is not None and hasattr(value, '_state') and value._state.adding:\n            # Store a reference to update the foreign key when the related object is saved\n            original_save = getattr(value, 'save', None)\n            if original_save:\n                def patched_save(*args, **kwargs):\n                    result = original_save(*args, **kwargs)\n                    # Update foreign key fields after the related object is saved\n                    for lh_field, rh_field in self.field.related_fields:\n                        current_fk_value = getattr(instance, lh_field.attname)\n                        new_fk_value = getattr(value, rh_field.attname)\n                        # Only update if the foreign key value has changed and is not empty\n                        if current_fk_value != new_fk_value and new_fk_value:\n                            setattr(instance, lh_field.attname, new_fk_value)\n                    return result\n                value.save = patched_save\n",
      "\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n        \n        # If the related object has an empty primary key, establish a callback\n        # to update the foreign key field when the primary key is set\n        if value is not None:\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                if pk_value == '' and not rh_field.empty_strings_allowed:\n                    # Store a reference to update the foreign key when pk is set\n                    def update_fk_on_pk_change(sender, instance_pk, **kwargs):\n                        if hasattr(instance_pk, rh_field.attname):\n                            new_pk_value = getattr(instance_pk, rh_field.attname)\n                            if new_pk_value != '':\n                                setattr(instance, lh_field.attname, new_pk_value)\n                    \n                    # Connect to the related object's attribute change\n                    if not hasattr(value, '_fk_update_callbacks'):\n                        value._fk_update_callbacks = []\n                    value._fk_update_callbacks.append((instance, lh_field, update_fk_on_pk_change))\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/db/models/fields/related.py lines 771-788)": [
      "\nclass ForeignKey(ForeignObject):\n    \"\"\"\n    Provide a many-to-one relation by adding a column to the local model\n    to hold the remote value.\n\n    By default ForeignKey will target the pk of the remote model but this\n    behavior can be changed by using the ``to_field`` argument.\n    \"\"\"\n    descriptor_class = ForeignKeyDeferredAttribute\n    # Field flags\n    many_to_many = False\n    many_to_one = True\n    one_to_many = False\n    one_to_one = False\n\n    rel_class = ManyToOneRel\n\n    empty_strings_allowed = False\n",
      "\nclass ForeignKey(ForeignObject):\n    \"\"\"\n    Provide a many-to-one relation by adding a column to the local model\n    to hold the remote value.\n\n    By default ForeignKey will target the pk of the remote model but this\n    behavior can be changed by using the ``to_field`` argument.\n    \"\"\"\n    descriptor_class = ForeignKeyDeferredAttribute\n    # Field flags\n    many_to_many = False\n    many_to_one = True\n    one_to_many = False\n    one_to_one = False\n\n    rel_class = ManyToOneRel\n\n    empty_strings_allowed = False\n    \n    def validate_foreign_key_value(self, value):\n        \"\"\"Validate foreign key value, preventing empty strings when not allowed.\"\"\"\n        if not self.empty_strings_allowed and value == '':\n            return None\n        return value\n",
      "\nclass ForeignKey(ForeignObject):\n    \"\"\"\n    Provide a many-to-one relation by adding a column to the local model\n    to hold the remote value.\n\n    By default ForeignKey will target the pk of the remote model but this\n    behavior can be changed by using the ``to_field`` argument.\n    \"\"\"\n    descriptor_class = ForeignKeyDeferredAttribute\n    # Field flags\n    many_to_many = False\n    many_to_one = True\n    one_to_many = False\n    one_to_one = False\n\n    rel_class = ManyToOneRel\n\n    empty_strings_allowed = False\n    \n    def validate_foreign_key_value(self, value):\n        \"\"\"Validate foreign key value, preventing empty strings when not allowed.\"\"\"\n        if not self.empty_strings_allowed and value == '':\n            raise ValueError(\n                f\"Empty string not allowed for foreign key field {self.name}. \"\n                f\"The related object's primary key must be set before assignment.\"\n            )\n        return value\n",
      "\nclass ForeignKey(ForeignObject):\n    \"\"\"\n    Provide a many-to-one relation by adding a column to the local model\n    to hold the remote value.\n\n    By default ForeignKey will target the pk of the remote model but this\n    behavior can be changed by using the ``to_field`` argument.\n    \"\"\"\n    descriptor_class = ForeignKeyDeferredAttribute\n    # Field flags\n    many_to_many = False\n    many_to_one = True\n    one_to_many = False\n    one_to_one = False\n\n    rel_class = ManyToOneRel\n\n    empty_strings_allowed = False\n",
      "\nclass ForeignKey(ForeignObject):\n    \"\"\"\n    Provide a many-to-one relation by adding a column to the local model\n    to hold the remote value.\n\n    By default ForeignKey will target the pk of the remote model but this\n    behavior can be changed by using the ``to_field`` argument.\n    \"\"\"\n    descriptor_class = ForeignKeyDeferredAttribute\n    # Field flags\n    many_to_many = False\n    many_to_one = True\n    one_to_many = False\n    one_to_one = False\n\n    rel_class = ManyToOneRel\n\n    empty_strings_allowed = False\n",
      "\nclass ForeignKey(ForeignObject):\n    \"\"\"\n    Provide a many-to-one relation by adding a column to the local model\n    to hold the remote value.\n\n    By default ForeignKey will target the pk of the remote model but this\n    behavior can be changed by using the ``to_field`` argument.\n    \"\"\"\n    descriptor_class = ForeignKeyDeferredAttribute\n    # Field flags\n    many_to_many = False\n    many_to_one = True\n    one_to_many = False\n    one_to_one = False\n\n    rel_class = ManyToOneRel\n\n    empty_strings_allowed = False\n    \n    def validate_fk_value(self, value, obj=None):\n        \"\"\"Validate foreign key value, preventing empty strings when not allowed.\"\"\"\n        if not self.empty_strings_allowed and value == '':\n            if obj and hasattr(obj, '_meta'):\n                model_name = obj._meta.verbose_name\n            else:\n                model_name = 'model'\n            raise ValueError(\n                f\"Cannot assign empty string to ForeignKey field '{self.name}' \"\n                f\"on {model_name}. Use None instead or set empty_strings_allowed=True.\"\n            )\n        return value\n",
      "\nclass ForeignKey(ForeignObject):\n    \"\"\"\n    Provide a many-to-one relation by adding a column to the local model\n    to hold the remote value.\n\n    By default ForeignKey will target the pk of the remote model but this\n    behavior can be changed by using the ``to_field`` argument.\n    \"\"\"\n    descriptor_class = ForeignKeyDeferredAttribute\n    # Field flags\n    many_to_many = False\n    many_to_one = True\n    one_to_many = False\n    one_to_one = False\n\n    rel_class = ManyToOneRel\n\n    empty_strings_allowed = False\n",
      "\nclass ForeignKey(ForeignObject):\n    \"\"\"\n    Provide a many-to-one relation by adding a column to the local model\n    to hold the remote value.\n\n    By default ForeignKey will target the pk of the remote model but this\n    behavior can be changed by using the ``to_field`` argument.\n    \"\"\"\n    descriptor_class = ForeignKeyDeferredAttribute\n    # Field flags\n    many_to_many = False\n    many_to_one = True\n    one_to_many = False\n    one_to_one = False\n\n    rel_class = ManyToOneRel\n\n    empty_strings_allowed = False\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..88dbb2a831 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -768,6 +768,7 @@ ForeignObject.register_lookup(RelatedLessThanOrEqual)\n ForeignObject.register_lookup(RelatedIsNull)\n \n \n+\n class ForeignKey(ForeignObject):\n     \"\"\"\n     Provide a many-to-one relation by adding a column to the local model\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..9bf8fecaa4 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,8 +72,13 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n+        # Validate that we're not storing empty strings when not allowed\n+        if (value == '' and hasattr(self.field, 'empty_strings_allowed') and \n+            not self.field.empty_strings_allowed):\n+            value = None\n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n             self.field.delete_cached_value(instance)\n         instance.__dict__[self.field.attname] = value\n@@ -200,6 +205,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,8 +260,25 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                # Get the primary key value from the related object\n+                pk_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the primary key is not empty/None\n+                # This prevents storing empty strings for CharField primary keys\n+                if pk_value or (pk_value is not None and not isinstance(rh_field, type(rh_field)) or not getattr(rh_field, 'empty_strings_allowed', True)):\n+                    setattr(instance, lh_field.attname, pk_value)\n+                else:\n+                    # Store None instead of empty string to defer FK resolution\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n \n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n",
    "variant_0": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..88dbb2a831 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -768,6 +768,7 @@ ForeignObject.register_lookup(RelatedLessThanOrEqual)\n ForeignObject.register_lookup(RelatedIsNull)\n \n \n+\n class ForeignKey(ForeignObject):\n     \"\"\"\n     Provide a many-to-one relation by adding a column to the local model\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..4d2a483a4a 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,8 +72,13 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n+        # Check if the value is an empty string and the field doesn't allow empty strings\n+        if value == '' and hasattr(self.field, 'empty_strings_allowed') and not self.field.empty_strings_allowed:\n+            value = None\n+        \n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n             self.field.delete_cached_value(instance)\n         instance.__dict__[self.field.attname] = value\n@@ -200,6 +205,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,11 +260,46 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                pk_value = getattr(value, rh_field.attname)\n+                # Check if primary key is empty and field doesn't allow empty strings\n+                if (pk_value == '' and hasattr(lh_field, 'empty_strings_allowed') and \n+                    not lh_field.empty_strings_allowed):\n+                    # Store a deferred reference to get the pk value later\n+                    setattr(instance, lh_field.attname + '_deferred_obj', value)\n+                    setattr(instance, lh_field.attname + '_deferred_attr', rh_field.attname)\n+                    # Set to None for now to avoid empty string storage\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    setattr(instance, lh_field.attname, pk_value)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    setattr(instance, lh_field.attname, pk_value)\n+\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n+        \n+        # If the related object has an empty primary key, set up a callback\n+        # to update the foreign key field when the primary key is set\n+        if value is not None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_value = getattr(value, rh_field.attname)\n+                if pk_value == '' and not rh_field.empty_strings_allowed:\n+                    # Store reference to update foreign key when primary key is set\n+                    if not hasattr(instance, '_pending_fk_updates'):\n+                        instance._pending_fk_updates = {}\n+                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n \n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n",
    "variant_1": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..88dbb2a831 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -768,6 +768,7 @@ ForeignObject.register_lookup(RelatedLessThanOrEqual)\n ForeignObject.register_lookup(RelatedIsNull)\n \n \n+\n class ForeignKey(ForeignObject):\n     \"\"\"\n     Provide a many-to-one relation by adding a column to the local model\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..c28038980e 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,8 +72,13 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n+        # Check if the value is an empty string and field doesn't allow empty strings\n+        if value == '' and hasattr(self.field, 'empty_strings_allowed') and not self.field.empty_strings_allowed:\n+            value = None\n+        \n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n             self.field.delete_cached_value(instance)\n         instance.__dict__[self.field.attname] = value\n@@ -200,6 +205,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,11 +260,45 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                # Get the foreign key value from the related object\n+                fk_value = getattr(value, rh_field.attname)\n+                \n+                # Check if the foreign key value is empty and shouldn't be allowed\n+                if (fk_value == '' and not getattr(lh_field, 'empty_strings_allowed', True)):\n+                    # Store a reference to the related object instead of the empty value\n+                    # This allows lazy evaluation of the foreign key when needed\n+                    setattr(instance, '_deferred_fk_' + lh_field.attname, value)\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    setattr(instance, lh_field.attname, fk_value)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+                else:\n+                    setattr(instance, lh_field.attname, pk_value)\n+\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n+        \n+        # If the related object's primary key is empty and we just set foreign key values,\n+        # establish a callback to update the foreign key when the primary key is set\n+        if value is not None and hasattr(value, '_state') and not value._state.adding:\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_value = getattr(value, rh_field.attname)\n+                if pk_value == '' and not rh_field.empty_strings_allowed:\n+                    # Store reference to update foreign key when primary key is set\n+                    if not hasattr(instance, '_deferred_fk_updates'):\n+                        instance._deferred_fk_updates = {}\n+                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n \n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n",
    "variant_2": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..097a75bae3 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -768,6 +768,7 @@ ForeignObject.register_lookup(RelatedLessThanOrEqual)\n ForeignObject.register_lookup(RelatedIsNull)\n \n \n+\n class ForeignKey(ForeignObject):\n     \"\"\"\n     Provide a many-to-one relation by adding a column to the local model\n@@ -786,6 +787,12 @@ class ForeignKey(ForeignObject):\n     rel_class = ManyToOneRel\n \n     empty_strings_allowed = False\n+    \n+    def validate_foreign_key_value(self, value):\n+        \"\"\"Validate foreign key value, preventing empty strings when not allowed.\"\"\"\n+        if not self.empty_strings_allowed and value == '':\n+            return None\n+        return value\n     default_error_messages = {\n         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')\n     }\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..f9589c6cd7 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,8 +72,13 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n+        # Check if the field doesn't allow empty strings and value is an empty string\n+        if not self.field.empty_strings_allowed and value == '':\n+            raise ValueError(f\"Field '{self.field.name}' cannot be an empty string\")\n+        \n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n             self.field.delete_cached_value(instance)\n         instance.__dict__[self.field.attname] = value\n@@ -200,6 +205,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,11 +260,47 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Don't set empty string values for foreign keys that don't allow them\n+                if (rh_value == '' and hasattr(lh_field, 'empty_strings_allowed') and \n+                    not lh_field.empty_strings_allowed):\n+                    # Store a reference to the related object for lazy evaluation\n+                    if not hasattr(instance, '_deferred_fk_updates'):\n+                        instance._deferred_fk_updates = {}\n+                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n+                else:\n+                    setattr(instance, lh_field.attname, rh_value)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    setattr(instance, lh_field.attname, fk_value)\n+\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n+        \n+        # If the related object's primary key is empty and we just assigned it,\n+        # we need to ensure the foreign key field gets updated when the PK is set\n+        if value is not None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_value = getattr(value, rh_field.attname)\n+                # If primary key is empty, set up a callback to update foreign key\n+                # when the primary key is assigned\n+                if not pk_value or (isinstance(pk_value, str) and pk_value == ''):\n+                    # Store reference to instance and field for later update\n+                    if not hasattr(value, '_pending_fk_updates'):\n+                        value._pending_fk_updates = []\n+                    value._pending_fk_updates.append((instance, lh_field))\n \n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n",
    "variant_3": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..35758a4fba 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -768,6 +768,7 @@ ForeignObject.register_lookup(RelatedLessThanOrEqual)\n ForeignObject.register_lookup(RelatedIsNull)\n \n \n+\n class ForeignKey(ForeignObject):\n     \"\"\"\n     Provide a many-to-one relation by adding a column to the local model\n@@ -786,6 +787,15 @@ class ForeignKey(ForeignObject):\n     rel_class = ManyToOneRel\n \n     empty_strings_allowed = False\n+    \n+    def validate_foreign_key_value(self, value):\n+        \"\"\"Validate foreign key value, preventing empty strings when not allowed.\"\"\"\n+        if not self.empty_strings_allowed and value == '':\n+            raise ValueError(\n+                f\"Empty string not allowed for foreign key field {self.name}. \"\n+                f\"The related object's primary key must be set before assignment.\"\n+            )\n+        return value\n     default_error_messages = {\n         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')\n     }\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..b274902f62 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,8 +72,13 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n+        # Check if the value is an empty string and the field doesn't allow empty strings\n+        if value == '' and hasattr(self.field, 'empty_strings_allowed') and not self.field.empty_strings_allowed:\n+            value = None\n+        \n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n             self.field.delete_cached_value(instance)\n         instance.__dict__[self.field.attname] = value\n@@ -200,6 +205,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,11 +260,47 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                pk_value = getattr(value, rh_field.attname)\n+                # Don't set empty string values for foreign keys that don't allow them\n+                if (pk_value == '' and \n+                    hasattr(lh_field, 'empty_strings_allowed') and \n+                    not lh_field.empty_strings_allowed):\n+                    # Store a reference to the related object for lazy evaluation\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = value\n+                else:\n+                    setattr(instance, lh_field.attname, pk_value)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+                    # Set foreign key to None temporarily to avoid storing empty string\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    setattr(instance, lh_field.attname, pk_value)\n+\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n+        \n+        # If the related object's primary key is empty and might be set later,\n+        # establish a callback to update the foreign key field when it changes\n+        if value is not None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_value = getattr(value, rh_field.attname)\n+                if pk_value == '' and not rh_field.empty_strings_allowed:\n+                    # Store a reference to update the FK when the PK is set\n+                    if not hasattr(instance, '_pending_fk_updates'):\n+                        instance._pending_fk_updates = {}\n+                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n \n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n",
    "variant_4": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..88dbb2a831 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -768,6 +768,7 @@ ForeignObject.register_lookup(RelatedLessThanOrEqual)\n ForeignObject.register_lookup(RelatedIsNull)\n \n \n+\n class ForeignKey(ForeignObject):\n     \"\"\"\n     Provide a many-to-one relation by adding a column to the local model\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..8d9ea487e8 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,8 +72,14 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n+        # Check if the value is an empty string and field doesn't allow empty strings\n+        if (value == '' and hasattr(self.field, 'empty_strings_allowed') and \n+            not self.field.empty_strings_allowed):\n+            value = None\n+            \n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n             self.field.delete_cached_value(instance)\n         instance.__dict__[self.field.attname] = value\n@@ -200,65 +206,103 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n-    def __set__(self, instance, value):\n-        \"\"\"\n-        Set the related instance through the forward relation.\n-\n-        With the example above, when setting ``child.parent = parent``:\n \n-        - ``self`` is the descriptor managing the ``parent`` attribute\n-        - ``instance`` is the ``child`` instance\n-        - ``value`` is the ``parent`` instance on the right of the equal sign\n-        \"\"\"\n-        # An object must be an instance of the related class.\n-        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n-            raise ValueError(\n-                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n-                    value,\n-                    instance._meta.object_name,\n-                    self.field.name,\n-                    self.field.remote_field.model._meta.object_name,\n-                )\n-            )\n-        elif value is not None:\n-            if instance._state.db is None:\n-                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n-            if value._state.db is None:\n-                value._state.db = router.db_for_write(value.__class__, instance=instance)\n-            if not router.allow_relation(value, instance):\n-                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+def __set__(self, instance, value):\n+    \"\"\"\n+    Set the related instance through the forward relation.\n \n-        remote_field = self.field.remote_field\n-        # If we're setting the value of a OneToOneField to None, we need to clear\n-        # out the cache on any old related object. Otherwise, deleting the\n-        # previously-related object will also cause this object to be deleted,\n-        # which is wrong.\n-        if value is None:\n-            # Look up the previously-related object, which may still be available\n-            # since we've not yet cleared out the related field.\n-            # Use the cache directly, instead of the accessor; if we haven't\n-            # populated the cache, then we don't care - we're only accessing\n-            # the object to invalidate the accessor cache, so there's no\n-            # need to populate the cache just to expire it again.\n-            related = self.field.get_cached_value(instance, default=None)\n-\n-            # If we've got an old related object, we need to clear out its\n-            # cache. This cache also might not exist if the related object\n-            # hasn't been accessed yet.\n-            if related is not None:\n-                remote_field.set_cached_value(related, None)\n+    With the example above, when setting ``child.parent = parent``:\n \n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+    - ``self`` is the descriptor managing the ``parent`` attribute\n+    - ``instance`` is the ``child`` instance\n+    - ``value`` is the ``parent`` instance on the right of the equal sign\n+    \"\"\"\n+    # An object must be an instance of the related class.\n+    if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n+        raise ValueError(\n+            'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n+                value,\n+                instance._meta.object_name,\n+                self.field.name,\n+                self.field.remote_field.model._meta.object_name,\n+            )\n+        )\n+    elif value is not None:\n+        if instance._state.db is None:\n+            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n+        if value._state.db is None:\n+            value._state.db = router.db_for_write(value.__class__, instance=instance)\n+        if not router.allow_relation(value, instance):\n+            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+\n+    remote_field = self.field.remote_field\n+    # If we're setting the value of a OneToOneField to None, we need to clear\n+    # out the cache on any old related object. Otherwise, deleting the\n+    # previously-related object will also cause this object to be deleted,\n+    # which is wrong.\n+    if value is None:\n+        # Look up the previously-related object, which may still be available\n+        # since we've not yet cleared out the related field.\n+        # Use the cache directly, instead of the accessor; if we haven't\n+        # populated the cache, then we don't care - we're only accessing\n+        # the object to invalidate the accessor cache, so there's no\n+        # need to populate the cache just to expire it again.\n+        related = self.field.get_cached_value(instance, default=None)\n+\n+        # If we've got an old related object, we need to clear out its\n+        # cache. This cache also might not exist if the related object\n+        # hasn't been accessed yet.\n+        if related is not None:\n+            remote_field.set_cached_value(related, None)\n+\n+        for lh_field, rh_field in self.field.related_fields:\n+            setattr(instance, lh_field.attname, None)\n+\n+    # Set the values of the related field.\n+    else:\n+        for lh_field, rh_field in self.field.related_fields:\n+            pk_value = getattr(value, rh_field.attname)\n+            # Only set the foreign key value if it's not empty or if empty strings are allowed\n+            if pk_value or pk_value == 0 or lh_field.empty_strings_allowed:\n+                setattr(instance, lh_field.attname, pk_value)\n+            else:\n+                # For non-empty-string fields with empty values, store a reference\n+                # to the related object so we can get the PK value later\n+                if not hasattr(instance, '_deferred_fk_updates'):\n+                    instance._deferred_fk_updates = {}\n+                instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n+\n+    # Set the related instance cache used by __get__ to avoid an SQL query\n+    # when accessing the attribute we just set.\n+    self.field.set_cached_value(instance, value)\n+\n+    # If this is a one-to-one relation, set the reverse accessor cache on\n+    # the related object to the current instance to avoid an extra SQL\n+    # query if it's accessed later on.\n+    if value is not None and not remote_field.multiple:\n+        remote_field.set_cached_value(value, instance)\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    # Normal assignment when primary key has a valid value\n+                    setattr(instance, lh_field.attname, pk_value)\n+                    # Clear any deferred assignment marker\n+                    if hasattr(instance, f'_deferred_{lh_field.attname}'):\n+                        delattr(instance, f'_deferred_{lh_field.attname}')\n \n-        # Set the values of the related field.\n-        else:\n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n+        \n+        # If the related object's primary key changes later, we need to update\n+        # the foreign key field to maintain consistency\n+        if value is not None and hasattr(value, '_state') and not value._state.adding:\n+            # For existing objects, check if we need to update the FK field\n+            for lh_field, rh_field in self.field.related_fields:\n+                current_fk_value = getattr(instance, lh_field.attname)\n+                actual_pk_value = getattr(value, rh_field.attname)\n+                if current_fk_value != actual_pk_value and actual_pk_value:\n+                    setattr(instance, lh_field.attname, actual_pk_value)\n \n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n",
    "variant_5": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..88dbb2a831 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -768,6 +768,7 @@ ForeignObject.register_lookup(RelatedLessThanOrEqual)\n ForeignObject.register_lookup(RelatedIsNull)\n \n \n+\n class ForeignKey(ForeignObject):\n     \"\"\"\n     Provide a many-to-one relation by adding a column to the local model\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..1a4cd22aab 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,8 +72,17 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n+        # Check if the field doesn't allow empty strings and value is empty string\n+        if (hasattr(self.field, 'empty_strings_allowed') and \n+            not self.field.empty_strings_allowed and value == ''):\n+            # Don't store empty string, let it remain None/unset\n+            if self.field.is_cached(instance):\n+                self.field.delete_cached_value(instance)\n+            return\n+            \n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n             self.field.delete_cached_value(instance)\n         instance.__dict__[self.field.attname] = value\n@@ -200,6 +209,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,7 +264,15 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                pk_value = getattr(value, rh_field.attname)\n+                # Don't set empty string values for foreign keys that don't allow them\n+                if pk_value == '' and not lh_field.empty_strings_allowed:\n+                    # Store a reference to the related object for lazy evaluation\n+                    if not hasattr(instance, '_pending_fk_updates'):\n+                        instance._pending_fk_updates = {}\n+                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n+                else:\n+                    setattr(instance, lh_field.attname, pk_value)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n@@ -266,6 +284,35 @@ class ForwardManyToOneDescriptor:\n         if value is not None and not remote_field.multiple:\n             remote_field.set_cached_value(value, instance)\n \n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+        \n+        # If the related object's primary key is empty and might change later,\n+        # set up a callback to update the foreign key field when it does\n+        if value is not None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_value = getattr(value, rh_field.attname)\n+                if pk_value == '' and not rh_field.empty_strings_allowed:\n+                    # Store a reference to update the FK when the PK is set\n+                    def update_fk_callback(sender, instance=value, **kwargs):\n+                        for lh_f, rh_f in self.field.related_fields:\n+                            new_pk = getattr(instance, rh_f.attname)\n+                            if new_pk != '':\n+                                setattr(instance._state.fields_cache.get(self.field.name + '_instance', instance), lh_f.attname, new_pk)\n+                    \n+                    # Connect to the related object's save signal to update FK\n+                    if not hasattr(value, '_fk_update_callbacks'):\n+                        value._fk_update_callbacks = []\n+                    value._fk_update_callbacks.append((instance, self.field, update_fk_callback))\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+\n     def __reduce__(self):\n         \"\"\"\n         Pickling should return the instance attached by self.field on the\n",
    "variant_6": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..5774d47818 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -768,6 +768,7 @@ ForeignObject.register_lookup(RelatedLessThanOrEqual)\n ForeignObject.register_lookup(RelatedIsNull)\n \n \n+\n class ForeignKey(ForeignObject):\n     \"\"\"\n     Provide a many-to-one relation by adding a column to the local model\n@@ -786,6 +787,19 @@ class ForeignKey(ForeignObject):\n     rel_class = ManyToOneRel\n \n     empty_strings_allowed = False\n+    \n+    def validate_fk_value(self, value, obj=None):\n+        \"\"\"Validate foreign key value, preventing empty strings when not allowed.\"\"\"\n+        if not self.empty_strings_allowed and value == '':\n+            if obj and hasattr(obj, '_meta'):\n+                model_name = obj._meta.verbose_name\n+            else:\n+                model_name = 'model'\n+            raise ValueError(\n+                f\"Cannot assign empty string to ForeignKey field '{self.name}' \"\n+                f\"on {model_name}. Use None instead or set empty_strings_allowed=True.\"\n+            )\n+        return value\n     default_error_messages = {\n         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')\n     }\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..4382903b90 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,8 +72,14 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n+        # Check if the value is an empty string and the field doesn't allow empty strings\n+        if (value == '' and hasattr(self.field, 'empty_strings_allowed') and \n+            not self.field.empty_strings_allowed):\n+            value = None\n+            \n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n             self.field.delete_cached_value(instance)\n         instance.__dict__[self.field.attname] = value\n@@ -200,65 +206,100 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n-    def __set__(self, instance, value):\n-        \"\"\"\n-        Set the related instance through the forward relation.\n-\n-        With the example above, when setting ``child.parent = parent``:\n \n-        - ``self`` is the descriptor managing the ``parent`` attribute\n-        - ``instance`` is the ``child`` instance\n-        - ``value`` is the ``parent`` instance on the right of the equal sign\n-        \"\"\"\n-        # An object must be an instance of the related class.\n-        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n-            raise ValueError(\n-                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n-                    value,\n-                    instance._meta.object_name,\n-                    self.field.name,\n-                    self.field.remote_field.model._meta.object_name,\n-                )\n-            )\n-        elif value is not None:\n-            if instance._state.db is None:\n-                instance._state.db = router.db_for_write(instance.__class__, instance=value)\n-            if value._state.db is None:\n-                value._state.db = router.db_for_write(value.__class__, instance=instance)\n-            if not router.allow_relation(value, instance):\n-                raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+def __set__(self, instance, value):\n+    \"\"\"\n+    Set the related instance through the forward relation.\n \n-        remote_field = self.field.remote_field\n-        # If we're setting the value of a OneToOneField to None, we need to clear\n-        # out the cache on any old related object. Otherwise, deleting the\n-        # previously-related object will also cause this object to be deleted,\n-        # which is wrong.\n-        if value is None:\n-            # Look up the previously-related object, which may still be available\n-            # since we've not yet cleared out the related field.\n-            # Use the cache directly, instead of the accessor; if we haven't\n-            # populated the cache, then we don't care - we're only accessing\n-            # the object to invalidate the accessor cache, so there's no\n-            # need to populate the cache just to expire it again.\n-            related = self.field.get_cached_value(instance, default=None)\n-\n-            # If we've got an old related object, we need to clear out its\n-            # cache. This cache also might not exist if the related object\n-            # hasn't been accessed yet.\n-            if related is not None:\n-                remote_field.set_cached_value(related, None)\n+    With the example above, when setting ``child.parent = parent``:\n \n-            for lh_field, rh_field in self.field.related_fields:\n+    - ``self`` is the descriptor managing the ``parent`` attribute\n+    - ``instance`` is the ``child`` instance\n+    - ``value`` is the ``parent`` instance on the right of the equal sign\n+    \"\"\"\n+    # An object must be an instance of the related class.\n+    if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n+        raise ValueError(\n+            'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n+                value,\n+                instance._meta.object_name,\n+                self.field.name,\n+                self.field.remote_field.model._meta.object_name,\n+            )\n+        )\n+    elif value is not None:\n+        if instance._state.db is None:\n+            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n+        if value._state.db is None:\n+            value._state.db = router.db_for_write(value.__class__, instance=instance)\n+        if not router.allow_relation(value, instance):\n+            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n+\n+    remote_field = self.field.remote_field\n+    # If we're setting the value of a OneToOneField to None, we need to clear\n+    # out the cache on any old related object. Otherwise, deleting the\n+    # previously-related object will also cause this object to be deleted,\n+    # which is wrong.\n+    if value is None:\n+        # Look up the previously-related object, which may still be available\n+        # since we've not yet cleared out the related field.\n+        # Use the cache directly, instead of the accessor; if we haven't\n+        # populated the cache, then we don't care - we're only accessing\n+        # the object to invalidate the accessor cache, so there's no\n+        # need to populate the cache just to expire it again.\n+        related = self.field.get_cached_value(instance, default=None)\n+\n+        # If we've got an old related object, we need to clear out its\n+        # cache. This cache also might not exist if the related object\n+        # hasn't been accessed yet.\n+        if related is not None:\n+            remote_field.set_cached_value(related, None)\n+\n+        for lh_field, rh_field in self.field.related_fields:\n+            setattr(instance, lh_field.attname, None)\n+\n+    # Set the values of the related field.\n+    else:\n+        for lh_field, rh_field in self.field.related_fields:\n+            rh_value = getattr(value, rh_field.attname)\n+            # Don't set empty string values for fields that don't allow them\n+            if rh_value == '' and not lh_field.empty_strings_allowed:\n+                # Store a reference to the related object for lazy evaluation\n+                setattr(instance, '_lazy_' + lh_field.attname, value)\n                 setattr(instance, lh_field.attname, None)\n+            else:\n+                setattr(instance, lh_field.attname, rh_value)\n+                # Clear any lazy reference since we have a valid value\n+                if hasattr(instance, '_lazy_' + lh_field.attname):\n+                    delattr(instance, '_lazy_' + lh_field.attname)\n+\n+    # Set the related instance cache used by __get__ to avoid an SQL query\n+    # when accessing the attribute we just set.\n+    self.field.set_cached_value(instance, value)\n+\n+    # If this is a one-to-one relation, set the reverse accessor cache on\n+    # the related object to the current instance to avoid an extra SQL\n+    # query if it's accessed later on.\n+    if value is not None and not remote_field.multiple:\n+        remote_field.set_cached_value(value, instance)\n+                else:\n+                    setattr(instance, lh_field.attname, pk_value)\n \n-        # Set the values of the related field.\n-        else:\n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n+        \n+        # If the related object's primary key is None or empty string, establish\n+        # a deferred update mechanism to capture the PK value when it's set\n+        if value is not None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_value = getattr(value, rh_field.attname)\n+                if pk_value == '' and not rh_field.empty_strings_allowed:\n+                    # Store a reference to update the FK when the related object's PK is set\n+                    if not hasattr(instance, '_deferred_fk_updates'):\n+                        instance._deferred_fk_updates = {}\n+                    instance._deferred_fk_updates[lh_field.attname] = (value, rh_field.attname)\n \n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n",
    "variant_7": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..88dbb2a831 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -768,6 +768,7 @@ ForeignObject.register_lookup(RelatedLessThanOrEqual)\n ForeignObject.register_lookup(RelatedIsNull)\n \n \n+\n class ForeignKey(ForeignObject):\n     \"\"\"\n     Provide a many-to-one relation by adding a column to the local model\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..0c1ca8c8a5 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,8 +72,14 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n+        # Check if the value is an empty string and the field doesn't allow empty strings\n+        if value == '' and not getattr(self.field, 'empty_strings_allowed', True):\n+            # Convert empty string to None for fields that don't allow empty strings\n+            value = None\n+        \n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n             self.field.delete_cached_value(instance)\n         instance.__dict__[self.field.attname] = value\n@@ -200,6 +206,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,11 +261,55 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Check if the primary key is empty and field doesn't allow empty strings\n+                if (rh_value == '' and hasattr(lh_field, 'empty_strings_allowed') and \n+                    not lh_field.empty_strings_allowed):\n+                    # Store a reference to the related object for lazy evaluation\n+                    setattr(instance, '_' + lh_field.attname + '_deferred_obj', value)\n+                    # Set the field to None temporarily\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    setattr(instance, lh_field.attname, rh_value)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+                    # Set current value as placeholder\n+                    setattr(instance, lh_field.attname, pk_value)\n+                else:\n+                    # Primary key is valid, set it normally\n+                    setattr(instance, lh_field.attname, pk_value)\n+\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n+        \n+        # If the related object's primary key might change later, set up a callback\n+        # to update the foreign key field when that happens\n+        if value is not None and hasattr(value, '_state') and value._state.adding:\n+            # Store a reference to update the foreign key when the related object is saved\n+            original_save = getattr(value, 'save', None)\n+            if original_save:\n+                def patched_save(*args, **kwargs):\n+                    result = original_save(*args, **kwargs)\n+                    # Update foreign key fields after the related object is saved\n+                    for lh_field, rh_field in self.field.related_fields:\n+                        current_fk_value = getattr(instance, lh_field.attname)\n+                        new_fk_value = getattr(value, rh_field.attname)\n+                        # Only update if the foreign key value has changed and is not empty\n+                        if current_fk_value != new_fk_value and new_fk_value:\n+                            setattr(instance, lh_field.attname, new_fk_value)\n+                    return result\n+                value.save = patched_save\n \n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n",
    "variant_8": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..88dbb2a831 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -768,6 +768,7 @@ ForeignObject.register_lookup(RelatedLessThanOrEqual)\n ForeignObject.register_lookup(RelatedIsNull)\n \n \n+\n class ForeignKey(ForeignObject):\n     \"\"\"\n     Provide a many-to-one relation by adding a column to the local model\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..70b3dab66e 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -72,8 +72,13 @@ from django.db.models.utils import resolve_callables\n from django.utils.functional import cached_property\n \n \n+\n class ForeignKeyDeferredAttribute(DeferredAttribute):\n     def __set__(self, instance, value):\n+        # Check if the field doesn't allow empty strings and value is an empty string\n+        if not getattr(self.field, 'empty_strings_allowed', True) and value == '':\n+            raise ValueError(f\"Empty string not allowed for field '{self.field.name}'\")\n+        \n         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n             self.field.delete_cached_value(instance)\n         instance.__dict__[self.field.attname] = value\n@@ -200,6 +205,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -254,11 +260,56 @@ class ForwardManyToOneDescriptor:\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                pk_value = getattr(value, rh_field.attname)\n+                # Check if the primary key is empty and field doesn't allow empty strings\n+                if (pk_value == '' and hasattr(lh_field, 'empty_strings_allowed') \n+                    and not lh_field.empty_strings_allowed):\n+                    # Store a reference to update the FK later when PK becomes available\n+                    if not hasattr(instance, '_pending_fk_updates'):\n+                        instance._pending_fk_updates = {}\n+                    instance._pending_fk_updates[lh_field.attname] = (value, rh_field.attname)\n+                    # Set to None for now to avoid storing empty string\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    setattr(instance, lh_field.attname, pk_value)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            remote_field.set_cached_value(value, instance)\n+                    # This will be resolved later when the foreign key is actually needed\n+                    setattr(instance, lh_field.attname + '_deferred_object', value)\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    setattr(instance, lh_field.attname, rh_value)\n+\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n+        \n+        # If the related object has an empty primary key, establish a callback\n+        # to update the foreign key field when the primary key is set\n+        if value is not None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_value = getattr(value, rh_field.attname)\n+                if pk_value == '' and not rh_field.empty_strings_allowed:\n+                    # Store a reference to update the foreign key when pk is set\n+                    def update_fk_on_pk_change(sender, instance_pk, **kwargs):\n+                        if hasattr(instance_pk, rh_field.attname):\n+                            new_pk_value = getattr(instance_pk, rh_field.attname)\n+                            if new_pk_value != '':\n+                                setattr(instance, lh_field.attname, new_pk_value)\n+                    \n+                    # Connect to the related object's attribute change\n+                    if not hasattr(value, '_fk_update_callbacks'):\n+                        value._fk_update_callbacks = []\n+                    value._fk_update_callbacks.append((instance, lh_field, update_fk_on_pk_change))\n \n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n"
  }
}