{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/backend_bases.py lines 1655-1658)": "\n    def __init__(self, figure=None):\n        super().__init__()\n        if figure is None:\n            figure = Figure()\n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 3047-3055)": "\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n",
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/backend_bases.py lines 2104-2107)": "\n    def _set_device_pixel_ratio(self, ratio):\n        \"\"\"\n        Set the device pixel ratio for the canvas.\n\n        This is typically set by the backend when the canvas is embedded in a\n        GUI framework that supports High DPI displays. The ratio is the number\n        of actual pixels per logical pixel.\n\n        Parameters\n        ----------\n        ratio : float\n            The device pixel ratio.\n\n        Returns\n        -------\n        bool\n            Whether the ratio has changed. Backends may interpret this as a\n            signal to resize the window, repaint the canvas, or change any\n            other relevant properties.\n        \"\"\"\n        if self._device_pixel_ratio == ratio:\n            return False\n        # In cases with mixed resolution displays, we need to be careful if the\n        # device pixel ratio changes - in this case we need to resize the\n        # canvas accordingly. Some backends provide events that indicate a\n        # change in DPI, but those that don't will update this before drawing.\n        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n        dpi = ratio * original_dpi\n        self.figure._set_dpi(dpi, forward=False)\n        self._device_pixel_ratio = ratio\n        return True\n",
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/backend_bases.py lines 2284-2284)": "\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n",
    "Location 5 (/root/hy/projects_4/matplotlib/lib/matplotlib/backend_bases.py lines 3509-3512)": "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        return cls.FigureCanvas.new_manager(figure, num)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/backend_bases.py lines 1655-1658)": [
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n    def __init__(self, figure=None):\n        super().__init__()\n        if figure is None:\n            figure = Figure()\n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n"
    ],
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 3047-3055)": [
      "\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n",
      "\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n",
      "\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n",
      "\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n",
      "\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n",
      "\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n",
      "\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n",
      "\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n"
    ],
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/backend_bases.py lines 2104-2107)": [
      "\n    def _set_device_pixel_ratio(self, ratio):\n        \"\"\"\n        Set the device pixel ratio for the canvas.\n\n        This is typically set by the backend to indicate the ratio between\n        physical pixels and logical pixels. The default is 1.0.\n\n        Parameters\n        ----------\n        ratio : float\n            The device pixel ratio.\n\n        Returns\n        -------\n        bool\n            Whether the ratio has changed. Backends may interpret this as a\n            signal to resize the window, repaint the canvas, or change any\n            other relevant properties.\n        \"\"\"\n        if self._device_pixel_ratio == ratio:\n            return False\n        # In cases with mixed resolution displays, we need to be careful if the\n        # device pixel ratio changes - in this case we need to resize the\n        # canvas accordingly. Some backends provide events that indicate a\n        # change in DPI, but those that don't will update this before drawing.\n        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n        dpi = ratio * original_dpi\n        self.figure._set_dpi(dpi, forward=False)\n        self._device_pixel_ratio = ratio\n        return True\n",
      "\n    def _set_device_pixel_ratio(self, ratio):\n        \"\"\"\n        Set the device pixel ratio for the canvas.\n\n        This is typically called by the backend when the device pixel ratio\n        changes (e.g. when a window is moved between displays with different\n        DPIs).\n\n        Parameters\n        ----------\n        ratio : float\n            The new device pixel ratio.\n\n        Returns\n        -------\n        bool\n            Whether the ratio has changed. Backends may interpret this as a\n            signal to resize the window, repaint the canvas, or change any\n            other relevant properties.\n        \"\"\"\n        if self._device_pixel_ratio == ratio:\n            return False\n        # In cases with mixed resolution displays, we need to be careful if the\n        # device pixel ratio changes - in this case we need to resize the\n        # canvas accordingly. Some backends provide events that indicate a\n        # change in DPI, but those that don't will update this before drawing.\n        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n        dpi = ratio * original_dpi\n        self.figure._set_dpi(dpi, forward=False)\n        self._device_pixel_ratio = ratio\n        return True\n",
      "\n    def _set_device_pixel_ratio(self, ratio):\n        \"\"\"\n        Set the device pixel ratio for the canvas.\n\n        This is typically set by the backend to indicate the device pixel\n        ratio, which is the ratio of physical pixels to logical pixels.\n        Calling this method will trigger a DPI change in the figure.\n\n        Parameters\n        ----------\n        ratio : float\n            The device pixel ratio\n\n        Returns\n        -------\n        bool\n            Whether the ratio has changed. Backends may interpret this as a\n            signal to resize the window, repaint the canvas, or change any\n            other relevant properties.\n        \"\"\"\n        if self._device_pixel_ratio == ratio:\n            return False\n        # In cases with mixed resolution displays, we need to be careful if the\n        # device pixel ratio changes - in this case we need to resize the\n        # canvas accordingly. Some backends provide events that indicate a\n        # change in DPI, but those that don't will update this before drawing.\n        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n        dpi = ratio * original_dpi\n        self.figure._set_dpi(dpi, forward=False)\n        self._device_pixel_ratio = ratio\n        return True\n",
      "\n    def _set_device_pixel_ratio(self, ratio):\n        \"\"\"\n        Set the device pixel ratio for the canvas.\n\n        This is typically called by the backend when moving between screens\n        of different DPI or when the system DPI setting is changed.\n\n        Parameters\n        ----------\n        ratio : float\n            The physical pixel to logical pixel ratio as a float.\n\n        Returns\n        -------\n        bool\n            Whether the ratio has changed. Backends may interpret this as a\n            signal to resize the window, repaint the canvas, or change any\n            other relevant properties.\n        \"\"\"\n        if self._device_pixel_ratio == ratio:\n            return False\n        # In cases with mixed resolution displays, we need to be careful if the\n        # device pixel ratio changes - in this case we need to resize the\n        # canvas accordingly. Some backends provide events that indicate a\n        # change in DPI, but those that don't will update this before drawing.\n        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n        dpi = ratio * original_dpi\n        self.figure._set_dpi(dpi, forward=False)\n        self._device_pixel_ratio = ratio\n        return True\n",
      "\n    def _set_device_pixel_ratio(self, ratio):\n        \"\"\"\n        Set the device pixel ratio for the canvas.\n\n        This is typically set by the backend to indicate the ratio between\n        physical and logical pixels on the canvas. The default value is 1.0.\n\n        Parameters\n        ----------\n        ratio : float\n            The device pixel ratio.\n\n        Returns\n        -------\n        bool\n            Whether the ratio has changed. Backends may interpret this as a\n            signal to resize the window, repaint the canvas, or change any\n            other relevant properties.\n        \"\"\"\n        if self._device_pixel_ratio == ratio:\n            return False\n        # In cases with mixed resolution displays, we need to be careful if the\n        # device pixel ratio changes - in this case we need to resize the\n        # canvas accordingly. Some backends provide events that indicate a\n        # change in DPI, but those that don't will update this before drawing.\n        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n        dpi = ratio * original_dpi\n        self.figure._set_dpi(dpi, forward=False)\n        self._device_pixel_ratio = ratio\n        return True\n",
      "\n    def _set_device_pixel_ratio(self, ratio):\n        \"\"\"\n        Set the device pixel ratio for the canvas.\n\n        This is typically set by the backend based on the display the canvas is\n        on. Subclasses that work with multiple displays may override to provide\n        alternative implementations.\n\n        Parameters\n        ----------\n        ratio : float\n            The device pixel ratio (as a float > 0).\n\n        Returns\n        -------\n        bool\n            Whether the ratio has changed. Backends may interpret this as a\n            signal to resize the window, repaint the canvas, or change any\n            other relevant properties.\n        \"\"\"\n        if self._device_pixel_ratio == ratio:\n            return False\n        # In cases with mixed resolution displays, we need to be careful if the\n        # device pixel ratio changes - in this case we need to resize the\n        # canvas accordingly. Some backends provide events that indicate a\n        # change in DPI, but those that don't will update this before drawing.\n        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n        dpi = ratio * original_dpi\n        self.figure._set_dpi(dpi, forward=False)\n        self._device_pixel_ratio = ratio\n        return True\n",
      "\n    def _set_device_pixel_ratio(self, ratio):\n        \"\"\"\n        Set the device pixel ratio for the canvas.\n\n        This is typically set by the backend when the canvas is embedded in a\n        GUI window that is aware of the device pixel ratio. The canvas does\n        not track this itself, since it can change as a window is moved\n        between different displays.\n\n        Parameters\n        ----------\n        ratio : float\n            The physical to logical pixel ratio, as a float greater than 0.\n\n        Returns\n        -------\n        bool\n            Whether the ratio has changed. Backends may interpret this as a\n            signal to resize the window, repaint the canvas, or change any\n            other relevant properties.\n        \"\"\"\n        if self._device_pixel_ratio == ratio:\n            return False\n        # In cases with mixed resolution displays, we need to be careful if the\n        # device pixel ratio changes - in this case we need to resize the\n        # canvas accordingly. Some backends provide events that indicate a\n        # change in DPI, but those that don't will update this before drawing.\n        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n        dpi = ratio * original_dpi\n        self.figure._set_dpi(dpi, forward=False)\n        self._device_pixel_ratio = ratio\n        return True\n",
      "\n    def _set_device_pixel_ratio(self, ratio):\n        \"\"\"\n        Set the device pixel ratio for the canvas.\n\n        This is typically set by the backend when the canvas is created, and\n        may be updated if the device pixel ratio changes (e.g. when a window\n        is moved between monitors with different DPIs).\n\n        Parameters\n        ----------\n        ratio : float\n            The physical to logical pixel ratio as a float.\n\n        Returns\n        -------\n        bool\n            Whether the ratio has changed. Backends may interpret this as a\n            signal to resize the window, repaint the canvas, or change any\n            other relevant properties.\n        \"\"\"\n        if self._device_pixel_ratio == ratio:\n            return False\n        # In cases with mixed resolution displays, we need to be careful if the\n        # device pixel ratio changes - in this case we need to resize the\n        # canvas accordingly. Some backends provide events that indicate a\n        # change in DPI, but those that don't will update this before drawing.\n        dpi = ratio * getattr(self.figure, '_original_dpi', self.figure.dpi)\n        self.figure._set_dpi(dpi, forward=False)\n        self._device_pixel_ratio = ratio\n        return True\n"
    ],
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/backend_bases.py lines 2284-2284)": [
      "\n        if dpi is None:\n            dpi = rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n",
      "\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n",
      "\n        if dpi is None:\n            dpi = rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n",
      "\n        if dpi is None:\n            dpi = rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n",
      "\n        if dpi == 'figure':\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n",
      "\n        if dpi is None:\n            dpi = rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n",
      "\n        if dpi is None:\n            dpi = rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n",
      "\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n"
    ],
    "Location 5 (/root/hy/projects_4/matplotlib/lib/matplotlib/backend_bases.py lines 3509-3512)": [
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        return cls.FigureCanvas.new_manager(figure, num)\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        return cls.FigureCanvas.new_manager(figure, num)\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        return cls.FigureCanvas.new_manager(figure, num)\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        return cls.FigureCanvas.new_manager(figure, num)\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        return cls.FigureCanvas.new_manager(figure, num)\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        return cls.FigureCanvas.new_manager(figure, num)\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        return cls.FigureCanvas.new_manager(figure, num)\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        return cls.FigureCanvas.new_manager(figure, num)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..a8f8fd806b 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -2101,6 +2103,7 @@ class FigureCanvasBase:\n         # device pixel ratio changes - in this case we need to resize the\n         # canvas accordingly. Some backends provide events that indicate a\n         # change in DPI, but those that don't will update this before drawing.\n+\n         dpi = ratio * self.figure._original_dpi\n         self.figure._set_dpi(dpi, forward=False)\n         self._device_pixel_ratio = ratio\n@@ -2281,6 +2284,7 @@ class FigureCanvasBase:\n         if dpi is None:\n             dpi = rcParams['savefig.dpi']\n         if dpi == 'figure':\n+\n             dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n \n         # Remove the figure manager, if any, to avoid resizing the GUI widget.\n@@ -3506,6 +3510,7 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..873314800e 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3044,6 +3044,7 @@ class Figure(FigureBase):\n         self.__dict__ = state\n \n         # re-initialise some of the unstored state information\n+\n         FigureCanvasBase(self)  # Set self.canvas.\n \n         if restore_to_pylab:\n",
    "variant_0": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..0686b2e0a2 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,24 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n+    def __init__(self, figure=None):\n+        super().__init__()\n+        if figure is None:\n+            figure = Figure()\n+        figure.set_canvas(self)\n+        self.figure = figure\n+        self.manager = None\n+        self.widgetlock = widgets.LockDraw()\n+        self._button = None  # the button pressed\n+        self._key = None  # the key pressed\n+        self._lastx, self._lasty = None, None\n+        self.mouse_grabber = None  # the Axes currently grabbing mouse\n+        self.toolbar = None  # NavigationToolbar2 will set me\n+        self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -2101,7 +2117,35 @@ class FigureCanvasBase:\n         # device pixel ratio changes - in this case we need to resize the\n         # canvas accordingly. Some backends provide events that indicate a\n         # change in DPI, but those that don't will update this before drawing.\n-        dpi = ratio * self.figure._original_dpi\n+\n+    def _set_device_pixel_ratio(self, ratio):\n+        \"\"\"\n+        Set the device pixel ratio for the canvas.\n+\n+        This is typically set by the backend when the canvas is embedded in a\n+        GUI framework that supports High DPI displays. The ratio is the number\n+        of actual pixels per logical pixel.\n+\n+        Parameters\n+        ----------\n+        ratio : float\n+            The device pixel ratio.\n+\n+        Returns\n+        -------\n+        bool\n+            Whether the ratio has changed. Backends may interpret this as a\n+            signal to resize the window, repaint the canvas, or change any\n+            other relevant properties.\n+        \"\"\"\n+        if self._device_pixel_ratio == ratio:\n+            return False\n+        # In cases with mixed resolution displays, we need to be careful if the\n+        # device pixel ratio changes - in this case we need to resize the\n+        # canvas accordingly. Some backends provide events that indicate a\n+        # change in DPI, but those that don't will update this before drawing.\n+        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+        dpi = ratio * original_dpi\n         self.figure._set_dpi(dpi, forward=False)\n         self._device_pixel_ratio = ratio\n         return True\n@@ -2281,6 +2325,7 @@ class FigureCanvasBase:\n         if dpi is None:\n             dpi = rcParams['savefig.dpi']\n         if dpi == 'figure':\n+\n             dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n \n         # Remove the figure manager, if any, to avoid resizing the GUI widget.\n@@ -3506,6 +3551,7 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d10f69691d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3043,6 +3043,8 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # re-initialise some of the unstored state information\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n",
    "variant_1": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..bccb0d333e 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -2101,7 +2103,34 @@ class FigureCanvasBase:\n         # device pixel ratio changes - in this case we need to resize the\n         # canvas accordingly. Some backends provide events that indicate a\n         # change in DPI, but those that don't will update this before drawing.\n-        dpi = ratio * self.figure._original_dpi\n+\n+    def _set_device_pixel_ratio(self, ratio):\n+        \"\"\"\n+        Set the device pixel ratio for the canvas.\n+\n+        This is typically set by the backend to indicate the ratio between\n+        physical pixels and logical pixels. The default is 1.0.\n+\n+        Parameters\n+        ----------\n+        ratio : float\n+            The device pixel ratio.\n+\n+        Returns\n+        -------\n+        bool\n+            Whether the ratio has changed. Backends may interpret this as a\n+            signal to resize the window, repaint the canvas, or change any\n+            other relevant properties.\n+        \"\"\"\n+        if self._device_pixel_ratio == ratio:\n+            return False\n+        # In cases with mixed resolution displays, we need to be careful if the\n+        # device pixel ratio changes - in this case we need to resize the\n+        # canvas accordingly. Some backends provide events that indicate a\n+        # change in DPI, but those that don't will update this before drawing.\n+        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+        dpi = ratio * original_dpi\n         self.figure._set_dpi(dpi, forward=False)\n         self._device_pixel_ratio = ratio\n         return True\n@@ -2278,6 +2307,10 @@ class FigureCanvasBase:\n                     filename = filename.rstrip('.') + '.' + format\n         format = format.lower()\n \n+        if dpi is None:\n+            dpi = rcParams['savefig.dpi']\n+        if dpi == 'figure':\n+\n         if dpi is None:\n             dpi = rcParams['savefig.dpi']\n         if dpi == 'figure':\n@@ -3506,6 +3539,7 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d10f69691d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3043,6 +3043,8 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # re-initialise some of the unstored state information\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n",
    "variant_2": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..97e12fd17a 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -2101,7 +2103,35 @@ class FigureCanvasBase:\n         # device pixel ratio changes - in this case we need to resize the\n         # canvas accordingly. Some backends provide events that indicate a\n         # change in DPI, but those that don't will update this before drawing.\n-        dpi = ratio * self.figure._original_dpi\n+\n+    def _set_device_pixel_ratio(self, ratio):\n+        \"\"\"\n+        Set the device pixel ratio for the canvas.\n+\n+        This is typically called by the backend when the device pixel ratio\n+        changes (e.g. when a window is moved between displays with different\n+        DPIs).\n+\n+        Parameters\n+        ----------\n+        ratio : float\n+            The new device pixel ratio.\n+\n+        Returns\n+        -------\n+        bool\n+            Whether the ratio has changed. Backends may interpret this as a\n+            signal to resize the window, repaint the canvas, or change any\n+            other relevant properties.\n+        \"\"\"\n+        if self._device_pixel_ratio == ratio:\n+            return False\n+        # In cases with mixed resolution displays, we need to be careful if the\n+        # device pixel ratio changes - in this case we need to resize the\n+        # canvas accordingly. Some backends provide events that indicate a\n+        # change in DPI, but those that don't will update this before drawing.\n+        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+        dpi = ratio * original_dpi\n         self.figure._set_dpi(dpi, forward=False)\n         self._device_pixel_ratio = ratio\n         return True\n@@ -2281,6 +2311,7 @@ class FigureCanvasBase:\n         if dpi is None:\n             dpi = rcParams['savefig.dpi']\n         if dpi == 'figure':\n+\n             dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n \n         # Remove the figure manager, if any, to avoid resizing the GUI widget.\n@@ -3506,6 +3537,7 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d10f69691d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3043,6 +3043,8 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # re-initialise some of the unstored state information\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n",
    "variant_3": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..adc8dbd746 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -2101,7 +2103,35 @@ class FigureCanvasBase:\n         # device pixel ratio changes - in this case we need to resize the\n         # canvas accordingly. Some backends provide events that indicate a\n         # change in DPI, but those that don't will update this before drawing.\n-        dpi = ratio * self.figure._original_dpi\n+\n+    def _set_device_pixel_ratio(self, ratio):\n+        \"\"\"\n+        Set the device pixel ratio for the canvas.\n+\n+        This is typically set by the backend to indicate the device pixel\n+        ratio, which is the ratio of physical pixels to logical pixels.\n+        Calling this method will trigger a DPI change in the figure.\n+\n+        Parameters\n+        ----------\n+        ratio : float\n+            The device pixel ratio\n+\n+        Returns\n+        -------\n+        bool\n+            Whether the ratio has changed. Backends may interpret this as a\n+            signal to resize the window, repaint the canvas, or change any\n+            other relevant properties.\n+        \"\"\"\n+        if self._device_pixel_ratio == ratio:\n+            return False\n+        # In cases with mixed resolution displays, we need to be careful if the\n+        # device pixel ratio changes - in this case we need to resize the\n+        # canvas accordingly. Some backends provide events that indicate a\n+        # change in DPI, but those that don't will update this before drawing.\n+        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+        dpi = ratio * original_dpi\n         self.figure._set_dpi(dpi, forward=False)\n         self._device_pixel_ratio = ratio\n         return True\n@@ -2278,6 +2308,10 @@ class FigureCanvasBase:\n                     filename = filename.rstrip('.') + '.' + format\n         format = format.lower()\n \n+        if dpi is None:\n+            dpi = rcParams['savefig.dpi']\n+        if dpi == 'figure':\n+\n         if dpi is None:\n             dpi = rcParams['savefig.dpi']\n         if dpi == 'figure':\n@@ -3506,6 +3540,7 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d10f69691d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3043,6 +3043,8 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # re-initialise some of the unstored state information\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n",
    "variant_4": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..63ed91399b 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -2101,7 +2103,34 @@ class FigureCanvasBase:\n         # device pixel ratio changes - in this case we need to resize the\n         # canvas accordingly. Some backends provide events that indicate a\n         # change in DPI, but those that don't will update this before drawing.\n-        dpi = ratio * self.figure._original_dpi\n+\n+    def _set_device_pixel_ratio(self, ratio):\n+        \"\"\"\n+        Set the device pixel ratio for the canvas.\n+\n+        This is typically called by the backend when moving between screens\n+        of different DPI or when the system DPI setting is changed.\n+\n+        Parameters\n+        ----------\n+        ratio : float\n+            The physical pixel to logical pixel ratio as a float.\n+\n+        Returns\n+        -------\n+        bool\n+            Whether the ratio has changed. Backends may interpret this as a\n+            signal to resize the window, repaint the canvas, or change any\n+            other relevant properties.\n+        \"\"\"\n+        if self._device_pixel_ratio == ratio:\n+            return False\n+        # In cases with mixed resolution displays, we need to be careful if the\n+        # device pixel ratio changes - in this case we need to resize the\n+        # canvas accordingly. Some backends provide events that indicate a\n+        # change in DPI, but those that don't will update this before drawing.\n+        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+        dpi = ratio * original_dpi\n         self.figure._set_dpi(dpi, forward=False)\n         self._device_pixel_ratio = ratio\n         return True\n@@ -2278,6 +2307,10 @@ class FigureCanvasBase:\n                     filename = filename.rstrip('.') + '.' + format\n         format = format.lower()\n \n+        if dpi is None:\n+            dpi = rcParams['savefig.dpi']\n+        if dpi == 'figure':\n+\n         if dpi is None:\n             dpi = rcParams['savefig.dpi']\n         if dpi == 'figure':\n@@ -3506,6 +3539,7 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d10f69691d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3043,6 +3043,8 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # re-initialise some of the unstored state information\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n",
    "variant_5": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5f6de85604 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -2101,7 +2103,34 @@ class FigureCanvasBase:\n         # device pixel ratio changes - in this case we need to resize the\n         # canvas accordingly. Some backends provide events that indicate a\n         # change in DPI, but those that don't will update this before drawing.\n-        dpi = ratio * self.figure._original_dpi\n+\n+    def _set_device_pixel_ratio(self, ratio):\n+        \"\"\"\n+        Set the device pixel ratio for the canvas.\n+\n+        This is typically set by the backend to indicate the ratio between\n+        physical and logical pixels on the canvas. The default value is 1.0.\n+\n+        Parameters\n+        ----------\n+        ratio : float\n+            The device pixel ratio.\n+\n+        Returns\n+        -------\n+        bool\n+            Whether the ratio has changed. Backends may interpret this as a\n+            signal to resize the window, repaint the canvas, or change any\n+            other relevant properties.\n+        \"\"\"\n+        if self._device_pixel_ratio == ratio:\n+            return False\n+        # In cases with mixed resolution displays, we need to be careful if the\n+        # device pixel ratio changes - in this case we need to resize the\n+        # canvas accordingly. Some backends provide events that indicate a\n+        # change in DPI, but those that don't will update this before drawing.\n+        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+        dpi = ratio * original_dpi\n         self.figure._set_dpi(dpi, forward=False)\n         self._device_pixel_ratio = ratio\n         return True\n@@ -2280,6 +2309,8 @@ class FigureCanvasBase:\n \n         if dpi is None:\n             dpi = rcParams['savefig.dpi']\n+        if dpi == 'figure':\n+\n         if dpi == 'figure':\n             dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n \n@@ -3506,6 +3537,7 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d10f69691d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3043,6 +3043,8 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # re-initialise some of the unstored state information\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n",
    "variant_6": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..55fa4e8d31 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,24 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n+    def __init__(self, figure=None):\n+        super().__init__()\n+        if figure is None:\n+            figure = Figure()\n+        figure.set_canvas(self)\n+        self.figure = figure\n+        self.manager = None\n+        self.widgetlock = widgets.LockDraw()\n+        self._button = None  # the button pressed\n+        self._key = None  # the key pressed\n+        self._lastx, self._lasty = None, None\n+        self.mouse_grabber = None  # the Axes currently grabbing mouse\n+        self.toolbar = None  # NavigationToolbar2 will set me\n+        self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -2101,7 +2117,35 @@ class FigureCanvasBase:\n         # device pixel ratio changes - in this case we need to resize the\n         # canvas accordingly. Some backends provide events that indicate a\n         # change in DPI, but those that don't will update this before drawing.\n-        dpi = ratio * self.figure._original_dpi\n+\n+    def _set_device_pixel_ratio(self, ratio):\n+        \"\"\"\n+        Set the device pixel ratio for the canvas.\n+\n+        This is typically set by the backend based on the display the canvas is\n+        on. Subclasses that work with multiple displays may override to provide\n+        alternative implementations.\n+\n+        Parameters\n+        ----------\n+        ratio : float\n+            The device pixel ratio (as a float > 0).\n+\n+        Returns\n+        -------\n+        bool\n+            Whether the ratio has changed. Backends may interpret this as a\n+            signal to resize the window, repaint the canvas, or change any\n+            other relevant properties.\n+        \"\"\"\n+        if self._device_pixel_ratio == ratio:\n+            return False\n+        # In cases with mixed resolution displays, we need to be careful if the\n+        # device pixel ratio changes - in this case we need to resize the\n+        # canvas accordingly. Some backends provide events that indicate a\n+        # change in DPI, but those that don't will update this before drawing.\n+        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+        dpi = ratio * original_dpi\n         self.figure._set_dpi(dpi, forward=False)\n         self._device_pixel_ratio = ratio\n         return True\n@@ -2278,6 +2322,10 @@ class FigureCanvasBase:\n                     filename = filename.rstrip('.') + '.' + format\n         format = format.lower()\n \n+        if dpi is None:\n+            dpi = rcParams['savefig.dpi']\n+        if dpi == 'figure':\n+\n         if dpi is None:\n             dpi = rcParams['savefig.dpi']\n         if dpi == 'figure':\n@@ -3506,6 +3554,7 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d10f69691d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3043,6 +3043,8 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # re-initialise some of the unstored state information\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n",
    "variant_7": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..cfd81e0d40 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -2101,7 +2103,36 @@ class FigureCanvasBase:\n         # device pixel ratio changes - in this case we need to resize the\n         # canvas accordingly. Some backends provide events that indicate a\n         # change in DPI, but those that don't will update this before drawing.\n-        dpi = ratio * self.figure._original_dpi\n+\n+    def _set_device_pixel_ratio(self, ratio):\n+        \"\"\"\n+        Set the device pixel ratio for the canvas.\n+\n+        This is typically set by the backend when the canvas is embedded in a\n+        GUI window that is aware of the device pixel ratio. The canvas does\n+        not track this itself, since it can change as a window is moved\n+        between different displays.\n+\n+        Parameters\n+        ----------\n+        ratio : float\n+            The physical to logical pixel ratio, as a float greater than 0.\n+\n+        Returns\n+        -------\n+        bool\n+            Whether the ratio has changed. Backends may interpret this as a\n+            signal to resize the window, repaint the canvas, or change any\n+            other relevant properties.\n+        \"\"\"\n+        if self._device_pixel_ratio == ratio:\n+            return False\n+        # In cases with mixed resolution displays, we need to be careful if the\n+        # device pixel ratio changes - in this case we need to resize the\n+        # canvas accordingly. Some backends provide events that indicate a\n+        # change in DPI, but those that don't will update this before drawing.\n+        original_dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n+        dpi = ratio * original_dpi\n         self.figure._set_dpi(dpi, forward=False)\n         self._device_pixel_ratio = ratio\n         return True\n@@ -2278,6 +2309,10 @@ class FigureCanvasBase:\n                     filename = filename.rstrip('.') + '.' + format\n         format = format.lower()\n \n+        if dpi is None:\n+            dpi = rcParams['savefig.dpi']\n+        if dpi == 'figure':\n+\n         if dpi is None:\n             dpi = rcParams['savefig.dpi']\n         if dpi == 'figure':\n@@ -3506,6 +3541,7 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d10f69691d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3043,6 +3043,8 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # re-initialise some of the unstored state information\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n",
    "variant_8": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..c03af5ba0f 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1652,8 +1652,10 @@ class FigureCanvasBase:\n         self.mouse_grabber = None  # the Axes currently grabbing mouse\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n+\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -2101,7 +2103,34 @@ class FigureCanvasBase:\n         # device pixel ratio changes - in this case we need to resize the\n         # canvas accordingly. Some backends provide events that indicate a\n         # change in DPI, but those that don't will update this before drawing.\n-        dpi = ratio * self.figure._original_dpi\n+\n+    def _set_device_pixel_ratio(self, ratio):\n+        \"\"\"\n+        Set the device pixel ratio for the canvas.\n+\n+        This is typically set by the backend when the canvas is created, and\n+        may be updated if the device pixel ratio changes (e.g. when a window\n+        is moved between monitors with different DPIs).\n+\n+        Parameters\n+        ----------\n+        ratio : float\n+            The physical to logical pixel ratio as a float.\n+\n+        Returns\n+        -------\n+        bool\n+            Whether the ratio has changed. Backends may interpret this as a\n+            signal to resize the window, repaint the canvas, or change any\n+            other relevant properties.\n+        \"\"\"\n+        if self._device_pixel_ratio == ratio:\n+            return False\n+        # In cases with mixed resolution displays, we need to be careful if the\n+        # device pixel ratio changes - in this case we need to resize the\n+        # canvas accordingly. Some backends provide events that indicate a\n+        # change in DPI, but those that don't will update this before drawing.\n+        dpi = ratio * getattr(self.figure, '_original_dpi', self.figure.dpi)\n         self.figure._set_dpi(dpi, forward=False)\n         self._device_pixel_ratio = ratio\n         return True\n@@ -2281,6 +2310,7 @@ class FigureCanvasBase:\n         if dpi is None:\n             dpi = rcParams['savefig.dpi']\n         if dpi == 'figure':\n+\n             dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n \n         # Remove the figure manager, if any, to avoid resizing the GUI widget.\n@@ -3506,6 +3536,7 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d10f69691d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3043,6 +3043,8 @@ class Figure(FigureBase):\n \n         self.__dict__ = state\n \n+        # re-initialise some of the unstored state information\n+\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n"
  }
}