{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 1664-1668)": "\ndef __init__(self, verbose_name=None, name=None, path='', match=None,\n             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n    # Store the original path parameter (may be callable)\n    self._original_path = path\n    # Resolve path if it's callable, otherwise use as-is\n    if callable(path):\n        self.path = path()\n    else:\n        self.path = path\n    self.match, self.recursive = match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    kwargs.setdefault('max_length', 100)\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 1688-1702)": "\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        # If path was originally callable, preserve it for migrations\n        if hasattr(self, '_original_path') and callable(self._original_path):\n            kwargs['path'] = self._original_path\n        elif self.path != '':\n            kwargs['path'] = self.path\n        if self.match is not None:\n            kwargs['match'] = self.match\n        if self.recursive is not False:\n            kwargs['recursive'] = self.recursive\n        if self.allow_files is not True:\n            kwargs['allow_files'] = self.allow_files\n        if self.allow_folders is not False:\n            kwargs['allow_folders'] = self.allow_folders\n        if kwargs.get(\"max_length\") == 100:\n            del kwargs[\"max_length\"]\n        return name, path, args, kwargs\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 1710-1715)": "\n    def formfield(self, **kwargs):\n        # Resolve callable path for form field usage\n        resolved_path = self.path() if callable(self.path) else self.path\n        return super().formfield(**{\n            'path': resolved_path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n",
    "Location 4 (/root/hy/projects_4/django/django/forms/fields.py lines 1079-1085)": "\ndef __init__(self, path, *, match=None, recursive=False, allow_files=True,\n             allow_folders=False, **kwargs):\n    # Resolve callable path for form operations\n    if callable(path):\n        resolved_path = path()\n    else:\n        resolved_path = path\n    \n    self.path, self.match, self.recursive = resolved_path, match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    super().__init__(choices=(), **kwargs)\n\n    if self.required:\n        self.choices = []\n    else:\n        self.choices = [(\"\", \"---------\")]\n\n    if self.match is not None:\n        self.match_re = re.compile(self.match)\n\n    if recursive:\n        for root, dirs, files in sorted(os.walk(self.path)):\n            if self.allow_files:\n",
    "Location 5 (/root/hy/projects_4/django/django/forms/fields.py lines 1092-1120)": "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path, self.match, self.recursive = path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        # Resolve callable path for file operations\n        resolved_path = path() if callable(path) else path\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n\n        self.widget.choices = self.choices\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 1664-1668)": [
      "\n    def __init__(self, verbose_name=None, name=None, path='', match=None,\n                 recursive=False, allow_files=True, allow_folders=False, **kwargs):\n        # Store the original path parameter for migration serialization\n        self._path_callable = path if callable(path) else None\n        # Resolve callable paths for immediate use\n        resolved_path = path() if callable(path) else path\n        self.path, self.match, self.recursive = resolved_path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        kwargs.setdefault('max_length', 100)\n",
      "\ndef __init__(self, verbose_name=None, name=None, path='', match=None,\n             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n    # Store the original path (which may be callable) for migration serialization\n    self._original_path = path\n    # Resolve callable paths for immediate use\n    self.path = path() if callable(path) else path\n    self.match, self.recursive = match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    kwargs.setdefault('max_length', 100)\n",
      "\ndef __init__(self, verbose_name=None, name=None, path='', match=None,\n             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n    # Store the original path (which might be callable) for migration serialization\n    self._original_path = path\n    # Resolve callable path for immediate use\n    self.path = path() if callable(path) else path\n    self.match, self.recursive = match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    kwargs.setdefault('max_length', 100)\n",
      "\ndef __init__(self, verbose_name=None, name=None, path='', match=None,\n             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n    # Store original path (which may be callable) for migration serialization\n    self._original_path = path\n    # Resolve callable path for immediate use\n    self.path = path() if callable(path) else path\n    self.match, self.recursive = match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    kwargs.setdefault('max_length', 100)\n",
      "\ndef __init__(self, verbose_name=None, name=None, path='', match=None,\n             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n    # Store the original path (which might be callable) for migration serialization\n    self._original_path = path\n    # Resolve the path if it's callable for immediate use\n    if callable(path):\n        self.path = path()\n    else:\n        self.path = path\n    self.match, self.recursive = match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    kwargs.setdefault('max_length', 100)\n",
      "\ndef __init__(self, verbose_name=None, name=None, path='', match=None,\n             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n    # Store the original path parameter (which might be callable)\n    self._original_path = path\n    # Resolve the path if it's callable, otherwise use as-is\n    self.path = path() if callable(path) else path\n    self.match, self.recursive = match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    kwargs.setdefault('max_length', 100)\n",
      "\ndef __init__(self, verbose_name=None, name=None, path='', match=None,\n             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n    # Store the original path (which may be callable) for migration serialization\n    self._original_path = path\n    # Resolve callable paths for immediate use\n    self.path = path() if callable(path) else path\n    self.match, self.recursive = match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    kwargs.setdefault('max_length', 100)\n",
      "\ndef __init__(self, verbose_name=None, name=None, path='', match=None,\n             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n    # Store the original path (which might be callable) for deconstruct\n    self._path_callable = path if callable(path) else None\n    # Resolve callable path for immediate use\n    self.path = path() if callable(path) else path\n    self.match, self.recursive = match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    kwargs.setdefault('max_length', 100)\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 1688-1702)": [
      "\ndef deconstruct(self):\n    name, path, args, kwargs = super().deconstruct()\n    # Use the original callable path if it was provided, otherwise use resolved path\n    path_to_serialize = getattr(self, '_original_path', self.path)\n    if path_to_serialize != '':\n        kwargs['path'] = path_to_serialize\n    if self.match is not None:\n        kwargs['match'] = self.match\n    if self.recursive is not False:\n        kwargs['recursive'] = self.recursive\n    if self.allow_files is not True:\n        kwargs['allow_files'] = self.allow_files\n    if self.allow_folders is not False:\n        kwargs['allow_folders'] = self.allow_folders\n    if kwargs.get(\"max_length\") == 100:\n        del kwargs[\"max_length\"]\n    return name, path, args, kwargs\n",
      "\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        # Use the original callable path if it exists, otherwise use the resolved path\n        path_value = getattr(self, '_original_path', self.path)\n        if path_value != '':\n            kwargs['path'] = path_value\n        if self.match is not None:\n            kwargs['match'] = self.match\n        if self.recursive is not False:\n            kwargs['recursive'] = self.recursive\n        if self.allow_files is not True:\n            kwargs['allow_files'] = self.allow_files\n        if self.allow_folders is not False:\n            kwargs['allow_folders'] = self.allow_folders\n        if kwargs.get(\"max_length\") == 100:\n            del kwargs[\"max_length\"]\n        return name, path, args, kwargs\n",
      "\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        # Use original callable path if it exists, otherwise use resolved path\n        path_value = getattr(self, '_original_path', self.path)\n        if path_value != '':\n            kwargs['path'] = path_value\n        if self.match is not None:\n            kwargs['match'] = self.match\n        if self.recursive is not False:\n            kwargs['recursive'] = self.recursive\n        if self.allow_files is not True:\n            kwargs['allow_files'] = self.allow_files\n        if self.allow_folders is not False:\n            kwargs['allow_folders'] = self.allow_folders\n        if kwargs.get(\"max_length\") == 100:\n            del kwargs[\"max_length\"]\n        return name, path, args, kwargs\n",
      "\ndef deconstruct(self):\n    name, path, args, kwargs = super().deconstruct()\n    # Preserve the original callable path for migrations if it exists\n    if hasattr(self, '_original_path') and self._original_path != '':\n        kwargs['path'] = self._original_path\n    elif self.path != '':\n        kwargs['path'] = self.path\n    if self.match is not None:\n        kwargs['match'] = self.match\n    if self.recursive is not False:\n        kwargs['recursive'] = self.recursive\n    if self.allow_files is not True:\n        kwargs['allow_files'] = self.allow_files\n    if self.allow_folders is not False:\n        kwargs['allow_folders'] = self.allow_folders\n    if kwargs.get(\"max_length\") == 100:\n        del kwargs[\"max_length\"]\n    return name, path, args, kwargs\n",
      "\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        # Use the original callable path if it exists, otherwise use the resolved path\n        path_value = getattr(self, '_original_path', self.path)\n        if path_value != '':\n            kwargs['path'] = path_value\n        if self.match is not None:\n            kwargs['match'] = self.match\n        if self.recursive is not False:\n            kwargs['recursive'] = self.recursive\n        if self.allow_files is not True:\n            kwargs['allow_files'] = self.allow_files\n        if self.allow_folders is not False:\n            kwargs['allow_folders'] = self.allow_folders\n        if kwargs.get(\"max_length\") == 100:\n            del kwargs[\"max_length\"]\n        return name, path, args, kwargs\n",
      "\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        # Use original callable path if it exists, otherwise use resolved path\n        if hasattr(self, '_original_path') and self._original_path is not None:\n            kwargs['path'] = self._original_path\n        elif self.path != '':\n            kwargs['path'] = self.path\n        if self.match is not None:\n            kwargs['match'] = self.match\n        if self.recursive is not False:\n            kwargs['recursive'] = self.recursive\n        if self.allow_files is not True:\n            kwargs['allow_files'] = self.allow_files\n        if self.allow_folders is not False:\n            kwargs['allow_folders'] = self.allow_folders\n        if kwargs.get(\"max_length\") == 100:\n            del kwargs[\"max_length\"]\n        return name, path, args, kwargs\n",
      "\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        # Use the original callable path if it exists, otherwise use the resolved path\n        path_value = getattr(self, '_original_path', self.path)\n        if path_value != '':\n            kwargs['path'] = path_value\n        if self.match is not None:\n            kwargs['match'] = self.match\n        if self.recursive is not False:\n            kwargs['recursive'] = self.recursive\n        if self.allow_files is not True:\n            kwargs['allow_files'] = self.allow_files\n        if self.allow_folders is not False:\n            kwargs['allow_folders'] = self.allow_folders\n        if kwargs.get(\"max_length\") == 100:\n            del kwargs[\"max_length\"]\n        return name, path, args, kwargs\n",
      "\n    def deconstruct(self):\n        name, path, args, kwargs = super().deconstruct()\n        # Use the original callable path if it was provided, otherwise use the resolved path\n        original_path = getattr(self, '_original_path', self.path)\n        if original_path != '':\n            kwargs['path'] = original_path\n        if self.match is not None:\n            kwargs['match'] = self.match\n        if self.recursive is not False:\n            kwargs['recursive'] = self.recursive\n        if self.allow_files is not True:\n            kwargs['allow_files'] = self.allow_files\n        if self.allow_folders is not False:\n            kwargs['allow_folders'] = self.allow_folders\n        if kwargs.get(\"max_length\") == 100:\n            del kwargs[\"max_length\"]\n        return name, path, args, kwargs\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 1710-1715)": [
      "\ndef formfield(self, **kwargs):\n    # Resolve callable path for form field usage\n    resolved_path = self.path() if callable(self.path) else self.path\n    return super().formfield(**{\n        'path': resolved_path,\n        'match': self.match,\n        'recursive': self.recursive,\n        'form_class': forms.FilePathField,\n        'allow_files': self.allow_files,\n        'allow_folders': self.allow_folders,\n        **kwargs,\n    })\n",
      "\n    def formfield(self, **kwargs):\n        # Resolve callable path for form field since forms need actual paths\n        resolved_path = self.path() if callable(self.path) else self.path\n        return super().formfield(**{\n            'path': resolved_path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n",
      "\ndef formfield(self, **kwargs):\n    # Resolve callable path for form field operations\n    resolved_path = self.path() if callable(self.path) else self.path\n    return super().formfield(**{\n        'path': resolved_path,\n        'match': self.match,\n        'recursive': self.recursive,\n        'form_class': forms.FilePathField,\n        'allow_files': self.allow_files,\n        'allow_folders': self.allow_folders,\n        **kwargs,\n    })\n",
      "\ndef formfield(self, **kwargs):\n    # Resolve callable path for form field use\n    resolved_path = self.path() if callable(self.path) else self.path\n    return super().formfield(**{\n        'path': resolved_path,\n        'match': self.match,\n        'recursive': self.recursive,\n        'form_class': forms.FilePathField,\n        'allow_files': self.allow_files,\n        'allow_folders': self.allow_folders,\n        **kwargs,\n    })\n",
      "\n    def formfield(self, **kwargs):\n        # Resolve callable path for form field usage\n        resolved_path = self.path() if callable(self.path) else self.path\n        return super().formfield(**{\n            'path': resolved_path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n",
      "\n    def formfield(self, **kwargs):\n        # Resolve callable path for form field usage\n        resolved_path = self.path() if callable(self.path) else self.path\n        return super().formfield(**{\n            'path': resolved_path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n",
      "\n    def formfield(self, **kwargs):\n        # Resolve callable path for form field usage\n        resolved_path = self.path() if callable(self.path) else self.path\n        return super().formfield(**{\n            'path': resolved_path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n",
      "\ndef formfield(self, **kwargs):\n    # Resolve callable path for form field usage\n    resolved_path = self.path() if callable(self.path) else self.path\n    return super().formfield(**{\n        'path': resolved_path,\n        'match': self.match,\n        'recursive': self.recursive,\n        'form_class': forms.FilePathField,\n        'allow_files': self.allow_files,\n        'allow_folders': self.allow_folders,\n        **kwargs,\n    })\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/forms/fields.py lines 1079-1085)": [
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        # Resolve callable path for file system operations\n        resolved_path = path() if callable(path) else path\n        self.path, self.match, self.recursive = resolved_path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        # Resolve callable path for file system operations\n        if callable(path):\n            resolved_path = path()\n        else:\n            resolved_path = path\n        \n        self.path, self.match, self.recursive = resolved_path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        # Resolve callable path for file system operations\n        if callable(path):\n            resolved_path = path()\n        else:\n            resolved_path = path\n        \n        self.path, self.match, self.recursive = resolved_path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n",
      "\ndef __init__(self, path, *, match=None, recursive=False, allow_files=True,\n             allow_folders=False, **kwargs):\n    # Resolve callable path for form field operations\n    if callable(path):\n        resolved_path = path()\n    else:\n        resolved_path = path\n    \n    self.path, self.match, self.recursive = resolved_path, match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    super().__init__(choices=(), **kwargs)\n\n    if self.required:\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        # Resolve callable path for file system operations\n        resolved_path = path() if callable(path) else path\n        self.path, self.match, self.recursive = resolved_path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        # Resolve callable path for file operations\n        if callable(path):\n            resolved_path = path()\n        else:\n            resolved_path = path\n        \n        self.path, self.match, self.recursive = resolved_path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n",
      "\ndef __init__(self, path, *, match=None, recursive=False, allow_files=True,\n             allow_folders=False, **kwargs):\n    # Resolve callable path for file operations\n    resolved_path = path() if callable(path) else path\n    self.path, self.match, self.recursive = resolved_path, match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    super().__init__(choices=(), **kwargs)\n\n    if self.required:\n        self.choices = []\n    else:\n        self.choices = [(\"\", \"---------\")]\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        # Resolve callable path for immediate use\n        resolved_path = path() if callable(path) else path\n        self.path, self.match, self.recursive = resolved_path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/forms/fields.py lines 1092-1120)": [
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        self.match, self.recursive = match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        # Resolve callable path for file system operations\n        resolved_path = path() if callable(path) else path\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n\n        self.widget.choices = self.choices\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        # Resolve callable path for file system operations\n        resolved_path = path() if callable(path) else path\n        self.match, self.recursive = match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n\n        self.widget.choices = self.choices\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        self.match, self.recursive = match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        # Resolve callable path for file system operations\n        resolved_path = path() if callable(path) else path\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n\n        self.widget.choices = self.choices\n",
      "\n    def __init__(self, path, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        # Resolve callable path for actual file operations\n        resolved_path = path() if callable(path) else path\n        self.resolved_path = os.fspath(resolved_path)\n        self.match, self.recursive = match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Use resolved_path for all file system operations\n        if recursive:\n            for root, dirs, files in sorted(os.walk(self.resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(self.resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(self.resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(self.resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n\n        self.widget.choices = self.choices\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        self.match, self.recursive = match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        # Resolve callable path for file operations\n        resolved_path = path() if callable(path) else path\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n\n        self.widget.choices = self.choices\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        self.match, self.recursive = match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Resolve callable path for file system operations\n        resolved_path = self.path() if callable(self.path) else self.path\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n\n        self.widget.choices = self.choices\n",
      "\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        \n        # Resolve callable path for file system operations\n        if callable(path):\n            resolved_path = path()\n        else:\n            resolved_path = path\n        \n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n\n        self.widget.choices = self.choices\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        self.match, self.recursive = match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        # Resolve callable path for file operations\n        resolved_path = path() if callable(path) else path\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n\n        self.widget.choices = self.choices\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..e0fc82181e 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1661,9 +1661,14 @@ class EmailField(CharField):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n+\n     def __init__(self, verbose_name=None, name=None, path='', match=None,\n                  recursive=False, allow_files=True, allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        # Store the original path (which might be callable) for migrations\n+        self._path = path\n+        # Store the resolved path for immediate use\n+        self.path = path() if callable(path) else path\n+        self.match, self.recursive = match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n@@ -1685,10 +1690,12 @@ class FilePathField(Field):\n             ]\n         return []\n \n+\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n-            kwargs['path'] = self.path\n+        # Use the original path (callable or string) for migrations\n+        if self._path != '':\n+            kwargs['path'] = self._path\n         if self.match is not None:\n             kwargs['match'] = self.match\n         if self.recursive is not False:\n@@ -1707,9 +1714,10 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': self.path,  # Use resolved path for form field\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..57d052b0c2 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,9 +1076,12 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        # Resolve callable path before storing\n+        resolved_path = path() if callable(path) else path\n+        self.path, self.match, self.recursive = resolved_path, match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)\n \n@@ -1090,20 +1093,21 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+\n         if recursive:\n             for root, dirs, files in sorted(os.walk(self.path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(self.path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(self.path, \"\", 1)))\n         else:\n             choices = []\n             for f in os.scandir(self.path):\n@@ -1118,7 +1122,6 @@ class FilePathField(ChoiceField):\n \n         self.widget.choices = self.choices\n \n-\n class SplitDateTimeField(MultiValueField):\n     widget = SplitDateTimeWidget\n     hidden_widget = SplitHiddenDateTimeWidget\n",
    "variant_0": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..5d6a1c05ae 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1661,11 +1661,19 @@ class EmailField(CharField):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n-    def __init__(self, verbose_name=None, name=None, path='', match=None,\n-                 recursive=False, allow_files=True, allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n-        self.allow_files, self.allow_folders = allow_files, allow_folders\n-        kwargs.setdefault('max_length', 100)\n+\n+def __init__(self, verbose_name=None, name=None, path='', match=None,\n+             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n+    # Store the original path parameter (may be callable)\n+    self._original_path = path\n+    # Resolve path if it's callable, otherwise use as-is\n+    if callable(path):\n+        self.path = path()\n+    else:\n+        self.path = path\n+    self.match, self.recursive = match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n     def check(self, **kwargs):\n@@ -1685,9 +1693,13 @@ class FilePathField(Field):\n             ]\n         return []\n \n+\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n+        # If path was originally callable, preserve it for migrations\n+        if hasattr(self, '_original_path') and callable(self._original_path):\n+            kwargs['path'] = self._original_path\n+        elif self.path != '':\n             kwargs['path'] = self.path\n         if self.match is not None:\n             kwargs['match'] = self.match\n@@ -1707,9 +1719,12 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n+        # Resolve callable path for form field usage\n+        resolved_path = self.path() if callable(self.path) else self.path\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': resolved_path,\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,\n@@ -1717,6 +1732,10 @@ class FilePathField(Field):\n             'allow_folders': self.allow_folders,\n             **kwargs,\n         })\n+            'allow_files': self.allow_files,\n+            'allow_folders': self.allow_folders,\n+            **kwargs,\n+        })\n \n     def get_internal_type(self):\n         return \"FilePathField\"\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..a68765d9be 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,6 +1076,37 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n+def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+             allow_folders=False, **kwargs):\n+    # Resolve callable path for form operations\n+    if callable(path):\n+        resolved_path = path()\n+    else:\n+        resolved_path = path\n+    \n+    self.path, self.match, self.recursive = resolved_path, match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    super().__init__(choices=(), **kwargs)\n+\n+    if self.required:\n+        self.choices = []\n+    else:\n+        self.choices = [(\"\", \"---------\")]\n+\n+    if self.match is not None:\n+        self.match_re = re.compile(self.match)\n+\n+    if recursive:\n+        for root, dirs, files in sorted(os.walk(self.path)):\n+            if self.allow_files:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n         self.path, self.match, self.recursive = path, match, recursive\n@@ -1087,26 +1118,29 @@ class FilePathField(ChoiceField):\n         else:\n             self.choices = [(\"\", \"---------\")]\n \n+        # Resolve callable path for file operations\n+        resolved_path = path() if callable(path) else path\n+\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1118,7 +1152,6 @@ class FilePathField(ChoiceField):\n \n         self.widget.choices = self.choices\n \n-\n class SplitDateTimeField(MultiValueField):\n     widget = SplitDateTimeWidget\n     hidden_widget = SplitHiddenDateTimeWidget\n",
    "variant_1": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..0c872e3751 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1661,9 +1661,14 @@ class EmailField(CharField):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n+\n     def __init__(self, verbose_name=None, name=None, path='', match=None,\n                  recursive=False, allow_files=True, allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        # Store the original path parameter for migration serialization\n+        self._path_callable = path if callable(path) else None\n+        # Resolve callable paths for immediate use\n+        resolved_path = path() if callable(path) else path\n+        self.path, self.match, self.recursive = resolved_path, match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n@@ -1685,21 +1690,24 @@ class FilePathField(Field):\n             ]\n         return []\n \n-    def deconstruct(self):\n-        name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n-            kwargs['path'] = self.path\n-        if self.match is not None:\n-            kwargs['match'] = self.match\n-        if self.recursive is not False:\n-            kwargs['recursive'] = self.recursive\n-        if self.allow_files is not True:\n-            kwargs['allow_files'] = self.allow_files\n-        if self.allow_folders is not False:\n-            kwargs['allow_folders'] = self.allow_folders\n-        if kwargs.get(\"max_length\") == 100:\n-            del kwargs[\"max_length\"]\n-        return name, path, args, kwargs\n+\n+def deconstruct(self):\n+    name, path, args, kwargs = super().deconstruct()\n+    # Use the original callable path if it was provided, otherwise use resolved path\n+    path_to_serialize = getattr(self, '_original_path', self.path)\n+    if path_to_serialize != '':\n+        kwargs['path'] = path_to_serialize\n+    if self.match is not None:\n+        kwargs['match'] = self.match\n+    if self.recursive is not False:\n+        kwargs['recursive'] = self.recursive\n+    if self.allow_files is not True:\n+        kwargs['allow_files'] = self.allow_files\n+    if self.allow_folders is not False:\n+        kwargs['allow_folders'] = self.allow_folders\n+    if kwargs.get(\"max_length\") == 100:\n+        del kwargs[\"max_length\"]\n+    return name, path, args, kwargs\n \n     def get_prep_value(self, value):\n         value = super().get_prep_value(value)\n@@ -1707,12 +1715,19 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n-    def formfield(self, **kwargs):\n-        return super().formfield(**{\n-            'path': self.path,\n-            'match': self.match,\n-            'recursive': self.recursive,\n-            'form_class': forms.FilePathField,\n+\n+def formfield(self, **kwargs):\n+    # Resolve callable path for form field usage\n+    resolved_path = self.path() if callable(self.path) else self.path\n+    return super().formfield(**{\n+        'path': resolved_path,\n+        'match': self.match,\n+        'recursive': self.recursive,\n+        'form_class': forms.FilePathField,\n+        'allow_files': self.allow_files,\n+        'allow_folders': self.allow_folders,\n+        **kwargs,\n+    })\n             'allow_files': self.allow_files,\n             'allow_folders': self.allow_folders,\n             **kwargs,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..7ae7421ae3 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,9 +1076,27 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n+    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+                 allow_folders=False, **kwargs):\n+        # Resolve callable path for file system operations\n+        resolved_path = path() if callable(path) else path\n+        self.path, self.match, self.recursive = resolved_path, match, recursive\n+        self.allow_files, self.allow_folders = allow_files, allow_folders\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        self.path = path\n+        self.match, self.recursive = match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)\n \n@@ -1087,26 +1105,29 @@ class FilePathField(ChoiceField):\n         else:\n             self.choices = [(\"\", \"---------\")]\n \n+        # Resolve callable path for file system operations\n+        resolved_path = path() if callable(path) else path\n+\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1118,7 +1139,6 @@ class FilePathField(ChoiceField):\n \n         self.widget.choices = self.choices\n \n-\n class SplitDateTimeField(MultiValueField):\n     widget = SplitDateTimeWidget\n     hidden_widget = SplitHiddenDateTimeWidget\n",
    "variant_2": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..728d95bd47 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1661,11 +1661,16 @@ class EmailField(CharField):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n-    def __init__(self, verbose_name=None, name=None, path='', match=None,\n-                 recursive=False, allow_files=True, allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n-        self.allow_files, self.allow_folders = allow_files, allow_folders\n-        kwargs.setdefault('max_length', 100)\n+\n+def __init__(self, verbose_name=None, name=None, path='', match=None,\n+             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n+    # Store the original path (which may be callable) for migration serialization\n+    self._original_path = path\n+    # Resolve callable paths for immediate use\n+    self.path = path() if callable(path) else path\n+    self.match, self.recursive = match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n     def check(self, **kwargs):\n@@ -1685,10 +1690,13 @@ class FilePathField(Field):\n             ]\n         return []\n \n+\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n-            kwargs['path'] = self.path\n+        # Use the original callable path if it exists, otherwise use the resolved path\n+        path_value = getattr(self, '_original_path', self.path)\n+        if path_value != '':\n+            kwargs['path'] = path_value\n         if self.match is not None:\n             kwargs['match'] = self.match\n         if self.recursive is not False:\n@@ -1707,9 +1715,12 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n+        # Resolve callable path for form field since forms need actual paths\n+        resolved_path = self.path() if callable(self.path) else self.path\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': resolved_path,\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,\n@@ -1717,6 +1728,10 @@ class FilePathField(Field):\n             'allow_folders': self.allow_folders,\n             **kwargs,\n         })\n+            'allow_files': self.allow_files,\n+            'allow_folders': self.allow_folders,\n+            **kwargs,\n+        })\n \n     def get_internal_type(self):\n         return \"FilePathField\"\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..2cc187a845 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,9 +1076,33 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n+    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+                 allow_folders=False, **kwargs):\n+        # Resolve callable path for file system operations\n+        if callable(path):\n+            resolved_path = path()\n+        else:\n+            resolved_path = path\n+        \n+        self.path, self.match, self.recursive = resolved_path, match, recursive\n+        self.allow_files, self.allow_folders = allow_files, allow_folders\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        self.path = path\n+        # Resolve callable path for file system operations\n+        resolved_path = path() if callable(path) else path\n+        self.match, self.recursive = match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)\n \n@@ -1091,22 +1115,22 @@ class FilePathField(ChoiceField):\n             self.match_re = re.compile(self.match)\n \n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1118,7 +1142,6 @@ class FilePathField(ChoiceField):\n \n         self.widget.choices = self.choices\n \n-\n class SplitDateTimeField(MultiValueField):\n     widget = SplitDateTimeWidget\n     hidden_widget = SplitHiddenDateTimeWidget\n",
    "variant_3": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..2dbdc889d8 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1661,11 +1661,16 @@ class EmailField(CharField):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n-    def __init__(self, verbose_name=None, name=None, path='', match=None,\n-                 recursive=False, allow_files=True, allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n-        self.allow_files, self.allow_folders = allow_files, allow_folders\n-        kwargs.setdefault('max_length', 100)\n+\n+def __init__(self, verbose_name=None, name=None, path='', match=None,\n+             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n+    # Store the original path (which might be callable) for migration serialization\n+    self._original_path = path\n+    # Resolve callable path for immediate use\n+    self.path = path() if callable(path) else path\n+    self.match, self.recursive = match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n     def check(self, **kwargs):\n@@ -1685,10 +1690,13 @@ class FilePathField(Field):\n             ]\n         return []\n \n+\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n-            kwargs['path'] = self.path\n+        # Use original callable path if it exists, otherwise use resolved path\n+        path_value = getattr(self, '_original_path', self.path)\n+        if path_value != '':\n+            kwargs['path'] = path_value\n         if self.match is not None:\n             kwargs['match'] = self.match\n         if self.recursive is not False:\n@@ -1707,12 +1715,19 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n-    def formfield(self, **kwargs):\n-        return super().formfield(**{\n-            'path': self.path,\n-            'match': self.match,\n-            'recursive': self.recursive,\n-            'form_class': forms.FilePathField,\n+\n+def formfield(self, **kwargs):\n+    # Resolve callable path for form field operations\n+    resolved_path = self.path() if callable(self.path) else self.path\n+    return super().formfield(**{\n+        'path': resolved_path,\n+        'match': self.match,\n+        'recursive': self.recursive,\n+        'form_class': forms.FilePathField,\n+        'allow_files': self.allow_files,\n+        'allow_folders': self.allow_folders,\n+        **kwargs,\n+    })\n             'allow_files': self.allow_files,\n             'allow_folders': self.allow_folders,\n             **kwargs,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..5ce861bc4e 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,9 +1076,16 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        # Resolve callable path for file system operations\n+        if callable(path):\n+            resolved_path = path()\n+        else:\n+            resolved_path = path\n+        \n+        self.path, self.match, self.recursive = resolved_path, match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)\n \n@@ -1090,23 +1097,41 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+                 allow_folders=False, **kwargs):\n+        self.path = path\n+        self.match, self.recursive = match, recursive\n+        self.allow_files, self.allow_folders = allow_files, allow_folders\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        # Resolve callable path for file system operations\n+        resolved_path = path() if callable(path) else path\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1118,7 +1143,6 @@ class FilePathField(ChoiceField):\n \n         self.widget.choices = self.choices\n \n-\n class SplitDateTimeField(MultiValueField):\n     widget = SplitDateTimeWidget\n     hidden_widget = SplitHiddenDateTimeWidget\n",
    "variant_4": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..994de6a889 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1661,11 +1661,16 @@ class EmailField(CharField):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n-    def __init__(self, verbose_name=None, name=None, path='', match=None,\n-                 recursive=False, allow_files=True, allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n-        self.allow_files, self.allow_folders = allow_files, allow_folders\n-        kwargs.setdefault('max_length', 100)\n+\n+def __init__(self, verbose_name=None, name=None, path='', match=None,\n+             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n+    # Store original path (which may be callable) for migration serialization\n+    self._original_path = path\n+    # Resolve callable path for immediate use\n+    self.path = path() if callable(path) else path\n+    self.match, self.recursive = match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n     def check(self, **kwargs):\n@@ -1685,21 +1690,25 @@ class FilePathField(Field):\n             ]\n         return []\n \n-    def deconstruct(self):\n-        name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n-            kwargs['path'] = self.path\n-        if self.match is not None:\n-            kwargs['match'] = self.match\n-        if self.recursive is not False:\n-            kwargs['recursive'] = self.recursive\n-        if self.allow_files is not True:\n-            kwargs['allow_files'] = self.allow_files\n-        if self.allow_folders is not False:\n-            kwargs['allow_folders'] = self.allow_folders\n-        if kwargs.get(\"max_length\") == 100:\n-            del kwargs[\"max_length\"]\n-        return name, path, args, kwargs\n+\n+def deconstruct(self):\n+    name, path, args, kwargs = super().deconstruct()\n+    # Preserve the original callable path for migrations if it exists\n+    if hasattr(self, '_original_path') and self._original_path != '':\n+        kwargs['path'] = self._original_path\n+    elif self.path != '':\n+        kwargs['path'] = self.path\n+    if self.match is not None:\n+        kwargs['match'] = self.match\n+    if self.recursive is not False:\n+        kwargs['recursive'] = self.recursive\n+    if self.allow_files is not True:\n+        kwargs['allow_files'] = self.allow_files\n+    if self.allow_folders is not False:\n+        kwargs['allow_folders'] = self.allow_folders\n+    if kwargs.get(\"max_length\") == 100:\n+        del kwargs[\"max_length\"]\n+    return name, path, args, kwargs\n \n     def get_prep_value(self, value):\n         value = super().get_prep_value(value)\n@@ -1707,12 +1716,19 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n-    def formfield(self, **kwargs):\n-        return super().formfield(**{\n-            'path': self.path,\n-            'match': self.match,\n-            'recursive': self.recursive,\n-            'form_class': forms.FilePathField,\n+\n+def formfield(self, **kwargs):\n+    # Resolve callable path for form field use\n+    resolved_path = self.path() if callable(self.path) else self.path\n+    return super().formfield(**{\n+        'path': resolved_path,\n+        'match': self.match,\n+        'recursive': self.recursive,\n+        'form_class': forms.FilePathField,\n+        'allow_files': self.allow_files,\n+        'allow_folders': self.allow_folders,\n+        **kwargs,\n+    })\n             'allow_files': self.allow_files,\n             'allow_folders': self.allow_folders,\n             **kwargs,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..b1d9a62c9f 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,9 +1076,34 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n-    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+\n+def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+             allow_folders=False, **kwargs):\n+    # Resolve callable path for form field operations\n+    if callable(path):\n+        resolved_path = path()\n+    else:\n+        resolved_path = path\n+    \n+    self.path, self.match, self.recursive = resolved_path, match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    super().__init__(choices=(), **kwargs)\n+\n+    if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n+    def __init__(self, path, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        self.path = path\n+        # Resolve callable path for actual file operations\n+        resolved_path = path() if callable(path) else path\n+        self.resolved_path = os.fspath(resolved_path)\n+        self.match, self.recursive = match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)\n \n@@ -1090,23 +1115,24 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Use resolved_path for all file system operations\n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(self.resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(self.resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(self.resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(self.resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1118,7 +1144,6 @@ class FilePathField(ChoiceField):\n \n         self.widget.choices = self.choices\n \n-\n class SplitDateTimeField(MultiValueField):\n     widget = SplitDateTimeWidget\n     hidden_widget = SplitHiddenDateTimeWidget\n",
    "variant_5": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..b305780209 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1661,11 +1661,19 @@ class EmailField(CharField):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n-    def __init__(self, verbose_name=None, name=None, path='', match=None,\n-                 recursive=False, allow_files=True, allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n-        self.allow_files, self.allow_folders = allow_files, allow_folders\n-        kwargs.setdefault('max_length', 100)\n+\n+def __init__(self, verbose_name=None, name=None, path='', match=None,\n+             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n+    # Store the original path (which might be callable) for migration serialization\n+    self._original_path = path\n+    # Resolve the path if it's callable for immediate use\n+    if callable(path):\n+        self.path = path()\n+    else:\n+        self.path = path\n+    self.match, self.recursive = match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n     def check(self, **kwargs):\n@@ -1685,10 +1693,13 @@ class FilePathField(Field):\n             ]\n         return []\n \n+\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n-            kwargs['path'] = self.path\n+        # Use the original callable path if it exists, otherwise use the resolved path\n+        path_value = getattr(self, '_original_path', self.path)\n+        if path_value != '':\n+            kwargs['path'] = path_value\n         if self.match is not None:\n             kwargs['match'] = self.match\n         if self.recursive is not False:\n@@ -1707,9 +1718,12 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n+        # Resolve callable path for form field usage\n+        resolved_path = self.path() if callable(self.path) else self.path\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': resolved_path,\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,\n@@ -1717,6 +1731,10 @@ class FilePathField(Field):\n             'allow_folders': self.allow_folders,\n             **kwargs,\n         })\n+            'allow_files': self.allow_files,\n+            'allow_folders': self.allow_folders,\n+            **kwargs,\n+        })\n \n     def get_internal_type(self):\n         return \"FilePathField\"\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..39829523d2 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,9 +1076,27 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n+    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+                 allow_folders=False, **kwargs):\n+        # Resolve callable path for file system operations\n+        resolved_path = path() if callable(path) else path\n+        self.path, self.match, self.recursive = resolved_path, match, recursive\n+        self.allow_files, self.allow_folders = allow_files, allow_folders\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        self.path = path\n+        self.match, self.recursive = match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)\n \n@@ -1087,26 +1105,29 @@ class FilePathField(ChoiceField):\n         else:\n             self.choices = [(\"\", \"---------\")]\n \n+        # Resolve callable path for file operations\n+        resolved_path = path() if callable(path) else path\n+\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1118,7 +1139,6 @@ class FilePathField(ChoiceField):\n \n         self.widget.choices = self.choices\n \n-\n class SplitDateTimeField(MultiValueField):\n     widget = SplitDateTimeWidget\n     hidden_widget = SplitHiddenDateTimeWidget\n",
    "variant_6": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..605042dc15 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1661,11 +1661,16 @@ class EmailField(CharField):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n-    def __init__(self, verbose_name=None, name=None, path='', match=None,\n-                 recursive=False, allow_files=True, allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n-        self.allow_files, self.allow_folders = allow_files, allow_folders\n-        kwargs.setdefault('max_length', 100)\n+\n+def __init__(self, verbose_name=None, name=None, path='', match=None,\n+             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n+    # Store the original path parameter (which might be callable)\n+    self._original_path = path\n+    # Resolve the path if it's callable, otherwise use as-is\n+    self.path = path() if callable(path) else path\n+    self.match, self.recursive = match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n     def check(self, **kwargs):\n@@ -1685,9 +1690,13 @@ class FilePathField(Field):\n             ]\n         return []\n \n+\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n+        # Use original callable path if it exists, otherwise use resolved path\n+        if hasattr(self, '_original_path') and self._original_path is not None:\n+            kwargs['path'] = self._original_path\n+        elif self.path != '':\n             kwargs['path'] = self.path\n         if self.match is not None:\n             kwargs['match'] = self.match\n@@ -1707,9 +1716,12 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n+        # Resolve callable path for form field usage\n+        resolved_path = self.path() if callable(self.path) else self.path\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': resolved_path,\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,\n@@ -1717,6 +1729,10 @@ class FilePathField(Field):\n             'allow_folders': self.allow_folders,\n             **kwargs,\n         })\n+            'allow_files': self.allow_files,\n+            'allow_folders': self.allow_folders,\n+            **kwargs,\n+        })\n \n     def get_internal_type(self):\n         return \"FilePathField\"\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..236b2cc54e 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,9 +1076,16 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        # Resolve callable path for file operations\n+        if callable(path):\n+            resolved_path = path()\n+        else:\n+            resolved_path = path\n+        \n+        self.path, self.match, self.recursive = resolved_path, match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)\n \n@@ -1090,23 +1097,41 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+                 allow_folders=False, **kwargs):\n+        self.path = path\n+        self.match, self.recursive = match, recursive\n+        self.allow_files, self.allow_folders = allow_files, allow_folders\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n+        # Resolve callable path for file system operations\n+        resolved_path = self.path() if callable(self.path) else self.path\n+\n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1118,7 +1143,6 @@ class FilePathField(ChoiceField):\n \n         self.widget.choices = self.choices\n \n-\n class SplitDateTimeField(MultiValueField):\n     widget = SplitDateTimeWidget\n     hidden_widget = SplitHiddenDateTimeWidget\n",
    "variant_7": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..7f2584e352 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1661,11 +1661,16 @@ class EmailField(CharField):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n-    def __init__(self, verbose_name=None, name=None, path='', match=None,\n-                 recursive=False, allow_files=True, allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n-        self.allow_files, self.allow_folders = allow_files, allow_folders\n-        kwargs.setdefault('max_length', 100)\n+\n+def __init__(self, verbose_name=None, name=None, path='', match=None,\n+             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n+    # Store the original path (which may be callable) for migration serialization\n+    self._original_path = path\n+    # Resolve callable paths for immediate use\n+    self.path = path() if callable(path) else path\n+    self.match, self.recursive = match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n     def check(self, **kwargs):\n@@ -1685,10 +1690,13 @@ class FilePathField(Field):\n             ]\n         return []\n \n+\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n-            kwargs['path'] = self.path\n+        # Use the original callable path if it exists, otherwise use the resolved path\n+        path_value = getattr(self, '_original_path', self.path)\n+        if path_value != '':\n+            kwargs['path'] = path_value\n         if self.match is not None:\n             kwargs['match'] = self.match\n         if self.recursive is not False:\n@@ -1707,9 +1715,12 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n+        # Resolve callable path for form field usage\n+        resolved_path = self.path() if callable(self.path) else self.path\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': resolved_path,\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..e6147f581c 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,10 +1076,34 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n-    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n-                 allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+\n+def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+             allow_folders=False, **kwargs):\n+    # Resolve callable path for file operations\n+    resolved_path = path() if callable(path) else path\n+    self.path, self.match, self.recursive = resolved_path, match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    super().__init__(choices=(), **kwargs)\n+\n+    if self.required:\n+        self.choices = []\n+    else:\n+        self.choices = [(\"\", \"---------\")]\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n+        \n+        # Resolve callable path for file system operations\n+        if callable(path):\n+            resolved_path = path()\n+        else:\n+            resolved_path = path\n+        \n         super().__init__(choices=(), **kwargs)\n \n         if self.required:\n@@ -1091,22 +1115,22 @@ class FilePathField(ChoiceField):\n             self.match_re = re.compile(self.match)\n \n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1118,7 +1142,6 @@ class FilePathField(ChoiceField):\n \n         self.widget.choices = self.choices\n \n-\n class SplitDateTimeField(MultiValueField):\n     widget = SplitDateTimeWidget\n     hidden_widget = SplitHiddenDateTimeWidget\n",
    "variant_8": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..a58cbec1db 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1661,11 +1661,16 @@ class EmailField(CharField):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n-    def __init__(self, verbose_name=None, name=None, path='', match=None,\n-                 recursive=False, allow_files=True, allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n-        self.allow_files, self.allow_folders = allow_files, allow_folders\n-        kwargs.setdefault('max_length', 100)\n+\n+def __init__(self, verbose_name=None, name=None, path='', match=None,\n+             recursive=False, allow_files=True, allow_folders=False, **kwargs):\n+    # Store the original path (which might be callable) for deconstruct\n+    self._path_callable = path if callable(path) else None\n+    # Resolve callable path for immediate use\n+    self.path = path() if callable(path) else path\n+    self.match, self.recursive = match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n     def check(self, **kwargs):\n@@ -1685,10 +1690,13 @@ class FilePathField(Field):\n             ]\n         return []\n \n+\n     def deconstruct(self):\n         name, path, args, kwargs = super().deconstruct()\n-        if self.path != '':\n-            kwargs['path'] = self.path\n+        # Use the original callable path if it was provided, otherwise use the resolved path\n+        original_path = getattr(self, '_original_path', self.path)\n+        if original_path != '':\n+            kwargs['path'] = original_path\n         if self.match is not None:\n             kwargs['match'] = self.match\n         if self.recursive is not False:\n@@ -1707,12 +1715,19 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n-    def formfield(self, **kwargs):\n-        return super().formfield(**{\n-            'path': self.path,\n-            'match': self.match,\n-            'recursive': self.recursive,\n-            'form_class': forms.FilePathField,\n+\n+def formfield(self, **kwargs):\n+    # Resolve callable path for form field usage\n+    resolved_path = self.path() if callable(self.path) else self.path\n+    return super().formfield(**{\n+        'path': resolved_path,\n+        'match': self.match,\n+        'recursive': self.recursive,\n+        'form_class': forms.FilePathField,\n+        'allow_files': self.allow_files,\n+        'allow_folders': self.allow_folders,\n+        **kwargs,\n+    })\n             'allow_files': self.allow_files,\n             'allow_folders': self.allow_folders,\n             **kwargs,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..7875c986da 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,9 +1076,27 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n+    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+                 allow_folders=False, **kwargs):\n+        # Resolve callable path for immediate use\n+        resolved_path = path() if callable(path) else path\n+        self.path, self.match, self.recursive = resolved_path, match, recursive\n+        self.allow_files, self.allow_folders = allow_files, allow_folders\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        self.path = path\n+        self.match, self.recursive = match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)\n \n@@ -1087,26 +1105,29 @@ class FilePathField(ChoiceField):\n         else:\n             self.choices = [(\"\", \"---------\")]\n \n+        # Resolve callable path for file operations\n+        resolved_path = path() if callable(path) else path\n+\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1118,7 +1139,6 @@ class FilePathField(ChoiceField):\n \n         self.widget.choices = self.choices\n \n-\n class SplitDateTimeField(MultiValueField):\n     widget = SplitDateTimeWidget\n     hidden_widget = SplitHiddenDateTimeWidget\n"
  }
}