{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1272-1275)": "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1294-1301)": "\n                def local_setter(field, related_obj, obj):\n                    # Set the reverse FK/M2M on the related object to point to obj\n                    field.set_cached_value(related_obj, obj)\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1280-1290)": "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
    "Location 4 (/root/hy/projects_4/django/django/db/models/query.py lines 131-134)": "\n            def local_setter(obj, from_obj):\n                # Avoid overwriting objects loaded by, e.g., select_related().\n                if final_field.is_cached(obj):\n                    return\n                final_field.set_cached_value(obj, from_obj)\n",
    "Location 5 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 1574-1603)": "\n    def add_filtered_relation(self, filtered_relation, alias):\n        filtered_relation.alias = alias\n        lookups = dict(get_children_from_q(filtered_relation.condition))\n        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n            filtered_relation.relation_name\n        )\n        if relation_lookup_parts:\n            raise ValueError(\n                \"FilteredRelation's relation_name cannot contain lookups \"\n                \"(got %r).\" % filtered_relation.relation_name\n            )\n        for lookup in chain(lookups):\n            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n            shift = 2 if not lookup_parts else 1\n            lookup_field_path = lookup_field_parts[:-shift]\n            for idx, lookup_field_part in enumerate(lookup_field_path):\n                if len(relation_field_parts) > idx:\n                    if relation_field_parts[idx] != lookup_field_part:\n                        raise ValueError(\n                            \"FilteredRelation's condition doesn't support \"\n                            \"relations outside the %r (got %r).\"\n                            % (filtered_relation.relation_name, lookup)\n                        )\n                else:\n                    raise ValueError(\n                        \"FilteredRelation's condition doesn't support nested \"\n                        \"relations deeper than the relation_name (got %r for \"\n                        \"%r).\" % (lookup, filtered_relation.relation_name)\n                    )\n        self._filtered_relations[filtered_relation.alias] = filtered_relation\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1272-1275)": [
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1294-1301)": [
      "\n                def local_setter(field, obj, from_obj):\n                    # setter for object retrieved in main query\n                    field.set_cached_value(obj, from_obj)\n",
      "\n                def local_setter(field, obj, from_obj):\n                    # Forward relationship: obj should be cached on from_obj\n                    field.set_cached_value(from_obj, obj)\n",
      "\n                def local_setter(field, related_obj, obj):\n                    field.set_cached_value(obj, related_obj)\n",
      "\n                def local_setter(field, obj, from_obj):\n                    # Reverse FK relationships need to set the cached value on the\n                    # related object, not on the from_obj.\n                    field.set_cached_value(obj, from_obj)\n",
      "\n                def local_setter(field, related_obj, obj):\n                    field.set_cached_value(obj, related_obj)\n",
      "\n                def local_setter(field, related_obj, obj):\n                    field.set_cached_value(obj, related_obj)\n",
      "\n                def local_setter(field, obj, from_obj):\n                    # Set 'obj' on 'from_obj'\n                    field.set_cached_value(obj, from_obj)\n",
      "\n                def local_setter(field, obj, from_obj):\n                    # Reverse the setter for FilteredRelation - obj is the target object\n                    field.set_cached_value(obj, from_obj)\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1280-1290)": [
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.set_cached_value(obj, from_obj)\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/db/models/query.py lines 131-134)": [
      "\n        def local_setter(obj, from_obj):\n            # Avoid overwriting objects loaded by, e.g., select_related().\n            if final_field.is_cached(obj):\n                return\n            final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(obj, from_obj):\n                # Avoid overwriting objects loaded by, e.g., select_related().\n                if final_field.is_cached(obj):\n                    return\n                final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(obj, from_obj):\n                # Avoid overwriting objects loaded by e.g. select_related().\n                if final_field.is_cached(obj):\n                    return\n                final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(obj, from_obj):\n                # Set FK on from_obj to obj using reverse of final field\n                final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(obj, from_obj):\n                # Avoid overwriting objects loaded by, e.g., select_related().\n                if final_field.is_cached(obj):\n                    return\n                final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(obj, from_obj):\n                # Set this object on the from_obj's related manager.\n                final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(obj, from_obj):\n                # Avoid overwriting objects loaded by, e.g., select_related().\n                if final_field.is_cached(obj):\n                    return\n                final_field.set_cached_value(obj, from_obj)\n",
      "\n            def local_setter(obj, from_obj):\n                # Avoid overwriting objects loaded by select_related().\n                if final_field.is_cached(obj):\n                    return\n                final_field.set_cached_value(obj, from_obj)\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 1574-1603)": [
      "\n    def add_filtered_relation(self, filtered_relation, alias):\n        filtered_relation.alias = alias\n        lookups = dict(get_children_from_q(filtered_relation.condition))\n        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n            filtered_relation.relation_name\n        )\n        if relation_lookup_parts:\n            raise ValueError(\n                \"FilteredRelation's relation_name cannot contain lookups \"\n                \"(got %r).\" % filtered_relation.relation_name\n            )\n        for lookup in chain(lookups):\n            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n            shift = 2 if not lookup_parts else 1\n            lookup_field_path = lookup_field_parts[:-shift]\n            for idx, lookup_field_part in enumerate(lookup_field_path):\n                if len(relation_field_parts) > idx:\n                    if relation_field_parts[idx] != lookup_field_part:\n                        raise ValueError(\n                            \"FilteredRelation's condition doesn't support \"\n                            \"relations outside the %r (got %r).\"\n                            % (filtered_relation.relation_name, lookup)\n                        )\n                else:\n                    raise ValueError(\n                        \"FilteredRelation's condition doesn't support nested \"\n                        \"relations deeper than the relation_name (got %r for \"\n                        \"%r).\" % (lookup, filtered_relation.relation_name)\n                    )\n        self._filtered_relations[filtered_relation.alias] = filtered_relation\n",
      "\n    def add_filtered_relation(self, filtered_relation, alias):\n        filtered_relation.alias = alias\n        lookups = dict(get_children_from_q(filtered_relation.condition))\n        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n            filtered_relation.relation_name\n        )\n        if relation_lookup_parts:\n            raise ValueError(\n                \"FilteredRelation's relation_name cannot contain lookups \"\n                \"(got %r).\" % filtered_relation.relation_name\n            )\n        for lookup in chain(lookups):\n            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n            shift = 2 if not lookup_parts else 1\n            lookup_field_path = lookup_field_parts[:-shift]\n            for idx, lookup_field_part in enumerate(lookup_field_path):\n                if len(relation_field_parts) > idx:\n                    if relation_field_parts[idx] != lookup_field_part:\n                        raise ValueError(\n                            \"FilteredRelation's condition doesn't support \"\n                            \"relations outside the %r (got %r).\"\n                            % (filtered_relation.relation_name, lookup)\n                        )\n                else:\n                    raise ValueError(\n                        \"FilteredRelation's condition doesn't support nested \"\n                        \"relations deeper than the relation_name (got %r for \"\n                        \"%r).\" % (lookup, filtered_relation.relation_name)\n                    )\n        self._filtered_relations[filtered_relation.alias] = filtered_relation\n",
      "\n    def add_filtered_relation(self, filtered_relation, alias):\n        filtered_relation.alias = alias\n        lookups = dict(get_children_from_q(filtered_relation.condition))\n        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n            filtered_relation.relation_name\n        )\n        if relation_lookup_parts:\n            raise ValueError(\n                \"FilteredRelation's relation_name cannot contain lookups \"\n                \"(got %r).\" % filtered_relation.relation_name\n            )\n        for lookup in chain(lookups):\n            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n            shift = 2 if not lookup_parts else 1\n            lookup_field_path = lookup_field_parts[:-shift]\n            for idx, lookup_field_part in enumerate(lookup_field_path):\n                if len(relation_field_parts) > idx:\n                    if relation_field_parts[idx] != lookup_field_part:\n                        raise ValueError(\n                            \"FilteredRelation's condition doesn't support \"\n                            \"relations outside the %r (got %r).\"\n                            % (filtered_relation.relation_name, lookup)\n                        )\n                else:\n                    raise ValueError(\n                        \"FilteredRelation's condition doesn't support nested \"\n                        \"relations deeper than the relation_name (got %r for \"\n                        \"%r).\" % (lookup, filtered_relation.relation_name)\n                    )\n        self._filtered_relations[filtered_relation.alias] = filtered_relation\n",
      "\n    def add_filtered_relation(self, filtered_relation, alias):\n        filtered_relation.alias = alias\n        lookups = dict(get_children_from_q(filtered_relation.condition))\n        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n            filtered_relation.relation_name\n        )\n        if relation_lookup_parts:\n            raise ValueError(\n                \"FilteredRelation's relation_name cannot contain lookups \"\n                \"(got %r).\" % filtered_relation.relation_name\n            )\n        for lookup in chain(lookups):\n            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n            shift = 2 if not lookup_parts else 1\n            lookup_field_path = lookup_field_parts[:-shift]\n            for idx, lookup_field_part in enumerate(lookup_field_path):\n                if len(relation_field_parts) > idx:\n                    if relation_field_parts[idx] != lookup_field_part:\n                        raise ValueError(\n                            \"FilteredRelation's condition doesn't support \"\n                            \"relations outside the %r (got %r).\"\n                            % (filtered_relation.relation_name, lookup)\n                        )\n                else:\n                    raise ValueError(\n                        \"FilteredRelation's condition doesn't support nested \"\n                        \"relations deeper than the relation_name (got %r for \"\n                        \"%r).\" % (lookup, filtered_relation.relation_name)\n                    )\n        self._filtered_relations[filtered_relation.alias] = filtered_relation\n",
      "\n    def add_filtered_relation(self, filtered_relation, alias):\n        filtered_relation.alias = alias\n        lookups = dict(get_children_from_q(filtered_relation.condition))\n        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n            filtered_relation.relation_name\n        )\n        if relation_lookup_parts:\n            raise ValueError(\n                \"FilteredRelation's relation_name cannot contain lookups \"\n                \"(got %r).\" % filtered_relation.relation_name\n            )\n        for lookup in chain(lookups):\n            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n            shift = 2 if not lookup_parts else 1\n            lookup_field_path = lookup_field_parts[:-shift]\n            for idx, lookup_field_part in enumerate(lookup_field_path):\n                if len(relation_field_parts) > idx:\n                    if relation_field_parts[idx] != lookup_field_part:\n                        raise ValueError(\n                            \"FilteredRelation's condition doesn't support \"\n                            \"relations outside the %r (got %r).\"\n                            % (filtered_relation.relation_name, lookup)\n                        )\n                else:\n                    raise ValueError(\n                        \"FilteredRelation's condition doesn't support nested \"\n                        \"relations deeper than the relation_name (got %r for \"\n                        \"%r).\" % (lookup, filtered_relation.relation_name)\n                    )\n        self._filtered_relations[filtered_relation.alias] = filtered_relation\n",
      "\ndef add_filtered_relation(self, filtered_relation, alias):\n    filtered_relation.alias = alias\n    lookups = dict(get_children_from_q(filtered_relation.condition))\n    relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n        filtered_relation.relation_name\n    )\n    if relation_lookup_parts:\n        raise ValueError(\n            \"FilteredRelation's relation_name cannot contain lookups \"\n            \"(got %r).\" % filtered_relation.relation_name\n        )\n    for lookup in chain(lookups):\n        lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n        shift = 2 if not lookup_parts else 1\n        lookup_field_path = lookup_field_parts[:-shift]\n        for idx, lookup_field_part in enumerate(lookup_field_path):\n            if len(relation_field_parts) > idx:\n                if relation_field_parts[idx] != lookup_field_part:\n                    raise ValueError(\n                        \"FilteredRelation's condition doesn't support \"\n                        \"relations outside the %r (got %r).\"\n                        % (filtered_relation.relation_name, lookup)\n                    )\n            else:\n                raise ValueError(\n                    \"FilteredRelation's condition doesn't support nested \"\n                    \"relations deeper than the relation_name (got %r for \"\n                    \"%r).\" % (lookup, filtered_relation.relation_name)\n                )\n    self._filtered_relations[filtered_relation.alias] = filtered_relation\n",
      "\ndef add_filtered_relation(self, filtered_relation, alias):\n    filtered_relation.alias = alias\n    lookups = dict(get_children_from_q(filtered_relation.condition))\n    relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n        filtered_relation.relation_name\n    )\n    if relation_lookup_parts:\n        raise ValueError(\n            \"FilteredRelation's relation_name cannot contain lookups \"\n            \"(got %r).\" % filtered_relation.relation_name\n        )\n    for lookup in chain(lookups):\n        lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n        shift = 2 if not lookup_parts else 1\n        lookup_field_path = lookup_field_parts[:-shift]\n        for idx, lookup_field_part in enumerate(lookup_field_path):\n            if len(relation_field_parts) > idx:\n                if relation_field_parts[idx] != lookup_field_part:\n                    raise ValueError(\n                        \"FilteredRelation's condition doesn't support \"\n                        \"relations outside the %r (got %r).\"\n                        % (filtered_relation.relation_name, lookup)\n                    )\n            else:\n                raise ValueError(\n                    \"FilteredRelation's condition doesn't support nested \"\n                    \"relations deeper than the relation_name (got %r for \"\n                    \"%r).\" % (lookup, filtered_relation.relation_name)\n                )\n    self._filtered_relations[filtered_relation.alias] = filtered_relation\n",
      "\n    def add_filtered_relation(self, filtered_relation, alias):\n        filtered_relation.alias = alias\n        lookups = dict(get_children_from_q(filtered_relation.condition))\n        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n            filtered_relation.relation_name\n        )\n        if relation_lookup_parts:\n            raise ValueError(\n                \"FilteredRelation's relation_name cannot contain lookups \"\n                \"(got %r).\" % filtered_relation.relation_name\n            )\n        for lookup in chain(lookups):\n            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n            shift = 2 if not lookup_parts else 1\n            lookup_field_path = lookup_field_parts[:-shift]\n            for idx, lookup_field_part in enumerate(lookup_field_path):\n                if len(relation_field_parts) > idx:\n                    if relation_field_parts[idx] != lookup_field_part:\n                        raise ValueError(\n                            \"FilteredRelation's condition doesn't support \"\n                            \"relations outside the %r (got %r).\"\n                            % (filtered_relation.relation_name, lookup)\n                        )\n                else:\n                    raise ValueError(\n                        \"FilteredRelation's condition doesn't support nested \"\n                        \"relations deeper than the relation_name (got %r for \"\n                        \"%r).\" % (lookup, filtered_relation.relation_name)\n                    )\n        self._filtered_relations[filtered_relation.alias] = filtered_relation\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662de12..a7bc331a36 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -128,6 +128,7 @@ class ModelIterable(BaseIterable):\n                     setattr(obj, attr_name, row[col_pos])\n \n             # Add the known related objects to the model.\n+\n             for field, rel_objs, rel_getter in known_related_objects:\n                 # Avoid overwriting objects loaded by, e.g., select_related().\n                 if field.is_cached(obj):\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..bfa6ac99ae 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,14 +1269,16 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+                    final_field.set_cached_value(obj, from_obj)\n \n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n+\n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n                 if cur_depth > 1:\n@@ -1291,6 +1293,7 @@ class SQLCompiler:\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0aa07e0b99..85fcc0088d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1571,6 +1571,7 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n+\n     def add_filtered_relation(self, filtered_relation, alias):\n         filtered_relation.alias = alias\n         lookups = dict(get_children_from_q(filtered_relation.condition))\n",
    "variant_0": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662de12..7f0d0f1328 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -128,10 +128,12 @@ class ModelIterable(BaseIterable):\n                     setattr(obj, attr_name, row[col_pos])\n \n             # Add the known related objects to the model.\n-            for field, rel_objs, rel_getter in known_related_objects:\n+\n+            def local_setter(obj, from_obj):\n                 # Avoid overwriting objects loaded by, e.g., select_related().\n-                if field.is_cached(obj):\n-                    continue\n+                if final_field.is_cached(obj):\n+                    return\n+                final_field.set_cached_value(obj, from_obj)\n                 rel_obj_id = rel_getter(obj)\n                 try:\n                     rel_obj = rel_objs[rel_obj_id]\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..646528ab56 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,36 +1269,27 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+                    final_field.set_cached_value(obj, from_obj)\n \n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n-            for name in list(requested):\n-                # Filtered relations work only on the topmost level.\n-                if cur_depth > 1:\n-                    break\n-                if name in self.query._filtered_relations:\n-                    fields_found.add(name)\n-                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n-                        [name], opts, root_alias\n-                    )\n-                    model = join_opts.model\n-                    alias = joins[-1]\n+\n+            def local_setter(final_field, obj, from_obj):\n+                # Set a reverse fk object when relation is non-empty.\n+                if from_obj:\n+                    final_field.set_cached_value(obj, from_obj)\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n-                    klass_info = {\n-                        \"model\": model,\n-                        \"field\": final_field,\n-                        \"reverse\": True,\n-                        \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n-                        \"from_parent\": from_parent,\n-                    }\n+\n+                def local_setter(field, related_obj, obj):\n+                    # Set the reverse FK/M2M on the related object to point to obj\n+                    field.set_cached_value(related_obj, obj)\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0aa07e0b99..85fcc0088d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1571,6 +1571,7 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n+\n     def add_filtered_relation(self, filtered_relation, alias):\n         filtered_relation.alias = alias\n         lookups = dict(get_children_from_q(filtered_relation.condition))\n",
    "variant_1": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662de12..e7402f7252 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -128,10 +128,12 @@ class ModelIterable(BaseIterable):\n                     setattr(obj, attr_name, row[col_pos])\n \n             # Add the known related objects to the model.\n-            for field, rel_objs, rel_getter in known_related_objects:\n-                # Avoid overwriting objects loaded by, e.g., select_related().\n-                if field.is_cached(obj):\n-                    continue\n+\n+        def local_setter(obj, from_obj):\n+            # Avoid overwriting objects loaded by, e.g., select_related().\n+            if final_field.is_cached(obj):\n+                return\n+            final_field.set_cached_value(obj, from_obj)\n                 rel_obj_id = rel_getter(obj)\n                 try:\n                     rel_obj = rel_objs[rel_obj_id]\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..7360f29318 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,36 +1269,27 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+                    final_field.set_cached_value(obj, from_obj)\n \n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n-            for name in list(requested):\n-                # Filtered relations work only on the topmost level.\n-                if cur_depth > 1:\n-                    break\n-                if name in self.query._filtered_relations:\n-                    fields_found.add(name)\n-                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n-                        [name], opts, root_alias\n-                    )\n-                    model = join_opts.model\n-                    alias = joins[-1]\n+\n+            def local_setter(final_field, obj, from_obj):\n+                # Set a reverse fk object when relation is non-empty.\n+                if from_obj:\n+                    final_field.set_cached_value(obj, from_obj)\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n-                    klass_info = {\n-                        \"model\": model,\n-                        \"field\": final_field,\n-                        \"reverse\": True,\n-                        \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n-                        \"from_parent\": from_parent,\n-                    }\n+\n+                def local_setter(field, obj, from_obj):\n+                    # setter for object retrieved in main query\n+                    field.set_cached_value(obj, from_obj)\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0aa07e0b99..85fcc0088d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1571,6 +1571,7 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n+\n     def add_filtered_relation(self, filtered_relation, alias):\n         filtered_relation.alias = alias\n         lookups = dict(get_children_from_q(filtered_relation.condition))\n",
    "variant_2": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662de12..7f0d0f1328 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -128,10 +128,12 @@ class ModelIterable(BaseIterable):\n                     setattr(obj, attr_name, row[col_pos])\n \n             # Add the known related objects to the model.\n-            for field, rel_objs, rel_getter in known_related_objects:\n+\n+            def local_setter(obj, from_obj):\n                 # Avoid overwriting objects loaded by, e.g., select_related().\n-                if field.is_cached(obj):\n-                    continue\n+                if final_field.is_cached(obj):\n+                    return\n+                final_field.set_cached_value(obj, from_obj)\n                 rel_obj_id = rel_getter(obj)\n                 try:\n                     rel_obj = rel_objs[rel_obj_id]\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..4e80ced8c9 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,36 +1269,27 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+                    final_field.set_cached_value(obj, from_obj)\n \n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n-            for name in list(requested):\n-                # Filtered relations work only on the topmost level.\n-                if cur_depth > 1:\n-                    break\n-                if name in self.query._filtered_relations:\n-                    fields_found.add(name)\n-                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n-                        [name], opts, root_alias\n-                    )\n-                    model = join_opts.model\n-                    alias = joins[-1]\n+\n+            def local_setter(final_field, obj, from_obj):\n+                # Set a reverse fk object when relation is non-empty.\n+                if from_obj:\n+                    final_field.set_cached_value(obj, from_obj)\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n-                    klass_info = {\n-                        \"model\": model,\n-                        \"field\": final_field,\n-                        \"reverse\": True,\n-                        \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n-                        \"from_parent\": from_parent,\n-                    }\n+\n+                def local_setter(field, obj, from_obj):\n+                    # Forward relationship: obj should be cached on from_obj\n+                    field.set_cached_value(from_obj, obj)\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0aa07e0b99..85fcc0088d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1571,6 +1571,7 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n+\n     def add_filtered_relation(self, filtered_relation, alias):\n         filtered_relation.alias = alias\n         lookups = dict(get_children_from_q(filtered_relation.condition))\n",
    "variant_3": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662de12..7a6dc3db4f 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -128,10 +128,12 @@ class ModelIterable(BaseIterable):\n                     setattr(obj, attr_name, row[col_pos])\n \n             # Add the known related objects to the model.\n-            for field, rel_objs, rel_getter in known_related_objects:\n-                # Avoid overwriting objects loaded by, e.g., select_related().\n-                if field.is_cached(obj):\n-                    continue\n+\n+            def local_setter(obj, from_obj):\n+                # Avoid overwriting objects loaded by e.g. select_related().\n+                if final_field.is_cached(obj):\n+                    return\n+                final_field.set_cached_value(obj, from_obj)\n                 rel_obj_id = rel_getter(obj)\n                 try:\n                     rel_obj = rel_objs[rel_obj_id]\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..0b2e0cefc5 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,36 +1269,26 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+                    final_field.set_cached_value(obj, from_obj)\n \n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n-            for name in list(requested):\n-                # Filtered relations work only on the topmost level.\n-                if cur_depth > 1:\n-                    break\n-                if name in self.query._filtered_relations:\n-                    fields_found.add(name)\n-                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n-                        [name], opts, root_alias\n-                    )\n-                    model = join_opts.model\n-                    alias = joins[-1]\n+\n+            def local_setter(final_field, obj, from_obj):\n+                # Set a reverse fk object when relation is non-empty.\n+                if from_obj:\n+                    final_field.set_cached_value(obj, from_obj)\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n-                    klass_info = {\n-                        \"model\": model,\n-                        \"field\": final_field,\n-                        \"reverse\": True,\n-                        \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n-                        \"from_parent\": from_parent,\n-                    }\n+\n+                def local_setter(field, related_obj, obj):\n+                    field.set_cached_value(obj, related_obj)\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0aa07e0b99..85fcc0088d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1571,6 +1571,7 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n+\n     def add_filtered_relation(self, filtered_relation, alias):\n         filtered_relation.alias = alias\n         lookups = dict(get_children_from_q(filtered_relation.condition))\n",
    "variant_4": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662de12..9b6b16ce90 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -128,10 +128,10 @@ class ModelIterable(BaseIterable):\n                     setattr(obj, attr_name, row[col_pos])\n \n             # Add the known related objects to the model.\n-            for field, rel_objs, rel_getter in known_related_objects:\n-                # Avoid overwriting objects loaded by, e.g., select_related().\n-                if field.is_cached(obj):\n-                    continue\n+\n+            def local_setter(obj, from_obj):\n+                # Set FK on from_obj to obj using reverse of final field\n+                final_field.set_cached_value(obj, from_obj)\n                 rel_obj_id = rel_getter(obj)\n                 try:\n                     rel_obj = rel_objs[rel_obj_id]\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..4c2ce88688 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,36 +1269,28 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+                    final_field.set_cached_value(obj, from_obj)\n \n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n-            for name in list(requested):\n-                # Filtered relations work only on the topmost level.\n-                if cur_depth > 1:\n-                    break\n-                if name in self.query._filtered_relations:\n-                    fields_found.add(name)\n-                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n-                        [name], opts, root_alias\n-                    )\n-                    model = join_opts.model\n-                    alias = joins[-1]\n+\n+            def local_setter(final_field, obj, from_obj):\n+                # Set a reverse fk object when relation is non-empty.\n+                if from_obj:\n+                    final_field.set_cached_value(obj, from_obj)\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n-                    klass_info = {\n-                        \"model\": model,\n-                        \"field\": final_field,\n-                        \"reverse\": True,\n-                        \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n-                        \"from_parent\": from_parent,\n-                    }\n+\n+                def local_setter(field, obj, from_obj):\n+                    # Reverse FK relationships need to set the cached value on the\n+                    # related object, not on the from_obj.\n+                    field.set_cached_value(obj, from_obj)\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0aa07e0b99..85fcc0088d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1571,6 +1571,7 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n+\n     def add_filtered_relation(self, filtered_relation, alias):\n         filtered_relation.alias = alias\n         lookups = dict(get_children_from_q(filtered_relation.condition))\n",
    "variant_5": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662de12..7f0d0f1328 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -128,10 +128,12 @@ class ModelIterable(BaseIterable):\n                     setattr(obj, attr_name, row[col_pos])\n \n             # Add the known related objects to the model.\n-            for field, rel_objs, rel_getter in known_related_objects:\n+\n+            def local_setter(obj, from_obj):\n                 # Avoid overwriting objects loaded by, e.g., select_related().\n-                if field.is_cached(obj):\n-                    continue\n+                if final_field.is_cached(obj):\n+                    return\n+                final_field.set_cached_value(obj, from_obj)\n                 rel_obj_id = rel_getter(obj)\n                 try:\n                     rel_obj = rel_objs[rel_obj_id]\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..0b2e0cefc5 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,36 +1269,26 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+                    final_field.set_cached_value(obj, from_obj)\n \n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n-            for name in list(requested):\n-                # Filtered relations work only on the topmost level.\n-                if cur_depth > 1:\n-                    break\n-                if name in self.query._filtered_relations:\n-                    fields_found.add(name)\n-                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n-                        [name], opts, root_alias\n-                    )\n-                    model = join_opts.model\n-                    alias = joins[-1]\n+\n+            def local_setter(final_field, obj, from_obj):\n+                # Set a reverse fk object when relation is non-empty.\n+                if from_obj:\n+                    final_field.set_cached_value(obj, from_obj)\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n-                    klass_info = {\n-                        \"model\": model,\n-                        \"field\": final_field,\n-                        \"reverse\": True,\n-                        \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n-                        \"from_parent\": from_parent,\n-                    }\n+\n+                def local_setter(field, related_obj, obj):\n+                    field.set_cached_value(obj, related_obj)\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0aa07e0b99..85fcc0088d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1571,6 +1571,7 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n+\n     def add_filtered_relation(self, filtered_relation, alias):\n         filtered_relation.alias = alias\n         lookups = dict(get_children_from_q(filtered_relation.condition))\n",
    "variant_6": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662de12..a890049740 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -128,10 +128,10 @@ class ModelIterable(BaseIterable):\n                     setattr(obj, attr_name, row[col_pos])\n \n             # Add the known related objects to the model.\n-            for field, rel_objs, rel_getter in known_related_objects:\n-                # Avoid overwriting objects loaded by, e.g., select_related().\n-                if field.is_cached(obj):\n-                    continue\n+\n+            def local_setter(obj, from_obj):\n+                # Set this object on the from_obj's related manager.\n+                final_field.set_cached_value(obj, from_obj)\n                 rel_obj_id = rel_getter(obj)\n                 try:\n                     rel_obj = rel_objs[rel_obj_id]\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..0b2e0cefc5 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,36 +1269,26 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+                    final_field.set_cached_value(obj, from_obj)\n \n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n-            for name in list(requested):\n-                # Filtered relations work only on the topmost level.\n-                if cur_depth > 1:\n-                    break\n-                if name in self.query._filtered_relations:\n-                    fields_found.add(name)\n-                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n-                        [name], opts, root_alias\n-                    )\n-                    model = join_opts.model\n-                    alias = joins[-1]\n+\n+            def local_setter(final_field, obj, from_obj):\n+                # Set a reverse fk object when relation is non-empty.\n+                if from_obj:\n+                    final_field.set_cached_value(obj, from_obj)\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n-                    klass_info = {\n-                        \"model\": model,\n-                        \"field\": final_field,\n-                        \"reverse\": True,\n-                        \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n-                        \"from_parent\": from_parent,\n-                    }\n+\n+                def local_setter(field, related_obj, obj):\n+                    field.set_cached_value(obj, related_obj)\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0aa07e0b99..3259c45ef5 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1571,36 +1571,37 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n+\n+def add_filtered_relation(self, filtered_relation, alias):\n+    filtered_relation.alias = alias\n+    lookups = dict(get_children_from_q(filtered_relation.condition))\n+    relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n+        filtered_relation.relation_name\n+    )\n+    if relation_lookup_parts:\n+        raise ValueError(\n+            \"FilteredRelation's relation_name cannot contain lookups \"\n+            \"(got %r).\" % filtered_relation.relation_name\n         )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n+    for lookup in chain(lookups):\n+        lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n+        shift = 2 if not lookup_parts else 1\n+        lookup_field_path = lookup_field_parts[:-shift]\n+        for idx, lookup_field_part in enumerate(lookup_field_path):\n+            if len(relation_field_parts) > idx:\n+                if relation_field_parts[idx] != lookup_field_part:\n                     raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n+                        \"FilteredRelation's condition doesn't support \"\n+                        \"relations outside the %r (got %r).\"\n+                        % (filtered_relation.relation_name, lookup)\n                     )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+            else:\n+                raise ValueError(\n+                    \"FilteredRelation's condition doesn't support nested \"\n+                    \"relations deeper than the relation_name (got %r for \"\n+                    \"%r).\" % (lookup, filtered_relation.relation_name)\n+                )\n+    self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n",
    "variant_7": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662de12..7f0d0f1328 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -128,10 +128,12 @@ class ModelIterable(BaseIterable):\n                     setattr(obj, attr_name, row[col_pos])\n \n             # Add the known related objects to the model.\n-            for field, rel_objs, rel_getter in known_related_objects:\n+\n+            def local_setter(obj, from_obj):\n                 # Avoid overwriting objects loaded by, e.g., select_related().\n-                if field.is_cached(obj):\n-                    continue\n+                if final_field.is_cached(obj):\n+                    return\n+                final_field.set_cached_value(obj, from_obj)\n                 rel_obj_id = rel_getter(obj)\n                 try:\n                     rel_obj = rel_objs[rel_obj_id]\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..10ab45e44d 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,36 +1269,27 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+                    final_field.set_cached_value(obj, from_obj)\n \n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n-            for name in list(requested):\n-                # Filtered relations work only on the topmost level.\n-                if cur_depth > 1:\n-                    break\n-                if name in self.query._filtered_relations:\n-                    fields_found.add(name)\n-                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n-                        [name], opts, root_alias\n-                    )\n-                    model = join_opts.model\n-                    alias = joins[-1]\n+\n+            def local_setter(final_field, obj, from_obj):\n+                # Set a reverse fk object when relation is non-empty.\n+                if from_obj:\n+                    final_field.set_cached_value(obj, from_obj)\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n-                    klass_info = {\n-                        \"model\": model,\n-                        \"field\": final_field,\n-                        \"reverse\": True,\n-                        \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n-                        \"from_parent\": from_parent,\n-                    }\n+\n+                def local_setter(field, obj, from_obj):\n+                    # Set 'obj' on 'from_obj'\n+                    field.set_cached_value(obj, from_obj)\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0aa07e0b99..3259c45ef5 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1571,36 +1571,37 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n+\n+def add_filtered_relation(self, filtered_relation, alias):\n+    filtered_relation.alias = alias\n+    lookups = dict(get_children_from_q(filtered_relation.condition))\n+    relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n+        filtered_relation.relation_name\n+    )\n+    if relation_lookup_parts:\n+        raise ValueError(\n+            \"FilteredRelation's relation_name cannot contain lookups \"\n+            \"(got %r).\" % filtered_relation.relation_name\n         )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n+    for lookup in chain(lookups):\n+        lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n+        shift = 2 if not lookup_parts else 1\n+        lookup_field_path = lookup_field_parts[:-shift]\n+        for idx, lookup_field_part in enumerate(lookup_field_path):\n+            if len(relation_field_parts) > idx:\n+                if relation_field_parts[idx] != lookup_field_part:\n                     raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n+                        \"FilteredRelation's condition doesn't support \"\n+                        \"relations outside the %r (got %r).\"\n+                        % (filtered_relation.relation_name, lookup)\n                     )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+            else:\n+                raise ValueError(\n+                    \"FilteredRelation's condition doesn't support nested \"\n+                    \"relations deeper than the relation_name (got %r for \"\n+                    \"%r).\" % (lookup, filtered_relation.relation_name)\n+                )\n+    self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n",
    "variant_8": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex f88662de12..8dde6496ce 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -128,10 +128,12 @@ class ModelIterable(BaseIterable):\n                     setattr(obj, attr_name, row[col_pos])\n \n             # Add the known related objects to the model.\n-            for field, rel_objs, rel_getter in known_related_objects:\n-                # Avoid overwriting objects loaded by, e.g., select_related().\n-                if field.is_cached(obj):\n-                    continue\n+\n+            def local_setter(obj, from_obj):\n+                # Avoid overwriting objects loaded by select_related().\n+                if final_field.is_cached(obj):\n+                    return\n+                final_field.set_cached_value(obj, from_obj)\n                 rel_obj_id = rel_getter(obj)\n                 try:\n                     rel_obj = rel_objs[rel_obj_id]\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..b9bc793316 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,36 +1269,27 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+                    final_field.set_cached_value(obj, from_obj)\n \n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n-            for name in list(requested):\n-                # Filtered relations work only on the topmost level.\n-                if cur_depth > 1:\n-                    break\n-                if name in self.query._filtered_relations:\n-                    fields_found.add(name)\n-                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n-                        [name], opts, root_alias\n-                    )\n-                    model = join_opts.model\n-                    alias = joins[-1]\n+\n+            def local_setter(final_field, obj, from_obj):\n+                # Set a reverse fk object when relation is non-empty.\n+                if from_obj:\n+                    final_field.set_cached_value(obj, from_obj)\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n-                    klass_info = {\n-                        \"model\": model,\n-                        \"field\": final_field,\n-                        \"reverse\": True,\n-                        \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n-                        \"from_parent\": from_parent,\n-                    }\n+\n+                def local_setter(field, obj, from_obj):\n+                    # Reverse the setter for FilteredRelation - obj is the target object\n+                    field.set_cached_value(obj, from_obj)\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 0aa07e0b99..85fcc0088d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1571,6 +1571,7 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n+\n     def add_filtered_relation(self, filtered_relation, alias):\n         filtered_relation.alias = alias\n         lookups = dict(get_children_from_q(filtered_relation.condition))\n"
  }
}