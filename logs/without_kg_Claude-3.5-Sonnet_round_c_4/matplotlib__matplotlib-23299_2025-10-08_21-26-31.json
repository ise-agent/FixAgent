{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/pyplot.py lines 222-226)": "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    if _backend_mod is not None:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n",
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/pyplot.py lines 200-206)": "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to switch to.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.pyplot as plt\n    newbackend = rcsetup.validate_backend(newbackend)\n    if newbackend == rcParams._get_backend_or_none():\n        # Nothing to do if the requested backend is already set\n        pass\n    else:\n        # Only close figures if we're actually switching backends,\n        # not during initial backend setup\n        if _backend_mod is not None:\n            close(\"all\")\n\n        if newbackend in rcsetup._interactive_bk:\n            _log.info(\"Using %s backend\", newbackend)\n        else:\n            _log.info(\"Using non-interactive backend %s\", newbackend)\n\n        _backend_mod = importlib.import_module(\n            cbook._backend_module_name(newbackend))\n        canvas_class = _backend_mod.FigureCanvas\n\n        required_framework = _get_required_interactive_framework(_backend_mod)\n        if required_framework is not None:\n            current_framework = \\\n                cbook._get_running_interactive_framework()\n            if (current_framework and required_framework\n                    and current_framework != required_framework):\n                raise ImportError(\n                    \"Cannot load backend {!r} which requires the {!r} \"\n                    \"interactive framework, as {!r} is currently running\"\n                    .format(newbackend, required_framework,\n                            current_framework))\n\n        # Load backend_xxx.py and extract the FigureCanvas class.\n        rcParams['backend'] = rcParams['backend.qt4'] = newbackend\n        # make sure the init is pulled up so we can assign to it later\n        import matplotlib.pyplot as plt\n        dict.__setitem__(rcParams, 'backend', newbackend)\n        importlib.reload(sys.modules[__name__])\n",
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/pyplot.py lines 940-941)": "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend may be one of the standard backend names listed in\n    `.backend_bases.Backend` or a custom backend's module name.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    old_backend = dict.__getitem__(rcParams, 'backend')\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx'}\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess, \"agg\", \"svg\", \"pdf\", \"ps\"]\n        else:\n            candidates = [\"agg\", \"svg\", \"pdf\", \"ps\"]\n            gui_framework = cbook._get_running_interactive_framework()\n            if gui_framework:\n                candidates = [f\"{gui_framework}agg\"] + candidates\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # At this point we've exhausted the list without success, we just\n            # let the import error raised above propagate out.\n            switch_backend(candidates[0])  # Raise the import error.\n            return\n\n    # Backends are implemented as modules, but \"inherit\" default method\n    # implementations from backend_bases._Backend.  This is achieved by\n    # creating a \"class\" that inherits from backend_bases._Backend and whose\n    # body is filled with the module's globals.\n    backend_mod = importlib.import_module(\n        cbook._backend_module_name(newbackend))\n\n    Backend = type(\"Backend\", (backend_bases._Backend,), vars(backend_mod))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    backend_mod.Backend = Backend\n\n    # Only close figures if we're actually switching from an existing backend\n    if _backend_mod is not None:\n        close(\"all\")\n\n    _backend_mod = backend_mod\n    for prop in dir(backend_mod):\n        setattr(sys.modules[__name__], prop, getattr(backend_mod, prop))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules[__name__].Backend = Backend\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n",
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/_pylab_helpers.py lines 77-82)": "\n    # Set the new backend, and fire any required events.\n    if new_figure_manager is None:\n        # Can't switch to the given backend, so keep using the old one.\n        return\n    \n    # If we're actually switching backends (not just initializing), close existing figures\n    if _backend_mod is not None:\n        close(\"all\")\n    \n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name] = getattr(backend_mod, func_name)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/pyplot.py lines 222-226)": [
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    if _backend_mod is not None:\n        close(\"all\")\n",
      "\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    if _backend_mod is not None:\n        close(\"all\")\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, so\n    backends with attached toolbars should be switched before any figures\n    are created.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n\n    Examples\n    --------\n    >>> switch_backend('Qt5Agg')\n    >>> switch_backend('macosx')\n\n    See Also\n    --------\n    matplotlib.get_backend : Return the name of the current backend.\n    matplotlib.use : Set the backend (with additional options).\n\n    Notes\n    -----\n    Switching backends will close all open figures.\n\n    This function is primarily intended for use in Jupyter notebooks where\n    you may want to show some plots with one backend, then switch to another.\n\n    .. versionadded:: 3.1\n    \"\"\"\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    \n    # Only close figures if we're actually switching backends, not initializing\n    if _backend_mod is not None:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    if _backend_mod is not None:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, so if you\n    are using an interactive backend from an ordinary Python shell, it will\n    be necessary to run ``%matplotlib`` again.\n\n    .. warning::\n\n        Since closing the figures is not a reversible operation, it is\n        recommended to first save your work.\n\n    Parameters\n    ----------\n    newbackend : str\n        A backend name, which is one of the following strings:\n        'Agg', 'Cairo', 'MacOSX', 'PGF', 'PS', 'Qt5Agg', 'SVG', 'TkAgg',\n        'WX', 'WXAgg', 'GTK3Cairo', 'GTK3Agg', 'WebAgg', 'nbAgg'.\n        Case-insensitive.\n\n    See Also\n    --------\n    matplotlib.get_backend : Return the name of the current backend.\n    matplotlib.use : Select the backend used by Matplotlib.\n    :ref:`backends`\n\n    \"\"\"\n    # Switching to an interactive backend is possible only if no event loop\n    # for another interactive backend has started.\n\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    switcher = matplotlib.backends.pylab_setup  # delay loading of module\n\n    if newbackend.startswith(\"module://\"):\n        module_name = newbackend[9:]\n    else:\n        module_name = f\"matplotlib.backends.backend_{newbackend.lower()}\"\n\n    # don't (prematurely) resolve the \"auto\" backend setting\n    if newbackend != rcsetup._auto_backend_sentinel:\n        backend = newbackend\n    else:\n        backend = rcParams._get_backend_or_none()\n\n    # Code for switching between backends.\n\n    # Do this even for non-interactive backends so that we get a\n    # consistent state upon repeated calls to switch_backend().\n\n    # A user may want to re-select a backend that they have modified.\n    # In that case, the module may already be imported, but is not the\n    # backend being used.  So we may need to reload it.\n\n    # Short-circuit if the new backend is the same as the old backend.\n    # In that case we can avoid the expensive close-all-figures step.\n    if (backend == matplotlib.get_backend()\n            and module_name in sys.modules):\n        return\n\n    # A small amount of state is stored in pyplot itself, rather than\n    # in the backend.  We need to clear this state when switching.\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        candidates += [\"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            switch_backend(\"agg\")\n            rcParamsOrig['backend'] = \"agg\"\n            return\n    else:\n        # Backends are imported and selected here, and apart from an\n        # appropriate cleanup, this is where backend switching happens.\n\n        # This is certainly one of the permanent ways to do this.\n        # It would be nicer if there were a good way to save and restore\n        # the state of the current figure manager.\n        global _backend_mod\n        # make sure the init is pulled up so we can assign to it later\n        import matplotlib.backends\n        # Only close figures if we're actually switching backends, not initializing\n        if _backend_mod is not None:\n            close(\"all\")\n\n        if newbackend.startswith(\"module://\"):\n            module_name = newbackend[9:]\n            backend_name = module_name\n        else:\n            backend_name = \"backend_{}\".format(newbackend.lower())\n            module_name = \"matplotlib.backends.{}\".format(backend_name)\n\n        _backend_mod, new_figure_manager, draw_if_interactive, _show = \\\n            matplotlib.backends.pylab_setup(module_name)\n\n        # Need to keep a global reference to the backend for compatibility\n        # reasons.  See https://github.com/matplotlib/matplotlib/issues/6092\n        matplotlib.backends.backend = backend_name\n\n        # make sure the repl display hook is installed in case we become\n        # interactive\n        install_repl_displayhook()\n\n        # This must be imported last in the matplotlib.backends.__init__,\n        # which is why we do it here.\n        matplotlib.backends._backend_loading.backend_registry._ensure_backend(\n            backend_name)\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, so\n    backends that are classified as interactive will raise an exception\n    if you try to change from a non-interactive backend to an interactive\n    one, or if you try to change from one interactive backend to another.\n\n    This limitation does not apply if the backend is changed from within a\n    plotting context manager such as with ``matplotlib.style.context()``\n    or :doc:`/tutorials/introductory/customizing`.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    if _backend_mod is not None:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend may be one of the standard backend names listed in the\n    documentation or a module name.  In the latter case, the module must\n    export a ``FigureCanvas`` class and a ``show`` function.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    if _backend_mod is not None:\n        close(\"all\")\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    if _backend_mod is not None:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n"
    ],
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/pyplot.py lines 200-206)": [
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to switch to.\n    \"\"\"\n    global _backend_mod\n    # Switching to the same backend should be a no-op.\n    if (newbackend is rcsetup._auto_backend_sentinel or\n            cbook._get_running_interactive_framework() is not None):\n        current_framework = _get_running_interactive_framework()\n        if current_framework is not None:\n            required_framework = _get_required_interactive_framework(\n                newbackend)\n            if (required_framework is not None and\n                    required_framework != current_framework):\n                raise ImportError(\n                    \"Cannot load backend {!r} which requires the {!r} \"\n                    \"interactive framework, as {!r} is currently running\"\n                    .format(newbackend, required_framework,\n                            current_framework))\n    \n    # Only close existing figures if we're actually switching backends,\n    # not during initial backend setup\n    if _backend_mod is not None:\n        close(\"all\")\n    \n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = _get_running_interactive_framework()\n        if current_framework is None:\n            backend = rcParamsOrig['backend']\n        else:\n            backend = dict(_interactive_bk)[current_framework]\n    else:\n        backend = newbackend\n    \n    backend = cbook._backend_module_name(backend)\n    _backend_mod = importlib.import_module(backend)\n    \n    # Need to keep a global reference to the backend for compatibility.\n    sys.modules['matplotlib.backends']._backend_mod = _backend_mod\n    \n    # Update the rcParam so that subsequent calls to get_backend() will\n    # return the correct value.\n    rcParams['backend'] = backend\n    \n    if hasattr(_backend_mod, 'new_figure_manager'):\n        new_figure_manager = _backend_mod.new_figure_manager\n    else:\n        def new_figure_manager(num, *args, **kwargs):\n            FigureClass = kwargs.pop('FigureClass', Figure)\n            fig = FigureClass(*args, **kwargs)\n            return new_figure_manager_given_figure(num, fig)\n    \n    _pylab_helpers.Gcf.new_figure_manager = staticmethod(new_figure_manager)\n    _pylab_helpers.Gcf.draw_all = lambda: None\n    \n    if hasattr(_backend_mod, 'new_figure_manager_given_figure'):\n        new_figure_manager_given_figure = \\\n            _backend_mod.new_figure_manager_given_figure\n    else:\n        def new_figure_manager_given_figure(num, figure):\n            canvas = _backend_mod.FigureCanvas(figure)\n            manager = _backend_mod.FigureManager(canvas, num)\n            return manager\n    \n    _pylab_helpers.Gcf.new_figure_manager_given_figure = \\\n        staticmethod(new_figure_manager_given_figure)\n    \n    if hasattr(_backend_mod, 'show'):\n        show = _backend_mod.show\n    else:\n        show = lambda: None\n    \n    _pylab_helpers.Gcf.show = staticmethod(show)\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to switch to.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.pyplot\n    newbackend = rcsetup.validate_backend(newbackend)\n    if newbackend == rcParams._get_backend_or_none():\n        # Nothing to do if the requested backend is already set\n        pass\n    else:\n        # Only close figures if we're actually switching from an existing backend,\n        # not during initial backend setup\n        if _backend_mod is not None:\n            close(\"all\")\n\n        if newbackend in rcsetup._interactive_bk:\n            _warn_if_gui_out_of_main_thread()\n\n        # Load the backend, and update the class instance if needed.\n        backend_mod = importlib.import_module(\n            cbook._backend_module_name(newbackend))\n\n        required_framework = _get_required_interactive_framework(backend_mod)\n        if required_framework is not None:\n            current_framework = \\\n                cbook._get_running_interactive_framework()\n            if (current_framework is not None and\n                    required_framework != current_framework):\n                raise ImportError(\n                    \"Cannot load backend {!r} which requires the {!r} \"\n                    \"interactive framework, as {!r} is currently running\"\n                    .format(newbackend, required_framework,\n                            current_framework))\n\n        # This must be done here (rather than in switch_backend) to handle\n        # the case where we're running headless and the backend is changed\n        # from the rcparams to something else after pyplot is imported.\n        rcParams['backend'] = rcParams['backend_fallback'] = newbackend\n        _backend_mod = backend_mod\n        for func_name in [\"new_figure_manager\", \"draw_if_interactive\",\n                          \"show\"]:\n            globals()[func_name] = getattr(backend_mod, func_name)\n\n        # Need to keep a global reference to the backend for compatibility\n        # reasons.  See https://github.com/matplotlib/matplotlib/issues/6092\n        matplotlib.backends.backend = newbackend\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to switch to.\n    \"\"\"\n    global _backend_mod\n    # Switching to the same backend should be a no-op.\n    if (newbackend is rcsetup._auto_backend_sentinel or\n            cbook._get_running_interactive_framework() is not None):\n        current_framework = _get_running_interactive_framework()\n        if current_framework is not None:\n            required_framework = _get_required_interactive_framework(newbackend)\n            if (required_framework is not None and\n                    current_framework != required_framework):\n                raise RuntimeError(\n                    \"Cannot load backend {!r} which requires the {!r} interactive \"\n                    \"framework, as {!r} is currently running\".format(\n                        newbackend, required_framework, current_framework))\n\n    # Only close figures if we're actually switching backends, not during initialization\n    if _backend_mod is not None:\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        for candidate in [\"macosx\", \"qt5agg\", \"qt4agg\", \"gtk3agg\", \"tkagg\"]:\n            try:\n                switch_backend(candidate)\n                break\n            except ImportError:\n                continue\n        else:\n            switch_backend(\"agg\")\n        return\n\n    backend_name = (newbackend[9:] if newbackend.startswith(\"module://\")\n                    else \"matplotlib.backends.backend_{}\".format(newbackend.lower()))\n\n    # Load the backend, and update the name if it was resolved by the\n    # load_backend call (in case the argument was a module).\n    backend_mod = importlib.import_module(backend_name)\n    _backend_mod = backend_mod\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.pyplot']._backend_mod = backend_mod\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to switch to.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.pyplot as plt\n    newbackend = cbook._backend_module_name(newbackend)\n    if newbackend == cbook._backend_module_name(_get_backend()):\n        # Nothing to do if the requested backend is already set\n        return\n\n    # Only close all figures if we're actually switching backends,\n    # not during initial backend setup\n    if _backend_mod is not None:\n        close(\"all\")\n\n    if newbackend in rcsetup._interactive_bk:\n        _log.debug(\"Loaded backend %s version %s.\", newbackend,\n                   sys.modules[newbackend].backend_version)\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n\n    # Load the new backend\n    _backend_mod = importlib.import_module(\n        cbook._backend_module_name(newbackend))\n\n    # Now that we've loaded the backend, we need to trigger any\n    # post-import backend initialization that may be needed.\n    canvas_class = _backend_mod.FigureCanvas\n\n    required_framework = _get_required_interactive_framework(_backend_mod)\n    if required_framework is not None:\n        ipython = _c_internal_utils.ipython_pylab_setup(required_framework)\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to switch to.\n    \"\"\"\n    # Check if we're actually switching backends or just initializing\n    if _backend_mod is not None:\n        # Only close figures when actually switching, not during initialization\n        close(\"all\")\n\n    global _backend_mod, _backend_mod_name\n    newbackend = rcsetup.validate_backend(newbackend)\n    if newbackend.startswith(\"module://\"):\n        module = importlib.import_module(newbackend[9:])\n    else:\n        module = importlib.import_module(\n            f\"matplotlib.backends.backend_{newbackend.lower()}\")\n    _backend_mod = module\n    _backend_mod_name = newbackend\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.pyplot']._backend_mod = module\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to switch to.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.pyplot as plt\n    newbackend = _validate_backend(newbackend)\n    backend_name = newbackend.lower()\n\n    # Only close figures if we're actually switching backends, not initializing\n    if _backend_mod is not None:\n        close(\"all\")\n\n    if backend_name.startswith(\"module://\"):\n        backend_mod = importlib.import_module(backend_name[9:])\n    else:\n        backend_mod = importlib.import_module(\n            f\"matplotlib.backends.backend_{backend_name}\")\n\n    canvas_class = backend_mod.FigureCanvas\n\n    required_framework = _get_required_interactive_framework(backend_mod)\n    if required_framework is not None:\n        current_framework = \\\n            _get_running_interactive_framework()\n        if (current_framework is not None and\n                current_framework is not required_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework.name,\n                    current_framework.name))\n\n    # Load the new backend.\n    _backend_mod = backend_mod\n    for fcm in Gcf.get_all_fig_managers():\n        fcm.canvas.figure.set_canvas(canvas_class(fcm.canvas.figure))\n    _pylab_helpers.Gcf._activeQue = []\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to switch to.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.pyplot\n    newbackend = rcsetup.validate_backend(newbackend)\n    if newbackend == rcParams._get_backend_or_none():\n        # Nothing to do if the requested backend is already set\n        pass\n    else:\n        # Only close all figures if we're actually switching backends,\n        # not during initial backend setup\n        if _backend_mod is not None:\n            close(\"all\")\n\n        if newbackend in rcsetup._interactive_bk:\n            _warn_if_gui_out_of_main_thread()\n\n        # Load the backend, and update the rcParam.\n        rcParams[\"backend\"] = newbackend\n        _backend_mod = backend_mod = importlib.import_module(\n            cbook._backend_module_name(newbackend))\n\n        # This must be imported and cached before switching the backend, so that\n        # `plt.show` can be called in non-IPython shells without triggering\n        # `ipython.py`'s `configure_inline_support` to request and cache a\n        # different backend than the one we just set.\n        if \"IPython\" in sys.modules:\n            from IPython import get_ipython\n            ip = get_ipython()\n            if ip is not None:\n                ip.enable_matplotlib(newbackend)\n\n        # Set up the backend.\n        install_repl_displayhook()\n\n        # The validation should be handled by the backend.\n        if hasattr(backend_mod, \"FigureCanvas\"):\n            new_figure_manager, draw_if_interactive, _show = _backend_mod_supports_v3_1(backend_mod)\n        else:\n            new_figure_manager = backend_mod.new_figure_manager\n            draw_if_interactive = backend_mod.draw_if_interactive\n            _show = backend_mod.show\n\n        _pylab_helpers.Gcf.set_active(None)\n        if hasattr(backend_mod, \"FigureManager\"):\n            _pylab_helpers.Gcf.figs = {}\n\n        # Need to keep a global reference to the backend for compatibility\n        # reasons.  See issues #7410, #9559.\n        globals()['new_figure_manager'] = new_figure_manager\n        globals()['draw_if_interactive'] = draw_if_interactive\n        globals()['_show'] = _show\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to switch to.\n\n    Examples\n    --------\n    Switching to the *Qt5Agg* backend::\n\n        plt.switch_backend('Qt5Agg')\n\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.pyplot\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = _get_running_interactive_framework()\n        mapping = {'qt5': 'qt5agg',\n                   'qt4': 'qt4agg',\n                   'gtk3': 'gtk3agg',\n                   'gtk': 'gtkagg',\n                   'tk': 'tkagg'}\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        candidates += [\n            \"macosx\", \"qt5agg\", \"qt4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n        # Don't try to use agg non-interactively so that importing pyplot in\n        # a script doesn't change matplotlib's behavior, but only if we get\n        # this far without a backend (which is not common since _init() sets\n        # a reasonable default).\n        if matplotlib.get_backend() == 'agg':\n            candidates.append(\"agg\")\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n                break\n            except ImportError:\n                continue\n        else:\n            switch_backend(\"agg\")\n        return\n\n    # Backends are case-insensitive.\n    newbackend = newbackend.lower()\n\n    # Only close figures if we're actually switching backends (not initializing)\n    if _backend_mod is not None:\n        close(\"all\")\n\n    if newbackend.startswith(\"module://\"):\n        backend_mod = importlib.import_module(newbackend[9:])\n    else:\n        backend_mod = importlib.import_module(\n            f\"matplotlib.backends.backend_{newbackend}\")\n    _backend_mod = backend_mod\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.backends.backend'] = backend_mod\n"
    ],
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/pyplot.py lines 940-941)": [
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend may be one of the standard backend names listed in the\n    documentation or a custom backend's module name.\n    \"\"\"\n    global _backend_mod, new_figure_manager, draw_if_interactive, show\n\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.pyplot as plt\n    plt.rcParams\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx'}\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        candidates += [\"agg\", \"ps\", \"pdf\", \"svg\", \"png\"]\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Switching to Agg should always succeed; if it doesn't, let the\n            # exception propagate out.\n            switch_backend(\"agg\")\n            rcParamsOrig['backend'] = \"agg\"\n            return\n\n    # Backends are implemented as modules, but \"inherit\" default method\n    # implementations from backend_bases._Backend.  This is achieved by\n    # creating a \"class\" that inherits from backend_bases._Backend and whose\n    # body is filled with the module's globals.\n    backend_name = (  # Normalize backend names for backend loading.\n        newbackend.lower()\n        .replace('module://', '')\n        .replace('qt5', 'qt')\n        .replace('cairo.', 'cairo')\n        .replace('_cairo', '')\n    )\n    module = importlib.import_module(\n        f\"matplotlib.backends.backend_{backend_name}\")\n    Backend = type(\"Backend\", (matplotlib.backends._Backend,), vars(module))\n\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, Backend.backend_version)\n\n    required_framework = _get_required_interactive_framework(Backend)\n    if required_framework is not None:\n        current_framework = cbook._get_running_interactive_framework()\n        if (current_framework is not None\n                and required_framework != current_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    # Only close existing figures if we're actually switching backends,\n    # not during initial backend setup\n    if _backend_mod is not None:\n        close(\"all\")\n\n    _backend_mod = Backend\n    new_figure_manager = _backend_mod.new_figure_manager\n    draw_if_interactive = _backend_mod.draw_if_interactive\n    show = _backend_mod.show\n\n    rcParams['backend'] = rcParamsDefault['backend'] = rcParamsOrig['backend'] = newbackend\n    backend_mod = sys.modules.get('matplotlib.backends')\n    if backend_mod is not None:\n        def backend_mod_fmt(backend):\n            return (backend if '://' in backend\n                    else 'module://matplotlib.backends.backend_{}'.format(backend.lower()))\n        backend_mod.__dict__.pop(\n            backend_mod_fmt(rcParamsOrig['backend']), None)\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, since\n    most GUI toolkits require the event loop to start before any GUI\n    objects can be created.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod, draw_if_interactive\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    \n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx'}\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        candidates += [\n            \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"webagg\"]\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Switching to Agg should always succeed; if it doesn't, let the\n            # exception propagate out.\n            switch_backend(\"agg\")\n            rcParamsOrig['backend'] = \"agg\"\n            return\n\n    # Backends are implemented as modules, but \"inherit\" default method\n    # implementations from backend_bases._Backend.  This is achieved by\n    # creating a \"class\" that inherits from backend_bases._Backend and whose\n    # body is filled with the module's globals.\n    backend_name = (newbackend[9:] if newbackend.startswith('module://')\n                    else f'matplotlib.backends.backend_{newbackend}')\n    backend_mod = importlib.import_module(backend_name)\n    Backend = type(\"Backend\", (matplotlib.backends._Backend,), vars(backend_mod))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend\n\n    # Only close figures if we're actually switching from an existing backend\n    if _backend_mod is not None:\n        close(\"all\")\n\n    _backend_mod = Backend\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\",\n                      \"show\", \"_get_output_canvas\"]:\n        globals()[func_name] = getattr(_backend_mod, func_name, None)\n\n    # Need to instantiate the backend on import for backward compatibility\n    # (backend modules used to be imported in `__init__.py`).\n    _backend_mod()\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, since\n    most GUI toolkits require the event loop to start before any GUI\n    operations can occur.  This restriction does not apply if the new backend\n    is non-interactive.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.pyplot\n    close_all = _backend_mod is not None\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx'}\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        candidates += [\"tkagg\", \"qtagg\", \"gtk3agg\", \"gtk4agg\", \"macosx\", \"agg\"]\n        # Don't try to import Web backends if webbrowser can't be imported\n        # (e.g. when DISPLAY is not set)\n        try:\n            import webbrowser\n            candidates += [\"webagg\"]\n        except ImportError:\n            pass\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        # If we get there, all backends failed to import.\n        switch_backend(\"agg\")  # Known to work.\n        rcParamsOrig['backend'] = \"agg\"\n        return\n\n    # Backends are imported as \"matplotlib.backends.backend_.*\".\n    backend_mod = importlib.import_module(\n        cbook._backend_module_name(newbackend))\n    Backend = _backend_registry.get(\n        newbackend, getattr(backend_mod, 'FigureCanvas', None))\n\n    if Backend is None:\n        raise RuntimeError(f\"The {newbackend!r} backend does not know how to \"\n                           f\"create a canvas or a figure manager\")\n\n    # Load the new backend, call install_repl_displayhook and\n    # update the class instances.\n    _backend_mod = backend_mod\n    install_repl_displayhook()\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.backends']._backend = backend_mod\n\n    # Only close figures if we had an existing backend (i.e., we're switching,\n    # not initializing)\n    if close_all:\n        close(\"all\")\n\n    # Set up the backend.\n    rcParams['backend'] = newbackend\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, backend_mod.backend_version)\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, since\n    most GUI toolkits require the event loop to start early and can't be\n    reinitialized. In that case, we can only switch to backends with the\n    same GUI toolkit.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod, draw_if_interactive\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    close_figures = _backend_mod is not None  # Only close figures if switching, not initializing\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx'}\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        candidates += [\n            \"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"webagg\"]\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n                break\n            except ImportError:\n                continue\n        else:\n            switch_backend(\"agg\")\n        return\n    # Backends are implemented as modules, but \"inherit\" default method\n    # implementations from backend_bases._Backend.  This is achieved by\n    # creating a \"class\" that inherits from backend_bases._Backend and whose\n    # body is filled with the module contents.\n    backend_name = (\n        newbackend[9:] if newbackend.startswith(\"module://\")\n        else f\"matplotlib.backends.backend_{newbackend}\").lower()\n    # No need to check is_interactive here: if we are, then the first\n    # matplotlib import will have set up the backend, and we can't switch.\n    if close_figures:\n        close(\"all\")\n\n    _log.debug(\"backend %s version %s\", newbackend, sys.version)\n\n    backend_mod = importlib.import_module(backend_name)\n    Backend = type(\"Backend\", (matplotlib.backends._Backend,), vars(backend_mod))\n\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\",\n                      \"show\", \"_get_running_interactive_framework\"]:\n        globals()[func_name] = getattr(backend_mod, func_name, None)\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.backends.backend'] = backend_mod\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, since\n    most GUI toolkits require the event loop to start before any GUI\n    objects can be created.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    from matplotlib.backends import backend_agg\n    close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        candidates += [\n            \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n\n    # Check if we've already imported this backend before\n    backend_name = (\n        newbackend[9:] if newbackend.startswith(\"module://\")\n        else f\"backend_{newbackend}\"\n    ).lower()\n\n    # Only close figures if we're actually switching from an existing backend\n    if _backend_mod is not None:\n        close(\"all\")\n\n    _log.debug(\"backend %s version %s\", newbackend, backend_version)\n    _backend_mod = importlib.import_module(\n        newbackend if newbackend.startswith(\"module://\")\n        else f\"matplotlib.backends.backend_{newbackend.lower()}\")\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.backends.backend'] = _backend_mod\n\n    rcParams['backend'] = newbackend\n\n    # make sure the repl display hook is installed in case we become\n    # interactive\n    install_repl_displayhook()\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI event loop is running, since\n    most GUI toolkits require the event loop to start before any window can be\n    created.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    plt.rcParams\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx'}\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        candidates += [\n            \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wx\"]\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Try default backends for non-interactive use.\n            switch_backend(\"agg\")\n            rcParamsOrig['backend'] = \"agg\"\n            return\n    # Backends are implemented as modules, but \"inherit\" default method\n    # implementations from backend_bases._Backend.  This is achieved by\n    # creating a \"class\" that inherits from backend_bases._Backend and whose\n    # body is filled with the module's globals.\n    backend_name = (newbackend[9:] if newbackend.startswith(\"module://\")\n                    else \"matplotlib.backends.backend_{}\".format(newbackend.lower()))\n\n    # Only close figures if we're actually switching backends, not during initialization\n    if _backend_mod is not None:\n        close(\"all\")\n\n    _backend_mod = importlib.import_module(backend_name)\n    canvas_class = _backend_mod.FigureCanvas\n\n    required_framework = _backend_mod.required_interactive_framework\n    if required_framework is not None:\n        current_framework = \\\n            cbook._get_running_interactive_framework()\n        if (current_framework is not None\n                and required_framework != current_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    # Load the new_figure_manager() and show() functions from the backend.\n\n    # Classically, backends can directly export these functions.  This should\n    # keep working for backcompat.\n    new_figure_manager = getattr(_backend_mod, \"new_figure_manager\", None)\n    show = getattr(_backend_mod, \"show\", None)\n    # Or they can export them from a module-level \"pyplot\" attribute (this is\n    # how we do it internally).  The latter approach is more robust as it\n    # avoids a backend exporting an incompatible `show` function by mistake.\n    if hasattr(_backend_mod, \"pyplot\"):\n        pyplot = _backend_mod.pyplot\n        new_figure_manager = getattr(pyplot, \"new_figure_manager\")\n        show = getattr(pyplot, \"show\")\n\n    # The old way of accessing the canvas class, via new_figure_manager()\n    # is deprecated in favor of accessing canvas_class directly.\n    _warn_if_gui_out_of_main_thread()\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.backends.backend_pdf'].__keep = _backend_mod\n\n    rcParams['backend'] = newbackend\n    return new_figure_manager, show\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend may be one of the standard backend names listed in\n    `~matplotlib.backend_bases` or a custom backend's module name.\n\n    Parameters\n    ----------\n    newbackend : str\n        The backend to switch to.\n\n    See Also\n    --------\n    matplotlib.get_backend : Return the name of the current backend.\n    matplotlib.use : Set the backend via the rcParam system.\n\n    Notes\n    -----\n    Switching backend may close all existing plots. Switching to an\n    interactive backend will display all figures created using pyplot.\n\n    .. versionadded:: 3.5\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    plt.rcParams\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx'}\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        candidates += [\"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"webagg\"]\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Switching to Agg should always succeed; if it doesn't, let the\n            # exception propagate out.\n            switch_backend(\"agg\")\n            rcParamsOrig['backend'] = \"agg\"\n            return\n\n    # Backends are implemented as modules, but \"inherit\" default method\n    # implementations from backend_bases._Backend.  This is achieved by\n    # creating a \"class\" that inherits from backend_bases._Backend and whose\n    # body is filled with the module's globals.\n    backend_name = (newbackend[9:] if newbackend.startswith(\"module://\")\n                    else \"matplotlib.backends.backend_{}\".format(newbackend.lower()))\n\n    # Only close figures if we're actually switching backends, not initializing\n    if _backend_mod is not None:\n        close(\"all\")\n\n    _backend_mod = importlib.import_module(backend_name)\n    canvas_class = _backend_mod.FigureCanvas\n\n    required_framework = canvas_class.required_interactive_framework\n    if required_framework is not None:\n        current_framework = cbook._get_running_interactive_framework()\n        if (current_framework is not None and\n                required_framework != current_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    # Load template docstring before adding it to pyplot.\n    plt.figure.__doc__ = _docstring.interpd.params(\n        _pylab_helpers.Gcf.figs, _backend_mod.new_figure_manager)(Figure.__init__.__doc__)\n\n    _pylab_helpers.Gcf._backend = _backend_mod\n    _pylab_helpers.Gcf.figs = {}\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.backends._backend'] = _backend_mod\n\n    # invalidate font cache, FcList soname cache etc.\n    importlib.invalidate_caches()\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend is case-insensitive.  Switching to an interactive backend\n    is possible only if no event loop for another interactive backend has\n    started.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n\n    Examples\n    --------\n    Switching to the 'Agg' backend::\n\n        plt.switch_backend('Agg')\n\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later.\n    new_backend = rcsetup.validate_backend(newbackend)\n    if new_backend == rcParams['backend']:\n        # Nothing to do if the requested backend is already set\n        pass\n    else:\n        # Only close existing figures when actually switching backends,\n        # not during initial backend setup\n        if _backend_mod is not None:\n            close(\"all\")\n\n        rcParams['backend'] = new_backend\n\n    # Need to keep a global reference to the backend_mod or the\n    # weakref will return None.\n    _backend_mod = importlib.import_module(\n        cbook._backend_module_name(rcParams['backend']))\n"
    ],
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/_pylab_helpers.py lines 77-82)": [
      "\n    def switch_backend(newbackend):\n        \"\"\"\n        Close all open figures and set the Matplotlib backend.\n\n        The backend may be one of the standard backend names listed in the\n        documentation, a module name, or a backend class instance.\n\n        Parameters\n        ----------\n        newbackend : str or `matplotlib.backend_bases.BaseBackend` subclass\n\n        See Also\n        --------\n        :doc:`/users/explain/backends`\n        matplotlib.get_backend\n        \"\"\"\n        # make sure the init is pulled up so we can assign to it later\n        import matplotlib.backends\n        if newbackend is rcsetup._auto_backend_sentinel:\n            current_framework = cbook._get_running_interactive_framework()\n            mapping = {'qt': 'qtagg',\n                       'gtk3': 'gtk3agg',\n                       'gtk4': 'gtk4agg',\n                       'tk': 'tkagg',\n                       'macosx': 'macosx',\n                       'headless': 'agg'}\n\n            best_guess = mapping.get(current_framework, None)\n            if best_guess is not None:\n                candidates = [best_guess]\n            else:\n                candidates = []\n            candidates += [\"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"agg\"]\n\n            # Don't try to fallback on the cairo-based backends as they each have\n            # an additional dependency (pycairo) over the agg-based backend, and\n            # are of worse quality.\n            for candidate in candidates:\n                try:\n                    switch_backend(candidate)\n                except ImportError:\n                    continue\n                else:\n                    rcParamsOrig['backend'] = candidate\n                    return\n            else:\n                # Switching to Agg should always succeed; if it doesn't, let the\n                # exception propagate out.\n                switch_backend(\"agg\")\n                rcParamsOrig['backend'] = \"agg\"\n                return\n\n        # Backends are implemented as modules, but \"inherit\" default method\n        # implementations from backend_bases._Backend.  This is achieved by\n        # creating a \"class\" that inherits from backend_bases._Backend and whose\n        # body is filled with the module contents.\n\n        backend_name = (newbackend if isinstance(newbackend, str)\n                        else type(newbackend).__module__)\n        # Don't warn that agg is non-interactive if explicitly requested.\n        if (not _is_backend_loading\n            and get_backend() != backend_name\n            and \".\" not in backend_name.lower()\n            and backend_name.lower() != \"agg\"):\n            _api.warn_external(\n                f\"Starting a Matplotlib GUI outside of the main thread will \"\n                f\"likely fail.\")\n\n        class backend_mod(matplotlib.backend_bases._Backend):\n            locals().update(vars(importlib.import_module(backend_name)))\n            backend_version = getattr(sys.modules[backend_name],\n                                      'backend_version', 'unknown')\n\n        def fmt_string_list(lst):\n            return (\", \".join(f\"'{x}'\" for x in lst[:-1]) +\n                    f\", and '{lst[-1]}'\")\n\n        required_framework = _get_required_interactive_framework(backend_mod)\n        if required_framework is not None:\n            current_framework = \\\n                cbook._get_running_interactive_framework()\n            if (current_framework is not None\n                    and required_framework != current_framework):\n                _api.warn_external(\n                    \"Switching to the {} backend will close all open figures. \"\n                    \"To avoid this, please ensure that your code is structured \"\n                    \"to only call pyplot functions from the main thread; see \"\n                    \"FAQ entry \\\"Working with threads\\\" for more details.\"\n                    .format(backend_name))\n\n        if newbackend is False:\n            return\n        # Only close figures if we're actually switching backends, not during initialization\n        if _backend_mod is not None:\n            close(\"all\")\n        new_figure_manager, draw_if_interactive, show = \\\n            backend_mod.new_figure_manager, \\\n            backend_mod.draw_if_interactive, \\\n            backend_mod.show\n\n        _pylab_helpers.Gcf._set_new_active_manager = \\\n            _pylab_helpers.Gcf.set_active\n        _pylab_helpers.Gcf.set_active = lambda manager: \\\n            _pylab_helpers.Gcf._set_new_active_manager(manager)\n\n        _pylab_helpers.Gcf.draw_all = draw_all\n\n        global _backend_mod, new_figure_manager, draw_if_interactive, show\n        _backend_mod = backend_mod\n        importlib.invalidate_caches()\n\n        # Need to keep a global reference to the backend for compatibility reasons.\n        # See https://github.com/matplotlib/matplotlib/issues/6092\n        sys.modules['matplotlib.backends._backend_pdf'] = backend_mod\n",
      "\n    # Set the backend case-insensitively, or raise an error if we can't.\n    # Backends are case-insensitive, as established in rcsetup.\n    try:\n        cbook._setattr_cm(sys.modules[new_backend], _backend_mod=new_backend)\n        if _backend_mod is not None:\n            close(\"all\")\n    finally:\n        _backend_mod = new_backend\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend may be one of the following:\n\n    - A backend name as a string, e.g. 'TkAgg', 'Qt5Agg', 'GTK3Agg'.\n    - An object such as a backend class or a backend instance. It must\n      implement the required backend API described in `.backend_bases`. In\n      particular, its ``FigureCanvas`` class must define a ``manager_class``\n      class attribute.\n\n    Parameters\n    ----------\n    newbackend : str or backend object\n\n    See Also\n    --------\n    :ref:`backends`\n    matplotlib.get_backend\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.pyplot\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'tk': 'tkagg',\n                   'wx': 'wxagg',\n                   'macosx': 'macosx'}\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        candidates += [\"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n                break\n            except ImportError:\n                continue\n        else:\n            switch_backend(\"agg\")\n        return\n    # Backends are installed as modules, but \"inherit\" default method\n    # implementations from backend_bases._Backend.  This is achieved by\n    # creating a \"class\" that inherits from backend_bases._Backend and has the\n    # backend module's globals as class dict (which is retrieved by\n    # importlib.import_module() below), which is analogous to types.ModuleType\n    # inheriting from object and having the module's __dict__ as instance\n    # dict.  Assigning sys.modules[name] = class_instance is analogous to\n    # sys.modules[name] = module_instance.\n    backend_mod = importlib.import_module(\n        f\"matplotlib.backends.backend_{newbackend.lower()}\")\n    Backend = type(\"Backend\", (backend_bases._Backend,), vars(backend_mod))\n\n    # Only close figures if we're switching from an existing backend,\n    # not during initial backend setup\n    if _backend_mod is not None:\n        close(\"all\")\n\n    _backend_mod = Backend\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name] = getattr(Backend, func_name)\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.backends.backend_{}'.format(\n        Backend.backend.lower())] = Backend\n",
      "\n    # Set the backend case-insensitively, or raise an error if we can't.\n    # Backends are expected to be modules in the \"matplotlib.backends\" namespace.\n    if backend_name.startswith('module://'):\n        backend_name = backend_name[9:]\n    backend_name = validate_backend(backend_name)\n    # Load the backend, and update the name if it was resolved by the\n    # auto-backend machinery to the default backend.\n    backend_mod = importlib.import_module(\n        cbook._backend_module_name(backend_name))\n    Backend = _backend_utils._backend_class_name_lookup.get(\n        backend_name, \"Backend\")\n\n    backend_mod = getattr(backend_mod, Backend, backend_mod)\n\n    # Close the old backend's figures.  Matplotlib only manages figures created\n    # by pyplot, so we cannot close user-created figures.\n    if _backend_mod is not None:\n        close(\"all\")\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name] = getattr(backend_mod, func_name)\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.backends.backend'] = backend_mod\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Set the pyplot backend to *newbackend*.\n\n    This closes all open figures.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to switch to.  This can either be one of the\n        standard backend names, which are case-insensitive:\n\n        - interactive backends:\n          GTK3Agg, GTK3Cairo, GTK4Agg, GTK4Cairo, MacOSX, nbAgg,\n          QtAgg, QtCairo, TkAgg, TkCairo, WebAgg, WX, WXAgg, WXCairo,\n          Qt5Agg, Qt5Cairo\n\n        - non-interactive backends:\n          Agg, Cairo, PDF, PS, SVG, Template\n\n        or a string of the form: ``module://my.module.name``.\n\n        Switching to an interactive backend is not possible if an unrelated\n        event loop has already been started (e.g., switching to GTK3Agg if a\n        TkAgg window has already been opened).  Switching to a non-interactive\n        backend is always possible.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.pyplot as plt\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess]\n        else:\n            candidates = []\n        candidates += [\"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"agg\"]\n        # Don't try to fallback on the cairo variants because they add a\n        # dependency.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Try default backends in the order they were originally tried for\n            # at import.\n            for candidate in [\"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"agg\"]:\n                try:\n                    switch_backend(candidate)\n                    break\n                except ImportError:\n                    continue\n            else:\n                raise ImportError(\"Failed to import any of the following Qt \"\n                                  \"binding modules: {}\".format(candidates))\n            finally:\n                rcParamsOrig['backend'] = candidate\n                return  # Save the rcParamsOrig'backend' for later.\n    else:\n        # Backends are case-insensitive\n        newbackend = newbackend.lower()\n\n    # Check if we're actually changing backends\n    if _backend_mod is not None:\n        close(\"all\")\n\n    if newbackend.startswith(\"module://\"):\n        backend_mod = importlib.import_module(newbackend[9:])\n    else:\n        backend_mod = importlib.import_module(\n            f\"matplotlib.backends.backend_{newbackend}\")\n\n    required_framework = _get_required_interactive_framework(backend_mod)\n    if required_framework is not None:\n        current_framework = cbook._get_running_interactive_framework()\n        if (current_framework is not None\n                and required_framework != current_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    # Load the new backend, save a reference to the previous one to release it.\n    new_figure_manager, new_figure_manager_given_figure = \\\n        _get_backend_mod(backend_name=newbackend, backend_mod=backend_mod)\n\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"new_figure_manager_given_figure\"]:\n        globals()[func_name] = locals()[func_name]\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.backends.backend_pdf'].__dict__.setdefault(\n        'backend_pdf', sys.modules[backend_mod.__name__])\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend may be one of the following:\n\n    - A backend name as a string, e.g. 'Qt5Agg', 'TkAgg'.\n    - 'module://my_backend' for a user-defined backend in a module called\n      my_backend.\n    - An object that implements the `.backend` protocol.\n\n    .. warning::\n\n       Switching backend will close all open figures.\n\n    Parameters\n    ----------\n    newbackend : str or backend object\n    \"\"\"\n    global _backend_mod, new_figure_manager, draw_if_interactive, show\n\n    # Short-circuit if the backend is not being changed.\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = _get_current_interactive_framework()\n        mapping = {'qt': 'qtagg', 'gtk3': 'gtk3agg', 'gtk4': 'gtk4agg',\n                   'tk': 'tkagg', 'wx': 'wxagg', 'macosx': 'macosx'}\n        best_guess = mapping.get(current_framework, None)\n        if best_guess is not None:\n            candidates = [best_guess, 'agg']\n        else:\n            candidates = ['agg']  # Defaults to Agg if no GUI is detected.\n\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in candidates:\n            try:\n                switch_backend(candidate)\n                break\n            except ImportError:\n                continue\n        else:\n            switch_backend('agg')\n        return\n\n    # Backends are implemented as modules, but \"inherit\" default method\n    # implementations from backend_bases._Backend.  This is achieved by\n    # creating a \"class\" that inherits from backend_bases._Backend and whose\n    # body is filled with the module's globals.\n    backend_name = (newbackend if isinstance(newbackend, str)\n                    else type(newbackend).__module__)\n    if backend_name.startswith('module://'):\n        backend_name = backend_name[9:]\n\n    if _backend_mod is not None:\n        close(\"all\")\n\n    _backend_mod = importlib.import_module(\n        cbook._backend_module_name(backend_name))\n    _backend_mod._backend = newbackend\n\n    new_figure_manager = _backend_mod.new_figure_manager\n    draw_if_interactive = _backend_mod.draw_if_interactive\n    show = _backend_mod.show\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    sys.modules['matplotlib.backends._backend'] = _backend_mod\n\n    # make sure the init is pulled up so we can assign to it later\n    dict.setdefault(rcParams, 'backend', rcsetup.defaultParams['backend'][0])\n    rcParams['backend'] = backend_name\n",
      "\n    def switch_backend(newbackend):\n        \"\"\"\n        Close all open figures and set the Matplotlib backend.\n\n        The backend may be one of the standard backend names listed in the\n        documentation or a custom backend's module name.\n\n        Parameters\n        ----------\n        newbackend : str\n            The backend to switch to.  This can either be one of the standard\n            backend names, which are case-insensitive:\n\n            - interactive backends:\n              GTK3Agg, GTK3Cairo, GTK4Agg, GTK4Cairo, MacOSX, nbAgg,\n              QtAgg, QtCairo, TkAgg, TkCairo, WebAgg\n\n            - non-interactive backends:\n              agg, cairo, pdf, pgf, ps, svg, template\n\n            or a string of the form: ``module://my.module.name``.\n\n            Switching to an interactive backend is not possible if an unrelated\n            event loop has already been started (e.g., switching to GTK3Agg if a\n            TkInter mainloop is already running).  This may be worked around by\n            restarting the Python process.\n        \"\"\"\n        # make sure the init is pulled up so we can assign to it later\n        import matplotlib.pyplot as plt\n        if newbackend is rcsetup._auto_backend_sentinel:\n            current_framework = cbook._get_running_interactive_framework()\n            mapping = {'qt': 'qtagg',\n                       'gtk3': 'gtk3agg',\n                       'gtk4': 'gtk4agg',\n                       'tk': 'tkagg',\n                       'macosx': 'macosx'}\n            best_guess = mapping.get(current_framework, None)\n            if best_guess is not None:\n                candidates = [best_guess]\n            else:\n                candidates = []\n            candidates += [\"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\",\n                           \"webagg\"]\n            # Don't try to fallback on the cairo variants because they add\n            # dependencies.\n            for candidate in candidates:\n                try:\n                    switch_backend(candidate)\n                except ImportError:\n                    continue\n                else:\n                    rcParamsOrig['backend'] = candidate\n                    return\n            else:\n                # Try default fallback or agg if that fails.\n                try:\n                    switch_backend(rcParamsDefault[\"backend\"])\n                except ImportError:\n                    switch_backend(\"agg\")\n                else:\n                    rcParamsOrig['backend'] = rcParamsDefault[\"backend\"]\n                return\n        else:\n            # Backends are case-insensitive.\n            newbackend = newbackend.lower()\n\n        # `plt.switch_backend(plt.get_backend())` should be a no-op.\n        # `newbackend` is lowercase and so is `_backend_mod.__name__`.\n        oldbackend = (backend_mod.__name__[12:]\n                      if backend_mod is not None else None)\n        if (oldbackend is not None and \n            newbackend == oldbackend.lower()):\n            return\n\n        # Only close figures when actually switching backends, not during initialization\n        if _backend_mod is not None:\n            close(\"all\")\n\n        backend_mod, new_figure_manager, draw_if_interactive, show = (\n            _get_backend_or_null(newbackend))\n        if backend_mod is None:\n            return\n\n        _log.debug(\"Loaded backend %s version %s.\",\n                   newbackend, backend_mod.backend_version)\n\n        rcParams['backend'] = newbackend\n        rcParamsOrig['backend'] = newbackend\n\n        global _backend_mod, new_figure_manager, draw_if_interactive, show\n        _backend_mod = backend_mod\n        new_figure_manager = new_figure_manager\n        draw_if_interactive = draw_if_interactive\n        show = show\n\n        # Need to keep a global reference to the backend for compatibility reasons.\n        # See https://github.com/matplotlib/matplotlib/issues/6092\n        sys.modules['matplotlib.backends._backend_' + newbackend] = backend_mod\n",
      "\n    @_copy_docstring_and_deprecators(matplotlib.pyplot.switch_backend)\n    def switch_backend(newbackend):\n        # make sure the init is pulled up so we can assign to it later.\n        global _backend_mod\n        if newbackend is rcsetup._auto_backend_sentinel:\n            current_framework = cbook._get_running_interactive_framework()\n            mapping = {'qt': 'qtagg', 'gtk3': 'gtk3agg', 'gtk4': 'gtk4agg',\n                       'tk': 'tkagg', 'wx': 'wxagg', 'macosx': 'macosx'}\n            best_guess = mapping.get(current_framework, None)\n            if best_guess is not None:\n                candidates = [best_guess]\n            else:\n                candidates = []\n            candidates += [\"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n            # Don't try to fallback on the cairo-based backends as they each have\n            # an additional dependency (pycairo) over the agg-based backend, and\n            # are of worse quality.\n            for candidate in candidates:\n                try:\n                    switch_backend(candidate)\n                except ImportError:\n                    continue\n                else:\n                    rcParamsOrig['backend'] = candidate\n                    return\n            else:\n                # Try default fallback which should always work.\n                switch_backend(rcParamsDefault[\"backend\"])\n                return\n        \n        # Only close figures if we're actually switching from an existing backend\n        if _backend_mod is not None:\n            close(\"all\")\n\n        if newbackend is None:\n            _backend_mod = None\n        else:\n            _backend_mod = importlib.import_module(\n                cbook._backend_module_name(newbackend))\n        backend = newbackend\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 24fcb81fc9..8ae752b521 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -74,6 +74,7 @@ class Gcf:\n     @classmethod\n     def destroy_fig(cls, fig):\n         \"\"\"Destroy figure *fig*.\"\"\"\n+\n         num = next((manager.num for manager in cls.figs.values()\n                     if manager.canvas.figure == fig), None)\n         if num is not None:\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..69e4c1cf9b 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -197,6 +197,7 @@ def _get_backend_mod():\n     Ensure that a backend is selected and return it.\n \n     This is currently private, but may be made public in the future.\n+\n     \"\"\"\n     if _backend_mod is None:\n         # Use __getitem__ here to avoid going through the fallback logic (which\n@@ -219,11 +220,13 @@ def switch_backend(newbackend):\n     newbackend : str\n         The name of the backend to use.\n     \"\"\"\n+\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n-\n+    # Only close figures if we're actually switching backends (not initializing)\n+    if _backend_mod is not None:\n+        close(\"all\")\n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n         mapping = {'qt': 'qtagg',\n@@ -937,6 +940,7 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n+\n     elif fig == 'all':\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n",
    "variant_0": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 24fcb81fc9..7b4e1491f4 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -74,12 +74,19 @@ class Gcf:\n     @classmethod\n     def destroy_fig(cls, fig):\n         \"\"\"Destroy figure *fig*.\"\"\"\n-        num = next((manager.num for manager in cls.figs.values()\n-                    if manager.canvas.figure == fig), None)\n-        if num is not None:\n-            cls.destroy(num)\n \n-    @classmethod\n+    # Set the new backend, and fire any required events.\n+    if new_figure_manager is None:\n+        # Can't switch to the given backend, so keep using the old one.\n+        return\n+    \n+    # If we're actually switching backends (not just initializing), close existing figures\n+    if _backend_mod is not None:\n+        close(\"all\")\n+    \n+    _backend_mod = backend_mod\n+    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n+        globals()[func_name] = getattr(backend_mod, func_name)\n     def destroy_all(cls):\n         \"\"\"Destroy all figures.\"\"\"\n         # Reimport gc in case the module globals have already been removed\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..3d6df7e119 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -197,14 +197,75 @@ def _get_backend_mod():\n     Ensure that a backend is selected and return it.\n \n     This is currently private, but may be made public in the future.\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to switch to.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.pyplot as plt\n+    newbackend = rcsetup.validate_backend(newbackend)\n+    if newbackend == rcParams._get_backend_or_none():\n+        # Nothing to do if the requested backend is already set\n+        pass\n+    else:\n+        # Only close figures if we're actually switching backends,\n+        # not during initial backend setup\n+        if _backend_mod is not None:\n+            close(\"all\")\n+\n+        if newbackend in rcsetup._interactive_bk:\n+            _log.info(\"Using %s backend\", newbackend)\n+        else:\n+            _log.info(\"Using non-interactive backend %s\", newbackend)\n+\n+        _backend_mod = importlib.import_module(\n+            cbook._backend_module_name(newbackend))\n+        canvas_class = _backend_mod.FigureCanvas\n+\n+        required_framework = _get_required_interactive_framework(_backend_mod)\n+        if required_framework is not None:\n+            current_framework = \\\n+                cbook._get_running_interactive_framework()\n+            if (current_framework and required_framework\n+                    and current_framework != required_framework):\n+                raise ImportError(\n+                    \"Cannot load backend {!r} which requires the {!r} \"\n+                    \"interactive framework, as {!r} is currently running\"\n+                    .format(newbackend, required_framework,\n+                            current_framework))\n+\n+        # Load backend_xxx.py and extract the FigureCanvas class.\n+        rcParams['backend'] = rcParams['backend.qt4'] = newbackend\n+        # make sure the init is pulled up so we can assign to it later\n+        import matplotlib.pyplot as plt\n+        dict.__setitem__(rcParams, 'backend', newbackend)\n+        importlib.reload(sys.modules[__name__])\n+\n+\n+def switch_backend(newbackend):\n     \"\"\"\n-    if _backend_mod is None:\n-        # Use __getitem__ here to avoid going through the fallback logic (which\n-        # will (re)import pyplot and then call switch_backend if we need to\n-        # resolve the auto sentinel)\n-        switch_backend(dict.__getitem__(rcParams, \"backend\"))\n-    return _backend_mod\n+    Close all open figures and set the Matplotlib backend.\n \n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n \n def switch_backend(newbackend):\n     \"\"\"\n@@ -222,8 +283,18 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+    if _backend_mod is not None:\n+        close(\"all\")\n \n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n         mapping = {'qt': 'qtagg',\n@@ -937,8 +1008,75 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n-    elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend may be one of the standard backend names listed in\n+    `.backend_bases.Backend` or a custom backend's module name.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    old_backend = dict.__getitem__(rcParams, 'backend')\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx'}\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess, \"agg\", \"svg\", \"pdf\", \"ps\"]\n+        else:\n+            candidates = [\"agg\", \"svg\", \"pdf\", \"ps\"]\n+            gui_framework = cbook._get_running_interactive_framework()\n+            if gui_framework:\n+                candidates = [f\"{gui_framework}agg\"] + candidates\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+            except ImportError:\n+                continue\n+            else:\n+                rcParamsOrig['backend'] = candidate\n+                return\n+        else:\n+            # At this point we've exhausted the list without success, we just\n+            # let the import error raised above propagate out.\n+            switch_backend(candidates[0])  # Raise the import error.\n+            return\n+\n+    # Backends are implemented as modules, but \"inherit\" default method\n+    # implementations from backend_bases._Backend.  This is achieved by\n+    # creating a \"class\" that inherits from backend_bases._Backend and whose\n+    # body is filled with the module's globals.\n+    backend_mod = importlib.import_module(\n+        cbook._backend_module_name(newbackend))\n+\n+    Backend = type(\"Backend\", (backend_bases._Backend,), vars(backend_mod))\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    backend_mod.Backend = Backend\n+\n+    # Only close figures if we're actually switching from an existing backend\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    _backend_mod = backend_mod\n+    for prop in dir(backend_mod):\n+        setattr(sys.modules[__name__], prop, getattr(backend_mod, prop))\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules[__name__].Backend = Backend\n+\n+    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_1": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 24fcb81fc9..72d643b2e2 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -74,12 +74,121 @@ class Gcf:\n     @classmethod\n     def destroy_fig(cls, fig):\n         \"\"\"Destroy figure *fig*.\"\"\"\n-        num = next((manager.num for manager in cls.figs.values()\n-                    if manager.canvas.figure == fig), None)\n-        if num is not None:\n-            cls.destroy(num)\n \n-    @classmethod\n+    def switch_backend(newbackend):\n+        \"\"\"\n+        Close all open figures and set the Matplotlib backend.\n+\n+        The backend may be one of the standard backend names listed in the\n+        documentation, a module name, or a backend class instance.\n+\n+        Parameters\n+        ----------\n+        newbackend : str or `matplotlib.backend_bases.BaseBackend` subclass\n+\n+        See Also\n+        --------\n+        :doc:`/users/explain/backends`\n+        matplotlib.get_backend\n+        \"\"\"\n+        # make sure the init is pulled up so we can assign to it later\n+        import matplotlib.backends\n+        if newbackend is rcsetup._auto_backend_sentinel:\n+            current_framework = cbook._get_running_interactive_framework()\n+            mapping = {'qt': 'qtagg',\n+                       'gtk3': 'gtk3agg',\n+                       'gtk4': 'gtk4agg',\n+                       'tk': 'tkagg',\n+                       'macosx': 'macosx',\n+                       'headless': 'agg'}\n+\n+            best_guess = mapping.get(current_framework, None)\n+            if best_guess is not None:\n+                candidates = [best_guess]\n+            else:\n+                candidates = []\n+            candidates += [\"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"agg\"]\n+\n+            # Don't try to fallback on the cairo-based backends as they each have\n+            # an additional dependency (pycairo) over the agg-based backend, and\n+            # are of worse quality.\n+            for candidate in candidates:\n+                try:\n+                    switch_backend(candidate)\n+                except ImportError:\n+                    continue\n+                else:\n+                    rcParamsOrig['backend'] = candidate\n+                    return\n+            else:\n+                # Switching to Agg should always succeed; if it doesn't, let the\n+                # exception propagate out.\n+                switch_backend(\"agg\")\n+                rcParamsOrig['backend'] = \"agg\"\n+                return\n+\n+        # Backends are implemented as modules, but \"inherit\" default method\n+        # implementations from backend_bases._Backend.  This is achieved by\n+        # creating a \"class\" that inherits from backend_bases._Backend and whose\n+        # body is filled with the module contents.\n+\n+        backend_name = (newbackend if isinstance(newbackend, str)\n+                        else type(newbackend).__module__)\n+        # Don't warn that agg is non-interactive if explicitly requested.\n+        if (not _is_backend_loading\n+            and get_backend() != backend_name\n+            and \".\" not in backend_name.lower()\n+            and backend_name.lower() != \"agg\"):\n+            _api.warn_external(\n+                f\"Starting a Matplotlib GUI outside of the main thread will \"\n+                f\"likely fail.\")\n+\n+        class backend_mod(matplotlib.backend_bases._Backend):\n+            locals().update(vars(importlib.import_module(backend_name)))\n+            backend_version = getattr(sys.modules[backend_name],\n+                                      'backend_version', 'unknown')\n+\n+        def fmt_string_list(lst):\n+            return (\", \".join(f\"'{x}'\" for x in lst[:-1]) +\n+                    f\", and '{lst[-1]}'\")\n+\n+        required_framework = _get_required_interactive_framework(backend_mod)\n+        if required_framework is not None:\n+            current_framework = \\\n+                cbook._get_running_interactive_framework()\n+            if (current_framework is not None\n+                    and required_framework != current_framework):\n+                _api.warn_external(\n+                    \"Switching to the {} backend will close all open figures. \"\n+                    \"To avoid this, please ensure that your code is structured \"\n+                    \"to only call pyplot functions from the main thread; see \"\n+                    \"FAQ entry \\\"Working with threads\\\" for more details.\"\n+                    .format(backend_name))\n+\n+        if newbackend is False:\n+            return\n+        # Only close figures if we're actually switching backends, not during initialization\n+        if _backend_mod is not None:\n+            close(\"all\")\n+        new_figure_manager, draw_if_interactive, show = \\\n+            backend_mod.new_figure_manager, \\\n+            backend_mod.draw_if_interactive, \\\n+            backend_mod.show\n+\n+        _pylab_helpers.Gcf._set_new_active_manager = \\\n+            _pylab_helpers.Gcf.set_active\n+        _pylab_helpers.Gcf.set_active = lambda manager: \\\n+            _pylab_helpers.Gcf._set_new_active_manager(manager)\n+\n+        _pylab_helpers.Gcf.draw_all = draw_all\n+\n+        global _backend_mod, new_figure_manager, draw_if_interactive, show\n+        _backend_mod = backend_mod\n+        importlib.invalidate_caches()\n+\n+        # Need to keep a global reference to the backend for compatibility reasons.\n+        # See https://github.com/matplotlib/matplotlib/issues/6092\n+        sys.modules['matplotlib.backends._backend_pdf'] = backend_mod\n     def destroy_all(cls):\n         \"\"\"Destroy all figures.\"\"\"\n         # Reimport gc in case the module globals have already been removed\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..62eb97abc0 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -197,15 +197,105 @@ def _get_backend_mod():\n     Ensure that a backend is selected and return it.\n \n     This is currently private, but may be made public in the future.\n+\n+def switch_backend(newbackend):\n     \"\"\"\n-    if _backend_mod is None:\n-        # Use __getitem__ here to avoid going through the fallback logic (which\n-        # will (re)import pyplot and then call switch_backend if we need to\n-        # resolve the auto sentinel)\n-        switch_backend(dict.__getitem__(rcParams, \"backend\"))\n-    return _backend_mod\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to switch to.\n+    \"\"\"\n+    global _backend_mod\n+    # Switching to the same backend should be a no-op.\n+    if (newbackend is rcsetup._auto_backend_sentinel or\n+            cbook._get_running_interactive_framework() is not None):\n+        current_framework = _get_running_interactive_framework()\n+        if current_framework is not None:\n+            required_framework = _get_required_interactive_framework(\n+                newbackend)\n+            if (required_framework is not None and\n+                    required_framework != current_framework):\n+                raise ImportError(\n+                    \"Cannot load backend {!r} which requires the {!r} \"\n+                    \"interactive framework, as {!r} is currently running\"\n+                    .format(newbackend, required_framework,\n+                            current_framework))\n+    \n+    # Only close existing figures if we're actually switching backends,\n+    # not during initial backend setup\n+    if _backend_mod is not None:\n+        close(\"all\")\n+    \n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = _get_running_interactive_framework()\n+        if current_framework is None:\n+            backend = rcParamsOrig['backend']\n+        else:\n+            backend = dict(_interactive_bk)[current_framework]\n+    else:\n+        backend = newbackend\n+    \n+    backend = cbook._backend_module_name(backend)\n+    _backend_mod = importlib.import_module(backend)\n+    \n+    # Need to keep a global reference to the backend for compatibility.\n+    sys.modules['matplotlib.backends']._backend_mod = _backend_mod\n+    \n+    # Update the rcParam so that subsequent calls to get_backend() will\n+    # return the correct value.\n+    rcParams['backend'] = backend\n+    \n+    if hasattr(_backend_mod, 'new_figure_manager'):\n+        new_figure_manager = _backend_mod.new_figure_manager\n+    else:\n+        def new_figure_manager(num, *args, **kwargs):\n+            FigureClass = kwargs.pop('FigureClass', Figure)\n+            fig = FigureClass(*args, **kwargs)\n+            return new_figure_manager_given_figure(num, fig)\n+    \n+    _pylab_helpers.Gcf.new_figure_manager = staticmethod(new_figure_manager)\n+    _pylab_helpers.Gcf.draw_all = lambda: None\n+    \n+    if hasattr(_backend_mod, 'new_figure_manager_given_figure'):\n+        new_figure_manager_given_figure = \\\n+            _backend_mod.new_figure_manager_given_figure\n+    else:\n+        def new_figure_manager_given_figure(num, figure):\n+            canvas = _backend_mod.FigureCanvas(figure)\n+            manager = _backend_mod.FigureManager(canvas, num)\n+            return manager\n+    \n+    _pylab_helpers.Gcf.new_figure_manager_given_figure = \\\n+        staticmethod(new_figure_manager_given_figure)\n+    \n+    if hasattr(_backend_mod, 'show'):\n+        show = _backend_mod.show\n+    else:\n+        show = lambda: None\n+    \n+    _pylab_helpers.Gcf.show = staticmethod(show)\n \n \n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+\n def switch_backend(newbackend):\n     \"\"\"\n     Close all open figures and set the Matplotlib backend.\n@@ -222,8 +312,8 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n-\n+    if _backend_mod is not None:\n+        close(\"all\")\n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n         mapping = {'qt': 'qtagg',\n@@ -937,8 +1027,101 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n-    elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend may be one of the standard backend names listed in the\n+    documentation or a custom backend's module name.\n+    \"\"\"\n+    global _backend_mod, new_figure_manager, draw_if_interactive, show\n+\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.pyplot as plt\n+    plt.rcParams\n+\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx'}\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        candidates += [\"agg\", \"ps\", \"pdf\", \"svg\", \"png\"]\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+            except ImportError:\n+                continue\n+            else:\n+                rcParamsOrig['backend'] = candidate\n+                return\n+        else:\n+            # Switching to Agg should always succeed; if it doesn't, let the\n+            # exception propagate out.\n+            switch_backend(\"agg\")\n+            rcParamsOrig['backend'] = \"agg\"\n+            return\n+\n+    # Backends are implemented as modules, but \"inherit\" default method\n+    # implementations from backend_bases._Backend.  This is achieved by\n+    # creating a \"class\" that inherits from backend_bases._Backend and whose\n+    # body is filled with the module's globals.\n+    backend_name = (  # Normalize backend names for backend loading.\n+        newbackend.lower()\n+        .replace('module://', '')\n+        .replace('qt5', 'qt')\n+        .replace('cairo.', 'cairo')\n+        .replace('_cairo', '')\n+    )\n+    module = importlib.import_module(\n+        f\"matplotlib.backends.backend_{backend_name}\")\n+    Backend = type(\"Backend\", (matplotlib.backends._Backend,), vars(module))\n+\n+    _log.debug(\"Loaded backend %s version %s.\",\n+               newbackend, Backend.backend_version)\n+\n+    required_framework = _get_required_interactive_framework(Backend)\n+    if required_framework is not None:\n+        current_framework = cbook._get_running_interactive_framework()\n+        if (current_framework is not None\n+                and required_framework != current_framework):\n+            raise ImportError(\n+                \"Cannot load backend {!r} which requires the {!r} interactive \"\n+                \"framework, as {!r} is currently running\".format(\n+                    newbackend, required_framework, current_framework))\n+\n+    # Only close existing figures if we're actually switching backends,\n+    # not during initial backend setup\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    _backend_mod = Backend\n+    new_figure_manager = _backend_mod.new_figure_manager\n+    draw_if_interactive = _backend_mod.draw_if_interactive\n+    show = _backend_mod.show\n+\n+    rcParams['backend'] = rcParamsDefault['backend'] = rcParamsOrig['backend'] = newbackend\n+    backend_mod = sys.modules.get('matplotlib.backends')\n+    if backend_mod is not None:\n+        def backend_mod_fmt(backend):\n+            return (backend if '://' in backend\n+                    else 'module://matplotlib.backends.backend_{}'.format(backend.lower()))\n+        backend_mod.__dict__.pop(\n+            backend_mod_fmt(rcParamsOrig['backend']), None)\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    matplotlib.backends.backend = newbackend\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_2": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 24fcb81fc9..b95b9dd4ce 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -74,12 +74,15 @@ class Gcf:\n     @classmethod\n     def destroy_fig(cls, fig):\n         \"\"\"Destroy figure *fig*.\"\"\"\n-        num = next((manager.num for manager in cls.figs.values()\n-                    if manager.canvas.figure == fig), None)\n-        if num is not None:\n-            cls.destroy(num)\n \n-    @classmethod\n+    # Set the backend case-insensitively, or raise an error if we can't.\n+    # Backends are case-insensitive, as established in rcsetup.\n+    try:\n+        cbook._setattr_cm(sys.modules[new_backend], _backend_mod=new_backend)\n+        if _backend_mod is not None:\n+            close(\"all\")\n+    finally:\n+        _backend_mod = new_backend\n     def destroy_all(cls):\n         \"\"\"Destroy all figures.\"\"\"\n         # Reimport gc in case the module globals have already been removed\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..b35bd53eeb 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -197,13 +197,64 @@ def _get_backend_mod():\n     Ensure that a backend is selected and return it.\n \n     This is currently private, but may be made public in the future.\n+\n+def switch_backend(newbackend):\n     \"\"\"\n-    if _backend_mod is None:\n-        # Use __getitem__ here to avoid going through the fallback logic (which\n-        # will (re)import pyplot and then call switch_backend if we need to\n-        # resolve the auto sentinel)\n-        switch_backend(dict.__getitem__(rcParams, \"backend\"))\n-    return _backend_mod\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to switch to.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.pyplot\n+    newbackend = rcsetup.validate_backend(newbackend)\n+    if newbackend == rcParams._get_backend_or_none():\n+        # Nothing to do if the requested backend is already set\n+        pass\n+    else:\n+        # Only close figures if we're actually switching from an existing backend,\n+        # not during initial backend setup\n+        if _backend_mod is not None:\n+            close(\"all\")\n+\n+        if newbackend in rcsetup._interactive_bk:\n+            _warn_if_gui_out_of_main_thread()\n+\n+        # Load the backend, and update the class instance if needed.\n+        backend_mod = importlib.import_module(\n+            cbook._backend_module_name(newbackend))\n+\n+        required_framework = _get_required_interactive_framework(backend_mod)\n+        if required_framework is not None:\n+            current_framework = \\\n+                cbook._get_running_interactive_framework()\n+            if (current_framework is not None and\n+                    required_framework != current_framework):\n+                raise ImportError(\n+                    \"Cannot load backend {!r} which requires the {!r} \"\n+                    \"interactive framework, as {!r} is currently running\"\n+                    .format(newbackend, required_framework,\n+                            current_framework))\n+\n+        # This must be done here (rather than in switch_backend) to handle\n+        # the case where we're running headless and the backend is changed\n+        # from the rcparams to something else after pyplot is imported.\n+        rcParams['backend'] = rcParams['backend_fallback'] = newbackend\n+        _backend_mod = backend_mod\n+        for func_name in [\"new_figure_manager\", \"draw_if_interactive\",\n+                          \"show\"]:\n+            globals()[func_name] = getattr(backend_mod, func_name)\n+\n+        # Need to keep a global reference to the backend for compatibility\n+        # reasons.  See https://github.com/matplotlib/matplotlib/issues/6092\n+        matplotlib.backends.backend = newbackend\n \n \n def switch_backend(newbackend):\n@@ -219,11 +270,12 @@ def switch_backend(newbackend):\n     newbackend : str\n         The name of the backend to use.\n     \"\"\"\n+\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n-\n+    if _backend_mod is not None:\n+        close(\"all\")\n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n         mapping = {'qt': 'qtagg',\n@@ -937,8 +989,81 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n-    elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, since\n+    most GUI toolkits require the event loop to start before any GUI\n+    objects can be created.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod, draw_if_interactive\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.backends\n+    \n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx'}\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        candidates += [\n+            \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"webagg\"]\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+            except ImportError:\n+                continue\n+            else:\n+                rcParamsOrig['backend'] = candidate\n+                return\n+        else:\n+            # Switching to Agg should always succeed; if it doesn't, let the\n+            # exception propagate out.\n+            switch_backend(\"agg\")\n+            rcParamsOrig['backend'] = \"agg\"\n+            return\n+\n+    # Backends are implemented as modules, but \"inherit\" default method\n+    # implementations from backend_bases._Backend.  This is achieved by\n+    # creating a \"class\" that inherits from backend_bases._Backend and whose\n+    # body is filled with the module's globals.\n+    backend_name = (newbackend[9:] if newbackend.startswith('module://')\n+                    else f'matplotlib.backends.backend_{newbackend}')\n+    backend_mod = importlib.import_module(backend_name)\n+    Backend = type(\"Backend\", (matplotlib.backends._Backend,), vars(backend_mod))\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    matplotlib.backends.backend = newbackend\n+\n+    # Only close figures if we're actually switching from an existing backend\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    _backend_mod = Backend\n+    for func_name in [\"new_figure_manager\", \"draw_if_interactive\",\n+                      \"show\", \"_get_output_canvas\"]:\n+        globals()[func_name] = getattr(_backend_mod, func_name, None)\n+\n+    # Need to instantiate the backend on import for backward compatibility\n+    # (backend modules used to be imported in `__init__.py`).\n+    _backend_mod()\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_3": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 24fcb81fc9..6c6d950820 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -74,12 +74,82 @@ class Gcf:\n     @classmethod\n     def destroy_fig(cls, fig):\n         \"\"\"Destroy figure *fig*.\"\"\"\n-        num = next((manager.num for manager in cls.figs.values()\n-                    if manager.canvas.figure == fig), None)\n-        if num is not None:\n-            cls.destroy(num)\n \n-    @classmethod\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend may be one of the following:\n+\n+    - A backend name as a string, e.g. 'TkAgg', 'Qt5Agg', 'GTK3Agg'.\n+    - An object such as a backend class or a backend instance. It must\n+      implement the required backend API described in `.backend_bases`. In\n+      particular, its ``FigureCanvas`` class must define a ``manager_class``\n+      class attribute.\n+\n+    Parameters\n+    ----------\n+    newbackend : str or backend object\n+\n+    See Also\n+    --------\n+    :ref:`backends`\n+    matplotlib.get_backend\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.pyplot\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg',\n+                   'wx': 'wxagg',\n+                   'macosx': 'macosx'}\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        candidates += [\"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+                break\n+            except ImportError:\n+                continue\n+        else:\n+            switch_backend(\"agg\")\n+        return\n+    # Backends are installed as modules, but \"inherit\" default method\n+    # implementations from backend_bases._Backend.  This is achieved by\n+    # creating a \"class\" that inherits from backend_bases._Backend and has the\n+    # backend module's globals as class dict (which is retrieved by\n+    # importlib.import_module() below), which is analogous to types.ModuleType\n+    # inheriting from object and having the module's __dict__ as instance\n+    # dict.  Assigning sys.modules[name] = class_instance is analogous to\n+    # sys.modules[name] = module_instance.\n+    backend_mod = importlib.import_module(\n+        f\"matplotlib.backends.backend_{newbackend.lower()}\")\n+    Backend = type(\"Backend\", (backend_bases._Backend,), vars(backend_mod))\n+\n+    # Only close figures if we're switching from an existing backend,\n+    # not during initial backend setup\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    _backend_mod = Backend\n+    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n+        globals()[func_name] = getattr(Backend, func_name)\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.backends.backend_{}'.format(\n+        Backend.backend.lower())] = Backend\n     def destroy_all(cls):\n         \"\"\"Destroy all figures.\"\"\"\n         # Reimport gc in case the module globals have already been removed\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..f151a7fcf5 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -197,13 +197,60 @@ def _get_backend_mod():\n     Ensure that a backend is selected and return it.\n \n     This is currently private, but may be made public in the future.\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to switch to.\n     \"\"\"\n-    if _backend_mod is None:\n-        # Use __getitem__ here to avoid going through the fallback logic (which\n-        # will (re)import pyplot and then call switch_backend if we need to\n-        # resolve the auto sentinel)\n-        switch_backend(dict.__getitem__(rcParams, \"backend\"))\n-    return _backend_mod\n+    global _backend_mod\n+    # Switching to the same backend should be a no-op.\n+    if (newbackend is rcsetup._auto_backend_sentinel or\n+            cbook._get_running_interactive_framework() is not None):\n+        current_framework = _get_running_interactive_framework()\n+        if current_framework is not None:\n+            required_framework = _get_required_interactive_framework(newbackend)\n+            if (required_framework is not None and\n+                    current_framework != required_framework):\n+                raise RuntimeError(\n+                    \"Cannot load backend {!r} which requires the {!r} interactive \"\n+                    \"framework, as {!r} is currently running\".format(\n+                        newbackend, required_framework, current_framework))\n+\n+    # Only close figures if we're actually switching backends, not during initialization\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        for candidate in [\"macosx\", \"qt5agg\", \"qt4agg\", \"gtk3agg\", \"tkagg\"]:\n+            try:\n+                switch_backend(candidate)\n+                break\n+            except ImportError:\n+                continue\n+        else:\n+            switch_backend(\"agg\")\n+        return\n+\n+    backend_name = (newbackend[9:] if newbackend.startswith(\"module://\")\n+                    else \"matplotlib.backends.backend_{}\".format(newbackend.lower()))\n+\n+    # Load the backend, and update the name if it was resolved by the\n+    # load_backend call (in case the argument was a module).\n+    backend_mod = importlib.import_module(backend_name)\n+    _backend_mod = backend_mod\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.pyplot']._backend_mod = backend_mod\n \n \n def switch_backend(newbackend):\n@@ -219,11 +266,55 @@ def switch_backend(newbackend):\n     newbackend : str\n         The name of the backend to use.\n     \"\"\"\n-    global _backend_mod\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, so\n+    backends with attached toolbars should be switched before any figures\n+    are created.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+\n+    Examples\n+    --------\n+    >>> switch_backend('Qt5Agg')\n+    >>> switch_backend('macosx')\n+\n+    See Also\n+    --------\n+    matplotlib.get_backend : Return the name of the current backend.\n+    matplotlib.use : Set the backend (with additional options).\n+\n+    Notes\n+    -----\n+    Switching backends will close all open figures.\n+\n+    This function is primarily intended for use in Jupyter notebooks where\n+    you may want to show some plots with one backend, then switch to another.\n+\n+    .. versionadded:: 3.1\n+    \"\"\"\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+    \n+    # Only close figures if we're actually switching backends, not initializing\n+    if _backend_mod is not None:\n+        close(\"all\")\n \n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n         mapping = {'qt': 'qtagg',\n@@ -937,8 +1028,89 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n-    elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, since\n+    most GUI toolkits require the event loop to start before any GUI\n+    operations can occur.  This restriction does not apply if the new backend\n+    is non-interactive.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.pyplot\n+    close_all = _backend_mod is not None\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx'}\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        candidates += [\"tkagg\", \"qtagg\", \"gtk3agg\", \"gtk4agg\", \"macosx\", \"agg\"]\n+        # Don't try to import Web backends if webbrowser can't be imported\n+        # (e.g. when DISPLAY is not set)\n+        try:\n+            import webbrowser\n+            candidates += [\"webagg\"]\n+        except ImportError:\n+            pass\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+            except ImportError:\n+                continue\n+            else:\n+                rcParamsOrig['backend'] = candidate\n+                return\n+        # If we get there, all backends failed to import.\n+        switch_backend(\"agg\")  # Known to work.\n+        rcParamsOrig['backend'] = \"agg\"\n+        return\n+\n+    # Backends are imported as \"matplotlib.backends.backend_.*\".\n+    backend_mod = importlib.import_module(\n+        cbook._backend_module_name(newbackend))\n+    Backend = _backend_registry.get(\n+        newbackend, getattr(backend_mod, 'FigureCanvas', None))\n+\n+    if Backend is None:\n+        raise RuntimeError(f\"The {newbackend!r} backend does not know how to \"\n+                           f\"create a canvas or a figure manager\")\n+\n+    # Load the new backend, call install_repl_displayhook and\n+    # update the class instances.\n+    _backend_mod = backend_mod\n+    install_repl_displayhook()\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.backends']._backend = backend_mod\n+\n+    # Only close figures if we had an existing backend (i.e., we're switching,\n+    # not initializing)\n+    if close_all:\n+        close(\"all\")\n+\n+    # Set up the backend.\n+    rcParams['backend'] = newbackend\n+    _log.debug(\"Loaded backend %s version %s.\",\n+               newbackend, backend_mod.backend_version)\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_4": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 24fcb81fc9..af7b894f8c 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -74,12 +74,32 @@ class Gcf:\n     @classmethod\n     def destroy_fig(cls, fig):\n         \"\"\"Destroy figure *fig*.\"\"\"\n-        num = next((manager.num for manager in cls.figs.values()\n-                    if manager.canvas.figure == fig), None)\n-        if num is not None:\n-            cls.destroy(num)\n \n-    @classmethod\n+    # Set the backend case-insensitively, or raise an error if we can't.\n+    # Backends are expected to be modules in the \"matplotlib.backends\" namespace.\n+    if backend_name.startswith('module://'):\n+        backend_name = backend_name[9:]\n+    backend_name = validate_backend(backend_name)\n+    # Load the backend, and update the name if it was resolved by the\n+    # auto-backend machinery to the default backend.\n+    backend_mod = importlib.import_module(\n+        cbook._backend_module_name(backend_name))\n+    Backend = _backend_utils._backend_class_name_lookup.get(\n+        backend_name, \"Backend\")\n+\n+    backend_mod = getattr(backend_mod, Backend, backend_mod)\n+\n+    # Close the old backend's figures.  Matplotlib only manages figures created\n+    # by pyplot, so we cannot close user-created figures.\n+    if _backend_mod is not None:\n+        close(\"all\")\n+    _backend_mod = backend_mod\n+    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n+        globals()[func_name] = getattr(backend_mod, func_name)\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.backends.backend'] = backend_mod\n     def destroy_all(cls):\n         \"\"\"Destroy all figures.\"\"\"\n         # Reimport gc in case the module globals have already been removed\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..b369768a8c 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -197,14 +197,65 @@ def _get_backend_mod():\n     Ensure that a backend is selected and return it.\n \n     This is currently private, but may be made public in the future.\n+\n+def switch_backend(newbackend):\n     \"\"\"\n-    if _backend_mod is None:\n-        # Use __getitem__ here to avoid going through the fallback logic (which\n-        # will (re)import pyplot and then call switch_backend if we need to\n-        # resolve the auto sentinel)\n-        switch_backend(dict.__getitem__(rcParams, \"backend\"))\n-    return _backend_mod\n+    Close all open figures and set the Matplotlib backend.\n \n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to switch to.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.pyplot as plt\n+    newbackend = cbook._backend_module_name(newbackend)\n+    if newbackend == cbook._backend_module_name(_get_backend()):\n+        # Nothing to do if the requested backend is already set\n+        return\n+\n+    # Only close all figures if we're actually switching backends,\n+    # not during initial backend setup\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    if newbackend in rcsetup._interactive_bk:\n+        _log.debug(\"Loaded backend %s version %s.\", newbackend,\n+                   sys.modules[newbackend].backend_version)\n+\n+    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n+\n+    # Load the new backend\n+    _backend_mod = importlib.import_module(\n+        cbook._backend_module_name(newbackend))\n+\n+    # Now that we've loaded the backend, we need to trigger any\n+    # post-import backend initialization that may be needed.\n+    canvas_class = _backend_mod.FigureCanvas\n+\n+    required_framework = _get_required_interactive_framework(_backend_mod)\n+    if required_framework is not None:\n+        ipython = _c_internal_utils.ipython_pylab_setup(required_framework)\n+\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n \n def switch_backend(newbackend):\n     \"\"\"\n@@ -222,8 +273,18 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+    if _backend_mod is not None:\n+        close(\"all\")\n \n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n         mapping = {'qt': 'qtagg',\n@@ -937,8 +998,76 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n-    elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, since\n+    most GUI toolkits require the event loop to start early and can't be\n+    reinitialized. In that case, we can only switch to backends with the\n+    same GUI toolkit.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod, draw_if_interactive\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.backends\n+    close_figures = _backend_mod is not None  # Only close figures if switching, not initializing\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx'}\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        candidates += [\n+            \"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"webagg\"]\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+                break\n+            except ImportError:\n+                continue\n+        else:\n+            switch_backend(\"agg\")\n+        return\n+    # Backends are implemented as modules, but \"inherit\" default method\n+    # implementations from backend_bases._Backend.  This is achieved by\n+    # creating a \"class\" that inherits from backend_bases._Backend and whose\n+    # body is filled with the module contents.\n+    backend_name = (\n+        newbackend[9:] if newbackend.startswith(\"module://\")\n+        else f\"matplotlib.backends.backend_{newbackend}\").lower()\n+    # No need to check is_interactive here: if we are, then the first\n+    # matplotlib import will have set up the backend, and we can't switch.\n+    if close_figures:\n+        close(\"all\")\n+\n+    _log.debug(\"backend %s version %s\", newbackend, sys.version)\n+\n+    backend_mod = importlib.import_module(backend_name)\n+    Backend = type(\"Backend\", (matplotlib.backends._Backend,), vars(backend_mod))\n+\n+    _backend_mod = backend_mod\n+    for func_name in [\"new_figure_manager\", \"draw_if_interactive\",\n+                      \"show\", \"_get_running_interactive_framework\"]:\n+        globals()[func_name] = getattr(backend_mod, func_name, None)\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.backends.backend'] = backend_mod\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_5": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 24fcb81fc9..bd66ddd745 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -74,12 +74,113 @@ class Gcf:\n     @classmethod\n     def destroy_fig(cls, fig):\n         \"\"\"Destroy figure *fig*.\"\"\"\n-        num = next((manager.num for manager in cls.figs.values()\n-                    if manager.canvas.figure == fig), None)\n-        if num is not None:\n-            cls.destroy(num)\n \n-    @classmethod\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Set the pyplot backend to *newbackend*.\n+\n+    This closes all open figures.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to switch to.  This can either be one of the\n+        standard backend names, which are case-insensitive:\n+\n+        - interactive backends:\n+          GTK3Agg, GTK3Cairo, GTK4Agg, GTK4Cairo, MacOSX, nbAgg,\n+          QtAgg, QtCairo, TkAgg, TkCairo, WebAgg, WX, WXAgg, WXCairo,\n+          Qt5Agg, Qt5Cairo\n+\n+        - non-interactive backends:\n+          Agg, Cairo, PDF, PS, SVG, Template\n+\n+        or a string of the form: ``module://my.module.name``.\n+\n+        Switching to an interactive backend is not possible if an unrelated\n+        event loop has already been started (e.g., switching to GTK3Agg if a\n+        TkAgg window has already been opened).  Switching to a non-interactive\n+        backend is always possible.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.pyplot as plt\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n+\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        candidates += [\"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"agg\"]\n+        # Don't try to fallback on the cairo variants because they add a\n+        # dependency.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+            except ImportError:\n+                continue\n+            else:\n+                rcParamsOrig['backend'] = candidate\n+                return\n+        else:\n+            # Try default backends in the order they were originally tried for\n+            # at import.\n+            for candidate in [\"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"agg\"]:\n+                try:\n+                    switch_backend(candidate)\n+                    break\n+                except ImportError:\n+                    continue\n+            else:\n+                raise ImportError(\"Failed to import any of the following Qt \"\n+                                  \"binding modules: {}\".format(candidates))\n+            finally:\n+                rcParamsOrig['backend'] = candidate\n+                return  # Save the rcParamsOrig'backend' for later.\n+    else:\n+        # Backends are case-insensitive\n+        newbackend = newbackend.lower()\n+\n+    # Check if we're actually changing backends\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    if newbackend.startswith(\"module://\"):\n+        backend_mod = importlib.import_module(newbackend[9:])\n+    else:\n+        backend_mod = importlib.import_module(\n+            f\"matplotlib.backends.backend_{newbackend}\")\n+\n+    required_framework = _get_required_interactive_framework(backend_mod)\n+    if required_framework is not None:\n+        current_framework = cbook._get_running_interactive_framework()\n+        if (current_framework is not None\n+                and required_framework != current_framework):\n+            raise ImportError(\n+                \"Cannot load backend {!r} which requires the {!r} interactive \"\n+                \"framework, as {!r} is currently running\".format(\n+                    newbackend, required_framework, current_framework))\n+\n+    # Load the new backend, save a reference to the previous one to release it.\n+    new_figure_manager, new_figure_manager_given_figure = \\\n+        _get_backend_mod(backend_name=newbackend, backend_mod=backend_mod)\n+\n+    _backend_mod = backend_mod\n+    for func_name in [\"new_figure_manager\", \"new_figure_manager_given_figure\"]:\n+        globals()[func_name] = locals()[func_name]\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.backends.backend_pdf'].__dict__.setdefault(\n+        'backend_pdf', sys.modules[backend_mod.__name__])\n     def destroy_all(cls):\n         \"\"\"Destroy all figures.\"\"\"\n         # Reimport gc in case the module globals have already been removed\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..e5b89ed6c9 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -197,13 +197,38 @@ def _get_backend_mod():\n     Ensure that a backend is selected and return it.\n \n     This is currently private, but may be made public in the future.\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to switch to.\n     \"\"\"\n-    if _backend_mod is None:\n-        # Use __getitem__ here to avoid going through the fallback logic (which\n-        # will (re)import pyplot and then call switch_backend if we need to\n-        # resolve the auto sentinel)\n-        switch_backend(dict.__getitem__(rcParams, \"backend\"))\n-    return _backend_mod\n+    # Check if we're actually switching backends or just initializing\n+    if _backend_mod is not None:\n+        # Only close figures when actually switching, not during initialization\n+        close(\"all\")\n+\n+    global _backend_mod, _backend_mod_name\n+    newbackend = rcsetup.validate_backend(newbackend)\n+    if newbackend.startswith(\"module://\"):\n+        module = importlib.import_module(newbackend[9:])\n+    else:\n+        module = importlib.import_module(\n+            f\"matplotlib.backends.backend_{newbackend.lower()}\")\n+    _backend_mod = module\n+    _backend_mod_name = newbackend\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.pyplot']._backend_mod = module\n \n \n def switch_backend(newbackend):\n@@ -219,11 +244,139 @@ def switch_backend(newbackend):\n     newbackend : str\n         The name of the backend to use.\n     \"\"\"\n-    global _backend_mod\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, so if you\n+    are using an interactive backend from an ordinary Python shell, it will\n+    be necessary to run ``%matplotlib`` again.\n+\n+    .. warning::\n+\n+        Since closing the figures is not a reversible operation, it is\n+        recommended to first save your work.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        A backend name, which is one of the following strings:\n+        'Agg', 'Cairo', 'MacOSX', 'PGF', 'PS', 'Qt5Agg', 'SVG', 'TkAgg',\n+        'WX', 'WXAgg', 'GTK3Cairo', 'GTK3Agg', 'WebAgg', 'nbAgg'.\n+        Case-insensitive.\n+\n+    See Also\n+    --------\n+    matplotlib.get_backend : Return the name of the current backend.\n+    matplotlib.use : Select the backend used by Matplotlib.\n+    :ref:`backends`\n+\n+    \"\"\"\n+    # Switching to an interactive backend is possible only if no event loop\n+    # for another interactive backend has started.\n+\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+    switcher = matplotlib.backends.pylab_setup  # delay loading of module\n+\n+    if newbackend.startswith(\"module://\"):\n+        module_name = newbackend[9:]\n+    else:\n+        module_name = f\"matplotlib.backends.backend_{newbackend.lower()}\"\n+\n+    # don't (prematurely) resolve the \"auto\" backend setting\n+    if newbackend != rcsetup._auto_backend_sentinel:\n+        backend = newbackend\n+    else:\n+        backend = rcParams._get_backend_or_none()\n+\n+    # Code for switching between backends.\n+\n+    # Do this even for non-interactive backends so that we get a\n+    # consistent state upon repeated calls to switch_backend().\n+\n+    # A user may want to re-select a backend that they have modified.\n+    # In that case, the module may already be imported, but is not the\n+    # backend being used.  So we may need to reload it.\n+\n+    # Short-circuit if the new backend is the same as the old backend.\n+    # In that case we can avoid the expensive close-all-figures step.\n+    if (backend == matplotlib.get_backend()\n+            and module_name in sys.modules):\n+        return\n+\n+    # A small amount of state is stored in pyplot itself, rather than\n+    # in the backend.  We need to clear this state when switching.\n+\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n+\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        candidates += [\"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n+\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+            except ImportError:\n+                continue\n+            else:\n+                rcParamsOrig['backend'] = candidate\n+                return\n+        else:\n+            switch_backend(\"agg\")\n+            rcParamsOrig['backend'] = \"agg\"\n+            return\n+    else:\n+        # Backends are imported and selected here, and apart from an\n+        # appropriate cleanup, this is where backend switching happens.\n+\n+        # This is certainly one of the permanent ways to do this.\n+        # It would be nicer if there were a good way to save and restore\n+        # the state of the current figure manager.\n+        global _backend_mod\n+        # make sure the init is pulled up so we can assign to it later\n+        import matplotlib.backends\n+        # Only close figures if we're actually switching backends, not initializing\n+        if _backend_mod is not None:\n+            close(\"all\")\n+\n+        if newbackend.startswith(\"module://\"):\n+            module_name = newbackend[9:]\n+            backend_name = module_name\n+        else:\n+            backend_name = \"backend_{}\".format(newbackend.lower())\n+            module_name = \"matplotlib.backends.{}\".format(backend_name)\n+\n+        _backend_mod, new_figure_manager, draw_if_interactive, _show = \\\n+            matplotlib.backends.pylab_setup(module_name)\n \n+        # Need to keep a global reference to the backend for compatibility\n+        # reasons.  See https://github.com/matplotlib/matplotlib/issues/6092\n+        matplotlib.backends.backend = backend_name\n+\n+        # make sure the repl display hook is installed in case we become\n+        # interactive\n+        install_repl_displayhook()\n+\n+        # This must be imported last in the matplotlib.backends.__init__,\n+        # which is why we do it here.\n+        matplotlib.backends._backend_loading.backend_registry._ensure_backend(\n+            backend_name)\n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n         mapping = {'qt': 'qtagg',\n@@ -937,8 +1090,78 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n-    elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, since\n+    most GUI toolkits require the event loop to start before any GUI\n+    objects can be created.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    from matplotlib.backends import backend_agg\n+    close(\"all\")\n+\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n+\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        candidates += [\n+            \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n+\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+            except ImportError:\n+                continue\n+            else:\n+                rcParamsOrig['backend'] = candidate\n+                return\n+\n+    # Check if we've already imported this backend before\n+    backend_name = (\n+        newbackend[9:] if newbackend.startswith(\"module://\")\n+        else f\"backend_{newbackend}\"\n+    ).lower()\n+\n+    # Only close figures if we're actually switching from an existing backend\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    _log.debug(\"backend %s version %s\", newbackend, backend_version)\n+    _backend_mod = importlib.import_module(\n+        newbackend if newbackend.startswith(\"module://\")\n+        else f\"matplotlib.backends.backend_{newbackend.lower()}\")\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.backends.backend'] = _backend_mod\n+\n+    rcParams['backend'] = newbackend\n+\n+    # make sure the repl display hook is installed in case we become\n+    # interactive\n+    install_repl_displayhook()\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_6": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 24fcb81fc9..3fa5ef6332 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -74,12 +74,79 @@ class Gcf:\n     @classmethod\n     def destroy_fig(cls, fig):\n         \"\"\"Destroy figure *fig*.\"\"\"\n-        num = next((manager.num for manager in cls.figs.values()\n-                    if manager.canvas.figure == fig), None)\n-        if num is not None:\n-            cls.destroy(num)\n \n-    @classmethod\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend may be one of the following:\n+\n+    - A backend name as a string, e.g. 'Qt5Agg', 'TkAgg'.\n+    - 'module://my_backend' for a user-defined backend in a module called\n+      my_backend.\n+    - An object that implements the `.backend` protocol.\n+\n+    .. warning::\n+\n+       Switching backend will close all open figures.\n+\n+    Parameters\n+    ----------\n+    newbackend : str or backend object\n+    \"\"\"\n+    global _backend_mod, new_figure_manager, draw_if_interactive, show\n+\n+    # Short-circuit if the backend is not being changed.\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = _get_current_interactive_framework()\n+        mapping = {'qt': 'qtagg', 'gtk3': 'gtk3agg', 'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg', 'wx': 'wxagg', 'macosx': 'macosx'}\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess, 'agg']\n+        else:\n+            candidates = ['agg']  # Defaults to Agg if no GUI is detected.\n+\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+                break\n+            except ImportError:\n+                continue\n+        else:\n+            switch_backend('agg')\n+        return\n+\n+    # Backends are implemented as modules, but \"inherit\" default method\n+    # implementations from backend_bases._Backend.  This is achieved by\n+    # creating a \"class\" that inherits from backend_bases._Backend and whose\n+    # body is filled with the module's globals.\n+    backend_name = (newbackend if isinstance(newbackend, str)\n+                    else type(newbackend).__module__)\n+    if backend_name.startswith('module://'):\n+        backend_name = backend_name[9:]\n+\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    _backend_mod = importlib.import_module(\n+        cbook._backend_module_name(backend_name))\n+    _backend_mod._backend = newbackend\n+\n+    new_figure_manager = _backend_mod.new_figure_manager\n+    draw_if_interactive = _backend_mod.draw_if_interactive\n+    show = _backend_mod.show\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.backends._backend'] = _backend_mod\n+\n+    # make sure the init is pulled up so we can assign to it later\n+    dict.setdefault(rcParams, 'backend', rcsetup.defaultParams['backend'][0])\n+    rcParams['backend'] = backend_name\n     def destroy_all(cls):\n         \"\"\"Destroy all figures.\"\"\"\n         # Reimport gc in case the module globals have already been removed\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..83758e5f3d 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -197,13 +197,55 @@ def _get_backend_mod():\n     Ensure that a backend is selected and return it.\n \n     This is currently private, but may be made public in the future.\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to switch to.\n     \"\"\"\n-    if _backend_mod is None:\n-        # Use __getitem__ here to avoid going through the fallback logic (which\n-        # will (re)import pyplot and then call switch_backend if we need to\n-        # resolve the auto sentinel)\n-        switch_backend(dict.__getitem__(rcParams, \"backend\"))\n-    return _backend_mod\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.pyplot as plt\n+    newbackend = _validate_backend(newbackend)\n+    backend_name = newbackend.lower()\n+\n+    # Only close figures if we're actually switching backends, not initializing\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    if backend_name.startswith(\"module://\"):\n+        backend_mod = importlib.import_module(backend_name[9:])\n+    else:\n+        backend_mod = importlib.import_module(\n+            f\"matplotlib.backends.backend_{backend_name}\")\n+\n+    canvas_class = backend_mod.FigureCanvas\n+\n+    required_framework = _get_required_interactive_framework(backend_mod)\n+    if required_framework is not None:\n+        current_framework = \\\n+            _get_running_interactive_framework()\n+        if (current_framework is not None and\n+                current_framework is not required_framework):\n+            raise ImportError(\n+                \"Cannot load backend {!r} which requires the {!r} interactive \"\n+                \"framework, as {!r} is currently running\".format(\n+                    newbackend, required_framework.name,\n+                    current_framework.name))\n+\n+    # Load the new backend.\n+    _backend_mod = backend_mod\n+    for fcm in Gcf.get_all_fig_managers():\n+        fcm.canvas.figure.set_canvas(canvas_class(fcm.canvas.figure))\n+    _pylab_helpers.Gcf._activeQue = []\n \n \n def switch_backend(newbackend):\n@@ -219,11 +261,44 @@ def switch_backend(newbackend):\n     newbackend : str\n         The name of the backend to use.\n     \"\"\"\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, so\n+    backends that are classified as interactive will raise an exception\n+    if you try to change from a non-interactive backend to an interactive\n+    one, or if you try to change from one interactive backend to another.\n+\n+    This limitation does not apply if the backend is changed from within a\n+    plotting context manager such as with ``matplotlib.style.context()``\n+    or :doc:`/tutorials/introductory/customizing`.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+    if _backend_mod is not None:\n+        close(\"all\")\n \n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n         mapping = {'qt': 'qtagg',\n@@ -937,8 +1012,102 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n-    elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI event loop is running, since\n+    most GUI toolkits require the event loop to start before any window can be\n+    created.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    plt.rcParams\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx'}\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        candidates += [\n+            \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wx\"]\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+            except ImportError:\n+                continue\n+            else:\n+                rcParamsOrig['backend'] = candidate\n+                return\n+        else:\n+            # Try default backends for non-interactive use.\n+            switch_backend(\"agg\")\n+            rcParamsOrig['backend'] = \"agg\"\n+            return\n+    # Backends are implemented as modules, but \"inherit\" default method\n+    # implementations from backend_bases._Backend.  This is achieved by\n+    # creating a \"class\" that inherits from backend_bases._Backend and whose\n+    # body is filled with the module's globals.\n+    backend_name = (newbackend[9:] if newbackend.startswith(\"module://\")\n+                    else \"matplotlib.backends.backend_{}\".format(newbackend.lower()))\n+\n+    # Only close figures if we're actually switching backends, not during initialization\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    _backend_mod = importlib.import_module(backend_name)\n+    canvas_class = _backend_mod.FigureCanvas\n+\n+    required_framework = _backend_mod.required_interactive_framework\n+    if required_framework is not None:\n+        current_framework = \\\n+            cbook._get_running_interactive_framework()\n+        if (current_framework is not None\n+                and required_framework != current_framework):\n+            raise ImportError(\n+                \"Cannot load backend {!r} which requires the {!r} interactive \"\n+                \"framework, as {!r} is currently running\".format(\n+                    newbackend, required_framework, current_framework))\n+\n+    # Load the new_figure_manager() and show() functions from the backend.\n+\n+    # Classically, backends can directly export these functions.  This should\n+    # keep working for backcompat.\n+    new_figure_manager = getattr(_backend_mod, \"new_figure_manager\", None)\n+    show = getattr(_backend_mod, \"show\", None)\n+    # Or they can export them from a module-level \"pyplot\" attribute (this is\n+    # how we do it internally).  The latter approach is more robust as it\n+    # avoids a backend exporting an incompatible `show` function by mistake.\n+    if hasattr(_backend_mod, \"pyplot\"):\n+        pyplot = _backend_mod.pyplot\n+        new_figure_manager = getattr(pyplot, \"new_figure_manager\")\n+        show = getattr(pyplot, \"show\")\n+\n+    # The old way of accessing the canvas class, via new_figure_manager()\n+    # is deprecated in favor of accessing canvas_class directly.\n+    _warn_if_gui_out_of_main_thread()\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.backends.backend_pdf'].__keep = _backend_mod\n+\n+    rcParams['backend'] = newbackend\n+    return new_figure_manager, show\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_7": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 24fcb81fc9..e31f10f1c2 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -74,12 +74,105 @@ class Gcf:\n     @classmethod\n     def destroy_fig(cls, fig):\n         \"\"\"Destroy figure *fig*.\"\"\"\n-        num = next((manager.num for manager in cls.figs.values()\n-                    if manager.canvas.figure == fig), None)\n-        if num is not None:\n-            cls.destroy(num)\n \n-    @classmethod\n+    def switch_backend(newbackend):\n+        \"\"\"\n+        Close all open figures and set the Matplotlib backend.\n+\n+        The backend may be one of the standard backend names listed in the\n+        documentation or a custom backend's module name.\n+\n+        Parameters\n+        ----------\n+        newbackend : str\n+            The backend to switch to.  This can either be one of the standard\n+            backend names, which are case-insensitive:\n+\n+            - interactive backends:\n+              GTK3Agg, GTK3Cairo, GTK4Agg, GTK4Cairo, MacOSX, nbAgg,\n+              QtAgg, QtCairo, TkAgg, TkCairo, WebAgg\n+\n+            - non-interactive backends:\n+              agg, cairo, pdf, pgf, ps, svg, template\n+\n+            or a string of the form: ``module://my.module.name``.\n+\n+            Switching to an interactive backend is not possible if an unrelated\n+            event loop has already been started (e.g., switching to GTK3Agg if a\n+            TkInter mainloop is already running).  This may be worked around by\n+            restarting the Python process.\n+        \"\"\"\n+        # make sure the init is pulled up so we can assign to it later\n+        import matplotlib.pyplot as plt\n+        if newbackend is rcsetup._auto_backend_sentinel:\n+            current_framework = cbook._get_running_interactive_framework()\n+            mapping = {'qt': 'qtagg',\n+                       'gtk3': 'gtk3agg',\n+                       'gtk4': 'gtk4agg',\n+                       'tk': 'tkagg',\n+                       'macosx': 'macosx'}\n+            best_guess = mapping.get(current_framework, None)\n+            if best_guess is not None:\n+                candidates = [best_guess]\n+            else:\n+                candidates = []\n+            candidates += [\"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\",\n+                           \"webagg\"]\n+            # Don't try to fallback on the cairo variants because they add\n+            # dependencies.\n+            for candidate in candidates:\n+                try:\n+                    switch_backend(candidate)\n+                except ImportError:\n+                    continue\n+                else:\n+                    rcParamsOrig['backend'] = candidate\n+                    return\n+            else:\n+                # Try default fallback or agg if that fails.\n+                try:\n+                    switch_backend(rcParamsDefault[\"backend\"])\n+                except ImportError:\n+                    switch_backend(\"agg\")\n+                else:\n+                    rcParamsOrig['backend'] = rcParamsDefault[\"backend\"]\n+                return\n+        else:\n+            # Backends are case-insensitive.\n+            newbackend = newbackend.lower()\n+\n+        # `plt.switch_backend(plt.get_backend())` should be a no-op.\n+        # `newbackend` is lowercase and so is `_backend_mod.__name__`.\n+        oldbackend = (backend_mod.__name__[12:]\n+                      if backend_mod is not None else None)\n+        if (oldbackend is not None and \n+            newbackend == oldbackend.lower()):\n+            return\n+\n+        # Only close figures when actually switching backends, not during initialization\n+        if _backend_mod is not None:\n+            close(\"all\")\n+\n+        backend_mod, new_figure_manager, draw_if_interactive, show = (\n+            _get_backend_or_null(newbackend))\n+        if backend_mod is None:\n+            return\n+\n+        _log.debug(\"Loaded backend %s version %s.\",\n+                   newbackend, backend_mod.backend_version)\n+\n+        rcParams['backend'] = newbackend\n+        rcParamsOrig['backend'] = newbackend\n+\n+        global _backend_mod, new_figure_manager, draw_if_interactive, show\n+        _backend_mod = backend_mod\n+        new_figure_manager = new_figure_manager\n+        draw_if_interactive = draw_if_interactive\n+        show = show\n+\n+        # Need to keep a global reference to the backend for compatibility reasons.\n+        # See https://github.com/matplotlib/matplotlib/issues/6092\n+        sys.modules['matplotlib.backends._backend_' + newbackend] = backend_mod\n     def destroy_all(cls):\n         \"\"\"Destroy all figures.\"\"\"\n         # Reimport gc in case the module globals have already been removed\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..d598ff8d4f 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -197,19 +197,95 @@ def _get_backend_mod():\n     Ensure that a backend is selected and return it.\n \n     This is currently private, but may be made public in the future.\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to switch to.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.pyplot\n+    newbackend = rcsetup.validate_backend(newbackend)\n+    if newbackend == rcParams._get_backend_or_none():\n+        # Nothing to do if the requested backend is already set\n+        pass\n+    else:\n+        # Only close all figures if we're actually switching backends,\n+        # not during initial backend setup\n+        if _backend_mod is not None:\n+            close(\"all\")\n+\n+        if newbackend in rcsetup._interactive_bk:\n+            _warn_if_gui_out_of_main_thread()\n+\n+        # Load the backend, and update the rcParam.\n+        rcParams[\"backend\"] = newbackend\n+        _backend_mod = backend_mod = importlib.import_module(\n+            cbook._backend_module_name(newbackend))\n+\n+        # This must be imported and cached before switching the backend, so that\n+        # `plt.show` can be called in non-IPython shells without triggering\n+        # `ipython.py`'s `configure_inline_support` to request and cache a\n+        # different backend than the one we just set.\n+        if \"IPython\" in sys.modules:\n+            from IPython import get_ipython\n+            ip = get_ipython()\n+            if ip is not None:\n+                ip.enable_matplotlib(newbackend)\n+\n+        # Set up the backend.\n+        install_repl_displayhook()\n+\n+        # The validation should be handled by the backend.\n+        if hasattr(backend_mod, \"FigureCanvas\"):\n+            new_figure_manager, draw_if_interactive, _show = _backend_mod_supports_v3_1(backend_mod)\n+        else:\n+            new_figure_manager = backend_mod.new_figure_manager\n+            draw_if_interactive = backend_mod.draw_if_interactive\n+            _show = backend_mod.show\n+\n+        _pylab_helpers.Gcf.set_active(None)\n+        if hasattr(backend_mod, \"FigureManager\"):\n+            _pylab_helpers.Gcf.figs = {}\n+\n+        # Need to keep a global reference to the backend for compatibility\n+        # reasons.  See issues #7410, #9559.\n+        globals()['new_figure_manager'] = new_figure_manager\n+        globals()['draw_if_interactive'] = draw_if_interactive\n+        globals()['_show'] = _show\n+\n+\n+def switch_backend(newbackend):\n     \"\"\"\n-    if _backend_mod is None:\n-        # Use __getitem__ here to avoid going through the fallback logic (which\n-        # will (re)import pyplot and then call switch_backend if we need to\n-        # resolve the auto sentinel)\n-        switch_backend(dict.__getitem__(rcParams, \"backend\"))\n-    return _backend_mod\n+    Close all open figures and set the Matplotlib backend.\n \n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n \n def switch_backend(newbackend):\n     \"\"\"\n     Close all open figures and set the Matplotlib backend.\n \n+    The backend may be one of the standard backend names listed in the\n+    documentation or a module name.  In the latter case, the module must\n+    export a ``FigureCanvas`` class and a ``show`` function.\n+\n     The argument is case-insensitive.  Switching to an interactive backend is\n     possible only if no event loop for another interactive backend has started.\n     Switching to and from non-interactive backends is always possible.\n@@ -222,8 +298,8 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n-\n+    if _backend_mod is not None:\n+        close(\"all\")\n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n         mapping = {'qt': 'qtagg',\n@@ -937,8 +1013,102 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n-    elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend may be one of the standard backend names listed in\n+    `~matplotlib.backend_bases` or a custom backend's module name.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The backend to switch to.\n+\n+    See Also\n+    --------\n+    matplotlib.get_backend : Return the name of the current backend.\n+    matplotlib.use : Set the backend via the rcParam system.\n+\n+    Notes\n+    -----\n+    Switching backend may close all existing plots. Switching to an\n+    interactive backend will display all figures created using pyplot.\n+\n+    .. versionadded:: 3.5\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    plt.rcParams\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx'}\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        candidates += [\"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"webagg\"]\n+        # Don't try to fallback on the cairo-based backends as they each have\n+        # an additional dependency (pycairo) over the agg-based backend, and\n+        # are of worse quality.\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+            except ImportError:\n+                continue\n+            else:\n+                rcParamsOrig['backend'] = candidate\n+                return\n+        else:\n+            # Switching to Agg should always succeed; if it doesn't, let the\n+            # exception propagate out.\n+            switch_backend(\"agg\")\n+            rcParamsOrig['backend'] = \"agg\"\n+            return\n+\n+    # Backends are implemented as modules, but \"inherit\" default method\n+    # implementations from backend_bases._Backend.  This is achieved by\n+    # creating a \"class\" that inherits from backend_bases._Backend and whose\n+    # body is filled with the module's globals.\n+    backend_name = (newbackend[9:] if newbackend.startswith(\"module://\")\n+                    else \"matplotlib.backends.backend_{}\".format(newbackend.lower()))\n+\n+    # Only close figures if we're actually switching backends, not initializing\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    _backend_mod = importlib.import_module(backend_name)\n+    canvas_class = _backend_mod.FigureCanvas\n+\n+    required_framework = canvas_class.required_interactive_framework\n+    if required_framework is not None:\n+        current_framework = cbook._get_running_interactive_framework()\n+        if (current_framework is not None and\n+                required_framework != current_framework):\n+            raise ImportError(\n+                \"Cannot load backend {!r} which requires the {!r} interactive \"\n+                \"framework, as {!r} is currently running\".format(\n+                    newbackend, required_framework, current_framework))\n+\n+    # Load template docstring before adding it to pyplot.\n+    plt.figure.__doc__ = _docstring.interpd.params(\n+        _pylab_helpers.Gcf.figs, _backend_mod.new_figure_manager)(Figure.__init__.__doc__)\n+\n+    _pylab_helpers.Gcf._backend = _backend_mod\n+    _pylab_helpers.Gcf.figs = {}\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.backends._backend'] = _backend_mod\n+\n+    # invalidate font cache, FcList soname cache etc.\n+    importlib.invalidate_caches()\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_8": "diff --git a/lib/matplotlib/_pylab_helpers.py b/lib/matplotlib/_pylab_helpers.py\nindex 24fcb81fc9..a5fc453739 100644\n--- a/lib/matplotlib/_pylab_helpers.py\n+++ b/lib/matplotlib/_pylab_helpers.py\n@@ -74,12 +74,47 @@ class Gcf:\n     @classmethod\n     def destroy_fig(cls, fig):\n         \"\"\"Destroy figure *fig*.\"\"\"\n-        num = next((manager.num for manager in cls.figs.values()\n-                    if manager.canvas.figure == fig), None)\n-        if num is not None:\n-            cls.destroy(num)\n \n-    @classmethod\n+    @_copy_docstring_and_deprecators(matplotlib.pyplot.switch_backend)\n+    def switch_backend(newbackend):\n+        # make sure the init is pulled up so we can assign to it later.\n+        global _backend_mod\n+        if newbackend is rcsetup._auto_backend_sentinel:\n+            current_framework = cbook._get_running_interactive_framework()\n+            mapping = {'qt': 'qtagg', 'gtk3': 'gtk3agg', 'gtk4': 'gtk4agg',\n+                       'tk': 'tkagg', 'wx': 'wxagg', 'macosx': 'macosx'}\n+            best_guess = mapping.get(current_framework, None)\n+            if best_guess is not None:\n+                candidates = [best_guess]\n+            else:\n+                candidates = []\n+            candidates += [\"macosx\", \"qt5agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n+            # Don't try to fallback on the cairo-based backends as they each have\n+            # an additional dependency (pycairo) over the agg-based backend, and\n+            # are of worse quality.\n+            for candidate in candidates:\n+                try:\n+                    switch_backend(candidate)\n+                except ImportError:\n+                    continue\n+                else:\n+                    rcParamsOrig['backend'] = candidate\n+                    return\n+            else:\n+                # Try default fallback which should always work.\n+                switch_backend(rcParamsDefault[\"backend\"])\n+                return\n+        \n+        # Only close figures if we're actually switching from an existing backend\n+        if _backend_mod is not None:\n+            close(\"all\")\n+\n+        if newbackend is None:\n+            _backend_mod = None\n+        else:\n+            _backend_mod = importlib.import_module(\n+                cbook._backend_module_name(newbackend))\n+        backend = newbackend\n     def destroy_all(cls):\n         \"\"\"Destroy all figures.\"\"\"\n         # Reimport gc in case the module globals have already been removed\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..3fda5b87ce 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -197,14 +197,92 @@ def _get_backend_mod():\n     Ensure that a backend is selected and return it.\n \n     This is currently private, but may be made public in the future.\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to switch to.\n+\n+    Examples\n+    --------\n+    Switching to the *Qt5Agg* backend::\n+\n+        plt.switch_backend('Qt5Agg')\n+\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.pyplot\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = _get_running_interactive_framework()\n+        mapping = {'qt5': 'qt5agg',\n+                   'qt4': 'qt4agg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk': 'gtkagg',\n+                   'tk': 'tkagg'}\n+        best_guess = mapping.get(current_framework, None)\n+        if best_guess is not None:\n+            candidates = [best_guess]\n+        else:\n+            candidates = []\n+        candidates += [\n+            \"macosx\", \"qt5agg\", \"qt4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n+        # Don't try to use agg non-interactively so that importing pyplot in\n+        # a script doesn't change matplotlib's behavior, but only if we get\n+        # this far without a backend (which is not common since _init() sets\n+        # a reasonable default).\n+        if matplotlib.get_backend() == 'agg':\n+            candidates.append(\"agg\")\n+        for candidate in candidates:\n+            try:\n+                switch_backend(candidate)\n+                break\n+            except ImportError:\n+                continue\n+        else:\n+            switch_backend(\"agg\")\n+        return\n+\n+    # Backends are case-insensitive.\n+    newbackend = newbackend.lower()\n+\n+    # Only close figures if we're actually switching backends (not initializing)\n+    if _backend_mod is not None:\n+        close(\"all\")\n+\n+    if newbackend.startswith(\"module://\"):\n+        backend_mod = importlib.import_module(newbackend[9:])\n+    else:\n+        backend_mod = importlib.import_module(\n+            f\"matplotlib.backends.backend_{newbackend}\")\n+    _backend_mod = backend_mod\n+\n+    # Need to keep a global reference to the backend for compatibility reasons.\n+    # See https://github.com/matplotlib/matplotlib/issues/6092\n+    sys.modules['matplotlib.backends.backend'] = backend_mod\n+\n+\n+def switch_backend(newbackend):\n     \"\"\"\n-    if _backend_mod is None:\n-        # Use __getitem__ here to avoid going through the fallback logic (which\n-        # will (re)import pyplot and then call switch_backend if we need to\n-        # resolve the auto sentinel)\n-        switch_backend(dict.__getitem__(rcParams, \"backend\"))\n-    return _backend_mod\n+    Close all open figures and set the Matplotlib backend.\n \n+    The argument is case-insensitive.  Switching to an interactive backend is\n+    possible only if no event loop for another interactive backend has started.\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n \n def switch_backend(newbackend):\n     \"\"\"\n@@ -222,8 +300,18 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+    if _backend_mod is not None:\n+        close(\"all\")\n \n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n         mapping = {'qt': 'qtagg',\n@@ -937,8 +1025,45 @@ def close(fig=None):\n             return\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n-    elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend is case-insensitive.  Switching to an interactive backend\n+    is possible only if no event loop for another interactive backend has\n+    started.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+\n+    Examples\n+    --------\n+    Switching to the 'Agg' backend::\n+\n+        plt.switch_backend('Agg')\n+\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later.\n+    new_backend = rcsetup.validate_backend(newbackend)\n+    if new_backend == rcParams['backend']:\n+        # Nothing to do if the requested backend is already set\n+        pass\n+    else:\n+        # Only close existing figures when actually switching backends,\n+        # not during initial backend setup\n+        if _backend_mod is not None:\n+            close(\"all\")\n+\n+        rcParams['backend'] = new_backend\n+\n+    # Need to keep a global reference to the backend_mod or the\n+    # weakref will return None.\n+    _backend_mod = importlib.import_module(\n+        cbook._backend_module_name(rcParams['backend']))\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n"
  }
}