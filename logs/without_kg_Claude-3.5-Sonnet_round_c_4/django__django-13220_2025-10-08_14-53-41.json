{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/core/exceptions.py lines 184-184)": "\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict (field errors)\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_messages = set(str(error) for error in self.error_dict[field])\n                other_messages = set(str(error) for error in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n        \n        # Both have error_list (non-field errors)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            self_messages = set(str(error) for error in self.error_list)\n            other_messages = set(str(error) for error in other.error_list)\n            return self_messages == other_messages\n        \n        # Both are single errors\n        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n        \n        # Mixed formats - not equal\n        else:\n            return False\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/core/exceptions.py lines 184-184)": [
      "\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict (field errors)\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_errors = [str(error) for error in self.error_dict[field]]\n                other_errors = [str(error) for error in other.error_dict[field]]\n                if sorted(self_errors) != sorted(other_errors):\n                    return False\n            return True\n        \n        # Both have error_list (non-field errors)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            self_errors = [str(error) for error in self.error_list]\n            other_errors = [str(error) for error in other.error_list]\n            return sorted(self_errors) == sorted(other_errors)\n        \n        # Both are single errors\n        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n        \n        # Mixed formats - compare using string representations\n        else:\n            return sorted(self.messages) == sorted(other.messages)\n",
      "\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_messages = [str(error) for error in self.error_dict[field]]\n                other_messages = [str(error) for error in other.error_dict[field]]\n                if sorted(self_messages) != sorted(other_messages):\n                    return False\n            return True\n        \n        # Both have error_list\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            self_messages = [str(error) for error in self.error_list]\n            other_messages = [str(error) for error in other.error_list]\n            return sorted(self_messages) == sorted(other_messages)\n        \n        # Both are single errors (neither has error_dict nor error_list)\n        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n        \n        # Mixed formats - not equal\n        else:\n            return False\n",
      "\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict (field errors)\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_errors = [str(error) for error in self.error_dict[field]]\n                other_errors = [str(error) for error in other.error_dict[field]]\n                if sorted(self_errors) != sorted(other_errors):\n                    return False\n            return True\n        \n        # Both have error_list (non-field errors)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            self_errors = [str(error) for error in self.error_list]\n            other_errors = [str(error) for error in other.error_list]\n            return sorted(self_errors) == sorted(other_errors)\n        \n        # Both are single errors\n        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n        \n        # Mixed formats - compare using messages\n        else:\n            return sorted(self.messages) == sorted(other.messages)\n",
      "\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare error dictionaries (field errors)\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_errors = [str(error) for error in self.error_dict[field]]\n                other_errors = [str(error) for error in other.error_dict[field]]\n                if set(self_errors) != set(other_errors):\n                    return False\n            return True\n        \n        # Compare error lists (non-field errors)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            self_errors = [str(error) for error in self.error_list]\n            other_errors = [str(error) for error in other.error_list]\n            return set(self_errors) == set(other_errors)\n        \n        # Compare single errors\n        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n        \n        # Different error structures\n        else:\n            return False\n",
      "\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Compare using the same structure detection logic as __str__\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            # Both have field errors - compare dictionaries\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                # Compare error lists for each field in order-independent way\n                self_errors = [str(error) for error in self.error_dict[field]]\n                other_errors = [str(error) for error in other.error_dict[field]]\n                if sorted(self_errors) != sorted(other_errors):\n                    return False\n            return True\n        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n            # One has field errors, other doesn't - not equal\n            return False\n        else:\n            # Both have error lists or single errors - compare messages\n            self_messages = list(self.messages)\n            other_messages = list(other.messages)\n            return sorted(self_messages) == sorted(other_messages)\n",
      "\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict (field errors)\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_messages = [str(error) for error in self.error_dict[field]]\n                other_messages = [str(error) for error in other.error_dict[field]]\n                if set(self_messages) != set(other_messages):\n                    return False\n            return True\n        \n        # Both have error_list (non-field errors)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            self_messages = [str(error) for error in self.error_list]\n            other_messages = [str(error) for error in other.error_list]\n            return set(self_messages) == set(other_messages)\n        \n        # Both are single errors\n        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n        \n        # Different formats - not equal\n        else:\n            return False\n",
      "\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict (field errors)\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_errors = [str(error) for error in self.error_dict[field]]\n                other_errors = [str(error) for error in other.error_dict[field]]\n                if sorted(self_errors) != sorted(other_errors):\n                    return False\n            return True\n        \n        # Both have error_list (non-field errors)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            self_errors = [str(error) for error in self.error_list]\n            other_errors = [str(error) for error in other.error_list]\n            return sorted(self_errors) == sorted(other_errors)\n        \n        # Single error format or mixed formats - compare string representations\n        else:\n            return sorted(self.messages) == sorted(other.messages)\n",
      "\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict (field errors)\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_messages = set(str(error) for error in self.error_dict[field])\n                other_messages = set(str(error) for error in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n        \n        # Both have error_list (non-field errors)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            self_messages = set(str(error) for error in self.error_list)\n            other_messages = set(str(error) for error in other.error_list)\n            return self_messages == other_messages\n        \n        # Both are single errors\n        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n        \n        # Mixed types - not equal\n        else:\n            return False\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..7959b182da 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,44 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict (field errors)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                # Compare error lists for each field in order-independent way\n+                self_messages = sorted(str(error.message) + str(getattr(error, 'code', '')) + str(getattr(error, 'params', ''))\n+                                     for error in self.error_dict[field])\n+                other_messages = sorted(str(error.message) + str(getattr(error, 'code', '')) + str(getattr(error, 'params', ''))\n+                                      for error in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # Both have error_list (non-field errors)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list') and \\\n+             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n+            # Compare error lists in order-independent way\n+            self_messages = sorted(str(error.message) + str(getattr(error, 'code', '')) + str(getattr(error, 'params', ''))\n+                                 for error in self.error_list)\n+            other_messages = sorted(str(error.message) + str(getattr(error, 'code', '')) + str(getattr(error, 'params', ''))\n+                                  for error in other.error_list)\n+            return self_messages == other_messages\n+        \n+        # Both are single errors (no error_dict or error_list)\n+        elif not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict') and \\\n+             not hasattr(self, 'error_list') and not hasattr(other, 'error_list'):\n+            return (self.message == other.message and \n+                    getattr(self, 'code', None) == getattr(other, 'code', None) and\n+                    getattr(self, 'params', None) == getattr(other, 'params', None))\n+        \n+        # Different formats - not equal\n+        else:\n+            return False\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_0": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..b5029171ea 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,37 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict (field errors)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_messages = set(str(error) for error in self.error_dict[field])\n+                other_messages = set(str(error) for error in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # Both have error_list (non-field errors)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            self_messages = set(str(error) for error in self.error_list)\n+            other_messages = set(str(error) for error in other.error_list)\n+            return self_messages == other_messages\n+        \n+        # Both are single errors\n+        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n+             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+        \n+        # Mixed formats - not equal\n+        else:\n+            return False\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_1": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..57d5005839 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,37 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict (field errors)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_errors = [str(error) for error in self.error_dict[field]]\n+                other_errors = [str(error) for error in other.error_dict[field]]\n+                if sorted(self_errors) != sorted(other_errors):\n+                    return False\n+            return True\n+        \n+        # Both have error_list (non-field errors)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            self_errors = [str(error) for error in self.error_list]\n+            other_errors = [str(error) for error in other.error_list]\n+            return sorted(self_errors) == sorted(other_errors)\n+        \n+        # Both are single errors\n+        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n+             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+        \n+        # Mixed formats - compare using string representations\n+        else:\n+            return sorted(self.messages) == sorted(other.messages)\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_2": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..4b99766c87 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,37 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_messages = [str(error) for error in self.error_dict[field]]\n+                other_messages = [str(error) for error in other.error_dict[field]]\n+                if sorted(self_messages) != sorted(other_messages):\n+                    return False\n+            return True\n+        \n+        # Both have error_list\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            self_messages = [str(error) for error in self.error_list]\n+            other_messages = [str(error) for error in other.error_list]\n+            return sorted(self_messages) == sorted(other_messages)\n+        \n+        # Both are single errors (neither has error_dict nor error_list)\n+        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n+             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+        \n+        # Mixed formats - not equal\n+        else:\n+            return False\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_3": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..a5349c5b4b 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,37 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict (field errors)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_errors = [str(error) for error in self.error_dict[field]]\n+                other_errors = [str(error) for error in other.error_dict[field]]\n+                if sorted(self_errors) != sorted(other_errors):\n+                    return False\n+            return True\n+        \n+        # Both have error_list (non-field errors)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            self_errors = [str(error) for error in self.error_list]\n+            other_errors = [str(error) for error in other.error_list]\n+            return sorted(self_errors) == sorted(other_errors)\n+        \n+        # Both are single errors\n+        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n+             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+        \n+        # Mixed formats - compare using messages\n+        else:\n+            return sorted(self.messages) == sorted(other.messages)\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_4": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..d7b24b6739 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,37 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare error dictionaries (field errors)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_errors = [str(error) for error in self.error_dict[field]]\n+                other_errors = [str(error) for error in other.error_dict[field]]\n+                if set(self_errors) != set(other_errors):\n+                    return False\n+            return True\n+        \n+        # Compare error lists (non-field errors)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            self_errors = [str(error) for error in self.error_list]\n+            other_errors = [str(error) for error in other.error_list]\n+            return set(self_errors) == set(other_errors)\n+        \n+        # Compare single errors\n+        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n+             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+        \n+        # Different error structures\n+        else:\n+            return False\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_5": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..bf99034f29 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,30 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Compare using the same structure detection logic as __str__\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            # Both have field errors - compare dictionaries\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                # Compare error lists for each field in order-independent way\n+                self_errors = [str(error) for error in self.error_dict[field]]\n+                other_errors = [str(error) for error in other.error_dict[field]]\n+                if sorted(self_errors) != sorted(other_errors):\n+                    return False\n+            return True\n+        elif hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+            # One has field errors, other doesn't - not equal\n+            return False\n+        else:\n+            # Both have error lists or single errors - compare messages\n+            self_messages = list(self.messages)\n+            other_messages = list(other.messages)\n+            return sorted(self_messages) == sorted(other_messages)\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_6": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..1126209704 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,37 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict (field errors)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_messages = [str(error) for error in self.error_dict[field]]\n+                other_messages = [str(error) for error in other.error_dict[field]]\n+                if set(self_messages) != set(other_messages):\n+                    return False\n+            return True\n+        \n+        # Both have error_list (non-field errors)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            self_messages = [str(error) for error in self.error_list]\n+            other_messages = [str(error) for error in other.error_list]\n+            return set(self_messages) == set(other_messages)\n+        \n+        # Both are single errors\n+        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n+             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+        \n+        # Different formats - not equal\n+        else:\n+            return False\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_7": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..0ccb02633d 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,30 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict (field errors)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_errors = [str(error) for error in self.error_dict[field]]\n+                other_errors = [str(error) for error in other.error_dict[field]]\n+                if sorted(self_errors) != sorted(other_errors):\n+                    return False\n+            return True\n+        \n+        # Both have error_list (non-field errors)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            self_errors = [str(error) for error in self.error_list]\n+            other_errors = [str(error) for error in other.error_list]\n+            return sorted(self_errors) == sorted(other_errors)\n+        \n+        # Single error format or mixed formats - compare string representations\n+        else:\n+            return sorted(self.messages) == sorted(other.messages)\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_8": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..469e7050db 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -182,6 +182,37 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict (field errors)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_messages = set(str(error) for error in self.error_dict[field])\n+                other_messages = set(str(error) for error in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # Both have error_list (non-field errors)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            self_messages = set(str(error) for error in self.error_list)\n+            other_messages = set(str(error) for error in other.error_list)\n+            return self_messages == other_messages\n+        \n+        # Both are single errors\n+        elif not hasattr(self, 'error_dict') and not hasattr(self, 'error_list') and \\\n+             not hasattr(other, 'error_dict') and not hasattr(other, 'error_list'):\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+        \n+        # Mixed types - not equal\n+        else:\n+            return False\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n"
  }
}