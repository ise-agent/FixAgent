{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/pytest/src/_pytest/mark/evaluate.py lines 18-18)": "\n",
    "Location 2 (/root/hy/projects_4/pytest/src/_pytest/mark/evaluate.py lines 21-31)": "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
    "Location 3 (/root/hy/projects_4/pytest/src/_pytest/mark/evaluate.py lines 101-101)": "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/pytest/src/_pytest/mark/evaluate.py lines 18-18)": [
      "\n",
      "\n",
      "\nevalcache_key = StoreKey[Dict[str, Any]]()\n",
      "\n# Remove this line entirely as the cache key is no longer needed\n",
      "\n",
      "\n",
      "\n# Remove this line entirely as we're eliminating the caching mechanism\n",
      "\n"
    ],
    "Location 2 (/root/hy/projects_4/pytest/src/_pytest/mark/evaluate.py lines 21-31)": [
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n",
      "\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    import _pytest._code\n    \n    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n    return eval(exprcode, d)\n"
    ],
    "Location 3 (/root/hy/projects_4/pytest/src/_pytest/mark/evaluate.py lines 101-101)": [
      "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n",
      "\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        import _pytest._code\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n",
      "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n",
      "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n",
      "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n",
      "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n",
      "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n",
      "\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n                        result = eval(exprcode, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..5d89cbaab 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,12 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+\n+\n+\n \n \n class MarkEvaluator:\n@@ -98,7 +90,9 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_0": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..3bcc5d4ed 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,15 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +93,23 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n+                        if \"reason\" not in mark.kwargs:\n+                            # XXX better be checked at collection time\n+                            msg = (\n+                                \"you need to specify reason=STRING \"\n+                                \"when using booleans as conditions.\"\n+                            )\n+                            fail(msg)\n+                        result = bool(expr)\n+                    if result:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_1": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..3bcc5d4ed 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,15 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +93,23 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n+                        if \"reason\" not in mark.kwargs:\n+                            # XXX better be checked at collection time\n+                            msg = (\n+                                \"you need to specify reason=STRING \"\n+                                \"when using booleans as conditions.\"\n+                            )\n+                            fail(msg)\n+                        result = bool(expr)\n+                    if result:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_2": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..b9dc71e40 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,15 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +93,12 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        import _pytest._code\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_3": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..bb65ab6ca 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,16 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n+\n evalcache_key = StoreKey[Dict[str, Any]]()\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +94,23 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n+                        if \"reason\" not in mark.kwargs:\n+                            # XXX better be checked at collection time\n+                            msg = (\n+                                \"you need to specify reason=STRING \"\n+                                \"when using booleans as conditions.\"\n+                            )\n+                            fail(msg)\n+                        result = bool(expr)\n+                    if result:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_4": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..ead17f463 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,16 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n+\n+# Remove this line entirely as the cache key is no longer needed\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +94,14 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_5": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..3bcc5d4ed 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,15 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +93,23 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n+                        if \"reason\" not in mark.kwargs:\n+                            # XXX better be checked at collection time\n+                            msg = (\n+                                \"you need to specify reason=STRING \"\n+                                \"when using booleans as conditions.\"\n+                            )\n+                            fail(msg)\n+                        result = bool(expr)\n+                    if result:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_6": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..3bcc5d4ed 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,15 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +93,23 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n+                        if \"reason\" not in mark.kwargs:\n+                            # XXX better be checked at collection time\n+                            msg = (\n+                                \"you need to specify reason=STRING \"\n+                                \"when using booleans as conditions.\"\n+                            )\n+                            fail(msg)\n+                        result = bool(expr)\n+                    if result:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_7": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..3769f1b63 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,16 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n+\n+# Remove this line entirely as we're eliminating the caching mechanism\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +94,23 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n+                        if \"reason\" not in mark.kwargs:\n+                            # XXX better be checked at collection time\n+                            msg = (\n+                                \"you need to specify reason=STRING \"\n+                                \"when using booleans as conditions.\"\n+                            )\n+                            fail(msg)\n+                        result = bool(expr)\n+                    if result:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n",
    "variant_8": "diff --git a/src/_pytest/mark/evaluate.py b/src/_pytest/mark/evaluate.py\nindex 759191668..3bcc5d4ed 100644\n--- a/src/_pytest/mark/evaluate.py\n+++ b/src/_pytest/mark/evaluate.py\n@@ -15,20 +15,15 @@ from _pytest.nodes import Item\n from _pytest.store import StoreKey\n \n \n-evalcache_key = StoreKey[Dict[str, Any]]()\n \n \n-def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n-    default = {}  # type: Dict[str, object]\n-    evalcache = config._store.setdefault(evalcache_key, default)\n-    try:\n-        return evalcache[expr]\n-    except KeyError:\n-        import _pytest._code\n \n-        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n-        evalcache[expr] = x = eval(exprcode, d)\n-        return x\n+\n+def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n+    import _pytest._code\n+    \n+    exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+    return eval(exprcode, d)\n \n \n class MarkEvaluator:\n@@ -98,7 +93,23 @@ class MarkEvaluator:\n                     self.expr = expr\n                     if isinstance(expr, str):\n                         d = self._getglobals()\n-                        result = cached_eval(self.item.config, expr, d)\n+\n+                for expr in args:\n+                    self.expr = expr\n+                    if isinstance(expr, str):\n+                        d = self._getglobals()\n+                        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n+                        result = eval(exprcode, d)\n+                    else:\n+                        if \"reason\" not in mark.kwargs:\n+                            # XXX better be checked at collection time\n+                            msg = (\n+                                \"you need to specify reason=STRING \"\n+                                \"when using booleans as conditions.\"\n+                            )\n+                            fail(msg)\n+                        result = bool(expr)\n+                    if result:\n                     else:\n                         if \"reason\" not in mark.kwargs:\n                             # XXX better be checked at collection time\n"
  }
}