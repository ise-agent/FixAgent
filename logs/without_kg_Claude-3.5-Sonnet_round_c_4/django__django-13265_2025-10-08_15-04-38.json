{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/migrations/autodetector.py lines 187-190)": "\n        # Generate index removal operations before field is removed\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n",
    "Location 2 (/root/hy/projects_4/django/django/db/migrations/autodetector.py lines 1015-1023)": "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_altered_foo_together() rely on self.altered_indexes and\n        self.altered_constraints being populated by\n        generate_removed_altered_foo_together(), so make sure there's a\n        clear split between the two phases.\n        \"\"\"\n        self.generated_operations = {}\n        self.altered_indexes = {}\n        self.altered_constraints = {}\n\n        # Prepare some old/new state and model lists, separating\n        # proxy models and ignoring unmigrated apps.\n        self.old_apps = self.from_state.concrete_apps\n        self.new_apps = self.to_state.concrete_apps\n        self.old_model_keys = set()\n        self.old_proxy_keys = set()\n        self.old_unmanaged_keys = set()\n        self.new_model_keys = set()\n        self.new_proxy_keys = set()\n        self.new_unmanaged_keys = set()\n        for (app_label, model_name), model_state in self.from_state.models.items():\n            if not model_state.options.get('managed', True):\n                self.old_unmanaged_keys.add((app_label, model_name))\n            elif app_label not in self.from_state.real_apps:\n                if model_state.options.get('proxy'):\n                    self.old_proxy_keys.add((app_label, model_name))\n                else:\n                    self.old_model_keys.add((app_label, model_name))\n\n        for (app_label, model_name), model_state in self.to_state.models.items():\n            if not model_state.options.get('managed', True):\n                self.new_unmanaged_keys.add((app_label, model_name))\n            elif app_label not in self.to_state.real_apps:\n                if model_state.options.get('proxy'):\n                    self.new_proxy_keys.add((app_label, model_name))\n                else:\n                    self.new_model_keys.add((app_label, model_name))\n\n        # Renames have to come first\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes/constraints first, before adding\n        # or removing fields, so that we can detect any\n        # ForeignKeyViolationError that may occur if we drop a foreign\n        # key field and there are still references to it.\n        self.generate_removed_altered_unique_together()\n        self.generate_removed_altered_index_together()\n\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
    "Location 3 (/root/hy/projects_4/django/django/db/migrations/autodetector.py lines 1192-1215)": "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations should create the same end state as\n        the current new_state, though they may not be optimal.\n        \"\"\"\n        # The first phase is generating all the operations for each app\n        # and gathering them into a big per-app list.\n        # Then go through that list, order things nicely, and split\n        # into migrations to resolve dependencies.\n        self.generated_operations = {}\n        self.altered_indexes = {}\n        self.altered_constraints = {}\n\n        # Prepare some old/new state and model lists, separating\n        # proxy models and ignoring unmigrated apps.\n        self.old_apps = self.from_state.concrete_apps\n        self.new_apps = self.to_state.concrete_apps\n        self.old_model_keys = set()\n        self.old_proxy_keys = set()\n        self.old_unmanaged_keys = set()\n        self.new_model_keys = set()\n        self.new_proxy_keys = set()\n        self.new_unmanaged_keys = set()\n        for (app_label, model_name), model_state in self.from_state.models.items():\n            if app_label not in self.from_state.real_apps:\n                continue\n            if model_state.options.get(\"proxy\"):\n                self.old_proxy_keys.add((app_label, model_name))\n            elif not model_state.options.get(\"managed\", True):\n                self.old_unmanaged_keys.add((app_label, model_name))\n            else:\n                self.old_model_keys.add((app_label, model_name))\n\n        for (app_label, model_name), model_state in self.to_state.models.items():\n            if app_label not in self.to_state.real_apps:\n                continue\n            if model_state.options.get(\"proxy\"):\n                self.new_proxy_keys.add((app_label, model_name))\n            elif not model_state.options.get(\"managed\", True):\n                self.new_unmanaged_keys.add((app_label, model_name))\n            else:\n                self.new_model_keys.add((app_label, model_name))\n\n        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n        self.through_users = {}\n        self.old_field_keys = {\n            (app_label, model_name, field_name)\n            for app_label, model_name in self.kept_model_keys\n            for field_name in self.from_state.models[\n                app_label,\n                self.renamed_models.get((app_label, model_name), model_name)\n            ].fields\n        }\n        self.new_field_keys = {\n            (app_label, model_name, field_name)\n            for app_label, model_name in self.kept_model_keys\n            for field_name in self.to_state.models[app_label, model_name].fields\n        }\n\n        self.generate_renamed_models()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes and store them in self.altered_indexes.\n        # This avoids the same computation in generate_removed_indexes()\n        # and generate_added_indexes().\n        self.create_altered_indexes()\n        self.create_altered_constraints()\n        # Generate index removal operations before field is removed\n        self.generate_removed_indexes()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        # Generate index addition operations after field is created, in\n        # case the index references the new field\n        self.generate_removed_constraints()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/migrations/autodetector.py lines 187-190)": [
      "\n        # Generate index removal operations before field is removed\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n",
      "\n        # Generate index removal operations before field is removed\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n",
      "\n        # Generate index removal operations before field is removed\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n",
      "\n        # Generate index removal operations before field is removed\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n",
      "\n        # Generate index removal operations before field is removed\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n",
      "\n        # Generate index removal operations before field is removed\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n",
      "\n        # Generate index removal operations before field is removed\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n",
      "\n        # Generate index removal operations before field is removed\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/migrations/autodetector.py lines 1015-1023)": [
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations should create the to_state from the\n        from_state, but not necessarily optimize them. The optimization\n        phase is a separate step later on.\n        \"\"\"\n        self.generated_operations = {}\n        self.altered_indexes = {}\n        self.altered_constraints = {}\n\n        # Prepare some old/new state and model lists, separating\n        # proxy models and ignoring unmigrated apps.\n        self.old_apps = self.from_state.concrete_apps\n        self.new_apps = self.to_state.concrete_apps\n        self.old_model_keys = set()\n        self.old_proxy_keys = set()\n        self.old_unmanaged_keys = set()\n        self.new_model_keys = set()\n        self.new_proxy_keys = set()\n        self.new_unmanaged_keys = set()\n        for (app_label, model_name), model_state in self.from_state.models.items():\n            if not model_state.options.get('managed', True):\n                self.old_unmanaged_keys.add((app_label, model_name))\n            elif app_label not in self.from_state.real_apps:\n                if model_state.options.get('proxy'):\n                    self.old_proxy_keys.add((app_label, model_name))\n                else:\n                    self.old_model_keys.add((app_label, model_name))\n        for (app_label, model_name), model_state in self.to_state.models.items():\n            if not model_state.options.get('managed', True):\n                self.new_unmanaged_keys.add((app_label, model_name))\n            elif app_label not in self.from_state.real_apps:\n                if model_state.options.get('proxy'):\n                    self.new_proxy_keys.add((app_label, model_name))\n                else:\n                    self.new_model_keys.add((app_label, model_name))\n\n        # Renames have to come first\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes/constraints before running through\n        # the other model changes, so that we can create/delete them\n        # properly\n        self._create_altered_indexes()\n        self._create_altered_constraints()\n\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        # Generate index/constraint operations\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n        # Generate removed index/constraint operations\n        self.generate_removed_indexes()\n        self.generate_removed_constraints()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_altered_foo_together() rely on self.altered_indexes and\n        self.altered_constraints being populated by\n        generate_removed_altered_foo_together(), so make sure that's run\n        first.\n        \"\"\"\n        self.generated_operations = {}\n        self.altered_indexes = {}\n        self.altered_constraints = {}\n\n        # Prepare some old/new state and model lists, separating\n        # proxy models and ignoring unmigrated apps.\n        self.old_apps = self.from_state.concrete_apps\n        self.new_apps = self.to_state.concrete_apps\n        self.old_model_keys = set()\n        self.old_proxy_keys = set()\n        self.old_unmanaged_keys = set()\n        self.new_model_keys = set()\n        self.new_proxy_keys = set()\n        self.new_unmanaged_keys = set()\n        for al, mn in self.from_state.models:\n            model = self.old_apps.get_model(al, mn)\n            if not model._meta.managed:\n                self.old_unmanaged_keys.add((al, mn))\n            elif self.old_apps.get_model(al, mn)._meta.proxy:\n                self.old_proxy_keys.add((al, mn))\n            else:\n                self.old_model_keys.add((al, mn))\n\n        for al, mn in self.to_state.models:\n            model = self.new_apps.get_model(al, mn)\n            if not model._meta.managed:\n                self.new_unmanaged_keys.add((al, mn))\n            elif self.new_apps.get_model(al, mn)._meta.proxy:\n                self.new_proxy_keys.add((al, mn))\n            else:\n                self.new_model_keys.add((al, mn))\n\n        self.generate_renamed_models()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the renamed fields and store them in self.renamed_fields.\n        # They are used by generate_removed_fields()\n        self.create_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n\n        self.generate_removed_altered_unique_together()\n        self.generate_removed_altered_index_together()\n        self.generate_removed_altered_constraints()\n        self.generate_removed_altered_indexes()\n\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self.generate_removed_indexes()\n        self.generate_removed_constraints()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_X_name() methods are used to generate the operations for each\n        of these types of change, and then the optimizer attempts to\n        optimize them - just in case, for example, a model with two\n        ForeignKeys gets a unique_together set, and then the \"alter\"\n        operation and the \"set unique_together\" should become one\n        AddModel with inline unique_together definition.\n\n        Alphabetical change types and a few notes:\n        add_alter_order_with_respect_to_index: Index with order_with_respect_to;\n            respect order of field changes\n        add_alter_unique_together: Unique together constraints\n        add_field/remove_field: Added and removed fields\n        add_index: Added indexes\n        add_constraint: Added constraints\n        alter_* (non-rename): Field and other changes\n        create_model/delete_model: Creation and deletion of entire models\n        rename_*: Field and model renames\n        remove_*: Removed indexes, constraints, etc.\n        \"\"\"\n        # The first phase is generating all the operations for each app\n        # and gathering the dependencies of each model.\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map.\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations.\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes and store them in self.altered_indexes.\n        # This also automatically generates deleted indexes.\n        self.create_altered_indexes()\n        self.create_altered_constraints()\n\n        # Generate index removal operations before field removal.\n        self.generate_removed_indexes()\n        self.generate_removed_constraints()\n\n        # Generate field operations.\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n\n        # Generate unique_together and index_together operations.\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        \n        # Generate order_with_respect_to operations before index operations\n        # to ensure _order field exists before creating indexes on it\n        self.generate_altered_order_with_respect_to()\n        \n        # Generate index and constraint operations after order_with_respect_to\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_altered_foo_together() rely on matching Field instances and\n        so must be run before generate_removed_fields().\n        generate_removed_fields() must be run before generate_deleted_models()\n        as it honors the through_fields on the relationship.\n        generate_deleted_models() must be run before generate_model_managers()\n        as the later relies on the former to distinguish through models.\n        generate_model_managers() must be run before generate_manager_bases()\n        as managers need to be handled before bases in multi-table inheritance\n        where the manager is defined on the child model.\n        \"\"\"\n        # The first phase is generating all the operations for each app\n        # and gathering them into a big per-app list.\n        # Then go through that list, order things nicely, and split off the\n        # migrations.\n\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n        self.generate_manager_bases()\n\n        # Create the altered indexes/unique_together operations\n        self._create_altered_indexes()\n\n        # Generate index/constraint operations\n        self.generate_removed_indexes()\n        self.generate_removed_constraints()\n\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_altered_foo_together() rely on generate_removed_foo() and\n        generate_added_foo() being run first.\n        \"\"\"\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n\n        # Create the renamed fields and store them in self.renamed_fields.\n        # They are used by generate_removed_fields()\n        self.create_renamed_fields()\n        # Generate field operations\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        # Generate index operation (only AddIndex and RemoveIndex)\n        self.generate_removed_indexes()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n        self.generate_removed_constraints()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_altered_foo_together() rely on self.altered_indexes and\n        self.altered_constraints so they must be called after\n        _detect_changes().\n        \"\"\"\n        self.generate_renamed_models()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_order_with_respect_to()\n        self.generate_altered_managers()\n        # Generate index operations\n        self.generate_removed_indexes()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n        self.generate_removed_constraints()\n        # Generate model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_db_table_comment()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_*() methods are responsible for generating individual\n        operations, depending on the type of the change. These methods\n        should produce operations which, when combined together, will\n        represent the change from the old state to the new state\n        (without any reordering - that's later).\n\n        generate_*() methods are grouped together and should create\n        operations in this order:\n\n        - Field and manager changes (including adding/removing through models)\n        - Field and manager renames\n        - Changing Meta options (index_together, unique_together, etc.)\n        - Adding/removing indexes and constraints\n\n        The generate_*() method are split into two phases:\n\n        Phase 1 (main phase): adding/removing/renaming fields and managers,\n        adding/removing models, changing most Meta options. These changes\n        can be done independently for each model, so the methods in this\n        phase don't need to consider inter-model dependencies and can be\n        run in any order.\n\n        Phase 2 (post phase): adding/removing/renaming indexes and\n        constraints. The methods in this phase may create operations which\n        reference fields or models, so they need to run after phase 1 has\n        completed.\n\n        The way the code is structured is that all the generate_*() methods\n        (including phase 1 and phase 2) are run together, but the operations\n        are split into two phases when writing them to the migration files\n        (see ``arrangement`` in ``_build_migration_list()``).\n        \"\"\"\n        # The first phase is generating all the operations for each app\n        # and gathering inter-app dependencies.\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Phase 1 - Adding model bases, managers and proxy models\n        # These depend on the previous loops' preparation\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes/unique_together before removing fields\n        # that the indexes/unique_together reference.\n        self.create_altered_indexes()\n        self.create_altered_unique_together()\n\n        # Generate field operations\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_renamed_fields()\n\n        # Phase 2 - Generate operations that may reference fields\n        # on other models (so these must be done after the model structure\n        # and field operations have been generated for all models).\n        # Create other index/unique_together changes\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        # Generate altered_order_with_respect_to before adding indexes\n        # to ensure _order field exists before indexes are created\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n        self.generate_removed_indexes()\n        self.generate_removed_constraints()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_renamed_models() and generate_removed_models() make the\n        migrations depend on the previous migration automatically.\n        \"\"\"\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes/constraints/etc. for the models before\n        # we do anything else with them\n        self.create_altered_indexes()\n        self.create_altered_constraints()\n        self.generate_removed_indexes()\n\n        # Generate index removal operations before field is removed\n        self.generate_removed_constraints()\n\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/migrations/autodetector.py lines 1192-1215)": [
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_altered_foo_together() rely on self.altered_indexes and\n        self.altered_constraints being populated by\n        generate_removed_indexes() and generate_removed_constraints().\n        \"\"\"\n        # The first phase is generating all the operations for each app\n        # and gathering modified models.\n        for app_label in self.from_state.apps.get_app_configs():\n            self.check_dependency(app_label, '__first__')\n        for app_label in self.to_state.apps.get_app_configs():\n            self.check_dependency(app_label, '__first__')\n\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map.\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations.\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes and store them in self.altered_indexes.\n        # This is used later in generate_altered_unique_together().\n        self.generate_removed_indexes()\n        # Create the altered constraints and store them in\n        # self.altered_constraints. This is used later in\n        # generate_altered_unique_together().\n        self.generate_removed_constraints()\n\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations should create the same end state as\n        to_state and represent a minimal set of changes.\n        \"\"\"\n        # The first phase is generating all the operations for each app\n        # and gathering them into a big per-app list.\n        # Then go through that list, order it, and split into migrations to\n        # resolve dependencies caused by M2Ms and FKs.\n        self.generated_operations = {}\n        self.altered_indexes = {}\n        self.altered_constraints = {}\n\n        # Prepare some old/new state and model lists, separating\n        # proxy models and ignoring unmigrated apps.\n        self.old_apps = self.from_state.concrete_apps\n        self.new_apps = self.to_state.concrete_apps\n        self.old_model_keys = set()\n        self.old_proxy_keys = set()\n        self.old_unmanaged_keys = set()\n        self.new_model_keys = set()\n        self.new_proxy_keys = set()\n        self.new_unmanaged_keys = set()\n        for (app_label, model_name), model_state in self.from_state.models.items():\n            if not model_state.options.get(\"managed\", True):\n                self.old_unmanaged_keys.add((app_label, model_name))\n            elif self.old_apps.get_model(app_label, model_name)._meta.proxy:\n                self.old_proxy_keys.add((app_label, model_name))\n            else:\n                self.old_model_keys.add((app_label, model_name))\n\n        for (app_label, model_name), model_state in self.to_state.models.items():\n            if not model_state.options.get(\"managed\", True):\n                self.new_unmanaged_keys.add((app_label, model_name))\n            elif self.new_apps.get_model(app_label, model_name)._meta.proxy:\n                self.new_proxy_keys.add((app_label, model_name))\n            else:\n                self.new_model_keys.add((app_label, model_name))\n\n        self.renamed_models = {}\n        self.renamed_models_rel = {}\n        self.renamed_fields = {}\n        self.renamed_fields_rel = {}\n        self.removed_altered_unique_together = []\n        self.removed_altered_index_together = []\n        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n        self.through_users = {}\n        self.old_field_keys = {\n            (app_label, model_name, field_name)\n            for app_label, model_name in self.kept_model_keys\n            for field_name in self.from_state.models[\n                app_label,\n                self.renamed_models.get((app_label, model_name), model_name)\n            ].fields\n        }\n        self.new_field_keys = {\n            (app_label, model_name, field_name)\n            for app_label, model_name in self.kept_model_keys\n            for field_name in self.to_state.models[app_label, model_name].fields\n        }\n\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self.generate_renamed_fields()\n        self.generate_removed_altered_unique_together()\n        self.generate_removed_altered_index_together()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes/constraints before adding new fields.\n        self.create_altered_indexes()\n        self.create_altered_constraints()\n\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_X_Y() functions are called to defer the generation of\n        individual operations; alter_foo_together operation are preferred\n        over multiple add/remove of foo_together at once.\n        \"\"\"\n        # The first phase is generating all the operations for each app\n        # and gathering them into a big per-app list.\n        # Then go through that list, order things nicely, and split\n        # into migrations to resolve dependencies caused by M2Ms and\n        # FKs.\n        self.generated_operations = {}\n\n        # Prepare some old/new state and model lists, separating\n        # proxy models and ignoring unmigrated apps.\n        self.old_apps = self.from_state.concrete_apps\n        self.new_apps = self.to_state.concrete_apps\n        self.old_model_keys = set()\n        self.old_proxy_keys = set()\n        self.old_unmanaged_keys = set()\n        self.new_model_keys = set()\n        self.new_proxy_keys = set()\n        self.new_unmanaged_keys = set()\n        for (app_label, model_name), model_state in self.from_state.models.items():\n            if not model_state.options.get(\"managed\", True):\n                self.old_unmanaged_keys.add((app_label, model_name))\n            elif self.old_apps.get_model(app_label, model_name)._meta.proxy:\n                self.old_proxy_keys.add((app_label, model_name))\n            else:\n                self.old_model_keys.add((app_label, model_name))\n\n        for (app_label, model_name), model_state in self.to_state.models.items():\n            if not model_state.options.get(\"managed\", True):\n                self.new_unmanaged_keys.add((app_label, model_name))\n            elif self.new_apps.get_model(app_label, model_name)._meta.proxy:\n                self.new_proxy_keys.add((app_label, model_name))\n            else:\n                self.new_model_keys.add((app_label, model_name))\n\n        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n        self.through_users = {}\n        self.old_field_keys = {\n            (app_label, model_name, field_name)\n            for app_label, model_name in self.kept_model_keys\n            for field_name in self.from_state.models[\n                app_label,\n                self.renamed_models.get((app_label, model_name), model_name)\n            ].fields\n        }\n        self.new_field_keys = {\n            (app_label, model_name, field_name)\n            for app_label, model_name in self.kept_model_keys\n            for field_name in self.to_state.models[app_label, model_name].fields\n        }\n\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the renamed fields and store them in self.renamed_fields.\n        # They are used by the migration optimizer (see #22275) and the\n        # generate_altered_fields().\n        self.generate_renamed_fields()\n\n        # Generate field operations\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n\n        # Generate index operation (only swap/alter_together).\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self.generate_removed_indexes()\n        self.generate_removed_constraints()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_renamed_models() and generate_removed_models() must be\n        called before any of the other generate_*() methods.\n        \"\"\"\n        # The first phase is generating all the operations for each app\n        # and gathering them into a big per-app list.\n        # Then go through that list, order things nicely, and split\n        # into migrations to resolve dependencies caused by M2Ms and\n        # FKs.\n        self.generated_operations = {}\n\n        # Prepare some old/new state and model lists, separating\n        # proxy models and ignoring unmigrated apps.\n        self.old_apps = self.from_state.concrete_apps\n        self.new_apps = self.to_state.concrete_apps\n        self.old_model_keys = set()\n        self.old_proxy_keys = set()\n        self.old_unmanaged_keys = set()\n        self.new_model_keys = set()\n        self.new_proxy_keys = set()\n        self.new_unmanaged_keys = set()\n        for app_label in self.kept_model_keys:\n            for model_name in self.from_state.models:\n                if model_name[0] == app_label:\n                    model_state = self.from_state.models[model_name]\n                    if not model_state.options.get(\"managed\", True):\n                        self.old_unmanaged_keys.add(model_name)\n                    elif model_state.options.get(\"proxy\", False):\n                        self.old_proxy_keys.add(model_name)\n                    else:\n                        self.old_model_keys.add(model_name)\n\n        for app_label in self.kept_model_keys:\n            for model_name in self.to_state.models:\n                if model_name[0] == app_label:\n                    model_state = self.to_state.models[model_name]\n                    if not model_state.options.get(\"managed\", True):\n                        self.new_unmanaged_keys.add(model_name)\n                    elif model_state.options.get(\"proxy\", False):\n                        self.new_proxy_keys.add(model_name)\n                    else:\n                        self.new_model_keys.add(model_name)\n\n        # Renames have to come first\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes and store them in self.altered_indexes.\n        # This is used later to exclude indexes on M2M fields from being\n        # created.\n        self.create_altered_indexes()\n        self.create_altered_constraints()\n\n        # Generate index removal operations before field is removed\n        self.generate_removed_indexes()\n        # Generate constraint removal operations before field is removed\n        self.generate_removed_constraints()\n\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        # Generate M2M fields after other fields (we need the table to exist)\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_renamed_models() and generate_removed_models() must be\n        run before any of the other generators.\n        \"\"\"\n        # The first phase is generating all the operations for each app\n        # and gathering them into a big per-app list.\n        # Then go through that list, order things nicely, and split\n        # into migrations to resolve dependencies caused by M2Ms and\n        # FKs.\n        self.generated_operations = {}\n        self.altered_indexes = {}\n        self.altered_constraints = {}\n\n        # Prepare some old/new state and model lists, separating\n        # proxy models and ignoring unmigrated apps.\n        self.old_apps = self.from_state.concrete_apps\n        self.new_apps = self.to_state.concrete_apps\n        self.old_model_keys = set()\n        self.old_proxy_keys = set()\n        self.old_unmanaged_keys = set()\n        self.new_model_keys = set()\n        self.new_proxy_keys = set()\n        self.new_unmanaged_keys = set()\n        for al, mn in self.from_state.models:\n            model = self.from_state.models[al, mn]\n            if not model.options.get(\"managed\", True):\n                self.old_unmanaged_keys.add((al, mn))\n            elif al not in self.from_state.real_apps:\n                if model.options.get(\"proxy\"):\n                    self.old_proxy_keys.add((al, mn))\n                else:\n                    self.old_model_keys.add((al, mn))\n\n        for al, mn in self.to_state.models:\n            model = self.to_state.models[al, mn]\n            if not model.options.get(\"managed\", True):\n                self.new_unmanaged_keys.add((al, mn))\n            elif al not in self.to_state.real_apps:\n                if model.options.get(\"proxy\"):\n                    self.new_proxy_keys.add((al, mn))\n                else:\n                    self.new_model_keys.add((al, mn))\n\n        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n        self.through_users = {}\n        self.old_field_keys = {\n            (al, mn, fn)\n            for al, mn in self.kept_model_keys\n            for fn in self.from_state.models[\n                al, self.renamed_models.get((al, mn), mn)\n            ].fields\n        }\n        self.new_field_keys = {\n            (al, mn, fn)\n            for al, mn in self.kept_model_keys\n            for fn in self.to_state.models[al, mn].fields\n        }\n\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes/constraints before running\n        # generate_removed_fields or generate_added_fields.\n        self.create_altered_indexes()\n        self.create_altered_constraints()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        # Generate index operation\n        self.generate_removed_indexes()\n        self.generate_removed_constraints()\n        # Generate M2M fields after models and fields\n        self.generate_added_m2m()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations aren't specially named, but the names\n        do matter for dependencies inside the set.\n\n        generate_altered_foo_together() rely on self.kept_model_keys.\n        This is fine for now but would be an issue if we allowed things\n        like CreateModel and DeleteModel in the same migration.\n        \"\"\"\n        self.generate_renamed_models()\n\n        # Prepare lists of fields and generate through model map\n        self._prepare_field_lists()\n        self._generate_through_model_map()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes/unique_together before adding new fields,\n        # because we need to take into account any renamed fields for backward\n        # compatibility.\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n\n        self.generate_removed_indexes()\n        self.generate_removed_constraints()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations should create the same end state as\n        'to_state' but may not be optimal. The plan is computed by\n        first generating a list of operations that achieve the required\n        state change and then splitting them into migrations respecting\n        the MigrationRecorder.Migration.max_migration_txt_size limit and\n        model inter-dependency constraints.\n\n        The migration plans are stored in self.migrations for later\n        retrieval.\n        \"\"\"\n        self.generated_operations = {}\n        self.altered_indexes = {}\n        self.altered_constraints = {}\n\n        # Prepare some old/new state and model lists, separating\n        # proxy models and ignoring unmigrated apps.\n        self.old_apps = self.from_state.concrete_apps\n        self.new_apps = self.to_state.concrete_apps\n        self.old_model_keys = set()\n        self.old_proxy_keys = set()\n        self.old_unmanaged_keys = set()\n        self.new_model_keys = set()\n        self.new_proxy_keys = set()\n        self.new_unmanaged_keys = set()\n        for al, mn in self.from_state.models:\n            model = self.old_apps.get_model(al, mn)\n            if not model._meta.managed:\n                self.old_unmanaged_keys.add((al, mn))\n            elif model._meta.proxy:\n                self.old_proxy_keys.add((al, mn))\n            else:\n                self.old_model_keys.add((al, mn))\n\n        for al, mn in self.to_state.models:\n            model = self.new_apps.get_model(al, mn)\n            if not model._meta.managed:\n                self.new_unmanaged_keys.add((al, mn))\n            elif model._meta.proxy:\n                self.new_proxy_keys.add((al, mn))\n            else:\n                self.new_model_keys.add((al, mn))\n\n        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n        self.through_users = {}\n        self.old_field_keys = {\n            (al, mn, fn)\n            for al, mn in self.kept_model_keys\n            for fn in self.from_state.models[\n                al, self.renamed_models.get((al, mn), mn)\n            ].fields\n        }\n        self.new_field_keys = {\n            (al, mn, fn)\n            for al, mn in self.kept_model_keys\n            for fn in self.to_state.models[al, mn].fields\n        }\n\n        self.generate_renamed_models()\n\n        # Prepare field lists\n        self.kept_field_keys = self.old_field_keys & self.new_field_keys\n        self.renamed_fields = {}\n        self.generate_renamed_fields()\n        self.generate_removed_altered_unique_together()\n        self.generate_removed_altered_index_together()\n        self.generate_removed_altered_order_with_respect_to()\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n\n        # Create the altered indexes/constraints first so we only have to\n        # deal with potential cascades from the removal side in one location.\n        # This must happen before the removal of the fields they depend on.\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        self.generate_removed_fields()\n\n        # Generate field operations\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n",
      "\n    def _detect_changes(self):\n        \"\"\"\n        Return a dict of migration plans which will achieve the\n        change from from_state to to_state. The dict has app labels\n        as keys and a list of migrations as values.\n\n        The resulting migrations are all marked as replacing the old\n        migration files they replace.\n        \"\"\"\n        # The first phase is generating all the operations for each app\n        # and gathering them into a big per-app list.\n        # Then go through that list, order things nicely, and split\n        # into migrations to accommodate dependency stuff.\n        self.generated_operations = {}\n        self.altered_indexes = {}\n        self.altered_constraints = {}\n\n        # Prepare some old/new state and model lists, separating\n        # proxy models and ignoring unmigrated apps.\n        self.old_apps = self.from_state.concrete_apps\n        self.new_apps = self.to_state.concrete_apps\n        self.old_model_keys = set()\n        self.old_proxy_keys = set()\n        self.old_unmanaged_keys = set()\n        self.new_model_keys = set()\n        self.new_proxy_keys = set()\n        self.new_unmanaged_keys = set()\n        for (app_label, model_name), model_state in self.from_state.models.items():\n            if app_label not in self.old_apps:\n                continue\n            if model_state.options.get(\"proxy\"):\n                self.old_proxy_keys.add((app_label, model_name))\n            elif not model_state.options.get(\"managed\", True):\n                self.old_unmanaged_keys.add((app_label, model_name))\n            else:\n                self.old_model_keys.add((app_label, model_name))\n\n        for (app_label, model_name), model_state in self.to_state.models.items():\n            if app_label not in self.new_apps:\n                continue\n            if model_state.options.get(\"proxy\"):\n                self.new_proxy_keys.add((app_label, model_name))\n            elif not model_state.options.get(\"managed\", True):\n                self.new_unmanaged_keys.add((app_label, model_name))\n            else:\n                self.new_model_keys.add((app_label, model_name))\n\n        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n\n        # Generate the operations for each target app\n        for app_label in sorted(self.new_apps.union(self.old_apps)):\n            self.generated_operations[app_label] = []\n            self.altered_indexes[app_label] = []\n            self.altered_constraints[app_label] = []\n\n        # Generate non-rename model operations\n        self.generate_deleted_models()\n        self.generate_created_models()\n        self.generate_deleted_proxies()\n        self.generate_created_proxies()\n        self.generate_altered_options()\n        self.generate_altered_managers()\n        # Create the altered indexes/constraints operations\n        self.generate_removed_constraints()\n        self.generate_removed_indexes()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        # Generate field operations\n        self.generate_renamed_fields()\n        self.generate_removed_fields()\n        self.generate_added_fields()\n        self.generate_altered_fields()\n        self.generate_altered_unique_together()\n        self.generate_altered_index_together()\n        self.generate_altered_order_with_respect_to()\n        self.generate_added_indexes()\n        self.generate_added_constraints()\n        self.generate_altered_db_table()\n        self.generate_renamed_models()\n\n        self._sort_migrations()\n        self._build_migration_list()\n        self._optimize_migrations()\n\n        return self.migrations\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..1a257a3b31 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -184,10 +184,11 @@ class MigrationAutodetector:\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n+\n+        self.generate_altered_order_with_respect_to()\n         self.generate_added_indexes()\n         self.generate_added_constraints()\n         self.generate_altered_db_table()\n-        self.generate_altered_order_with_respect_to()\n \n         self._sort_migrations()\n         self._build_migration_list(graph)\n@@ -1012,6 +1013,7 @@ class MigrationAutodetector:\n                 }\n             })\n \n+\n     def generate_added_indexes(self):\n         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n             for index in alt_indexes['added_indexes']:\n@@ -1189,6 +1191,7 @@ class MigrationAutodetector:\n                     )\n                 )\n \n+\n     def generate_altered_order_with_respect_to(self):\n         for app_label, model_name in sorted(self.kept_model_keys):\n             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n",
    "variant_0": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..ff0f484adc 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -184,10 +184,21 @@ class MigrationAutodetector:\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n         self.generate_added_indexes()\n         self.generate_added_constraints()\n         self.generate_altered_db_table()\n-        self.generate_altered_order_with_respect_to()\n \n         self._sort_migrations()\n         self._build_migration_list(graph)\n@@ -1012,15 +1023,93 @@ class MigrationAutodetector:\n                 }\n             })\n \n-    def generate_added_indexes(self):\n-        for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n-            for index in alt_indexes['added_indexes']:\n-                self.add_operation(\n-                    app_label,\n-                    operations.AddIndex(\n-                        model_name=model_name,\n-                        index=index,\n-                    )\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_altered_foo_together() rely on self.altered_indexes and\n+        self.altered_constraints being populated by\n+        generate_removed_altered_foo_together(), so make sure there's a\n+        clear split between the two phases.\n+        \"\"\"\n+        self.generated_operations = {}\n+        self.altered_indexes = {}\n+        self.altered_constraints = {}\n+\n+        # Prepare some old/new state and model lists, separating\n+        # proxy models and ignoring unmigrated apps.\n+        self.old_apps = self.from_state.concrete_apps\n+        self.new_apps = self.to_state.concrete_apps\n+        self.old_model_keys = set()\n+        self.old_proxy_keys = set()\n+        self.old_unmanaged_keys = set()\n+        self.new_model_keys = set()\n+        self.new_proxy_keys = set()\n+        self.new_unmanaged_keys = set()\n+        for (app_label, model_name), model_state in self.from_state.models.items():\n+            if not model_state.options.get('managed', True):\n+                self.old_unmanaged_keys.add((app_label, model_name))\n+            elif app_label not in self.from_state.real_apps:\n+                if model_state.options.get('proxy'):\n+                    self.old_proxy_keys.add((app_label, model_name))\n+                else:\n+                    self.old_model_keys.add((app_label, model_name))\n+\n+        for (app_label, model_name), model_state in self.to_state.models.items():\n+            if not model_state.options.get('managed', True):\n+                self.new_unmanaged_keys.add((app_label, model_name))\n+            elif app_label not in self.to_state.real_apps:\n+                if model_state.options.get('proxy'):\n+                    self.new_proxy_keys.add((app_label, model_name))\n+                else:\n+                    self.new_model_keys.add((app_label, model_name))\n+\n+        # Renames have to come first\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes/constraints first, before adding\n+        # or removing fields, so that we can detect any\n+        # ForeignKeyViolationError that may occur if we drop a foreign\n+        # key field and there are still references to it.\n+        self.generate_removed_altered_unique_together()\n+        self.generate_removed_altered_index_together()\n+\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                 )\n \n     def generate_removed_indexes(self):\n@@ -1189,30 +1278,109 @@ class MigrationAutodetector:\n                     )\n                 )\n \n-    def generate_altered_order_with_respect_to(self):\n-        for app_label, model_name in sorted(self.kept_model_keys):\n-            old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n-            old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, model_name]\n-            if (old_model_state.options.get(\"order_with_respect_to\") !=\n-                    new_model_state.options.get(\"order_with_respect_to\")):\n-                # Make sure it comes second if we're adding\n-                # (removal dependency is part of RemoveField)\n-                dependencies = []\n-                if new_model_state.options.get(\"order_with_respect_to\"):\n-                    dependencies.append((\n-                        app_label,\n-                        model_name,\n-                        new_model_state.options[\"order_with_respect_to\"],\n-                        True,\n-                    ))\n-                # Actually generate the operation\n-                self.add_operation(\n-                    app_label,\n-                    operations.AlterOrderWithRespectTo(\n-                        name=model_name,\n-                        order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n-                    ),\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations should create the same end state as\n+        the current new_state, though they may not be optimal.\n+        \"\"\"\n+        # The first phase is generating all the operations for each app\n+        # and gathering them into a big per-app list.\n+        # Then go through that list, order things nicely, and split\n+        # into migrations to resolve dependencies.\n+        self.generated_operations = {}\n+        self.altered_indexes = {}\n+        self.altered_constraints = {}\n+\n+        # Prepare some old/new state and model lists, separating\n+        # proxy models and ignoring unmigrated apps.\n+        self.old_apps = self.from_state.concrete_apps\n+        self.new_apps = self.to_state.concrete_apps\n+        self.old_model_keys = set()\n+        self.old_proxy_keys = set()\n+        self.old_unmanaged_keys = set()\n+        self.new_model_keys = set()\n+        self.new_proxy_keys = set()\n+        self.new_unmanaged_keys = set()\n+        for (app_label, model_name), model_state in self.from_state.models.items():\n+            if app_label not in self.from_state.real_apps:\n+                continue\n+            if model_state.options.get(\"proxy\"):\n+                self.old_proxy_keys.add((app_label, model_name))\n+            elif not model_state.options.get(\"managed\", True):\n+                self.old_unmanaged_keys.add((app_label, model_name))\n+            else:\n+                self.old_model_keys.add((app_label, model_name))\n+\n+        for (app_label, model_name), model_state in self.to_state.models.items():\n+            if app_label not in self.to_state.real_apps:\n+                continue\n+            if model_state.options.get(\"proxy\"):\n+                self.new_proxy_keys.add((app_label, model_name))\n+            elif not model_state.options.get(\"managed\", True):\n+                self.new_unmanaged_keys.add((app_label, model_name))\n+            else:\n+                self.new_model_keys.add((app_label, model_name))\n+\n+        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n+        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n+        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n+        self.through_users = {}\n+        self.old_field_keys = {\n+            (app_label, model_name, field_name)\n+            for app_label, model_name in self.kept_model_keys\n+            for field_name in self.from_state.models[\n+                app_label,\n+                self.renamed_models.get((app_label, model_name), model_name)\n+            ].fields\n+        }\n+        self.new_field_keys = {\n+            (app_label, model_name, field_name)\n+            for app_label, model_name in self.kept_model_keys\n+            for field_name in self.to_state.models[app_label, model_name].fields\n+        }\n+\n+        self.generate_renamed_models()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes and store them in self.altered_indexes.\n+        # This avoids the same computation in generate_removed_indexes()\n+        # and generate_added_indexes().\n+        self.create_altered_indexes()\n+        self.create_altered_constraints()\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_indexes()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        # Generate index addition operations after field is created, in\n+        # case the index references the new field\n+        self.generate_removed_constraints()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                     dependencies=dependencies,\n                 )\n \n",
    "variant_1": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..798581041c 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -184,10 +184,21 @@ class MigrationAutodetector:\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n         self.generate_added_indexes()\n         self.generate_added_constraints()\n         self.generate_altered_db_table()\n-        self.generate_altered_order_with_respect_to()\n \n         self._sort_migrations()\n         self._build_migration_list(graph)\n@@ -1012,15 +1023,90 @@ class MigrationAutodetector:\n                 }\n             })\n \n-    def generate_added_indexes(self):\n-        for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n-            for index in alt_indexes['added_indexes']:\n-                self.add_operation(\n-                    app_label,\n-                    operations.AddIndex(\n-                        model_name=model_name,\n-                        index=index,\n-                    )\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations should create the to_state from the\n+        from_state, but not necessarily optimize them. The optimization\n+        phase is a separate step later on.\n+        \"\"\"\n+        self.generated_operations = {}\n+        self.altered_indexes = {}\n+        self.altered_constraints = {}\n+\n+        # Prepare some old/new state and model lists, separating\n+        # proxy models and ignoring unmigrated apps.\n+        self.old_apps = self.from_state.concrete_apps\n+        self.new_apps = self.to_state.concrete_apps\n+        self.old_model_keys = set()\n+        self.old_proxy_keys = set()\n+        self.old_unmanaged_keys = set()\n+        self.new_model_keys = set()\n+        self.new_proxy_keys = set()\n+        self.new_unmanaged_keys = set()\n+        for (app_label, model_name), model_state in self.from_state.models.items():\n+            if not model_state.options.get('managed', True):\n+                self.old_unmanaged_keys.add((app_label, model_name))\n+            elif app_label not in self.from_state.real_apps:\n+                if model_state.options.get('proxy'):\n+                    self.old_proxy_keys.add((app_label, model_name))\n+                else:\n+                    self.old_model_keys.add((app_label, model_name))\n+        for (app_label, model_name), model_state in self.to_state.models.items():\n+            if not model_state.options.get('managed', True):\n+                self.new_unmanaged_keys.add((app_label, model_name))\n+            elif app_label not in self.from_state.real_apps:\n+                if model_state.options.get('proxy'):\n+                    self.new_proxy_keys.add((app_label, model_name))\n+                else:\n+                    self.new_model_keys.add((app_label, model_name))\n+\n+        # Renames have to come first\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes/constraints before running through\n+        # the other model changes, so that we can create/delete them\n+        # properly\n+        self._create_altered_indexes()\n+        self._create_altered_constraints()\n+\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        # Generate index/constraint operations\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+        # Generate removed index/constraint operations\n+        self.generate_removed_indexes()\n+        self.generate_removed_constraints()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                 )\n \n     def generate_removed_indexes(self):\n@@ -1189,30 +1275,65 @@ class MigrationAutodetector:\n                     )\n                 )\n \n-    def generate_altered_order_with_respect_to(self):\n-        for app_label, model_name in sorted(self.kept_model_keys):\n-            old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n-            old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, model_name]\n-            if (old_model_state.options.get(\"order_with_respect_to\") !=\n-                    new_model_state.options.get(\"order_with_respect_to\")):\n-                # Make sure it comes second if we're adding\n-                # (removal dependency is part of RemoveField)\n-                dependencies = []\n-                if new_model_state.options.get(\"order_with_respect_to\"):\n-                    dependencies.append((\n-                        app_label,\n-                        model_name,\n-                        new_model_state.options[\"order_with_respect_to\"],\n-                        True,\n-                    ))\n-                # Actually generate the operation\n-                self.add_operation(\n-                    app_label,\n-                    operations.AlterOrderWithRespectTo(\n-                        name=model_name,\n-                        order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n-                    ),\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_altered_foo_together() rely on self.altered_indexes and\n+        self.altered_constraints being populated by\n+        generate_removed_indexes() and generate_removed_constraints().\n+        \"\"\"\n+        # The first phase is generating all the operations for each app\n+        # and gathering modified models.\n+        for app_label in self.from_state.apps.get_app_configs():\n+            self.check_dependency(app_label, '__first__')\n+        for app_label in self.to_state.apps.get_app_configs():\n+            self.check_dependency(app_label, '__first__')\n+\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map.\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations.\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes and store them in self.altered_indexes.\n+        # This is used later in generate_altered_unique_together().\n+        self.generate_removed_indexes()\n+        # Create the altered constraints and store them in\n+        # self.altered_constraints. This is used later in\n+        # generate_altered_unique_together().\n+        self.generate_removed_constraints()\n+\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                     dependencies=dependencies,\n                 )\n \n",
    "variant_2": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..31198ced0d 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -184,10 +184,21 @@ class MigrationAutodetector:\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n         self.generate_added_indexes()\n         self.generate_added_constraints()\n         self.generate_altered_db_table()\n-        self.generate_altered_order_with_respect_to()\n \n         self._sort_migrations()\n         self._build_migration_list(graph)\n@@ -1012,15 +1023,90 @@ class MigrationAutodetector:\n                 }\n             })\n \n-    def generate_added_indexes(self):\n-        for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n-            for index in alt_indexes['added_indexes']:\n-                self.add_operation(\n-                    app_label,\n-                    operations.AddIndex(\n-                        model_name=model_name,\n-                        index=index,\n-                    )\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_altered_foo_together() rely on self.altered_indexes and\n+        self.altered_constraints being populated by\n+        generate_removed_altered_foo_together(), so make sure that's run\n+        first.\n+        \"\"\"\n+        self.generated_operations = {}\n+        self.altered_indexes = {}\n+        self.altered_constraints = {}\n+\n+        # Prepare some old/new state and model lists, separating\n+        # proxy models and ignoring unmigrated apps.\n+        self.old_apps = self.from_state.concrete_apps\n+        self.new_apps = self.to_state.concrete_apps\n+        self.old_model_keys = set()\n+        self.old_proxy_keys = set()\n+        self.old_unmanaged_keys = set()\n+        self.new_model_keys = set()\n+        self.new_proxy_keys = set()\n+        self.new_unmanaged_keys = set()\n+        for al, mn in self.from_state.models:\n+            model = self.old_apps.get_model(al, mn)\n+            if not model._meta.managed:\n+                self.old_unmanaged_keys.add((al, mn))\n+            elif self.old_apps.get_model(al, mn)._meta.proxy:\n+                self.old_proxy_keys.add((al, mn))\n+            else:\n+                self.old_model_keys.add((al, mn))\n+\n+        for al, mn in self.to_state.models:\n+            model = self.new_apps.get_model(al, mn)\n+            if not model._meta.managed:\n+                self.new_unmanaged_keys.add((al, mn))\n+            elif self.new_apps.get_model(al, mn)._meta.proxy:\n+                self.new_proxy_keys.add((al, mn))\n+            else:\n+                self.new_model_keys.add((al, mn))\n+\n+        self.generate_renamed_models()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the renamed fields and store them in self.renamed_fields.\n+        # They are used by generate_removed_fields()\n+        self.create_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+\n+        self.generate_removed_altered_unique_together()\n+        self.generate_removed_altered_index_together()\n+        self.generate_removed_altered_constraints()\n+        self.generate_removed_altered_indexes()\n+\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self.generate_removed_indexes()\n+        self.generate_removed_constraints()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                 )\n \n     def generate_removed_indexes(self):\n@@ -1189,30 +1275,108 @@ class MigrationAutodetector:\n                     )\n                 )\n \n-    def generate_altered_order_with_respect_to(self):\n-        for app_label, model_name in sorted(self.kept_model_keys):\n-            old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n-            old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, model_name]\n-            if (old_model_state.options.get(\"order_with_respect_to\") !=\n-                    new_model_state.options.get(\"order_with_respect_to\")):\n-                # Make sure it comes second if we're adding\n-                # (removal dependency is part of RemoveField)\n-                dependencies = []\n-                if new_model_state.options.get(\"order_with_respect_to\"):\n-                    dependencies.append((\n-                        app_label,\n-                        model_name,\n-                        new_model_state.options[\"order_with_respect_to\"],\n-                        True,\n-                    ))\n-                # Actually generate the operation\n-                self.add_operation(\n-                    app_label,\n-                    operations.AlterOrderWithRespectTo(\n-                        name=model_name,\n-                        order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n-                    ),\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations should create the same end state as\n+        to_state and represent a minimal set of changes.\n+        \"\"\"\n+        # The first phase is generating all the operations for each app\n+        # and gathering them into a big per-app list.\n+        # Then go through that list, order it, and split into migrations to\n+        # resolve dependencies caused by M2Ms and FKs.\n+        self.generated_operations = {}\n+        self.altered_indexes = {}\n+        self.altered_constraints = {}\n+\n+        # Prepare some old/new state and model lists, separating\n+        # proxy models and ignoring unmigrated apps.\n+        self.old_apps = self.from_state.concrete_apps\n+        self.new_apps = self.to_state.concrete_apps\n+        self.old_model_keys = set()\n+        self.old_proxy_keys = set()\n+        self.old_unmanaged_keys = set()\n+        self.new_model_keys = set()\n+        self.new_proxy_keys = set()\n+        self.new_unmanaged_keys = set()\n+        for (app_label, model_name), model_state in self.from_state.models.items():\n+            if not model_state.options.get(\"managed\", True):\n+                self.old_unmanaged_keys.add((app_label, model_name))\n+            elif self.old_apps.get_model(app_label, model_name)._meta.proxy:\n+                self.old_proxy_keys.add((app_label, model_name))\n+            else:\n+                self.old_model_keys.add((app_label, model_name))\n+\n+        for (app_label, model_name), model_state in self.to_state.models.items():\n+            if not model_state.options.get(\"managed\", True):\n+                self.new_unmanaged_keys.add((app_label, model_name))\n+            elif self.new_apps.get_model(app_label, model_name)._meta.proxy:\n+                self.new_proxy_keys.add((app_label, model_name))\n+            else:\n+                self.new_model_keys.add((app_label, model_name))\n+\n+        self.renamed_models = {}\n+        self.renamed_models_rel = {}\n+        self.renamed_fields = {}\n+        self.renamed_fields_rel = {}\n+        self.removed_altered_unique_together = []\n+        self.removed_altered_index_together = []\n+        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n+        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n+        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n+        self.through_users = {}\n+        self.old_field_keys = {\n+            (app_label, model_name, field_name)\n+            for app_label, model_name in self.kept_model_keys\n+            for field_name in self.from_state.models[\n+                app_label,\n+                self.renamed_models.get((app_label, model_name), model_name)\n+            ].fields\n+        }\n+        self.new_field_keys = {\n+            (app_label, model_name, field_name)\n+            for app_label, model_name in self.kept_model_keys\n+            for field_name in self.to_state.models[app_label, model_name].fields\n+        }\n+\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self.generate_renamed_fields()\n+        self.generate_removed_altered_unique_together()\n+        self.generate_removed_altered_index_together()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes/constraints before adding new fields.\n+        self.create_altered_indexes()\n+        self.create_altered_constraints()\n+\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                     dependencies=dependencies,\n                 )\n \n",
    "variant_3": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..7044308a1b 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -184,10 +184,21 @@ class MigrationAutodetector:\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n         self.generate_added_indexes()\n         self.generate_added_constraints()\n         self.generate_altered_db_table()\n-        self.generate_altered_order_with_respect_to()\n \n         self._sort_migrations()\n         self._build_migration_list(graph)\n@@ -1012,15 +1023,84 @@ class MigrationAutodetector:\n                 }\n             })\n \n-    def generate_added_indexes(self):\n-        for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n-            for index in alt_indexes['added_indexes']:\n-                self.add_operation(\n-                    app_label,\n-                    operations.AddIndex(\n-                        model_name=model_name,\n-                        index=index,\n-                    )\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_X_name() methods are used to generate the operations for each\n+        of these types of change, and then the optimizer attempts to\n+        optimize them - just in case, for example, a model with two\n+        ForeignKeys gets a unique_together set, and then the \"alter\"\n+        operation and the \"set unique_together\" should become one\n+        AddModel with inline unique_together definition.\n+\n+        Alphabetical change types and a few notes:\n+        add_alter_order_with_respect_to_index: Index with order_with_respect_to;\n+            respect order of field changes\n+        add_alter_unique_together: Unique together constraints\n+        add_field/remove_field: Added and removed fields\n+        add_index: Added indexes\n+        add_constraint: Added constraints\n+        alter_* (non-rename): Field and other changes\n+        create_model/delete_model: Creation and deletion of entire models\n+        rename_*: Field and model renames\n+        remove_*: Removed indexes, constraints, etc.\n+        \"\"\"\n+        # The first phase is generating all the operations for each app\n+        # and gathering the dependencies of each model.\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map.\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations.\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes and store them in self.altered_indexes.\n+        # This also automatically generates deleted indexes.\n+        self.create_altered_indexes()\n+        self.create_altered_constraints()\n+\n+        # Generate index removal operations before field removal.\n+        self.generate_removed_indexes()\n+        self.generate_removed_constraints()\n+\n+        # Generate field operations.\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+\n+        # Generate unique_together and index_together operations.\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        \n+        # Generate order_with_respect_to operations before index operations\n+        # to ensure _order field exists before creating indexes on it\n+        self.generate_altered_order_with_respect_to()\n+        \n+        # Generate index and constraint operations after order_with_respect_to\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                 )\n \n     def generate_removed_indexes(self):\n@@ -1189,30 +1269,111 @@ class MigrationAutodetector:\n                     )\n                 )\n \n-    def generate_altered_order_with_respect_to(self):\n-        for app_label, model_name in sorted(self.kept_model_keys):\n-            old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n-            old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, model_name]\n-            if (old_model_state.options.get(\"order_with_respect_to\") !=\n-                    new_model_state.options.get(\"order_with_respect_to\")):\n-                # Make sure it comes second if we're adding\n-                # (removal dependency is part of RemoveField)\n-                dependencies = []\n-                if new_model_state.options.get(\"order_with_respect_to\"):\n-                    dependencies.append((\n-                        app_label,\n-                        model_name,\n-                        new_model_state.options[\"order_with_respect_to\"],\n-                        True,\n-                    ))\n-                # Actually generate the operation\n-                self.add_operation(\n-                    app_label,\n-                    operations.AlterOrderWithRespectTo(\n-                        name=model_name,\n-                        order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n-                    ),\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_X_Y() functions are called to defer the generation of\n+        individual operations; alter_foo_together operation are preferred\n+        over multiple add/remove of foo_together at once.\n+        \"\"\"\n+        # The first phase is generating all the operations for each app\n+        # and gathering them into a big per-app list.\n+        # Then go through that list, order things nicely, and split\n+        # into migrations to resolve dependencies caused by M2Ms and\n+        # FKs.\n+        self.generated_operations = {}\n+\n+        # Prepare some old/new state and model lists, separating\n+        # proxy models and ignoring unmigrated apps.\n+        self.old_apps = self.from_state.concrete_apps\n+        self.new_apps = self.to_state.concrete_apps\n+        self.old_model_keys = set()\n+        self.old_proxy_keys = set()\n+        self.old_unmanaged_keys = set()\n+        self.new_model_keys = set()\n+        self.new_proxy_keys = set()\n+        self.new_unmanaged_keys = set()\n+        for (app_label, model_name), model_state in self.from_state.models.items():\n+            if not model_state.options.get(\"managed\", True):\n+                self.old_unmanaged_keys.add((app_label, model_name))\n+            elif self.old_apps.get_model(app_label, model_name)._meta.proxy:\n+                self.old_proxy_keys.add((app_label, model_name))\n+            else:\n+                self.old_model_keys.add((app_label, model_name))\n+\n+        for (app_label, model_name), model_state in self.to_state.models.items():\n+            if not model_state.options.get(\"managed\", True):\n+                self.new_unmanaged_keys.add((app_label, model_name))\n+            elif self.new_apps.get_model(app_label, model_name)._meta.proxy:\n+                self.new_proxy_keys.add((app_label, model_name))\n+            else:\n+                self.new_model_keys.add((app_label, model_name))\n+\n+        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n+        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n+        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n+        self.through_users = {}\n+        self.old_field_keys = {\n+            (app_label, model_name, field_name)\n+            for app_label, model_name in self.kept_model_keys\n+            for field_name in self.from_state.models[\n+                app_label,\n+                self.renamed_models.get((app_label, model_name), model_name)\n+            ].fields\n+        }\n+        self.new_field_keys = {\n+            (app_label, model_name, field_name)\n+            for app_label, model_name in self.kept_model_keys\n+            for field_name in self.to_state.models[app_label, model_name].fields\n+        }\n+\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the renamed fields and store them in self.renamed_fields.\n+        # They are used by the migration optimizer (see #22275) and the\n+        # generate_altered_fields().\n+        self.generate_renamed_fields()\n+\n+        # Generate field operations\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+\n+        # Generate index operation (only swap/alter_together).\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self.generate_removed_indexes()\n+        self.generate_removed_constraints()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                     dependencies=dependencies,\n                 )\n \n",
    "variant_4": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..9543d9b0e0 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -184,10 +184,21 @@ class MigrationAutodetector:\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n         self.generate_added_indexes()\n         self.generate_added_constraints()\n         self.generate_altered_db_table()\n-        self.generate_altered_order_with_respect_to()\n \n         self._sort_migrations()\n         self._build_migration_list(graph)\n@@ -1012,15 +1023,71 @@ class MigrationAutodetector:\n                 }\n             })\n \n-    def generate_added_indexes(self):\n-        for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n-            for index in alt_indexes['added_indexes']:\n-                self.add_operation(\n-                    app_label,\n-                    operations.AddIndex(\n-                        model_name=model_name,\n-                        index=index,\n-                    )\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_altered_foo_together() rely on matching Field instances and\n+        so must be run before generate_removed_fields().\n+        generate_removed_fields() must be run before generate_deleted_models()\n+        as it honors the through_fields on the relationship.\n+        generate_deleted_models() must be run before generate_model_managers()\n+        as the later relies on the former to distinguish through models.\n+        generate_model_managers() must be run before generate_manager_bases()\n+        as managers need to be handled before bases in multi-table inheritance\n+        where the manager is defined on the child model.\n+        \"\"\"\n+        # The first phase is generating all the operations for each app\n+        # and gathering them into a big per-app list.\n+        # Then go through that list, order things nicely, and split off the\n+        # migrations.\n+\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+        self.generate_manager_bases()\n+\n+        # Create the altered indexes/unique_together operations\n+        self._create_altered_indexes()\n+\n+        # Generate index/constraint operations\n+        self.generate_removed_indexes()\n+        self.generate_removed_constraints()\n+\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                 )\n \n     def generate_removed_indexes(self):\n@@ -1189,30 +1256,102 @@ class MigrationAutodetector:\n                     )\n                 )\n \n-    def generate_altered_order_with_respect_to(self):\n-        for app_label, model_name in sorted(self.kept_model_keys):\n-            old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n-            old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, model_name]\n-            if (old_model_state.options.get(\"order_with_respect_to\") !=\n-                    new_model_state.options.get(\"order_with_respect_to\")):\n-                # Make sure it comes second if we're adding\n-                # (removal dependency is part of RemoveField)\n-                dependencies = []\n-                if new_model_state.options.get(\"order_with_respect_to\"):\n-                    dependencies.append((\n-                        app_label,\n-                        model_name,\n-                        new_model_state.options[\"order_with_respect_to\"],\n-                        True,\n-                    ))\n-                # Actually generate the operation\n-                self.add_operation(\n-                    app_label,\n-                    operations.AlterOrderWithRespectTo(\n-                        name=model_name,\n-                        order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n-                    ),\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_renamed_models() and generate_removed_models() must be\n+        called before any of the other generate_*() methods.\n+        \"\"\"\n+        # The first phase is generating all the operations for each app\n+        # and gathering them into a big per-app list.\n+        # Then go through that list, order things nicely, and split\n+        # into migrations to resolve dependencies caused by M2Ms and\n+        # FKs.\n+        self.generated_operations = {}\n+\n+        # Prepare some old/new state and model lists, separating\n+        # proxy models and ignoring unmigrated apps.\n+        self.old_apps = self.from_state.concrete_apps\n+        self.new_apps = self.to_state.concrete_apps\n+        self.old_model_keys = set()\n+        self.old_proxy_keys = set()\n+        self.old_unmanaged_keys = set()\n+        self.new_model_keys = set()\n+        self.new_proxy_keys = set()\n+        self.new_unmanaged_keys = set()\n+        for app_label in self.kept_model_keys:\n+            for model_name in self.from_state.models:\n+                if model_name[0] == app_label:\n+                    model_state = self.from_state.models[model_name]\n+                    if not model_state.options.get(\"managed\", True):\n+                        self.old_unmanaged_keys.add(model_name)\n+                    elif model_state.options.get(\"proxy\", False):\n+                        self.old_proxy_keys.add(model_name)\n+                    else:\n+                        self.old_model_keys.add(model_name)\n+\n+        for app_label in self.kept_model_keys:\n+            for model_name in self.to_state.models:\n+                if model_name[0] == app_label:\n+                    model_state = self.to_state.models[model_name]\n+                    if not model_state.options.get(\"managed\", True):\n+                        self.new_unmanaged_keys.add(model_name)\n+                    elif model_state.options.get(\"proxy\", False):\n+                        self.new_proxy_keys.add(model_name)\n+                    else:\n+                        self.new_model_keys.add(model_name)\n+\n+        # Renames have to come first\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes and store them in self.altered_indexes.\n+        # This is used later to exclude indexes on M2M fields from being\n+        # created.\n+        self.create_altered_indexes()\n+        self.create_altered_constraints()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_indexes()\n+        # Generate constraint removal operations before field is removed\n+        self.generate_removed_constraints()\n+\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        # Generate M2M fields after other fields (we need the table to exist)\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                     dependencies=dependencies,\n                 )\n \n",
    "variant_5": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..c6adab07ab 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -184,10 +184,21 @@ class MigrationAutodetector:\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n         self.generate_added_indexes()\n         self.generate_added_constraints()\n         self.generate_altered_db_table()\n-        self.generate_altered_order_with_respect_to()\n \n         self._sort_migrations()\n         self._build_migration_list(graph)\n@@ -1012,15 +1023,53 @@ class MigrationAutodetector:\n                 }\n             })\n \n-    def generate_added_indexes(self):\n-        for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n-            for index in alt_indexes['added_indexes']:\n-                self.add_operation(\n-                    app_label,\n-                    operations.AddIndex(\n-                        model_name=model_name,\n-                        index=index,\n-                    )\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_altered_foo_together() rely on generate_removed_foo() and\n+        generate_added_foo() being run first.\n+        \"\"\"\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+\n+        # Create the renamed fields and store them in self.renamed_fields.\n+        # They are used by generate_removed_fields()\n+        self.create_renamed_fields()\n+        # Generate field operations\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        # Generate index operation (only AddIndex and RemoveIndex)\n+        self.generate_removed_indexes()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+        self.generate_removed_constraints()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                 )\n \n     def generate_removed_indexes(self):\n@@ -1189,30 +1238,115 @@ class MigrationAutodetector:\n                     )\n                 )\n \n-    def generate_altered_order_with_respect_to(self):\n-        for app_label, model_name in sorted(self.kept_model_keys):\n-            old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n-            old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, model_name]\n-            if (old_model_state.options.get(\"order_with_respect_to\") !=\n-                    new_model_state.options.get(\"order_with_respect_to\")):\n-                # Make sure it comes second if we're adding\n-                # (removal dependency is part of RemoveField)\n-                dependencies = []\n-                if new_model_state.options.get(\"order_with_respect_to\"):\n-                    dependencies.append((\n-                        app_label,\n-                        model_name,\n-                        new_model_state.options[\"order_with_respect_to\"],\n-                        True,\n-                    ))\n-                # Actually generate the operation\n-                self.add_operation(\n-                    app_label,\n-                    operations.AlterOrderWithRespectTo(\n-                        name=model_name,\n-                        order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n-                    ),\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_renamed_models() and generate_removed_models() must be\n+        run before any of the other generators.\n+        \"\"\"\n+        # The first phase is generating all the operations for each app\n+        # and gathering them into a big per-app list.\n+        # Then go through that list, order things nicely, and split\n+        # into migrations to resolve dependencies caused by M2Ms and\n+        # FKs.\n+        self.generated_operations = {}\n+        self.altered_indexes = {}\n+        self.altered_constraints = {}\n+\n+        # Prepare some old/new state and model lists, separating\n+        # proxy models and ignoring unmigrated apps.\n+        self.old_apps = self.from_state.concrete_apps\n+        self.new_apps = self.to_state.concrete_apps\n+        self.old_model_keys = set()\n+        self.old_proxy_keys = set()\n+        self.old_unmanaged_keys = set()\n+        self.new_model_keys = set()\n+        self.new_proxy_keys = set()\n+        self.new_unmanaged_keys = set()\n+        for al, mn in self.from_state.models:\n+            model = self.from_state.models[al, mn]\n+            if not model.options.get(\"managed\", True):\n+                self.old_unmanaged_keys.add((al, mn))\n+            elif al not in self.from_state.real_apps:\n+                if model.options.get(\"proxy\"):\n+                    self.old_proxy_keys.add((al, mn))\n+                else:\n+                    self.old_model_keys.add((al, mn))\n+\n+        for al, mn in self.to_state.models:\n+            model = self.to_state.models[al, mn]\n+            if not model.options.get(\"managed\", True):\n+                self.new_unmanaged_keys.add((al, mn))\n+            elif al not in self.to_state.real_apps:\n+                if model.options.get(\"proxy\"):\n+                    self.new_proxy_keys.add((al, mn))\n+                else:\n+                    self.new_model_keys.add((al, mn))\n+\n+        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n+        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n+        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n+        self.through_users = {}\n+        self.old_field_keys = {\n+            (al, mn, fn)\n+            for al, mn in self.kept_model_keys\n+            for fn in self.from_state.models[\n+                al, self.renamed_models.get((al, mn), mn)\n+            ].fields\n+        }\n+        self.new_field_keys = {\n+            (al, mn, fn)\n+            for al, mn in self.kept_model_keys\n+            for fn in self.to_state.models[al, mn].fields\n+        }\n+\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes/constraints before running\n+        # generate_removed_fields or generate_added_fields.\n+        self.create_altered_indexes()\n+        self.create_altered_constraints()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        # Generate index operation\n+        self.generate_removed_indexes()\n+        self.generate_removed_constraints()\n+        # Generate M2M fields after models and fields\n+        self.generate_added_m2m()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                     dependencies=dependencies,\n                 )\n \n",
    "variant_6": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..361164e971 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -184,10 +184,21 @@ class MigrationAutodetector:\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n         self.generate_added_indexes()\n         self.generate_added_constraints()\n         self.generate_altered_db_table()\n-        self.generate_altered_order_with_respect_to()\n \n         self._sort_migrations()\n         self._build_migration_list(graph)\n@@ -1012,15 +1023,49 @@ class MigrationAutodetector:\n                 }\n             })\n \n-    def generate_added_indexes(self):\n-        for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n-            for index in alt_indexes['added_indexes']:\n-                self.add_operation(\n-                    app_label,\n-                    operations.AddIndex(\n-                        model_name=model_name,\n-                        index=index,\n-                    )\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_altered_foo_together() rely on self.altered_indexes and\n+        self.altered_constraints so they must be called after\n+        _detect_changes().\n+        \"\"\"\n+        self.generate_renamed_models()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_altered_managers()\n+        # Generate index operations\n+        self.generate_removed_indexes()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+        self.generate_removed_constraints()\n+        # Generate model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_db_table_comment()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                 )\n \n     def generate_removed_indexes(self):\n@@ -1189,30 +1234,58 @@ class MigrationAutodetector:\n                     )\n                 )\n \n-    def generate_altered_order_with_respect_to(self):\n-        for app_label, model_name in sorted(self.kept_model_keys):\n-            old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n-            old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, model_name]\n-            if (old_model_state.options.get(\"order_with_respect_to\") !=\n-                    new_model_state.options.get(\"order_with_respect_to\")):\n-                # Make sure it comes second if we're adding\n-                # (removal dependency is part of RemoveField)\n-                dependencies = []\n-                if new_model_state.options.get(\"order_with_respect_to\"):\n-                    dependencies.append((\n-                        app_label,\n-                        model_name,\n-                        new_model_state.options[\"order_with_respect_to\"],\n-                        True,\n-                    ))\n-                # Actually generate the operation\n-                self.add_operation(\n-                    app_label,\n-                    operations.AlterOrderWithRespectTo(\n-                        name=model_name,\n-                        order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n-                    ),\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_altered_foo_together() rely on self.kept_model_keys.\n+        This is fine for now but would be an issue if we allowed things\n+        like CreateModel and DeleteModel in the same migration.\n+        \"\"\"\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes/unique_together before adding new fields,\n+        # because we need to take into account any renamed fields for backward\n+        # compatibility.\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+\n+        self.generate_removed_indexes()\n+        self.generate_removed_constraints()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                     dependencies=dependencies,\n                 )\n \n",
    "variant_7": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..e7750fc9de 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -184,10 +184,21 @@ class MigrationAutodetector:\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n         self.generate_added_indexes()\n         self.generate_added_constraints()\n         self.generate_altered_db_table()\n-        self.generate_altered_order_with_respect_to()\n \n         self._sort_migrations()\n         self._build_migration_list(graph)\n@@ -1012,15 +1023,96 @@ class MigrationAutodetector:\n                 }\n             })\n \n-    def generate_added_indexes(self):\n-        for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n-            for index in alt_indexes['added_indexes']:\n-                self.add_operation(\n-                    app_label,\n-                    operations.AddIndex(\n-                        model_name=model_name,\n-                        index=index,\n-                    )\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_*() methods are responsible for generating individual\n+        operations, depending on the type of the change. These methods\n+        should produce operations which, when combined together, will\n+        represent the change from the old state to the new state\n+        (without any reordering - that's later).\n+\n+        generate_*() methods are grouped together and should create\n+        operations in this order:\n+\n+        - Field and manager changes (including adding/removing through models)\n+        - Field and manager renames\n+        - Changing Meta options (index_together, unique_together, etc.)\n+        - Adding/removing indexes and constraints\n+\n+        The generate_*() method are split into two phases:\n+\n+        Phase 1 (main phase): adding/removing/renaming fields and managers,\n+        adding/removing models, changing most Meta options. These changes\n+        can be done independently for each model, so the methods in this\n+        phase don't need to consider inter-model dependencies and can be\n+        run in any order.\n+\n+        Phase 2 (post phase): adding/removing/renaming indexes and\n+        constraints. The methods in this phase may create operations which\n+        reference fields or models, so they need to run after phase 1 has\n+        completed.\n+\n+        The way the code is structured is that all the generate_*() methods\n+        (including phase 1 and phase 2) are run together, but the operations\n+        are split into two phases when writing them to the migration files\n+        (see ``arrangement`` in ``_build_migration_list()``).\n+        \"\"\"\n+        # The first phase is generating all the operations for each app\n+        # and gathering inter-app dependencies.\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Phase 1 - Adding model bases, managers and proxy models\n+        # These depend on the previous loops' preparation\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes/unique_together before removing fields\n+        # that the indexes/unique_together reference.\n+        self.create_altered_indexes()\n+        self.create_altered_unique_together()\n+\n+        # Generate field operations\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_renamed_fields()\n+\n+        # Phase 2 - Generate operations that may reference fields\n+        # on other models (so these must be done after the model structure\n+        # and field operations have been generated for all models).\n+        # Create other index/unique_together changes\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        # Generate altered_order_with_respect_to before adding indexes\n+        # to ensure _order field exists before indexes are created\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+        self.generate_removed_indexes()\n+        self.generate_removed_constraints()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                 )\n \n     def generate_removed_indexes(self):\n@@ -1189,30 +1281,112 @@ class MigrationAutodetector:\n                     )\n                 )\n \n-    def generate_altered_order_with_respect_to(self):\n-        for app_label, model_name in sorted(self.kept_model_keys):\n-            old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n-            old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, model_name]\n-            if (old_model_state.options.get(\"order_with_respect_to\") !=\n-                    new_model_state.options.get(\"order_with_respect_to\")):\n-                # Make sure it comes second if we're adding\n-                # (removal dependency is part of RemoveField)\n-                dependencies = []\n-                if new_model_state.options.get(\"order_with_respect_to\"):\n-                    dependencies.append((\n-                        app_label,\n-                        model_name,\n-                        new_model_state.options[\"order_with_respect_to\"],\n-                        True,\n-                    ))\n-                # Actually generate the operation\n-                self.add_operation(\n-                    app_label,\n-                    operations.AlterOrderWithRespectTo(\n-                        name=model_name,\n-                        order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n-                    ),\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations should create the same end state as\n+        'to_state' but may not be optimal. The plan is computed by\n+        first generating a list of operations that achieve the required\n+        state change and then splitting them into migrations respecting\n+        the MigrationRecorder.Migration.max_migration_txt_size limit and\n+        model inter-dependency constraints.\n+\n+        The migration plans are stored in self.migrations for later\n+        retrieval.\n+        \"\"\"\n+        self.generated_operations = {}\n+        self.altered_indexes = {}\n+        self.altered_constraints = {}\n+\n+        # Prepare some old/new state and model lists, separating\n+        # proxy models and ignoring unmigrated apps.\n+        self.old_apps = self.from_state.concrete_apps\n+        self.new_apps = self.to_state.concrete_apps\n+        self.old_model_keys = set()\n+        self.old_proxy_keys = set()\n+        self.old_unmanaged_keys = set()\n+        self.new_model_keys = set()\n+        self.new_proxy_keys = set()\n+        self.new_unmanaged_keys = set()\n+        for al, mn in self.from_state.models:\n+            model = self.old_apps.get_model(al, mn)\n+            if not model._meta.managed:\n+                self.old_unmanaged_keys.add((al, mn))\n+            elif model._meta.proxy:\n+                self.old_proxy_keys.add((al, mn))\n+            else:\n+                self.old_model_keys.add((al, mn))\n+\n+        for al, mn in self.to_state.models:\n+            model = self.new_apps.get_model(al, mn)\n+            if not model._meta.managed:\n+                self.new_unmanaged_keys.add((al, mn))\n+            elif model._meta.proxy:\n+                self.new_proxy_keys.add((al, mn))\n+            else:\n+                self.new_model_keys.add((al, mn))\n+\n+        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n+        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n+        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n+        self.through_users = {}\n+        self.old_field_keys = {\n+            (al, mn, fn)\n+            for al, mn in self.kept_model_keys\n+            for fn in self.from_state.models[\n+                al, self.renamed_models.get((al, mn), mn)\n+            ].fields\n+        }\n+        self.new_field_keys = {\n+            (al, mn, fn)\n+            for al, mn in self.kept_model_keys\n+            for fn in self.to_state.models[al, mn].fields\n+        }\n+\n+        self.generate_renamed_models()\n+\n+        # Prepare field lists\n+        self.kept_field_keys = self.old_field_keys & self.new_field_keys\n+        self.renamed_fields = {}\n+        self.generate_renamed_fields()\n+        self.generate_removed_altered_unique_together()\n+        self.generate_removed_altered_index_together()\n+        self.generate_removed_altered_order_with_respect_to()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes/constraints first so we only have to\n+        # deal with potential cascades from the removal side in one location.\n+        # This must happen before the removal of the fields they depend on.\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        self.generate_removed_fields()\n+\n+        # Generate field operations\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                     dependencies=dependencies,\n                 )\n \n",
    "variant_8": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 89e2dceeaf..93a8b21497 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -184,10 +184,21 @@ class MigrationAutodetector:\n         self.generate_altered_fields()\n         self.generate_altered_unique_together()\n         self.generate_altered_index_together()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n         self.generate_added_indexes()\n         self.generate_added_constraints()\n         self.generate_altered_db_table()\n-        self.generate_altered_order_with_respect_to()\n \n         self._sort_migrations()\n         self._build_migration_list(graph)\n@@ -1012,15 +1023,60 @@ class MigrationAutodetector:\n                 }\n             })\n \n-    def generate_added_indexes(self):\n-        for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n-            for index in alt_indexes['added_indexes']:\n-                self.add_operation(\n-                    app_label,\n-                    operations.AddIndex(\n-                        model_name=model_name,\n-                        index=index,\n-                    )\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations aren't specially named, but the names\n+        do matter for dependencies inside the set.\n+\n+        generate_renamed_models() and generate_removed_models() make the\n+        migrations depend on the previous migration automatically.\n+        \"\"\"\n+        self.generate_renamed_models()\n+\n+        # Prepare lists of fields and generate through model map\n+        self._prepare_field_lists()\n+        self._generate_through_model_map()\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+\n+        # Create the altered indexes/constraints/etc. for the models before\n+        # we do anything else with them\n+        self.create_altered_indexes()\n+        self.create_altered_constraints()\n+        self.generate_removed_indexes()\n+\n+        # Generate index removal operations before field is removed\n+        self.generate_removed_constraints()\n+\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                 )\n \n     def generate_removed_indexes(self):\n@@ -1189,30 +1245,94 @@ class MigrationAutodetector:\n                     )\n                 )\n \n-    def generate_altered_order_with_respect_to(self):\n-        for app_label, model_name in sorted(self.kept_model_keys):\n-            old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n-            old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, model_name]\n-            if (old_model_state.options.get(\"order_with_respect_to\") !=\n-                    new_model_state.options.get(\"order_with_respect_to\")):\n-                # Make sure it comes second if we're adding\n-                # (removal dependency is part of RemoveField)\n-                dependencies = []\n-                if new_model_state.options.get(\"order_with_respect_to\"):\n-                    dependencies.append((\n-                        app_label,\n-                        model_name,\n-                        new_model_state.options[\"order_with_respect_to\"],\n-                        True,\n-                    ))\n-                # Actually generate the operation\n-                self.add_operation(\n-                    app_label,\n-                    operations.AlterOrderWithRespectTo(\n-                        name=model_name,\n-                        order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n-                    ),\n+\n+    def _detect_changes(self):\n+        \"\"\"\n+        Return a dict of migration plans which will achieve the\n+        change from from_state to to_state. The dict has app labels\n+        as keys and a list of migrations as values.\n+\n+        The resulting migrations are all marked as replacing the old\n+        migration files they replace.\n+        \"\"\"\n+        # The first phase is generating all the operations for each app\n+        # and gathering them into a big per-app list.\n+        # Then go through that list, order things nicely, and split\n+        # into migrations to accommodate dependency stuff.\n+        self.generated_operations = {}\n+        self.altered_indexes = {}\n+        self.altered_constraints = {}\n+\n+        # Prepare some old/new state and model lists, separating\n+        # proxy models and ignoring unmigrated apps.\n+        self.old_apps = self.from_state.concrete_apps\n+        self.new_apps = self.to_state.concrete_apps\n+        self.old_model_keys = set()\n+        self.old_proxy_keys = set()\n+        self.old_unmanaged_keys = set()\n+        self.new_model_keys = set()\n+        self.new_proxy_keys = set()\n+        self.new_unmanaged_keys = set()\n+        for (app_label, model_name), model_state in self.from_state.models.items():\n+            if app_label not in self.old_apps:\n+                continue\n+            if model_state.options.get(\"proxy\"):\n+                self.old_proxy_keys.add((app_label, model_name))\n+            elif not model_state.options.get(\"managed\", True):\n+                self.old_unmanaged_keys.add((app_label, model_name))\n+            else:\n+                self.old_model_keys.add((app_label, model_name))\n+\n+        for (app_label, model_name), model_state in self.to_state.models.items():\n+            if app_label not in self.new_apps:\n+                continue\n+            if model_state.options.get(\"proxy\"):\n+                self.new_proxy_keys.add((app_label, model_name))\n+            elif not model_state.options.get(\"managed\", True):\n+                self.new_unmanaged_keys.add((app_label, model_name))\n+            else:\n+                self.new_model_keys.add((app_label, model_name))\n+\n+        self.kept_model_keys = self.old_model_keys & self.new_model_keys\n+        self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n+        self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n+\n+        # Generate the operations for each target app\n+        for app_label in sorted(self.new_apps.union(self.old_apps)):\n+            self.generated_operations[app_label] = []\n+            self.altered_indexes[app_label] = []\n+            self.altered_constraints[app_label] = []\n+\n+        # Generate non-rename model operations\n+        self.generate_deleted_models()\n+        self.generate_created_models()\n+        self.generate_deleted_proxies()\n+        self.generate_created_proxies()\n+        self.generate_altered_options()\n+        self.generate_altered_managers()\n+        # Create the altered indexes/constraints operations\n+        self.generate_removed_constraints()\n+        self.generate_removed_indexes()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        # Generate field operations\n+        self.generate_renamed_fields()\n+        self.generate_removed_fields()\n+        self.generate_added_fields()\n+        self.generate_altered_fields()\n+        self.generate_altered_unique_together()\n+        self.generate_altered_index_together()\n+        self.generate_altered_order_with_respect_to()\n+        self.generate_added_indexes()\n+        self.generate_added_constraints()\n+        self.generate_altered_db_table()\n+        self.generate_renamed_models()\n+\n+        self._sort_migrations()\n+        self._build_migration_list()\n+        self._optimize_migrations()\n+\n+        return self.migrations\n                     dependencies=dependencies,\n                 )\n \n"
  }
}