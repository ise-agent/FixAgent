{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/related.py lines 1210-1217)": "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/fields/related.py lines 1261-1262)": "\n        return warnings\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that symmetrical ManyToManyFields don't specify related_name.\n        \"\"\"\n        warnings = []\n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            warnings.append(\n                checks.Error(\n                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        return warnings\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/related.py lines 1180-1181)": "\n        if symmetrical is None:\n            symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n",
    "Location 4 (/root/hy/projects_4/django/django/db/models/fields/related.py lines 1188-1197)": "\n        kwargs['rel'] = self.rel_class(\n            self, to,\n            related_name=related_name,\n            related_query_name=related_query_name,\n            limit_choices_to=limit_choices_to,\n            symmetrical=symmetrical,\n            through=through,\n            through_fields=through_fields,\n            db_constraint=db_constraint,\n        )\n        \n        # Check for invalid related_name on symmetrical ManyToManyField\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify a related_name on a symmetrical ManyToManyField.\"\n            )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/related.py lines 1210-1217)": [
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n        ]\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/fields/related.py lines 1261-1262)": [
      "\n        return warnings\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified on symmetrical ManyToManyFields.\n        \"\"\"\n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            return [\n                checks.Error(\n                    \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\",\n                    hint=\"Either set symmetrical=False or remove the related_name argument.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            ]\n        return []\n\n",
      "\n        return warnings\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified on symmetrical ManyToManyFields.\n        \"\"\"\n        errors = []\n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            errors.append(\n                checks.Error(\n                    \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        return errors\n",
      "\n        return warnings\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that symmetrical ManyToManyFields don't specify a related_name.\n        \"\"\"\n        warnings = []\n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            warnings.append(\n                checks.Error(\n                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        return warnings\n",
      "\n    def _check_ignored_options(self, **kwargs):\n        warnings = []\n\n        if self.remote_field.limit_choices_to and self.remote_field.through and not self.remote_field.through._meta.auto_created:\n            warnings.append(\n                checks.Warning(\n                    'limit_choices_to has no effect on ManyToManyField '\n                    'with a through model.',\n                    obj=self,\n                    id='fields.W343',\n                )\n            )\n\n        return warnings\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that symmetrical ManyToManyFields don't specify related_name.\n        \"\"\"\n        errors = []\n        \n        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n            errors.append(\n                checks.Error(\n                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        \n        return errors\n",
      "\n        return warnings\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified on symmetrical ManyToManyFields.\n        \"\"\"\n        errors = []\n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            errors.append(\n                checks.Error(\n                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        return errors\n",
      "\n        return warnings\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified on symmetrical ManyToManyFields.\n        \"\"\"\n        errors = []\n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            errors.append(\n                checks.Error(\n                    \"Cannot specify related_name on a symmetrical ManyToManyField.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        return errors\n",
      "\n        return warnings\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified on symmetrical ManyToManyFields.\n        \"\"\"\n        errors = []\n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            errors.append(\n                checks.Error(\n                    \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        return errors\n",
      "\n        return warnings\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified on symmetrical ManyToManyFields.\n        \"\"\"\n        errors = []\n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            errors.append(\n                checks.Error(\n                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        return errors\n\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/related.py lines 1180-1181)": [
      "\n        if symmetrical is None:\n            symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n",
      "\n        if symmetrical is None:\n            symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n        \n        # Check for invalid related_name on symmetrical relationships\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\"\n            )\n",
      "\n        if symmetrical is None:\n            symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n",
      "\n        if symmetrical is None:\n            symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n        \n        # Check for invalid related_name on symmetrical relationships\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n            )\n",
      "\n        if symmetrical is None:\n            symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n",
      "\n        if symmetrical is None:\n            symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n\n        # Validate that related_name is not specified for symmetrical relationships\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\"\n            )\n",
      "\n        if symmetrical is None:\n            symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n        \n        # Check for invalid related_name on symmetrical relationships\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n            )\n",
      "\n        if symmetrical is None:\n            symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n\n        # Check for invalid related_name on symmetrical relationships\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n            )\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/db/models/fields/related.py lines 1188-1197)": [
      "\n        kwargs['rel'] = self.rel_class(\n            self, to,\n            related_name=related_name,\n            related_query_name=related_query_name,\n            limit_choices_to=limit_choices_to,\n            symmetrical=symmetrical,\n            through=through,\n            through_fields=through_fields,\n            db_constraint=db_constraint,\n        )\n        \n        # Validate that related_name is not specified on symmetrical relationships\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n            )\n",
      "\n        kwargs['rel'] = self.rel_class(\n            self, to,\n            related_name=related_name,\n            related_query_name=related_query_name,\n            limit_choices_to=limit_choices_to,\n            symmetrical=symmetrical,\n            through=through,\n            through_fields=through_fields,\n            db_constraint=db_constraint,\n        )\n",
      "\n        kwargs['rel'] = self.rel_class(\n            self, to,\n            related_name=related_name,\n            related_query_name=related_query_name,\n            limit_choices_to=limit_choices_to,\n            symmetrical=symmetrical,\n            through=through,\n            through_fields=through_fields,\n            db_constraint=db_constraint,\n        )\n        \n        # Check for invalid related_name on symmetrical ManyToManyField\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n            )\n",
      "\n        kwargs['rel'] = self.rel_class(\n            self, to,\n            related_name=related_name,\n            related_query_name=related_query_name,\n            limit_choices_to=limit_choices_to,\n            symmetrical=symmetrical,\n            through=through,\n            through_fields=through_fields,\n            db_constraint=db_constraint,\n        )\n",
      "\n        kwargs['rel'] = self.rel_class(\n            self, to,\n            related_name=related_name,\n            related_query_name=related_query_name,\n            limit_choices_to=limit_choices_to,\n            symmetrical=symmetrical,\n            through=through,\n            through_fields=through_fields,\n            db_constraint=db_constraint,\n        )\n        \n        # Check for invalid related_name on symmetrical ManyToManyField\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n            )\n",
      "\n        kwargs['rel'] = self.rel_class(\n            self, to,\n            related_name=related_name,\n            related_query_name=related_query_name,\n            limit_choices_to=limit_choices_to,\n            symmetrical=symmetrical,\n            through=through,\n            through_fields=through_fields,\n            db_constraint=db_constraint,\n        )\n",
      "\n        kwargs['rel'] = self.rel_class(\n            self, to,\n            related_name=related_name,\n            related_query_name=related_query_name,\n            limit_choices_to=limit_choices_to,\n            symmetrical=symmetrical,\n            through=through,\n            through_fields=through_fields,\n            db_constraint=db_constraint,\n        )\n        \n        # Validate that related_name is not specified on symmetrical ManyToManyFields\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\"\n            )\n",
      "\n        kwargs['rel'] = self.rel_class(\n            self, to,\n            related_name=related_name,\n            related_query_name=related_query_name,\n            limit_choices_to=limit_choices_to,\n            symmetrical=symmetrical,\n            through=through,\n            through_fields=through_fields,\n            db_constraint=db_constraint,\n        )\n        \n        # Check for invalid related_name on symmetrical ManyToManyField\n        if symmetrical and related_name is not None:\n            raise ValueError(\n                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n            )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..bfb1981034 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1177,6 +1177,7 @@ class ManyToManyField(RelatedField):\n                     )\n                 )\n \n+\n         if symmetrical is None:\n             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n \n@@ -1185,6 +1186,7 @@ class ManyToManyField(RelatedField):\n                 'Cannot specify a db_table if an intermediary model is used.'\n             )\n \n+\n         kwargs['rel'] = self.rel_class(\n             self, to,\n             related_name=related_name,\n@@ -1207,12 +1209,14 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_unique(**kwargs),\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n         ]\n \n@@ -1258,8 +1262,23 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+\n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified on symmetrical ManyToManyFields.\n+        \"\"\"\n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            return [\n+                checks.Error(\n+                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            ]\n+        return []\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n",
    "variant_0": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..e853f8a050 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1177,6 +1177,7 @@ class ManyToManyField(RelatedField):\n                     )\n                 )\n \n+\n         if symmetrical is None:\n             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n \n@@ -1185,6 +1186,7 @@ class ManyToManyField(RelatedField):\n                 'Cannot specify a db_table if an intermediary model is used.'\n             )\n \n+\n         kwargs['rel'] = self.rel_class(\n             self, to,\n             related_name=related_name,\n@@ -1195,6 +1197,12 @@ class ManyToManyField(RelatedField):\n             through_fields=through_fields,\n             db_constraint=db_constraint,\n         )\n+        \n+        # Check for invalid related_name on symmetrical ManyToManyField\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify a related_name on a symmetrical ManyToManyField.\"\n+            )\n         self.has_null_arg = 'null' in kwargs\n \n         super().__init__(\n@@ -1207,6 +1215,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1223,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1258,8 +1268,24 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+\n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that symmetrical ManyToManyFields don't specify related_name.\n+        \"\"\"\n+        warnings = []\n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            warnings.append(\n+                checks.Error(\n+                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        return warnings\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n",
    "variant_1": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..847d2cd7ce 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1177,6 +1177,7 @@ class ManyToManyField(RelatedField):\n                     )\n                 )\n \n+\n         if symmetrical is None:\n             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n \n@@ -1185,6 +1186,7 @@ class ManyToManyField(RelatedField):\n                 'Cannot specify a db_table if an intermediary model is used.'\n             )\n \n+\n         kwargs['rel'] = self.rel_class(\n             self, to,\n             related_name=related_name,\n@@ -1195,6 +1197,12 @@ class ManyToManyField(RelatedField):\n             through_fields=through_fields,\n             db_constraint=db_constraint,\n         )\n+        \n+        # Validate that related_name is not specified on symmetrical relationships\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n+            )\n         self.has_null_arg = 'null' in kwargs\n \n         super().__init__(\n@@ -1207,6 +1215,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1223,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1258,8 +1268,25 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+\n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified on symmetrical ManyToManyFields.\n+        \"\"\"\n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            return [\n+                checks.Error(\n+                    \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\",\n+                    hint=\"Either set symmetrical=False or remove the related_name argument.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            ]\n+        return []\n+\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n",
    "variant_2": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..d46e5910b8 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1177,14 +1177,22 @@ class ManyToManyField(RelatedField):\n                     )\n                 )\n \n+\n         if symmetrical is None:\n             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n+        \n+        # Check for invalid related_name on symmetrical relationships\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\"\n+            )\n \n         if through is not None and db_table is not None:\n             raise ValueError(\n                 'Cannot specify a db_table if an intermediary model is used.'\n             )\n \n+\n         kwargs['rel'] = self.rel_class(\n             self, to,\n             related_name=related_name,\n@@ -1207,6 +1215,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1223,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1258,8 +1268,24 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+\n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified on symmetrical ManyToManyFields.\n+        \"\"\"\n+        errors = []\n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            errors.append(\n+                checks.Error(\n+                    \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        return errors\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n",
    "variant_3": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..436f1b0ec3 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1177,6 +1177,7 @@ class ManyToManyField(RelatedField):\n                     )\n                 )\n \n+\n         if symmetrical is None:\n             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n \n@@ -1185,6 +1186,7 @@ class ManyToManyField(RelatedField):\n                 'Cannot specify a db_table if an intermediary model is used.'\n             )\n \n+\n         kwargs['rel'] = self.rel_class(\n             self, to,\n             related_name=related_name,\n@@ -1195,6 +1197,12 @@ class ManyToManyField(RelatedField):\n             through_fields=through_fields,\n             db_constraint=db_constraint,\n         )\n+        \n+        # Check for invalid related_name on symmetrical ManyToManyField\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n+            )\n         self.has_null_arg = 'null' in kwargs\n \n         super().__init__(\n@@ -1207,6 +1215,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1223,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1258,8 +1268,24 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+\n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that symmetrical ManyToManyFields don't specify a related_name.\n+        \"\"\"\n+        warnings = []\n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            warnings.append(\n+                checks.Error(\n+                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        return warnings\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n",
    "variant_4": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..b6d5fd09ee 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1177,14 +1177,22 @@ class ManyToManyField(RelatedField):\n                     )\n                 )\n \n+\n         if symmetrical is None:\n             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n+        \n+        # Check for invalid related_name on symmetrical relationships\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n+            )\n \n         if through is not None and db_table is not None:\n             raise ValueError(\n                 'Cannot specify a db_table if an intermediary model is used.'\n             )\n \n+\n         kwargs['rel'] = self.rel_class(\n             self, to,\n             related_name=related_name,\n@@ -1207,6 +1215,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1223,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1258,8 +1268,38 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+\n+    def _check_ignored_options(self, **kwargs):\n+        warnings = []\n+\n+        if self.remote_field.limit_choices_to and self.remote_field.through and not self.remote_field.through._meta.auto_created:\n+            warnings.append(\n+                checks.Warning(\n+                    'limit_choices_to has no effect on ManyToManyField '\n+                    'with a through model.',\n+                    obj=self,\n+                    id='fields.W343',\n+                )\n+            )\n+\n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that symmetrical ManyToManyFields don't specify related_name.\n+        \"\"\"\n+        errors = []\n+        \n+        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n+            errors.append(\n+                checks.Error(\n+                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        \n+        return errors\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n",
    "variant_5": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..a3bcd15719 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1177,6 +1177,7 @@ class ManyToManyField(RelatedField):\n                     )\n                 )\n \n+\n         if symmetrical is None:\n             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n \n@@ -1185,6 +1186,7 @@ class ManyToManyField(RelatedField):\n                 'Cannot specify a db_table if an intermediary model is used.'\n             )\n \n+\n         kwargs['rel'] = self.rel_class(\n             self, to,\n             related_name=related_name,\n@@ -1195,6 +1197,12 @@ class ManyToManyField(RelatedField):\n             through_fields=through_fields,\n             db_constraint=db_constraint,\n         )\n+        \n+        # Check for invalid related_name on symmetrical ManyToManyField\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n+            )\n         self.has_null_arg = 'null' in kwargs\n \n         super().__init__(\n@@ -1207,6 +1215,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1223,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1258,8 +1268,24 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+\n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified on symmetrical ManyToManyFields.\n+        \"\"\"\n+        errors = []\n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            errors.append(\n+                checks.Error(\n+                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        return errors\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n",
    "variant_6": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..8a4b995d88 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1177,14 +1177,22 @@ class ManyToManyField(RelatedField):\n                     )\n                 )\n \n+\n         if symmetrical is None:\n             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n \n+        # Validate that related_name is not specified for symmetrical relationships\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\"\n+            )\n+\n         if through is not None and db_table is not None:\n             raise ValueError(\n                 'Cannot specify a db_table if an intermediary model is used.'\n             )\n \n+\n         kwargs['rel'] = self.rel_class(\n             self, to,\n             related_name=related_name,\n@@ -1207,6 +1215,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1223,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1258,8 +1268,24 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+\n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified on symmetrical ManyToManyFields.\n+        \"\"\"\n+        errors = []\n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            errors.append(\n+                checks.Error(\n+                    \"Cannot specify related_name on a symmetrical ManyToManyField.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        return errors\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n",
    "variant_7": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..9f0f91b975 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1177,14 +1177,22 @@ class ManyToManyField(RelatedField):\n                     )\n                 )\n \n+\n         if symmetrical is None:\n             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n+        \n+        # Check for invalid related_name on symmetrical relationships\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n+            )\n \n         if through is not None and db_table is not None:\n             raise ValueError(\n                 'Cannot specify a db_table if an intermediary model is used.'\n             )\n \n+\n         kwargs['rel'] = self.rel_class(\n             self, to,\n             related_name=related_name,\n@@ -1195,6 +1203,12 @@ class ManyToManyField(RelatedField):\n             through_fields=through_fields,\n             db_constraint=db_constraint,\n         )\n+        \n+        # Validate that related_name is not specified on symmetrical ManyToManyFields\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\"\n+            )\n         self.has_null_arg = 'null' in kwargs\n \n         super().__init__(\n@@ -1207,6 +1221,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1229,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1258,8 +1274,24 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+\n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified on symmetrical ManyToManyFields.\n+        \"\"\"\n+        errors = []\n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            errors.append(\n+                checks.Error(\n+                    \"Cannot specify 'related_name' on a symmetrical ManyToManyField.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        return errors\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n",
    "variant_8": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..a7221160dc 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1177,14 +1177,22 @@ class ManyToManyField(RelatedField):\n                     )\n                 )\n \n+\n         if symmetrical is None:\n             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n \n+        # Check for invalid related_name on symmetrical relationships\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n+            )\n+\n         if through is not None and db_table is not None:\n             raise ValueError(\n                 'Cannot specify a db_table if an intermediary model is used.'\n             )\n \n+\n         kwargs['rel'] = self.rel_class(\n             self, to,\n             related_name=related_name,\n@@ -1195,6 +1203,12 @@ class ManyToManyField(RelatedField):\n             through_fields=through_fields,\n             db_constraint=db_constraint,\n         )\n+        \n+        # Check for invalid related_name on symmetrical ManyToManyField\n+        if symmetrical and related_name is not None:\n+            raise ValueError(\n+                \"Cannot specify related_name on a symmetrical ManyToManyField.\"\n+            )\n         self.has_null_arg = 'null' in kwargs\n \n         super().__init__(\n@@ -1207,12 +1221,14 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_unique(**kwargs),\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n         ]\n \n@@ -1258,8 +1274,25 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+\n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified on symmetrical ManyToManyFields.\n+        \"\"\"\n+        errors = []\n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            errors.append(\n+                checks.Error(\n+                    'Cannot specify related_name on a symmetrical ManyToManyField.',\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        return errors\n+\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n"
  }
}