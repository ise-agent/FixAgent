{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/pytest/src/_pytest/main.py lines 362-365)": "\n    def __missing__(self, path: py.path.local) -> str:\n        # Save current working directory\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.path))\n            r = self.path.bestrelpath(path)  # type: str\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n        self[path] = r\n        return r\n",
    "Location 2 (/root/hy/projects_4/pytest/src/_pytest/main.py lines 403-405)": "\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n",
    "Location 3 (/root/hy/projects_4/pytest/src/_pytest/nodes.py lines 598-607)": "\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])\n",
    "Location 4 (/root/hy/projects_4/pytest/src/_pytest/main.py lines 422-424)": "\ndef _node_location_to_relpath(self, node_path: py.path.local) -> str:\n    # bestrelpath is a quite slow function\n    # Save current working directory to ensure consistent path calculation\n    current_cwd = os.getcwd()\n    try:\n        # Temporarily change to the root directory for consistent path calculation\n        os.chdir(str(self.config.rootdir))\n        return self._bestrelpathcache[node_path]\n    finally:\n        # Restore the original working directory\n        os.chdir(current_cwd)\n",
    "Location 5 (/root/hy/projects_4/pytest/src/_pytest/nodes.py lines 390-408)": "\ndef __missing__(self, path: py.path.local) -> str:\n    # Save current working directory\n    current_cwd = os.getcwd()\n    try:\n        # Temporarily change to the root directory for consistent path calculation\n        os.chdir(str(self.path))\n        r = self.path.bestrelpath(path)  # type: str\n    finally:\n        # Restore the original working directory\n        os.chdir(current_cwd)\n    self[path] = r\n    return r\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/pytest/src/_pytest/main.py lines 362-365)": [
      "\n    def __missing__(self, path: py.path.local) -> str:\n        # Save current working directory\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.path))\n            r = self.path.bestrelpath(path)  # type: str\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n        self[path] = r\n        return r\n",
      "\n    def __missing__(self, path: py.path.local) -> str:\n        # Save current working directory\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.path))\n            r = self.path.bestrelpath(path)  # type: str\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n        self[path] = r\n        return r\n",
      "\n    def __missing__(self, path: py.path.local) -> str:\n        # Save current working directory\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.path))\n            r = self.path.bestrelpath(path)  # type: str\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n        self[path] = r\n        return r\n",
      "\n    def __missing__(self, path: py.path.local) -> str:\n        # Save current working directory\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.path))\n            r = self.path.bestrelpath(path)  # type: str\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n        self[path] = r\n        return r\n",
      "\n    def __missing__(self, path: py.path.local) -> str:\n        # Save current working directory\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.path))\n            r = self.path.bestrelpath(path)  # type: str\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n        self[path] = r\n        return r\n",
      "\n    def __missing__(self, path: py.path.local) -> str:\n        # Save current working directory\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.path))\n            r = self.path.bestrelpath(path)  # type: str\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n        self[path] = r\n        return r\n",
      "\n    def __missing__(self, path: py.path.local) -> str:\n        # Save current working directory\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.path))\n            r = self.path.bestrelpath(path)  # type: str\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n        self[path] = r\n        return r\n",
      "\n    def __missing__(self, path: py.path.local) -> str:\n        # Save current working directory\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.path))\n            r = self.path.bestrelpath(path)  # type: str\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n        self[path] = r\n        return r\n"
    ],
    "Location 2 (/root/hy/projects_4/pytest/src/_pytest/main.py lines 403-405)": [
      "\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n",
      "\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n",
      "\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n",
      "\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n",
      "\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n",
      "\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n",
      "\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n",
      "\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n"
    ],
    "Location 3 (/root/hy/projects_4/pytest/src/_pytest/nodes.py lines 598-607)": [
      "\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])\n",
      "\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])\n",
      "\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])\n",
      "\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])\n",
      "\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])\n",
      "\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])\n",
      "\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])\n",
      "\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])\n"
    ],
    "Location 4 (/root/hy/projects_4/pytest/src/_pytest/main.py lines 422-424)": [
      "\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        # Save current working directory to ensure consistent path calculation\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.config.rootdir))\n            return self._bestrelpathcache[node_path]\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n",
      "\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        # Save current working directory to ensure consistent path calculation\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.config.rootdir))\n            return self._bestrelpathcache[node_path]\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n",
      "\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        # Save current working directory to ensure consistent path calculation\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.config.rootdir))\n            return self._bestrelpathcache[node_path]\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n",
      "\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        # Save current working directory to ensure consistent path calculation\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.config.rootdir))\n            return self._bestrelpathcache[node_path]\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n",
      "\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        # Save current working directory to ensure consistent path calculation\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.config.rootdir))\n            return self._bestrelpathcache[node_path]\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n",
      "\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        # Save current working directory to ensure consistent path calculation\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.config.rootdir))\n            return self._bestrelpathcache[node_path]\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n",
      "\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        # Save current working directory to ensure consistent path calculation\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.config.rootdir))\n            return self._bestrelpathcache[node_path]\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n",
      "\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        # Save current working directory to ensure consistent path calculation\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.config.rootdir))\n            return self._bestrelpathcache[node_path]\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n"
    ],
    "Location 5 (/root/hy/projects_4/pytest/src/_pytest/nodes.py lines 390-408)": [
      "\ndef __missing__(self, path: py.path.local) -> str:\n    # Save current working directory\n    current_cwd = os.getcwd()\n    try:\n        # Temporarily change to the root directory for consistent path calculation\n        os.chdir(str(self.path))\n        r = self.path.bestrelpath(path)  # type: str\n    finally:\n        # Restore the original working directory\n        os.chdir(current_cwd)\n    self[path] = r\n    return r\n",
      "\ndef __missing__(self, path: py.path.local) -> str:\n    # Save current working directory\n    current_cwd = os.getcwd()\n    try:\n        # Temporarily change to the root directory for consistent path calculation\n        os.chdir(str(self.path))\n        r = self.path.bestrelpath(path)  # type: str\n    finally:\n        # Restore the original working directory\n        os.chdir(current_cwd)\n    self[path] = r\n    return r\n",
      "\n    def __missing__(self, path: py.path.local) -> str:\n        # Save current working directory\n        current_cwd = os.getcwd()\n        try:\n            # Temporarily change to the root directory for consistent path calculation\n            os.chdir(str(self.path))\n            r = self.path.bestrelpath(path)  # type: str\n        finally:\n            # Restore the original working directory\n            os.chdir(current_cwd)\n        self[path] = r\n        return r\n",
      "\ndef __missing__(self, path: py.path.local) -> str:\n    # Save current working directory\n    current_cwd = os.getcwd()\n    try:\n        # Temporarily change to the root directory for consistent path calculation\n        os.chdir(str(self.path))\n        r = self.path.bestrelpath(path)  # type: str\n    finally:\n        # Restore the original working directory\n        os.chdir(current_cwd)\n    self[path] = r\n    return r\n",
      "\ndef __missing__(self, path: py.path.local) -> str:\n    # Save current working directory\n    current_cwd = os.getcwd()\n    try:\n        # Temporarily change to the root directory for consistent path calculation\n        os.chdir(str(self.path))\n        r = self.path.bestrelpath(path)  # type: str\n    finally:\n        # Restore the original working directory\n        os.chdir(current_cwd)\n    self[path] = r\n    return r\n",
      "\ndef __missing__(self, path: py.path.local) -> str:\n    # Save current working directory\n    current_cwd = os.getcwd()\n    try:\n        # Temporarily change to the root directory for consistent path calculation\n        os.chdir(str(self.path))\n        r = self.path.bestrelpath(path)  # type: str\n    finally:\n        # Restore the original working directory\n        os.chdir(current_cwd)\n    self[path] = r\n    return r\n",
      "\ndef __missing__(self, path: py.path.local) -> str:\n    # Save current working directory\n    current_cwd = os.getcwd()\n    try:\n        # Temporarily change to the root directory for consistent path calculation\n        os.chdir(str(self.path))\n        r = self.path.bestrelpath(path)  # type: str\n    finally:\n        # Restore the original working directory\n        os.chdir(current_cwd)\n    self[path] = r\n    return r\n",
      "\ndef __missing__(self, path: py.path.local) -> str:\n    # Save current working directory\n    current_cwd = os.getcwd()\n    try:\n        # Temporarily change to the root directory for consistent path calculation\n        os.chdir(str(self.path))\n        r = self.path.bestrelpath(path)  # type: str\n    finally:\n        # Restore the original working directory\n        os.chdir(current_cwd)\n    self[path] = r\n    return r\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex de7e16744..6ec3b1fb9 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -359,8 +359,17 @@ class Failed(Exception):\n class _bestrelpath_cache(dict):\n     path = attr.ib(type=py.path.local)\n \n+\n     def __missing__(self, path: py.path.local) -> str:\n-        r = self.path.bestrelpath(path)  # type: str\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n         self[path] = r\n         return r\n \n@@ -400,6 +409,7 @@ class Session(nodes.FSCollector):\n         # Dirnames of pkgs with dunder-init files.\n         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n \n+\n         self._bestrelpathcache = _bestrelpath_cache(\n             config.rootdir\n         )  # type: Dict[py.path.local, str]\n@@ -419,6 +429,7 @@ class Session(nodes.FSCollector):\n             self.testscollected,\n         )\n \n+\n     def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n         # bestrelpath is a quite slow function\n         return self._bestrelpathcache[node_path]\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4a79bc861..891cb2f99 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -387,6 +387,7 @@ class Node(metaclass=NodeMeta):\n         return self._repr_failure_py(excinfo, style)\n \n \n+\n def get_fslocation_from_item(\n     item: \"Item\",\n ) -> Tuple[Union[str, py.path.local], Optional[int]]:\n@@ -595,6 +596,7 @@ class Item(Node):\n     def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n         return self.fspath, None, \"\"\n \n+\n     @cached_property\n     def location(self) -> Tuple[str, Optional[int], str]:\n         location = self.reportinfo()\n",
    "variant_0": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex de7e16744..789be993f 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -359,8 +359,17 @@ class Failed(Exception):\n class _bestrelpath_cache(dict):\n     path = attr.ib(type=py.path.local)\n \n+\n     def __missing__(self, path: py.path.local) -> str:\n-        r = self.path.bestrelpath(path)  # type: str\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n         self[path] = r\n         return r\n \n@@ -400,6 +409,7 @@ class Session(nodes.FSCollector):\n         # Dirnames of pkgs with dunder-init files.\n         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n \n+\n         self._bestrelpathcache = _bestrelpath_cache(\n             config.rootdir\n         )  # type: Dict[py.path.local, str]\n@@ -419,9 +429,18 @@ class Session(nodes.FSCollector):\n             self.testscollected,\n         )\n \n-    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n-        # bestrelpath is a quite slow function\n+\n+def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n+    # bestrelpath is a quite slow function\n+    # Save current working directory to ensure consistent path calculation\n+    current_cwd = os.getcwd()\n+    try:\n+        # Temporarily change to the root directory for consistent path calculation\n+        os.chdir(str(self.config.rootdir))\n         return self._bestrelpathcache[node_path]\n+    finally:\n+        # Restore the original working directory\n+        os.chdir(current_cwd)\n \n     @hookimpl(tryfirst=True)\n     def pytest_collectstart(self):\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4a79bc861..095d2b3e6 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -387,25 +387,19 @@ class Node(metaclass=NodeMeta):\n         return self._repr_failure_py(excinfo, style)\n \n \n-def get_fslocation_from_item(\n-    item: \"Item\",\n-) -> Tuple[Union[str, py.path.local], Optional[int]]:\n-    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n \n-    * \"fslocation\": a pair (path, lineno)\n-    * \"obj\": a Python object that the item wraps.\n-    * \"fspath\": just a path\n-\n-    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n-    \"\"\"\n+def __missing__(self, path: py.path.local) -> str:\n+    # Save current working directory\n+    current_cwd = os.getcwd()\n     try:\n-        return item.location[:2]\n-    except AttributeError:\n-        pass\n-    obj = getattr(item, \"obj\", None)\n-    if obj is not None:\n-        return getfslineno(obj)\n-    return getattr(item, \"fspath\", \"unknown location\"), -1\n+        # Temporarily change to the root directory for consistent path calculation\n+        os.chdir(str(self.path))\n+        r = self.path.bestrelpath(path)  # type: str\n+    finally:\n+        # Restore the original working directory\n+        os.chdir(current_cwd)\n+    self[path] = r\n+    return r\n \n \n class Collector(Node):\n@@ -595,6 +589,7 @@ class Item(Node):\n     def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n         return self.fspath, None, \"\"\n \n+\n     @cached_property\n     def location(self) -> Tuple[str, Optional[int], str]:\n         location = self.reportinfo()\n",
    "variant_1": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex de7e16744..345cc881a 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -359,8 +359,17 @@ class Failed(Exception):\n class _bestrelpath_cache(dict):\n     path = attr.ib(type=py.path.local)\n \n+\n     def __missing__(self, path: py.path.local) -> str:\n-        r = self.path.bestrelpath(path)  # type: str\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n         self[path] = r\n         return r\n \n@@ -400,6 +409,7 @@ class Session(nodes.FSCollector):\n         # Dirnames of pkgs with dunder-init files.\n         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n \n+\n         self._bestrelpathcache = _bestrelpath_cache(\n             config.rootdir\n         )  # type: Dict[py.path.local, str]\n@@ -419,9 +429,18 @@ class Session(nodes.FSCollector):\n             self.testscollected,\n         )\n \n+\n     def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n         # bestrelpath is a quite slow function\n-        return self._bestrelpathcache[node_path]\n+        # Save current working directory to ensure consistent path calculation\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.config.rootdir))\n+            return self._bestrelpathcache[node_path]\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n \n     @hookimpl(tryfirst=True)\n     def pytest_collectstart(self):\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4a79bc861..095d2b3e6 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -387,25 +387,19 @@ class Node(metaclass=NodeMeta):\n         return self._repr_failure_py(excinfo, style)\n \n \n-def get_fslocation_from_item(\n-    item: \"Item\",\n-) -> Tuple[Union[str, py.path.local], Optional[int]]:\n-    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n \n-    * \"fslocation\": a pair (path, lineno)\n-    * \"obj\": a Python object that the item wraps.\n-    * \"fspath\": just a path\n-\n-    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n-    \"\"\"\n+def __missing__(self, path: py.path.local) -> str:\n+    # Save current working directory\n+    current_cwd = os.getcwd()\n     try:\n-        return item.location[:2]\n-    except AttributeError:\n-        pass\n-    obj = getattr(item, \"obj\", None)\n-    if obj is not None:\n-        return getfslineno(obj)\n-    return getattr(item, \"fspath\", \"unknown location\"), -1\n+        # Temporarily change to the root directory for consistent path calculation\n+        os.chdir(str(self.path))\n+        r = self.path.bestrelpath(path)  # type: str\n+    finally:\n+        # Restore the original working directory\n+        os.chdir(current_cwd)\n+    self[path] = r\n+    return r\n \n \n class Collector(Node):\n@@ -595,6 +589,7 @@ class Item(Node):\n     def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n         return self.fspath, None, \"\"\n \n+\n     @cached_property\n     def location(self) -> Tuple[str, Optional[int], str]:\n         location = self.reportinfo()\n",
    "variant_2": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex de7e16744..345cc881a 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -359,8 +359,17 @@ class Failed(Exception):\n class _bestrelpath_cache(dict):\n     path = attr.ib(type=py.path.local)\n \n+\n     def __missing__(self, path: py.path.local) -> str:\n-        r = self.path.bestrelpath(path)  # type: str\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n         self[path] = r\n         return r\n \n@@ -400,6 +409,7 @@ class Session(nodes.FSCollector):\n         # Dirnames of pkgs with dunder-init files.\n         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n \n+\n         self._bestrelpathcache = _bestrelpath_cache(\n             config.rootdir\n         )  # type: Dict[py.path.local, str]\n@@ -419,9 +429,18 @@ class Session(nodes.FSCollector):\n             self.testscollected,\n         )\n \n+\n     def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n         # bestrelpath is a quite slow function\n-        return self._bestrelpathcache[node_path]\n+        # Save current working directory to ensure consistent path calculation\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.config.rootdir))\n+            return self._bestrelpathcache[node_path]\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n \n     @hookimpl(tryfirst=True)\n     def pytest_collectstart(self):\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4a79bc861..095d2b3e6 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -387,25 +387,19 @@ class Node(metaclass=NodeMeta):\n         return self._repr_failure_py(excinfo, style)\n \n \n-def get_fslocation_from_item(\n-    item: \"Item\",\n-) -> Tuple[Union[str, py.path.local], Optional[int]]:\n-    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n \n-    * \"fslocation\": a pair (path, lineno)\n-    * \"obj\": a Python object that the item wraps.\n-    * \"fspath\": just a path\n-\n-    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n-    \"\"\"\n+def __missing__(self, path: py.path.local) -> str:\n+    # Save current working directory\n+    current_cwd = os.getcwd()\n     try:\n-        return item.location[:2]\n-    except AttributeError:\n-        pass\n-    obj = getattr(item, \"obj\", None)\n-    if obj is not None:\n-        return getfslineno(obj)\n-    return getattr(item, \"fspath\", \"unknown location\"), -1\n+        # Temporarily change to the root directory for consistent path calculation\n+        os.chdir(str(self.path))\n+        r = self.path.bestrelpath(path)  # type: str\n+    finally:\n+        # Restore the original working directory\n+        os.chdir(current_cwd)\n+    self[path] = r\n+    return r\n \n \n class Collector(Node):\n@@ -595,6 +589,7 @@ class Item(Node):\n     def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n         return self.fspath, None, \"\"\n \n+\n     @cached_property\n     def location(self) -> Tuple[str, Optional[int], str]:\n         location = self.reportinfo()\n",
    "variant_3": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex de7e16744..345cc881a 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -359,8 +359,17 @@ class Failed(Exception):\n class _bestrelpath_cache(dict):\n     path = attr.ib(type=py.path.local)\n \n+\n     def __missing__(self, path: py.path.local) -> str:\n-        r = self.path.bestrelpath(path)  # type: str\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n         self[path] = r\n         return r\n \n@@ -400,6 +409,7 @@ class Session(nodes.FSCollector):\n         # Dirnames of pkgs with dunder-init files.\n         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n \n+\n         self._bestrelpathcache = _bestrelpath_cache(\n             config.rootdir\n         )  # type: Dict[py.path.local, str]\n@@ -419,9 +429,18 @@ class Session(nodes.FSCollector):\n             self.testscollected,\n         )\n \n+\n     def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n         # bestrelpath is a quite slow function\n-        return self._bestrelpathcache[node_path]\n+        # Save current working directory to ensure consistent path calculation\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.config.rootdir))\n+            return self._bestrelpathcache[node_path]\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n \n     @hookimpl(tryfirst=True)\n     def pytest_collectstart(self):\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4a79bc861..bb6a41a9f 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -387,25 +387,19 @@ class Node(metaclass=NodeMeta):\n         return self._repr_failure_py(excinfo, style)\n \n \n-def get_fslocation_from_item(\n-    item: \"Item\",\n-) -> Tuple[Union[str, py.path.local], Optional[int]]:\n-    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n \n-    * \"fslocation\": a pair (path, lineno)\n-    * \"obj\": a Python object that the item wraps.\n-    * \"fspath\": just a path\n-\n-    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n-    \"\"\"\n-    try:\n-        return item.location[:2]\n-    except AttributeError:\n-        pass\n-    obj = getattr(item, \"obj\", None)\n-    if obj is not None:\n-        return getfslineno(obj)\n-    return getattr(item, \"fspath\", \"unknown location\"), -1\n+    def __missing__(self, path: py.path.local) -> str:\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n+        self[path] = r\n+        return r\n \n \n class Collector(Node):\n@@ -595,6 +589,7 @@ class Item(Node):\n     def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n         return self.fspath, None, \"\"\n \n+\n     @cached_property\n     def location(self) -> Tuple[str, Optional[int], str]:\n         location = self.reportinfo()\n",
    "variant_4": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex de7e16744..345cc881a 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -359,8 +359,17 @@ class Failed(Exception):\n class _bestrelpath_cache(dict):\n     path = attr.ib(type=py.path.local)\n \n+\n     def __missing__(self, path: py.path.local) -> str:\n-        r = self.path.bestrelpath(path)  # type: str\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n         self[path] = r\n         return r\n \n@@ -400,6 +409,7 @@ class Session(nodes.FSCollector):\n         # Dirnames of pkgs with dunder-init files.\n         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n \n+\n         self._bestrelpathcache = _bestrelpath_cache(\n             config.rootdir\n         )  # type: Dict[py.path.local, str]\n@@ -419,9 +429,18 @@ class Session(nodes.FSCollector):\n             self.testscollected,\n         )\n \n+\n     def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n         # bestrelpath is a quite slow function\n-        return self._bestrelpathcache[node_path]\n+        # Save current working directory to ensure consistent path calculation\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.config.rootdir))\n+            return self._bestrelpathcache[node_path]\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n \n     @hookimpl(tryfirst=True)\n     def pytest_collectstart(self):\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4a79bc861..095d2b3e6 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -387,25 +387,19 @@ class Node(metaclass=NodeMeta):\n         return self._repr_failure_py(excinfo, style)\n \n \n-def get_fslocation_from_item(\n-    item: \"Item\",\n-) -> Tuple[Union[str, py.path.local], Optional[int]]:\n-    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n \n-    * \"fslocation\": a pair (path, lineno)\n-    * \"obj\": a Python object that the item wraps.\n-    * \"fspath\": just a path\n-\n-    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n-    \"\"\"\n+def __missing__(self, path: py.path.local) -> str:\n+    # Save current working directory\n+    current_cwd = os.getcwd()\n     try:\n-        return item.location[:2]\n-    except AttributeError:\n-        pass\n-    obj = getattr(item, \"obj\", None)\n-    if obj is not None:\n-        return getfslineno(obj)\n-    return getattr(item, \"fspath\", \"unknown location\"), -1\n+        # Temporarily change to the root directory for consistent path calculation\n+        os.chdir(str(self.path))\n+        r = self.path.bestrelpath(path)  # type: str\n+    finally:\n+        # Restore the original working directory\n+        os.chdir(current_cwd)\n+    self[path] = r\n+    return r\n \n \n class Collector(Node):\n@@ -595,6 +589,7 @@ class Item(Node):\n     def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n         return self.fspath, None, \"\"\n \n+\n     @cached_property\n     def location(self) -> Tuple[str, Optional[int], str]:\n         location = self.reportinfo()\n",
    "variant_5": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex de7e16744..345cc881a 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -359,8 +359,17 @@ class Failed(Exception):\n class _bestrelpath_cache(dict):\n     path = attr.ib(type=py.path.local)\n \n+\n     def __missing__(self, path: py.path.local) -> str:\n-        r = self.path.bestrelpath(path)  # type: str\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n         self[path] = r\n         return r\n \n@@ -400,6 +409,7 @@ class Session(nodes.FSCollector):\n         # Dirnames of pkgs with dunder-init files.\n         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n \n+\n         self._bestrelpathcache = _bestrelpath_cache(\n             config.rootdir\n         )  # type: Dict[py.path.local, str]\n@@ -419,9 +429,18 @@ class Session(nodes.FSCollector):\n             self.testscollected,\n         )\n \n+\n     def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n         # bestrelpath is a quite slow function\n-        return self._bestrelpathcache[node_path]\n+        # Save current working directory to ensure consistent path calculation\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.config.rootdir))\n+            return self._bestrelpathcache[node_path]\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n \n     @hookimpl(tryfirst=True)\n     def pytest_collectstart(self):\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4a79bc861..095d2b3e6 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -387,25 +387,19 @@ class Node(metaclass=NodeMeta):\n         return self._repr_failure_py(excinfo, style)\n \n \n-def get_fslocation_from_item(\n-    item: \"Item\",\n-) -> Tuple[Union[str, py.path.local], Optional[int]]:\n-    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n \n-    * \"fslocation\": a pair (path, lineno)\n-    * \"obj\": a Python object that the item wraps.\n-    * \"fspath\": just a path\n-\n-    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n-    \"\"\"\n+def __missing__(self, path: py.path.local) -> str:\n+    # Save current working directory\n+    current_cwd = os.getcwd()\n     try:\n-        return item.location[:2]\n-    except AttributeError:\n-        pass\n-    obj = getattr(item, \"obj\", None)\n-    if obj is not None:\n-        return getfslineno(obj)\n-    return getattr(item, \"fspath\", \"unknown location\"), -1\n+        # Temporarily change to the root directory for consistent path calculation\n+        os.chdir(str(self.path))\n+        r = self.path.bestrelpath(path)  # type: str\n+    finally:\n+        # Restore the original working directory\n+        os.chdir(current_cwd)\n+    self[path] = r\n+    return r\n \n \n class Collector(Node):\n@@ -595,6 +589,7 @@ class Item(Node):\n     def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n         return self.fspath, None, \"\"\n \n+\n     @cached_property\n     def location(self) -> Tuple[str, Optional[int], str]:\n         location = self.reportinfo()\n",
    "variant_6": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex de7e16744..345cc881a 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -359,8 +359,17 @@ class Failed(Exception):\n class _bestrelpath_cache(dict):\n     path = attr.ib(type=py.path.local)\n \n+\n     def __missing__(self, path: py.path.local) -> str:\n-        r = self.path.bestrelpath(path)  # type: str\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n         self[path] = r\n         return r\n \n@@ -400,6 +409,7 @@ class Session(nodes.FSCollector):\n         # Dirnames of pkgs with dunder-init files.\n         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n \n+\n         self._bestrelpathcache = _bestrelpath_cache(\n             config.rootdir\n         )  # type: Dict[py.path.local, str]\n@@ -419,9 +429,18 @@ class Session(nodes.FSCollector):\n             self.testscollected,\n         )\n \n+\n     def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n         # bestrelpath is a quite slow function\n-        return self._bestrelpathcache[node_path]\n+        # Save current working directory to ensure consistent path calculation\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.config.rootdir))\n+            return self._bestrelpathcache[node_path]\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n \n     @hookimpl(tryfirst=True)\n     def pytest_collectstart(self):\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4a79bc861..095d2b3e6 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -387,25 +387,19 @@ class Node(metaclass=NodeMeta):\n         return self._repr_failure_py(excinfo, style)\n \n \n-def get_fslocation_from_item(\n-    item: \"Item\",\n-) -> Tuple[Union[str, py.path.local], Optional[int]]:\n-    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n \n-    * \"fslocation\": a pair (path, lineno)\n-    * \"obj\": a Python object that the item wraps.\n-    * \"fspath\": just a path\n-\n-    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n-    \"\"\"\n+def __missing__(self, path: py.path.local) -> str:\n+    # Save current working directory\n+    current_cwd = os.getcwd()\n     try:\n-        return item.location[:2]\n-    except AttributeError:\n-        pass\n-    obj = getattr(item, \"obj\", None)\n-    if obj is not None:\n-        return getfslineno(obj)\n-    return getattr(item, \"fspath\", \"unknown location\"), -1\n+        # Temporarily change to the root directory for consistent path calculation\n+        os.chdir(str(self.path))\n+        r = self.path.bestrelpath(path)  # type: str\n+    finally:\n+        # Restore the original working directory\n+        os.chdir(current_cwd)\n+    self[path] = r\n+    return r\n \n \n class Collector(Node):\n@@ -595,6 +589,7 @@ class Item(Node):\n     def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n         return self.fspath, None, \"\"\n \n+\n     @cached_property\n     def location(self) -> Tuple[str, Optional[int], str]:\n         location = self.reportinfo()\n",
    "variant_7": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex de7e16744..345cc881a 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -359,8 +359,17 @@ class Failed(Exception):\n class _bestrelpath_cache(dict):\n     path = attr.ib(type=py.path.local)\n \n+\n     def __missing__(self, path: py.path.local) -> str:\n-        r = self.path.bestrelpath(path)  # type: str\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n         self[path] = r\n         return r\n \n@@ -400,6 +409,7 @@ class Session(nodes.FSCollector):\n         # Dirnames of pkgs with dunder-init files.\n         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n \n+\n         self._bestrelpathcache = _bestrelpath_cache(\n             config.rootdir\n         )  # type: Dict[py.path.local, str]\n@@ -419,9 +429,18 @@ class Session(nodes.FSCollector):\n             self.testscollected,\n         )\n \n+\n     def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n         # bestrelpath is a quite slow function\n-        return self._bestrelpathcache[node_path]\n+        # Save current working directory to ensure consistent path calculation\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.config.rootdir))\n+            return self._bestrelpathcache[node_path]\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n \n     @hookimpl(tryfirst=True)\n     def pytest_collectstart(self):\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4a79bc861..095d2b3e6 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -387,25 +387,19 @@ class Node(metaclass=NodeMeta):\n         return self._repr_failure_py(excinfo, style)\n \n \n-def get_fslocation_from_item(\n-    item: \"Item\",\n-) -> Tuple[Union[str, py.path.local], Optional[int]]:\n-    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n \n-    * \"fslocation\": a pair (path, lineno)\n-    * \"obj\": a Python object that the item wraps.\n-    * \"fspath\": just a path\n-\n-    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n-    \"\"\"\n+def __missing__(self, path: py.path.local) -> str:\n+    # Save current working directory\n+    current_cwd = os.getcwd()\n     try:\n-        return item.location[:2]\n-    except AttributeError:\n-        pass\n-    obj = getattr(item, \"obj\", None)\n-    if obj is not None:\n-        return getfslineno(obj)\n-    return getattr(item, \"fspath\", \"unknown location\"), -1\n+        # Temporarily change to the root directory for consistent path calculation\n+        os.chdir(str(self.path))\n+        r = self.path.bestrelpath(path)  # type: str\n+    finally:\n+        # Restore the original working directory\n+        os.chdir(current_cwd)\n+    self[path] = r\n+    return r\n \n \n class Collector(Node):\n@@ -595,6 +589,7 @@ class Item(Node):\n     def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n         return self.fspath, None, \"\"\n \n+\n     @cached_property\n     def location(self) -> Tuple[str, Optional[int], str]:\n         location = self.reportinfo()\n",
    "variant_8": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex de7e16744..345cc881a 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -359,8 +359,17 @@ class Failed(Exception):\n class _bestrelpath_cache(dict):\n     path = attr.ib(type=py.path.local)\n \n+\n     def __missing__(self, path: py.path.local) -> str:\n-        r = self.path.bestrelpath(path)  # type: str\n+        # Save current working directory\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.path))\n+            r = self.path.bestrelpath(path)  # type: str\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n         self[path] = r\n         return r\n \n@@ -400,6 +409,7 @@ class Session(nodes.FSCollector):\n         # Dirnames of pkgs with dunder-init files.\n         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n \n+\n         self._bestrelpathcache = _bestrelpath_cache(\n             config.rootdir\n         )  # type: Dict[py.path.local, str]\n@@ -419,9 +429,18 @@ class Session(nodes.FSCollector):\n             self.testscollected,\n         )\n \n+\n     def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n         # bestrelpath is a quite slow function\n-        return self._bestrelpathcache[node_path]\n+        # Save current working directory to ensure consistent path calculation\n+        current_cwd = os.getcwd()\n+        try:\n+            # Temporarily change to the root directory for consistent path calculation\n+            os.chdir(str(self.config.rootdir))\n+            return self._bestrelpathcache[node_path]\n+        finally:\n+            # Restore the original working directory\n+            os.chdir(current_cwd)\n \n     @hookimpl(tryfirst=True)\n     def pytest_collectstart(self):\ndiff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py\nindex 4a79bc861..095d2b3e6 100644\n--- a/src/_pytest/nodes.py\n+++ b/src/_pytest/nodes.py\n@@ -387,25 +387,19 @@ class Node(metaclass=NodeMeta):\n         return self._repr_failure_py(excinfo, style)\n \n \n-def get_fslocation_from_item(\n-    item: \"Item\",\n-) -> Tuple[Union[str, py.path.local], Optional[int]]:\n-    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n \n-    * \"fslocation\": a pair (path, lineno)\n-    * \"obj\": a Python object that the item wraps.\n-    * \"fspath\": just a path\n-\n-    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n-    \"\"\"\n+def __missing__(self, path: py.path.local) -> str:\n+    # Save current working directory\n+    current_cwd = os.getcwd()\n     try:\n-        return item.location[:2]\n-    except AttributeError:\n-        pass\n-    obj = getattr(item, \"obj\", None)\n-    if obj is not None:\n-        return getfslineno(obj)\n-    return getattr(item, \"fspath\", \"unknown location\"), -1\n+        # Temporarily change to the root directory for consistent path calculation\n+        os.chdir(str(self.path))\n+        r = self.path.bestrelpath(path)  # type: str\n+    finally:\n+        # Restore the original working directory\n+        os.chdir(current_cwd)\n+    self[path] = r\n+    return r\n \n \n class Collector(Node):\n@@ -595,6 +589,7 @@ class Item(Node):\n     def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n         return self.fspath, None, \"\"\n \n+\n     @cached_property\n     def location(self) -> Tuple[str, Optional[int], str]:\n         location = self.reportinfo()\n"
  }
}