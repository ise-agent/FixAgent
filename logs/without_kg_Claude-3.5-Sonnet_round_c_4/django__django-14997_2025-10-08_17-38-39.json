{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/backends/sqlite3/schema.py lines 422-428)": "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.include or\n            constraint.deferrable\n        ) and not constraint.contains_expressions:\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n",
    "Location 2 (/root/hy/projects_4/django/django/db/backends/base/schema.py lines 1271-1278)": "\n        if condition or include or opclasses:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            columns = Expressions(table, expressions, compiler, self.quote_value)\n",
    "Location 3 (/root/hy/projects_4/django/django/db/backends/ddl_references.py lines 204-210)": "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        # Handle expressions that might be strings or expression objects\n        if hasattr(expressions, '__iter__') and not isinstance(expressions, str):\n            columns = [col.target.column for col in self.compiler.query._gen_cols([expressions])]\n        else:\n            columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n",
    "Location 4 (/root/hy/projects_4/django/django/db/models/constraints.py lines 198-207)": "\n    def create_sql(self, model, schema_editor):\n        fields = [model._meta.get_field(field_name) for field_name in self.fields]\n        include = [model._meta.get_field(field_name).column for field_name in self.include]\n        condition = self._get_condition_sql(model, schema_editor)\n        expressions = self._get_index_expressions(model, schema_editor)\n        return schema_editor._create_unique_sql(\n            model, fields, self.name, condition=condition,\n            deferrable=self.deferrable, include=include,\n            opclasses=self.opclasses, expressions=expressions,\n        )\n",
    "Location 5 (/root/hy/projects_4/django/django/db/backends/base/schema.py lines 401-407)": "\n    def add_constraint(self, model, constraint):\n        \"\"\"Add a constraint to a model.\"\"\"\n        sql = constraint.create_sql(model, self)\n        if sql:\n            # Constraint.create_sql returns interpolated SQL which makes\n            # params=None a necessity to avoid escaping attempts on execution.\n            self.execute(sql, params=None)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/backends/sqlite3/schema.py lines 422-428)": [
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.include or\n            constraint.deferrable\n        ) and not constraint.contains_expressions:\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.include or\n            constraint.deferrable\n        ) and not constraint.contains_expressions:\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.include or\n            constraint.deferrable\n        ) and not constraint.contains_expressions:\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.include or\n            constraint.deferrable\n        ) and not constraint.contains_expressions:\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.include or\n            constraint.deferrable\n        ) and not constraint.contains_expressions:\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.include or\n            constraint.deferrable\n        ) and not constraint.contains_expressions:\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.include or\n            constraint.deferrable\n        ) and not constraint.contains_expressions:\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.include or\n            constraint.deferrable\n        ) and not constraint.contains_expressions:\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/backends/base/schema.py lines 1271-1278)": [
      "\n        if condition or include or opclasses:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            columns = Expressions(table, expressions, compiler, self.quote_value)\n",
      "\n        if condition or include or opclasses:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            columns = Expressions(table, expressions, compiler, self.quote_value)\n",
      "\n        if condition or include or opclasses:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            columns = Expressions(table, expressions, compiler, self.quote_value)\n",
      "\n        if condition or include or opclasses:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            columns = Expressions(table, expressions, compiler, self.quote_value)\n",
      "\n        if condition or include or opclasses:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            columns = Expressions(table, expressions, compiler, self.quote_value)\n",
      "\n        if condition or include or opclasses:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            columns = Expressions(table, expressions, compiler, self.quote_value)\n",
      "\n        if condition or include or opclasses:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            columns = Expressions(table, expressions, compiler, self.quote_value)\n",
      "\n        if condition or include or opclasses:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            columns = Expressions(table, expressions, compiler, self.quote_value)\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/backends/ddl_references.py lines 204-210)": [
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        # Handle expressions list properly - it may contain a single expression or multiple\n        expr_list = expressions if isinstance(expressions, list) else [expressions]\n        columns = [col.target.column for col in self.compiler.query._gen_cols(expr_list)]\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        # Handle expressions that might not have target.column attribute\n        columns = []\n        for col in self.compiler.query._gen_cols([self.expressions]):\n            if hasattr(col, 'target') and hasattr(col.target, 'column'):\n                columns.append(col.target.column)\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        # Handle expressions that might not have target.column attributes\n        columns = []\n        try:\n            for col in self.compiler.query._gen_cols([self.expressions]):\n                if hasattr(col, 'target') and hasattr(col.target, 'column'):\n                    columns.append(col.target.column)\n        except (AttributeError, TypeError):\n            # Fallback for expressions that don't have standard column structure\n            columns = []\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        # Handle expressions list properly - extract from nested structure if needed\n        expr_list = expressions if isinstance(expressions, list) else [expressions]\n        columns = [col.target.column for col in self.compiler.query._gen_cols(expr_list)]\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        # Extract columns without generating table.column notation for SQLite compatibility\n        columns = []\n        for col in self.compiler.query._gen_cols([self.expressions]):\n            if hasattr(col.target, 'column'):\n                columns.append(col.target.column)\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        # Handle expressions that may not have column targets\n        columns = []\n        try:\n            for col in self.compiler.query._gen_cols([self.expressions]):\n                if hasattr(col, 'target') and hasattr(col.target, 'column'):\n                    columns.append(col.target.column)\n        except (AttributeError, TypeError):\n            # Fallback for expressions without proper column targets\n            pass\n        super().__init__(table, columns)\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        # Handle expressions that might be tuples or single expressions\n        if isinstance(expressions, (list, tuple)):\n            expr_list = list(expressions)\n        else:\n            expr_list = [expressions]\n        columns = [col.target.column for col in self.compiler.query._gen_cols([expr_list])]\n        super().__init__(table, columns)\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/db/models/constraints.py lines 198-207)": [
      "\n    def create_sql(self, model, schema_editor):\n        fields = [model._meta.get_field(field_name) for field_name in self.fields]\n        include = [model._meta.get_field(field_name).column for field_name in self.include]\n        condition = self._get_condition_sql(model, schema_editor)\n        expressions = self._get_index_expressions(model, schema_editor)\n        return schema_editor._create_unique_sql(\n            model, fields, self.name, condition=condition,\n            deferrable=self.deferrable, include=include,\n            opclasses=self.opclasses, expressions=expressions,\n        )\n",
      "\n    def create_sql(self, model, schema_editor):\n        fields = [model._meta.get_field(field_name) for field_name in self.fields]\n        include = [model._meta.get_field(field_name).column for field_name in self.include]\n        condition = self._get_condition_sql(model, schema_editor)\n        expressions = self._get_index_expressions(model, schema_editor)\n        return schema_editor._create_unique_sql(\n            model, fields, self.name, condition=condition,\n            deferrable=self.deferrable, include=include,\n            opclasses=self.opclasses, expressions=expressions,\n        )\n",
      "\n    def create_sql(self, model, schema_editor):\n        fields = [model._meta.get_field(field_name) for field_name in self.fields]\n        include = [model._meta.get_field(field_name).column for field_name in self.include]\n        condition = self._get_condition_sql(model, schema_editor)\n        expressions = self._get_index_expressions(model, schema_editor)\n        return schema_editor._create_unique_sql(\n            model, fields, self.name, condition=condition,\n            deferrable=self.deferrable, include=include,\n            opclasses=self.opclasses, expressions=expressions,\n        )\n",
      "\n    def create_sql(self, model, schema_editor):\n        fields = [model._meta.get_field(field_name) for field_name in self.fields]\n        include = [model._meta.get_field(field_name).column for field_name in self.include]\n        condition = self._get_condition_sql(model, schema_editor)\n        expressions = self._get_index_expressions(model, schema_editor)\n        return schema_editor._create_unique_sql(\n            model, fields, self.name, condition=condition,\n            deferrable=self.deferrable, include=include,\n            opclasses=self.opclasses, expressions=expressions,\n        )\n",
      "\n    def create_sql(self, model, schema_editor):\n        fields = [model._meta.get_field(field_name) for field_name in self.fields]\n        include = [model._meta.get_field(field_name).column for field_name in self.include]\n        condition = self._get_condition_sql(model, schema_editor)\n        expressions = self._get_index_expressions(model, schema_editor)\n        return schema_editor._create_unique_sql(\n            model, fields, self.name, condition=condition,\n            deferrable=self.deferrable, include=include,\n            opclasses=self.opclasses, expressions=expressions,\n        )\n",
      "\n    def create_sql(self, model, schema_editor):\n        fields = [model._meta.get_field(field_name) for field_name in self.fields]\n        include = [model._meta.get_field(field_name).column for field_name in self.include]\n        condition = self._get_condition_sql(model, schema_editor)\n        expressions = self._get_index_expressions(model, schema_editor)\n        return schema_editor._create_unique_sql(\n            model, fields, self.name, condition=condition,\n            deferrable=self.deferrable, include=include,\n            opclasses=self.opclasses, expressions=expressions,\n        )\n",
      "\n    def create_sql(self, model, schema_editor):\n        fields = [model._meta.get_field(field_name) for field_name in self.fields]\n        include = [model._meta.get_field(field_name).column for field_name in self.include]\n        condition = self._get_condition_sql(model, schema_editor)\n        expressions = self._get_index_expressions(model, schema_editor)\n        return schema_editor._create_unique_sql(\n            model, fields, self.name, condition=condition,\n            deferrable=self.deferrable, include=include,\n            opclasses=self.opclasses, expressions=expressions,\n        )\n",
      "\n    def create_sql(self, model, schema_editor):\n        fields = [model._meta.get_field(field_name) for field_name in self.fields]\n        include = [model._meta.get_field(field_name).column for field_name in self.include]\n        condition = self._get_condition_sql(model, schema_editor)\n        expressions = self._get_index_expressions(model, schema_editor)\n        return schema_editor._create_unique_sql(\n            model, fields, self.name, condition=condition,\n            deferrable=self.deferrable, include=include,\n            opclasses=self.opclasses, expressions=expressions,\n        )\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/db/backends/base/schema.py lines 401-407)": [
      "\n    def add_constraint(self, model, constraint):\n        \"\"\"Add a constraint to a model.\"\"\"\n        sql = constraint.create_sql(model, self)\n        if sql:\n            # Constraint.create_sql returns interpolated SQL which makes\n            # params=None a necessity to avoid escaping attempts on execution.\n            self.execute(sql, params=None)\n",
      "\n    def add_constraint(self, model, constraint):\n        \"\"\"Add a constraint to a model.\"\"\"\n        sql = constraint.create_sql(model, self)\n        if sql:\n            # Constraint.create_sql returns interpolated SQL which makes\n            # params=None a necessity to avoid escaping attempts on execution.\n            self.execute(sql, params=None)\n",
      "\n    def add_constraint(self, model, constraint):\n        \"\"\"Add a constraint to a model.\"\"\"\n        sql = constraint.create_sql(model, self)\n        if sql:\n            # Constraint.create_sql returns interpolated SQL which makes\n            # params=None a necessity to avoid escaping attempts on execution.\n            self.execute(sql, params=None)\n",
      "\n    def add_constraint(self, model, constraint):\n        \"\"\"Add a constraint to a model.\"\"\"\n        sql = constraint.create_sql(model, self)\n        if sql:\n            # Constraint.create_sql returns interpolated SQL which makes\n            # params=None a necessity to avoid escaping attempts on execution.\n            self.execute(sql, params=None)\n",
      "\n    def add_constraint(self, model, constraint):\n        \"\"\"Add a constraint to a model.\"\"\"\n        sql = constraint.create_sql(model, self)\n        if sql:\n            # Constraint.create_sql returns interpolated SQL which makes\n            # params=None a necessity to avoid escaping attempts on execution.\n            self.execute(sql, params=None)\n",
      "\n    def add_constraint(self, model, constraint):\n        \"\"\"Add a constraint to a model.\"\"\"\n        sql = constraint.create_sql(model, self)\n        if sql:\n            # Constraint.create_sql returns interpolated SQL which makes\n            # params=None a necessity to avoid escaping attempts on execution.\n            self.execute(sql, params=None)\n",
      "\n    def add_constraint(self, model, constraint):\n        \"\"\"Add a constraint to a model.\"\"\"\n        sql = constraint.create_sql(model, self)\n        if sql:\n            # Constraint.create_sql returns interpolated SQL which makes\n            # params=None a necessity to avoid escaping attempts on execution.\n            self.execute(sql, params=None)\n",
      "\n    def add_constraint(self, model, constraint):\n        \"\"\"Add a constraint to a model.\"\"\"\n        sql = constraint.create_sql(model, self)\n        if sql:\n            # Constraint.create_sql returns interpolated SQL which makes\n            # params=None a necessity to avoid escaping attempts on execution.\n            self.execute(sql, params=None)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..def2735975 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -398,6 +398,7 @@ class BaseDatabaseSchemaEditor:\n             return None\n         self.execute(index.remove_sql(model, self))\n \n+\n     def add_constraint(self, model, constraint):\n         \"\"\"Add a constraint to a model.\"\"\"\n         sql = constraint.create_sql(model, self)\n@@ -1268,6 +1269,7 @@ class BaseDatabaseSchemaEditor:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n         else:\n             name = self.quote_name(name)\n+\n         if condition or include or opclasses or expressions:\n             sql = self.sql_create_unique_index\n         else:\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..ae3e2e3e32 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,6 +201,7 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..4fc6d00c22 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -419,12 +419,12 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         self.delete_model(old_field.remote_field.through)\n \n     def add_constraint(self, model, constraint):\n+\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n-            constraint.contains_expressions or\n             constraint.include or\n             constraint.deferrable\n-        ):\n+        ) and not constraint.contains_expressions:\n             super().add_constraint(model, constraint)\n         else:\n             self._remake_table(model)\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex d36d076346..3d166b1f0f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -195,6 +195,7 @@ class UniqueConstraint(BaseConstraint):\n             opclasses=self.opclasses, expressions=expressions,\n         )\n \n+\n     def create_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name) for field_name in self.fields]\n         include = [model._meta.get_field(field_name).column for field_name in self.include]\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..202d781bff 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -398,6 +398,7 @@ class BaseDatabaseSchemaEditor:\n             return None\n         self.execute(index.remove_sql(model, self))\n \n+\n     def add_constraint(self, model, constraint):\n         \"\"\"Add a constraint to a model.\"\"\"\n         sql = constraint.create_sql(model, self)\n@@ -1268,7 +1269,8 @@ class BaseDatabaseSchemaEditor:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n         else:\n             name = self.quote_name(name)\n-        if condition or include or opclasses or expressions:\n+\n+        if condition or include or opclasses:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..106fb6b961 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,12 +201,17 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        # Handle expressions that might be strings or expression objects\n+        if hasattr(expressions, '__iter__') and not isinstance(expressions, str):\n+            columns = [col.target.column for col in self.compiler.query._gen_cols([expressions])]\n+        else:\n+            columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n         super().__init__(table, columns)\n \n     def rename_table_references(self, old_table, new_table):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..6a960202e0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -418,16 +418,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+    def add_constraint(self, model, constraint):\n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n-            constraint.contains_expressions or\n             constraint.include or\n             constraint.deferrable\n-        ):\n+        ) and not constraint.contains_expressions:\n             super().add_constraint(model, constraint)\n         else:\n             self._remake_table(model)\n+        else:\n+            self._remake_table(model)\n \n     def remove_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex d36d076346..3d166b1f0f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -195,6 +195,7 @@ class UniqueConstraint(BaseConstraint):\n             opclasses=self.opclasses, expressions=expressions,\n         )\n \n+\n     def create_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name) for field_name in self.fields]\n         include = [model._meta.get_field(field_name).column for field_name in self.include]\n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..202d781bff 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -398,6 +398,7 @@ class BaseDatabaseSchemaEditor:\n             return None\n         self.execute(index.remove_sql(model, self))\n \n+\n     def add_constraint(self, model, constraint):\n         \"\"\"Add a constraint to a model.\"\"\"\n         sql = constraint.create_sql(model, self)\n@@ -1268,7 +1269,8 @@ class BaseDatabaseSchemaEditor:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n         else:\n             name = self.quote_name(name)\n-        if condition or include or opclasses or expressions:\n+\n+        if condition or include or opclasses:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..75b1b484ce 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,12 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        # Handle expressions list properly - it may contain a single expression or multiple\n+        expr_list = expressions if isinstance(expressions, list) else [expressions]\n+        columns = [col.target.column for col in self.compiler.query._gen_cols(expr_list)]\n         super().__init__(table, columns)\n \n     def rename_table_references(self, old_table, new_table):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..6a960202e0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -418,16 +418,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+    def add_constraint(self, model, constraint):\n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n-            constraint.contains_expressions or\n             constraint.include or\n             constraint.deferrable\n-        ):\n+        ) and not constraint.contains_expressions:\n             super().add_constraint(model, constraint)\n         else:\n             self._remake_table(model)\n+        else:\n+            self._remake_table(model)\n \n     def remove_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex d36d076346..3d166b1f0f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -195,6 +195,7 @@ class UniqueConstraint(BaseConstraint):\n             opclasses=self.opclasses, expressions=expressions,\n         )\n \n+\n     def create_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name) for field_name in self.fields]\n         include = [model._meta.get_field(field_name).column for field_name in self.include]\n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..202d781bff 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -398,6 +398,7 @@ class BaseDatabaseSchemaEditor:\n             return None\n         self.execute(index.remove_sql(model, self))\n \n+\n     def add_constraint(self, model, constraint):\n         \"\"\"Add a constraint to a model.\"\"\"\n         sql = constraint.create_sql(model, self)\n@@ -1268,7 +1269,8 @@ class BaseDatabaseSchemaEditor:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n         else:\n             name = self.quote_name(name)\n-        if condition or include or opclasses or expressions:\n+\n+        if condition or include or opclasses:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..39b8fdd7b2 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,12 +201,17 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        # Handle expressions that might not have target.column attribute\n+        columns = []\n+        for col in self.compiler.query._gen_cols([self.expressions]):\n+            if hasattr(col, 'target') and hasattr(col.target, 'column'):\n+                columns.append(col.target.column)\n         super().__init__(table, columns)\n \n     def rename_table_references(self, old_table, new_table):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..6a960202e0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -418,16 +418,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+    def add_constraint(self, model, constraint):\n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n-            constraint.contains_expressions or\n             constraint.include or\n             constraint.deferrable\n-        ):\n+        ) and not constraint.contains_expressions:\n             super().add_constraint(model, constraint)\n         else:\n             self._remake_table(model)\n+        else:\n+            self._remake_table(model)\n \n     def remove_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex d36d076346..3d166b1f0f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -195,6 +195,7 @@ class UniqueConstraint(BaseConstraint):\n             opclasses=self.opclasses, expressions=expressions,\n         )\n \n+\n     def create_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name) for field_name in self.fields]\n         include = [model._meta.get_field(field_name).column for field_name in self.include]\n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..202d781bff 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -398,6 +398,7 @@ class BaseDatabaseSchemaEditor:\n             return None\n         self.execute(index.remove_sql(model, self))\n \n+\n     def add_constraint(self, model, constraint):\n         \"\"\"Add a constraint to a model.\"\"\"\n         sql = constraint.create_sql(model, self)\n@@ -1268,7 +1269,8 @@ class BaseDatabaseSchemaEditor:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n         else:\n             name = self.quote_name(name)\n-        if condition or include or opclasses or expressions:\n+\n+        if condition or include or opclasses:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..ae3e2e3e32 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,6 +201,7 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..6a960202e0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -418,16 +418,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+    def add_constraint(self, model, constraint):\n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n-            constraint.contains_expressions or\n             constraint.include or\n             constraint.deferrable\n-        ):\n+        ) and not constraint.contains_expressions:\n             super().add_constraint(model, constraint)\n         else:\n             self._remake_table(model)\n+        else:\n+            self._remake_table(model)\n \n     def remove_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex d36d076346..3d166b1f0f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -195,6 +195,7 @@ class UniqueConstraint(BaseConstraint):\n             opclasses=self.opclasses, expressions=expressions,\n         )\n \n+\n     def create_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name) for field_name in self.fields]\n         include = [model._meta.get_field(field_name).column for field_name in self.include]\n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..202d781bff 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -398,6 +398,7 @@ class BaseDatabaseSchemaEditor:\n             return None\n         self.execute(index.remove_sql(model, self))\n \n+\n     def add_constraint(self, model, constraint):\n         \"\"\"Add a constraint to a model.\"\"\"\n         sql = constraint.create_sql(model, self)\n@@ -1268,7 +1269,8 @@ class BaseDatabaseSchemaEditor:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n         else:\n             name = self.quote_name(name)\n-        if condition or include or opclasses or expressions:\n+\n+        if condition or include or opclasses:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..54d426d1a9 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,12 +201,21 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        # Handle expressions that might not have target.column attributes\n+        columns = []\n+        try:\n+            for col in self.compiler.query._gen_cols([self.expressions]):\n+                if hasattr(col, 'target') and hasattr(col.target, 'column'):\n+                    columns.append(col.target.column)\n+        except (AttributeError, TypeError):\n+            # Fallback for expressions that don't have standard column structure\n+            columns = []\n         super().__init__(table, columns)\n \n     def rename_table_references(self, old_table, new_table):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..6a960202e0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -418,16 +418,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+    def add_constraint(self, model, constraint):\n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n-            constraint.contains_expressions or\n             constraint.include or\n             constraint.deferrable\n-        ):\n+        ) and not constraint.contains_expressions:\n             super().add_constraint(model, constraint)\n         else:\n             self._remake_table(model)\n+        else:\n+            self._remake_table(model)\n \n     def remove_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex d36d076346..3d166b1f0f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -195,6 +195,7 @@ class UniqueConstraint(BaseConstraint):\n             opclasses=self.opclasses, expressions=expressions,\n         )\n \n+\n     def create_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name) for field_name in self.fields]\n         include = [model._meta.get_field(field_name).column for field_name in self.include]\n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..202d781bff 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -398,6 +398,7 @@ class BaseDatabaseSchemaEditor:\n             return None\n         self.execute(index.remove_sql(model, self))\n \n+\n     def add_constraint(self, model, constraint):\n         \"\"\"Add a constraint to a model.\"\"\"\n         sql = constraint.create_sql(model, self)\n@@ -1268,7 +1269,8 @@ class BaseDatabaseSchemaEditor:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n         else:\n             name = self.quote_name(name)\n-        if condition or include or opclasses or expressions:\n+\n+        if condition or include or opclasses:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..6c9d49e1d0 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,12 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        # Handle expressions list properly - extract from nested structure if needed\n+        expr_list = expressions if isinstance(expressions, list) else [expressions]\n+        columns = [col.target.column for col in self.compiler.query._gen_cols(expr_list)]\n         super().__init__(table, columns)\n \n     def rename_table_references(self, old_table, new_table):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..6a960202e0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -418,16 +418,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+    def add_constraint(self, model, constraint):\n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n-            constraint.contains_expressions or\n             constraint.include or\n             constraint.deferrable\n-        ):\n+        ) and not constraint.contains_expressions:\n             super().add_constraint(model, constraint)\n         else:\n             self._remake_table(model)\n+        else:\n+            self._remake_table(model)\n \n     def remove_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex d36d076346..3d166b1f0f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -195,6 +195,7 @@ class UniqueConstraint(BaseConstraint):\n             opclasses=self.opclasses, expressions=expressions,\n         )\n \n+\n     def create_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name) for field_name in self.fields]\n         include = [model._meta.get_field(field_name).column for field_name in self.include]\n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..202d781bff 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -398,6 +398,7 @@ class BaseDatabaseSchemaEditor:\n             return None\n         self.execute(index.remove_sql(model, self))\n \n+\n     def add_constraint(self, model, constraint):\n         \"\"\"Add a constraint to a model.\"\"\"\n         sql = constraint.create_sql(model, self)\n@@ -1268,7 +1269,8 @@ class BaseDatabaseSchemaEditor:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n         else:\n             name = self.quote_name(name)\n-        if condition or include or opclasses or expressions:\n+\n+        if condition or include or opclasses:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..c563a185ca 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,12 +201,17 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        # Extract columns without generating table.column notation for SQLite compatibility\n+        columns = []\n+        for col in self.compiler.query._gen_cols([self.expressions]):\n+            if hasattr(col.target, 'column'):\n+                columns.append(col.target.column)\n         super().__init__(table, columns)\n \n     def rename_table_references(self, old_table, new_table):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..6a960202e0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -418,16 +418,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+    def add_constraint(self, model, constraint):\n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n-            constraint.contains_expressions or\n             constraint.include or\n             constraint.deferrable\n-        ):\n+        ) and not constraint.contains_expressions:\n             super().add_constraint(model, constraint)\n         else:\n             self._remake_table(model)\n+        else:\n+            self._remake_table(model)\n \n     def remove_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex d36d076346..3d166b1f0f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -195,6 +195,7 @@ class UniqueConstraint(BaseConstraint):\n             opclasses=self.opclasses, expressions=expressions,\n         )\n \n+\n     def create_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name) for field_name in self.fields]\n         include = [model._meta.get_field(field_name).column for field_name in self.include]\n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..202d781bff 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -398,6 +398,7 @@ class BaseDatabaseSchemaEditor:\n             return None\n         self.execute(index.remove_sql(model, self))\n \n+\n     def add_constraint(self, model, constraint):\n         \"\"\"Add a constraint to a model.\"\"\"\n         sql = constraint.create_sql(model, self)\n@@ -1268,7 +1269,8 @@ class BaseDatabaseSchemaEditor:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n         else:\n             name = self.quote_name(name)\n-        if condition or include or opclasses or expressions:\n+\n+        if condition or include or opclasses:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..d26ea81951 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,12 +201,21 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        # Handle expressions that may not have column targets\n+        columns = []\n+        try:\n+            for col in self.compiler.query._gen_cols([self.expressions]):\n+                if hasattr(col, 'target') and hasattr(col.target, 'column'):\n+                    columns.append(col.target.column)\n+        except (AttributeError, TypeError):\n+            # Fallback for expressions without proper column targets\n+            pass\n         super().__init__(table, columns)\n \n     def rename_table_references(self, old_table, new_table):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..6a960202e0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -418,16 +418,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+    def add_constraint(self, model, constraint):\n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n-            constraint.contains_expressions or\n             constraint.include or\n             constraint.deferrable\n-        ):\n+        ) and not constraint.contains_expressions:\n             super().add_constraint(model, constraint)\n         else:\n             self._remake_table(model)\n+        else:\n+            self._remake_table(model)\n \n     def remove_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex d36d076346..3d166b1f0f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -195,6 +195,7 @@ class UniqueConstraint(BaseConstraint):\n             opclasses=self.opclasses, expressions=expressions,\n         )\n \n+\n     def create_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name) for field_name in self.fields]\n         include = [model._meta.get_field(field_name).column for field_name in self.include]\n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..202d781bff 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -398,6 +398,7 @@ class BaseDatabaseSchemaEditor:\n             return None\n         self.execute(index.remove_sql(model, self))\n \n+\n     def add_constraint(self, model, constraint):\n         \"\"\"Add a constraint to a model.\"\"\"\n         sql = constraint.create_sql(model, self)\n@@ -1268,7 +1269,8 @@ class BaseDatabaseSchemaEditor:\n             name = IndexName(table, columns, '_uniq', create_unique_name)\n         else:\n             name = self.quote_name(name)\n-        if condition or include or opclasses or expressions:\n+\n+        if condition or include or opclasses:\n             sql = self.sql_create_unique_index\n         else:\n             sql = self.sql_create_unique\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..08a1548e59 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,12 +201,18 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        # Handle expressions that might be tuples or single expressions\n+        if isinstance(expressions, (list, tuple)):\n+            expr_list = list(expressions)\n+        else:\n+            expr_list = [expressions]\n+        columns = [col.target.column for col in self.compiler.query._gen_cols([expr_list])]\n         super().__init__(table, columns)\n \n     def rename_table_references(self, old_table, new_table):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..6a960202e0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -418,16 +418,19 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+    def add_constraint(self, model, constraint):\n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n-            constraint.contains_expressions or\n             constraint.include or\n             constraint.deferrable\n-        ):\n+        ) and not constraint.contains_expressions:\n             super().add_constraint(model, constraint)\n         else:\n             self._remake_table(model)\n+        else:\n+            self._remake_table(model)\n \n     def remove_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex d36d076346..3d166b1f0f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -195,6 +195,7 @@ class UniqueConstraint(BaseConstraint):\n             opclasses=self.opclasses, expressions=expressions,\n         )\n \n+\n     def create_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name) for field_name in self.fields]\n         include = [model._meta.get_field(field_name).column for field_name in self.include]\n"
  }
}