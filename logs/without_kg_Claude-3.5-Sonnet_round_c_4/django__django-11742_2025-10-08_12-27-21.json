{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 954-958)": "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_max_length_attribute(**kwargs),\n            *self._check_max_length_choices_compatibility(**kwargs),\n        ]\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 960-979)": "\n    def _check_max_length_attribute(self, **kwargs):\n        if self.max_length is None:\n            return [\n                checks.Error(\n                    \"CharFields must define a 'max_length' attribute.\",\n                    obj=self,\n                    id='fields.E120',\n                )\n            ]\n        elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n                self.max_length <= 0):\n            return [\n                checks.Error(\n                    \"'max_length' must be a positive integer.\",\n                    obj=self,\n                    id='fields.E121',\n                )\n            ]\n        else:\n            return []\n\n    def _check_max_length_choices_compatibility(self, **kwargs):\n        if not self.choices or self.max_length is None:\n            return []\n        \n        def extract_choice_values(choices):\n            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n            values = []\n            for choice_item in choices:\n                try:\n                    # Try grouped format: (group_name, [(value, display), ...])\n                    group_name, group_choices = choice_item\n                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n                        values.extend(extract_choice_values(group_choices))\n                    else:\n                        # Simple format: (value, display)\n                        values.append(group_name)\n                except (TypeError, ValueError):\n                    # Simple format: (value, display)\n                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n            return values\n        \n        choice_values = extract_choice_values(self.choices)\n        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n        \n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    obj=self,\n                    id='fields.E122',\n                )\n            ]\n        return []\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 244-292)": "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 954-958)": [
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_max_length_attribute(**kwargs),\n            *self._check_max_length_choices_compatibility(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_max_length_attribute(**kwargs),\n            *self._check_max_length_choices_compatibility(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_max_length_attribute(**kwargs),\n            *self._check_max_length_choices_compatibility(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_max_length_attribute(**kwargs),\n            *self._check_max_length_choices_compatibility(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_max_length_attribute(**kwargs),\n            *self._check_max_length_choices_compatibility(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_max_length_attribute(**kwargs),\n            *self._check_max_length_choices_compatibility(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_max_length_attribute(**kwargs),\n            *self._check_max_length_choices_compatibility(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_max_length_attribute(**kwargs),\n            *self._check_max_length_choices_compatibility(**kwargs),\n        ]\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 960-979)": [
      "\n    def _check_max_length_attribute(self, **kwargs):\n        if self.max_length is None:\n            return [\n                checks.Error(\n                    \"CharFields must define a 'max_length' attribute.\",\n                    obj=self,\n                    id='fields.E120',\n                )\n            ]\n        elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n                self.max_length <= 0):\n            return [\n                checks.Error(\n                    \"'max_length' must be a positive integer.\",\n                    obj=self,\n                    id='fields.E121',\n                )\n            ]\n        else:\n            return []\n\n    def _check_max_length_choices_compatibility(self, **kwargs):\n        if not self.choices or self.max_length is None:\n            return []\n        \n        def extract_choice_values(choices):\n            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n            values = []\n            for choice_item in choices:\n                try:\n                    # Try grouped format: (group_name, [(value, display), ...])\n                    group_name, group_choices = choice_item\n                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n                        values.extend(extract_choice_values(group_choices))\n                    else:\n                        # Simple format: (value, display)\n                        values.append(group_name)\n                except (TypeError, ValueError):\n                    # Simple format: (value, display)\n                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n            return values\n        \n        choice_values = extract_choice_values(self.choices)\n        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n        \n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    obj=self,\n                    id='fields.E122',\n                )\n            ]\n        return []\n",
      "\n    def _check_max_length_attribute(self, **kwargs):\n        if self.max_length is None:\n            return [\n                checks.Error(\n                    \"CharFields must define a 'max_length' attribute.\",\n                    obj=self,\n                    id='fields.E120',\n                )\n            ]\n        elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n                self.max_length <= 0):\n            return [\n                checks.Error(\n                    \"'max_length' must be a positive integer.\",\n                    obj=self,\n                    id='fields.E121',\n                )\n            ]\n        else:\n            return []\n\n    def _check_max_length_choices_compatibility(self, **kwargs):\n        if not self.choices or self.max_length is None:\n            return []\n        \n        def extract_choice_values(choices):\n            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n            values = []\n            for choice_item in choices:\n                try:\n                    # Try grouped format: (group_name, [(value, display), ...])\n                    group_name, group_choices = choice_item\n                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n                        values.extend(extract_choice_values(group_choices))\n                    else:\n                        # Simple format: (value, display)\n                        values.append(group_name)\n                except (TypeError, ValueError):\n                    # Simple format: (value, display)\n                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n            return values\n        \n        choice_values = extract_choice_values(self.choices)\n        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n        \n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    obj=self,\n                    id='fields.E122',\n                )\n            ]\n        return []\n",
      "\n    def _check_max_length_attribute(self, **kwargs):\n        if self.max_length is None:\n            return [\n                checks.Error(\n                    \"CharFields must define a 'max_length' attribute.\",\n                    obj=self,\n                    id='fields.E120',\n                )\n            ]\n        elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n                self.max_length <= 0):\n            return [\n                checks.Error(\n                    \"'max_length' must be a positive integer.\",\n                    obj=self,\n                    id='fields.E121',\n                )\n            ]\n        else:\n            return []\n\n    def _check_max_length_choices_compatibility(self, **kwargs):\n        if not self.choices or self.max_length is None:\n            return []\n        \n        def extract_choice_values(choices):\n            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n            values = []\n            for choice_item in choices:\n                try:\n                    # Try grouped format: (group_name, [(value, display), ...])\n                    group_name, group_choices = choice_item\n                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n                        values.extend(extract_choice_values(group_choices))\n                    else:\n                        # Simple format: (value, display)\n                        values.append(group_name)\n                except (TypeError, ValueError):\n                    # Simple format: (value, display)\n                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n            return values\n        \n        choice_values = extract_choice_values(self.choices)\n        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n        \n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    obj=self,\n                    id='fields.E122',\n                )\n            ]\n        return []\n",
      "\n    def _check_max_length_attribute(self, **kwargs):\n        if self.max_length is None:\n            return [\n                checks.Error(\n                    \"CharFields must define a 'max_length' attribute.\",\n                    obj=self,\n                    id='fields.E120',\n                )\n            ]\n        elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n                self.max_length <= 0):\n            return [\n                checks.Error(\n                    \"'max_length' must be a positive integer.\",\n                    obj=self,\n                    id='fields.E121',\n                )\n            ]\n        else:\n            return []\n\n    def _check_max_length_choices_compatibility(self, **kwargs):\n        if not self.choices or self.max_length is None:\n            return []\n        \n        def extract_choice_values(choices):\n            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n            values = []\n            for choice_item in choices:\n                try:\n                    # Try grouped format: (group_name, [(value, display), ...])\n                    group_name, group_choices = choice_item\n                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n                        values.extend(extract_choice_values(group_choices))\n                    else:\n                        # Simple format: (value, display)\n                        values.append(group_name)\n                except (TypeError, ValueError):\n                    # Simple format: (value, display)\n                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n            return values\n        \n        choice_values = extract_choice_values(self.choices)\n        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n        \n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    obj=self,\n                    id='fields.E122',\n                )\n            ]\n        return []\n",
      "\n    def _check_max_length_attribute(self, **kwargs):\n        if self.max_length is None:\n            return [\n                checks.Error(\n                    \"CharFields must define a 'max_length' attribute.\",\n                    obj=self,\n                    id='fields.E120',\n                )\n            ]\n        elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n                self.max_length <= 0):\n            return [\n                checks.Error(\n                    \"'max_length' must be a positive integer.\",\n                    obj=self,\n                    id='fields.E121',\n                )\n            ]\n        else:\n            return []\n\n    def _check_max_length_choices_compatibility(self, **kwargs):\n        if not self.choices or self.max_length is None:\n            return []\n        \n        def extract_choice_values(choices):\n            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n            values = []\n            for choice_item in choices:\n                try:\n                    # Try grouped format: (group_name, [(value, display), ...])\n                    group_name, group_choices = choice_item\n                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n                        values.extend(extract_choice_values(group_choices))\n                    else:\n                        # Simple format: (value, display)\n                        values.append(group_name)\n                except (TypeError, ValueError):\n                    # Simple format: (value, display)\n                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n            return values\n        \n        choice_values = extract_choice_values(self.choices)\n        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n        \n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    obj=self,\n                    id='fields.E122',\n                )\n            ]\n        return []\n",
      "\n    def _check_max_length_attribute(self, **kwargs):\n        if self.max_length is None:\n            return [\n                checks.Error(\n                    \"CharFields must define a 'max_length' attribute.\",\n                    obj=self,\n                    id='fields.E120',\n                )\n            ]\n        elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n                self.max_length <= 0):\n            return [\n                checks.Error(\n                    \"'max_length' must be a positive integer.\",\n                    obj=self,\n                    id='fields.E121',\n                )\n            ]\n        else:\n            return []\n\n    def _check_max_length_choices_compatibility(self, **kwargs):\n        if not self.choices or self.max_length is None:\n            return []\n        \n        def extract_choice_values(choices):\n            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n            values = []\n            for choice_item in choices:\n                try:\n                    # Try grouped format: (group_name, [(value, display), ...])\n                    group_name, group_choices = choice_item\n                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n                        values.extend(extract_choice_values(group_choices))\n                    else:\n                        # Simple format: (value, display)\n                        values.append(group_name)\n                except (TypeError, ValueError):\n                    # Simple format: (value, display)\n                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n            return values\n        \n        choice_values = extract_choice_values(self.choices)\n        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n        \n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    obj=self,\n                    id='fields.E122',\n                )\n            ]\n        return []\n",
      "\n    def _check_max_length_attribute(self, **kwargs):\n        if self.max_length is None:\n            return [\n                checks.Error(\n                    \"CharFields must define a 'max_length' attribute.\",\n                    obj=self,\n                    id='fields.E120',\n                )\n            ]\n        elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n                self.max_length <= 0):\n            return [\n                checks.Error(\n                    \"'max_length' must be a positive integer.\",\n                    obj=self,\n                    id='fields.E121',\n                )\n            ]\n        else:\n            return []\n\n    def _check_max_length_choices_compatibility(self, **kwargs):\n        if not self.choices or self.max_length is None:\n            return []\n        \n        def extract_choice_values(choices):\n            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n            values = []\n            for choice_item in choices:\n                try:\n                    # Try grouped format: (group_name, [(value, display), ...])\n                    group_name, group_choices = choice_item\n                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n                        values.extend(extract_choice_values(group_choices))\n                    else:\n                        # Simple format: (value, display)\n                        values.append(group_name)\n                except (TypeError, ValueError):\n                    # Simple format: (value, display)\n                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n            return values\n        \n        choice_values = extract_choice_values(self.choices)\n        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n        \n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    obj=self,\n                    id='fields.E122',\n                )\n            ]\n        return []\n",
      "\n    def _check_max_length_attribute(self, **kwargs):\n        if self.max_length is None:\n            return [\n                checks.Error(\n                    \"CharFields must define a 'max_length' attribute.\",\n                    obj=self,\n                    id='fields.E120',\n                )\n            ]\n        elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n                self.max_length <= 0):\n            return [\n                checks.Error(\n                    \"'max_length' must be a positive integer.\",\n                    obj=self,\n                    id='fields.E121',\n                )\n            ]\n        else:\n            return []\n\n    def _check_max_length_choices_compatibility(self, **kwargs):\n        if not self.choices or self.max_length is None:\n            return []\n        \n        def extract_choice_values(choices):\n            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n            values = []\n            for choice_item in choices:\n                try:\n                    # Try grouped format: (group_name, [(value, display), ...])\n                    group_name, group_choices = choice_item\n                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n                        values.extend(extract_choice_values(group_choices))\n                    else:\n                        # Simple format: (value, display)\n                        values.append(group_name)\n                except (TypeError, ValueError):\n                    # Simple format: (value, display)\n                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n            return values\n        \n        choice_values = extract_choice_values(self.choices)\n        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n        \n        if max_choice_length > self.max_length:\n            return [\n                checks.Error(\n                    f\"'max_length' is too small to fit the longest value \"\n                    f\"in 'choices' ({max_choice_length} characters).\",\n                    obj=self,\n                    id='fields.E122',\n                )\n            ]\n        return []\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 244-292)": [
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..e413de682d 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -951,12 +952,15 @@ class CharField(Field):\n         super().__init__(*args, **kwargs)\n         self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_max_length_attribute(**kwargs),\n+            *self._check_max_length_choices_compatibility(**kwargs),\n         ]\n \n+\n     def _check_max_length_attribute(self, **kwargs):\n         if self.max_length is None:\n             return [\n@@ -978,6 +982,44 @@ class CharField(Field):\n         else:\n             return []\n \n+    def _check_max_length_choices_compatibility(self, **kwargs):\n+        if not self.choices or self.max_length is None:\n+            return []\n+\n+        def extract_choice_values(choices):\n+            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n+            values = []\n+            for choice_item in choices:\n+                try:\n+                    # Try grouped format: (group_name, [(value, display), ...])\n+                    group_name, group_choices = choice_item\n+                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n+                        values.extend(extract_choice_values(group_choices))\n+                    else:\n+                        # Simple format: (value, display)\n+                        values.append(group_name)\n+                except (TypeError, ValueError):\n+                    # Simple format: (value, display)\n+                    if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str):\n+                        values.append(choice_item[0])\n+                    else:\n+                        values.append(choice_item)\n+            return values\n+\n+        choice_values = extract_choice_values(self.choices)\n+        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n+\n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    \"'max_length' is too small to fit the longest value \"\n+                    \"in 'choices' (%d characters).\" % max_choice_length,\n+                    obj=self,\n+                    id='fields.E122',\n+                )\n+            ]\n+        return []\n+\n     def cast_db_type(self, connection):\n         if self.max_length is None:\n             return connection.ops.cast_char_field_without_max_length\n",
    "variant_0": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..117db8c9ab 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -951,12 +952,15 @@ class CharField(Field):\n         super().__init__(*args, **kwargs)\n         self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_max_length_attribute(**kwargs),\n+            *self._check_max_length_choices_compatibility(**kwargs),\n         ]\n \n+\n     def _check_max_length_attribute(self, **kwargs):\n         if self.max_length is None:\n             return [\n@@ -978,6 +982,41 @@ class CharField(Field):\n         else:\n             return []\n \n+    def _check_max_length_choices_compatibility(self, **kwargs):\n+        if not self.choices or self.max_length is None:\n+            return []\n+        \n+        def extract_choice_values(choices):\n+            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n+            values = []\n+            for choice_item in choices:\n+                try:\n+                    # Try grouped format: (group_name, [(value, display), ...])\n+                    group_name, group_choices = choice_item\n+                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n+                        values.extend(extract_choice_values(group_choices))\n+                    else:\n+                        # Simple format: (value, display)\n+                        values.append(group_name)\n+                except (TypeError, ValueError):\n+                    # Simple format: (value, display)\n+                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n+            return values\n+        \n+        choice_values = extract_choice_values(self.choices)\n+        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n+        \n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    obj=self,\n+                    id='fields.E122',\n+                )\n+            ]\n+        return []\n+\n     def cast_db_type(self, connection):\n         if self.max_length is None:\n             return connection.ops.cast_char_field_without_max_length\n",
    "variant_1": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..117db8c9ab 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -951,12 +952,15 @@ class CharField(Field):\n         super().__init__(*args, **kwargs)\n         self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_max_length_attribute(**kwargs),\n+            *self._check_max_length_choices_compatibility(**kwargs),\n         ]\n \n+\n     def _check_max_length_attribute(self, **kwargs):\n         if self.max_length is None:\n             return [\n@@ -978,6 +982,41 @@ class CharField(Field):\n         else:\n             return []\n \n+    def _check_max_length_choices_compatibility(self, **kwargs):\n+        if not self.choices or self.max_length is None:\n+            return []\n+        \n+        def extract_choice_values(choices):\n+            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n+            values = []\n+            for choice_item in choices:\n+                try:\n+                    # Try grouped format: (group_name, [(value, display), ...])\n+                    group_name, group_choices = choice_item\n+                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n+                        values.extend(extract_choice_values(group_choices))\n+                    else:\n+                        # Simple format: (value, display)\n+                        values.append(group_name)\n+                except (TypeError, ValueError):\n+                    # Simple format: (value, display)\n+                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n+            return values\n+        \n+        choice_values = extract_choice_values(self.choices)\n+        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n+        \n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    obj=self,\n+                    id='fields.E122',\n+                )\n+            ]\n+        return []\n+\n     def cast_db_type(self, connection):\n         if self.max_length is None:\n             return connection.ops.cast_char_field_without_max_length\n",
    "variant_2": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..117db8c9ab 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -951,12 +952,15 @@ class CharField(Field):\n         super().__init__(*args, **kwargs)\n         self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_max_length_attribute(**kwargs),\n+            *self._check_max_length_choices_compatibility(**kwargs),\n         ]\n \n+\n     def _check_max_length_attribute(self, **kwargs):\n         if self.max_length is None:\n             return [\n@@ -978,6 +982,41 @@ class CharField(Field):\n         else:\n             return []\n \n+    def _check_max_length_choices_compatibility(self, **kwargs):\n+        if not self.choices or self.max_length is None:\n+            return []\n+        \n+        def extract_choice_values(choices):\n+            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n+            values = []\n+            for choice_item in choices:\n+                try:\n+                    # Try grouped format: (group_name, [(value, display), ...])\n+                    group_name, group_choices = choice_item\n+                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n+                        values.extend(extract_choice_values(group_choices))\n+                    else:\n+                        # Simple format: (value, display)\n+                        values.append(group_name)\n+                except (TypeError, ValueError):\n+                    # Simple format: (value, display)\n+                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n+            return values\n+        \n+        choice_values = extract_choice_values(self.choices)\n+        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n+        \n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    obj=self,\n+                    id='fields.E122',\n+                )\n+            ]\n+        return []\n+\n     def cast_db_type(self, connection):\n         if self.max_length is None:\n             return connection.ops.cast_char_field_without_max_length\n",
    "variant_3": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..117db8c9ab 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -951,12 +952,15 @@ class CharField(Field):\n         super().__init__(*args, **kwargs)\n         self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_max_length_attribute(**kwargs),\n+            *self._check_max_length_choices_compatibility(**kwargs),\n         ]\n \n+\n     def _check_max_length_attribute(self, **kwargs):\n         if self.max_length is None:\n             return [\n@@ -978,6 +982,41 @@ class CharField(Field):\n         else:\n             return []\n \n+    def _check_max_length_choices_compatibility(self, **kwargs):\n+        if not self.choices or self.max_length is None:\n+            return []\n+        \n+        def extract_choice_values(choices):\n+            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n+            values = []\n+            for choice_item in choices:\n+                try:\n+                    # Try grouped format: (group_name, [(value, display), ...])\n+                    group_name, group_choices = choice_item\n+                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n+                        values.extend(extract_choice_values(group_choices))\n+                    else:\n+                        # Simple format: (value, display)\n+                        values.append(group_name)\n+                except (TypeError, ValueError):\n+                    # Simple format: (value, display)\n+                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n+            return values\n+        \n+        choice_values = extract_choice_values(self.choices)\n+        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n+        \n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    obj=self,\n+                    id='fields.E122',\n+                )\n+            ]\n+        return []\n+\n     def cast_db_type(self, connection):\n         if self.max_length is None:\n             return connection.ops.cast_char_field_without_max_length\n",
    "variant_4": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..117db8c9ab 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -951,12 +952,15 @@ class CharField(Field):\n         super().__init__(*args, **kwargs)\n         self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_max_length_attribute(**kwargs),\n+            *self._check_max_length_choices_compatibility(**kwargs),\n         ]\n \n+\n     def _check_max_length_attribute(self, **kwargs):\n         if self.max_length is None:\n             return [\n@@ -978,6 +982,41 @@ class CharField(Field):\n         else:\n             return []\n \n+    def _check_max_length_choices_compatibility(self, **kwargs):\n+        if not self.choices or self.max_length is None:\n+            return []\n+        \n+        def extract_choice_values(choices):\n+            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n+            values = []\n+            for choice_item in choices:\n+                try:\n+                    # Try grouped format: (group_name, [(value, display), ...])\n+                    group_name, group_choices = choice_item\n+                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n+                        values.extend(extract_choice_values(group_choices))\n+                    else:\n+                        # Simple format: (value, display)\n+                        values.append(group_name)\n+                except (TypeError, ValueError):\n+                    # Simple format: (value, display)\n+                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n+            return values\n+        \n+        choice_values = extract_choice_values(self.choices)\n+        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n+        \n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    obj=self,\n+                    id='fields.E122',\n+                )\n+            ]\n+        return []\n+\n     def cast_db_type(self, connection):\n         if self.max_length is None:\n             return connection.ops.cast_char_field_without_max_length\n",
    "variant_5": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..117db8c9ab 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -951,12 +952,15 @@ class CharField(Field):\n         super().__init__(*args, **kwargs)\n         self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_max_length_attribute(**kwargs),\n+            *self._check_max_length_choices_compatibility(**kwargs),\n         ]\n \n+\n     def _check_max_length_attribute(self, **kwargs):\n         if self.max_length is None:\n             return [\n@@ -978,6 +982,41 @@ class CharField(Field):\n         else:\n             return []\n \n+    def _check_max_length_choices_compatibility(self, **kwargs):\n+        if not self.choices or self.max_length is None:\n+            return []\n+        \n+        def extract_choice_values(choices):\n+            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n+            values = []\n+            for choice_item in choices:\n+                try:\n+                    # Try grouped format: (group_name, [(value, display), ...])\n+                    group_name, group_choices = choice_item\n+                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n+                        values.extend(extract_choice_values(group_choices))\n+                    else:\n+                        # Simple format: (value, display)\n+                        values.append(group_name)\n+                except (TypeError, ValueError):\n+                    # Simple format: (value, display)\n+                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n+            return values\n+        \n+        choice_values = extract_choice_values(self.choices)\n+        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n+        \n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    obj=self,\n+                    id='fields.E122',\n+                )\n+            ]\n+        return []\n+\n     def cast_db_type(self, connection):\n         if self.max_length is None:\n             return connection.ops.cast_char_field_without_max_length\n",
    "variant_6": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..117db8c9ab 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -951,12 +952,15 @@ class CharField(Field):\n         super().__init__(*args, **kwargs)\n         self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_max_length_attribute(**kwargs),\n+            *self._check_max_length_choices_compatibility(**kwargs),\n         ]\n \n+\n     def _check_max_length_attribute(self, **kwargs):\n         if self.max_length is None:\n             return [\n@@ -978,6 +982,41 @@ class CharField(Field):\n         else:\n             return []\n \n+    def _check_max_length_choices_compatibility(self, **kwargs):\n+        if not self.choices or self.max_length is None:\n+            return []\n+        \n+        def extract_choice_values(choices):\n+            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n+            values = []\n+            for choice_item in choices:\n+                try:\n+                    # Try grouped format: (group_name, [(value, display), ...])\n+                    group_name, group_choices = choice_item\n+                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n+                        values.extend(extract_choice_values(group_choices))\n+                    else:\n+                        # Simple format: (value, display)\n+                        values.append(group_name)\n+                except (TypeError, ValueError):\n+                    # Simple format: (value, display)\n+                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n+            return values\n+        \n+        choice_values = extract_choice_values(self.choices)\n+        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n+        \n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    obj=self,\n+                    id='fields.E122',\n+                )\n+            ]\n+        return []\n+\n     def cast_db_type(self, connection):\n         if self.max_length is None:\n             return connection.ops.cast_char_field_without_max_length\n",
    "variant_7": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..117db8c9ab 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -951,12 +952,15 @@ class CharField(Field):\n         super().__init__(*args, **kwargs)\n         self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_max_length_attribute(**kwargs),\n+            *self._check_max_length_choices_compatibility(**kwargs),\n         ]\n \n+\n     def _check_max_length_attribute(self, **kwargs):\n         if self.max_length is None:\n             return [\n@@ -978,6 +982,41 @@ class CharField(Field):\n         else:\n             return []\n \n+    def _check_max_length_choices_compatibility(self, **kwargs):\n+        if not self.choices or self.max_length is None:\n+            return []\n+        \n+        def extract_choice_values(choices):\n+            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n+            values = []\n+            for choice_item in choices:\n+                try:\n+                    # Try grouped format: (group_name, [(value, display), ...])\n+                    group_name, group_choices = choice_item\n+                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n+                        values.extend(extract_choice_values(group_choices))\n+                    else:\n+                        # Simple format: (value, display)\n+                        values.append(group_name)\n+                except (TypeError, ValueError):\n+                    # Simple format: (value, display)\n+                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n+            return values\n+        \n+        choice_values = extract_choice_values(self.choices)\n+        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n+        \n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    obj=self,\n+                    id='fields.E122',\n+                )\n+            ]\n+        return []\n+\n     def cast_db_type(self, connection):\n         if self.max_length is None:\n             return connection.ops.cast_char_field_without_max_length\n",
    "variant_8": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..117db8c9ab 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -951,12 +952,15 @@ class CharField(Field):\n         super().__init__(*args, **kwargs)\n         self.validators.append(validators.MaxLengthValidator(self.max_length))\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n             *self._check_max_length_attribute(**kwargs),\n+            *self._check_max_length_choices_compatibility(**kwargs),\n         ]\n \n+\n     def _check_max_length_attribute(self, **kwargs):\n         if self.max_length is None:\n             return [\n@@ -978,6 +982,41 @@ class CharField(Field):\n         else:\n             return []\n \n+    def _check_max_length_choices_compatibility(self, **kwargs):\n+        if not self.choices or self.max_length is None:\n+            return []\n+        \n+        def extract_choice_values(choices):\n+            \"\"\"Extract all choice values from choices, handling both simple and grouped formats.\"\"\"\n+            values = []\n+            for choice_item in choices:\n+                try:\n+                    # Try grouped format: (group_name, [(value, display), ...])\n+                    group_name, group_choices = choice_item\n+                    if hasattr(group_choices, '__iter__') and not isinstance(group_choices, str):\n+                        values.extend(extract_choice_values(group_choices))\n+                    else:\n+                        # Simple format: (value, display)\n+                        values.append(group_name)\n+                except (TypeError, ValueError):\n+                    # Simple format: (value, display)\n+                    values.append(choice_item[0] if hasattr(choice_item, '__iter__') and not isinstance(choice_item, str) else choice_item)\n+            return values\n+        \n+        choice_values = extract_choice_values(self.choices)\n+        max_choice_length = max(len(str(value)) for value in choice_values) if choice_values else 0\n+        \n+        if max_choice_length > self.max_length:\n+            return [\n+                checks.Error(\n+                    f\"'max_length' is too small to fit the longest value \"\n+                    f\"in 'choices' ({max_choice_length} characters).\",\n+                    obj=self,\n+                    id='fields.E122',\n+                )\n+            ]\n+        return []\n+\n     def cast_db_type(self, connection):\n         if self.max_length is None:\n             return connection.ops.cast_char_field_without_max_length\n"
  }
}