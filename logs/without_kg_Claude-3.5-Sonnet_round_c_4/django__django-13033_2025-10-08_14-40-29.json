{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 730-747)": "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 725-725)": "\ndef find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                       already_seen=None):\n    \"\"\"\n    Return the table alias (the name might be ambiguous, the alias will\n    not be) and column name for ordering by the given 'name' parameter.\n    The 'name' is of the form 'field1__field2__...__fieldN'.\n    \"\"\"\n    name, order = get_order_dir(name, default_order)\n    descending = order == 'DESC'\n    pieces = name.split(LOOKUP_SEP)\n    field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n    # If we get to this point and the field is a relation to another model,\n    # append the default ordering for that model unless it is the pk\n    # shortcut or the attribute name of the field that is specified.\n    # Also don't apply when accessing foreign key ID field directly (e.g., record__root_id)\n    if (field.is_relation and opts.ordering and \n        getattr(field, 'attname', None) != name and name != 'pk' and\n        not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n        # Firstly, avoid infinite loops.\n        already_seen = already_seen or set()\n        join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n        if join_tuple in already_seen:\n            raise FieldError('Infinite loop caused by ordering.')\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 751-762)": "\ndef _setup_joins(self, pieces, opts, alias):\n    \"\"\"\n    Helper method for get_order_by() and get_distinct().\n\n    get_ordering() and get_distinct() must produce same target columns on\n    same input, as the prefixes of get_ordering() and get_distinct() must\n    match. Executing SQL where this is not true is an error.\n    \"\"\"\n    alias = alias or self.query.get_initial_alias()\n    field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n    alias = joins[-1] if joins else alias\n    return field, targets, alias, joins, path, opts, transform_function\n",
    "Location 4 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 1424-1450)": "\n    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n        \"\"\"\n        Walk the list of names and turns them into PathInfo tuples. A single\n        name in 'names' can generate multiple PathInfos (m2m, for example).\n\n        'names' is the path of names to travel, 'opts' is the model Options we\n        start the name resolving from, 'allow_many' is as for setup_joins().\n        If fail_on_missing is set to True, then a name that can't be resolved\n        will generate a FieldError.\n\n        Return a list of PathInfo tuples. In addition return the final field\n        (the last used join field) and target (which is a field guaranteed to\n        contain the same value as the final field). Finally, return those names\n        that weren't found (which are likely transforms and the final lookup).\n        \"\"\"\n        path, names_with_path = [], []\n        for pos, name in enumerate(names):\n            cur_names_with_path = (name, [])\n            if name == 'pk':\n                name = opts.pk.name\n\n            field = None\n            filtered_relation = None\n            try:\n                field = opts.get_field(name)\n            except FieldDoesNotExist:\n                if name in self.annotation_select:\n",
    "Location 5 (/root/hy/projects_4/django/django/db/models/options.py lines 545-551)": "\n    @cached_property\n    def fields_map(self):\n        res = {}\n        fields = self._get_fields(forward=False, include_hidden=True)\n        for field in fields:\n            res[field.name] = field\n            # Due to the way Django's internals work, get_field() should also\n            # be able to fetch a field by attname. In the case of a concrete\n            # field with relation, includes the *_id name too\n            try:\n                res[field.attname] = field\n            except AttributeError:\n                pass\n        return res\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 730-747)": [
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       order, already_seen))\n            return results\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 725-725)": [
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        # Also check if we're accessing a foreign key's _id field directly.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        # Also skip if we're accessing a foreign key's _id field directly.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n",
      "\ndef find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                       already_seen=None):\n    \"\"\"\n    Return the table alias (the name might be ambiguous, the alias will\n    not be) and column name for ordering by the given 'name' parameter.\n    The 'name' is of the form 'field1__field2__...__fieldN'.\n    \"\"\"\n    name, order = get_order_dir(name, default_order)\n    descending = order == 'DESC'\n    pieces = name.split(LOOKUP_SEP)\n    field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n    # If we get to this point and the field is a relation to another model,\n    # append the default ordering for that model unless it is the pk\n    # shortcut or the attribute name of the field that is specified.\n    # Also avoid applying default ordering when accessing foreign key ID fields directly.\n    if (field.is_relation and opts.ordering and \n        getattr(field, 'attname', None) != name and name != 'pk' and\n        not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n        # Firstly, avoid infinite loops.\n        already_seen = already_seen or set()\n        join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n        if join_tuple in already_seen:\n            raise FieldError('Infinite loop caused by ordering.')\n",
      "\ndef find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                       already_seen=None):\n    \"\"\"\n    Return the table alias (the name might be ambiguous, the alias will\n    not be) and column name for ordering by the given 'name' parameter.\n    The 'name' is of the form 'field1__field2__...__fieldN'.\n    \"\"\"\n    name, order = get_order_dir(name, default_order)\n    descending = order == 'DESC'\n    pieces = name.split(LOOKUP_SEP)\n    field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n    # If we get to this point and the field is a relation to another model,\n    # append the default ordering for that model unless it is the pk\n    # shortcut or the attribute name of the field that is specified.\n    # Also skip if the lookup refers to a foreign key's _id attribute directly.\n    if (field.is_relation and opts.ordering and \n        getattr(field, 'attname', None) != name and name != 'pk' and\n        not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n        # Firstly, avoid infinite loops.\n        already_seen = already_seen or set()\n        join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n        if join_tuple in already_seen:\n            raise FieldError('Infinite loop caused by ordering.')\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        # Also avoid applying default ordering when accessing foreign key ID fields directly.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        # Also skip if we're accessing a foreign key's _id field directly.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        # Also avoid applying default ordering when accessing foreign key ID fields directly.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless it is the pk\n        # shortcut or the attribute name of the field that is specified.\n        # Also skip if we're accessing a foreign key's _id attribute directly.\n        if (field.is_relation and opts.ordering and \n            getattr(field, 'attname', None) != name and name != 'pk' and\n            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 751-762)": [
      "\n    def _setup_joins(self, pieces, opts, alias):\n        \"\"\"\n        Helper method for get_order_by() and get_distinct().\n\n        get_ordering() and get_distinct() must produce same target columns on\n        same input, as the prefixes of get_ordering() and get_distinct() must\n        match. Executing SQL where this is not true is an error.\n        \"\"\"\n        alias = alias or self.query.get_initial_alias()\n        field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n        alias = joins[-1] if joins else alias\n        return field, targets, alias, joins, path, opts, transform_function\n",
      "\n    def _setup_joins(self, pieces, opts, alias):\n        \"\"\"\n        Helper method for get_order_by() and get_distinct().\n\n        get_ordering() and get_distinct() must produce same target columns on\n        same input, as the prefixes of get_ordering() and get_distinct() must\n        match. Executing SQL where this is not true is an error.\n        \"\"\"\n        alias = alias or self.query.get_initial_alias()\n        field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n        alias = joins[-1] if joins else alias\n        return field, targets, alias, joins, path, opts, transform_function\n",
      "\n    def _setup_joins(self, pieces, opts, alias):\n        \"\"\"\n        Helper method for get_order_by() and get_distinct().\n\n        get_ordering() and get_distinct() must produce same target columns on\n        same input, as the prefixes of get_ordering() and get_distinct() must\n        match. Executing SQL where this is not true is an error.\n        \"\"\"\n        alias = alias or self.query.get_initial_alias()\n        field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n        alias = joins[-1] if joins else alias\n        return field, targets, alias, joins, path, opts, transform_function\n",
      "\ndef _setup_joins(self, pieces, opts, alias):\n    \"\"\"\n    Helper method for get_order_by() and get_distinct().\n\n    get_ordering() and get_distinct() must produce same target columns on\n    same input, as the prefixes of get_ordering() and get_distinct() must\n    match. Executing SQL where this is not true is an error.\n    \"\"\"\n    alias = alias or self.query.get_initial_alias()\n    field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n    alias = joins[-1] if joins else alias\n    return field, targets, alias, joins, path, opts, transform_function\n",
      "\ndef _setup_joins(self, pieces, opts, alias):\n    \"\"\"\n    Helper method for get_order_by() and get_distinct().\n\n    get_ordering() and get_distinct() must produce same target columns on\n    same input, as the prefixes of get_ordering() and get_distinct() must\n    match. Executing SQL where this is not true is an error.\n    \"\"\"\n    alias = alias or self.query.get_initial_alias()\n    field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n    alias = joins[-1] if joins else alias\n    return field, targets, alias, joins, path, opts, transform_function\n",
      "\n    def _setup_joins(self, pieces, opts, alias):\n        \"\"\"\n        Helper method for get_order_by() and get_distinct().\n\n        get_ordering() and get_distinct() must produce same target columns on\n        same input, as the prefixes of get_ordering() and get_distinct() must\n        match. Executing SQL where this is not true is an error.\n        \"\"\"\n        alias = alias or self.query.get_initial_alias()\n        field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n        alias = joins[-1] if joins else alias\n        return field, targets, alias, joins, path, opts, transform_function\n",
      "\n    def _setup_joins(self, pieces, opts, alias):\n        \"\"\"\n        Helper method for get_order_by() and get_distinct().\n\n        get_ordering() and get_distinct() must produce same target columns on\n        same input, as the prefixes of get_ordering() and get_distinct() must\n        match. Executing SQL where this is not true is an error.\n        \"\"\"\n        alias = alias or self.query.get_initial_alias()\n        field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n        alias = joins[-1] if joins else alias\n        return field, targets, alias, joins, path, opts, transform_function\n",
      "\n    def _setup_joins(self, pieces, opts, alias):\n        \"\"\"\n        Helper method for get_order_by() and get_distinct().\n\n        get_ordering() and get_distinct() must produce same target columns on\n        same input, as the prefixes of get_ordering() and get_distinct() must\n        match. Executing SQL where this is not true is an error.\n        \"\"\"\n        alias = alias or self.query.get_initial_alias()\n        field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n        alias = joins[-1] if joins else alias\n        return field, targets, alias, joins, path, opts, transform_function\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 1424-1450)": [
      "\ndef names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n    \"\"\"\n    Walk the list of names and turns them into PathInfo tuples. A single\n    name in 'names' can generate multiple PathInfos (m2m, for example).\n\n    'names' is the path of names to travel, 'opts' is the model Options we\n    start the name resolving from, 'allow_many' is as for setup_joins().\n    If fail_on_missing is set to True, then a name that can't be resolved\n    will generate a FieldError.\n\n    Return a list of PathInfo tuples. In addition return the final field\n    (the last used join field) and target (which is a field guaranteed to\n    contain the same value as the final field). Finally, return those names\n    that weren't found (which are likely transforms and the final lookup).\n    \"\"\"\n    path, names_with_path = [], []\n    for pos, name in enumerate(names):\n        cur_names_with_path = (name, [])\n        if name == 'pk':\n            name = opts.pk.name\n\n        field = None\n        filtered_relation = None\n        try:\n            field = opts.get_field(name)\n        except FieldDoesNotExist:\n            if name in self.annotation_select:\n                field = self.annotation_select[name].output_field\n            elif name in self._filtered_relations and pos == 0:\n                filtered_relation = self._filtered_relations[name]\n                field = opts.get_field(filtered_relation.relation_name)\n",
      "\ndef names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n    \"\"\"\n    Walk the list of names and turns them into PathInfo tuples. A single\n    name in 'names' can generate multiple PathInfos (m2m, for example).\n\n    'names' is the path of names to travel, 'opts' is the model Options we\n    start the name resolving from, 'allow_many' is as for setup_joins().\n    If fail_on_missing is set to True, then a name that can't be resolved\n    will generate a FieldError.\n\n    Return a list of PathInfo tuples. In addition return the final field\n    (the last used join field) and target (which is a field guaranteed to\n    contain the same value as the final field). Finally, return those names\n    that weren't found (which are likely transforms and the final lookup).\n    \"\"\"\n    path, names_with_path = [], []\n    for pos, name in enumerate(names):\n        cur_names_with_path = (name, [])\n        if name == 'pk':\n            name = opts.pk.name\n\n        field = None\n        filtered_relation = None\n        try:\n            field = opts.get_field(name)\n        except FieldDoesNotExist:\n            if name in self.annotation_select:\n                field = self.annotation_select[name].output_field\n            elif name in self._filtered_relations and pos == 0:\n                filtered_relation = self._filtered_relations[name]\n                field = opts.get_field(filtered_relation.relation_name)\n",
      "\ndef names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n    \"\"\"\n    Walk the list of names and turns them into PathInfo tuples. A single\n    name in 'names' can generate multiple PathInfos (m2m, for example).\n\n    'names' is the path of names to travel, 'opts' is the model Options we\n    start the name resolving from, 'allow_many' is as for setup_joins().\n    If fail_on_missing is set to True, then a name that can't be resolved\n    will generate a FieldError.\n\n    Return a list of PathInfo tuples. In addition return the final field\n    (the last used join field) and target (which is a field guaranteed to\n    contain the same value as the final field). Finally, return those names\n    that weren't found (which are likely transforms and the final lookup).\n    \"\"\"\n    path, names_with_path = [], []\n    for pos, name in enumerate(names):\n        cur_names_with_path = (name, [])\n        if name == 'pk':\n            name = opts.pk.name\n\n        field = None\n        filtered_relation = None\n        try:\n            field = opts.get_field(name)\n        except FieldDoesNotExist:\n            if name in self.annotation_select:\n                field = self.annotation_select[name].output_field\n            elif name in self._filtered_relations and pos == 0:\n                filtered_relation = self._filtered_relations[name]\n                field = opts.get_field(filtered_relation.relation_name)\n",
      "\n    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n        \"\"\"\n        Walk the list of names and turns them into PathInfo tuples. A single\n        name in 'names' can generate multiple PathInfos (m2m, for example).\n\n        'names' is the path of names to travel, 'opts' is the model Options we\n        start the name resolving from, 'allow_many' is as for setup_joins().\n        If fail_on_missing is set to True, then a name that can't be resolved\n        will generate a FieldError.\n\n        Return a list of PathInfo tuples. In addition return the final field\n        (the last used join field) and target (which is a field guaranteed to\n        contain the same value as the final field). Finally, return those names\n        that weren't found (which are likely transforms and the final lookup).\n        \"\"\"\n        path, names_with_path = [], []\n        for pos, name in enumerate(names):\n            cur_names_with_path = (name, [])\n            if name == 'pk':\n                name = opts.pk.name\n\n            field = None\n            filtered_relation = None\n            try:\n                field = opts.get_field(name)\n            except FieldDoesNotExist:\n                if name in self.annotation_select:\n",
      "\ndef names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n    \"\"\"\n    Walk the list of names and turns them into PathInfo tuples. A single\n    name in 'names' can generate multiple PathInfos (m2m, for example).\n\n    'names' is the path of names to travel, 'opts' is the model Options we\n    start the name resolving from, 'allow_many' is as for setup_joins().\n    If fail_on_missing is set to True, then a name that can't be resolved\n    will generate a FieldError.\n\n    Return a list of PathInfo tuples. In addition return the final field\n    (the last used join field) and target (which is a field guaranteed to\n    contain the same value as the final field). Finally, return those names\n    that weren't found (which are likely transforms and the final lookup).\n    \"\"\"\n    path, names_with_path = [], []\n    for pos, name in enumerate(names):\n        cur_names_with_path = (name, [])\n        if name == 'pk':\n            name = opts.pk.name\n\n        field = None\n        filtered_relation = None\n        try:\n            field = opts.get_field(name)\n        except FieldDoesNotExist:\n            if name in self.annotation_select:\n                field = self.annotation_select[name].output_field\n            elif name in self._filtered_relations and pos == 0:\n                filtered_relation = self._filtered_relations[name]\n                field = opts.get_field(filtered_relation.relation_name)\n",
      "\n    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n        \"\"\"\n        Walk the list of names and turns them into PathInfo tuples. A single\n        name in 'names' can generate multiple PathInfos (m2m, for example).\n\n        'names' is the path of names to travel, 'opts' is the model Options we\n        start the name resolving from, 'allow_many' is as for setup_joins().\n        If fail_on_missing is set to True, then a name that can't be resolved\n        will generate a FieldError.\n\n        Return a list of PathInfo tuples. In addition return the final field\n        (the last used join field) and target (which is a field guaranteed to\n        contain the same value as the final field). Finally, return those names\n        that weren't found (which are likely transforms and the final lookup).\n        \"\"\"\n        path, names_with_path = [], []\n        for pos, name in enumerate(names):\n            cur_names_with_path = (name, [])\n            if name == 'pk':\n                name = opts.pk.name\n\n            field = None\n            filtered_relation = None\n            try:\n                field = opts.get_field(name)\n            except FieldDoesNotExist:\n                if name in self.annotation_select:\n",
      "\n    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n        \"\"\"\n        Walk the list of names and turns them into PathInfo tuples. A single\n        name in 'names' can generate multiple PathInfos (m2m, for example).\n\n        'names' is the path of names to travel, 'opts' is the model Options we\n        start the name resolving from, 'allow_many' is as for setup_joins().\n        If fail_on_missing is set to True, then a name that can't be resolved\n        will generate a FieldError.\n\n        Return a list of PathInfo tuples. In addition return the final field\n        (the last used join field) and target (which is a field guaranteed to\n        contain the same value as the final field). Finally, return those names\n        that weren't found (which are likely transforms and the final lookup).\n        \"\"\"\n        path, names_with_path = [], []\n        for pos, name in enumerate(names):\n            cur_names_with_path = (name, [])\n            if name == 'pk':\n                name = opts.pk.name\n\n            field = None\n            filtered_relation = None\n            try:\n                field = opts.get_field(name)\n            except FieldDoesNotExist:\n                if name in self.annotation_select:\n",
      "\n    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n        \"\"\"\n        Walk the list of names and turns them into PathInfo tuples. A single\n        name in 'names' can generate multiple PathInfos (m2m, for example).\n\n        'names' is the path of names to travel, 'opts' is the model Options we\n        start the name resolving from, 'allow_many' is as for setup_joins().\n        If fail_on_missing is set to True, then a name that can't be resolved\n        will generate a FieldError.\n\n        Return a list of PathInfo tuples. In addition return the final field\n        (the last used join field) and target (which is a field guaranteed to\n        contain the same value as the final field). Finally, return those names\n        that weren't found (which are likely transforms and the final lookup).\n        \"\"\"\n        path, names_with_path = [], []\n        for pos, name in enumerate(names):\n            cur_names_with_path = (name, [])\n            if name == 'pk':\n                name = opts.pk.name\n\n            field = None\n            filtered_relation = None\n            try:\n                field = opts.get_field(name)\n            except FieldDoesNotExist:\n                if name in self.annotation_select:\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/db/models/options.py lines 545-551)": [
      "\n    @cached_property\n    def fields_map(self):\n        res = {}\n        fields = self._get_fields(forward=False, include_hidden=True)\n        for field in fields:\n            res[field.name] = field\n            # Due to the way Django's internals work, get_field() should also\n            # be able to fetch a field by attname. In the case of a concrete\n            # field with relation, includes the *_id name too\n            try:\n                res[field.attname] = field\n            except AttributeError:\n                pass\n        return res\n",
      "\n    @cached_property\n    def fields_map(self):\n        res = {}\n        fields = self._get_fields(forward=False, include_hidden=True)\n        for field in fields:\n            res[field.name] = field\n            # Due to the way Django's internals work, get_field() should also\n            # be able to fetch a field by attname. In the case of a concrete\n            # field with relation, includes the *_id name too\n            try:\n                res[field.attname] = field\n            except AttributeError:\n                pass\n        return res\n",
      "\n    @cached_property\n    def fields_map(self):\n        res = {}\n        fields = self._get_fields(forward=False, include_hidden=True)\n        for field in fields:\n            res[field.name] = field\n            # Due to the way Django's internals work, get_field() should also\n            # be able to fetch a field by attname. In the case of a concrete\n            # field with relation, includes the *_id name too\n            try:\n                res[field.attname] = field\n            except AttributeError:\n                pass\n        return res\n",
      "\n        # Due to the way Django's internals work, get_field() should also\n        # be able to fetch a field by attname. In the case of a concrete\n        # field with relation, includes the *_id name too\n        try:\n            res[field.attname] = field\n        except AttributeError:\n            pass\n",
      "\n    @cached_property\n    def fields_map(self):\n        res = {}\n        fields = self._get_fields(forward=False, include_hidden=True)\n        for field in fields:\n            res[field.name] = field\n            # Due to the way Django's internals work, get_field() should also\n            # be able to fetch a field by attname. In the case of a concrete\n            # field with relation, includes the *_id name too\n            try:\n                res[field.attname] = field\n            except AttributeError:\n                pass\n        return res\n",
      "\n    @cached_property\n    def fields_map(self):\n        res = {}\n        fields = self._get_fields(forward=False, include_hidden=True)\n        for field in fields:\n            res[field.name] = field\n            # Due to the way Django's internals work, get_field() should also\n            # be able to fetch a field by attname. In the case of a concrete\n            # field with relation, includes the *_id name too\n            try:\n                res[field.attname] = field\n            except AttributeError:\n                pass\n        return res\n",
      "\n    @cached_property\n    def fields_map(self):\n        res = {}\n        fields = self._get_fields(forward=False, include_hidden=True)\n        for field in fields:\n            res[field.name] = field\n            # Due to the way Django's internals work, get_field() should also\n            # be able to fetch a field by attname. In the case of a concrete\n            # field with relation, includes the *_id name too\n            try:\n                res[field.attname] = field\n            except AttributeError:\n                pass\n        return res\n",
      "\n    @cached_property\n    def fields_map(self):\n        res = {}\n        fields = self._get_fields(forward=False, include_hidden=True)\n        for field in fields:\n            res[field.name] = field\n            # Due to the way Django's internals work, get_field() should also\n            # be able to fetch a field by attname. In the case of a concrete\n            # field with relation, includes the *_id name too\n            try:\n                res[field.attname] = field\n            except AttributeError:\n                pass\n        return res\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0e28b6812a..753942adee 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -542,6 +542,7 @@ class Options:\n         fields = self._get_fields(forward=False, include_hidden=True)\n         for field in fields:\n             res[field.name] = field\n+\n             # Due to the way Django's internals work, get_field() should also\n             # be able to fetch a field by attname. In the case of a concrete\n             # field with relation, includes the *_id name too\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..bf04b764a7 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -722,12 +722,14 @@ class SQLCompiler:\n         name, order = get_order_dir(name, default_order)\n         descending = order == 'DESC'\n         pieces = name.split(LOOKUP_SEP)\n+\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n \n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk' and not (pieces and pieces[-1] == getattr(field, 'attname', None)):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -748,6 +750,7 @@ class SQLCompiler:\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n+\n     def _setup_joins(self, pieces, opts, alias):\n         \"\"\"\n         Helper method for get_order_by() and get_distinct().\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..9e03690109 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1421,6 +1421,7 @@ class Query(BaseExpression):\n                 )\n         self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n+\n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n         Walk the list of names and turns them into PathInfo tuples. A single\n",
    "variant_0": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0e28b6812a..43edc6ae7c 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -536,6 +536,13 @@ class Options:\n                 pass\n         return res\n \n+    @cached_property\n+    def fields_map(self):\n+        res = {}\n+        fields = self._get_fields(forward=False, include_hidden=True)\n+        for field in fields:\n+            res[field.name] = field\n+\n     @cached_property\n     def fields_map(self):\n         res = {}\n@@ -550,6 +557,7 @@ class Options:\n             except AttributeError:\n                 pass\n         return res\n+        return res\n \n     def get_field(self, field_name):\n         \"\"\"\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..2a8ba1adf2 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -722,12 +722,42 @@ class SQLCompiler:\n         name, order = get_order_dir(name, default_order)\n         descending = order == 'DESC'\n         pieces = name.split(LOOKUP_SEP)\n-        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n+                       already_seen=None):\n+    \"\"\"\n+    Return the table alias (the name might be ambiguous, the alias will\n+    not be) and column name for ordering by the given 'name' parameter.\n+    The 'name' is of the form 'field1__field2__...__fieldN'.\n+    \"\"\"\n+    name, order = get_order_dir(name, default_order)\n+    descending = order == 'DESC'\n+    pieces = name.split(LOOKUP_SEP)\n+    field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+    # If we get to this point and the field is a relation to another model,\n+    # append the default ordering for that model unless it is the pk\n+    # shortcut or the attribute name of the field that is specified.\n+    # Also don't apply when accessing foreign key ID field directly (e.g., record__root_id)\n+    if (field.is_relation and opts.ordering and \n+        getattr(field, 'attname', None) != name and name != 'pk' and\n+        not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n+        # Firstly, avoid infinite loops.\n+        already_seen = already_seen or set()\n+        join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+        if join_tuple in already_seen:\n+            raise FieldError('Infinite loop caused by ordering.')\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n \n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -748,18 +778,19 @@ class SQLCompiler:\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n-    def _setup_joins(self, pieces, opts, alias):\n-        \"\"\"\n-        Helper method for get_order_by() and get_distinct().\n \n-        get_ordering() and get_distinct() must produce same target columns on\n-        same input, as the prefixes of get_ordering() and get_distinct() must\n-        match. Executing SQL where this is not true is an error.\n-        \"\"\"\n-        alias = alias or self.query.get_initial_alias()\n-        field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n-        alias = joins[-1]\n-        return field, targets, alias, joins, path, opts, transform_function\n+def _setup_joins(self, pieces, opts, alias):\n+    \"\"\"\n+    Helper method for get_order_by() and get_distinct().\n+\n+    get_ordering() and get_distinct() must produce same target columns on\n+    same input, as the prefixes of get_ordering() and get_distinct() must\n+    match. Executing SQL where this is not true is an error.\n+    \"\"\"\n+    alias = alias or self.query.get_initial_alias()\n+    field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n+    alias = joins[-1] if joins else alias\n+    return field, targets, alias, joins, path, opts, transform_function\n \n     def get_from_clause(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..9e03690109 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1421,6 +1421,7 @@ class Query(BaseExpression):\n                 )\n         self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n+\n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n         Walk the list of names and turns them into PathInfo tuples. A single\n",
    "variant_1": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0e28b6812a..43edc6ae7c 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -536,6 +536,13 @@ class Options:\n                 pass\n         return res\n \n+    @cached_property\n+    def fields_map(self):\n+        res = {}\n+        fields = self._get_fields(forward=False, include_hidden=True)\n+        for field in fields:\n+            res[field.name] = field\n+\n     @cached_property\n     def fields_map(self):\n         res = {}\n@@ -550,6 +557,7 @@ class Options:\n             except AttributeError:\n                 pass\n         return res\n+        return res\n \n     def get_field(self, field_name):\n         \"\"\"\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..b025a26ec5 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -712,6 +712,17 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n+                           already_seen=None):\n+        \"\"\"\n+        Return the table alias (the name might be ambiguous, the alias will\n+        not be) and column name for ordering by the given 'name' parameter.\n+        The 'name' is of the form 'field1__field2__...__fieldN'.\n+        \"\"\"\n+        name, order = get_order_dir(name, default_order)\n+        descending = order == 'DESC'\n+        pieces = name.split(LOOKUP_SEP)\n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -727,7 +738,26 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        # Also check if we're accessing a foreign key's _id field directly.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -748,6 +778,7 @@ class SQLCompiler:\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n+\n     def _setup_joins(self, pieces, opts, alias):\n         \"\"\"\n         Helper method for get_order_by() and get_distinct().\n@@ -758,7 +789,7 @@ class SQLCompiler:\n         \"\"\"\n         alias = alias or self.query.get_initial_alias()\n         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n-        alias = joins[-1]\n+        alias = joins[-1] if joins else alias\n         return field, targets, alias, joins, path, opts, transform_function\n \n     def get_from_clause(self):\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..91998fc19d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1421,33 +1421,38 @@ class Query(BaseExpression):\n                 )\n         self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n-    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n-        \"\"\"\n-        Walk the list of names and turns them into PathInfo tuples. A single\n-        name in 'names' can generate multiple PathInfos (m2m, for example).\n-\n-        'names' is the path of names to travel, 'opts' is the model Options we\n-        start the name resolving from, 'allow_many' is as for setup_joins().\n-        If fail_on_missing is set to True, then a name that can't be resolved\n-        will generate a FieldError.\n-\n-        Return a list of PathInfo tuples. In addition return the final field\n-        (the last used join field) and target (which is a field guaranteed to\n-        contain the same value as the final field). Finally, return those names\n-        that weren't found (which are likely transforms and the final lookup).\n-        \"\"\"\n-        path, names_with_path = [], []\n-        for pos, name in enumerate(names):\n-            cur_names_with_path = (name, [])\n-            if name == 'pk':\n-                name = opts.pk.name\n \n-            field = None\n-            filtered_relation = None\n-            try:\n-                field = opts.get_field(name)\n-            except FieldDoesNotExist:\n-                if name in self.annotation_select:\n+def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n+    \"\"\"\n+    Walk the list of names and turns them into PathInfo tuples. A single\n+    name in 'names' can generate multiple PathInfos (m2m, for example).\n+\n+    'names' is the path of names to travel, 'opts' is the model Options we\n+    start the name resolving from, 'allow_many' is as for setup_joins().\n+    If fail_on_missing is set to True, then a name that can't be resolved\n+    will generate a FieldError.\n+\n+    Return a list of PathInfo tuples. In addition return the final field\n+    (the last used join field) and target (which is a field guaranteed to\n+    contain the same value as the final field). Finally, return those names\n+    that weren't found (which are likely transforms and the final lookup).\n+    \"\"\"\n+    path, names_with_path = [], []\n+    for pos, name in enumerate(names):\n+        cur_names_with_path = (name, [])\n+        if name == 'pk':\n+            name = opts.pk.name\n+\n+        field = None\n+        filtered_relation = None\n+        try:\n+            field = opts.get_field(name)\n+        except FieldDoesNotExist:\n+            if name in self.annotation_select:\n+                field = self.annotation_select[name].output_field\n+            elif name in self._filtered_relations and pos == 0:\n+                filtered_relation = self._filtered_relations[name]\n+                field = opts.get_field(filtered_relation.relation_name)\n                     field = self.annotation_select[name].output_field\n                 elif name in self._filtered_relations and pos == 0:\n                     filtered_relation = self._filtered_relations[name]\n",
    "variant_2": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0e28b6812a..43edc6ae7c 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -536,6 +536,13 @@ class Options:\n                 pass\n         return res\n \n+    @cached_property\n+    def fields_map(self):\n+        res = {}\n+        fields = self._get_fields(forward=False, include_hidden=True)\n+        for field in fields:\n+            res[field.name] = field\n+\n     @cached_property\n     def fields_map(self):\n         res = {}\n@@ -550,6 +557,7 @@ class Options:\n             except AttributeError:\n                 pass\n         return res\n+        return res\n \n     def get_field(self, field_name):\n         \"\"\"\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..0a614d1cbb 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -712,6 +712,17 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n+                           already_seen=None):\n+        \"\"\"\n+        Return the table alias (the name might be ambiguous, the alias will\n+        not be) and column name for ordering by the given 'name' parameter.\n+        The 'name' is of the form 'field1__field2__...__fieldN'.\n+        \"\"\"\n+        name, order = get_order_dir(name, default_order)\n+        descending = order == 'DESC'\n+        pieces = name.split(LOOKUP_SEP)\n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -727,7 +738,26 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        # Also skip if we're accessing a foreign key's _id field directly.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -748,6 +778,7 @@ class SQLCompiler:\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n+\n     def _setup_joins(self, pieces, opts, alias):\n         \"\"\"\n         Helper method for get_order_by() and get_distinct().\n@@ -758,7 +789,7 @@ class SQLCompiler:\n         \"\"\"\n         alias = alias or self.query.get_initial_alias()\n         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n-        alias = joins[-1]\n+        alias = joins[-1] if joins else alias\n         return field, targets, alias, joins, path, opts, transform_function\n \n     def get_from_clause(self):\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..91998fc19d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1421,33 +1421,38 @@ class Query(BaseExpression):\n                 )\n         self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n-    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n-        \"\"\"\n-        Walk the list of names and turns them into PathInfo tuples. A single\n-        name in 'names' can generate multiple PathInfos (m2m, for example).\n-\n-        'names' is the path of names to travel, 'opts' is the model Options we\n-        start the name resolving from, 'allow_many' is as for setup_joins().\n-        If fail_on_missing is set to True, then a name that can't be resolved\n-        will generate a FieldError.\n-\n-        Return a list of PathInfo tuples. In addition return the final field\n-        (the last used join field) and target (which is a field guaranteed to\n-        contain the same value as the final field). Finally, return those names\n-        that weren't found (which are likely transforms and the final lookup).\n-        \"\"\"\n-        path, names_with_path = [], []\n-        for pos, name in enumerate(names):\n-            cur_names_with_path = (name, [])\n-            if name == 'pk':\n-                name = opts.pk.name\n \n-            field = None\n-            filtered_relation = None\n-            try:\n-                field = opts.get_field(name)\n-            except FieldDoesNotExist:\n-                if name in self.annotation_select:\n+def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n+    \"\"\"\n+    Walk the list of names and turns them into PathInfo tuples. A single\n+    name in 'names' can generate multiple PathInfos (m2m, for example).\n+\n+    'names' is the path of names to travel, 'opts' is the model Options we\n+    start the name resolving from, 'allow_many' is as for setup_joins().\n+    If fail_on_missing is set to True, then a name that can't be resolved\n+    will generate a FieldError.\n+\n+    Return a list of PathInfo tuples. In addition return the final field\n+    (the last used join field) and target (which is a field guaranteed to\n+    contain the same value as the final field). Finally, return those names\n+    that weren't found (which are likely transforms and the final lookup).\n+    \"\"\"\n+    path, names_with_path = [], []\n+    for pos, name in enumerate(names):\n+        cur_names_with_path = (name, [])\n+        if name == 'pk':\n+            name = opts.pk.name\n+\n+        field = None\n+        filtered_relation = None\n+        try:\n+            field = opts.get_field(name)\n+        except FieldDoesNotExist:\n+            if name in self.annotation_select:\n+                field = self.annotation_select[name].output_field\n+            elif name in self._filtered_relations and pos == 0:\n+                filtered_relation = self._filtered_relations[name]\n+                field = opts.get_field(filtered_relation.relation_name)\n                     field = self.annotation_select[name].output_field\n                 elif name in self._filtered_relations and pos == 0:\n                     filtered_relation = self._filtered_relations[name]\n",
    "variant_3": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0e28b6812a..43edc6ae7c 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -536,6 +536,13 @@ class Options:\n                 pass\n         return res\n \n+    @cached_property\n+    def fields_map(self):\n+        res = {}\n+        fields = self._get_fields(forward=False, include_hidden=True)\n+        for field in fields:\n+            res[field.name] = field\n+\n     @cached_property\n     def fields_map(self):\n         res = {}\n@@ -550,6 +557,7 @@ class Options:\n             except AttributeError:\n                 pass\n         return res\n+        return res\n \n     def get_field(self, field_name):\n         \"\"\"\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..7aaa7ea76b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -722,12 +722,42 @@ class SQLCompiler:\n         name, order = get_order_dir(name, default_order)\n         descending = order == 'DESC'\n         pieces = name.split(LOOKUP_SEP)\n-        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n+                       already_seen=None):\n+    \"\"\"\n+    Return the table alias (the name might be ambiguous, the alias will\n+    not be) and column name for ordering by the given 'name' parameter.\n+    The 'name' is of the form 'field1__field2__...__fieldN'.\n+    \"\"\"\n+    name, order = get_order_dir(name, default_order)\n+    descending = order == 'DESC'\n+    pieces = name.split(LOOKUP_SEP)\n+    field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+    # If we get to this point and the field is a relation to another model,\n+    # append the default ordering for that model unless it is the pk\n+    # shortcut or the attribute name of the field that is specified.\n+    # Also avoid applying default ordering when accessing foreign key ID fields directly.\n+    if (field.is_relation and opts.ordering and \n+        getattr(field, 'attname', None) != name and name != 'pk' and\n+        not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n+        # Firstly, avoid infinite loops.\n+        already_seen = already_seen or set()\n+        join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+        if join_tuple in already_seen:\n+            raise FieldError('Infinite loop caused by ordering.')\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n \n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -748,6 +778,7 @@ class SQLCompiler:\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n+\n     def _setup_joins(self, pieces, opts, alias):\n         \"\"\"\n         Helper method for get_order_by() and get_distinct().\n@@ -758,7 +789,7 @@ class SQLCompiler:\n         \"\"\"\n         alias = alias or self.query.get_initial_alias()\n         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n-        alias = joins[-1]\n+        alias = joins[-1] if joins else alias\n         return field, targets, alias, joins, path, opts, transform_function\n \n     def get_from_clause(self):\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..91998fc19d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1421,33 +1421,38 @@ class Query(BaseExpression):\n                 )\n         self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n-    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n-        \"\"\"\n-        Walk the list of names and turns them into PathInfo tuples. A single\n-        name in 'names' can generate multiple PathInfos (m2m, for example).\n-\n-        'names' is the path of names to travel, 'opts' is the model Options we\n-        start the name resolving from, 'allow_many' is as for setup_joins().\n-        If fail_on_missing is set to True, then a name that can't be resolved\n-        will generate a FieldError.\n-\n-        Return a list of PathInfo tuples. In addition return the final field\n-        (the last used join field) and target (which is a field guaranteed to\n-        contain the same value as the final field). Finally, return those names\n-        that weren't found (which are likely transforms and the final lookup).\n-        \"\"\"\n-        path, names_with_path = [], []\n-        for pos, name in enumerate(names):\n-            cur_names_with_path = (name, [])\n-            if name == 'pk':\n-                name = opts.pk.name\n \n-            field = None\n-            filtered_relation = None\n-            try:\n-                field = opts.get_field(name)\n-            except FieldDoesNotExist:\n-                if name in self.annotation_select:\n+def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n+    \"\"\"\n+    Walk the list of names and turns them into PathInfo tuples. A single\n+    name in 'names' can generate multiple PathInfos (m2m, for example).\n+\n+    'names' is the path of names to travel, 'opts' is the model Options we\n+    start the name resolving from, 'allow_many' is as for setup_joins().\n+    If fail_on_missing is set to True, then a name that can't be resolved\n+    will generate a FieldError.\n+\n+    Return a list of PathInfo tuples. In addition return the final field\n+    (the last used join field) and target (which is a field guaranteed to\n+    contain the same value as the final field). Finally, return those names\n+    that weren't found (which are likely transforms and the final lookup).\n+    \"\"\"\n+    path, names_with_path = [], []\n+    for pos, name in enumerate(names):\n+        cur_names_with_path = (name, [])\n+        if name == 'pk':\n+            name = opts.pk.name\n+\n+        field = None\n+        filtered_relation = None\n+        try:\n+            field = opts.get_field(name)\n+        except FieldDoesNotExist:\n+            if name in self.annotation_select:\n+                field = self.annotation_select[name].output_field\n+            elif name in self._filtered_relations and pos == 0:\n+                filtered_relation = self._filtered_relations[name]\n+                field = opts.get_field(filtered_relation.relation_name)\n                     field = self.annotation_select[name].output_field\n                 elif name in self._filtered_relations and pos == 0:\n                     filtered_relation = self._filtered_relations[name]\n",
    "variant_4": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0e28b6812a..d9d4b27868 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -542,13 +542,14 @@ class Options:\n         fields = self._get_fields(forward=False, include_hidden=True)\n         for field in fields:\n             res[field.name] = field\n-            # Due to the way Django's internals work, get_field() should also\n-            # be able to fetch a field by attname. In the case of a concrete\n-            # field with relation, includes the *_id name too\n-            try:\n-                res[field.attname] = field\n-            except AttributeError:\n-                pass\n+\n+        # Due to the way Django's internals work, get_field() should also\n+        # be able to fetch a field by attname. In the case of a concrete\n+        # field with relation, includes the *_id name too\n+        try:\n+            res[field.attname] = field\n+        except AttributeError:\n+            pass\n         return res\n \n     def get_field(self, field_name):\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..5fb42596e9 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -722,12 +722,42 @@ class SQLCompiler:\n         name, order = get_order_dir(name, default_order)\n         descending = order == 'DESC'\n         pieces = name.split(LOOKUP_SEP)\n-        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n+                       already_seen=None):\n+    \"\"\"\n+    Return the table alias (the name might be ambiguous, the alias will\n+    not be) and column name for ordering by the given 'name' parameter.\n+    The 'name' is of the form 'field1__field2__...__fieldN'.\n+    \"\"\"\n+    name, order = get_order_dir(name, default_order)\n+    descending = order == 'DESC'\n+    pieces = name.split(LOOKUP_SEP)\n+    field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+    # If we get to this point and the field is a relation to another model,\n+    # append the default ordering for that model unless it is the pk\n+    # shortcut or the attribute name of the field that is specified.\n+    # Also skip if the lookup refers to a foreign key's _id attribute directly.\n+    if (field.is_relation and opts.ordering and \n+        getattr(field, 'attname', None) != name and name != 'pk' and\n+        not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n+        # Firstly, avoid infinite loops.\n+        already_seen = already_seen or set()\n+        join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+        if join_tuple in already_seen:\n+            raise FieldError('Infinite loop caused by ordering.')\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n \n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -748,18 +778,19 @@ class SQLCompiler:\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n-    def _setup_joins(self, pieces, opts, alias):\n-        \"\"\"\n-        Helper method for get_order_by() and get_distinct().\n \n-        get_ordering() and get_distinct() must produce same target columns on\n-        same input, as the prefixes of get_ordering() and get_distinct() must\n-        match. Executing SQL where this is not true is an error.\n-        \"\"\"\n-        alias = alias or self.query.get_initial_alias()\n-        field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n-        alias = joins[-1]\n-        return field, targets, alias, joins, path, opts, transform_function\n+def _setup_joins(self, pieces, opts, alias):\n+    \"\"\"\n+    Helper method for get_order_by() and get_distinct().\n+\n+    get_ordering() and get_distinct() must produce same target columns on\n+    same input, as the prefixes of get_ordering() and get_distinct() must\n+    match. Executing SQL where this is not true is an error.\n+    \"\"\"\n+    alias = alias or self.query.get_initial_alias()\n+    field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n+    alias = joins[-1] if joins else alias\n+    return field, targets, alias, joins, path, opts, transform_function\n \n     def get_from_clause(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..9e03690109 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1421,6 +1421,7 @@ class Query(BaseExpression):\n                 )\n         self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n+\n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n         Walk the list of names and turns them into PathInfo tuples. A single\n",
    "variant_5": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0e28b6812a..43edc6ae7c 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -536,6 +536,13 @@ class Options:\n                 pass\n         return res\n \n+    @cached_property\n+    def fields_map(self):\n+        res = {}\n+        fields = self._get_fields(forward=False, include_hidden=True)\n+        for field in fields:\n+            res[field.name] = field\n+\n     @cached_property\n     def fields_map(self):\n         res = {}\n@@ -550,6 +557,7 @@ class Options:\n             except AttributeError:\n                 pass\n         return res\n+        return res\n \n     def get_field(self, field_name):\n         \"\"\"\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..e37c27390a 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -712,6 +712,17 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n+                           already_seen=None):\n+        \"\"\"\n+        Return the table alias (the name might be ambiguous, the alias will\n+        not be) and column name for ordering by the given 'name' parameter.\n+        The 'name' is of the form 'field1__field2__...__fieldN'.\n+        \"\"\"\n+        name, order = get_order_dir(name, default_order)\n+        descending = order == 'DESC'\n+        pieces = name.split(LOOKUP_SEP)\n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -727,7 +738,26 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        # Also avoid applying default ordering when accessing foreign key ID fields directly.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -748,18 +778,19 @@ class SQLCompiler:\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n-    def _setup_joins(self, pieces, opts, alias):\n-        \"\"\"\n-        Helper method for get_order_by() and get_distinct().\n \n-        get_ordering() and get_distinct() must produce same target columns on\n-        same input, as the prefixes of get_ordering() and get_distinct() must\n-        match. Executing SQL where this is not true is an error.\n-        \"\"\"\n-        alias = alias or self.query.get_initial_alias()\n-        field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n-        alias = joins[-1]\n-        return field, targets, alias, joins, path, opts, transform_function\n+def _setup_joins(self, pieces, opts, alias):\n+    \"\"\"\n+    Helper method for get_order_by() and get_distinct().\n+\n+    get_ordering() and get_distinct() must produce same target columns on\n+    same input, as the prefixes of get_ordering() and get_distinct() must\n+    match. Executing SQL where this is not true is an error.\n+    \"\"\"\n+    alias = alias or self.query.get_initial_alias()\n+    field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n+    alias = joins[-1] if joins else alias\n+    return field, targets, alias, joins, path, opts, transform_function\n \n     def get_from_clause(self):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..91998fc19d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1421,33 +1421,38 @@ class Query(BaseExpression):\n                 )\n         self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n-    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n-        \"\"\"\n-        Walk the list of names and turns them into PathInfo tuples. A single\n-        name in 'names' can generate multiple PathInfos (m2m, for example).\n-\n-        'names' is the path of names to travel, 'opts' is the model Options we\n-        start the name resolving from, 'allow_many' is as for setup_joins().\n-        If fail_on_missing is set to True, then a name that can't be resolved\n-        will generate a FieldError.\n-\n-        Return a list of PathInfo tuples. In addition return the final field\n-        (the last used join field) and target (which is a field guaranteed to\n-        contain the same value as the final field). Finally, return those names\n-        that weren't found (which are likely transforms and the final lookup).\n-        \"\"\"\n-        path, names_with_path = [], []\n-        for pos, name in enumerate(names):\n-            cur_names_with_path = (name, [])\n-            if name == 'pk':\n-                name = opts.pk.name\n \n-            field = None\n-            filtered_relation = None\n-            try:\n-                field = opts.get_field(name)\n-            except FieldDoesNotExist:\n-                if name in self.annotation_select:\n+def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n+    \"\"\"\n+    Walk the list of names and turns them into PathInfo tuples. A single\n+    name in 'names' can generate multiple PathInfos (m2m, for example).\n+\n+    'names' is the path of names to travel, 'opts' is the model Options we\n+    start the name resolving from, 'allow_many' is as for setup_joins().\n+    If fail_on_missing is set to True, then a name that can't be resolved\n+    will generate a FieldError.\n+\n+    Return a list of PathInfo tuples. In addition return the final field\n+    (the last used join field) and target (which is a field guaranteed to\n+    contain the same value as the final field). Finally, return those names\n+    that weren't found (which are likely transforms and the final lookup).\n+    \"\"\"\n+    path, names_with_path = [], []\n+    for pos, name in enumerate(names):\n+        cur_names_with_path = (name, [])\n+        if name == 'pk':\n+            name = opts.pk.name\n+\n+        field = None\n+        filtered_relation = None\n+        try:\n+            field = opts.get_field(name)\n+        except FieldDoesNotExist:\n+            if name in self.annotation_select:\n+                field = self.annotation_select[name].output_field\n+            elif name in self._filtered_relations and pos == 0:\n+                filtered_relation = self._filtered_relations[name]\n+                field = opts.get_field(filtered_relation.relation_name)\n                     field = self.annotation_select[name].output_field\n                 elif name in self._filtered_relations and pos == 0:\n                     filtered_relation = self._filtered_relations[name]\n",
    "variant_6": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0e28b6812a..43edc6ae7c 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -536,6 +536,13 @@ class Options:\n                 pass\n         return res\n \n+    @cached_property\n+    def fields_map(self):\n+        res = {}\n+        fields = self._get_fields(forward=False, include_hidden=True)\n+        for field in fields:\n+            res[field.name] = field\n+\n     @cached_property\n     def fields_map(self):\n         res = {}\n@@ -550,6 +557,7 @@ class Options:\n             except AttributeError:\n                 pass\n         return res\n+        return res\n \n     def get_field(self, field_name):\n         \"\"\"\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..0a614d1cbb 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -712,6 +712,17 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n+                           already_seen=None):\n+        \"\"\"\n+        Return the table alias (the name might be ambiguous, the alias will\n+        not be) and column name for ordering by the given 'name' parameter.\n+        The 'name' is of the form 'field1__field2__...__fieldN'.\n+        \"\"\"\n+        name, order = get_order_dir(name, default_order)\n+        descending = order == 'DESC'\n+        pieces = name.split(LOOKUP_SEP)\n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -727,7 +738,26 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        # Also skip if we're accessing a foreign key's _id field directly.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -748,6 +778,7 @@ class SQLCompiler:\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n+\n     def _setup_joins(self, pieces, opts, alias):\n         \"\"\"\n         Helper method for get_order_by() and get_distinct().\n@@ -758,7 +789,7 @@ class SQLCompiler:\n         \"\"\"\n         alias = alias or self.query.get_initial_alias()\n         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n-        alias = joins[-1]\n+        alias = joins[-1] if joins else alias\n         return field, targets, alias, joins, path, opts, transform_function\n \n     def get_from_clause(self):\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..9e03690109 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1421,6 +1421,7 @@ class Query(BaseExpression):\n                 )\n         self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n+\n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n         Walk the list of names and turns them into PathInfo tuples. A single\n",
    "variant_7": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0e28b6812a..43edc6ae7c 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -536,6 +536,13 @@ class Options:\n                 pass\n         return res\n \n+    @cached_property\n+    def fields_map(self):\n+        res = {}\n+        fields = self._get_fields(forward=False, include_hidden=True)\n+        for field in fields:\n+            res[field.name] = field\n+\n     @cached_property\n     def fields_map(self):\n         res = {}\n@@ -550,6 +557,7 @@ class Options:\n             except AttributeError:\n                 pass\n         return res\n+        return res\n \n     def get_field(self, field_name):\n         \"\"\"\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..6ccf2ccc66 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -712,6 +712,17 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n+                           already_seen=None):\n+        \"\"\"\n+        Return the table alias (the name might be ambiguous, the alias will\n+        not be) and column name for ordering by the given 'name' parameter.\n+        The 'name' is of the form 'field1__field2__...__fieldN'.\n+        \"\"\"\n+        name, order = get_order_dir(name, default_order)\n+        descending = order == 'DESC'\n+        pieces = name.split(LOOKUP_SEP)\n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -727,7 +738,26 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        # Also avoid applying default ordering when accessing foreign key ID fields directly.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -748,6 +778,7 @@ class SQLCompiler:\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n+\n     def _setup_joins(self, pieces, opts, alias):\n         \"\"\"\n         Helper method for get_order_by() and get_distinct().\n@@ -758,7 +789,7 @@ class SQLCompiler:\n         \"\"\"\n         alias = alias or self.query.get_initial_alias()\n         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n-        alias = joins[-1]\n+        alias = joins[-1] if joins else alias\n         return field, targets, alias, joins, path, opts, transform_function\n \n     def get_from_clause(self):\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..9e03690109 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1421,6 +1421,7 @@ class Query(BaseExpression):\n                 )\n         self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n+\n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n         Walk the list of names and turns them into PathInfo tuples. A single\n",
    "variant_8": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 0e28b6812a..43edc6ae7c 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -536,6 +536,13 @@ class Options:\n                 pass\n         return res\n \n+    @cached_property\n+    def fields_map(self):\n+        res = {}\n+        fields = self._get_fields(forward=False, include_hidden=True)\n+        for field in fields:\n+            res[field.name] = field\n+\n     @cached_property\n     def fields_map(self):\n         res = {}\n@@ -550,6 +557,7 @@ class Options:\n             except AttributeError:\n                 pass\n         return res\n+        return res\n \n     def get_field(self, field_name):\n         \"\"\"\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb..56f3b27786 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -712,6 +712,17 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n+                           already_seen=None):\n+        \"\"\"\n+        Return the table alias (the name might be ambiguous, the alias will\n+        not be) and column name for ordering by the given 'name' parameter.\n+        The 'name' is of the form 'field1__field2__...__fieldN'.\n+        \"\"\"\n+        name, order = get_order_dir(name, default_order)\n+        descending = order == 'DESC'\n+        pieces = name.split(LOOKUP_SEP)\n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -727,7 +738,26 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        # Also skip if we're accessing a foreign key's _id attribute directly.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless it is the pk\n+        # shortcut or the attribute name of the field that is specified.\n+        if (field.is_relation and opts.ordering and \n+            getattr(field, 'attname', None) != name and name != 'pk' and\n+            not (pieces and pieces[-1] == getattr(field, 'attname', None))):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n@@ -748,6 +778,7 @@ class SQLCompiler:\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n \n+\n     def _setup_joins(self, pieces, opts, alias):\n         \"\"\"\n         Helper method for get_order_by() and get_distinct().\n@@ -758,7 +789,7 @@ class SQLCompiler:\n         \"\"\"\n         alias = alias or self.query.get_initial_alias()\n         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n-        alias = joins[-1]\n+        alias = joins[-1] if joins else alias\n         return field, targets, alias, joins, path, opts, transform_function\n \n     def get_from_clause(self):\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..9e03690109 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1421,6 +1421,7 @@ class Query(BaseExpression):\n                 )\n         self._filtered_relations[filtered_relation.alias] = filtered_relation\n \n+\n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n         Walk the list of names and turns them into PathInfo tuples. A single\n"
  }
}