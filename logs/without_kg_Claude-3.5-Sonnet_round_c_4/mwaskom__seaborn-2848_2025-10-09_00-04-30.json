{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/seaborn/seaborn/_core/rules.py lines 125-153)": "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter out null values from provided order, matching old behavior\n        order = list(filter(pd.notnull, order))\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
    "Location 2 (/root/hy/projects_4/seaborn/seaborn/_core/groupby.py lines 47-67)": "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Input data.\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = list(filter(pd.notnull, pd.Series(vector).unique()))\n    else:\n        # Validate that provided order values exist in the data\n        # and filter out null values to match old behavior\n        order = list(filter(pd.notnull, order))\n        \n    if order:\n        return order\n    else:\n        return list(filter(pd.notnull, pd.Series(vector).unique()))\n",
    "Location 3 (/root/hy/projects_4/seaborn/seaborn/_core/plot.py lines 990-994)": "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` objects.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector, dtype=object).unique()\n    else:\n        order = pd.Series(order, dtype=object)\n        # Validate that provided order values exist in the data\n        data_values = pd.Series(vector, dtype=object)\n        valid_order = []\n        for val in order:\n            if val in data_values.values:\n                valid_order.append(val)\n        order = valid_order\n\n    # Filter out null values, matching old implementation behavior\n    order = filter(pd.notnull, order)\n    return list(order)\n",
    "Location 4 (/root/hy/projects_4/seaborn/seaborn/_core/plot.py lines 1129-1133)": "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter the provided order to only include values present in the data\n        # This maintains backward compatibility with the old implementation\n        # and prevents unmapped values from causing downstream errors\n        order = filter(pd.notnull, order)\n        return list(order)\n\n    if vector is None:\n        return []\n\n    # Handle scalar values\n    if np.isscalar(vector):\n        return [vector] if pd.notnull(vector) else []\n\n    vector = pd.Series(vector, dtype=object)\n    if vector.isna().all():\n        return []\n\n    # Use pandas categorical ordering if available, otherwise preserve order of appearance\n    if hasattr(vector, \"cat\"):\n        order = vector.cat.categories\n    else:\n        order = vector.drop_duplicates()\n\n    order = filter(pd.notnull, order)\n    return list(order)\n",
    "Location 5 (/root/hy/projects_4/seaborn/seaborn/_oldcore.py lines 1712-1748)": "\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values using an ordering given by the data.\n\n    When the vector is a pandas Categorical or has a \"categories\" attribute,\n    the order of the categories will be used. Otherwise, the unique values\n    will be determined and, if the data appear to be numeric, they will be\n    sorted. Any null values are filtered out.\n\n    Parameters\n    ----------\n    vector : list, array, Categorical, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the ``values`` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        if hasattr(vector, \"categories\"):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n\n                try:\n                    order = vector.unique()\n                except AttributeError:\n                    order = pd.unique(vector)\n\n                if variable_type(vector) == \"numeric\":\n                    order = np.sort(order)\n\n    # Always filter out null values, even when order is provided\n    # This maintains backward compatibility and prevents downstream errors\n    order = filter(pd.notnull, order)\n    return list(order)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/seaborn/seaborn/_core/rules.py lines 125-153)": [
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter out null values from provided order, matching old behavior\n        order = list(filter(pd.notnull, order))\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter out null values from provided order, matching old behavior\n        order = list(filter(pd.notnull, order))\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter out null values from provided order, similar to old implementation\n        order = list(filter(pd.notnull, order))\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter out null values from provided order, matching old behavior\n        order = list(filter(pd.notnull, order))\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter out null values from provided order, matching old behavior\n        order = list(filter(pd.notnull, order))\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter out null values from provided order, matching old behavior\n        order = list(filter(pd.notnull, order))\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter out null values from provided order, matching old behavior\n        order = list(filter(pd.notnull, order))\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter out null values from provided order, matching old behavior\n        order = list(filter(pd.notnull, order))\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(order) == \"numeric\":\n            order.sort()\n\n    return order\n"
    ],
    "Location 2 (/root/hy/projects_4/seaborn/seaborn/_core/groupby.py lines 47-67)": [
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector, dtype=\"category\").cat.categories\n    else:\n        # Validate that provided order values exist in the data\n        # and filter out any null values, similar to old implementation\n        order = pd.Series(order, dtype=\"category\").cat.categories\n        # Only keep order values that actually exist in the vector\n        vector_categories = pd.Series(vector, dtype=\"category\").cat.categories\n        order = [x for x in order if x in vector_categories]\n    \n    # Filter out null values from the final order\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `vector` values.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector).unique()\n    else:\n        # Validate provided order against actual data\n        # Filter out any order values that don't exist in the vector\n        vector_series = pd.Series(vector)\n        valid_values = set(vector_series.dropna().unique())\n        order = [val for val in order if val in valid_values]\n    \n    # Always filter out null values, similar to old implementation\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        if hasattr(vector, \"cat\"):\n            order = vector.cat.categories\n        else:\n            try:\n                order = vector.unique()\n            except AttributeError:\n                order = pd.unique(vector)\n            if variable_type(vector) == \"numeric\":\n                order = np.sort(order)\n        order = filter(pd.notnull, order)\n        return list(order)\n    else:\n        # Validate the provided order against the actual data\n        # Filter out null values and values not present in the data\n        if hasattr(vector, \"cat\"):\n            data_values = set(vector.cat.categories)\n        else:\n            try:\n                data_values = set(vector.unique())\n            except AttributeError:\n                data_values = set(pd.unique(vector))\n        \n        # Filter the order to only include non-null values that exist in the data\n        filtered_order = [x for x in order if pd.notnull(x) and x in data_values]\n        return filtered_order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = vector.unique()\n    else:\n        order = filter(pd.notnull, order)\n    return list(filter(pd.notnull, order))\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector, dtype=object).unique()\n    else:\n        order = pd.Series(order, dtype=object)\n        # Filter order to only include values present in the data\n        vector_set = set(pd.Series(vector, dtype=object).dropna())\n        order = order[order.isin(vector_set)]\n    \n    # Always filter out null values, even when order is provided\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector, dtype=\"category\").cat.categories\n    else:\n        # Validate that provided order values exist in the data\n        # and filter out any null values, matching old implementation behavior\n        data_values = set(pd.Series(vector).dropna().unique())\n        order = [x for x in order if pd.notnull(x) and x in data_values]\n    \n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector).unique()\n    else:\n        # Validate that provided order values exist in the data\n        # This maintains compatibility with old behavior where subset orders\n        # were validated against actual data\n        data_values = set(pd.Series(vector).dropna().unique())\n        order = [x for x in order if x in data_values]\n    \n    # Always filter out null values, even when order is provided\n    # This matches the old implementation behavior\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector).unique()\n    else:\n        # Validate that provided order values exist in the data\n        vector_vals = set(pd.Series(vector).dropna().unique())\n        order = [x for x in order if x in vector_vals]\n    \n    # Always filter out null values, consistent with old implementation\n    order = filter(pd.notnull, order)\n    return list(order)\n"
    ],
    "Location 3 (/root/hy/projects_4/seaborn/seaborn/_core/plot.py lines 990-994)": [
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Validate and filter the provided order against actual data\n        # This matches the behavior of the old implementation\n        order = filter(pd.notnull, order)\n        return list(order)\n    \n    if vector.dtype.name == \"category\":\n        order = vector.cat.categories\n    else:\n        try:\n            order = vector.unique()\n        except TypeError:\n            order = vector.drop_duplicates()\n\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = vector.dropna().unique()\n        if vector.dtype.name == \"category\":\n            # Handle categorical data, respecting existing order\n            order = vector.cat.remove_unused_categories().cat.categories\n        elif vector.dtype.name in [\"object\", \"string\"]:\n            # Handle object/string data, sort if possible\n            try:\n                order = natsort.natsorted(order, alg=natsort.ns.PATH)\n            except (TypeError, AttributeError):\n                order = sorted(order)\n        else:\n            # Handle numeric data\n            order = sorted(order)\n    else:\n        # Even when order is provided, validate and filter like the old implementation\n        # This ensures subset orders don't cause downstream isnan errors\n        order = filter(pd.notnull, order)\n\n    return list(order)\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = vector.dropna().unique()\n    else:\n        # Validate order against actual data and filter out nulls\n        # This maintains backward compatibility with the old implementation\n        order = filter(pd.notnull, order)\n    \n    return list(order)\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = vector.unique()\n    else:\n        # Validate that all provided order values exist in the data\n        # and filter out any that don't (similar to old implementation)\n        valid_values = set(vector.dropna().unique())\n        order = [x for x in order if x in valid_values]\n    \n    # Always filter out null values, even from provided order\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector, dtype=object).unique()\n    elif len(order) < len(pd.Series(vector, dtype=object).unique()):\n        # When a subset order is provided, validate it against actual data\n        # and filter out any null values to prevent downstream errors\n        order = filter(pd.notnull, order)\n    else:\n        # For complete orders, still filter out nulls for consistency\n        order = filter(pd.notnull, order)\n    \n    return list(order)\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = list(filter(pd.notnull, vector.unique()))\n    else:\n        # Validate and filter the provided order against actual data\n        # This ensures subset orders work correctly and prevents unmapped values\n        data_values = set(filter(pd.notnull, vector.dropna().unique()))\n        order = list(filter(lambda x: pd.notnull(x) and x in data_values, order))\n    \n    return order\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = list(filter(pd.notnull, vector.unique()))\n    else:\n        # Even when order is provided, we need to validate it against the data\n        # and filter out any null values to maintain compatibility with old behavior\n        order = list(filter(pd.notnull, order))\n    \n    return order\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Unique values in the data, in the proper order for plotting.\n\n    \"\"\"\n    if order is not None:\n        # Validate the order against actual data values to prevent unmapped values\n        # Filter out any values in the order that don't exist in the data\n        valid_values = set(vector.dropna().unique())\n        order = [x for x in order if x in valid_values]\n        # Also filter out any NaN/None values as in the old implementation\n        order = list(filter(pd.notnull, order))\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = vector.cat.categories\n    else:\n        try:\n            order = vector.unique()\n        except TypeError:\n            order = pd.unique(vector.dropna())\n\n    order = filter(pd.notnull, order)\n    return list(order)\n"
    ],
    "Location 4 (/root/hy/projects_4/seaborn/seaborn/_core/plot.py lines 1129-1133)": [
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = list(filter(pd.notnull, vector.unique()))\n    else:\n        # Validate the provided order by filtering out values not in the data\n        # and removing null values, similar to the old implementation\n        vector_vals = set(filter(pd.notnull, vector.dropna().unique()))\n        order = [x for x in order if pd.notnull(x) and x in vector_vals]\n    \n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector, dtype=object).unique()\n    else:\n        # Validate that provided order values exist in the data\n        unique_vals = pd.Series(vector, dtype=object).unique()\n        # Filter out null values from the order, matching old behavior\n        order = [x for x in order if pd.notnull(x) and x in unique_vals]\n    \n    # Always filter out null values from the final order\n    order = [x for x in order if pd.notnull(x)]\n    return list(order)\n",
      "\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n\n    if order is None:\n        order = vector.drop_duplicates()\n        if vector.dtype.name == \"category\":\n            order = vector.cat.categories\n        try:\n            order = order.sort_values()\n        except TypeError:\n            pass\n    else:\n        # Validate that the provided order exists in the data\n        # This matches the old implementation behavior\n        order = pd.Series(order, dtype=vector.dtype)\n        # Filter out null values, similar to old implementation\n        order = order.dropna()\n        # Only keep order values that actually exist in the data\n        if not order.empty:\n            existing_values = set(vector.dropna().unique())\n            order = order[order.isin(existing_values)]\n    \n    # Convert to list and filter nulls (matching old implementation line 1747)\n    order = [x for x in order if pd.notnull(x)]\n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector, dtype=\"category\").cat.categories\n    else:\n        order = pd.CategoricalIndex(order, categories=order).categories\n    \n    # Always filter out null values, even when order is provided\n    # This maintains compatibility with the old implementation\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : list, array, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter out null values from provided order, similar to old implementation\n        order = filter(pd.notnull, order)\n        return list(order)\n\n    if vector is None:\n        return []\n    \n    vector = pd.Series(vector, copy=False)\n    \n    if vector.dtype.name == \"category\":\n        order = vector.cat.categories\n    else:\n        try:\n            order = vector.unique()\n        except TypeError:\n            order = pd.unique(vector)\n            \n        if variable_type(vector, boolean_type=\"categorical\") == \"numeric\":\n            order = np.sort(order)\n    \n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Vector of \"categorical\" values\n    order : list-like\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = pd.Series(vector, dtype=object).unique()\n    else:\n        # Validate that provided order values exist in the data\n        # and filter out any null values, similar to old implementation\n        vector_vals = set(pd.Series(vector, dtype=object).dropna().unique())\n        order = [x for x in order if pd.notnull(x) and x in vector_vals]\n    \n    # Always filter out null values from the final order\n    order = [x for x in order if pd.notnull(x)]\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, Index, or numpy array\n        Vector of \"categorical\" values\n    order : list-like\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        order = list(filter(pd.notnull, pd.unique(vector)))\n        if hasattr(vector, \"dtype\") and vector.dtype.name == \"category\":\n            # Cast to list to handle differences in pandas versions with\n            # categorical data that can't be compared to None\n            order = [c for c in vector.dtype.categories if c in order]\n    else:\n        # Validate that the provided order contains only values present in the data\n        # and filter out any null values, maintaining compatibility with old behavior\n        order = list(filter(pd.notnull, order))\n        \n    return order\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series, 1d array, or list\n        Vector of \"categorical\" values\n    order : list-like\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        # Filter the provided order to only include values that exist in the data\n        # This maintains compatibility with the old implementation\n        vector_values = pd.Series(vector).dropna().unique()\n        # Only include order values that are present in the actual data\n        filtered_order = [x for x in order if x in vector_values]\n        return filtered_order\n    \n    if vector is None:\n        return None\n    vector = pd.Series(vector, copy=False)\n    return list(filter(pd.notnull, vector.unique()))\n"
    ],
    "Location 5 (/root/hy/projects_4/seaborn/seaborn/_oldcore.py lines 1712-1748)": [
      "\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values using the provided order if given.\"\"\"\n\n    if order is None:\n        if hasattr(vector, \"categories\"):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n                try:\n                    order = vector.unique()\n                except AttributeError:\n                    order = pd.unique(vector)\n\n                if variable_type(vector) == \"numeric\":\n                    order = np.sort(order)\n    else:\n        # When order is provided, validate it against the actual data\n        # to maintain consistency with old behavior\n        if hasattr(vector, \"categories\"):\n            actual_values = vector.categories\n        else:\n            try:\n                actual_values = vector.cat.categories\n            except (TypeError, AttributeError):\n                try:\n                    actual_values = vector.unique()\n                except AttributeError:\n                    actual_values = pd.unique(vector)\n        \n        # Filter the provided order to only include values present in the data\n        # This prevents unmapped values from causing downstream errors\n        actual_values_set = set(pd.Series(actual_values).dropna())\n        order = [val for val in order if val in actual_values_set]\n\n    # Always filter null values from the final order\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values using the provided order if given.\"\"\"\n    if order is None:\n        if hasattr(vector, \"categories\"):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n                try:\n                    order = vector.unique()\n                except AttributeError:\n                    order = pd.unique(vector)\n\n                if variable_type(vector) == \"numeric\":\n                    order = np.sort(order)\n    else:\n        # Validate that the provided order values exist in the vector\n        # and filter out any null values, similar to old implementation\n        if hasattr(vector, 'isin'):\n            # For pandas Series/Index\n            vector_values = vector.dropna() if hasattr(vector, 'dropna') else vector\n        else:\n            # For numpy arrays and other iterables\n            vector_values = pd.Series(vector).dropna()\n        \n        # Filter order to only include values that exist in the data\n        # and are not null, maintaining the original order sequence\n        order = [x for x in order if pd.notnull(x) and x in vector_values.values]\n    \n    # Apply null filtering like the old implementation\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values using an ordering algorithm.\"\"\"\n    if order is None:\n        if hasattr(vector, \"categories\"):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n                try:\n                    order = vector.unique()\n                except AttributeError:\n                    order = pd.unique(vector)\n\n                if variable_type(vector) == \"numeric\":\n                    order = np.sort(order)\n\n    # Always filter out null values and validate order against actual data\n    if order is not None:\n        # Get unique values from vector for validation\n        try:\n            vector_vals = vector.unique() if hasattr(vector, 'unique') else pd.unique(vector)\n        except (TypeError, AttributeError):\n            vector_vals = pd.unique(vector)\n        \n        # Filter order to only include values that exist in vector and are not null\n        order = [x for x in order if pd.notnull(x) and x in vector_vals]\n    \n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values using the provided order when given.\"\"\"\n    if order is not None:\n        # Validate and filter the provided order against actual data\n        if hasattr(vector, \"categories\"):\n            actual_values = set(vector.categories)\n        else:\n            try:\n                actual_values = set(vector.cat.categories)\n            except (TypeError, AttributeError):\n                try:\n                    actual_values = set(vector.unique())\n                except AttributeError:\n                    actual_values = set(pd.unique(vector))\n        \n        # Filter out null values and values not present in the data\n        filtered_order = []\n        for val in order:\n            if pd.notnull(val) and val in actual_values:\n                filtered_order.append(val)\n        return filtered_order\n    \n    if hasattr(vector, \"categories\"):\n        order = vector.categories\n    else:\n        try:\n            order = vector.cat.categories\n        except (TypeError, AttributeError):\n            try:\n                order = vector.unique()\n            except AttributeError:\n                order = pd.unique(vector)\n\n            if variable_type(vector) == \"numeric\":\n                order = np.sort(order)\n\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values using an ordering given in `order`.\"\"\"\n    if order is None:\n        if hasattr(vector, \"categories\"):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n                try:\n                    order = vector.unique()\n                except AttributeError:\n                    order = pd.unique(vector)\n                if variable_type(vector) == \"numeric\":\n                    order = np.sort(order)\n    \n    # Always filter out null values, even when order is provided\n    # This maintains backward compatibility with the old implementation\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values using the provided order if given.\"\"\"\n    if order is None:\n        if hasattr(vector, \"categories\"):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n                try:\n                    order = vector.unique()\n                except AttributeError:\n                    order = pd.unique(vector)\n                \n                if variable_type(vector) == \"numeric\":\n                    order = np.sort(order)\n    else:\n        # Validate that provided order values exist in the data\n        # and filter out any null values, similar to old implementation\n        if hasattr(vector, \"cat\") and hasattr(vector.cat, \"categories\"):\n            # For categorical data, ensure order values are in categories\n            vector_cats = set(vector.cat.categories)\n            order = [x for x in order if x in vector_cats and pd.notnull(x)]\n        else:\n            # For non-categorical data, ensure order values exist in data\n            try:\n                vector_unique = set(vector.unique())\n            except AttributeError:\n                vector_unique = set(pd.unique(vector))\n            order = [x for x in order if x in vector_unique and pd.notnull(x)]\n    \n    # Always filter out null values for consistency with old implementation\n    order = [x for x in order if pd.notnull(x)]\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values using an ordering algorithm.\"\"\"\n\n    if order is None:\n        if hasattr(vector, \"categories\"):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n                try:\n                    order = vector.unique()\n                except AttributeError:\n                    order = pd.unique(vector)\n\n                if variable_type(vector) == \"numeric\":\n                    order = np.sort(order)\n\n    # Always filter out null values from order, even when order is provided\n    order = filter(pd.notnull, order)\n    return list(order)\n",
      "\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values using an ordering scheme.\"\"\"\n    if order is None:\n        if hasattr(vector, \"categories\"):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n                try:\n                    order = vector.unique()\n                except AttributeError:\n                    order = pd.unique(vector)\n                \n                if variable_type(vector) == \"numeric\":\n                    order = np.sort(order)\n        \n        order = filter(pd.notnull, order)\n    else:\n        # Even when order is provided, filter out null values and validate\n        # against the actual data to maintain backward compatibility\n        order = filter(pd.notnull, order)\n    \n    return list(order)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py\nindex 3809a530..3145ae3a 100644\n--- a/seaborn/_core/groupby.py\n+++ b/seaborn/_core/groupby.py\n@@ -44,13 +44,14 @@ class GroupBy:\n             order = {k: None for k in order}\n         self.order = order\n \n+\n     def _get_groups(self, data: DataFrame) -> MultiIndex:\n         \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n         levels = {}\n         for var, order in self.order.items():\n             if var in data:\n-                if order is None:\n-                    order = categorical_order(data[var])\n+                # Always call categorical_order for validation, even when order is provided\n+                order = categorical_order(data[var], order)\n                 levels[var] = order\n \n         grouper: str | list[str]\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 2469df00..2b73852c 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -986,6 +986,8 @@ class Plotter:\n \n                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n \n+                if stat.group_by_orient:\n+\n                 if stat.group_by_orient:\n                     grouper = [orient, *grouping_vars]\n                 else:\n@@ -1126,6 +1128,7 @@ class Plotter:\n                     if move_by is None:\n                         move_by = grouping_properties\n                     move_groupers = [*move_by, *default_grouping_vars]\n+\n                     if move_step.group_by_orient:\n                         move_groupers.insert(0, orient)\n                     order = {var: get_order(var) for var in move_groupers}\ndiff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..64869c3d 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -122,6 +122,7 @@ def variable_type(\n     return VarType(\"categorical\")\n \n \n+\n def categorical_order(vector: Series, order: list | None = None) -> list:\n     \"\"\"\n     Return a list of unique data values using seaborn's ordering rules.\n@@ -141,7 +142,9 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n \n     \"\"\"\n     if order is not None:\n-        return order\n+        # Apply null filtering to provided order, matching old implementation behavior\n+        order = filter(pd.notnull, order)\n+        return list(order)\n \n     if vector.dtype.name == \"category\":\n         order = list(vector.cat.categories)\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..46a8df76 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1709,6 +1709,7 @@ def unique_markers(n):\n     return markers[:n]\n \n \n+\n def categorical_order(vector, order=None):\n     \"\"\"Return a list of unique data values.\n \n",
    "variant_0": "diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py\nindex 3809a530..7a09173a 100644\n--- a/seaborn/_core/groupby.py\n+++ b/seaborn/_core/groupby.py\n@@ -44,27 +44,36 @@ class GroupBy:\n             order = {k: None for k in order}\n         self.order = order\n \n-    def _get_groups(self, data: DataFrame) -> MultiIndex:\n-        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n-        levels = {}\n-        for var, order in self.order.items():\n-            if var in data:\n-                if order is None:\n-                    order = categorical_order(data[var])\n-                levels[var] = order\n-\n-        grouper: str | list[str]\n-        groups: Index | MultiIndex | None\n-        if not levels:\n-            grouper = []\n-            groups = None\n-        elif len(levels) > 1:\n-            grouper = list(levels)\n-            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)\n-        else:\n-            grouper, = list(levels)\n-            groups = pd.Index(levels[grouper], name=grouper)\n-        return grouper, groups\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Input data.\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = list(filter(pd.notnull, pd.Series(vector).unique()))\n+    else:\n+        # Validate that provided order values exist in the data\n+        # and filter out null values to match old behavior\n+        order = list(filter(pd.notnull, order))\n+        \n+    if order:\n+        return order\n+    else:\n+        return list(filter(pd.notnull, pd.Series(vector).unique()))\n \n     def _reorder_columns(self, res, data):\n         \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 2469df00..787b0891 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -987,11 +987,40 @@ class Plotter:\n                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n \n                 if stat.group_by_orient:\n-                    grouper = [orient, *grouping_vars]\n-                else:\n-                    grouper = grouping_vars\n-                groupby = GroupBy(grouper)\n-                res = stat(df, groupby, orient, scales)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` objects.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector, dtype=object).unique()\n+    else:\n+        order = pd.Series(order, dtype=object)\n+        # Validate that provided order values exist in the data\n+        data_values = pd.Series(vector, dtype=object)\n+        valid_order = []\n+        for val in order:\n+            if val in data_values.values:\n+                valid_order.append(val)\n+        order = valid_order\n+\n+    # Filter out null values, matching old implementation behavior\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n                 if pair_vars:\n                     data.frames[coord_vars] = res\n@@ -1126,11 +1155,51 @@ class Plotter:\n                     if move_by is None:\n                         move_by = grouping_properties\n                     move_groupers = [*move_by, *default_grouping_vars]\n-                    if move_step.group_by_orient:\n-                        move_groupers.insert(0, orient)\n-                    order = {var: get_order(var) for var in move_groupers}\n-                    groupby = GroupBy(order)\n-                    df = move_step(df, groupby, orient)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Filter the provided order to only include values present in the data\n+        # This maintains backward compatibility with the old implementation\n+        # and prevents unmapped values from causing downstream errors\n+        order = filter(pd.notnull, order)\n+        return list(order)\n+\n+    if vector is None:\n+        return []\n+\n+    # Handle scalar values\n+    if np.isscalar(vector):\n+        return [vector] if pd.notnull(vector) else []\n+\n+    vector = pd.Series(vector, dtype=object)\n+    if vector.isna().all():\n+        return []\n+\n+    # Use pandas categorical ordering if available, otherwise preserve order of appearance\n+    if hasattr(vector, \"cat\"):\n+        order = vector.cat.categories\n+    else:\n+        order = vector.drop_duplicates()\n+\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n             df = self._unscale_coords(subplots, df, orient)\n \ndiff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..d53ab60c 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -122,6 +122,7 @@ def variable_type(\n     return VarType(\"categorical\")\n \n \n+\n def categorical_order(vector: Series, order: list | None = None) -> list:\n     \"\"\"\n     Return a list of unique data values using seaborn's ordering rules.\n@@ -141,6 +142,8 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n \n     \"\"\"\n     if order is not None:\n+        # Filter out null values from provided order, matching old behavior\n+        order = list(filter(pd.notnull, order))\n         return order\n \n     if vector.dtype.name == \"category\":\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..324519e0 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1709,10 +1709,14 @@ def unique_markers(n):\n     return markers[:n]\n \n \n+\n def categorical_order(vector, order=None):\n-    \"\"\"Return a list of unique data values.\n+    \"\"\"Return a list of unique data values using an ordering given by the data.\n \n-    Determine an ordered list of levels in ``values``.\n+    When the vector is a pandas Categorical or has a \"categories\" attribute,\n+    the order of the categories will be used. Otherwise, the unique values\n+    will be determined and, if the data appear to be numeric, they will be\n+    sorted. Any null values are filtered out.\n \n     Parameters\n     ----------\n@@ -1744,5 +1748,7 @@ def categorical_order(vector, order=None):\n                 if variable_type(vector) == \"numeric\":\n                     order = np.sort(order)\n \n-        order = filter(pd.notnull, order)\n+    # Always filter out null values, even when order is provided\n+    # This maintains backward compatibility and prevents downstream errors\n+    order = filter(pd.notnull, order)\n     return list(order)\n",
    "variant_1": "diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py\nindex 3809a530..0aa10952 100644\n--- a/seaborn/_core/groupby.py\n+++ b/seaborn/_core/groupby.py\n@@ -44,27 +44,38 @@ class GroupBy:\n             order = {k: None for k in order}\n         self.order = order\n \n-    def _get_groups(self, data: DataFrame) -> MultiIndex:\n-        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n-        levels = {}\n-        for var, order in self.order.items():\n-            if var in data:\n-                if order is None:\n-                    order = categorical_order(data[var])\n-                levels[var] = order\n-\n-        grouper: str | list[str]\n-        groups: Index | MultiIndex | None\n-        if not levels:\n-            grouper = []\n-            groups = None\n-        elif len(levels) > 1:\n-            grouper = list(levels)\n-            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)\n-        else:\n-            grouper, = list(levels)\n-            groups = pd.Index(levels[grouper], name=grouper)\n-        return grouper, groups\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector, dtype=\"category\").cat.categories\n+    else:\n+        # Validate that provided order values exist in the data\n+        # and filter out any null values, similar to old implementation\n+        order = pd.Series(order, dtype=\"category\").cat.categories\n+        # Only keep order values that actually exist in the vector\n+        vector_categories = pd.Series(vector, dtype=\"category\").cat.categories\n+        order = [x for x in order if x in vector_categories]\n+    \n+    # Filter out null values from the final order\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n     def _reorder_columns(self, res, data):\n         \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 2469df00..08c0ea7d 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -987,11 +987,41 @@ class Plotter:\n                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n \n                 if stat.group_by_orient:\n-                    grouper = [orient, *grouping_vars]\n-                else:\n-                    grouper = grouping_vars\n-                groupby = GroupBy(grouper)\n-                res = stat(df, groupby, orient, scales)\n+\n+def categorical_order(vector: Series, order: list | None = None) -> list:\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series\n+        Vector of \"categorical\" values\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Validate and filter the provided order against actual data\n+        # This matches the behavior of the old implementation\n+        order = filter(pd.notnull, order)\n+        return list(order)\n+    \n+    if vector.dtype.name == \"category\":\n+        order = vector.cat.categories\n+    else:\n+        try:\n+            order = vector.unique()\n+        except TypeError:\n+            order = vector.drop_duplicates()\n+\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n                 if pair_vars:\n                     data.frames[coord_vars] = res\n@@ -1126,11 +1156,34 @@ class Plotter:\n                     if move_by is None:\n                         move_by = grouping_properties\n                     move_groupers = [*move_by, *default_grouping_vars]\n-                    if move_step.group_by_orient:\n-                        move_groupers.insert(0, orient)\n-                    order = {var: get_order(var) for var in move_groupers}\n-                    groupby = GroupBy(order)\n-                    df = move_step(df, groupby, orient)\n+\n+def categorical_order(vector: Series, order: list | None = None) -> list:\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series\n+        Vector of \"categorical\" values\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = list(filter(pd.notnull, vector.unique()))\n+    else:\n+        # Validate the provided order by filtering out values not in the data\n+        # and removing null values, similar to the old implementation\n+        vector_vals = set(filter(pd.notnull, vector.dropna().unique()))\n+        order = [x for x in order if pd.notnull(x) and x in vector_vals]\n+    \n+    return order\n \n             df = self._unscale_coords(subplots, df, orient)\n \ndiff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..d53ab60c 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -122,6 +122,7 @@ def variable_type(\n     return VarType(\"categorical\")\n \n \n+\n def categorical_order(vector: Series, order: list | None = None) -> list:\n     \"\"\"\n     Return a list of unique data values using seaborn's ordering rules.\n@@ -141,6 +142,8 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n \n     \"\"\"\n     if order is not None:\n+        # Filter out null values from provided order, matching old behavior\n+        order = list(filter(pd.notnull, order))\n         return order\n \n     if vector.dtype.name == \"category\":\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..e82fc0d0 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1709,25 +1709,10 @@ def unique_markers(n):\n     return markers[:n]\n \n \n-def categorical_order(vector, order=None):\n-    \"\"\"Return a list of unique data values.\n-\n-    Determine an ordered list of levels in ``values``.\n-\n-    Parameters\n-    ----------\n-    vector : list, array, Categorical, or Series\n-        Vector of \"categorical\" values\n-    order : list-like, optional\n-        Desired order of category levels to override the order determined\n-        from the ``values`` object.\n \n-    Returns\n-    -------\n-    order : list\n-        Ordered list of category levels not including null values.\n+def categorical_order(vector, order=None):\n+    \"\"\"Return a list of unique data values using the provided order if given.\"\"\"\n \n-    \"\"\"\n     if order is None:\n         if hasattr(vector, \"categories\"):\n             order = vector.categories\n@@ -1735,7 +1720,6 @@ def categorical_order(vector, order=None):\n             try:\n                 order = vector.cat.categories\n             except (TypeError, AttributeError):\n-\n                 try:\n                     order = vector.unique()\n                 except AttributeError:\n@@ -1743,6 +1727,25 @@ def categorical_order(vector, order=None):\n \n                 if variable_type(vector) == \"numeric\":\n                     order = np.sort(order)\n-\n-        order = filter(pd.notnull, order)\n+    else:\n+        # When order is provided, validate it against the actual data\n+        # to maintain consistency with old behavior\n+        if hasattr(vector, \"categories\"):\n+            actual_values = vector.categories\n+        else:\n+            try:\n+                actual_values = vector.cat.categories\n+            except (TypeError, AttributeError):\n+                try:\n+                    actual_values = vector.unique()\n+                except AttributeError:\n+                    actual_values = pd.unique(vector)\n+        \n+        # Filter the provided order to only include values present in the data\n+        # This prevents unmapped values from causing downstream errors\n+        actual_values_set = set(pd.Series(actual_values).dropna())\n+        order = [val for val in order if val in actual_values_set]\n+\n+    # Always filter null values from the final order\n+    order = filter(pd.notnull, order)\n     return list(order)\n",
    "variant_2": "diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py\nindex 3809a530..9d466b3d 100644\n--- a/seaborn/_core/groupby.py\n+++ b/seaborn/_core/groupby.py\n@@ -44,27 +44,37 @@ class GroupBy:\n             order = {k: None for k in order}\n         self.order = order\n \n-    def _get_groups(self, data: DataFrame) -> MultiIndex:\n-        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n-        levels = {}\n-        for var, order in self.order.items():\n-            if var in data:\n-                if order is None:\n-                    order = categorical_order(data[var])\n-                levels[var] = order\n-\n-        grouper: str | list[str]\n-        groups: Index | MultiIndex | None\n-        if not levels:\n-            grouper = []\n-            groups = None\n-        elif len(levels) > 1:\n-            grouper = list(levels)\n-            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)\n-        else:\n-            grouper, = list(levels)\n-            groups = pd.Index(levels[grouper], name=grouper)\n-        return grouper, groups\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `vector` values.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector).unique()\n+    else:\n+        # Validate provided order against actual data\n+        # Filter out any order values that don't exist in the vector\n+        vector_series = pd.Series(vector)\n+        valid_values = set(vector_series.dropna().unique())\n+        order = [val for val in order if val in valid_values]\n+    \n+    # Always filter out null values, similar to old implementation\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n     def _reorder_columns(self, res, data):\n         \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 2469df00..928d055e 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -987,11 +987,45 @@ class Plotter:\n                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n \n                 if stat.group_by_orient:\n-                    grouper = [orient, *grouping_vars]\n-                else:\n-                    grouper = grouping_vars\n-                groupby = GroupBy(grouper)\n-                res = stat(df, groupby, orient, scales)\n+\n+def categorical_order(vector: Series, order: list | None = None) -> list:\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series\n+        Vector of \"categorical\" values\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = vector.dropna().unique()\n+        if vector.dtype.name == \"category\":\n+            # Handle categorical data, respecting existing order\n+            order = vector.cat.remove_unused_categories().cat.categories\n+        elif vector.dtype.name in [\"object\", \"string\"]:\n+            # Handle object/string data, sort if possible\n+            try:\n+                order = natsort.natsorted(order, alg=natsort.ns.PATH)\n+            except (TypeError, AttributeError):\n+                order = sorted(order)\n+        else:\n+            # Handle numeric data\n+            order = sorted(order)\n+    else:\n+        # Even when order is provided, validate and filter like the old implementation\n+        # This ensures subset orders don't cause downstream isnan errors\n+        order = filter(pd.notnull, order)\n+\n+    return list(order)\n \n                 if pair_vars:\n                     data.frames[coord_vars] = res\n@@ -1126,11 +1160,36 @@ class Plotter:\n                     if move_by is None:\n                         move_by = grouping_properties\n                     move_groupers = [*move_by, *default_grouping_vars]\n-                    if move_step.group_by_orient:\n-                        move_groupers.insert(0, orient)\n-                    order = {var: get_order(var) for var in move_groupers}\n-                    groupby = GroupBy(order)\n-                    df = move_step(df, groupby, orient)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector, dtype=object).unique()\n+    else:\n+        # Validate that provided order values exist in the data\n+        unique_vals = pd.Series(vector, dtype=object).unique()\n+        # Filter out null values from the order, matching old behavior\n+        order = [x for x in order if pd.notnull(x) and x in unique_vals]\n+    \n+    # Always filter out null values from the final order\n+    order = [x for x in order if pd.notnull(x)]\n+    return list(order)\n \n             df = self._unscale_coords(subplots, df, orient)\n \ndiff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..d53ab60c 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -122,6 +122,7 @@ def variable_type(\n     return VarType(\"categorical\")\n \n \n+\n def categorical_order(vector: Series, order: list | None = None) -> list:\n     \"\"\"\n     Return a list of unique data values using seaborn's ordering rules.\n@@ -141,6 +142,8 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n \n     \"\"\"\n     if order is not None:\n+        # Filter out null values from provided order, matching old behavior\n+        order = list(filter(pd.notnull, order))\n         return order\n \n     if vector.dtype.name == \"category\":\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..8c15edc3 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1709,25 +1709,9 @@ def unique_markers(n):\n     return markers[:n]\n \n \n-def categorical_order(vector, order=None):\n-    \"\"\"Return a list of unique data values.\n-\n-    Determine an ordered list of levels in ``values``.\n-\n-    Parameters\n-    ----------\n-    vector : list, array, Categorical, or Series\n-        Vector of \"categorical\" values\n-    order : list-like, optional\n-        Desired order of category levels to override the order determined\n-        from the ``values`` object.\n-\n-    Returns\n-    -------\n-    order : list\n-        Ordered list of category levels not including null values.\n \n-    \"\"\"\n+def categorical_order(vector, order=None):\n+    \"\"\"Return a list of unique data values using the provided order if given.\"\"\"\n     if order is None:\n         if hasattr(vector, \"categories\"):\n             order = vector.categories\n@@ -1735,7 +1719,6 @@ def categorical_order(vector, order=None):\n             try:\n                 order = vector.cat.categories\n             except (TypeError, AttributeError):\n-\n                 try:\n                     order = vector.unique()\n                 except AttributeError:\n@@ -1743,6 +1726,20 @@ def categorical_order(vector, order=None):\n \n                 if variable_type(vector) == \"numeric\":\n                     order = np.sort(order)\n-\n-        order = filter(pd.notnull, order)\n+    else:\n+        # Validate that the provided order values exist in the vector\n+        # and filter out any null values, similar to old implementation\n+        if hasattr(vector, 'isin'):\n+            # For pandas Series/Index\n+            vector_values = vector.dropna() if hasattr(vector, 'dropna') else vector\n+        else:\n+            # For numpy arrays and other iterables\n+            vector_values = pd.Series(vector).dropna()\n+        \n+        # Filter order to only include values that exist in the data\n+        # and are not null, maintaining the original order sequence\n+        order = [x for x in order if pd.notnull(x) and x in vector_values.values]\n+    \n+    # Apply null filtering like the old implementation\n+    order = filter(pd.notnull, order)\n     return list(order)\n",
    "variant_3": "diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py\nindex 3809a530..b9b75127 100644\n--- a/seaborn/_core/groupby.py\n+++ b/seaborn/_core/groupby.py\n@@ -44,27 +44,51 @@ class GroupBy:\n             order = {k: None for k in order}\n         self.order = order\n \n-    def _get_groups(self, data: DataFrame) -> MultiIndex:\n-        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n-        levels = {}\n-        for var, order in self.order.items():\n-            if var in data:\n-                if order is None:\n-                    order = categorical_order(data[var])\n-                levels[var] = order\n-\n-        grouper: str | list[str]\n-        groups: Index | MultiIndex | None\n-        if not levels:\n-            grouper = []\n-            groups = None\n-        elif len(levels) > 1:\n-            grouper = list(levels)\n-            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        if hasattr(vector, \"cat\"):\n+            order = vector.cat.categories\n+        else:\n+            try:\n+                order = vector.unique()\n+            except AttributeError:\n+                order = pd.unique(vector)\n+            if variable_type(vector) == \"numeric\":\n+                order = np.sort(order)\n+        order = filter(pd.notnull, order)\n+        return list(order)\n+    else:\n+        # Validate the provided order against the actual data\n+        # Filter out null values and values not present in the data\n+        if hasattr(vector, \"cat\"):\n+            data_values = set(vector.cat.categories)\n         else:\n-            grouper, = list(levels)\n-            groups = pd.Index(levels[grouper], name=grouper)\n-        return grouper, groups\n+            try:\n+                data_values = set(vector.unique())\n+            except AttributeError:\n+                data_values = set(pd.unique(vector))\n+        \n+        # Filter the order to only include non-null values that exist in the data\n+        filtered_order = [x for x in order if pd.notnull(x) and x in data_values]\n+        return filtered_order\n \n     def _reorder_columns(self, res, data):\n         \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 2469df00..17bac18d 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -987,11 +987,33 @@ class Plotter:\n                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n \n                 if stat.group_by_orient:\n-                    grouper = [orient, *grouping_vars]\n-                else:\n-                    grouper = grouping_vars\n-                groupby = GroupBy(grouper)\n-                res = stat(df, groupby, orient, scales)\n+\n+def categorical_order(vector: Series, order: list | None = None) -> list:\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series\n+        Vector of \"categorical\" values\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = vector.dropna().unique()\n+    else:\n+        # Validate order against actual data and filter out nulls\n+        # This maintains backward compatibility with the old implementation\n+        order = filter(pd.notnull, order)\n+    \n+    return list(order)\n \n                 if pair_vars:\n                     data.frames[coord_vars] = res\n@@ -1126,11 +1148,31 @@ class Plotter:\n                     if move_by is None:\n                         move_by = grouping_properties\n                     move_groupers = [*move_by, *default_grouping_vars]\n-                    if move_step.group_by_orient:\n-                        move_groupers.insert(0, orient)\n-                    order = {var: get_order(var) for var in move_groupers}\n-                    groupby = GroupBy(order)\n-                    df = move_step(df, groupby, orient)\n+\n+def categorical_order(vector: Series, order: list | None = None) -> list:\n+\n+    if order is None:\n+        order = vector.drop_duplicates()\n+        if vector.dtype.name == \"category\":\n+            order = vector.cat.categories\n+        try:\n+            order = order.sort_values()\n+        except TypeError:\n+            pass\n+    else:\n+        # Validate that the provided order exists in the data\n+        # This matches the old implementation behavior\n+        order = pd.Series(order, dtype=vector.dtype)\n+        # Filter out null values, similar to old implementation\n+        order = order.dropna()\n+        # Only keep order values that actually exist in the data\n+        if not order.empty:\n+            existing_values = set(vector.dropna().unique())\n+            order = order[order.isin(existing_values)]\n+    \n+    # Convert to list and filter nulls (matching old implementation line 1747)\n+    order = [x for x in order if pd.notnull(x)]\n+    return order\n \n             df = self._unscale_coords(subplots, df, orient)\n \ndiff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..b7ccb858 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -122,6 +122,7 @@ def variable_type(\n     return VarType(\"categorical\")\n \n \n+\n def categorical_order(vector: Series, order: list | None = None) -> list:\n     \"\"\"\n     Return a list of unique data values using seaborn's ordering rules.\n@@ -141,6 +142,8 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n \n     \"\"\"\n     if order is not None:\n+        # Filter out null values from provided order, similar to old implementation\n+        order = list(filter(pd.notnull, order))\n         return order\n \n     if vector.dtype.name == \"category\":\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..a1aa5d30 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1709,25 +1709,9 @@ def unique_markers(n):\n     return markers[:n]\n \n \n-def categorical_order(vector, order=None):\n-    \"\"\"Return a list of unique data values.\n-\n-    Determine an ordered list of levels in ``values``.\n-\n-    Parameters\n-    ----------\n-    vector : list, array, Categorical, or Series\n-        Vector of \"categorical\" values\n-    order : list-like, optional\n-        Desired order of category levels to override the order determined\n-        from the ``values`` object.\n-\n-    Returns\n-    -------\n-    order : list\n-        Ordered list of category levels not including null values.\n \n-    \"\"\"\n+def categorical_order(vector, order=None):\n+    \"\"\"Return a list of unique data values using an ordering algorithm.\"\"\"\n     if order is None:\n         if hasattr(vector, \"categories\"):\n             order = vector.categories\n@@ -1735,7 +1719,6 @@ def categorical_order(vector, order=None):\n             try:\n                 order = vector.cat.categories\n             except (TypeError, AttributeError):\n-\n                 try:\n                     order = vector.unique()\n                 except AttributeError:\n@@ -1744,5 +1727,15 @@ def categorical_order(vector, order=None):\n                 if variable_type(vector) == \"numeric\":\n                     order = np.sort(order)\n \n-        order = filter(pd.notnull, order)\n+    # Always filter out null values and validate order against actual data\n+    if order is not None:\n+        # Get unique values from vector for validation\n+        try:\n+            vector_vals = vector.unique() if hasattr(vector, 'unique') else pd.unique(vector)\n+        except (TypeError, AttributeError):\n+            vector_vals = pd.unique(vector)\n+        \n+        # Filter order to only include values that exist in vector and are not null\n+        order = [x for x in order if pd.notnull(x) and x in vector_vals]\n+    \n     return list(order)\n",
    "variant_4": "diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py\nindex 3809a530..a8c47a92 100644\n--- a/seaborn/_core/groupby.py\n+++ b/seaborn/_core/groupby.py\n@@ -44,27 +44,30 @@ class GroupBy:\n             order = {k: None for k in order}\n         self.order = order\n \n-    def _get_groups(self, data: DataFrame) -> MultiIndex:\n-        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n-        levels = {}\n-        for var, order in self.order.items():\n-            if var in data:\n-                if order is None:\n-                    order = categorical_order(data[var])\n-                levels[var] = order\n-\n-        grouper: str | list[str]\n-        groups: Index | MultiIndex | None\n-        if not levels:\n-            grouper = []\n-            groups = None\n-        elif len(levels) > 1:\n-            grouper = list(levels)\n-            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)\n-        else:\n-            grouper, = list(levels)\n-            groups = pd.Index(levels[grouper], name=grouper)\n-        return grouper, groups\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = vector.unique()\n+    else:\n+        order = filter(pd.notnull, order)\n+    return list(filter(pd.notnull, order))\n \n     def _reorder_columns(self, res, data):\n         \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 2469df00..f44c8529 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -987,11 +987,36 @@ class Plotter:\n                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n \n                 if stat.group_by_orient:\n-                    grouper = [orient, *grouping_vars]\n-                else:\n-                    grouper = grouping_vars\n-                groupby = GroupBy(grouper)\n-                res = stat(df, groupby, orient, scales)\n+\n+def categorical_order(vector: Series, order: list | None = None) -> list:\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series\n+        Vector of \"categorical\" values\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = vector.unique()\n+    else:\n+        # Validate that all provided order values exist in the data\n+        # and filter out any that don't (similar to old implementation)\n+        valid_values = set(vector.dropna().unique())\n+        order = [x for x in order if x in valid_values]\n+    \n+    # Always filter out null values, even from provided order\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n                 if pair_vars:\n                     data.frames[coord_vars] = res\n@@ -1126,11 +1151,34 @@ class Plotter:\n                     if move_by is None:\n                         move_by = grouping_properties\n                     move_groupers = [*move_by, *default_grouping_vars]\n-                    if move_step.group_by_orient:\n-                        move_groupers.insert(0, orient)\n-                    order = {var: get_order(var) for var in move_groupers}\n-                    groupby = GroupBy(order)\n-                    df = move_step(df, groupby, orient)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector, dtype=\"category\").cat.categories\n+    else:\n+        order = pd.CategoricalIndex(order, categories=order).categories\n+    \n+    # Always filter out null values, even when order is provided\n+    # This maintains compatibility with the old implementation\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n             df = self._unscale_coords(subplots, df, orient)\n \ndiff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..d53ab60c 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -122,6 +122,7 @@ def variable_type(\n     return VarType(\"categorical\")\n \n \n+\n def categorical_order(vector: Series, order: list | None = None) -> list:\n     \"\"\"\n     Return a list of unique data values using seaborn's ordering rules.\n@@ -141,6 +142,8 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n \n     \"\"\"\n     if order is not None:\n+        # Filter out null values from provided order, matching old behavior\n+        order = list(filter(pd.notnull, order))\n         return order\n \n     if vector.dtype.name == \"category\":\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..9411170d 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1709,40 +1709,42 @@ def unique_markers(n):\n     return markers[:n]\n \n \n-def categorical_order(vector, order=None):\n-    \"\"\"Return a list of unique data values.\n-\n-    Determine an ordered list of levels in ``values``.\n-\n-    Parameters\n-    ----------\n-    vector : list, array, Categorical, or Series\n-        Vector of \"categorical\" values\n-    order : list-like, optional\n-        Desired order of category levels to override the order determined\n-        from the ``values`` object.\n-\n-    Returns\n-    -------\n-    order : list\n-        Ordered list of category levels not including null values.\n \n-    \"\"\"\n-    if order is None:\n+def categorical_order(vector, order=None):\n+    \"\"\"Return a list of unique data values using the provided order when given.\"\"\"\n+    if order is not None:\n+        # Validate and filter the provided order against actual data\n         if hasattr(vector, \"categories\"):\n-            order = vector.categories\n+            actual_values = set(vector.categories)\n         else:\n             try:\n-                order = vector.cat.categories\n+                actual_values = set(vector.cat.categories)\n             except (TypeError, AttributeError):\n-\n                 try:\n-                    order = vector.unique()\n+                    actual_values = set(vector.unique())\n                 except AttributeError:\n-                    order = pd.unique(vector)\n+                    actual_values = set(pd.unique(vector))\n+        \n+        # Filter out null values and values not present in the data\n+        filtered_order = []\n+        for val in order:\n+            if pd.notnull(val) and val in actual_values:\n+                filtered_order.append(val)\n+        return filtered_order\n+    \n+    if hasattr(vector, \"categories\"):\n+        order = vector.categories\n+    else:\n+        try:\n+            order = vector.cat.categories\n+        except (TypeError, AttributeError):\n+            try:\n+                order = vector.unique()\n+            except AttributeError:\n+                order = pd.unique(vector)\n \n-                if variable_type(vector) == \"numeric\":\n-                    order = np.sort(order)\n+            if variable_type(vector) == \"numeric\":\n+                order = np.sort(order)\n \n-        order = filter(pd.notnull, order)\n+    order = filter(pd.notnull, order)\n     return list(order)\n",
    "variant_5": "diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py\nindex 3809a530..6fdcdcb8 100644\n--- a/seaborn/_core/groupby.py\n+++ b/seaborn/_core/groupby.py\n@@ -44,27 +44,36 @@ class GroupBy:\n             order = {k: None for k in order}\n         self.order = order\n \n-    def _get_groups(self, data: DataFrame) -> MultiIndex:\n-        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n-        levels = {}\n-        for var, order in self.order.items():\n-            if var in data:\n-                if order is None:\n-                    order = categorical_order(data[var])\n-                levels[var] = order\n-\n-        grouper: str | list[str]\n-        groups: Index | MultiIndex | None\n-        if not levels:\n-            grouper = []\n-            groups = None\n-        elif len(levels) > 1:\n-            grouper = list(levels)\n-            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)\n-        else:\n-            grouper, = list(levels)\n-            groups = pd.Index(levels[grouper], name=grouper)\n-        return grouper, groups\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector, dtype=object).unique()\n+    else:\n+        order = pd.Series(order, dtype=object)\n+        # Filter order to only include values present in the data\n+        vector_set = set(pd.Series(vector, dtype=object).dropna())\n+        order = order[order.isin(vector_set)]\n+    \n+    # Always filter out null values, even when order is provided\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n     def _reorder_columns(self, res, data):\n         \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 2469df00..496d48c3 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -987,11 +987,36 @@ class Plotter:\n                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n \n                 if stat.group_by_orient:\n-                    grouper = [orient, *grouping_vars]\n-                else:\n-                    grouper = grouping_vars\n-                groupby = GroupBy(grouper)\n-                res = stat(df, groupby, orient, scales)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector, dtype=object).unique()\n+    elif len(order) < len(pd.Series(vector, dtype=object).unique()):\n+        # When a subset order is provided, validate it against actual data\n+        # and filter out any null values to prevent downstream errors\n+        order = filter(pd.notnull, order)\n+    else:\n+        # For complete orders, still filter out nulls for consistency\n+        order = filter(pd.notnull, order)\n+    \n+    return list(order)\n \n                 if pair_vars:\n                     data.frames[coord_vars] = res\n@@ -1126,11 +1151,48 @@ class Plotter:\n                     if move_by is None:\n                         move_by = grouping_properties\n                     move_groupers = [*move_by, *default_grouping_vars]\n-                    if move_step.group_by_orient:\n-                        move_groupers.insert(0, orient)\n-                    order = {var: get_order(var) for var in move_groupers}\n-                    groupby = GroupBy(order)\n-                    df = move_step(df, groupby, orient)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Filter out null values from provided order, similar to old implementation\n+        order = filter(pd.notnull, order)\n+        return list(order)\n+\n+    if vector is None:\n+        return []\n+    \n+    vector = pd.Series(vector, copy=False)\n+    \n+    if vector.dtype.name == \"category\":\n+        order = vector.cat.categories\n+    else:\n+        try:\n+            order = vector.unique()\n+        except TypeError:\n+            order = pd.unique(vector)\n+            \n+        if variable_type(vector, boolean_type=\"categorical\") == \"numeric\":\n+            order = np.sort(order)\n+    \n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n             df = self._unscale_coords(subplots, df, orient)\n \ndiff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..d53ab60c 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -122,6 +122,7 @@ def variable_type(\n     return VarType(\"categorical\")\n \n \n+\n def categorical_order(vector: Series, order: list | None = None) -> list:\n     \"\"\"\n     Return a list of unique data values using seaborn's ordering rules.\n@@ -141,6 +142,8 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n \n     \"\"\"\n     if order is not None:\n+        # Filter out null values from provided order, matching old behavior\n+        order = list(filter(pd.notnull, order))\n         return order\n \n     if vector.dtype.name == \"category\":\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..5be91bf8 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1709,25 +1709,9 @@ def unique_markers(n):\n     return markers[:n]\n \n \n-def categorical_order(vector, order=None):\n-    \"\"\"Return a list of unique data values.\n-\n-    Determine an ordered list of levels in ``values``.\n \n-    Parameters\n-    ----------\n-    vector : list, array, Categorical, or Series\n-        Vector of \"categorical\" values\n-    order : list-like, optional\n-        Desired order of category levels to override the order determined\n-        from the ``values`` object.\n-\n-    Returns\n-    -------\n-    order : list\n-        Ordered list of category levels not including null values.\n-\n-    \"\"\"\n+def categorical_order(vector, order=None):\n+    \"\"\"Return a list of unique data values using an ordering given in `order`.\"\"\"\n     if order is None:\n         if hasattr(vector, \"categories\"):\n             order = vector.categories\n@@ -1735,14 +1719,14 @@ def categorical_order(vector, order=None):\n             try:\n                 order = vector.cat.categories\n             except (TypeError, AttributeError):\n-\n                 try:\n                     order = vector.unique()\n                 except AttributeError:\n                     order = pd.unique(vector)\n-\n                 if variable_type(vector) == \"numeric\":\n                     order = np.sort(order)\n-\n-        order = filter(pd.notnull, order)\n+    \n+    # Always filter out null values, even when order is provided\n+    # This maintains backward compatibility with the old implementation\n+    order = filter(pd.notnull, order)\n     return list(order)\n",
    "variant_6": "diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py\nindex 3809a530..13359ed6 100644\n--- a/seaborn/_core/groupby.py\n+++ b/seaborn/_core/groupby.py\n@@ -44,27 +44,34 @@ class GroupBy:\n             order = {k: None for k in order}\n         self.order = order\n \n-    def _get_groups(self, data: DataFrame) -> MultiIndex:\n-        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n-        levels = {}\n-        for var, order in self.order.items():\n-            if var in data:\n-                if order is None:\n-                    order = categorical_order(data[var])\n-                levels[var] = order\n-\n-        grouper: str | list[str]\n-        groups: Index | MultiIndex | None\n-        if not levels:\n-            grouper = []\n-            groups = None\n-        elif len(levels) > 1:\n-            grouper = list(levels)\n-            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)\n-        else:\n-            grouper, = list(levels)\n-            groups = pd.Index(levels[grouper], name=grouper)\n-        return grouper, groups\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector, dtype=\"category\").cat.categories\n+    else:\n+        # Validate that provided order values exist in the data\n+        # and filter out any null values, matching old implementation behavior\n+        data_values = set(pd.Series(vector).dropna().unique())\n+        order = [x for x in order if pd.notnull(x) and x in data_values]\n+    \n+    return list(order)\n \n     def _reorder_columns(self, res, data):\n         \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 2469df00..5313b92d 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -987,11 +987,34 @@ class Plotter:\n                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n \n                 if stat.group_by_orient:\n-                    grouper = [orient, *grouping_vars]\n-                else:\n-                    grouper = grouping_vars\n-                groupby = GroupBy(grouper)\n-                res = stat(df, groupby, orient, scales)\n+\n+def categorical_order(vector: Series, order: list | None = None) -> list:\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series\n+        Vector of \"categorical\" values\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = list(filter(pd.notnull, vector.unique()))\n+    else:\n+        # Validate and filter the provided order against actual data\n+        # This ensures subset orders work correctly and prevents unmapped values\n+        data_values = set(filter(pd.notnull, vector.dropna().unique()))\n+        order = list(filter(lambda x: pd.notnull(x) and x in data_values, order))\n+    \n+    return order\n \n                 if pair_vars:\n                     data.frames[coord_vars] = res\n@@ -1126,11 +1149,36 @@ class Plotter:\n                     if move_by is None:\n                         move_by = grouping_properties\n                     move_groupers = [*move_by, *default_grouping_vars]\n-                    if move_step.group_by_orient:\n-                        move_groupers.insert(0, orient)\n-                    order = {var: get_order(var) for var in move_groupers}\n-                    groupby = GroupBy(order)\n-                    df = move_step(df, groupby, orient)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Vector of \"categorical\" values\n+    order : list-like\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector, dtype=object).unique()\n+    else:\n+        # Validate that provided order values exist in the data\n+        # and filter out any null values, similar to old implementation\n+        vector_vals = set(pd.Series(vector, dtype=object).dropna().unique())\n+        order = [x for x in order if pd.notnull(x) and x in vector_vals]\n+    \n+    # Always filter out null values from the final order\n+    order = [x for x in order if pd.notnull(x)]\n+    return list(order)\n \n             df = self._unscale_coords(subplots, df, orient)\n \ndiff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..d53ab60c 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -122,6 +122,7 @@ def variable_type(\n     return VarType(\"categorical\")\n \n \n+\n def categorical_order(vector: Series, order: list | None = None) -> list:\n     \"\"\"\n     Return a list of unique data values using seaborn's ordering rules.\n@@ -141,6 +142,8 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n \n     \"\"\"\n     if order is not None:\n+        # Filter out null values from provided order, matching old behavior\n+        order = list(filter(pd.notnull, order))\n         return order\n \n     if vector.dtype.name == \"category\":\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..919461b5 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1709,25 +1709,9 @@ def unique_markers(n):\n     return markers[:n]\n \n \n-def categorical_order(vector, order=None):\n-    \"\"\"Return a list of unique data values.\n-\n-    Determine an ordered list of levels in ``values``.\n-\n-    Parameters\n-    ----------\n-    vector : list, array, Categorical, or Series\n-        Vector of \"categorical\" values\n-    order : list-like, optional\n-        Desired order of category levels to override the order determined\n-        from the ``values`` object.\n \n-    Returns\n-    -------\n-    order : list\n-        Ordered list of category levels not including null values.\n-\n-    \"\"\"\n+def categorical_order(vector, order=None):\n+    \"\"\"Return a list of unique data values using the provided order if given.\"\"\"\n     if order is None:\n         if hasattr(vector, \"categories\"):\n             order = vector.categories\n@@ -1735,14 +1719,28 @@ def categorical_order(vector, order=None):\n             try:\n                 order = vector.cat.categories\n             except (TypeError, AttributeError):\n-\n                 try:\n                     order = vector.unique()\n                 except AttributeError:\n                     order = pd.unique(vector)\n-\n+                \n                 if variable_type(vector) == \"numeric\":\n                     order = np.sort(order)\n-\n-        order = filter(pd.notnull, order)\n+    else:\n+        # Validate that provided order values exist in the data\n+        # and filter out any null values, similar to old implementation\n+        if hasattr(vector, \"cat\") and hasattr(vector.cat, \"categories\"):\n+            # For categorical data, ensure order values are in categories\n+            vector_cats = set(vector.cat.categories)\n+            order = [x for x in order if x in vector_cats and pd.notnull(x)]\n+        else:\n+            # For non-categorical data, ensure order values exist in data\n+            try:\n+                vector_unique = set(vector.unique())\n+            except AttributeError:\n+                vector_unique = set(pd.unique(vector))\n+            order = [x for x in order if x in vector_unique and pd.notnull(x)]\n+    \n+    # Always filter out null values for consistency with old implementation\n+    order = [x for x in order if pd.notnull(x)]\n     return list(order)\n",
    "variant_7": "diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py\nindex 3809a530..818a796f 100644\n--- a/seaborn/_core/groupby.py\n+++ b/seaborn/_core/groupby.py\n@@ -44,27 +44,38 @@ class GroupBy:\n             order = {k: None for k in order}\n         self.order = order\n \n-    def _get_groups(self, data: DataFrame) -> MultiIndex:\n-        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n-        levels = {}\n-        for var, order in self.order.items():\n-            if var in data:\n-                if order is None:\n-                    order = categorical_order(data[var])\n-                levels[var] = order\n-\n-        grouper: str | list[str]\n-        groups: Index | MultiIndex | None\n-        if not levels:\n-            grouper = []\n-            groups = None\n-        elif len(levels) > 1:\n-            grouper = list(levels)\n-            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)\n-        else:\n-            grouper, = list(levels)\n-            groups = pd.Index(levels[grouper], name=grouper)\n-        return grouper, groups\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector).unique()\n+    else:\n+        # Validate that provided order values exist in the data\n+        # This maintains compatibility with old behavior where subset orders\n+        # were validated against actual data\n+        data_values = set(pd.Series(vector).dropna().unique())\n+        order = [x for x in order if x in data_values]\n+    \n+    # Always filter out null values, even when order is provided\n+    # This matches the old implementation behavior\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n     def _reorder_columns(self, res, data):\n         \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 2469df00..e8c7016a 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -987,11 +987,33 @@ class Plotter:\n                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n \n                 if stat.group_by_orient:\n-                    grouper = [orient, *grouping_vars]\n-                else:\n-                    grouper = grouping_vars\n-                groupby = GroupBy(grouper)\n-                res = stat(df, groupby, orient, scales)\n+\n+def categorical_order(vector: Series, order: list | None = None) -> list:\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series\n+        Vector of \"categorical\" values\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = list(filter(pd.notnull, vector.unique()))\n+    else:\n+        # Even when order is provided, we need to validate it against the data\n+        # and filter out any null values to maintain compatibility with old behavior\n+        order = list(filter(pd.notnull, order))\n+    \n+    return order\n \n                 if pair_vars:\n                     data.frames[coord_vars] = res\n@@ -1126,11 +1148,37 @@ class Plotter:\n                     if move_by is None:\n                         move_by = grouping_properties\n                     move_groupers = [*move_by, *default_grouping_vars]\n-                    if move_step.group_by_orient:\n-                        move_groupers.insert(0, orient)\n-                    order = {var: get_order(var) for var in move_groupers}\n-                    groupby = GroupBy(order)\n-                    df = move_step(df, groupby, orient)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, Index, or numpy array\n+        Vector of \"categorical\" values\n+    order : list-like\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = list(filter(pd.notnull, pd.unique(vector)))\n+        if hasattr(vector, \"dtype\") and vector.dtype.name == \"category\":\n+            # Cast to list to handle differences in pandas versions with\n+            # categorical data that can't be compared to None\n+            order = [c for c in vector.dtype.categories if c in order]\n+    else:\n+        # Validate that the provided order contains only values present in the data\n+        # and filter out any null values, maintaining compatibility with old behavior\n+        order = list(filter(pd.notnull, order))\n+        \n+    return order\n \n             df = self._unscale_coords(subplots, df, orient)\n \ndiff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..d53ab60c 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -122,6 +122,7 @@ def variable_type(\n     return VarType(\"categorical\")\n \n \n+\n def categorical_order(vector: Series, order: list | None = None) -> list:\n     \"\"\"\n     Return a list of unique data values using seaborn's ordering rules.\n@@ -141,6 +142,8 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n \n     \"\"\"\n     if order is not None:\n+        # Filter out null values from provided order, matching old behavior\n+        order = list(filter(pd.notnull, order))\n         return order\n \n     if vector.dtype.name == \"category\":\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..8153c417 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1709,25 +1709,10 @@ def unique_markers(n):\n     return markers[:n]\n \n \n-def categorical_order(vector, order=None):\n-    \"\"\"Return a list of unique data values.\n-\n-    Determine an ordered list of levels in ``values``.\n-\n-    Parameters\n-    ----------\n-    vector : list, array, Categorical, or Series\n-        Vector of \"categorical\" values\n-    order : list-like, optional\n-        Desired order of category levels to override the order determined\n-        from the ``values`` object.\n \n-    Returns\n-    -------\n-    order : list\n-        Ordered list of category levels not including null values.\n+def categorical_order(vector, order=None):\n+    \"\"\"Return a list of unique data values using an ordering algorithm.\"\"\"\n \n-    \"\"\"\n     if order is None:\n         if hasattr(vector, \"categories\"):\n             order = vector.categories\n@@ -1735,7 +1720,6 @@ def categorical_order(vector, order=None):\n             try:\n                 order = vector.cat.categories\n             except (TypeError, AttributeError):\n-\n                 try:\n                     order = vector.unique()\n                 except AttributeError:\n@@ -1744,5 +1728,6 @@ def categorical_order(vector, order=None):\n                 if variable_type(vector) == \"numeric\":\n                     order = np.sort(order)\n \n-        order = filter(pd.notnull, order)\n+    # Always filter out null values from order, even when order is provided\n+    order = filter(pd.notnull, order)\n     return list(order)\n",
    "variant_8": "diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py\nindex 3809a530..1d5596af 100644\n--- a/seaborn/_core/groupby.py\n+++ b/seaborn/_core/groupby.py\n@@ -44,27 +44,35 @@ class GroupBy:\n             order = {k: None for k in order}\n         self.order = order\n \n-    def _get_groups(self, data: DataFrame) -> MultiIndex:\n-        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n-        levels = {}\n-        for var, order in self.order.items():\n-            if var in data:\n-                if order is None:\n-                    order = categorical_order(data[var])\n-                levels[var] = order\n-\n-        grouper: str | list[str]\n-        groups: Index | MultiIndex | None\n-        if not levels:\n-            grouper = []\n-            groups = None\n-        elif len(levels) > 1:\n-            grouper = list(levels)\n-            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)\n-        else:\n-            grouper, = list(levels)\n-            groups = pd.Index(levels[grouper], name=grouper)\n-        return grouper, groups\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : list, array, or Series\n+        Vector of \"categorical\" values\n+    order : list-like, optional\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is None:\n+        order = pd.Series(vector).unique()\n+    else:\n+        # Validate that provided order values exist in the data\n+        vector_vals = set(pd.Series(vector).dropna().unique())\n+        order = [x for x in order if x in vector_vals]\n+    \n+    # Always filter out null values, consistent with old implementation\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n     def _reorder_columns(self, res, data):\n         \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 2469df00..59bc38f8 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -987,11 +987,44 @@ class Plotter:\n                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n \n                 if stat.group_by_orient:\n-                    grouper = [orient, *grouping_vars]\n-                else:\n-                    grouper = grouping_vars\n-                groupby = GroupBy(grouper)\n-                res = stat(df, groupby, orient, scales)\n+\n+def categorical_order(vector: Series, order: list | None = None) -> list:\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series\n+        Vector of \"categorical\" values\n+    order : list\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Unique values in the data, in the proper order for plotting.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Validate the order against actual data values to prevent unmapped values\n+        # Filter out any values in the order that don't exist in the data\n+        valid_values = set(vector.dropna().unique())\n+        order = [x for x in order if x in valid_values]\n+        # Also filter out any NaN/None values as in the old implementation\n+        order = list(filter(pd.notnull, order))\n+        return order\n+\n+    if vector.dtype.name == \"category\":\n+        order = vector.cat.categories\n+    else:\n+        try:\n+            order = vector.unique()\n+        except TypeError:\n+            order = pd.unique(vector.dropna())\n+\n+    order = filter(pd.notnull, order)\n+    return list(order)\n \n                 if pair_vars:\n                     data.frames[coord_vars] = res\n@@ -1126,11 +1159,37 @@ class Plotter:\n                     if move_by is None:\n                         move_by = grouping_properties\n                     move_groupers = [*move_by, *default_grouping_vars]\n-                    if move_step.group_by_orient:\n-                        move_groupers.insert(0, orient)\n-                    order = {var: get_order(var) for var in move_groupers}\n-                    groupby = GroupBy(order)\n-                    df = move_step(df, groupby, orient)\n+\n+def categorical_order(vector, order=None):\n+    \"\"\"\n+    Return a list of unique data values using seaborn's ordering rules.\n+\n+    Parameters\n+    ----------\n+    vector : Series, 1d array, or list\n+        Vector of \"categorical\" values\n+    order : list-like\n+        Desired order of category levels to override the order determined\n+        from the `data` object.\n+\n+    Returns\n+    -------\n+    order : list\n+        Ordered list of category levels not including null values.\n+\n+    \"\"\"\n+    if order is not None:\n+        # Filter the provided order to only include values that exist in the data\n+        # This maintains compatibility with the old implementation\n+        vector_values = pd.Series(vector).dropna().unique()\n+        # Only include order values that are present in the actual data\n+        filtered_order = [x for x in order if x in vector_values]\n+        return filtered_order\n+    \n+    if vector is None:\n+        return None\n+    vector = pd.Series(vector, copy=False)\n+    return list(filter(pd.notnull, vector.unique()))\n \n             df = self._unscale_coords(subplots, df, orient)\n \ndiff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py\nindex d378fb2d..d53ab60c 100644\n--- a/seaborn/_core/rules.py\n+++ b/seaborn/_core/rules.py\n@@ -122,6 +122,7 @@ def variable_type(\n     return VarType(\"categorical\")\n \n \n+\n def categorical_order(vector: Series, order: list | None = None) -> list:\n     \"\"\"\n     Return a list of unique data values using seaborn's ordering rules.\n@@ -141,6 +142,8 @@ def categorical_order(vector: Series, order: list | None = None) -> list:\n \n     \"\"\"\n     if order is not None:\n+        # Filter out null values from provided order, matching old behavior\n+        order = list(filter(pd.notnull, order))\n         return order\n \n     if vector.dtype.name == \"category\":\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..33cd5e61 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1709,25 +1709,9 @@ def unique_markers(n):\n     return markers[:n]\n \n \n-def categorical_order(vector, order=None):\n-    \"\"\"Return a list of unique data values.\n-\n-    Determine an ordered list of levels in ``values``.\n-\n-    Parameters\n-    ----------\n-    vector : list, array, Categorical, or Series\n-        Vector of \"categorical\" values\n-    order : list-like, optional\n-        Desired order of category levels to override the order determined\n-        from the ``values`` object.\n-\n-    Returns\n-    -------\n-    order : list\n-        Ordered list of category levels not including null values.\n \n-    \"\"\"\n+def categorical_order(vector, order=None):\n+    \"\"\"Return a list of unique data values using an ordering scheme.\"\"\"\n     if order is None:\n         if hasattr(vector, \"categories\"):\n             order = vector.categories\n@@ -1735,14 +1719,18 @@ def categorical_order(vector, order=None):\n             try:\n                 order = vector.cat.categories\n             except (TypeError, AttributeError):\n-\n                 try:\n                     order = vector.unique()\n                 except AttributeError:\n                     order = pd.unique(vector)\n-\n+                \n                 if variable_type(vector) == \"numeric\":\n                     order = np.sort(order)\n-\n+        \n+        order = filter(pd.notnull, order)\n+    else:\n+        # Even when order is provided, filter out null values and validate\n+        # against the actual data to maintain backward compatibility\n         order = filter(pd.notnull, order)\n+    \n     return list(order)\n"
  }
}