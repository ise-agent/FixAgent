{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/artist.py lines 1307-1312)": "\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default for non-finite values\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/colors.py lines 1904-1912)": "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/artist.py lines 1307-1312)": [
      "\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default for non-finite values\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default for non-finite values\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default for non-finite values\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default for non-finite values\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default for non-finite values\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default for non-finite values\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default for non-finite values\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default for non-finite values\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n"
    ],
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/colors.py lines 1904-1912)": [
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n",
      "\n    def inverse(self, value):\n        \"\"\"\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        \"\"\"\n        raise ValueError(\"BoundaryNorm is not invertible\")\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..5880bac234 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1304,10 +1304,16 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default for non-finite values\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_0": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..304891c6d1 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1304,10 +1304,17 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+\n+            if np.isfinite(normed):\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default for non-finite values\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_1": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..304891c6d1 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1304,10 +1304,17 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+\n+            if np.isfinite(normed):\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default for non-finite values\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_2": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..304891c6d1 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1304,10 +1304,17 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+\n+            if np.isfinite(normed):\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default for non-finite values\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_3": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..304891c6d1 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1304,10 +1304,17 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+\n+            if np.isfinite(normed):\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default for non-finite values\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_4": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..b030b25f2d 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1304,10 +1304,17 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+\n+            if np.isfinite(normed):\n+                # Midpoints of neighboring color intervals.\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default for non-finite values\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_5": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..304891c6d1 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1304,10 +1304,17 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+\n+            if np.isfinite(normed):\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default for non-finite values\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_6": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..304891c6d1 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1304,10 +1304,17 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+\n+            if np.isfinite(normed):\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default for non-finite values\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_7": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..304891c6d1 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1304,10 +1304,17 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+\n+            if np.isfinite(normed):\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default for non-finite values\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_8": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..304891c6d1 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1304,10 +1304,17 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+\n+            if np.isfinite(normed):\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default for non-finite values\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n"
  }
}