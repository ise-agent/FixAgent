{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/deletion.py lines 278-280)": "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/deletion.py lines 324-326)": "\n        # fast deletes\n        for qs in self.fast_deletes:\n            count = qs._raw_delete(using=self.using)\n            if count:\n                deleted_counter[qs.model._meta.label] += count\n\n        # delete instances\n        for model, instances in self.data.items():\n            pk_list = [obj.pk for obj in instances]\n            query = sql.DeleteQuery(model)\n            query.delete_batch(pk_list, self.using)\n            deleted_counter[model._meta.label] += len(instances)\n\n            if not model._meta.auto_created:\n                for obj in instances:\n                    signals.post_delete.send(\n                        sender=model, instance=obj, using=self.using\n                    )\n\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/deletion.py lines 278-280)": [
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/deletion.py lines 324-326)": [
      "\n                # update collected instances\n                for instances_for_fieldvalues in self.field_updates.values():\n                    for (field, value), instances in instances_for_fieldvalues.items():\n                        for obj in instances:\n                            setattr(obj, field.attname, value)\n                for model, instances in self.data.items():\n                    for instance in instances:\n                        setattr(instance, model._meta.pk.attname, None)\n",
      "\n                    # fast delete\n                    if len(self.data) == 1:\n                        model = list(self.data)[0]\n                        if len(self.data[model]) == 1:\n                            instance = self.data[model][0]\n                            if self.can_fast_delete(instance):\n                                with transaction.mark_for_rollback_on_error(self.using):\n                                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                                setattr(instance, model._meta.pk.attname, None)\n                                return count, {model._meta.label: count}\n",
      "\n        # fast delete\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error(self.using):\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count}\n",
      "\n                # Optimization: if there is only one object and no\n                # dependencies, just delete it.\n                setattr(instance, model._meta.pk.attname, None)\n                return 1, {model._meta.label: 1}\n",
      "\n                # fast deletes\n                for qs in self.fast_deletes:\n                    count = qs._raw_delete(using=self.using)\n                    if count:\n                        deleted_counter[qs.model._meta.label] += count\n\n                # update fields\n                for model, instances_for_fieldvalues in self.field_updates.items():\n                    for (field, value), instances in instances_for_fieldvalues.items():\n                        query = sql.UpdateQuery(model)\n                        query.update_batch([obj.pk for obj in instances],\n                                           {field.name: value}, self.using)\n\n                # reverse instance collections\n                for instances in self.data.values():\n                    instances.reverse()\n\n                # delete instances\n                for model, instances in self.data.items():\n                    query = sql.DeleteQuery(model)\n                    pk_list = [obj.pk for obj in instances]\n                    count = query.delete_batch(pk_list, self.using)\n                    if count:\n                        deleted_counter[model._meta.label] += count\n\n                    if not model._meta.auto_created:\n                        for obj in instances:\n                            signals.post_delete.send(\n                                sender=model, instance=obj, using=self.using\n                            )\n\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n",
      "\n                # update collected instances\n                for instances_for_fieldvalues in self.field_updates.values():\n                    for (field, value), instances in instances_for_fieldvalues.items():\n                        for obj in instances:\n                            setattr(obj, field.attname, value)\n                for model, instances in self.data.items():\n                    for instance in instances:\n                        setattr(instance, model._meta.pk.attname, None)\n                return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n                    deleted_counter[model._meta.label] += 1\n                    setattr(instance, model._meta.pk.attname, None)\n                    return deleted_counter, {model._meta.label: deleted_counter[model._meta.label]}\n",
      "\n                # Clear the pk so it doesn't keep a reference to the database.\n                setattr(instance, model._meta.pk.attname, None)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..5bebd6a753 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -275,8 +275,10 @@ class Collector:\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n+\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -321,6 +323,7 @@ class Collector:\n             for (field, value), instances in instances_for_fieldvalues.items():\n                 for obj in instances:\n                     setattr(obj, field.attname, value)\n+\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n",
    "variant_0": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..f0265cb9bf 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -271,12 +271,18 @@ class Collector:\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n \n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+\n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -316,6 +322,31 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+            for (field, value), instances in instances_for_fieldvalues.items():\n+                for obj in instances:\n+                    setattr(obj, field.attname, value)\n+\n+        # fast deletes\n+        for qs in self.fast_deletes:\n+            count = qs._raw_delete(using=self.using)\n+            if count:\n+                deleted_counter[qs.model._meta.label] += count\n+\n+        # delete instances\n+        for model, instances in self.data.items():\n+            pk_list = [obj.pk for obj in instances]\n+            query = sql.DeleteQuery(model)\n+            query.delete_batch(pk_list, self.using)\n+            deleted_counter[model._meta.label] += len(instances)\n+\n+            if not model._meta.auto_created:\n+                for obj in instances:\n+                    signals.post_delete.send(\n+                        sender=model, instance=obj, using=self.using\n+                    )\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n",
    "variant_1": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..9c06bcefa9 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -271,12 +271,18 @@ class Collector:\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n \n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+\n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -321,7 +327,13 @@ class Collector:\n             for (field, value), instances in instances_for_fieldvalues.items():\n                 for obj in instances:\n                     setattr(obj, field.attname, value)\n-        for model, instances in self.data.items():\n-            for instance in instances:\n-                setattr(instance, model._meta.pk.attname, None)\n+\n+                # update collected instances\n+                for instances_for_fieldvalues in self.field_updates.values():\n+                    for (field, value), instances in instances_for_fieldvalues.items():\n+                        for obj in instances:\n+                            setattr(obj, field.attname, value)\n+                for model, instances in self.data.items():\n+                    for instance in instances:\n+                        setattr(instance, model._meta.pk.attname, None)\n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_2": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..a04c1e4a47 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -271,12 +271,18 @@ class Collector:\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n \n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+\n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -321,7 +327,15 @@ class Collector:\n             for (field, value), instances in instances_for_fieldvalues.items():\n                 for obj in instances:\n                     setattr(obj, field.attname, value)\n-        for model, instances in self.data.items():\n-            for instance in instances:\n-                setattr(instance, model._meta.pk.attname, None)\n+\n+                    # fast delete\n+                    if len(self.data) == 1:\n+                        model = list(self.data)[0]\n+                        if len(self.data[model]) == 1:\n+                            instance = self.data[model][0]\n+                            if self.can_fast_delete(instance):\n+                                with transaction.mark_for_rollback_on_error(self.using):\n+                                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                                setattr(instance, model._meta.pk.attname, None)\n+                                return count, {model._meta.label: count}\n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_3": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..40aba83c50 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -271,12 +271,18 @@ class Collector:\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n \n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+\n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -321,7 +327,13 @@ class Collector:\n             for (field, value), instances in instances_for_fieldvalues.items():\n                 for obj in instances:\n                     setattr(obj, field.attname, value)\n-        for model, instances in self.data.items():\n-            for instance in instances:\n+\n+        # fast delete\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error(self.using):\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count}\n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_4": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..92447d11c9 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -271,12 +271,18 @@ class Collector:\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n \n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+\n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -321,7 +327,9 @@ class Collector:\n             for (field, value), instances in instances_for_fieldvalues.items():\n                 for obj in instances:\n                     setattr(obj, field.attname, value)\n-        for model, instances in self.data.items():\n-            for instance in instances:\n+\n+                # Optimization: if there is only one object and no\n+                # dependencies, just delete it.\n                 setattr(instance, model._meta.pk.attname, None)\n+                return 1, {model._meta.label: 1}\n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_5": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..fd2936964f 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -271,12 +271,18 @@ class Collector:\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n \n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+\n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -316,6 +322,43 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+            for (field, value), instances in instances_for_fieldvalues.items():\n+                for obj in instances:\n+                    setattr(obj, field.attname, value)\n+\n+                # fast deletes\n+                for qs in self.fast_deletes:\n+                    count = qs._raw_delete(using=self.using)\n+                    if count:\n+                        deleted_counter[qs.model._meta.label] += count\n+\n+                # update fields\n+                for model, instances_for_fieldvalues in self.field_updates.items():\n+                    for (field, value), instances in instances_for_fieldvalues.items():\n+                        query = sql.UpdateQuery(model)\n+                        query.update_batch([obj.pk for obj in instances],\n+                                           {field.name: value}, self.using)\n+\n+                # reverse instance collections\n+                for instances in self.data.values():\n+                    instances.reverse()\n+\n+                # delete instances\n+                for model, instances in self.data.items():\n+                    query = sql.DeleteQuery(model)\n+                    pk_list = [obj.pk for obj in instances]\n+                    count = query.delete_batch(pk_list, self.using)\n+                    if count:\n+                        deleted_counter[model._meta.label] += count\n+\n+                    if not model._meta.auto_created:\n+                        for obj in instances:\n+                            signals.post_delete.send(\n+                                sender=model, instance=obj, using=self.using\n+                            )\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n",
    "variant_6": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..09cc3d18b2 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -271,12 +271,18 @@ class Collector:\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n \n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+\n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -321,7 +327,14 @@ class Collector:\n             for (field, value), instances in instances_for_fieldvalues.items():\n                 for obj in instances:\n                     setattr(obj, field.attname, value)\n-        for model, instances in self.data.items():\n-            for instance in instances:\n-                setattr(instance, model._meta.pk.attname, None)\n+\n+                # update collected instances\n+                for instances_for_fieldvalues in self.field_updates.values():\n+                    for (field, value), instances in instances_for_fieldvalues.items():\n+                        for obj in instances:\n+                            setattr(obj, field.attname, value)\n+                for model, instances in self.data.items():\n+                    for instance in instances:\n+                        setattr(instance, model._meta.pk.attname, None)\n+                return sum(deleted_counter.values()), dict(deleted_counter)\n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_7": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..8bcd88f0ee 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -271,12 +271,18 @@ class Collector:\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n \n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+\n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -321,7 +327,8 @@ class Collector:\n             for (field, value), instances in instances_for_fieldvalues.items():\n                 for obj in instances:\n                     setattr(obj, field.attname, value)\n-        for model, instances in self.data.items():\n-            for instance in instances:\n-                setattr(instance, model._meta.pk.attname, None)\n+\n+                    deleted_counter[model._meta.label] += 1\n+                    setattr(instance, model._meta.pk.attname, None)\n+                    return deleted_counter, {model._meta.label: deleted_counter[model._meta.label]}\n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_8": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..03320940d3 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -271,12 +271,18 @@ class Collector:\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n \n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+\n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -321,6 +327,9 @@ class Collector:\n             for (field, value), instances in instances_for_fieldvalues.items():\n                 for obj in instances:\n                     setattr(obj, field.attname, value)\n+\n+                # Clear the pk so it doesn't keep a reference to the database.\n+                setattr(instance, model._meta.pk.attname, None)\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n"
  }
}