{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/query_utils.py lines 47-53)": "\ndef _combine(self, other, conn):\n    if not isinstance(other, Q):\n        raise TypeError(other)\n\n    # If the other Q() is empty, ignore it and just use `self`.\n    if not other:\n        return copy.deepcopy(self)\n    # Or if this Q is empty, ignore it and just use `other`.\n    elif not self:\n        return copy.deepcopy(other)\n\n    obj = type(self)()\n    obj.connector = conn\n    obj.add(self, conn)\n    obj.add(other, conn)\n    return obj\n",
    "Location 2 (/root/hy/projects_4/django/django/utils/tree.py lines 50-54)": "\n    def __deepcopy__(self, memodict):\n        obj = Node(connector=self.connector, negated=self.negated)\n        obj.__class__ = self.__class__\n        # Convert non-pickleable types to pickleable before deepcopy\n        hashable_children = make_hashable(self.children)\n        obj.children = copy.deepcopy(hashable_children, memodict)\n        return obj\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/query_utils.py lines 47-53)": [
      "\n    def _combine(self, other, conn):\n        if not isinstance(other, Q):\n            raise TypeError(other)\n\n        # If the other Q() is empty, ignore it and just use `self`.\n        if not other:\n            return copy.deepcopy(self)\n        # Or if this Q is empty, ignore it and just use `other`.\n        elif not self:\n            return copy.deepcopy(other)\n\n        obj = type(self)()\n        obj.connector = conn\n        obj.add(self, conn)\n        obj.add(other, conn)\n        return obj\n",
      "\n    def _combine(self, other, conn):\n        if not isinstance(other, Q):\n            raise TypeError(other)\n\n        # If the other Q() is empty, ignore it and just use `self`.\n        if not other:\n            return copy.deepcopy(self)\n        # Or if this Q is empty, ignore it and just use `other`.\n        elif not self:\n            return copy.deepcopy(other)\n\n        obj = type(self)()\n        obj.connector = conn\n        obj.add(self, conn)\n        obj.add(other, conn)\n        return obj\n",
      "\n    def _combine(self, other, conn):\n        if not isinstance(other, Q):\n            raise TypeError(other)\n\n        # If the other Q() is empty, ignore it and just use `self`.\n        if not other:\n            return copy.deepcopy(self)\n        # Or if this Q is empty, ignore it and just use `other`.\n        elif not self:\n            return copy.deepcopy(other)\n",
      "\ndef _combine(self, other, conn):\n    if not isinstance(other, Q):\n        raise TypeError(other)\n\n    # If the other Q() is empty, ignore it and just use `self`.\n    if not other:\n        return copy.deepcopy(self)\n    # Or if this Q is empty, ignore it and just use `other`.\n    elif not self:\n        return copy.deepcopy(other)\n\n    obj = type(self)()\n    obj.connector = conn\n    obj.add(self, conn)\n    obj.add(other, conn)\n    return obj\n",
      "\n    def _combine(self, other, conn):\n        if not isinstance(other, Q):\n            raise TypeError(other)\n\n        # If the other Q() is empty, ignore it and just use `self`.\n        if not other:\n            return copy.deepcopy(self)\n        # Or if this Q is empty, ignore it and just use `other`.\n        elif not self:\n            return copy.deepcopy(other)\n\n        obj = type(self)()\n        obj.connector = conn\n        obj.add(self, conn)\n        obj.add(other, conn)\n        return obj\n",
      "\n    def _combine(self, other, conn):\n        if not isinstance(other, Q):\n            raise TypeError(other)\n\n        # If the other Q() is empty, ignore it and just use `self`.\n        if not other:\n            return copy.deepcopy(self)\n        # Or if this Q is empty, ignore it and just use `other`.\n        elif not self:\n            return copy.deepcopy(other)\n\n        obj = type(self)()\n        obj.connector = conn\n        obj.add(self, conn)\n        obj.add(other, conn)\n        return obj\n",
      "\ndef _combine(self, other, conn):\n    if not isinstance(other, Q):\n        raise TypeError(other)\n\n    # If the other Q() is empty, ignore it and just use `self`.\n    if not other:\n        return copy.deepcopy(self)\n    # Or if this Q is empty, ignore it and just use `other`.\n    elif not self:\n        return copy.deepcopy(other)\n\n    obj = type(self)()\n    obj.connector = conn\n    obj.add(self, conn)\n    obj.add(other, conn)\n    return obj\n",
      "\ndef _combine(self, other, conn):\n    if not isinstance(other, Q):\n        raise TypeError(other)\n\n    # If the other Q() is empty, ignore it and just use `self`.\n    if not other:\n        return copy.deepcopy(self)\n    # Or if this Q is empty, ignore it and just use `other`.\n    elif not self:\n        return copy.deepcopy(other)\n\n    obj = type(self)()\n    obj.connector = conn\n    obj.add(self, conn)\n    obj.add(other, conn)\n    return obj\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/utils/tree.py lines 50-54)": [
      "\n    def __deepcopy__(self, memodict):\n        obj = Node(connector=self.connector, negated=self.negated)\n        obj.__class__ = self.__class__\n        # Convert non-pickleable types to pickleable before deepcopy\n        hashable_children = make_hashable(self.children)\n        obj.children = copy.deepcopy(hashable_children, memodict)\n        return obj\n",
      "\n    def __deepcopy__(self, memodict):\n        obj = Node(connector=self.connector, negated=self.negated)\n        obj.__class__ = self.__class__\n        # Convert non-pickleable types to pickleable before deepcopy\n        hashable_children = make_hashable(self.children)\n        obj.children = copy.deepcopy(hashable_children, memodict)\n        return obj\n",
      "\n    def __deepcopy__(self, memodict):\n        obj = Node(connector=self.connector, negated=self.negated)\n        obj.__class__ = self.__class__\n        # Convert non-pickleable types to pickleable before deepcopy\n        hashable_children = make_hashable(self.children)\n        obj.children = copy.deepcopy(hashable_children, memodict)\n        return obj\n",
      "\n    def __deepcopy__(self, memodict):\n        obj = Node(connector=self.connector, negated=self.negated)\n        obj.__class__ = self.__class__\n        # Convert non-pickleable types to pickleable before deepcopy\n        hashable_children = make_hashable(self.children)\n        obj.children = copy.deepcopy(hashable_children, memodict)\n        return obj\n",
      "\n    def __deepcopy__(self, memodict):\n        obj = Node(connector=self.connector, negated=self.negated)\n        obj.__class__ = self.__class__\n        # Convert non-pickleable types to pickleable before deepcopy\n        hashable_children = make_hashable(self.children)\n        obj.children = copy.deepcopy(hashable_children, memodict)\n        return obj\n",
      "\n    def __deepcopy__(self, memodict):\n        obj = Node(connector=self.connector, negated=self.negated)\n        obj.__class__ = self.__class__\n        # Convert non-pickleable types to pickleable before deepcopy\n        hashable_children = make_hashable(self.children)\n        obj.children = copy.deepcopy(hashable_children, memodict)\n        return obj\n",
      "\n    def __deepcopy__(self, memodict):\n        obj = Node(connector=self.connector, negated=self.negated)\n        obj.__class__ = self.__class__\n        # Convert non-pickleable types to pickleable before deepcopy\n        hashable_children = make_hashable(self.children)\n        obj.children = copy.deepcopy(hashable_children, memodict)\n        return obj\n",
      "\n    def __deepcopy__(self, memodict):\n        obj = Node(connector=self.connector, negated=self.negated)\n        obj.__class__ = self.__class__\n        # Convert non-pickleable types to pickleable before deepcopy\n        hashable_children = make_hashable(self.children)\n        obj.children = copy.deepcopy(hashable_children, memodict)\n        return obj\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..420dfa1526 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -44,6 +44,7 @@ class Q(tree.Node):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n \n+\n         # If the other Q() is empty, ignore it and just use `self`.\n         if not other:\n             return copy.deepcopy(self)\ndiff --git a/django/utils/tree.py b/django/utils/tree.py\nindex 302cd37d5f..d85dd814a5 100644\n--- a/django/utils/tree.py\n+++ b/django/utils/tree.py\n@@ -47,10 +47,11 @@ class Node:\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__name__, self)\n \n+\n     def __deepcopy__(self, memodict):\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        obj.children = copy.deepcopy(make_hashable(self.children), memodict)\n         return obj\n \n     def __len__(self):\n",
    "variant_0": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..77ae018b1a 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -44,13 +44,23 @@ class Q(tree.Node):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n \n-        # If the other Q() is empty, ignore it and just use `self`.\n-        if not other:\n-            return copy.deepcopy(self)\n-        # Or if this Q is empty, ignore it and just use `other`.\n-        elif not self:\n-            return copy.deepcopy(other)\n \n+def _combine(self, other, conn):\n+    if not isinstance(other, Q):\n+        raise TypeError(other)\n+\n+    # If the other Q() is empty, ignore it and just use `self`.\n+    if not other:\n+        return copy.deepcopy(self)\n+    # Or if this Q is empty, ignore it and just use `other`.\n+    elif not self:\n+        return copy.deepcopy(other)\n+\n+    obj = type(self)()\n+    obj.connector = conn\n+    obj.add(self, conn)\n+    obj.add(other, conn)\n+    return obj\n         obj = type(self)()\n         obj.connector = conn\n         obj.add(self, conn)\ndiff --git a/django/utils/tree.py b/django/utils/tree.py\nindex 302cd37d5f..2938c641a6 100644\n--- a/django/utils/tree.py\n+++ b/django/utils/tree.py\n@@ -47,10 +47,13 @@ class Node:\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__name__, self)\n \n+\n     def __deepcopy__(self, memodict):\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        # Convert non-pickleable types to pickleable before deepcopy\n+        hashable_children = make_hashable(self.children)\n+        obj.children = copy.deepcopy(hashable_children, memodict)\n         return obj\n \n     def __len__(self):\n",
    "variant_1": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..d80d24ac3f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,6 +40,11 @@ class Q(tree.Node):\n     def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n+    def _combine(self, other, conn):\n+        if not isinstance(other, Q):\n+            raise TypeError(other)\n+\n+\n     def _combine(self, other, conn):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n@@ -56,6 +61,11 @@ class Q(tree.Node):\n         obj.add(self, conn)\n         obj.add(other, conn)\n         return obj\n+        obj = type(self)()\n+        obj.connector = conn\n+        obj.add(self, conn)\n+        obj.add(other, conn)\n+        return obj\n \n     def __or__(self, other):\n         return self._combine(other, self.OR)\ndiff --git a/django/utils/tree.py b/django/utils/tree.py\nindex 302cd37d5f..2938c641a6 100644\n--- a/django/utils/tree.py\n+++ b/django/utils/tree.py\n@@ -47,10 +47,13 @@ class Node:\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__name__, self)\n \n+\n     def __deepcopy__(self, memodict):\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        # Convert non-pickleable types to pickleable before deepcopy\n+        hashable_children = make_hashable(self.children)\n+        obj.children = copy.deepcopy(hashable_children, memodict)\n         return obj\n \n     def __len__(self):\n",
    "variant_2": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..d80d24ac3f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,6 +40,11 @@ class Q(tree.Node):\n     def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n+    def _combine(self, other, conn):\n+        if not isinstance(other, Q):\n+            raise TypeError(other)\n+\n+\n     def _combine(self, other, conn):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n@@ -56,6 +61,11 @@ class Q(tree.Node):\n         obj.add(self, conn)\n         obj.add(other, conn)\n         return obj\n+        obj = type(self)()\n+        obj.connector = conn\n+        obj.add(self, conn)\n+        obj.add(other, conn)\n+        return obj\n \n     def __or__(self, other):\n         return self._combine(other, self.OR)\ndiff --git a/django/utils/tree.py b/django/utils/tree.py\nindex 302cd37d5f..2938c641a6 100644\n--- a/django/utils/tree.py\n+++ b/django/utils/tree.py\n@@ -47,10 +47,13 @@ class Node:\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__name__, self)\n \n+\n     def __deepcopy__(self, memodict):\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        # Convert non-pickleable types to pickleable before deepcopy\n+        hashable_children = make_hashable(self.children)\n+        obj.children = copy.deepcopy(hashable_children, memodict)\n         return obj\n \n     def __len__(self):\n",
    "variant_3": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..ff08f89ff6 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,6 +40,11 @@ class Q(tree.Node):\n     def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n+    def _combine(self, other, conn):\n+        if not isinstance(other, Q):\n+            raise TypeError(other)\n+\n+\n     def _combine(self, other, conn):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n@@ -50,7 +55,6 @@ class Q(tree.Node):\n         # Or if this Q is empty, ignore it and just use `other`.\n         elif not self:\n             return copy.deepcopy(other)\n-\n         obj = type(self)()\n         obj.connector = conn\n         obj.add(self, conn)\ndiff --git a/django/utils/tree.py b/django/utils/tree.py\nindex 302cd37d5f..2938c641a6 100644\n--- a/django/utils/tree.py\n+++ b/django/utils/tree.py\n@@ -47,10 +47,13 @@ class Node:\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__name__, self)\n \n+\n     def __deepcopy__(self, memodict):\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        # Convert non-pickleable types to pickleable before deepcopy\n+        hashable_children = make_hashable(self.children)\n+        obj.children = copy.deepcopy(hashable_children, memodict)\n         return obj\n \n     def __len__(self):\n",
    "variant_4": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..77ae018b1a 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -44,13 +44,23 @@ class Q(tree.Node):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n \n-        # If the other Q() is empty, ignore it and just use `self`.\n-        if not other:\n-            return copy.deepcopy(self)\n-        # Or if this Q is empty, ignore it and just use `other`.\n-        elif not self:\n-            return copy.deepcopy(other)\n \n+def _combine(self, other, conn):\n+    if not isinstance(other, Q):\n+        raise TypeError(other)\n+\n+    # If the other Q() is empty, ignore it and just use `self`.\n+    if not other:\n+        return copy.deepcopy(self)\n+    # Or if this Q is empty, ignore it and just use `other`.\n+    elif not self:\n+        return copy.deepcopy(other)\n+\n+    obj = type(self)()\n+    obj.connector = conn\n+    obj.add(self, conn)\n+    obj.add(other, conn)\n+    return obj\n         obj = type(self)()\n         obj.connector = conn\n         obj.add(self, conn)\ndiff --git a/django/utils/tree.py b/django/utils/tree.py\nindex 302cd37d5f..2938c641a6 100644\n--- a/django/utils/tree.py\n+++ b/django/utils/tree.py\n@@ -47,10 +47,13 @@ class Node:\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__name__, self)\n \n+\n     def __deepcopy__(self, memodict):\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        # Convert non-pickleable types to pickleable before deepcopy\n+        hashable_children = make_hashable(self.children)\n+        obj.children = copy.deepcopy(hashable_children, memodict)\n         return obj\n \n     def __len__(self):\n",
    "variant_5": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..d80d24ac3f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,6 +40,11 @@ class Q(tree.Node):\n     def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n+    def _combine(self, other, conn):\n+        if not isinstance(other, Q):\n+            raise TypeError(other)\n+\n+\n     def _combine(self, other, conn):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n@@ -56,6 +61,11 @@ class Q(tree.Node):\n         obj.add(self, conn)\n         obj.add(other, conn)\n         return obj\n+        obj = type(self)()\n+        obj.connector = conn\n+        obj.add(self, conn)\n+        obj.add(other, conn)\n+        return obj\n \n     def __or__(self, other):\n         return self._combine(other, self.OR)\ndiff --git a/django/utils/tree.py b/django/utils/tree.py\nindex 302cd37d5f..2938c641a6 100644\n--- a/django/utils/tree.py\n+++ b/django/utils/tree.py\n@@ -47,10 +47,13 @@ class Node:\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__name__, self)\n \n+\n     def __deepcopy__(self, memodict):\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        # Convert non-pickleable types to pickleable before deepcopy\n+        hashable_children = make_hashable(self.children)\n+        obj.children = copy.deepcopy(hashable_children, memodict)\n         return obj\n \n     def __len__(self):\n",
    "variant_6": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..d80d24ac3f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,6 +40,11 @@ class Q(tree.Node):\n     def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n+    def _combine(self, other, conn):\n+        if not isinstance(other, Q):\n+            raise TypeError(other)\n+\n+\n     def _combine(self, other, conn):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n@@ -56,6 +61,11 @@ class Q(tree.Node):\n         obj.add(self, conn)\n         obj.add(other, conn)\n         return obj\n+        obj = type(self)()\n+        obj.connector = conn\n+        obj.add(self, conn)\n+        obj.add(other, conn)\n+        return obj\n \n     def __or__(self, other):\n         return self._combine(other, self.OR)\ndiff --git a/django/utils/tree.py b/django/utils/tree.py\nindex 302cd37d5f..2938c641a6 100644\n--- a/django/utils/tree.py\n+++ b/django/utils/tree.py\n@@ -47,10 +47,13 @@ class Node:\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__name__, self)\n \n+\n     def __deepcopy__(self, memodict):\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        # Convert non-pickleable types to pickleable before deepcopy\n+        hashable_children = make_hashable(self.children)\n+        obj.children = copy.deepcopy(hashable_children, memodict)\n         return obj\n \n     def __len__(self):\n",
    "variant_7": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..77ae018b1a 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -44,13 +44,23 @@ class Q(tree.Node):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n \n-        # If the other Q() is empty, ignore it and just use `self`.\n-        if not other:\n-            return copy.deepcopy(self)\n-        # Or if this Q is empty, ignore it and just use `other`.\n-        elif not self:\n-            return copy.deepcopy(other)\n \n+def _combine(self, other, conn):\n+    if not isinstance(other, Q):\n+        raise TypeError(other)\n+\n+    # If the other Q() is empty, ignore it and just use `self`.\n+    if not other:\n+        return copy.deepcopy(self)\n+    # Or if this Q is empty, ignore it and just use `other`.\n+    elif not self:\n+        return copy.deepcopy(other)\n+\n+    obj = type(self)()\n+    obj.connector = conn\n+    obj.add(self, conn)\n+    obj.add(other, conn)\n+    return obj\n         obj = type(self)()\n         obj.connector = conn\n         obj.add(self, conn)\ndiff --git a/django/utils/tree.py b/django/utils/tree.py\nindex 302cd37d5f..2938c641a6 100644\n--- a/django/utils/tree.py\n+++ b/django/utils/tree.py\n@@ -47,10 +47,13 @@ class Node:\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__name__, self)\n \n+\n     def __deepcopy__(self, memodict):\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        # Convert non-pickleable types to pickleable before deepcopy\n+        hashable_children = make_hashable(self.children)\n+        obj.children = copy.deepcopy(hashable_children, memodict)\n         return obj\n \n     def __len__(self):\n",
    "variant_8": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c2623f099f..77ae018b1a 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -44,13 +44,23 @@ class Q(tree.Node):\n         if not isinstance(other, Q):\n             raise TypeError(other)\n \n-        # If the other Q() is empty, ignore it and just use `self`.\n-        if not other:\n-            return copy.deepcopy(self)\n-        # Or if this Q is empty, ignore it and just use `other`.\n-        elif not self:\n-            return copy.deepcopy(other)\n \n+def _combine(self, other, conn):\n+    if not isinstance(other, Q):\n+        raise TypeError(other)\n+\n+    # If the other Q() is empty, ignore it and just use `self`.\n+    if not other:\n+        return copy.deepcopy(self)\n+    # Or if this Q is empty, ignore it and just use `other`.\n+    elif not self:\n+        return copy.deepcopy(other)\n+\n+    obj = type(self)()\n+    obj.connector = conn\n+    obj.add(self, conn)\n+    obj.add(other, conn)\n+    return obj\n         obj = type(self)()\n         obj.connector = conn\n         obj.add(self, conn)\ndiff --git a/django/utils/tree.py b/django/utils/tree.py\nindex 302cd37d5f..2938c641a6 100644\n--- a/django/utils/tree.py\n+++ b/django/utils/tree.py\n@@ -47,10 +47,13 @@ class Node:\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__name__, self)\n \n+\n     def __deepcopy__(self, memodict):\n         obj = Node(connector=self.connector, negated=self.negated)\n         obj.__class__ = self.__class__\n-        obj.children = copy.deepcopy(self.children, memodict)\n+        # Convert non-pickleable types to pickleable before deepcopy\n+        hashable_children = make_hashable(self.children)\n+        obj.children = copy.deepcopy(hashable_children, memodict)\n         return obj\n \n     def __len__(self):\n"
  }
}