{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/scikit-learn/sklearn/utils/_pprint.py lines 97-101)": "\ndef _changed_params(estimator):\n    \"\"\"Return dict (param_name: value) of parameters that were given to\n    estimator with non-default values.\"\"\"\n\n    params = estimator.get_params(deep=False)\n    filtered_params = {}\n    init_func = getattr(estimator.__init__, 'deprecated_original',\n                        estimator.__init__)\n    init_params = signature(init_func).parameters\n    init_params = {name: param.default for name, param in init_params.items()}\n    for k, v in params.items():\n        # Handle array comparison safely\n        try:\n            # For arrays, use np.array_equal for proper comparison\n            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n                import numpy as np\n                values_equal = np.array_equal(v, init_params[k])\n            else:\n                values_equal = (v == init_params[k])\n        except (ValueError, TypeError):\n            # Fallback for incompatible types\n            values_equal = False\n        \n        if (not values_equal and\n                not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n            filtered_params[k] = v\n    return filtered_params\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/scikit-learn/sklearn/utils/_pprint.py lines 97-101)": [
      "\ndef _changed_params(estimator):\n    \"\"\"Return dict (param_name: value) of parameters that were given to\n    estimator with non-default values.\"\"\"\n\n    params = estimator.get_params(deep=False)\n    filtered_params = {}\n    init_func = getattr(estimator.__init__, 'deprecated_original',\n                        estimator.__init__)\n    init_params = signature(init_func).parameters\n    init_params = {name: param.default for name, param in init_params.items()}\n    for k, v in params.items():\n        # Handle array comparison safely\n        try:\n            # For arrays, use np.array_equal for proper comparison\n            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n                import numpy as np\n                values_equal = np.array_equal(v, init_params[k])\n            else:\n                values_equal = (v == init_params[k])\n        except (ValueError, TypeError):\n            # Fallback for incompatible types\n            values_equal = False\n        \n        if (not values_equal and\n                not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n            filtered_params[k] = v\n    return filtered_params\n",
      "\ndef _changed_params(estimator):\n    \"\"\"Return dict (param_name: value) of parameters that were given to\n    estimator with non-default values.\"\"\"\n\n    params = estimator.get_params(deep=False)\n    filtered_params = {}\n    init_func = getattr(estimator.__init__, 'deprecated_original',\n                        estimator.__init__)\n    init_params = signature(init_func).parameters\n    init_params = {name: param.default for name, param in init_params.items()}\n    for k, v in params.items():\n        # Handle array comparison safely\n        try:\n            # For arrays, use np.array_equal for proper comparison\n            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n                import numpy as np\n                values_equal = np.array_equal(v, init_params[k])\n            else:\n                values_equal = (v == init_params[k])\n        except (ValueError, TypeError):\n            # Fallback for incompatible types\n            values_equal = False\n        \n        if (not values_equal and\n                not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n            filtered_params[k] = v\n    return filtered_params\n",
      "\ndef _changed_params(estimator):\n    \"\"\"Return dict (param_name: value) of parameters that were given to\n    estimator with non-default values.\"\"\"\n\n    params = estimator.get_params(deep=False)\n    filtered_params = {}\n    init_func = getattr(estimator.__init__, 'deprecated_original',\n                        estimator.__init__)\n    init_params = signature(init_func).parameters\n    init_params = {name: param.default for name, param in init_params.items()}\n    for k, v in params.items():\n        # Handle array comparison safely\n        try:\n            # For arrays, use np.array_equal for proper comparison\n            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n                import numpy as np\n                values_equal = np.array_equal(v, init_params[k])\n            else:\n                values_equal = (v == init_params[k])\n        except (ValueError, TypeError):\n            # Fallback for incompatible types\n            values_equal = False\n        \n        if (not values_equal and\n                not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n            filtered_params[k] = v\n    return filtered_params\n",
      "\ndef _changed_params(estimator):\n    \"\"\"Return dict (param_name: value) of parameters that were given to\n    estimator with non-default values.\"\"\"\n\n    params = estimator.get_params(deep=False)\n    filtered_params = {}\n    init_func = getattr(estimator.__init__, 'deprecated_original',\n                        estimator.__init__)\n    init_params = signature(init_func).parameters\n    init_params = {name: param.default for name, param in init_params.items()}\n    for k, v in params.items():\n        # Handle array comparison safely\n        try:\n            # For arrays, use np.array_equal for proper comparison\n            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n                import numpy as np\n                values_equal = np.array_equal(v, init_params[k])\n            else:\n                values_equal = (v == init_params[k])\n        except (ValueError, TypeError):\n            # Fallback for incompatible types\n            values_equal = False\n        \n        if (not values_equal and\n                not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n            filtered_params[k] = v\n    return filtered_params\n",
      "\ndef _changed_params(estimator):\n    \"\"\"Return dict (param_name: value) of parameters that were given to\n    estimator with non-default values.\"\"\"\n\n    params = estimator.get_params(deep=False)\n    filtered_params = {}\n    init_func = getattr(estimator.__init__, 'deprecated_original',\n                        estimator.__init__)\n    init_params = signature(init_func).parameters\n    init_params = {name: param.default for name, param in init_params.items()}\n    for k, v in params.items():\n        # Handle array comparison safely\n        try:\n            # For arrays, use np.array_equal for proper comparison\n            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n                import numpy as np\n                values_equal = np.array_equal(v, init_params[k])\n            else:\n                values_equal = (v == init_params[k])\n        except (ValueError, TypeError):\n            # Fallback for incompatible types\n            values_equal = False\n        \n        if (not values_equal and\n                not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n            filtered_params[k] = v\n    return filtered_params\n",
      "\ndef _changed_params(estimator):\n    \"\"\"Return dict (param_name: value) of parameters that were given to\n    estimator with non-default values.\"\"\"\n\n    params = estimator.get_params(deep=False)\n    filtered_params = {}\n    init_func = getattr(estimator.__init__, 'deprecated_original',\n                        estimator.__init__)\n    init_params = signature(init_func).parameters\n    init_params = {name: param.default for name, param in init_params.items()}\n    for k, v in params.items():\n        # Handle array comparison safely\n        try:\n            # For arrays, use np.array_equal for proper comparison\n            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n                import numpy as np\n                values_equal = np.array_equal(v, init_params[k])\n            else:\n                values_equal = (v == init_params[k])\n        except (ValueError, TypeError):\n            # Fallback for incompatible types\n            values_equal = False\n        \n        if (not values_equal and\n                not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n            filtered_params[k] = v\n    return filtered_params\n",
      "\ndef _changed_params(estimator):\n    \"\"\"Return dict (param_name: value) of parameters that were given to\n    estimator with non-default values.\"\"\"\n\n    params = estimator.get_params(deep=False)\n    filtered_params = {}\n    init_func = getattr(estimator.__init__, 'deprecated_original',\n                        estimator.__init__)\n    init_params = signature(init_func).parameters\n    init_params = {name: param.default for name, param in init_params.items()}\n    for k, v in params.items():\n        # Handle array comparison safely\n        try:\n            # For arrays, use np.array_equal for proper comparison\n            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n                import numpy as np\n                values_equal = np.array_equal(v, init_params[k])\n            else:\n                values_equal = (v == init_params[k])\n        except (ValueError, TypeError):\n            # Fallback for incompatible types\n            values_equal = False\n        \n        if (not values_equal and\n                not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n            filtered_params[k] = v\n    return filtered_params\n",
      "\ndef _changed_params(estimator):\n    \"\"\"Return dict (param_name: value) of parameters that were given to\n    estimator with non-default values.\"\"\"\n\n    params = estimator.get_params(deep=False)\n    filtered_params = {}\n    init_func = getattr(estimator.__init__, 'deprecated_original',\n                        estimator.__init__)\n    init_params = signature(init_func).parameters\n    init_params = {name: param.default for name, param in init_params.items()}\n    for k, v in params.items():\n        # Handle array comparison safely\n        try:\n            # For arrays, use np.array_equal for proper comparison\n            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n                import numpy as np\n                values_equal = np.array_equal(v, init_params[k])\n            else:\n                values_equal = (v == init_params[k])\n        except (ValueError, TypeError):\n            # Fallback for incompatible types\n            values_equal = False\n        \n        if (not values_equal and\n                not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n            filtered_params[k] = v\n    return filtered_params\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/utils/_pprint.py b/sklearn/utils/_pprint.py\nindex b8686dba5..b957eb3e2 100644\n--- a/sklearn/utils/_pprint.py\n+++ b/sklearn/utils/_pprint.py\n@@ -94,8 +94,21 @@ def _changed_params(estimator):\n                         estimator.__init__)\n     init_params = signature(init_func).parameters\n     init_params = {name: param.default for name, param in init_params.items()}\n+\n     for k, v in params.items():\n-        if (v != init_params[k] and\n+        # Handle array comparison safely\n+        try:\n+            # For arrays, use np.array_equal for proper comparison\n+            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n+                import numpy as np\n+                values_equal = np.array_equal(v, init_params[k])\n+            else:\n+                values_equal = (v == init_params[k])\n+        except (ValueError, TypeError):\n+            # Fallback for incompatible types\n+            values_equal = False\n+        \n+        if (not values_equal and\n                 not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n             filtered_params[k] = v\n     return filtered_params\n",
    "variant_0": "diff --git a/sklearn/utils/_pprint.py b/sklearn/utils/_pprint.py\nindex b8686dba5..df621d517 100644\n--- a/sklearn/utils/_pprint.py\n+++ b/sklearn/utils/_pprint.py\n@@ -84,6 +84,17 @@ class KeyValTupleParam(KeyValTuple):\n     pass\n \n \n+def _changed_params(estimator):\n+    \"\"\"Return dict (param_name: value) of parameters that were given to\n+    estimator with non-default values.\"\"\"\n+\n+    params = estimator.get_params(deep=False)\n+    filtered_params = {}\n+    init_func = getattr(estimator.__init__, 'deprecated_original',\n+                        estimator.__init__)\n+    init_params = signature(init_func).parameters\n+    init_params = {name: param.default for name, param in init_params.items()}\n+\n def _changed_params(estimator):\n     \"\"\"Return dict (param_name: value) of parameters that were given to\n     estimator with non-default values.\"\"\"\n@@ -95,7 +106,19 @@ def _changed_params(estimator):\n     init_params = signature(init_func).parameters\n     init_params = {name: param.default for name, param in init_params.items()}\n     for k, v in params.items():\n-        if (v != init_params[k] and\n+        # Handle array comparison safely\n+        try:\n+            # For arrays, use np.array_equal for proper comparison\n+            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n+                import numpy as np\n+                values_equal = np.array_equal(v, init_params[k])\n+            else:\n+                values_equal = (v == init_params[k])\n+        except (ValueError, TypeError):\n+            # Fallback for incompatible types\n+            values_equal = False\n+        \n+        if (not values_equal and\n                 not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n             filtered_params[k] = v\n     return filtered_params\n",
    "variant_1": "diff --git a/sklearn/utils/_pprint.py b/sklearn/utils/_pprint.py\nindex b8686dba5..df621d517 100644\n--- a/sklearn/utils/_pprint.py\n+++ b/sklearn/utils/_pprint.py\n@@ -84,6 +84,17 @@ class KeyValTupleParam(KeyValTuple):\n     pass\n \n \n+def _changed_params(estimator):\n+    \"\"\"Return dict (param_name: value) of parameters that were given to\n+    estimator with non-default values.\"\"\"\n+\n+    params = estimator.get_params(deep=False)\n+    filtered_params = {}\n+    init_func = getattr(estimator.__init__, 'deprecated_original',\n+                        estimator.__init__)\n+    init_params = signature(init_func).parameters\n+    init_params = {name: param.default for name, param in init_params.items()}\n+\n def _changed_params(estimator):\n     \"\"\"Return dict (param_name: value) of parameters that were given to\n     estimator with non-default values.\"\"\"\n@@ -95,7 +106,19 @@ def _changed_params(estimator):\n     init_params = signature(init_func).parameters\n     init_params = {name: param.default for name, param in init_params.items()}\n     for k, v in params.items():\n-        if (v != init_params[k] and\n+        # Handle array comparison safely\n+        try:\n+            # For arrays, use np.array_equal for proper comparison\n+            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n+                import numpy as np\n+                values_equal = np.array_equal(v, init_params[k])\n+            else:\n+                values_equal = (v == init_params[k])\n+        except (ValueError, TypeError):\n+            # Fallback for incompatible types\n+            values_equal = False\n+        \n+        if (not values_equal and\n                 not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n             filtered_params[k] = v\n     return filtered_params\n",
    "variant_2": "diff --git a/sklearn/utils/_pprint.py b/sklearn/utils/_pprint.py\nindex b8686dba5..df621d517 100644\n--- a/sklearn/utils/_pprint.py\n+++ b/sklearn/utils/_pprint.py\n@@ -84,6 +84,17 @@ class KeyValTupleParam(KeyValTuple):\n     pass\n \n \n+def _changed_params(estimator):\n+    \"\"\"Return dict (param_name: value) of parameters that were given to\n+    estimator with non-default values.\"\"\"\n+\n+    params = estimator.get_params(deep=False)\n+    filtered_params = {}\n+    init_func = getattr(estimator.__init__, 'deprecated_original',\n+                        estimator.__init__)\n+    init_params = signature(init_func).parameters\n+    init_params = {name: param.default for name, param in init_params.items()}\n+\n def _changed_params(estimator):\n     \"\"\"Return dict (param_name: value) of parameters that were given to\n     estimator with non-default values.\"\"\"\n@@ -95,7 +106,19 @@ def _changed_params(estimator):\n     init_params = signature(init_func).parameters\n     init_params = {name: param.default for name, param in init_params.items()}\n     for k, v in params.items():\n-        if (v != init_params[k] and\n+        # Handle array comparison safely\n+        try:\n+            # For arrays, use np.array_equal for proper comparison\n+            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n+                import numpy as np\n+                values_equal = np.array_equal(v, init_params[k])\n+            else:\n+                values_equal = (v == init_params[k])\n+        except (ValueError, TypeError):\n+            # Fallback for incompatible types\n+            values_equal = False\n+        \n+        if (not values_equal and\n                 not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n             filtered_params[k] = v\n     return filtered_params\n",
    "variant_3": "diff --git a/sklearn/utils/_pprint.py b/sklearn/utils/_pprint.py\nindex b8686dba5..df621d517 100644\n--- a/sklearn/utils/_pprint.py\n+++ b/sklearn/utils/_pprint.py\n@@ -84,6 +84,17 @@ class KeyValTupleParam(KeyValTuple):\n     pass\n \n \n+def _changed_params(estimator):\n+    \"\"\"Return dict (param_name: value) of parameters that were given to\n+    estimator with non-default values.\"\"\"\n+\n+    params = estimator.get_params(deep=False)\n+    filtered_params = {}\n+    init_func = getattr(estimator.__init__, 'deprecated_original',\n+                        estimator.__init__)\n+    init_params = signature(init_func).parameters\n+    init_params = {name: param.default for name, param in init_params.items()}\n+\n def _changed_params(estimator):\n     \"\"\"Return dict (param_name: value) of parameters that were given to\n     estimator with non-default values.\"\"\"\n@@ -95,7 +106,19 @@ def _changed_params(estimator):\n     init_params = signature(init_func).parameters\n     init_params = {name: param.default for name, param in init_params.items()}\n     for k, v in params.items():\n-        if (v != init_params[k] and\n+        # Handle array comparison safely\n+        try:\n+            # For arrays, use np.array_equal for proper comparison\n+            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n+                import numpy as np\n+                values_equal = np.array_equal(v, init_params[k])\n+            else:\n+                values_equal = (v == init_params[k])\n+        except (ValueError, TypeError):\n+            # Fallback for incompatible types\n+            values_equal = False\n+        \n+        if (not values_equal and\n                 not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n             filtered_params[k] = v\n     return filtered_params\n",
    "variant_4": "diff --git a/sklearn/utils/_pprint.py b/sklearn/utils/_pprint.py\nindex b8686dba5..df621d517 100644\n--- a/sklearn/utils/_pprint.py\n+++ b/sklearn/utils/_pprint.py\n@@ -84,6 +84,17 @@ class KeyValTupleParam(KeyValTuple):\n     pass\n \n \n+def _changed_params(estimator):\n+    \"\"\"Return dict (param_name: value) of parameters that were given to\n+    estimator with non-default values.\"\"\"\n+\n+    params = estimator.get_params(deep=False)\n+    filtered_params = {}\n+    init_func = getattr(estimator.__init__, 'deprecated_original',\n+                        estimator.__init__)\n+    init_params = signature(init_func).parameters\n+    init_params = {name: param.default for name, param in init_params.items()}\n+\n def _changed_params(estimator):\n     \"\"\"Return dict (param_name: value) of parameters that were given to\n     estimator with non-default values.\"\"\"\n@@ -95,7 +106,19 @@ def _changed_params(estimator):\n     init_params = signature(init_func).parameters\n     init_params = {name: param.default for name, param in init_params.items()}\n     for k, v in params.items():\n-        if (v != init_params[k] and\n+        # Handle array comparison safely\n+        try:\n+            # For arrays, use np.array_equal for proper comparison\n+            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n+                import numpy as np\n+                values_equal = np.array_equal(v, init_params[k])\n+            else:\n+                values_equal = (v == init_params[k])\n+        except (ValueError, TypeError):\n+            # Fallback for incompatible types\n+            values_equal = False\n+        \n+        if (not values_equal and\n                 not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n             filtered_params[k] = v\n     return filtered_params\n",
    "variant_5": "diff --git a/sklearn/utils/_pprint.py b/sklearn/utils/_pprint.py\nindex b8686dba5..df621d517 100644\n--- a/sklearn/utils/_pprint.py\n+++ b/sklearn/utils/_pprint.py\n@@ -84,6 +84,17 @@ class KeyValTupleParam(KeyValTuple):\n     pass\n \n \n+def _changed_params(estimator):\n+    \"\"\"Return dict (param_name: value) of parameters that were given to\n+    estimator with non-default values.\"\"\"\n+\n+    params = estimator.get_params(deep=False)\n+    filtered_params = {}\n+    init_func = getattr(estimator.__init__, 'deprecated_original',\n+                        estimator.__init__)\n+    init_params = signature(init_func).parameters\n+    init_params = {name: param.default for name, param in init_params.items()}\n+\n def _changed_params(estimator):\n     \"\"\"Return dict (param_name: value) of parameters that were given to\n     estimator with non-default values.\"\"\"\n@@ -95,7 +106,19 @@ def _changed_params(estimator):\n     init_params = signature(init_func).parameters\n     init_params = {name: param.default for name, param in init_params.items()}\n     for k, v in params.items():\n-        if (v != init_params[k] and\n+        # Handle array comparison safely\n+        try:\n+            # For arrays, use np.array_equal for proper comparison\n+            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n+                import numpy as np\n+                values_equal = np.array_equal(v, init_params[k])\n+            else:\n+                values_equal = (v == init_params[k])\n+        except (ValueError, TypeError):\n+            # Fallback for incompatible types\n+            values_equal = False\n+        \n+        if (not values_equal and\n                 not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n             filtered_params[k] = v\n     return filtered_params\n",
    "variant_6": "diff --git a/sklearn/utils/_pprint.py b/sklearn/utils/_pprint.py\nindex b8686dba5..df621d517 100644\n--- a/sklearn/utils/_pprint.py\n+++ b/sklearn/utils/_pprint.py\n@@ -84,6 +84,17 @@ class KeyValTupleParam(KeyValTuple):\n     pass\n \n \n+def _changed_params(estimator):\n+    \"\"\"Return dict (param_name: value) of parameters that were given to\n+    estimator with non-default values.\"\"\"\n+\n+    params = estimator.get_params(deep=False)\n+    filtered_params = {}\n+    init_func = getattr(estimator.__init__, 'deprecated_original',\n+                        estimator.__init__)\n+    init_params = signature(init_func).parameters\n+    init_params = {name: param.default for name, param in init_params.items()}\n+\n def _changed_params(estimator):\n     \"\"\"Return dict (param_name: value) of parameters that were given to\n     estimator with non-default values.\"\"\"\n@@ -95,7 +106,19 @@ def _changed_params(estimator):\n     init_params = signature(init_func).parameters\n     init_params = {name: param.default for name, param in init_params.items()}\n     for k, v in params.items():\n-        if (v != init_params[k] and\n+        # Handle array comparison safely\n+        try:\n+            # For arrays, use np.array_equal for proper comparison\n+            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n+                import numpy as np\n+                values_equal = np.array_equal(v, init_params[k])\n+            else:\n+                values_equal = (v == init_params[k])\n+        except (ValueError, TypeError):\n+            # Fallback for incompatible types\n+            values_equal = False\n+        \n+        if (not values_equal and\n                 not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n             filtered_params[k] = v\n     return filtered_params\n",
    "variant_7": "diff --git a/sklearn/utils/_pprint.py b/sklearn/utils/_pprint.py\nindex b8686dba5..df621d517 100644\n--- a/sklearn/utils/_pprint.py\n+++ b/sklearn/utils/_pprint.py\n@@ -84,6 +84,17 @@ class KeyValTupleParam(KeyValTuple):\n     pass\n \n \n+def _changed_params(estimator):\n+    \"\"\"Return dict (param_name: value) of parameters that were given to\n+    estimator with non-default values.\"\"\"\n+\n+    params = estimator.get_params(deep=False)\n+    filtered_params = {}\n+    init_func = getattr(estimator.__init__, 'deprecated_original',\n+                        estimator.__init__)\n+    init_params = signature(init_func).parameters\n+    init_params = {name: param.default for name, param in init_params.items()}\n+\n def _changed_params(estimator):\n     \"\"\"Return dict (param_name: value) of parameters that were given to\n     estimator with non-default values.\"\"\"\n@@ -95,7 +106,19 @@ def _changed_params(estimator):\n     init_params = signature(init_func).parameters\n     init_params = {name: param.default for name, param in init_params.items()}\n     for k, v in params.items():\n-        if (v != init_params[k] and\n+        # Handle array comparison safely\n+        try:\n+            # For arrays, use np.array_equal for proper comparison\n+            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n+                import numpy as np\n+                values_equal = np.array_equal(v, init_params[k])\n+            else:\n+                values_equal = (v == init_params[k])\n+        except (ValueError, TypeError):\n+            # Fallback for incompatible types\n+            values_equal = False\n+        \n+        if (not values_equal and\n                 not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n             filtered_params[k] = v\n     return filtered_params\n",
    "variant_8": "diff --git a/sklearn/utils/_pprint.py b/sklearn/utils/_pprint.py\nindex b8686dba5..df621d517 100644\n--- a/sklearn/utils/_pprint.py\n+++ b/sklearn/utils/_pprint.py\n@@ -84,6 +84,17 @@ class KeyValTupleParam(KeyValTuple):\n     pass\n \n \n+def _changed_params(estimator):\n+    \"\"\"Return dict (param_name: value) of parameters that were given to\n+    estimator with non-default values.\"\"\"\n+\n+    params = estimator.get_params(deep=False)\n+    filtered_params = {}\n+    init_func = getattr(estimator.__init__, 'deprecated_original',\n+                        estimator.__init__)\n+    init_params = signature(init_func).parameters\n+    init_params = {name: param.default for name, param in init_params.items()}\n+\n def _changed_params(estimator):\n     \"\"\"Return dict (param_name: value) of parameters that were given to\n     estimator with non-default values.\"\"\"\n@@ -95,7 +106,19 @@ def _changed_params(estimator):\n     init_params = signature(init_func).parameters\n     init_params = {name: param.default for name, param in init_params.items()}\n     for k, v in params.items():\n-        if (v != init_params[k] and\n+        # Handle array comparison safely\n+        try:\n+            # For arrays, use np.array_equal for proper comparison\n+            if hasattr(v, '__array__') or hasattr(init_params[k], '__array__'):\n+                import numpy as np\n+                values_equal = np.array_equal(v, init_params[k])\n+            else:\n+                values_equal = (v == init_params[k])\n+        except (ValueError, TypeError):\n+            # Fallback for incompatible types\n+            values_equal = False\n+        \n+        if (not values_equal and\n                 not (is_scalar_nan(init_params[k]) and is_scalar_nan(v))):\n             filtered_params[k] = v\n     return filtered_params\n"
  }
}