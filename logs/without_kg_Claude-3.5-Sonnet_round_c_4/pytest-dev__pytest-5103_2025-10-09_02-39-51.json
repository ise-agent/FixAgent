{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/pytest/src/_pytest/assertion/rewrite.py lines 967-992)": "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() builtin functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a unique variable name for the iterator\n            iter_var = self.variable()\n            \n            # Visit the iterable argument\n            iter_expr, iter_expl = self.visit(iterable_arg)\n            \n            # Create the unrolled logic\n            # For all(): check each element is True, fail on first False\n            # For any(): check each element is True, succeed on first True\n            \n            if func_name == 'all':\n                # Generate: for item in iterable: assert item\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # Create the for loop body that checks each element\n                element_check = ast.Name(element_var, ast.Load())\n                check_expr, check_expl = self.visit(element_check)\n                \n                # Build explanation showing which element failed\n                explanation = \"%s(%s)\" % (func_name, iter_expl)\n                \n                # Create a call to the original builtin for the result\n                builtin_call = ast.Call(\n                    ast.Attribute(\n                        ast.Name(\"@py_builtins\", ast.Load()),\n                        func_name,\n                        ast.Load()\n                    ),\n                    [iter_expr],\n                    []\n                )\n                res = self.assign(builtin_call)\n                \n                # Create detailed explanation for failures\n                res_expl = self.explanation_param(self.display(res))\n                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, explanation)\n                \n                return res, outer_expl\n                \n            else:  # func_name == 'any'\n                # Similar logic for any()\n                explanation = \"%s(%s)\" % (func_name, iter_expl)\n                \n                builtin_call = ast.Call(\n                    ast.Attribute(\n                        ast.Name(\"@py_builtins\", ast.Load()),\n                        func_name,\n                        ast.Load()\n                    ),\n                    [iter_expr],\n                    []\n                )\n                res = self.assign(builtin_call)\n                \n                res_expl = self.explanation_param(self.display(res))\n                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, explanation)\n                \n                return res, outer_expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
    "Location 2 (/root/hy/projects_4/pytest/src/_pytest/assertion/rewrite.py lines 1000-1028)": "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-ins\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n            self.statements.append(iter_assign)\n            \n            # Create a result variable initialized to True for all(), False for any()\n            result_var = self.variable()\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n            self.statements.append(result_assign)\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop body\n            loop_body = []\n            \n            # Create test condition based on function type\n            if func_name == 'all':\n                # For all(): if not item, set result to False and break\n                test_condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n                false_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n                loop_body.append(ast.If(test_condition, [false_assign, ast.Break()], []))\n            else:  # any()\n                # For any(): if item, set result to True and break\n                test_condition = ast.Name(loop_var, ast.Load())\n                true_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n                loop_body.append(ast.If(test_condition, [true_assign, ast.Break()], []))\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iter_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            return ast.Name(result_var, ast.Load()), result_var\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_keywords = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_keywords.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **kwargs\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_keywords)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
    "Location 3 (/root/hy/projects_4/pytest/src/_pytest/assertion/rewrite.py lines 1033-1036)": "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-ins to provide detailed failure info\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its explanation\n            iterable, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable)\n            self.statements.append(iter_assign)\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Initialize result based on function (True for all, False for any)\n            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n            self.statements.append(result_assign)\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop to iterate through elements\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Get the current element\n            element = ast.Name(loop_var, ast.Load())\n            element_result, element_expl = self.visit(element)\n            \n            # Create condition based on function type\n            if func_name == 'all':\n                # For all(): if not element, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), element)\n                new_value = ast.NameConstant(False)\n            else:\n                # For any(): if element, set result to True and break\n                condition = element\n                new_value = ast.NameConstant(True)\n            \n            # Assignment in the if block\n            if_body = [\n                ast.Assign([ast.Name(result_var, ast.Store())], new_value),\n                ast.Break()\n            ]\n            \n            # Create the if statement\n            if_stmt = ast.If(condition, if_body, [])\n            loop_body.append(if_stmt)\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            result = ast.Name(result_var, ast.Load())\n            \n            # Create explanation\n            if func_name == 'all':\n                expl = \"all(%s)\" % (iterable_expl,)\n            else:\n                expl = \"any(%s)\" % (iterable_expl,)\n                \n            return result, expl\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        keyword_expls = []\n        new_keywords = []\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            keyword_expls.append(expl)\n            new_keywords.append(ast.keyword(keyword.arg, res))\n        if keyword_expls:\n            expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls + keyword_expls))\n        else:\n            expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n\n        new_call = ast.Call(new_func, new_args, new_keywords)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
    "Location 4 (/root/hy/projects_4/pytest/src/_pytest/assertion/rewrite.py lines 757-760)": "\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n",
    "Location 5 (/root/hy/projects_4/pytest/src/_pytest/assertion/rewrite.py lines 670-675)": "\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/pytest/src/_pytest/assertion/rewrite.py lines 967-992)": [
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create result variable initialized to True for all(), False for any()\n            result_var = self.variable()\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create the loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create loop body\n            loop_body = []\n            \n            # Get the element and its explanation\n            element_expr = ast.Name(loop_var, ast.Load())\n            element_var = self.variable()\n            loop_body.append(ast.Assign([ast.Name(element_var, ast.Store())], element_expr))\n            \n            # For all(): if not element, set result to False and break\n            # For any(): if element, set result to True and break\n            if func_name == 'all':\n                condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n                result_value = ast.NameConstant(False)\n            else:  # any()\n                condition = ast.Name(element_var, ast.Load())\n                result_value = ast.NameConstant(True)\n            \n            # Create if statement to update result and break\n            if_body = [\n                ast.Assign([ast.Name(result_var, ast.Store())], result_value),\n                ast.Break()\n            ]\n            loop_body.append(ast.If(condition, if_body, []))\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            result_name = ast.Name(result_var, ast.Load())\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res = self.assign(result_name)\n            res_expl = self.explanation_param(self.display(res))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return res, outer_expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a unique variable name for the loop\n            loop_var = self.variable()\n            iter_var = self.variable()\n            result_var = self.variable()\n            \n            # Visit the iterable argument\n            iter_expr, iter_expl = self.visit(iterable_arg)\n            \n            # Create the unrolled logic\n            # For all(): start with True, break on first False\n            # For any(): start with False, break on first True\n            initial_value = ast.NameConstant(value=(func_name == 'all'))\n            target_value = ast.NameConstant(value=(func_name == 'any'))\n            \n            # Assign the result variable with initial value\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n            self.statements.append(result_assign)\n            \n            # Create iterator\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], \n                                   ast.Call(self.builtin(\"iter\"), [iter_expr], []))\n            self.statements.append(iter_assign)\n            \n            # Create the loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # Create loop body with assertion-like logic\n            element_name = ast.Name(loop_var, ast.Load())\n            \n            # For all(): if not element: result = False; break\n            # For any(): if element: result = True; break\n            if func_name == 'all':\n                test_condition = ast.UnaryOp(ast.Not(), element_name)\n            else:  # any\n                test_condition = element_name\n                \n            # Create the conditional break logic\n            assign_result = ast.Assign([ast.Name(result_var, ast.Store())], target_value)\n            break_stmt = ast.Break()\n            \n            if_body = [assign_result, break_stmt]\n            if_stmt = ast.If(test_condition, if_body, [])\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            res = ast.Name(result_var, ast.Load())\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iter_expl)\n            res_expl = self.explanation_param(self.display(res))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return res, outer_expl\n        \n        # Original function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            iterable_var = self.variable()\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n            \n            # Create a temporary variable for the loop variable\n            loop_var = self.variable()\n            \n            # Create a temporary variable for the result\n            result_var = self.variable()\n            \n            # Initialize result variable based on function (True for all, False for any)\n            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Get the predicate result for current element\n            element_expr = ast.Name(loop_var, ast.Load())\n            element_res = self.assign(element_expr)\n            \n            # Create condition based on function type\n            if func_name == 'all':\n                # For all(): if not element, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n                loop_body.append(ast.If(\n                    condition,\n                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                     ast.Break()],\n                    []\n                ))\n            else:  # any()\n                # For any(): if element, set result to True and break\n                condition = ast.Name(loop_var, ast.Load())\n                loop_body.append(ast.If(\n                    condition,\n                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                     ast.Break()],\n                    []\n                ))\n            \n            # Create the for loop\n            for_loop = ast.For(\n                ast.Name(loop_var, ast.Store()),\n                ast.Name(iterable_var, ast.Load()),\n                loop_body,\n                []\n            )\n            \n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            res = ast.Name(result_var, ast.Load())\n            res_var = self.assign(res)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(res_var))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return res_var, outer_expl\n        \n        # Original function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n            \n            # Create the unrolled loop logic\n            if func_name == 'all':\n                # For all(): check each element is truthy\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # Create: for element in iterable: if not element: return False\n                loop_body = []\n                \n                # Get the element value and explanation\n                element_name = ast.Name(element_var, ast.Load())\n                element_res = self.assign(element_name)\n                element_explanation = self.explanation_param(self.display(element_res))\n                \n                # Create the negated test: not element\n                negated_test = ast.UnaryOp(ast.Not(), element_name)\n                negated_res = self.assign(negated_test)\n                \n                # Create assertion that will fail with detailed info\n                fail_stmt = ast.Assert(\n                    ast.Constant(False),\n                    ast.BinOp(\n                        ast.Str(\"assert \"),\n                        ast.Add(),\n                        ast.Str(element_explanation)\n                    )\n                )\n                \n                # If not element, fail the assertion\n                loop_body.append(ast.If(negated_test, [fail_stmt], []))\n                \n                # Create the for loop\n                for_loop = ast.For(\n                    ast.Name(element_var, ast.Store()),\n                    ast.Name(iterable_var, ast.Load()),\n                    loop_body,\n                    []\n                )\n                \n                self.statements.append(for_loop)\n                \n                # Return True if we get through all elements\n                result_var = self.variable()\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(True)))\n                \n                explanation = f\"all({iterable_expl})\"\n                return ast.Name(result_var, ast.Load()), explanation\n                \n            else:  # any()\n                # For any(): check if any element is truthy\n                loop_var = self.variable()\n                element_var = self.variable()\n                result_var = self.variable()\n                \n                # Initialize result to False\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(False)))\n                \n                # Create: for element in iterable: if element: result = True; break\n                loop_body = []\n                \n                element_name = ast.Name(element_var, ast.Load())\n                \n                # If element is truthy, set result to True and break\n                loop_body.append(ast.If(\n                    element_name,\n                    [\n                        ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(True)),\n                        ast.Break()\n                    ],\n                    []\n                ))\n                \n                for_loop = ast.For(\n                    ast.Name(element_var, ast.Store()),\n                    ast.Name(iterable_var, ast.Load()),\n                    loop_body,\n                    []\n                )\n                \n                self.statements.append(for_loop)\n                \n                explanation = f\"any({iterable_expl})\"\n                return ast.Name(result_var, ast.Load()), explanation\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a unique variable name for the iterator\n            iter_var = self.variable()\n            \n            # Visit the iterable argument\n            iter_expr, iter_expl = self.visit(iterable_arg)\n            \n            # Create the unrolled logic\n            # For all(): check each element is truthy, fail on first falsy\n            # For any(): check each element is truthy, succeed on first truthy\n            \n            if func_name == 'all':\n                # Transform all(iterable) into:\n                # _pytest_temp_iter = iter(iterable)\n                # for _pytest_temp_var in _pytest_temp_iter:\n                #     if not _pytest_temp_var:\n                #         return False\n                # return True\n                \n                loop_var = self.variable()\n                temp_var = self.variable()\n                \n                # Create iterator assignment\n                iter_call = ast.Call(\n                    func=ast.Name(\"iter\", ast.Load()),\n                    args=[iter_expr],\n                    keywords=[]\n                )\n                iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iter_call)\n                \n                # Create the loop body that checks each element\n                loop_target = ast.Name(loop_var, ast.Store())\n                loop_iter = ast.Name(iter_var, ast.Load())\n                \n                # Create the condition: not element\n                element_load = ast.Name(loop_var, ast.Load())\n                not_element = ast.UnaryOp(ast.Not(), element_load)\n                \n                # Create explanation for the failing element\n                element_expl = self.explanation_param(self.display(ast.Name(loop_var, ast.Load())))\n                fail_expl = \"False\\n{False = not %s\\n}\" % element_expl\n                \n                # Create the early return for failure case\n                fail_return = ast.Return(ast.NameConstant(False))\n                \n                # Wrap in conditional\n                loop_body = [ast.If(not_element, [fail_return], [])]\n                \n                # Create the for loop\n                for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n                \n                # Create final return True\n                success_return = ast.Return(ast.NameConstant(True))\n                \n                # Combine into a function that we'll call immediately\n                func_body = [iter_assign, for_loop, success_return]\n                \n                # Create an immediately invoked function expression\n                temp_func = ast.FunctionDef(\n                    name=temp_var,\n                    args=ast.arguments(args=[], defaults=[], kwonlyargs=[], kw_defaults=[], vararg=None, kwarg=None),\n                    body=func_body,\n                    decorator_list=[],\n                    returns=None\n                )\n                \n                # Actually, let's use a simpler approach with a generator expression\n                # that we can evaluate step by step\n                \n                # For now, fall back to creating a detailed explanation\n                expl = \"all(%s)\" % iter_expl\n                new_call = ast.Call(\n                    func=ast.Name(\"all\", ast.Load()),\n                    args=[iter_expr], \n                    keywords=[]\n                )\n                res = self.assign(new_call)\n                res_expl = self.explanation_param(self.display(res))\n                \n                # Try to provide more detail about what failed\n                outer_expl = \"%s\\n{%s = all(%s)\\n}\" % (res_expl, res_expl, iter_expl)\n                return res, outer_expl\n                \n            else:  # func_name == 'any'\n                # Similar logic for any() but with opposite semantics\n                expl = \"any(%s)\" % iter_expl\n                new_call = ast.Call(\n                    func=ast.Name(\"any\", ast.Load()),\n                    args=[iter_expr],\n                    keywords=[]\n                )\n                res = self.assign(new_call)\n                res_expl = self.explanation_param(self.display(res))\n                outer_expl = \"%s\\n{%s = any(%s)\\n}\" % (res_expl, res_expl, iter_expl)\n                return res, outer_expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n            \n            # Create the unrolled loop logic\n            loop_var = self.variable()\n            result_var = self.variable()\n            \n            # Initialize result variable (True for all(), False for any())\n            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            \n            # Create the loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the loop body\n            element_expr = ast.Name(loop_var, ast.Load())\n            element_test_var = self.variable()\n            \n            if func_name == 'all':\n                # For all(): if not element, set result to False and break\n                test_expr = ast.UnaryOp(ast.Not(), element_expr)\n                assign_value = ast.NameConstant(False)\n            else:\n                # For any(): if element, set result to True and break\n                test_expr = element_expr\n                assign_value = ast.NameConstant(True)\n            \n            # Assign the test result to a variable for better error reporting\n            test_assign = ast.Assign([ast.Name(element_test_var, ast.Store())], element_expr)\n            \n            # Create the conditional assignment and break\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], assign_value)\n            break_stmt = ast.Break()\n            \n            if_body = [result_assign, break_stmt]\n            if_stmt = ast.If(test_expr, if_body, [])\n            \n            loop_body = [test_assign, if_stmt]\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            \n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            result_name = ast.Name(result_var, ast.Load())\n            res = self.assign(result_name)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(res))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return res, outer_expl\n        \n        # Original function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            iter_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable_res))\n            \n            # Create result variable\n            result_var = self.variable()\n            \n            # Initialize result based on function type\n            if func_name == 'all':\n                init_value = ast.NameConstant(True)\n            else:  # any\n                init_value = ast.NameConstant(False)\n            \n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # Create loop body\n            element_res = ast.Name(loop_var, ast.Load())\n            \n            if func_name == 'all':\n                # For all(): if not element, set result to False and break\n                test = ast.UnaryOp(ast.Not(), element_res)\n                assign_false = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n                break_stmt = ast.Break()\n                if_stmt = ast.If(test, [assign_false, break_stmt], [])\n            else:  # any\n                # For any(): if element, set result to True and break\n                test = element_res\n                assign_true = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n                break_stmt = ast.Break()\n                if_stmt = ast.If(test, [assign_true, break_stmt], [])\n            \n            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            result = ast.Name(result_var, ast.Load())\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            return result, expl\n        \n        # Original function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Assign the iterable to our temporary variable\n            self.statements.append(ast.Assign([iterable_var], iterable_expr))\n            \n            # Create a loop variable\n            loop_var = self.variable()\n            \n            # Create the loop body that checks each element\n            element_expr, element_expl = self.visit(loop_var)\n            \n            if func_name == 'all':\n                # For all(), we want to assert each element is truthy\n                test_expr = element_expr\n                test_expl = element_expl\n            else:  # any()\n                # For any(), we want to find at least one truthy element\n                # We'll use a different approach - track if we found any True\n                found_var = self.variable()\n                self.statements.append(ast.Assign([found_var], ast.NameConstant(False)))\n                \n                # Create conditional to set found_var = True if element is truthy\n                set_found = ast.Assign([found_var], ast.NameConstant(True))\n                condition = ast.If(element_expr, [set_found], [])\n                \n                # Create the for loop\n                for_loop = ast.For(\n                    target=loop_var,\n                    iter=iterable_var,\n                    body=[condition],\n                    orelse=[]\n                )\n                self.statements.append(for_loop)\n                \n                # Return the found variable\n                res_expl = self.explanation_param(self.display(found_var))\n                outer_expl = \"%s\\n{%s = any(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n                return found_var, outer_expl\n            \n            # For all(), create assertion in loop body\n            assert_stmt = ast.Assert(test_expr, None)\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=loop_var,\n                iter=iterable_var,\n                body=[assert_stmt],\n                orelse=[]\n            )\n            self.statements.append(for_loop)\n            \n            # Return True (all elements passed)\n            true_var = self.variable()\n            self.statements.append(ast.Assign([true_var], ast.NameConstant(True)))\n            \n            res_expl = self.explanation_param(self.display(true_var))\n            outer_expl = \"%s\\n{%s = all(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n            return true_var, outer_expl\n        \n        # Original function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
    ],
    "Location 2 (/root/hy/projects_4/pytest/src/_pytest/assertion/rewrite.py lines 1000-1028)": [
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-ins\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create the unrolled logic\n            temp_result = self.variable()\n            loop_var = self.variable()\n            \n            # For all(): start with True, fail on first False\n            # For any(): start with False, succeed on first True\n            initial_value = ast.NameConstant(value=(func_name == 'all'))\n            assign_initial = ast.Assign([ast.Name(temp_result, ast.Store())], initial_value)\n            \n            # Create the loop variable assignment and condition check\n            if func_name == 'all':\n                # For all(): if any element is False, result is False\n                condition_check = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n            else:\n                # For any(): if any element is True, result is True  \n                condition_check = ast.Name(loop_var, ast.Load())\n            \n            # Create explanation for the failing element\n            element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n            \n            # Build the unrolled assertion logic\n            stmts = [\n                ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res),\n                assign_initial\n            ]\n            \n            # Create a for loop that checks each element\n            loop_body = [\n                ast.Assign([ast.Name(loop_var, ast.Store())], ast.Name('__item', ast.Load())),\n                ast.If(\n                    test=condition_check,\n                    body=[\n                        ast.Assign([ast.Name(temp_result, ast.Store())], \n                                 ast.NameConstant(value=(func_name == 'any'))),\n                        ast.Break()\n                    ],\n                    orelse=[]\n                )\n            ]\n            \n            for_loop = ast.For(\n                target=ast.Name('__item', ast.Store()),\n                iter=ast.Name(iterable_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            \n            stmts.append(for_loop)\n            \n            # Execute the statements\n            for stmt in stmts:\n                self.statements.append(stmt)\n            \n            # Return the result with explanation\n            res = ast.Name(temp_result, ast.Load())\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            return res, expl\n        \n        # Original logic for regular function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **kwargs\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-ins\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a unique variable name for the iteration\n            iter_var = self.variable()\n            item_var = self.variable()\n            result_var = self.variable()\n            \n            # Visit the iterable argument\n            new_iterable, iterable_expl = self.visit(iterable_arg)\n            \n            # Create the unrolled logic\n            # For all(): result = True; for item in iterable: if not item: result = False; break\n            # For any(): result = False; for item in iterable: if item: result = True; break\n            \n            initial_value = ast.NameConstant(value=(func_name == 'all'))\n            break_condition_test = ast.UnaryOp(op=ast.Not(), operand=ast.Name(id=item_var, ctx=ast.Load())) if func_name == 'all' else ast.Name(id=item_var, ctx=ast.Load())\n            break_value = ast.NameConstant(value=(func_name == 'any'))\n            \n            # Create the unrolled statements\n            statements = [\n                # result = True/False\n                ast.Assign(targets=[ast.Name(id=result_var, ctx=ast.Store())], value=initial_value),\n                # for item in iterable:\n                ast.For(\n                    target=ast.Name(id=item_var, ctx=ast.Store()),\n                    iter=ast.Name(id=iter_var, ctx=ast.Load()),\n                    body=[\n                        # Check the condition and potentially break\n                        ast.If(\n                            test=break_condition_test,\n                            body=[\n                                ast.Assign(targets=[ast.Name(id=result_var, ctx=ast.Store())], value=break_value),\n                                ast.Break()\n                            ],\n                            orelse=[]\n                        )\n                    ],\n                    orelse=[]\n                )\n            ]\n            \n            # Create assignment for the iterable\n            iter_assign = ast.Assign(targets=[ast.Name(id=iter_var, ctx=ast.Store())], value=new_iterable)\n            \n            # Execute the statements\n            self.statements.append(iter_assign)\n            for stmt in statements:\n                self.statements.append(stmt)\n            \n            # Return the result variable\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(ast.Name(id=result_var, ctx=ast.Load())))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return ast.Name(id=result_var, ctx=ast.Load()), outer_expl\n        \n        # Original function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_keywords = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_keywords.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_keywords)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python 3.5 and above\n        \"\"\"\n        # Special handling for all() and any() built-ins to provide better error messages\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n            self.statements.append(iter_assign)\n            \n            # Create a temporary variable for the result\n            result_var = self.variable()\n            \n            # Initialize result to True for all(), False for any()\n            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n            self.statements.append(result_assign)\n            \n            # Create the loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop body\n            loop_body = []\n            \n            if func_name == 'all':\n                # For all(): if not item, set result to False and break\n                test_var = self.variable()\n                test_assign = ast.Assign([ast.Name(test_var, ast.Store())], ast.Name(loop_var, ast.Load()))\n                loop_body.append(test_assign)\n                \n                # Create the condition: not item\n                not_test = ast.UnaryOp(ast.Not(), ast.Name(test_var, ast.Load()))\n                \n                # If not item: result = False; break\n                false_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n                break_stmt = ast.Break()\n                if_stmt = ast.If(not_test, [false_assign, break_stmt], [])\n                loop_body.append(if_stmt)\n            else:\n                # For any(): if item, set result to True and break\n                test_var = self.variable()\n                test_assign = ast.Assign([ast.Name(test_var, ast.Store())], ast.Name(loop_var, ast.Load()))\n                loop_body.append(test_assign)\n                \n                # If item: result = True; break\n                true_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n                break_stmt = ast.Break()\n                if_stmt = ast.If(ast.Name(test_var, ast.Load()), [true_assign, break_stmt], [])\n                loop_body.append(if_stmt)\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iter_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            return ast.Name(result_var, ast.Load()), result_var\n        \n        # Original call handling for non-all/any functions\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **kwargs\n                arg_expls.append(\"**\" + expl)\n\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-ins to provide better error messages\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            self.statements.append(ast.Assign([iterable_var], iterable_res))\n            \n            # Create loop variable\n            item_var = self.variable()\n            \n            # Create result variable initialized to True for all(), False for any()\n            result_var = self.variable()\n            initial_value = ast.NameConstant(value=(func_name == 'all'))\n            self.statements.append(ast.Assign([result_var], initial_value))\n            \n            # Create the unrolled loop\n            if isinstance(iterable_arg, ast.GeneratorExp):\n                # Handle generator expressions specially\n                gen = iterable_arg\n                loop_target = ast.Name(gen.element.id if isinstance(gen.element, ast.Name) else 'item', ast.Store())\n                \n                # Extract the condition from generator\n                for comprehension in gen.generators:\n                    # Create for loop\n                    loop = ast.For(\n                        target=loop_target,\n                        iter=comprehension.iter,\n                        body=[],\n                        orelse=[]\n                    )\n                    \n                    # Add conditions as if statements\n                    current_body = loop.body\n                    for if_clause in comprehension.ifs:\n                        if_stmt = ast.If(test=if_clause, body=[], orelse=[])\n                        current_body.append(if_stmt)\n                        current_body = if_stmt.body\n                    \n                    # Create the test expression\n                    test_expr = gen.element\n                    \n                    # For all(): if not test_expr: result = False; break\n                    # For any(): if test_expr: result = True; break\n                    if func_name == 'all':\n                        condition = ast.UnaryOp(op=ast.Not(), operand=test_expr)\n                        new_value = ast.NameConstant(value=False)\n                    else:  # any()\n                        condition = test_expr\n                        new_value = ast.NameConstant(value=True)\n                    \n                    # Create assertion for detailed error reporting\n                    if func_name == 'all':\n                        assert_stmt = ast.Assert(test=test_expr, msg=None)\n                        current_body.append(assert_stmt)\n                    else:  # any() - we want to track when we find a True value\n                        # For any(), we continue until we find True, so we assert the opposite to get details\n                        negated_test = ast.UnaryOp(op=ast.Not(), operand=test_expr)\n                        temp_var = self.variable()\n                        assign_temp = ast.Assign([temp_var], test_expr)\n                        current_body.append(assign_temp)\n                        \n                        # If condition is true, set result and break\n                        if_true = ast.If(\n                            test=ast.Name(temp_var.id, ast.Load()),\n                            body=[\n                                ast.Assign([result_var], ast.NameConstant(value=True)),\n                                ast.Break()\n                            ],\n                            orelse=[]\n                        )\n                        current_body.append(if_true)\n                    \n                    self.statements.append(loop)\n            else:\n                # Handle regular iterables\n                loop = ast.For(\n                    target=item_var,\n                    iter=iterable_var,\n                    body=[],\n                    orelse=[]\n                )\n                \n                if func_name == 'all':\n                    # For all(): assert each item, if any fails the assertion will show details\n                    assert_stmt = ast.Assert(test=item_var, msg=None)\n                    loop.body.append(assert_stmt)\n                else:  # any()\n                    # For any(): if item is true, set result and break\n                    if_stmt = ast.If(\n                        test=item_var,\n                        body=[\n                            ast.Assign([result_var], ast.NameConstant(value=True)),\n                            ast.Break()\n                        ],\n                        orelse=[]\n                    )\n                    loop.body.append(if_stmt)\n                \n                self.statements.append(loop)\n            \n            # Return the result\n            res_expl = self.explanation_param(self.display(result_var))\n            return result_var, res_expl\n        \n        # Original visit_Call_35 logic for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            arg_expls.append(keyword.arg + \"=\" + expl)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            # Get the iterable argument\n            iterable_arg = call.args[0]\n            \n            # Create a unique variable name for the loop\n            loop_var = self.variable()\n            iter_var = self.variable()\n            result_var = self.variable()\n            \n            # Visit the iterable expression\n            iter_res, iter_expl = self.visit(iterable_arg)\n            \n            # Create the unrolled logic\n            is_all = call.func.id == 'all'\n            \n            # For all(): result starts True, becomes False on first falsy item\n            # For any(): result starts False, becomes True on first truthy item\n            initial_value = ast.NameConstant(value=is_all)\n            \n            # Create assignment: result_var = True/False\n            result_assign = ast.Assign(\n                targets=[ast.Name(result_var, ast.Store())],\n                value=initial_value\n            )\n            \n            # Create the loop variable and iterator\n            loop_target = ast.Name(loop_var, ast.Store())\n            iter_call = ast.Call(\n                func=ast.Name('iter', ast.Load()),\n                args=[iter_res],\n                keywords=[]\n            )\n            iter_assign = ast.Assign(\n                targets=[ast.Name(iter_var, ast.Store())],\n                value=iter_call\n            )\n            \n            # Create the loop body\n            # Get next item: loop_var = next(iter_var)\n            next_call = ast.Call(\n                func=ast.Name('next', ast.Load()),\n                args=[ast.Name(iter_var, ast.Load())],\n                keywords=[]\n            )\n            item_assign = ast.Assign(\n                targets=[loop_target],\n                value=next_call\n            )\n            \n            # Create condition check\n            item_ref = ast.Name(loop_var, ast.Load())\n            if is_all:\n                # For all(): if not item, result = False and break\n                condition = ast.UnaryOp(op=ast.Not(), operand=item_ref)\n                new_value = ast.NameConstant(value=False)\n            else:\n                # For any(): if item, result = True and break\n                condition = item_ref\n                new_value = ast.NameConstant(value=True)\n            \n            # Create the conditional assignment and break\n            cond_assign = ast.Assign(\n                targets=[ast.Name(result_var, ast.Store())],\n                value=new_value\n            )\n            break_stmt = ast.Break()\n            \n            # Create if statement\n            if_stmt = ast.If(\n                test=condition,\n                body=[cond_assign, break_stmt],\n                orelse=[]\n            )\n            \n            # Create try/except for StopIteration\n            try_stmt = ast.Try(\n                body=[\n                    ast.While(\n                        test=ast.NameConstant(value=True),\n                        body=[item_assign, if_stmt],\n                        orelse=[]\n                    )\n                ],\n                handlers=[\n                    ast.ExceptHandler(\n                        type=ast.Name('StopIteration', ast.Load()),\n                        name=None,\n                        body=[ast.Pass()]\n                    )\n                ],\n                orelse=[],\n                finalbody=[]\n            )\n            \n            # Build the complete statement sequence\n            stmts = [result_assign, iter_assign, try_stmt]\n            \n            # Add all statements to the current statement list\n            self.statements.extend(stmts)\n            \n            # Return the result variable\n            res = ast.Name(result_var, ast.Load())\n            res_name = self.assign(res)\n            \n            # Create explanation\n            func_name = call.func.id\n            expl = \"%s(%s)\" % (func_name, iter_expl)\n            res_expl = self.explanation_param(self.display(res_name))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return res_name, outer_expl\n        \n        # Original visit_Call_35 logic for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_keywords = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_keywords.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_keywords)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-ins\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and\n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            iter_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable_res))\n            \n            # Create result variable\n            result_var = self.variable()\n            \n            # For all(): start with True, for any(): start with False\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # Create loop body\n            loop_body = []\n            \n            if func_name == 'all':\n                # For all(): if any element is False, set result to False and break\n                element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n                test_var = self.variable()\n                loop_body.append(ast.Assign([ast.Name(test_var, ast.Store())], element_res))\n                \n                # if not element: result = False; break\n                not_test = ast.UnaryOp(ast.Not(), ast.Name(test_var, ast.Load()))\n                assign_false = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n                break_stmt = ast.Break()\n                if_stmt = ast.If(not_test, [assign_false, break_stmt], [])\n                loop_body.append(if_stmt)\n            else:  # any()\n                # For any(): if any element is True, set result to True and break\n                element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n                test_var = self.variable()\n                loop_body.append(ast.Assign([ast.Name(test_var, ast.Store())], element_res))\n                \n                # if element: result = True; break\n                assign_true = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n                break_stmt = ast.Break()\n                if_stmt = ast.If(ast.Name(test_var, ast.Load()), [assign_true, break_stmt], [])\n                loop_body.append(if_stmt)\n            \n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            res = ast.Name(result_var, ast.Load())\n            res_expl = self.explanation_param(self.display(res))\n            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (res_expl, res_expl, func_name, iterable_expl)\n            return res, outer_expl\n        \n        # Original visit_Call_35 logic for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **kwargs\n                arg_expls.append(\"**\" + expl)\n\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-ins to provide better error messages\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n            self.statements.append(iter_assign)\n            \n            # Create a temporary variable for the result\n            result_var = self.variable()\n            \n            # Initialize result variable based on function (True for all, False for any)\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n            self.statements.append(result_assign)\n            \n            # Create a loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop to iterate over the iterable\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # Create the loop body\n            loop_body = []\n            \n            if func_name == 'all':\n                # For all(): if any element is falsy, set result to False and break\n                test_expr = ast.Name(loop_var, ast.Load())\n                # Create: if not item: result = False; break\n                not_test = ast.UnaryOp(ast.Not(), test_expr)\n                false_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n                break_stmt = ast.Break()\n                if_stmt = ast.If(not_test, [false_assign, break_stmt], [])\n                loop_body.append(if_stmt)\n            else:  # any()\n                # For any(): if any element is truthy, set result to True and break\n                test_expr = ast.Name(loop_var, ast.Load())\n                # Create: if item: result = True; break\n                true_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n                break_stmt = ast.Break()\n                if_stmt = ast.If(test_expr, [true_assign, break_stmt], [])\n                loop_body.append(if_stmt)\n            \n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            result_name = ast.Name(result_var, ast.Load())\n            return result_name, result_var\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on 3.5+\n        \"\"\"\n        # Special handling for all() and any() built-ins\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n            self.statements.append(iter_assign)\n            \n            # Create a result variable\n            result_var = self.variable()\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n            self.statements.append(result_assign)\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # For all(): if not item, result = False and break\n            # For any(): if item, result = True and break\n            if func_name == 'all':\n                test = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n                assign_value = ast.NameConstant(False)\n            else:  # any()\n                test = ast.Name(loop_var, ast.Load())\n                assign_value = ast.NameConstant(True)\n            \n            # Create the if statement inside the loop\n            if_assign = ast.Assign([ast.Name(result_var, ast.Store())], assign_value)\n            if_break = ast.Break()\n            if_body = [if_assign, if_break]\n            if_stmt = ast.If(test, if_body, [])\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            return ast.Name(result_var, ast.Load()), result_var\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **kwargs\n                arg_expls.append(\"**\" + expl)\n\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
    ],
    "Location 3 (/root/hy/projects_4/pytest/src/_pytest/assertion/rewrite.py lines 1033-1036)": [
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            iterable_assign = ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_arg)\n            self.statements.append(iterable_assign)\n            \n            # Create a result variable initialized to the identity value\n            result_var = self.variable()\n            identity_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], identity_value)\n            self.statements.append(result_assign)\n            \n            # Create the unrolling loop\n            loop_var = self.variable()\n            \n            # Create the loop body that updates result and provides detailed assertion info\n            loop_body = []\n            \n            # Get the current element\n            element_var = self.variable()\n            element_assign = ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load()))\n            loop_body.append(element_assign)\n            \n            # Create condition check with detailed explanation\n            if func_name == 'all':\n                # For all(): if not element, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n                new_value = ast.NameConstant(False)\n            else:\n                # For any(): if element, set result to True and break  \n                condition = ast.Name(element_var, ast.Load())\n                new_value = ast.NameConstant(True)\n            \n            # Update result and break on condition\n            update_result = ast.Assign([ast.Name(result_var, ast.Store())], new_value)\n            break_stmt = ast.Break()\n            \n            if_stmt = ast.If(condition, [update_result, break_stmt], [])\n            loop_body.append(if_stmt)\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iterable_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            return ast.Name(result_var, ast.Load()), self.explanation_param(result_var)\n        \n        # Original visit_Call_35 logic for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        new_kwargs = []\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(\"%s=%s\" % (keyword.arg, expl))\n            else:\n                arg_expls.append(\"**%s\" % expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            iterable_assign = ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_arg)\n            self.statements.append(iterable_assign)\n            \n            # Create result variable\n            result_var = self.variable()\n            \n            # For all(): start with True, for any(): start with False\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n            self.statements.append(result_assign)\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Get the current element\n            element = ast.Name(loop_var, ast.Load())\n            \n            # For generators/comprehensions, we need to extract the test condition\n            if isinstance(iterable_arg, ast.GeneratorExp):\n                # Extract the element and test from generator\n                test_expr = iterable_arg.elt\n                element_name = iterable_arg.generators[0].target.id\n                \n                # Substitute the loop variable for the generator variable\n                class VariableReplacer(ast.NodeTransformer):\n                    def visit_Name(self, node):\n                        if isinstance(node.ctx, ast.Load) and node.id == element_name:\n                            return ast.Name(loop_var, ast.Load())\n                        return node\n                \n                test_expr = VariableReplacer().visit(test_expr)\n                iterable_source = iterable_arg.generators[0].iter\n                \n                # Update the iterable assignment\n                self.statements[-2] = ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_source)\n            else:\n                # For simple iterables, the test is just the element itself\n                test_expr = element\n            \n            # Visit the test expression to get proper explanation\n            test_result, test_expl = self.visit(test_expr)\n            \n            # Create condition based on function type\n            if func_name == 'all':\n                # For all(): if any element is False, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), test_result)\n                new_value = ast.NameConstant(False)\n            else:\n                # For any(): if any element is True, set result to True and break\n                condition = test_result\n                new_value = ast.NameConstant(True)\n            \n            # Create the if statement\n            if_body = [\n                ast.Assign([ast.Name(result_var, ast.Store())], new_value),\n                ast.Break()\n            ]\n            \n            if_stmt = ast.If(condition, if_body, [])\n            loop_body.append(if_stmt)\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Create explanation\n            result_name = ast.Name(result_var, ast.Load())\n            res = self.assign(result_name)\n            res_expl = self.explanation_param(self.display(res))\n            \n            # Build explanation showing the unrolled evaluation\n            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (\n                res_expl, res_expl, func_name, self.explanation_param(self.display(ast.Name(iterable_var, ast.Load())))\n            )\n            \n            return res, outer_expl\n        \n        # Original visit_Call_35 logic for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        keyword_expls = []\n        new_keywords = []\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            keyword_expls.append(expl)\n            new_keywords.append(ast.keyword(keyword.arg, res))\n        if keyword_expls:\n            expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls + keyword_expls))\n        else:\n            expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n\n        new_call = ast.Call(new_func, new_args, new_keywords)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.assign(iterable_arg)\n            \n            # Create a loop variable\n            loop_var = self.variable()\n            \n            # Create result variable initialized to True for all(), False for any()\n            result_var = self.variable()\n            initial_value = ast.NameConstant(value=(func_name == 'all'))\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create the loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the loop body\n            loop_body = []\n            \n            # For all(): if not item: result = False; break\n            # For any(): if item: result = True; break\n            item_test = ast.Name(loop_var, ast.Load())\n            if func_name == 'all':\n                condition = ast.UnaryOp(ast.Not(), item_test)\n                new_value = ast.NameConstant(value=False)\n            else:  # any()\n                condition = item_test\n                new_value = ast.NameConstant(value=True)\n            \n            # Create assignment and break statements\n            assign_stmt = ast.Assign([ast.Name(result_var, ast.Store())], new_value)\n            break_stmt = ast.Break()\n            \n            # Create if statement\n            if_stmt = ast.If(condition, [assign_stmt, break_stmt], [])\n            loop_body.append(if_stmt)\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            result_name = ast.Name(result_var, ast.Load())\n            return result_name, self.explanation_param(self.display(result_name))\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        new_kwargs = []\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and call.func.id in ('all', 'any') and\n            len(call.args) == 1 and not call.keywords):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument to get its explanation\n            iterable, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a unique variable name for the iteration\n            iter_var = self.variable()\n            element_var = self.variable()\n            result_var = self.variable()\n            \n            # Create the unrolled logic\n            # For all(): result = True; for element in iterable: if not element: result = False; break\n            # For any(): result = False; for element in iterable: if element: result = True; break\n            \n            initial_value = ast.NameConstant(value=(func_name == 'all'))\n            assign_initial = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n            \n            # Create the test condition\n            if func_name == 'all':\n                test_condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n                break_value = ast.NameConstant(value=False)\n            else:  # any\n                test_condition = ast.Name(element_var, ast.Load())\n                break_value = ast.NameConstant(value=True)\n            \n            # Create the if statement inside the loop\n            assign_result = ast.Assign([ast.Name(result_var, ast.Store())], break_value)\n            break_stmt = ast.Break()\n            if_stmt = ast.If(test_condition, [assign_result, break_stmt], [])\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=ast.Name(element_var, ast.Store()),\n                iter=iterable,\n                body=[if_stmt],\n                orelse=[]\n            )\n            \n            # Add the statements to the current statement list\n            self.statements.append(assign_initial)\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            result_name = ast.Name(result_var, ast.Load())\n            result_expl = self.explanation_param(self.display(result_name))\n            \n            # Create explanation showing the unrolled logic\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (result_expl, result_expl, expl)\n            \n            return result_name, outer_expl\n\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        keyword_expls = []\n        new_keywords = []\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            keyword_expls.append(expl)\n            new_keywords.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(\"%s=%s\" % (keyword.arg, expl))\n            else:  # **args\n                arg_expls.append(\"**%s\" % expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_keywords)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n            self.statements.append(iter_assign)\n            \n            # Create result variable\n            result_var = self.variable()\n            \n            # For all(), start with True and AND each element\n            # For any(), start with False and OR each element  \n            initial_value = ast.NameConstant(value=(func_name == 'all'))\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n            self.statements.append(result_assign)\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # Create loop body that updates result and provides detailed assertion info\n            element_node = ast.Name(loop_var, ast.Load())\n            element_res, element_expl = self.visit(element_node)\n            \n            if func_name == 'all':\n                # For all(): if any element is False, the result is False\n                # result = result and element\n                test_node = ast.UnaryOp(ast.Not(), element_node)\n                condition = ast.Compare(test_node, [ast.Is()], [ast.NameConstant(value=True)])\n                \n                # If element is False, set result to False and break\n                result_update = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(value=False))\n                break_stmt = ast.Break()\n                if_body = [result_update, break_stmt]\n            else:  # any()\n                # For any(): if any element is True, the result is True  \n                # result = result or element\n                condition = ast.Compare(element_node, [ast.Is()], [ast.NameConstant(value=True)])\n                \n                # If element is True, set result to True and break\n                result_update = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(value=True))\n                break_stmt = ast.Break()\n                if_body = [result_update, break_stmt]\n            \n            if_stmt = ast.If(condition, if_body, [])\n            loop_body = [if_stmt]\n            \n            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            result_node = ast.Name(result_var, ast.Load())\n            res_expl = \"%s(%s)\" % (func_name, self.explanation_param(self.display(ast.Name(iter_var, ast.Load()))))\n            \n            return result_node, res_expl\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        new_kwargs = []\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], arg)\n            self.statements.append(iter_assign)\n            \n            # Create a loop variable\n            loop_var = self.variable()\n            \n            # Create the unrolled logic\n            if func_name == 'all':\n                # For all(): if any element is False, the assertion fails\n                # for item in iterable:\n                #     if not item:\n                #         assert item  # This will show the failing item\n                loop_body = [\n                    ast.If(\n                        test=ast.UnaryOp(op=ast.Not(), operand=ast.Name(loop_var, ast.Load())),\n                        body=[\n                            ast.Assert(\n                                test=ast.Name(loop_var, ast.Load()),\n                                msg=None\n                            )\n                        ],\n                        orelse=[]\n                    )\n                ]\n            else:  # func_name == 'any'\n                # For any(): if all elements are False, create a final assertion\n                # Create a flag to track if any element was True\n                flag_var = self.variable()\n                flag_assign = ast.Assign([ast.Name(flag_var, ast.Store())], ast.NameConstant(False))\n                self.statements.append(flag_assign)\n                \n                loop_body = [\n                    ast.If(\n                        test=ast.Name(loop_var, ast.Load()),\n                        body=[\n                            ast.Assign([ast.Name(flag_var, ast.Store())], ast.NameConstant(True))\n                        ],\n                        orelse=[]\n                    )\n                ]\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iter_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            self.statements.append(for_loop)\n            \n            if func_name == 'any':\n                # Add final assertion for any()\n                final_assert = ast.Assert(\n                    test=ast.Name(flag_var, ast.Load()),\n                    msg=None\n                )\n                self.statements.append(final_assert)\n                return ast.Name(flag_var, ast.Load()), self.explanation_param(flag_var)\n            else:\n                # For all(), return True if we get here\n                return ast.NameConstant(True), \"True\"\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        new_kwargs = []\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(\"%s=%s\" % (keyword.arg, expl))\n            else:\n                arg_expls.append(\"**%s\" % expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable for the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n            self.statements.append(iter_assign)\n            \n            # Create result variable\n            result_var = self.variable()\n            \n            # Initialize result based on function (True for all, False for any)\n            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n            self.statements.append(result_assign)\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # Create the condition inside the loop\n            element_name = ast.Name(loop_var, ast.Load())\n            \n            if func_name == 'all':\n                # For all(): if not element, set result to False and break\n                test_condition = ast.UnaryOp(ast.Not(), element_name)\n                break_value = ast.NameConstant(False)\n            else:\n                # For any(): if element, set result to True and break  \n                test_condition = element_name\n                break_value = ast.NameConstant(True)\n            \n            # Assignment inside if block\n            result_update = ast.Assign([ast.Name(result_var, ast.Store())], break_value)\n            break_stmt = ast.Break()\n            \n            # Create if statement\n            if_stmt = ast.If(test_condition, [result_update, break_stmt], [])\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            return ast.Name(result_var, ast.Load()), self.explanation_param(func_name + \"(...)\")\n        \n        try:\n            new_func, func_expl = self.visit(call.func)\n        except ValueError:\n            # Rewriting the func may fail if it's not a simple name\n            return self.generic_visit(call)\n        arg_expls = []\n        new_args = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        new_kwargs = []\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have keyword.arg = None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            iter_var = self.variable()\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], arg)\n            self.statements.append(iter_assign)\n            \n            # Create a loop variable\n            loop_var = self.variable()\n            \n            # Create the result variable (starts True for all(), False for any())\n            result_var = self.variable()\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n            self.statements.append(result_assign)\n            \n            # Create the for loop\n            loop_target = ast.Name(loop_var, ast.Store())\n            loop_iter = ast.Name(iter_var, ast.Load())\n            \n            # For all(): if not item, result = False and break\n            # For any(): if item, result = True and break\n            if func_name == 'all':\n                test_node = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n                assign_value = ast.NameConstant(False)\n            else:  # any()\n                test_node = ast.Name(loop_var, ast.Load())\n                assign_value = ast.NameConstant(True)\n            \n            # Create assignment and break in the if body\n            loop_assign = ast.Assign([ast.Name(result_var, ast.Store())], assign_value)\n            loop_break = ast.Break()\n            if_body = [loop_assign, loop_break]\n            \n            # Create the if statement\n            if_stmt = ast.If(test_node, if_body, [])\n            \n            # Create the for loop\n            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            return ast.Name(result_var, ast.Load()), self.explanation_param(result_var)\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        new_kwargs = []\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
    ],
    "Location 4 (/root/hy/projects_4/pytest/src/_pytest/assertion/rewrite.py lines 757-760)": [
      "\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n",
      "\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n",
      "\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n",
      "\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n",
      "\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n",
      "\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n",
      "\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n",
      "\ndef builtin(self, name):\n    \"\"\"Return the builtin called *name*.\"\"\"\n    builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n    return ast.Attribute(builtin_name, name, ast.Load())\n"
    ],
    "Location 5 (/root/hy/projects_4/pytest/src/_pytest/assertion/rewrite.py lines 670-675)": [
      "\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n",
      "\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n",
      "\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n",
      "\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        # Add import for itertools to support all/any unrolling\n        aliases.append(ast.alias(\"itertools\", \"@py_itertools\"))\n",
      "\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n",
      "\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n",
      "\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n",
      "\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..098469233 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -667,12 +667,11 @@ class AssertionRewriter(ast.NodeVisitor):\n         if not mod.body:\n             # Nothing to do.\n             return\n-        # Insert some special imports at the top of the module but after any\n-        # docstrings and __future__ imports.\n-        aliases = [\n-            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n-            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n-        ]\n+\n+    def builtin(self, name):\n+        \"\"\"Return the builtin called *name*.\"\"\"\n+        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n+        return ast.Attribute(builtin_name, name, ast.Load())\n         doc = getattr(mod, \"docstring\", None)\n         expect_docstring = doc is None\n         if doc is not None and self.is_rewrite_disabled(doc):\n@@ -754,10 +753,11 @@ class AssertionRewriter(ast.NodeVisitor):\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n \n-    def builtin(self, name):\n-        \"\"\"Return the builtin called *name*.\"\"\"\n-        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n-        return ast.Attribute(builtin_name, name, ast.Load())\n+\n+    if sys.version_info >= (3, 5):\n+        visit_Call = visit_Call_35\n+    else:\n+        visit_Call = visit_Call_legacy\n \n     def explanation_param(self, expr):\n         \"\"\"Return a new named %-formatting placeholder for expr.\n@@ -964,10 +964,133 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n+assert all(predicate(x) for x in iterable)\n+\n+    def visit_Starred(self, starred):\n+        # From Python 3.5, a Starred node can appear in a function call\n+        res, expl = self.visit(starred.value)\n+        new_starred = ast.Starred(res, starred.ctx)\n+        return new_starred, \"*\" + expl\n+\n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            new_iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a variable to store the iterable\n+            iterable_var = self.assign(new_iterable)\n+            \n+            # Create variables for the loop\n+            result_var = self.variable()\n+            item_var = self.variable()\n+            \n+            # Initialize result variable (True for all(), False for any())\n+            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(\n+                ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n+            )\n+            \n+            # Create the for loop that unrolls the all/any logic\n+            loop_body = []\n+            \n+            # Visit each item in the iterable for detailed explanation\n+            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n+                # Handle generator expressions and list comprehensions\n+                if hasattr(iterable_arg, 'elt'):  # Generator expression\n+                    element_expr = iterable_arg.elt\n+                    target = iterable_arg.generators[0].target\n+                    iter_expr = iterable_arg.generators[0].iter\n+                else:  # List comprehension  \n+                    element_expr = iterable_arg.elt\n+                    target = iterable_arg.generators[0].target\n+                    iter_expr = iterable_arg.generators[0].iter\n+                \n+                # Create loop variable assignment\n+                loop_body.append(\n+                    ast.Assign([target], ast.Name(item_var, ast.Load()))\n+                )\n+                \n+                # Visit the element expression for detailed explanation\n+                element_result, element_expl = self.visit(element_expr)\n+                element_var = self.assign(element_result)\n+                \n+                # Create condition check\n+                if func_name == 'all':\n+                    # For all(): if any element is False, set result to False and break\n+                    condition = ast.UnaryOp(ast.Not(), ast.Name(element_var.id, ast.Load()))\n+                    loop_body.append(\n+                        ast.If(\n+                            condition,\n+                            [\n+                                ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                                ast.Break()\n+                            ],\n+                            []\n+                        )\n+                    )\n+                else:  # any()\n+                    # For any(): if any element is True, set result to True and break\n+                    condition = ast.Name(element_var.id, ast.Load())\n+                    loop_body.append(\n+                        ast.If(\n+                            condition,\n+                            [\n+                                ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                                ast.Break()\n+                            ],\n+                            []\n+                        )\n+                    )\n+                \n+                # Create the for loop over the original iterable\n+                visited_iter, iter_expl = self.visit(iter_expr)\n+                for_loop = ast.For(\n+                    target=ast.Name(item_var, ast.Store()),\n+                    iter=visited_iter,\n+                    body=loop_body,\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+            else:\n+                # Handle simple iterables (lists, tuples, etc.)\n+                for_loop = ast.For(\n+                    target=ast.Name(item_var, ast.Store()),\n+                    iter=iterable_var,\n+                    body=[\n+                        ast.If(\n+                            ast.UnaryOp(ast.Not(), ast.Name(item_var, ast.Load())) if func_name == 'all' \n+                            else ast.Name(item_var, ast.Load()),\n+                            [\n+                                ast.Assign([ast.Name(result_var, ast.Store())], \n+                                          ast.NameConstant(False) if func_name == 'all' else ast.NameConstant(True)),\n+                                ast.Break()\n+                            ],\n+                            []\n+                        )\n+                    ],\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (res_expl, res_expl, func_name, iterable_expl)\n+            return res, outer_expl\n+        \n+        # Original generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -991,16 +1114,127 @@ warn_explicit(\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n         return res, outer_expl\n \n-    def visit_Starred(self, starred):\n-        # From Python 3.5, a Starred node can appear in a function call\n-        res, expl = self.visit(starred.value)\n-        new_starred = ast.Starred(res, starred.ctx)\n-        return new_starred, \"*\" + expl\n+    # ast.Call signature changed on 3.5,\n+    # conditionally change  which methods is named\n+    # visit_Call depending on Python version\n \n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            new_iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a variable to store the iterable\n+            iterable_var = self.assign(new_iterable)\n+            \n+            # Create variables for the loop\n+            result_var = self.variable()\n+            item_var = self.variable()\n+            \n+            # Initialize result variable (True for all(), False for any())\n+            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(\n+                ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n+            )\n+            \n+            # Create the for loop that unrolls the all/any logic\n+            loop_body = []\n+            \n+            # Visit each item in the iterable for detailed explanation\n+            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n+                # Handle generator expressions and list comprehensions\n+                if hasattr(iterable_arg, 'elt'):  # Generator expression\n+                    element_expr = iterable_arg.elt\n+                    target = iterable_arg.generators[0].target\n+                    iter_expr = iterable_arg.generators[0].iter\n+                else:  # List comprehension  \n+                    element_expr = iterable_arg.elt\n+                    target = iterable_arg.generators[0].target\n+                    iter_expr = iterable_arg.generators[0].iter\n+                \n+                # Create loop variable assignment\n+                loop_body.append(\n+                    ast.Assign([target], ast.Name(item_var, ast.Load()))\n+                )\n+                \n+                # Visit the element expression for detailed explanation\n+                element_result, element_expl = self.visit(element_expr)\n+                element_var = self.assign(element_result)\n+                \n+                # Create condition check\n+                if func_name == 'all':\n+                    # For all(): if any element is False, set result to False and break\n+                    condition = ast.UnaryOp(ast.Not(), ast.Name(element_var.id, ast.Load()))\n+                    loop_body.append(\n+                        ast.If(\n+                            condition,\n+                            [\n+                                ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                                ast.Break()\n+                            ],\n+                            []\n+                        )\n+                    )\n+                else:  # any()\n+                    # For any(): if any element is True, set result to True and break\n+                    condition = ast.Name(element_var.id, ast.Load())\n+                    loop_body.append(\n+                        ast.If(\n+                            condition,\n+                            [\n+                                ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                                ast.Break()\n+                            ],\n+                            []\n+                        )\n+                    )\n+                \n+                # Create the for loop over the original iterable\n+                visited_iter, iter_expl = self.visit(iter_expr)\n+                for_loop = ast.For(\n+                    target=ast.Name(item_var, ast.Store()),\n+                    iter=visited_iter,\n+                    body=loop_body,\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+            else:\n+                # Handle simple iterables (lists, tuples, etc.)\n+                for_loop = ast.For(\n+                    target=ast.Name(item_var, ast.Store()),\n+                    iter=iterable_var,\n+                    body=[\n+                        ast.If(\n+                            ast.UnaryOp(ast.Not(), ast.Name(item_var, ast.Load())) if func_name == 'all' \n+                            else ast.Name(item_var, ast.Load()),\n+                            [\n+                                ast.Assign([ast.Name(result_var, ast.Store())], \n+                                          ast.NameConstant(False) if func_name == 'all' else ast.NameConstant(True)),\n+                                ast.Break()\n+                            ],\n+                            []\n+                        )\n+                    ],\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (res_expl, res_expl, func_name, iterable_expl)\n+            return res, outer_expl\n+        \n+        # Original generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -1027,14 +1261,6 @@ warn_explicit(\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n         return res, outer_expl\n \n-    # ast.Call signature changed on 3.5,\n-    # conditionally change  which methods is named\n-    # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n-\n     def visit_Attribute(self, attr):\n         if not isinstance(attr.ctx, ast.Load):\n             return self.generic_visit(attr)\n",
    "variant_0": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..234da06b7 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -662,6 +662,12 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.module_path = module_path\n         self.config = config\n \n+    def run(self, mod):\n+        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n+        if not mod.body:\n+            # Nothing to do.\n+            return\n+\n     def run(self, mod):\n         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n         if not mod.body:\n@@ -754,6 +760,7 @@ class AssertionRewriter(ast.NodeVisitor):\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n \n+\n     def builtin(self, name):\n         \"\"\"Return the builtin called *name*.\"\"\"\n         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n@@ -964,10 +971,80 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() builtin functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a unique variable name for the iterator\n+            iter_var = self.variable()\n+            \n+            # Visit the iterable argument\n+            iter_expr, iter_expl = self.visit(iterable_arg)\n+            \n+            # Create the unrolled logic\n+            # For all(): check each element is True, fail on first False\n+            # For any(): check each element is True, succeed on first True\n+            \n+            if func_name == 'all':\n+                # Generate: for item in iterable: assert item\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # Create the for loop body that checks each element\n+                element_check = ast.Name(element_var, ast.Load())\n+                check_expr, check_expl = self.visit(element_check)\n+                \n+                # Build explanation showing which element failed\n+                explanation = \"%s(%s)\" % (func_name, iter_expl)\n+                \n+                # Create a call to the original builtin for the result\n+                builtin_call = ast.Call(\n+                    ast.Attribute(\n+                        ast.Name(\"@py_builtins\", ast.Load()),\n+                        func_name,\n+                        ast.Load()\n+                    ),\n+                    [iter_expr],\n+                    []\n+                )\n+                res = self.assign(builtin_call)\n+                \n+                # Create detailed explanation for failures\n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, explanation)\n+                \n+                return res, outer_expl\n+                \n+            else:  # func_name == 'any'\n+                # Similar logic for any()\n+                explanation = \"%s(%s)\" % (func_name, iter_expl)\n+                \n+                builtin_call = ast.Call(\n+                    ast.Attribute(\n+                        ast.Name(\"@py_builtins\", ast.Load()),\n+                        func_name,\n+                        ast.Load()\n+                    ),\n+                    [iter_expr],\n+                    []\n+                )\n+                res = self.assign(builtin_call)\n+                \n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, explanation)\n+                \n+                return res, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1074,78 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-ins\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create a result variable initialized to True for all(), False for any()\n+            result_var = self.variable()\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop body\n+            loop_body = []\n+            \n+            # Create test condition based on function type\n+            if func_name == 'all':\n+                # For all(): if not item, set result to False and break\n+                test_condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n+                false_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n+                loop_body.append(ast.If(test_condition, [false_assign, ast.Break()], []))\n+            else:  # any()\n+                # For any(): if item, set result to True and break\n+                test_condition = ast.Name(loop_var, ast.Load())\n+                true_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n+                loop_body.append(ast.If(test_condition, [true_assign, ast.Break()], []))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iter_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            return ast.Name(result_var, ast.Load()), result_var\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n-        new_kwargs = []\n-        new_star = new_kwarg = None\n+        new_keywords = []\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n-            arg_expls.append(\"**\" + expl)\n+            new_keywords.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **kwargs\n+                arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_keywords)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n@@ -1030,10 +1154,107 @@ warn_explicit(\n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n     # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on Python3.5 and after\n+        \"\"\"\n+        # Special handling for all() and any() built-ins to provide detailed failure info\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its explanation\n+            iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable)\n+            self.statements.append(iter_assign)\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function (True for all, False for any)\n+            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop to iterate through elements\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Get the current element\n+            element = ast.Name(loop_var, ast.Load())\n+            element_result, element_expl = self.visit(element)\n+            \n+            # Create condition based on function type\n+            if func_name == 'all':\n+                # For all(): if not element, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), element)\n+                new_value = ast.NameConstant(False)\n+            else:\n+                # For any(): if element, set result to True and break\n+                condition = element\n+                new_value = ast.NameConstant(True)\n+            \n+            # Assignment in the if block\n+            if_body = [\n+                ast.Assign([ast.Name(result_var, ast.Store())], new_value),\n+                ast.Break()\n+            ]\n+            \n+            # Create the if statement\n+            if_stmt = ast.If(condition, if_body, [])\n+            loop_body.append(if_stmt)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result = ast.Name(result_var, ast.Load())\n+            \n+            # Create explanation\n+            if func_name == 'all':\n+                expl = \"all(%s)\" % (iterable_expl,)\n+            else:\n+                expl = \"any(%s)\" % (iterable_expl,)\n+                \n+            return result, expl\n+        \n+        new_func, func_expl = self.visit(call.func)\n+        arg_expls = []\n+        new_args = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            arg_expls.append(expl)\n+            new_args.append(res)\n+        keyword_expls = []\n+        new_keywords = []\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            keyword_expls.append(expl)\n+            new_keywords.append(ast.keyword(keyword.arg, res))\n+        if keyword_expls:\n+            expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls + keyword_expls))\n+        else:\n+            expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+\n+        new_call = ast.Call(new_func, new_args, new_keywords)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n \n     def visit_Attribute(self, attr):\n         if not isinstance(attr.ctx, ast.Load):\n",
    "variant_1": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..9950bc9ce 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -662,6 +662,12 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.module_path = module_path\n         self.config = config\n \n+    def run(self, mod):\n+        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n+        if not mod.body:\n+            # Nothing to do.\n+            return\n+\n     def run(self, mod):\n         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n         if not mod.body:\n@@ -754,6 +760,7 @@ class AssertionRewriter(ast.NodeVisitor):\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n \n+\n     def builtin(self, name):\n         \"\"\"Return the builtin called *name*.\"\"\"\n         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n@@ -964,10 +971,75 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create result variable initialized to True for all(), False for any()\n+            result_var = self.variable()\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create the loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create loop body\n+            loop_body = []\n+            \n+            # Get the element and its explanation\n+            element_expr = ast.Name(loop_var, ast.Load())\n+            element_var = self.variable()\n+            loop_body.append(ast.Assign([ast.Name(element_var, ast.Store())], element_expr))\n+            \n+            # For all(): if not element, set result to False and break\n+            # For any(): if element, set result to True and break\n+            if func_name == 'all':\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n+                result_value = ast.NameConstant(False)\n+            else:  # any()\n+                condition = ast.Name(element_var, ast.Load())\n+                result_value = ast.NameConstant(True)\n+            \n+            # Create if statement to update result and break\n+            if_body = [\n+                ast.Assign([ast.Name(result_var, ast.Store())], result_value),\n+                ast.Break()\n+            ]\n+            loop_body.append(ast.If(condition, if_body, []))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result_name = ast.Name(result_var, ast.Load())\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res = self.assign(result_name)\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return res, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1069,100 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-ins\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create the unrolled logic\n+            temp_result = self.variable()\n+            loop_var = self.variable()\n+            \n+            # For all(): start with True, fail on first False\n+            # For any(): start with False, succeed on first True\n+            initial_value = ast.NameConstant(value=(func_name == 'all'))\n+            assign_initial = ast.Assign([ast.Name(temp_result, ast.Store())], initial_value)\n+            \n+            # Create the loop variable assignment and condition check\n+            if func_name == 'all':\n+                # For all(): if any element is False, result is False\n+                condition_check = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n+            else:\n+                # For any(): if any element is True, result is True  \n+                condition_check = ast.Name(loop_var, ast.Load())\n+            \n+            # Create explanation for the failing element\n+            element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n+            \n+            # Build the unrolled assertion logic\n+            stmts = [\n+                ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res),\n+                assign_initial\n+            ]\n+            \n+            # Create a for loop that checks each element\n+            loop_body = [\n+                ast.Assign([ast.Name(loop_var, ast.Store())], ast.Name('__item', ast.Load())),\n+                ast.If(\n+                    test=condition_check,\n+                    body=[\n+                        ast.Assign([ast.Name(temp_result, ast.Store())], \n+                                 ast.NameConstant(value=(func_name == 'any'))),\n+                        ast.Break()\n+                    ],\n+                    orelse=[]\n+                )\n+            ]\n+            \n+            for_loop = ast.For(\n+                target=ast.Name('__item', ast.Store()),\n+                iter=ast.Name(iterable_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            \n+            stmts.append(for_loop)\n+            \n+            # Execute the statements\n+            for stmt in stmts:\n+                self.statements.append(stmt)\n+            \n+            # Return the result with explanation\n+            res = ast.Name(temp_result, ast.Load())\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            return res, expl\n+        \n+        # Original logic for regular function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n-        new_star = new_kwarg = None\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n             new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n-            arg_expls.append(\"**\" + expl)\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **kwargs\n+                arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n@@ -1030,10 +1171,93 @@ warn_explicit(\n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n     # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on Python3.5 and after\n+        \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            iterable_assign = ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_arg)\n+            self.statements.append(iterable_assign)\n+            \n+            # Create a result variable initialized to the identity value\n+            result_var = self.variable()\n+            identity_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], identity_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create the unrolling loop\n+            loop_var = self.variable()\n+            \n+            # Create the loop body that updates result and provides detailed assertion info\n+            loop_body = []\n+            \n+            # Get the current element\n+            element_var = self.variable()\n+            element_assign = ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load()))\n+            loop_body.append(element_assign)\n+            \n+            # Create condition check with detailed explanation\n+            if func_name == 'all':\n+                # For all(): if not element, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n+                new_value = ast.NameConstant(False)\n+            else:\n+                # For any(): if element, set result to True and break  \n+                condition = ast.Name(element_var, ast.Load())\n+                new_value = ast.NameConstant(True)\n+            \n+            # Update result and break on condition\n+            update_result = ast.Assign([ast.Name(result_var, ast.Store())], new_value)\n+            break_stmt = ast.Break()\n+            \n+            if_stmt = ast.If(condition, [update_result, break_stmt], [])\n+            loop_body.append(if_stmt)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iterable_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            return ast.Name(result_var, ast.Load()), self.explanation_param(result_var)\n+        \n+        # Original visit_Call_35 logic for other function calls\n+        new_func, func_expl = self.visit(call.func)\n+        arg_expls = []\n+        new_args = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            arg_expls.append(expl)\n+            new_args.append(res)\n+        new_kwargs = []\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            new_kwargs.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(\"%s=%s\" % (keyword.arg, expl))\n+            else:\n+                arg_expls.append(\"**%s\" % expl)\n+\n+        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n \n     def visit_Attribute(self, attr):\n         if not isinstance(attr.ctx, ast.Load):\n",
    "variant_2": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..1b9c67bce 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -662,6 +662,12 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.module_path = module_path\n         self.config = config\n \n+    def run(self, mod):\n+        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n+        if not mod.body:\n+            # Nothing to do.\n+            return\n+\n     def run(self, mod):\n         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n         if not mod.body:\n@@ -754,6 +760,7 @@ class AssertionRewriter(ast.NodeVisitor):\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n \n+\n     def builtin(self, name):\n         \"\"\"Return the builtin called *name*.\"\"\"\n         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n@@ -964,10 +971,78 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a unique variable name for the loop\n+            loop_var = self.variable()\n+            iter_var = self.variable()\n+            result_var = self.variable()\n+            \n+            # Visit the iterable argument\n+            iter_expr, iter_expl = self.visit(iterable_arg)\n+            \n+            # Create the unrolled logic\n+            # For all(): start with True, break on first False\n+            # For any(): start with False, break on first True\n+            initial_value = ast.NameConstant(value=(func_name == 'all'))\n+            target_value = ast.NameConstant(value=(func_name == 'any'))\n+            \n+            # Assign the result variable with initial value\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create iterator\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], \n+                                   ast.Call(self.builtin(\"iter\"), [iter_expr], []))\n+            self.statements.append(iter_assign)\n+            \n+            # Create the loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # Create loop body with assertion-like logic\n+            element_name = ast.Name(loop_var, ast.Load())\n+            \n+            # For all(): if not element: result = False; break\n+            # For any(): if element: result = True; break\n+            if func_name == 'all':\n+                test_condition = ast.UnaryOp(ast.Not(), element_name)\n+            else:  # any\n+                test_condition = element_name\n+                \n+            # Create the conditional break logic\n+            assign_result = ast.Assign([ast.Name(result_var, ast.Store())], target_value)\n+            break_stmt = ast.Break()\n+            \n+            if_body = [assign_result, break_stmt]\n+            if_stmt = ast.If(test_condition, if_body, [])\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iter_expl)\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return res, outer_expl\n+        \n+        # Original function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1072,91 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on Python 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-ins\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a unique variable name for the iteration\n+            iter_var = self.variable()\n+            item_var = self.variable()\n+            result_var = self.variable()\n+            \n+            # Visit the iterable argument\n+            new_iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create the unrolled logic\n+            # For all(): result = True; for item in iterable: if not item: result = False; break\n+            # For any(): result = False; for item in iterable: if item: result = True; break\n+            \n+            initial_value = ast.NameConstant(value=(func_name == 'all'))\n+            break_condition_test = ast.UnaryOp(op=ast.Not(), operand=ast.Name(id=item_var, ctx=ast.Load())) if func_name == 'all' else ast.Name(id=item_var, ctx=ast.Load())\n+            break_value = ast.NameConstant(value=(func_name == 'any'))\n+            \n+            # Create the unrolled statements\n+            statements = [\n+                # result = True/False\n+                ast.Assign(targets=[ast.Name(id=result_var, ctx=ast.Store())], value=initial_value),\n+                # for item in iterable:\n+                ast.For(\n+                    target=ast.Name(id=item_var, ctx=ast.Store()),\n+                    iter=ast.Name(id=iter_var, ctx=ast.Load()),\n+                    body=[\n+                        # Check the condition and potentially break\n+                        ast.If(\n+                            test=break_condition_test,\n+                            body=[\n+                                ast.Assign(targets=[ast.Name(id=result_var, ctx=ast.Store())], value=break_value),\n+                                ast.Break()\n+                            ],\n+                            orelse=[]\n+                        )\n+                    ],\n+                    orelse=[]\n+                )\n+            ]\n+            \n+            # Create assignment for the iterable\n+            iter_assign = ast.Assign(targets=[ast.Name(id=iter_var, ctx=ast.Store())], value=new_iterable)\n+            \n+            # Execute the statements\n+            self.statements.append(iter_assign)\n+            for stmt in statements:\n+                self.statements.append(stmt)\n+            \n+            # Return the result variable\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(ast.Name(id=result_var, ctx=ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return ast.Name(id=result_var, ctx=ast.Load()), outer_expl\n+        \n+        # Original function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n-        new_kwargs = []\n-        new_star = new_kwarg = None\n+        new_keywords = []\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n-            arg_expls.append(\"**\" + expl)\n+            new_keywords.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **args\n+                arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_keywords)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n@@ -1030,10 +1165,129 @@ warn_explicit(\n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n     # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on Python3.5 and after\n+        \"\"\"\n+        # Special handling for all() and any() functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            iterable_assign = ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_arg)\n+            self.statements.append(iterable_assign)\n+            \n+            # Create result variable\n+            result_var = self.variable()\n+            \n+            # For all(): start with True, for any(): start with False\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Get the current element\n+            element = ast.Name(loop_var, ast.Load())\n+            \n+            # For generators/comprehensions, we need to extract the test condition\n+            if isinstance(iterable_arg, ast.GeneratorExp):\n+                # Extract the element and test from generator\n+                test_expr = iterable_arg.elt\n+                element_name = iterable_arg.generators[0].target.id\n+                \n+                # Substitute the loop variable for the generator variable\n+                class VariableReplacer(ast.NodeTransformer):\n+                    def visit_Name(self, node):\n+                        if isinstance(node.ctx, ast.Load) and node.id == element_name:\n+                            return ast.Name(loop_var, ast.Load())\n+                        return node\n+                \n+                test_expr = VariableReplacer().visit(test_expr)\n+                iterable_source = iterable_arg.generators[0].iter\n+                \n+                # Update the iterable assignment\n+                self.statements[-2] = ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_source)\n+            else:\n+                # For simple iterables, the test is just the element itself\n+                test_expr = element\n+            \n+            # Visit the test expression to get proper explanation\n+            test_result, test_expl = self.visit(test_expr)\n+            \n+            # Create condition based on function type\n+            if func_name == 'all':\n+                # For all(): if any element is False, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), test_result)\n+                new_value = ast.NameConstant(False)\n+            else:\n+                # For any(): if any element is True, set result to True and break\n+                condition = test_result\n+                new_value = ast.NameConstant(True)\n+            \n+            # Create the if statement\n+            if_body = [\n+                ast.Assign([ast.Name(result_var, ast.Store())], new_value),\n+                ast.Break()\n+            ]\n+            \n+            if_stmt = ast.If(condition, if_body, [])\n+            loop_body.append(if_stmt)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            result_name = ast.Name(result_var, ast.Load())\n+            res = self.assign(result_name)\n+            res_expl = self.explanation_param(self.display(res))\n+            \n+            # Build explanation showing the unrolled evaluation\n+            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (\n+                res_expl, res_expl, func_name, self.explanation_param(self.display(ast.Name(iterable_var, ast.Load())))\n+            )\n+            \n+            return res, outer_expl\n+        \n+        # Original visit_Call_35 logic for non-all/any calls\n+        new_func, func_expl = self.visit(call.func)\n+        arg_expls = []\n+        new_args = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            arg_expls.append(expl)\n+            new_args.append(res)\n+        keyword_expls = []\n+        new_keywords = []\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            keyword_expls.append(expl)\n+            new_keywords.append(ast.keyword(keyword.arg, res))\n+        if keyword_expls:\n+            expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls + keyword_expls))\n+        else:\n+            expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+\n+        new_call = ast.Call(new_func, new_args, new_keywords)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n \n     def visit_Attribute(self, attr):\n         if not isinstance(attr.ctx, ast.Load):\n",
    "variant_3": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..01c8f16d8 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -662,6 +662,12 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.module_path = module_path\n         self.config = config\n \n+    def run(self, mod):\n+        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n+        if not mod.body:\n+            # Nothing to do.\n+            return\n+\n     def run(self, mod):\n         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n         if not mod.body:\n@@ -754,6 +760,7 @@ class AssertionRewriter(ast.NodeVisitor):\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n \n+\n     def builtin(self, name):\n         \"\"\"Return the builtin called *name*.\"\"\"\n         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n@@ -964,10 +971,83 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n+            \n+            # Create a temporary variable for the loop variable\n+            loop_var = self.variable()\n+            \n+            # Create a temporary variable for the result\n+            result_var = self.variable()\n+            \n+            # Initialize result variable based on function (True for all, False for any)\n+            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Get the predicate result for current element\n+            element_expr = ast.Name(loop_var, ast.Load())\n+            element_res = self.assign(element_expr)\n+            \n+            # Create condition based on function type\n+            if func_name == 'all':\n+                # For all(): if not element, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n+                loop_body.append(ast.If(\n+                    condition,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                     ast.Break()],\n+                    []\n+                ))\n+            else:  # any()\n+                # For any(): if element, set result to True and break\n+                condition = ast.Name(loop_var, ast.Load())\n+                loop_body.append(ast.If(\n+                    condition,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                     ast.Break()],\n+                    []\n+                ))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                ast.Name(loop_var, ast.Store()),\n+                ast.Name(iterable_var, ast.Load()),\n+                loop_body,\n+                []\n+            )\n+            \n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            res_var = self.assign(res)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(res_var))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return res_var, outer_expl\n+        \n+        # Original function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1077,103 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on Python 3.5 and above\n         \"\"\"\n+        # Special handling for all() and any() built-ins to provide better error messages\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create a temporary variable for the result\n+            result_var = self.variable()\n+            \n+            # Initialize result to True for all(), False for any()\n+            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create the loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop body\n+            loop_body = []\n+            \n+            if func_name == 'all':\n+                # For all(): if not item, set result to False and break\n+                test_var = self.variable()\n+                test_assign = ast.Assign([ast.Name(test_var, ast.Store())], ast.Name(loop_var, ast.Load()))\n+                loop_body.append(test_assign)\n+                \n+                # Create the condition: not item\n+                not_test = ast.UnaryOp(ast.Not(), ast.Name(test_var, ast.Load()))\n+                \n+                # If not item: result = False; break\n+                false_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n+                break_stmt = ast.Break()\n+                if_stmt = ast.If(not_test, [false_assign, break_stmt], [])\n+                loop_body.append(if_stmt)\n+            else:\n+                # For any(): if item, set result to True and break\n+                test_var = self.variable()\n+                test_assign = ast.Assign([ast.Name(test_var, ast.Store())], ast.Name(loop_var, ast.Load()))\n+                loop_body.append(test_assign)\n+                \n+                # If item: result = True; break\n+                true_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n+                break_stmt = ast.Break()\n+                if_stmt = ast.If(ast.Name(test_var, ast.Load()), [true_assign, break_stmt], [])\n+                loop_body.append(if_stmt)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iter_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            return ast.Name(result_var, ast.Load()), result_var\n+        \n+        # Original call handling for non-all/any functions\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n-        new_star = new_kwarg = None\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n             new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **kwargs\n+                arg_expls.append(\"**\" + expl)\n+\n         if call.starargs:\n             new_star, expl = self.visit(call.starargs)\n             arg_expls.append(\"*\" + expl)\n+\n         if call.kwargs:\n             new_kwarg, expl = self.visit(call.kwargs)\n             arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n@@ -1030,10 +1182,85 @@ warn_explicit(\n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n     # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on Python3.5 and after\n+        \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.assign(iterable_arg)\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create result variable initialized to True for all(), False for any()\n+            result_var = self.variable()\n+            initial_value = ast.NameConstant(value=(func_name == 'all'))\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create the loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # For all(): if not item: result = False; break\n+            # For any(): if item: result = True; break\n+            item_test = ast.Name(loop_var, ast.Load())\n+            if func_name == 'all':\n+                condition = ast.UnaryOp(ast.Not(), item_test)\n+                new_value = ast.NameConstant(value=False)\n+            else:  # any()\n+                condition = item_test\n+                new_value = ast.NameConstant(value=True)\n+            \n+            # Create assignment and break statements\n+            assign_stmt = ast.Assign([ast.Name(result_var, ast.Store())], new_value)\n+            break_stmt = ast.Break()\n+            \n+            # Create if statement\n+            if_stmt = ast.If(condition, [assign_stmt, break_stmt], [])\n+            loop_body.append(if_stmt)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result_name = ast.Name(result_var, ast.Load())\n+            return result_name, self.explanation_param(self.display(result_name))\n+        \n+        new_func, func_expl = self.visit(call.func)\n+        arg_expls = []\n+        new_args = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            arg_expls.append(expl)\n+            new_args.append(res)\n+        new_kwargs = []\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            new_kwargs.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **args\n+                arg_expls.append(\"**\" + expl)\n+\n+        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n \n     def visit_Attribute(self, attr):\n         if not isinstance(attr.ctx, ast.Load):\n",
    "variant_4": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..0a163903a 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -662,6 +662,12 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.module_path = module_path\n         self.config = config\n \n+    def run(self, mod):\n+        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n+        if not mod.body:\n+            # Nothing to do.\n+            return\n+\n     def run(self, mod):\n         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n         if not mod.body:\n@@ -673,6 +679,8 @@ class AssertionRewriter(ast.NodeVisitor):\n             ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n             ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n         ]\n+        # Add import for itertools to support all/any unrolling\n+        aliases.append(ast.alias(\"itertools\", \"@py_itertools\"))\n         doc = getattr(mod, \"docstring\", None)\n         expect_docstring = doc is None\n         if doc is not None and self.is_rewrite_disabled(doc):\n@@ -754,6 +762,7 @@ class AssertionRewriter(ast.NodeVisitor):\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n \n+\n     def builtin(self, name):\n         \"\"\"Return the builtin called *name*.\"\"\"\n         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n@@ -964,10 +973,109 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n+            \n+            # Create the unrolled loop logic\n+            if func_name == 'all':\n+                # For all(): check each element is truthy\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # Create: for element in iterable: if not element: return False\n+                loop_body = []\n+                \n+                # Get the element value and explanation\n+                element_name = ast.Name(element_var, ast.Load())\n+                element_res = self.assign(element_name)\n+                element_explanation = self.explanation_param(self.display(element_res))\n+                \n+                # Create the negated test: not element\n+                negated_test = ast.UnaryOp(ast.Not(), element_name)\n+                negated_res = self.assign(negated_test)\n+                \n+                # Create assertion that will fail with detailed info\n+                fail_stmt = ast.Assert(\n+                    ast.Constant(False),\n+                    ast.BinOp(\n+                        ast.Str(\"assert \"),\n+                        ast.Add(),\n+                        ast.Str(element_explanation)\n+                    )\n+                )\n+                \n+                # If not element, fail the assertion\n+                loop_body.append(ast.If(negated_test, [fail_stmt], []))\n+                \n+                # Create the for loop\n+                for_loop = ast.For(\n+                    ast.Name(element_var, ast.Store()),\n+                    ast.Name(iterable_var, ast.Load()),\n+                    loop_body,\n+                    []\n+                )\n+                \n+                self.statements.append(for_loop)\n+                \n+                # Return True if we get through all elements\n+                result_var = self.variable()\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(True)))\n+                \n+                explanation = f\"all({iterable_expl})\"\n+                return ast.Name(result_var, ast.Load()), explanation\n+                \n+            else:  # any()\n+                # For any(): check if any element is truthy\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                result_var = self.variable()\n+                \n+                # Initialize result to False\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(False)))\n+                \n+                # Create: for element in iterable: if element: result = True; break\n+                loop_body = []\n+                \n+                element_name = ast.Name(element_var, ast.Load())\n+                \n+                # If element is truthy, set result to True and break\n+                loop_body.append(ast.If(\n+                    element_name,\n+                    [\n+                        ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(True)),\n+                        ast.Break()\n+                    ],\n+                    []\n+                ))\n+                \n+                for_loop = ast.For(\n+                    ast.Name(element_var, ast.Store()),\n+                    ast.Name(iterable_var, ast.Load()),\n+                    loop_body,\n+                    []\n+                )\n+                \n+                self.statements.append(for_loop)\n+                \n+                explanation = f\"any({iterable_expl})\"\n+                return ast.Name(result_var, ast.Load()), explanation\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,23 +1105,134 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-ins to provide better error messages\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            self.statements.append(ast.Assign([iterable_var], iterable_res))\n+            \n+            # Create loop variable\n+            item_var = self.variable()\n+            \n+            # Create result variable initialized to True for all(), False for any()\n+            result_var = self.variable()\n+            initial_value = ast.NameConstant(value=(func_name == 'all'))\n+            self.statements.append(ast.Assign([result_var], initial_value))\n+            \n+            # Create the unrolled loop\n+            if isinstance(iterable_arg, ast.GeneratorExp):\n+                # Handle generator expressions specially\n+                gen = iterable_arg\n+                loop_target = ast.Name(gen.element.id if isinstance(gen.element, ast.Name) else 'item', ast.Store())\n+                \n+                # Extract the condition from generator\n+                for comprehension in gen.generators:\n+                    # Create for loop\n+                    loop = ast.For(\n+                        target=loop_target,\n+                        iter=comprehension.iter,\n+                        body=[],\n+                        orelse=[]\n+                    )\n+                    \n+                    # Add conditions as if statements\n+                    current_body = loop.body\n+                    for if_clause in comprehension.ifs:\n+                        if_stmt = ast.If(test=if_clause, body=[], orelse=[])\n+                        current_body.append(if_stmt)\n+                        current_body = if_stmt.body\n+                    \n+                    # Create the test expression\n+                    test_expr = gen.element\n+                    \n+                    # For all(): if not test_expr: result = False; break\n+                    # For any(): if test_expr: result = True; break\n+                    if func_name == 'all':\n+                        condition = ast.UnaryOp(op=ast.Not(), operand=test_expr)\n+                        new_value = ast.NameConstant(value=False)\n+                    else:  # any()\n+                        condition = test_expr\n+                        new_value = ast.NameConstant(value=True)\n+                    \n+                    # Create assertion for detailed error reporting\n+                    if func_name == 'all':\n+                        assert_stmt = ast.Assert(test=test_expr, msg=None)\n+                        current_body.append(assert_stmt)\n+                    else:  # any() - we want to track when we find a True value\n+                        # For any(), we continue until we find True, so we assert the opposite to get details\n+                        negated_test = ast.UnaryOp(op=ast.Not(), operand=test_expr)\n+                        temp_var = self.variable()\n+                        assign_temp = ast.Assign([temp_var], test_expr)\n+                        current_body.append(assign_temp)\n+                        \n+                        # If condition is true, set result and break\n+                        if_true = ast.If(\n+                            test=ast.Name(temp_var.id, ast.Load()),\n+                            body=[\n+                                ast.Assign([result_var], ast.NameConstant(value=True)),\n+                                ast.Break()\n+                            ],\n+                            orelse=[]\n+                        )\n+                        current_body.append(if_true)\n+                    \n+                    self.statements.append(loop)\n+            else:\n+                # Handle regular iterables\n+                loop = ast.For(\n+                    target=item_var,\n+                    iter=iterable_var,\n+                    body=[],\n+                    orelse=[]\n+                )\n+                \n+                if func_name == 'all':\n+                    # For all(): assert each item, if any fails the assertion will show details\n+                    assert_stmt = ast.Assert(test=item_var, msg=None)\n+                    loop.body.append(assert_stmt)\n+                else:  # any()\n+                    # For any(): if item is true, set result and break\n+                    if_stmt = ast.If(\n+                        test=item_var,\n+                        body=[\n+                            ast.Assign([result_var], ast.NameConstant(value=True)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                    loop.body.append(if_stmt)\n+                \n+                self.statements.append(loop)\n+            \n+            # Return the result\n+            res_expl = self.explanation_param(self.display(result_var))\n+            return result_var, res_expl\n+        \n+        # Original visit_Call_35 logic for non-all/any calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n-        new_star = new_kwarg = None\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n             arg_expls.append(keyword.arg + \"=\" + expl)\n+            new_kwargs.append(ast.keyword(keyword.arg, res))\n         if call.starargs:\n             new_star, expl = self.visit(call.starargs)\n             arg_expls.append(\"*\" + expl)\n@@ -1021,7 +1240,7 @@ warn_explicit(\n             new_kwarg, expl = self.visit(call.kwargs)\n             arg_expls.append(\"**\" + expl)\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n@@ -1030,10 +1249,91 @@ warn_explicit(\n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n     # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on Python3.5 and after\n+        \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and call.func.id in ('all', 'any') and\n+            len(call.args) == 1 and not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its explanation\n+            iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a unique variable name for the iteration\n+            iter_var = self.variable()\n+            element_var = self.variable()\n+            result_var = self.variable()\n+            \n+            # Create the unrolled logic\n+            # For all(): result = True; for element in iterable: if not element: result = False; break\n+            # For any(): result = False; for element in iterable: if element: result = True; break\n+            \n+            initial_value = ast.NameConstant(value=(func_name == 'all'))\n+            assign_initial = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n+            \n+            # Create the test condition\n+            if func_name == 'all':\n+                test_condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n+                break_value = ast.NameConstant(value=False)\n+            else:  # any\n+                test_condition = ast.Name(element_var, ast.Load())\n+                break_value = ast.NameConstant(value=True)\n+            \n+            # Create the if statement inside the loop\n+            assign_result = ast.Assign([ast.Name(result_var, ast.Store())], break_value)\n+            break_stmt = ast.Break()\n+            if_stmt = ast.If(test_condition, [assign_result, break_stmt], [])\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(element_var, ast.Store()),\n+                iter=iterable,\n+                body=[if_stmt],\n+                orelse=[]\n+            )\n+            \n+            # Add the statements to the current statement list\n+            self.statements.append(assign_initial)\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result_name = ast.Name(result_var, ast.Load())\n+            result_expl = self.explanation_param(self.display(result_name))\n+            \n+            # Create explanation showing the unrolled logic\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (result_expl, result_expl, expl)\n+            \n+            return result_name, outer_expl\n+\n+        new_func, func_expl = self.visit(call.func)\n+        arg_expls = []\n+        new_args = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            arg_expls.append(expl)\n+            new_args.append(res)\n+        keyword_expls = []\n+        new_keywords = []\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            keyword_expls.append(expl)\n+            new_keywords.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(\"%s=%s\" % (keyword.arg, expl))\n+            else:  # **args\n+                arg_expls.append(\"**%s\" % expl)\n+        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+        new_call = ast.Call(new_func, new_args, new_keywords)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n \n     def visit_Attribute(self, attr):\n         if not isinstance(attr.ctx, ast.Load):\n",
    "variant_5": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..9279a3145 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -662,6 +662,12 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.module_path = module_path\n         self.config = config\n \n+    def run(self, mod):\n+        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n+        if not mod.body:\n+            # Nothing to do.\n+            return\n+\n     def run(self, mod):\n         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n         if not mod.body:\n@@ -754,6 +760,7 @@ class AssertionRewriter(ast.NodeVisitor):\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n \n+\n     def builtin(self, name):\n         \"\"\"Return the builtin called *name*.\"\"\"\n         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n@@ -964,10 +971,115 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a unique variable name for the iterator\n+            iter_var = self.variable()\n+            \n+            # Visit the iterable argument\n+            iter_expr, iter_expl = self.visit(iterable_arg)\n+            \n+            # Create the unrolled logic\n+            # For all(): check each element is truthy, fail on first falsy\n+            # For any(): check each element is truthy, succeed on first truthy\n+            \n+            if func_name == 'all':\n+                # Transform all(iterable) into:\n+                # _pytest_temp_iter = iter(iterable)\n+                # for _pytest_temp_var in _pytest_temp_iter:\n+                #     if not _pytest_temp_var:\n+                #         return False\n+                # return True\n+                \n+                loop_var = self.variable()\n+                temp_var = self.variable()\n+                \n+                # Create iterator assignment\n+                iter_call = ast.Call(\n+                    func=ast.Name(\"iter\", ast.Load()),\n+                    args=[iter_expr],\n+                    keywords=[]\n+                )\n+                iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iter_call)\n+                \n+                # Create the loop body that checks each element\n+                loop_target = ast.Name(loop_var, ast.Store())\n+                loop_iter = ast.Name(iter_var, ast.Load())\n+                \n+                # Create the condition: not element\n+                element_load = ast.Name(loop_var, ast.Load())\n+                not_element = ast.UnaryOp(ast.Not(), element_load)\n+                \n+                # Create explanation for the failing element\n+                element_expl = self.explanation_param(self.display(ast.Name(loop_var, ast.Load())))\n+                fail_expl = \"False\\n{False = not %s\\n}\" % element_expl\n+                \n+                # Create the early return for failure case\n+                fail_return = ast.Return(ast.NameConstant(False))\n+                \n+                # Wrap in conditional\n+                loop_body = [ast.If(not_element, [fail_return], [])]\n+                \n+                # Create the for loop\n+                for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+                \n+                # Create final return True\n+                success_return = ast.Return(ast.NameConstant(True))\n+                \n+                # Combine into a function that we'll call immediately\n+                func_body = [iter_assign, for_loop, success_return]\n+                \n+                # Create an immediately invoked function expression\n+                temp_func = ast.FunctionDef(\n+                    name=temp_var,\n+                    args=ast.arguments(args=[], defaults=[], kwonlyargs=[], kw_defaults=[], vararg=None, kwarg=None),\n+                    body=func_body,\n+                    decorator_list=[],\n+                    returns=None\n+                )\n+                \n+                # Actually, let's use a simpler approach with a generator expression\n+                # that we can evaluate step by step\n+                \n+                # For now, fall back to creating a detailed explanation\n+                expl = \"all(%s)\" % iter_expl\n+                new_call = ast.Call(\n+                    func=ast.Name(\"all\", ast.Load()),\n+                    args=[iter_expr], \n+                    keywords=[]\n+                )\n+                res = self.assign(new_call)\n+                res_expl = self.explanation_param(self.display(res))\n+                \n+                # Try to provide more detail about what failed\n+                outer_expl = \"%s\\n{%s = all(%s)\\n}\" % (res_expl, res_expl, iter_expl)\n+                return res, outer_expl\n+                \n+            else:  # func_name == 'any'\n+                # Similar logic for any() but with opposite semantics\n+                expl = \"any(%s)\" % iter_expl\n+                new_call = ast.Call(\n+                    func=ast.Name(\"any\", ast.Load()),\n+                    args=[iter_expr],\n+                    keywords=[]\n+                )\n+                res = self.assign(new_call)\n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = any(%s)\\n}\" % (res_expl, res_expl, iter_expl)\n+                return res, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1109,146 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            # Get the iterable argument\n+            iterable_arg = call.args[0]\n+            \n+            # Create a unique variable name for the loop\n+            loop_var = self.variable()\n+            iter_var = self.variable()\n+            result_var = self.variable()\n+            \n+            # Visit the iterable expression\n+            iter_res, iter_expl = self.visit(iterable_arg)\n+            \n+            # Create the unrolled logic\n+            is_all = call.func.id == 'all'\n+            \n+            # For all(): result starts True, becomes False on first falsy item\n+            # For any(): result starts False, becomes True on first truthy item\n+            initial_value = ast.NameConstant(value=is_all)\n+            \n+            # Create assignment: result_var = True/False\n+            result_assign = ast.Assign(\n+                targets=[ast.Name(result_var, ast.Store())],\n+                value=initial_value\n+            )\n+            \n+            # Create the loop variable and iterator\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            iter_call = ast.Call(\n+                func=ast.Name('iter', ast.Load()),\n+                args=[iter_res],\n+                keywords=[]\n+            )\n+            iter_assign = ast.Assign(\n+                targets=[ast.Name(iter_var, ast.Store())],\n+                value=iter_call\n+            )\n+            \n+            # Create the loop body\n+            # Get next item: loop_var = next(iter_var)\n+            next_call = ast.Call(\n+                func=ast.Name('next', ast.Load()),\n+                args=[ast.Name(iter_var, ast.Load())],\n+                keywords=[]\n+            )\n+            item_assign = ast.Assign(\n+                targets=[loop_target],\n+                value=next_call\n+            )\n+            \n+            # Create condition check\n+            item_ref = ast.Name(loop_var, ast.Load())\n+            if is_all:\n+                # For all(): if not item, result = False and break\n+                condition = ast.UnaryOp(op=ast.Not(), operand=item_ref)\n+                new_value = ast.NameConstant(value=False)\n+            else:\n+                # For any(): if item, result = True and break\n+                condition = item_ref\n+                new_value = ast.NameConstant(value=True)\n+            \n+            # Create the conditional assignment and break\n+            cond_assign = ast.Assign(\n+                targets=[ast.Name(result_var, ast.Store())],\n+                value=new_value\n+            )\n+            break_stmt = ast.Break()\n+            \n+            # Create if statement\n+            if_stmt = ast.If(\n+                test=condition,\n+                body=[cond_assign, break_stmt],\n+                orelse=[]\n+            )\n+            \n+            # Create try/except for StopIteration\n+            try_stmt = ast.Try(\n+                body=[\n+                    ast.While(\n+                        test=ast.NameConstant(value=True),\n+                        body=[item_assign, if_stmt],\n+                        orelse=[]\n+                    )\n+                ],\n+                handlers=[\n+                    ast.ExceptHandler(\n+                        type=ast.Name('StopIteration', ast.Load()),\n+                        name=None,\n+                        body=[ast.Pass()]\n+                    )\n+                ],\n+                orelse=[],\n+                finalbody=[]\n+            )\n+            \n+            # Build the complete statement sequence\n+            stmts = [result_assign, iter_assign, try_stmt]\n+            \n+            # Add all statements to the current statement list\n+            self.statements.extend(stmts)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            res_name = self.assign(res)\n+            \n+            # Create explanation\n+            func_name = call.func.id\n+            expl = \"%s(%s)\" % (func_name, iter_expl)\n+            res_expl = self.explanation_param(self.display(res_name))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return res_name, outer_expl\n+        \n+        # Original visit_Call_35 logic for non-all/any calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n-        new_kwargs = []\n-        new_star = new_kwarg = None\n+        new_keywords = []\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n-            arg_expls.append(\"**\" + expl)\n+            new_keywords.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **args\n+                arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_keywords)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n@@ -1030,10 +1257,98 @@ warn_explicit(\n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n     # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on Python3.5 and after\n+        \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create result variable\n+            result_var = self.variable()\n+            \n+            # For all(), start with True and AND each element\n+            # For any(), start with False and OR each element  \n+            initial_value = ast.NameConstant(value=(func_name == 'all'))\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # Create loop body that updates result and provides detailed assertion info\n+            element_node = ast.Name(loop_var, ast.Load())\n+            element_res, element_expl = self.visit(element_node)\n+            \n+            if func_name == 'all':\n+                # For all(): if any element is False, the result is False\n+                # result = result and element\n+                test_node = ast.UnaryOp(ast.Not(), element_node)\n+                condition = ast.Compare(test_node, [ast.Is()], [ast.NameConstant(value=True)])\n+                \n+                # If element is False, set result to False and break\n+                result_update = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(value=False))\n+                break_stmt = ast.Break()\n+                if_body = [result_update, break_stmt]\n+            else:  # any()\n+                # For any(): if any element is True, the result is True  \n+                # result = result or element\n+                condition = ast.Compare(element_node, [ast.Is()], [ast.NameConstant(value=True)])\n+                \n+                # If element is True, set result to True and break\n+                result_update = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(value=True))\n+                break_stmt = ast.Break()\n+                if_body = [result_update, break_stmt]\n+            \n+            if_stmt = ast.If(condition, if_body, [])\n+            loop_body = [if_stmt]\n+            \n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result_node = ast.Name(result_var, ast.Load())\n+            res_expl = \"%s(%s)\" % (func_name, self.explanation_param(self.display(ast.Name(iter_var, ast.Load()))))\n+            \n+            return result_node, res_expl\n+        \n+        new_func, func_expl = self.visit(call.func)\n+        arg_expls = []\n+        new_args = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            arg_expls.append(expl)\n+            new_args.append(res)\n+        new_kwargs = []\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            new_kwargs.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **args\n+                arg_expls.append(\"**\" + expl)\n+\n+        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n \n     def visit_Attribute(self, attr):\n         if not isinstance(attr.ctx, ast.Load):\n",
    "variant_6": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..f48fe9d76 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -662,6 +662,12 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.module_path = module_path\n         self.config = config\n \n+    def run(self, mod):\n+        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n+        if not mod.body:\n+            # Nothing to do.\n+            return\n+\n     def run(self, mod):\n         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n         if not mod.body:\n@@ -754,6 +760,7 @@ class AssertionRewriter(ast.NodeVisitor):\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n \n+\n     def builtin(self, name):\n         \"\"\"Return the builtin called *name*.\"\"\"\n         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n@@ -964,10 +971,76 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n+            \n+            # Create the unrolled loop logic\n+            loop_var = self.variable()\n+            result_var = self.variable()\n+            \n+            # Initialize result variable (True for all(), False for any())\n+            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create the loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the loop body\n+            element_expr = ast.Name(loop_var, ast.Load())\n+            element_test_var = self.variable()\n+            \n+            if func_name == 'all':\n+                # For all(): if not element, set result to False and break\n+                test_expr = ast.UnaryOp(ast.Not(), element_expr)\n+                assign_value = ast.NameConstant(False)\n+            else:\n+                # For any(): if element, set result to True and break\n+                test_expr = element_expr\n+                assign_value = ast.NameConstant(True)\n+            \n+            # Assign the test result to a variable for better error reporting\n+            test_assign = ast.Assign([ast.Name(element_test_var, ast.Store())], element_expr)\n+            \n+            # Create the conditional assignment and break\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], assign_value)\n+            break_stmt = ast.Break()\n+            \n+            if_body = [result_assign, break_stmt]\n+            if_stmt = ast.If(test_expr, if_body, [])\n+            \n+            loop_body = [test_assign, if_stmt]\n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            \n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result_name = ast.Name(result_var, ast.Load())\n+            res = self.assign(result_name)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return res, outer_expl\n+        \n+        # Original function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1070,101 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-ins\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and\n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            iter_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable_res))\n+            \n+            # Create result variable\n+            result_var = self.variable()\n+            \n+            # For all(): start with True, for any(): start with False\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # Create loop body\n+            loop_body = []\n+            \n+            if func_name == 'all':\n+                # For all(): if any element is False, set result to False and break\n+                element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n+                test_var = self.variable()\n+                loop_body.append(ast.Assign([ast.Name(test_var, ast.Store())], element_res))\n+                \n+                # if not element: result = False; break\n+                not_test = ast.UnaryOp(ast.Not(), ast.Name(test_var, ast.Load()))\n+                assign_false = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n+                break_stmt = ast.Break()\n+                if_stmt = ast.If(not_test, [assign_false, break_stmt], [])\n+                loop_body.append(if_stmt)\n+            else:  # any()\n+                # For any(): if any element is True, set result to True and break\n+                element_res, element_expl = self.visit(ast.Name(loop_var, ast.Load()))\n+                test_var = self.variable()\n+                loop_body.append(ast.Assign([ast.Name(test_var, ast.Store())], element_res))\n+                \n+                # if element: result = True; break\n+                assign_true = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n+                break_stmt = ast.Break()\n+                if_stmt = ast.If(ast.Name(test_var, ast.Load()), [assign_true, break_stmt], [])\n+                loop_body.append(if_stmt)\n+            \n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s(%s)\\n}\" % (res_expl, res_expl, func_name, iterable_expl)\n+            return res, outer_expl\n+        \n+        # Original visit_Call_35 logic for non-all/any calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n-        new_star = new_kwarg = None\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n             new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **kwargs\n+                arg_expls.append(\"**\" + expl)\n+\n         if call.starargs:\n             new_star, expl = self.visit(call.starargs)\n             arg_expls.append(\"*\" + expl)\n+\n         if call.kwargs:\n             new_kwarg, expl = self.visit(call.kwargs)\n             arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n@@ -1030,10 +1173,105 @@ warn_explicit(\n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n     # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on Python3.5 and after\n+        \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the unrolled logic\n+            if func_name == 'all':\n+                # For all(): if any element is False, the assertion fails\n+                # for item in iterable:\n+                #     if not item:\n+                #         assert item  # This will show the failing item\n+                loop_body = [\n+                    ast.If(\n+                        test=ast.UnaryOp(op=ast.Not(), operand=ast.Name(loop_var, ast.Load())),\n+                        body=[\n+                            ast.Assert(\n+                                test=ast.Name(loop_var, ast.Load()),\n+                                msg=None\n+                            )\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+            else:  # func_name == 'any'\n+                # For any(): if all elements are False, create a final assertion\n+                # Create a flag to track if any element was True\n+                flag_var = self.variable()\n+                flag_assign = ast.Assign([ast.Name(flag_var, ast.Store())], ast.NameConstant(False))\n+                self.statements.append(flag_assign)\n+                \n+                loop_body = [\n+                    ast.If(\n+                        test=ast.Name(loop_var, ast.Load()),\n+                        body=[\n+                            ast.Assign([ast.Name(flag_var, ast.Store())], ast.NameConstant(True))\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iter_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            self.statements.append(for_loop)\n+            \n+            if func_name == 'any':\n+                # Add final assertion for any()\n+                final_assert = ast.Assert(\n+                    test=ast.Name(flag_var, ast.Load()),\n+                    msg=None\n+                )\n+                self.statements.append(final_assert)\n+                return ast.Name(flag_var, ast.Load()), self.explanation_param(flag_var)\n+            else:\n+                # For all(), return True if we get here\n+                return ast.NameConstant(True), \"True\"\n+        \n+        new_func, func_expl = self.visit(call.func)\n+        arg_expls = []\n+        new_args = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            arg_expls.append(expl)\n+            new_args.append(res)\n+        new_kwargs = []\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            new_kwargs.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(\"%s=%s\" % (keyword.arg, expl))\n+            else:\n+                arg_expls.append(\"**%s\" % expl)\n+\n+        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n \n     def visit_Attribute(self, attr):\n         if not isinstance(attr.ctx, ast.Load):\n",
    "variant_7": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..c3729aedb 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -662,6 +662,12 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.module_path = module_path\n         self.config = config\n \n+    def run(self, mod):\n+        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n+        if not mod.body:\n+            # Nothing to do.\n+            return\n+\n     def run(self, mod):\n         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n         if not mod.body:\n@@ -754,6 +760,7 @@ class AssertionRewriter(ast.NodeVisitor):\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n \n+\n     def builtin(self, name):\n         \"\"\"Return the builtin called *name*.\"\"\"\n         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n@@ -964,10 +971,67 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            iter_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable_res))\n+            \n+            # Create result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            if func_name == 'all':\n+                init_value = ast.NameConstant(True)\n+            else:  # any\n+                init_value = ast.NameConstant(False)\n+            \n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # Create loop body\n+            element_res = ast.Name(loop_var, ast.Load())\n+            \n+            if func_name == 'all':\n+                # For all(): if not element, set result to False and break\n+                test = ast.UnaryOp(ast.Not(), element_res)\n+                assign_false = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n+                break_stmt = ast.Break()\n+                if_stmt = ast.If(test, [assign_false, break_stmt], [])\n+            else:  # any\n+                # For any(): if element, set result to True and break\n+                test = element_res\n+                assign_true = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n+                break_stmt = ast.Break()\n+                if_stmt = ast.If(test, [assign_true, break_stmt], [])\n+            \n+            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result = ast.Name(result_var, ast.Load())\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            return result, expl\n+        \n+        # Original function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1061,85 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on Python 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-ins to provide better error messages\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create a temporary variable for the result\n+            result_var = self.variable()\n+            \n+            # Initialize result variable based on function (True for all, False for any)\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop to iterate over the iterable\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            if func_name == 'all':\n+                # For all(): if any element is falsy, set result to False and break\n+                test_expr = ast.Name(loop_var, ast.Load())\n+                # Create: if not item: result = False; break\n+                not_test = ast.UnaryOp(ast.Not(), test_expr)\n+                false_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n+                break_stmt = ast.Break()\n+                if_stmt = ast.If(not_test, [false_assign, break_stmt], [])\n+                loop_body.append(if_stmt)\n+            else:  # any()\n+                # For any(): if any element is truthy, set result to True and break\n+                test_expr = ast.Name(loop_var, ast.Load())\n+                # Create: if item: result = True; break\n+                true_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n+                break_stmt = ast.Break()\n+                if_stmt = ast.If(test_expr, [true_assign, break_stmt], [])\n+                loop_body.append(if_stmt)\n+            \n+            for_loop = ast.For(loop_target, loop_iter, loop_body, [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result_name = ast.Name(result_var, ast.Load())\n+            return result_name, result_var\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n-        new_star = new_kwarg = None\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n             new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n-            arg_expls.append(\"**\" + expl)\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **args\n+                arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n@@ -1030,10 +1148,91 @@ warn_explicit(\n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n     # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on Python3.5 and after\n+        \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function (True for all, False for any)\n+            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # Create the condition inside the loop\n+            element_name = ast.Name(loop_var, ast.Load())\n+            \n+            if func_name == 'all':\n+                # For all(): if not element, set result to False and break\n+                test_condition = ast.UnaryOp(ast.Not(), element_name)\n+                break_value = ast.NameConstant(False)\n+            else:\n+                # For any(): if element, set result to True and break  \n+                test_condition = element_name\n+                break_value = ast.NameConstant(True)\n+            \n+            # Assignment inside if block\n+            result_update = ast.Assign([ast.Name(result_var, ast.Store())], break_value)\n+            break_stmt = ast.Break()\n+            \n+            # Create if statement\n+            if_stmt = ast.If(test_condition, [result_update, break_stmt], [])\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            return ast.Name(result_var, ast.Load()), self.explanation_param(func_name + \"(...)\")\n+        \n+        try:\n+            new_func, func_expl = self.visit(call.func)\n+        except ValueError:\n+            # Rewriting the func may fail if it's not a simple name\n+            return self.generic_visit(call)\n+        arg_expls = []\n+        new_args = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            arg_expls.append(expl)\n+            new_args.append(res)\n+        new_kwargs = []\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            new_kwargs.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **args have keyword.arg = None\n+                arg_expls.append(\"**\" + expl)\n+\n+        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n \n     def visit_Attribute(self, attr):\n         if not isinstance(attr.ctx, ast.Load):\n",
    "variant_8": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..efb30ccf2 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -662,6 +662,12 @@ class AssertionRewriter(ast.NodeVisitor):\n         self.module_path = module_path\n         self.config = config\n \n+    def run(self, mod):\n+        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n+        if not mod.body:\n+            # Nothing to do.\n+            return\n+\n     def run(self, mod):\n         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n         if not mod.body:\n@@ -754,10 +760,11 @@ class AssertionRewriter(ast.NodeVisitor):\n         attr = ast.Attribute(py_name, name, ast.Load())\n         return ast_Call(attr, list(args), [])\n \n-    def builtin(self, name):\n-        \"\"\"Return the builtin called *name*.\"\"\"\n-        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n-        return ast.Attribute(builtin_name, name, ast.Load())\n+\n+def builtin(self, name):\n+    \"\"\"Return the builtin called *name*.\"\"\"\n+    builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n+    return ast.Attribute(builtin_name, name, ast.Load())\n \n     def explanation_param(self, expr):\n         \"\"\"Return a new named %-formatting placeholder for expr.\n@@ -964,10 +971,81 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Assign the iterable to our temporary variable\n+            self.statements.append(ast.Assign([iterable_var], iterable_expr))\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the loop body that checks each element\n+            element_expr, element_expl = self.visit(loop_var)\n+            \n+            if func_name == 'all':\n+                # For all(), we want to assert each element is truthy\n+                test_expr = element_expr\n+                test_expl = element_expl\n+            else:  # any()\n+                # For any(), we want to find at least one truthy element\n+                # We'll use a different approach - track if we found any True\n+                found_var = self.variable()\n+                self.statements.append(ast.Assign([found_var], ast.NameConstant(False)))\n+                \n+                # Create conditional to set found_var = True if element is truthy\n+                set_found = ast.Assign([found_var], ast.NameConstant(True))\n+                condition = ast.If(element_expr, [set_found], [])\n+                \n+                # Create the for loop\n+                for_loop = ast.For(\n+                    target=loop_var,\n+                    iter=iterable_var,\n+                    body=[condition],\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+                \n+                # Return the found variable\n+                res_expl = self.explanation_param(self.display(found_var))\n+                outer_expl = \"%s\\n{%s = any(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n+                return found_var, outer_expl\n+            \n+            # For all(), create assertion in loop body\n+            assert_stmt = ast.Assert(test_expr, None)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=loop_var,\n+                iter=iterable_var,\n+                body=[assert_stmt],\n+                orelse=[]\n+            )\n+            self.statements.append(for_loop)\n+            \n+            # Return True (all elements passed)\n+            true_var = self.variable()\n+            self.statements.append(ast.Assign([true_var], ast.NameConstant(True)))\n+            \n+            res_expl = self.explanation_param(self.display(true_var))\n+            outer_expl = \"%s\\n{%s = all(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n+            return true_var, outer_expl\n+        \n+        # Original function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,31 +1075,85 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n+\n+    def visit_Call_35(self, call):\n         \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n+        visit `ast.Call` nodes on 3.5+\n         \"\"\"\n+        # Special handling for all() and any() built-ins\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable for the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # For all(): if not item, result = False and break\n+            # For any(): if item, result = True and break\n+            if func_name == 'all':\n+                test = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n+                assign_value = ast.NameConstant(False)\n+            else:  # any()\n+                test = ast.Name(loop_var, ast.Load())\n+                assign_value = ast.NameConstant(True)\n+            \n+            # Create the if statement inside the loop\n+            if_assign = ast.Assign([ast.Name(result_var, ast.Store())], assign_value)\n+            if_break = ast.Break()\n+            if_body = [if_assign, if_break]\n+            if_stmt = ast.If(test, if_body, [])\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            return ast.Name(result_var, ast.Load()), result_var\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n         new_kwargs = []\n-        new_star = new_kwarg = None\n         for arg in call.args:\n             res, expl = self.visit(arg)\n-            new_args.append(res)\n             arg_expls.append(expl)\n+            new_args.append(res)\n         for keyword in call.keywords:\n             res, expl = self.visit(keyword.value)\n             new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **kwargs\n+                arg_expls.append(\"**\" + expl)\n+\n         if call.starargs:\n             new_star, expl = self.visit(call.starargs)\n             arg_expls.append(\"*\" + expl)\n+\n         if call.kwargs:\n             new_kwarg, expl = self.visit(call.kwargs)\n             arg_expls.append(\"**\" + expl)\n+\n         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n         res = self.assign(new_call)\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n@@ -1030,10 +1162,83 @@ warn_explicit(\n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n     # visit_Call depending on Python version\n-    if sys.version_info >= (3, 5):\n-        visit_Call = visit_Call_35\n-    else:\n-        visit_Call = visit_Call_legacy\n+\n+    def visit_Call_35(self, call):\n+        \"\"\"\n+        visit `ast.Call` nodes on Python3.5 and after\n+        \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iter_var = self.variable()\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], arg)\n+            self.statements.append(iter_assign)\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the result variable (starts True for all(), False for any())\n+            result_var = self.variable()\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n+            self.statements.append(result_assign)\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(loop_var, ast.Store())\n+            loop_iter = ast.Name(iter_var, ast.Load())\n+            \n+            # For all(): if not item, result = False and break\n+            # For any(): if item, result = True and break\n+            if func_name == 'all':\n+                test_node = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n+                assign_value = ast.NameConstant(False)\n+            else:  # any()\n+                test_node = ast.Name(loop_var, ast.Load())\n+                assign_value = ast.NameConstant(True)\n+            \n+            # Create assignment and break in the if body\n+            loop_assign = ast.Assign([ast.Name(result_var, ast.Store())], assign_value)\n+            loop_break = ast.Break()\n+            if_body = [loop_assign, loop_break]\n+            \n+            # Create the if statement\n+            if_stmt = ast.If(test_node, if_body, [])\n+            \n+            # Create the for loop\n+            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            return ast.Name(result_var, ast.Load()), self.explanation_param(result_var)\n+        \n+        new_func, func_expl = self.visit(call.func)\n+        arg_expls = []\n+        new_args = []\n+        for arg in call.args:\n+            res, expl = self.visit(arg)\n+            arg_expls.append(expl)\n+            new_args.append(res)\n+        new_kwargs = []\n+        for keyword in call.keywords:\n+            res, expl = self.visit(keyword.value)\n+            new_kwargs.append(ast.keyword(keyword.arg, res))\n+            if keyword.arg:\n+                arg_expls.append(keyword.arg + \"=\" + expl)\n+            else:  # **args\n+                arg_expls.append(\"**\" + expl)\n+\n+        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+        new_call = ast.Call(new_func, new_args, new_kwargs)\n+        res = self.assign(new_call)\n+        res_expl = self.explanation_param(self.display(res))\n+        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+        return res, outer_expl\n \n     def visit_Attribute(self, attr):\n         if not isinstance(attr.ctx, ast.Load):\n"
  }
}