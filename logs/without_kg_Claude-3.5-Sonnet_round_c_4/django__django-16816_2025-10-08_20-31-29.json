{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/contrib/admin/checks.py lines 893-918)": "\n    def _check_list_display_item(self, obj, item, label):\n        if callable(item):\n            return []\n        \n        # Check if it's a model field\n        try:\n            field = obj.model._meta.get_field(item)\n        except FieldDoesNotExist:\n            # Check if it's an attribute of the ModelAdmin class\n            if hasattr(obj, item):\n                return []\n            # Check if it's an attribute of the model\n            try:\n                field = getattr(obj.model, item)\n            except AttributeError:\n                return [\n                    checks.Error(\n                        \"The value of '%s' refers to '%s', which is not a \"\n                        \"callable, an attribute of '%s', or an attribute or \"\n                        \"method on '%s'.\"\n                        % (\n                            label,\n                            item,\n                            obj.__class__.__name__,\n                            obj.model._meta.label,\n                        ),\n                        obj=obj.__class__,\n                        id=\"admin.E108\",\n                    )\n                ]\n            else:\n                return []\n        else:\n            # It's a model field, continue with field validation\n            pass\n",
    "Location 2 (/root/hy/projects_4/django/django/contrib/admin/utils.py lines 340-378)": "\ndef label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n    \"\"\"\n    Return a sensible label for a field name. The name can be a callable,\n    property (but not created with @property decorator), or the name of an\n    object's attribute, as well as a model field. If return_attr is True, also\n    return the resolved attribute (which could be a callable). This will be\n    None if (and only if) the name refers to a field.\n    \"\"\"\n    attr = None\n    try:\n        field = _get_non_gfk_field(model._meta, name)\n        try:\n            label = field.verbose_name\n        except AttributeError:\n            # field is likely a ForeignObjectRel\n            label = field.related_model._meta.verbose_name\n    except FieldDoesNotExist:\n        if name == \"__str__\":\n            label = str(model._meta.verbose_name)\n            attr = str\n        else:\n            if callable(name):\n                attr = name\n            elif model_admin and hasattr(model_admin, name):\n                attr = getattr(model_admin, name)\n            elif hasattr(model, name):\n                attr = getattr(model, name)\n            elif form and name in form.fields:\n                attr = form.fields[name]\n            else:\n                message = \"Unable to lookup '%s' on %s\" % (\n                    name,\n                    model._meta.object_name,\n                )\n                if model_admin:\n                    message += \" or %s\" % model_admin.__class__.__name__\n                if form:\n                    message += \" or %s\" % form.__class__.__name__\n                raise AttributeError(message)\n",
    "Location 3 (/root/hy/projects_4/django/tests/modeladmin/test_checks.py lines 520-531)": "\n    def test_missing_field(self):\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"non_existent_field\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'non_existent_field', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n\n    def test_missing_field_choice_scenario(self):\n        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"choice\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'choice', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/contrib/admin/checks.py lines 893-918)": [
      "\n    def _check_list_display_item(self, obj, item, label):\n        if callable(item):\n            return []\n        \n        # Check if it's a model field\n        try:\n            field = obj.model._meta.get_field(item)\n        except FieldDoesNotExist:\n            # Check if it's an attribute of the ModelAdmin\n            if hasattr(obj, item):\n                return []\n            # Check if it's an attribute/method of the model\n            try:\n                field = getattr(obj.model, item)\n            except AttributeError:\n                return [\n                    checks.Error(\n                        \"The value of '%s' refers to '%s', which is not a \"\n                        \"callable, an attribute of '%s', or an attribute or \"\n                        \"method on '%s'.\"\n                        % (\n                            label,\n                            item,\n                            obj.__class__.__name__,\n                            obj.model._meta.label,\n                        ),\n                        obj=obj.__class__,\n                        id=\"admin.E108\",\n                    )\n                ]\n            else:\n                return []\n",
      "\n    def _check_list_display_item(self, obj, item, label):\n        if callable(item):\n            return []\n        \n        # Check if it's a model field\n        try:\n            field = obj.model._meta.get_field(item)\n        except FieldDoesNotExist:\n            # Check if it's an admin attribute\n            if hasattr(obj, item):\n                return []\n            # Check if it's a model attribute\n            try:\n                field = getattr(obj.model, item)\n            except AttributeError:\n                return [\n                    checks.Error(\n                        \"The value of '%s' refers to '%s', which is not a \"\n                        \"callable, an attribute of '%s', or an attribute or \"\n                        \"method on '%s'.\"\n                        % (\n                            label,\n                            item,\n                            obj.__class__.__name__,\n                            obj.model._meta.label,\n                        ),\n                        obj=obj.__class__,\n                        id=\"admin.E108\",\n                    )\n                ]\n            else:\n                # Found model attribute, return empty list (no error)\n                return []\n",
      "\n    def _check_list_display_item(self, obj, item, label):\n        if callable(item):\n            return []\n        \n        # Check if it's a model field\n        try:\n            field = obj.model._meta.get_field(item)\n        except FieldDoesNotExist:\n            # Check if it's an attribute of the ModelAdmin\n            if hasattr(obj, item):\n                return []\n            # Check if it's an attribute of the model\n            try:\n                field = getattr(obj.model, item)\n            except AttributeError:\n                return [\n                    checks.Error(\n                        \"The value of '%s' refers to '%s', which is not a \"\n                        \"callable, an attribute of '%s', or an attribute or \"\n                        \"method on '%s'.\"\n                        % (\n                            label,\n                            item,\n                            obj.__class__.__name__,\n                            obj.model._meta.label,\n                        ),\n                        obj=obj.__class__,\n                        id=\"admin.E108\",\n                    )\n                ]\n            else:\n                # Model attribute exists, return no errors\n                return []\n        else:\n            # Model field exists, continue with field validation\n            pass\n",
      "\n    def _check_list_display_item(self, obj, item, label):\n        if callable(item):\n            return []\n        \n        # First check if it's a model field\n        try:\n            field = obj.model._meta.get_field(item)\n        except FieldDoesNotExist:\n            # Then check if it's an attribute of the ModelAdmin\n            if hasattr(obj, item):\n                return []\n            \n            # Finally check if it's an attribute of the model\n            try:\n                field = getattr(obj.model, item)\n            except AttributeError:\n                return [\n                    checks.Error(\n                        \"The value of '%s' refers to '%s', which is not a \"\n                        \"callable, an attribute of '%s', or an attribute or \"\n                        \"method on '%s'.\"\n                        % (\n                            label,\n                            item,\n                            obj.__class__.__name__,\n                            obj.model._meta.label,\n                        ),\n                        obj=obj.__class__,\n                        id=\"admin.E108\",\n                    )\n                ]\n            else:\n                # If we found it on the model, return no errors\n                return []\n",
      "\ndef _check_list_display_item(self, obj, item, label):\n    if callable(item):\n        return []\n    \n    # First check if it's a model field\n    try:\n        field = obj.model._meta.get_field(item)\n    except FieldDoesNotExist:\n        # Not a model field, check if it's an attribute of the ModelAdmin\n        if hasattr(obj, item):\n            return []\n        # Finally check if it's an attribute of the model\n        try:\n            field = getattr(obj.model, item)\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"The value of '%s' refers to '%s', which is not a \"\n                    \"callable, an attribute of '%s', or an attribute or \"\n                    \"method on '%s'.\"\n                    % (\n                        label,\n                        item,\n                        obj.__class__.__name__,\n                        obj.model._meta.label,\n                    ),\n                    obj=obj.__class__,\n                    id=\"admin.E108\",\n                )\n            ]\n        else:\n            # It's a model attribute, return empty list (no error)\n            return []\n    else:\n        # It's a model field, continue with existing field validation logic\n        pass\n",
      "\n    def _check_list_display_item(self, obj, item, label):\n        if callable(item):\n            return []\n        \n        # Check if it's a model field\n        try:\n            field = obj.model._meta.get_field(item)\n        except FieldDoesNotExist:\n            # Check if it's an admin attribute\n            if hasattr(obj, item):\n                return []\n            \n            # Check if it's a model attribute/method\n            try:\n                field = getattr(obj.model, item)\n            except AttributeError:\n                return [\n                    checks.Error(\n                        \"The value of '%s' refers to '%s', which is not a \"\n                        \"callable, an attribute of '%s', or an attribute or \"\n                        \"method on '%s'.\"\n                        % (\n                            label,\n                            item,\n                            obj.__class__.__name__,\n                            obj.model._meta.label,\n                        ),\n                        obj=obj.__class__,\n                        id=\"admin.E108\",\n                    )\n                ]\n            else:\n                # Found on model, continue with field validation\n                pass\n        else:\n            # Found as model field, continue with field validation\n            pass\n",
      "\n    def _check_list_display_item(self, obj, item, label):\n        if callable(item):\n            return []\n        \n        # Check if it's a model field first\n        try:\n            field = obj.model._meta.get_field(item)\n        except FieldDoesNotExist:\n            # Check if it's an attribute of the ModelAdmin class\n            if hasattr(obj, item):\n                return []\n            \n            # Check if it's an attribute or method on the model\n            try:\n                field = getattr(obj.model, item)\n            except AttributeError:\n                return [\n                    checks.Error(\n                        \"The value of '%s' refers to '%s', which is not a \"\n                        \"callable, an attribute of '%s', or an attribute or \"\n                        \"method on '%s'.\"\n                        % (\n                            label,\n                            item,\n                            obj.__class__.__name__,\n                            obj.model._meta.label,\n                        ),\n                        obj=obj.__class__,\n                        id=\"admin.E108\",\n                    )\n                ]\n            else:\n                # Found it on the model, so it's valid\n                return []\n",
      "\n    def _check_list_display_item(self, obj, item, label):\n        if callable(item):\n            return []\n        \n        # Check if it's a model field first\n        try:\n            field = obj.model._meta.get_field(item)\n        except FieldDoesNotExist:\n            # Check if it's an admin attribute\n            if hasattr(obj, item):\n                return []\n            \n            # Check if it's a model attribute/method\n            try:\n                field = getattr(obj.model, item)\n            except AttributeError:\n                return [\n                    checks.Error(\n                        \"The value of '%s' refers to '%s', which is not a \"\n                        \"callable, an attribute of '%s', or an attribute or \"\n                        \"method on '%s'.\"\n                        % (\n                            label,\n                            item,\n                            obj.__class__.__name__,\n                            obj.model._meta.label,\n                        ),\n                        obj=obj.__class__,\n                        id=\"admin.E108\",\n                    )\n                ]\n            else:\n                return []\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/contrib/admin/utils.py lines 340-378)": [
      "\ndef label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n    \"\"\"\n    Return a sensible label for a field name. The name can be a callable,\n    property (but not created with @property decorator), or the name of an\n    object's attribute, as well as a model field. If return_attr is True, also\n    return the resolved attribute (which could be a callable). This will be\n    None if (and only if) the name refers to a field.\n    \"\"\"\n    attr = None\n    try:\n        field = _get_non_gfk_field(model._meta, name)\n        try:\n            label = field.verbose_name\n        except AttributeError:\n            # field is likely a ForeignObjectRel\n            label = field.related_model._meta.verbose_name\n    except FieldDoesNotExist:\n        if name == \"__str__\":\n            label = str(model._meta.verbose_name)\n            attr = str\n        else:\n            if callable(name):\n                attr = name\n            elif model_admin and hasattr(model_admin, name):\n                attr = getattr(model_admin, name)\n            elif hasattr(model, name):\n                attr = getattr(model, name)\n            elif form and name in form.fields:\n                attr = form.fields[name]\n            else:\n                message = \"Unable to lookup '%s' on %s\" % (\n                    name,\n                    model._meta.object_name,\n                )\n                if model_admin:\n                    message += \" or %s\" % model_admin.__class__.__name__\n                if form:\n                    message += \" or %s\" % form.__class__.__name__\n                raise AttributeError(message)\n",
      "\ndef label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n    \"\"\"\n    Return a sensible label for a field name. The name can be a callable,\n    property (but not created with @property decorator), or the name of an\n    object's attribute, as well as a model field. If return_attr is True, also\n    return the resolved attribute (which could be a callable). This will be\n    None if (and only if) the name refers to a field.\n    \"\"\"\n    attr = None\n    try:\n        field = _get_non_gfk_field(model._meta, name)\n        try:\n            label = field.verbose_name\n        except AttributeError:\n            # field is likely a ForeignObjectRel\n            label = field.related_model._meta.verbose_name\n    except FieldDoesNotExist:\n        if name == \"__str__\":\n            label = str(model._meta.verbose_name)\n            attr = str\n        else:\n            if callable(name):\n                attr = name\n            elif model_admin and hasattr(model_admin, name):\n                attr = getattr(model_admin, name)\n            elif hasattr(model, name):\n                attr = getattr(model, name)\n            elif form and name in form.fields:\n                attr = form.fields[name]\n            else:\n                message = \"Unable to lookup '%s' on %s\" % (\n                    name,\n                    model._meta.object_name,\n                )\n                if model_admin:\n                    message += \" or %s\" % model_admin.__class__.__name__\n                if form:\n                    message += \" or %s\" % form.__class__.__name__\n                raise AttributeError(message)\n",
      "\ndef label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n    \"\"\"\n    Return a sensible label for a field name. The name can be a callable,\n    property (but not created with @property decorator), or the name of an\n    object's attribute, as well as a model field. If return_attr is True, also\n    return the resolved attribute (which could be a callable). This will be\n    None if (and only if) the name refers to a field.\n    \"\"\"\n    attr = None\n    try:\n        field = _get_non_gfk_field(model._meta, name)\n        try:\n            label = field.verbose_name\n        except AttributeError:\n            # field is likely a ForeignObjectRel\n            label = field.related_model._meta.verbose_name\n    except FieldDoesNotExist:\n        if name == \"__str__\":\n            label = str(model._meta.verbose_name)\n            attr = str\n        else:\n            if callable(name):\n                attr = name\n            elif model_admin and hasattr(model_admin, name):\n                attr = getattr(model_admin, name)\n            elif hasattr(model, name):\n                attr = getattr(model, name)\n            elif form and name in form.fields:\n                attr = form.fields[name]\n            else:\n                message = \"Unable to lookup '%s' on %s\" % (\n                    name,\n                    model._meta.object_name,\n                )\n                if model_admin:\n                    message += \" or %s\" % model_admin.__class__.__name__\n                if form:\n                    message += \" or %s\" % form.__class__.__name__\n                raise AttributeError(message)\n",
      "\ndef label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n    \"\"\"\n    Return a sensible label for a field name. The name can be a callable,\n    property (but not created with @property decorator), or the name of an\n    object's attribute, as well as a model field. If return_attr is True, also\n    return the resolved attribute (which could be a callable). This will be\n    None if (and only if) the name refers to a field.\n    \"\"\"\n    attr = None\n    try:\n        field = _get_non_gfk_field(model._meta, name)\n        try:\n            label = field.verbose_name\n        except AttributeError:\n            # field is likely a ForeignObjectRel\n            label = field.related_model._meta.verbose_name\n    except FieldDoesNotExist:\n        if name == \"__str__\":\n            label = str(model._meta.verbose_name)\n            attr = str\n        else:\n            if callable(name):\n                attr = name\n            elif model_admin and hasattr(model_admin, name):\n                attr = getattr(model_admin, name)\n            elif hasattr(model, name):\n                attr = getattr(model, name)\n            elif form and name in form.fields:\n                attr = form.fields[name]\n            else:\n                message = \"Unable to lookup '%s' on %s\" % (\n                    name,\n                    model._meta.object_name,\n                )\n                if model_admin:\n                    message += \" or %s\" % model_admin.__class__.__name__\n                if form:\n                    message += \" or %s\" % form.__class__.__name__\n                raise AttributeError(message)\n",
      "\ndef label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n    \"\"\"\n    Return a sensible label for a field name. The name can be a callable,\n    property (but not created with @property decorator), or the name of an\n    object's attribute, as well as a model field. If return_attr is True, also\n    return the resolved attribute (which could be a callable). This will be\n    None if (and only if) the name refers to a field.\n    \"\"\"\n    attr = None\n    try:\n        field = _get_non_gfk_field(model._meta, name)\n        try:\n            label = field.verbose_name\n        except AttributeError:\n            # field is likely a ForeignObjectRel\n            label = field.related_model._meta.verbose_name\n    except FieldDoesNotExist:\n        if name == \"__str__\":\n            label = str(model._meta.verbose_name)\n            attr = str\n        else:\n            if callable(name):\n                attr = name\n            elif model_admin and hasattr(model_admin, name):\n                attr = getattr(model_admin, name)\n            elif hasattr(model, name):\n                attr = getattr(model, name)\n            elif form and name in form.fields:\n                attr = form.fields[name]\n            else:\n                message = \"Unable to lookup '%s' on %s\" % (\n                    name,\n                    model._meta.object_name,\n                )\n                if model_admin:\n                    message += \" or %s\" % model_admin.__class__.__name__\n                if form:\n                    message += \" or %s\" % form.__class__.__name__\n                raise AttributeError(message)\n",
      "\ndef label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n    \"\"\"\n    Return a sensible label for a field name. The name can be a callable,\n    property (but not created with @property decorator), or the name of an\n    object's attribute, as well as a model field. If return_attr is True, also\n    return the resolved attribute (which could be a callable). This will be\n    None if (and only if) the name refers to a field.\n    \"\"\"\n    attr = None\n    try:\n        field = _get_non_gfk_field(model._meta, name)\n        try:\n            label = field.verbose_name\n        except AttributeError:\n            # field is likely a ForeignObjectRel\n            label = field.related_model._meta.verbose_name\n    except FieldDoesNotExist:\n        if name == \"__str__\":\n            label = str(model._meta.verbose_name)\n            attr = str\n        else:\n            if callable(name):\n                attr = name\n            elif model_admin and hasattr(model_admin, name):\n                attr = getattr(model_admin, name)\n            elif hasattr(model, name):\n                attr = getattr(model, name)\n            elif form and name in form.fields:\n                attr = form.fields[name]\n            else:\n                message = \"Unable to lookup '%s' on %s\" % (\n                    name,\n                    model._meta.object_name,\n                )\n                if model_admin:\n                    message += \" or %s\" % model_admin.__class__.__name__\n                if form:\n                    message += \" or %s\" % form.__class__.__name__\n                raise AttributeError(message)\n",
      "\ndef label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n    \"\"\"\n    Return a sensible label for a field name. The name can be a callable,\n    property (but not created with @property decorator), or the name of an\n    object's attribute, as well as a model field. If return_attr is True, also\n    return the resolved attribute (which could be a callable). This will be\n    None if (and only if) the name refers to a field.\n    \"\"\"\n    attr = None\n    try:\n        field = _get_non_gfk_field(model._meta, name)\n        try:\n            label = field.verbose_name\n        except AttributeError:\n            # field is likely a ForeignObjectRel\n            label = field.related_model._meta.verbose_name\n    except FieldDoesNotExist:\n        if name == \"__str__\":\n            label = str(model._meta.verbose_name)\n            attr = str\n        else:\n            if callable(name):\n                attr = name\n            elif model_admin and hasattr(model_admin, name):\n                attr = getattr(model_admin, name)\n            elif hasattr(model, name):\n                attr = getattr(model, name)\n            elif form and name in form.fields:\n                attr = form.fields[name]\n            else:\n                message = \"Unable to lookup '%s' on %s\" % (\n                    name,\n                    model._meta.object_name,\n                )\n                if model_admin:\n                    message += \" or %s\" % model_admin.__class__.__name__\n                if form:\n                    message += \" or %s\" % form.__class__.__name__\n                raise AttributeError(message)\n",
      "\ndef label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n    \"\"\"\n    Return a sensible label for a field name. The name can be a callable,\n    property (but not created with @property decorator), or the name of an\n    object's attribute, as well as a model field. If return_attr is True, also\n    return the resolved attribute (which could be a callable). This will be\n    None if (and only if) the name refers to a field.\n    \"\"\"\n    attr = None\n    try:\n        field = _get_non_gfk_field(model._meta, name)\n        try:\n            label = field.verbose_name\n        except AttributeError:\n            # field is likely a ForeignObjectRel\n            label = field.related_model._meta.verbose_name\n    except FieldDoesNotExist:\n        if name == \"__str__\":\n            label = str(model._meta.verbose_name)\n            attr = str\n        else:\n            if callable(name):\n                attr = name\n            elif model_admin and hasattr(model_admin, name):\n                attr = getattr(model_admin, name)\n            elif hasattr(model, name):\n                attr = getattr(model, name)\n            elif form and name in form.fields:\n                attr = form.fields[name]\n            else:\n                message = \"Unable to lookup '%s' on %s\" % (\n                    name,\n                    model._meta.object_name,\n                )\n                if model_admin:\n                    message += \" or %s\" % model_admin.__class__.__name__\n                if form:\n                    message += \" or %s\" % form.__class__.__name__\n                raise AttributeError(message)\n"
    ],
    "Location 3 (/root/hy/projects_4/django/tests/modeladmin/test_checks.py lines 520-531)": [
      "\n    def test_missing_field(self):\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"non_existent_field\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'non_existent_field', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n\n    def test_missing_field_choice_scenario(self):\n        \"\"\"\n        Test that list_display validation catches non-existent fields that\n        would fail at runtime, specifically the 'choice' scenario.\n        \"\"\"\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"choice\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'choice', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n",
      "\n    def test_missing_field(self):\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"non_existent_field\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'non_existent_field', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n\n    def test_missing_field_choice_scenario(self):\n        \"\"\"Test the specific scenario where 'choice' field doesn't exist.\"\"\"\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"choice\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'choice', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n",
      "\n    def test_missing_field(self):\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"non_existent_field\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'non_existent_field', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n\n    def test_missing_field_choice_scenario(self):\n        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"choice\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'choice', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n",
      "\n    def test_missing_field(self):\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"non_existent_field\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'non_existent_field', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n\n    def test_missing_field_choice_scenario(self):\n        \"\"\"Test the specific scenario where 'choice' field doesn't exist.\"\"\"\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"choice\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'choice', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n",
      "\n    def test_missing_field(self):\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"non_existent_field\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'non_existent_field', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n\n    def test_missing_field_choice_scenario(self):\n        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"choice\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'choice', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n",
      "\n    def test_missing_field(self):\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"non_existent_field\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'non_existent_field', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n\n    def test_missing_field_choice_scenario(self):\n        \"\"\"Test the specific scenario where list_display contains a non-existent field like 'choice'\"\"\"\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"choice\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'choice', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n",
      "\n    def test_missing_field(self):\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"non_existent_field\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'non_existent_field', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n\n    def test_missing_field_choice_scenario(self):\n        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"choice\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'choice', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n",
      "\n    def test_missing_field(self):\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"non_existent_field\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'non_existent_field', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n\n    def test_missing_field_choice_scenario(self):\n        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n        class TestModelAdmin(ModelAdmin):\n            list_display = (\"choice\",)\n\n        self.assertIsInvalid(\n            TestModelAdmin,\n            ValidationTestModel,\n            \"The value of 'list_display[0]' refers to 'choice', \"\n            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n            \"admin.E108\",\n        )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..e16c2c50d3 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -890,32 +890,51 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                 )\n             )\n \n+\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n-            return []\n+        \n+        # First, try to get the field from the model (same as runtime logic)\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n-            try:\n-                field = getattr(obj.model, item)\n-            except AttributeError:\n-                return [\n-                    checks.Error(\n-                        \"The value of '%s' refers to '%s', which is not a \"\n-                        \"callable, an attribute of '%s', or an attribute or \"\n-                        \"method on '%s'.\"\n-                        % (\n-                            label,\n-                            item,\n-                            obj.__class__.__name__,\n-                            obj.model._meta.label,\n-                        ),\n-                        obj=obj.__class__,\n-                        id=\"admin.E108\",\n-                    )\n-                ]\n+            # If not a model field, check in the same order as label_for_field\n+            if item == \"__str__\":\n+                # Special case for __str__ method\n+                return []\n+            elif callable(item):\n+                # Already checked above, but keeping for completeness\n+                return []\n+            elif hasattr(obj, item):\n+                # Check if admin has the attribute and it's actually usable\n+                attr = getattr(obj, item)\n+                if callable(attr) or hasattr(attr, 'short_description'):\n+                    return []\n+            elif hasattr(obj.model, item):\n+                # Check if model has the attribute\n+                try:\n+                    attr = getattr(obj.model, item)\n+                    return []\n+                except AttributeError:\n+                    pass\n+            \n+            # If none of the above worked, return E108 error\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n+                    \"method on '%s'.\"\n+                    % (\n+                        label,\n+                        item,\n+                        obj.__class__.__name__,\n+                        obj.model._meta.label,\n+                    ),\n+                    obj=obj.__class__,\n+                    id=\"admin.E108\",\n+                )\n+            ]\n         if isinstance(field, models.ManyToManyField) or (\n             getattr(field, \"rel\", None) and field.rel.field.many_to_one\n         ):\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 5e6a400b6c..45f69a83e1 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -337,6 +337,7 @@ def _get_non_gfk_field(opts, name):\n     return field\n \n \n+\n def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..2b89e09c6a 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -517,6 +517,7 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E107\",\n         )\n \n+\n     def test_missing_field(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"non_existent_field\",)\n@@ -530,6 +531,20 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E108\",\n         )\n \n+    def test_missing_field_choice_scenario(self):\n+        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = (\"choice\",)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin,\n+            ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'choice', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n+            \"admin.E108\",\n+        )\n+\n     def test_invalid_field_type(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"users\",)\n",
    "variant_0": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..ed33bbb52f 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -890,14 +890,19 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                 )\n             )\n \n+\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n-            return []\n+        \n+        # Check if it's a model field\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n+            # Check if it's an attribute of the ModelAdmin class\n+            if hasattr(obj, item):\n+                return []\n+            # Check if it's an attribute of the model\n             try:\n                 field = getattr(obj.model, item)\n             except AttributeError:\n@@ -916,6 +921,11 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                         id=\"admin.E108\",\n                     )\n                 ]\n+            else:\n+                return []\n+        else:\n+            # It's a model field, continue with field validation\n+            pass\n         if isinstance(field, models.ManyToManyField) or (\n             getattr(field, \"rel\", None) and field.rel.field.many_to_one\n         ):\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 5e6a400b6c..e5b810fd3b 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -337,6 +337,7 @@ def _get_non_gfk_field(opts, name):\n     return field\n \n \n+\n def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\n@@ -360,7 +361,7 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n         else:\n             if callable(name):\n                 attr = name\n-            elif hasattr(model_admin, name):\n+            elif model_admin and hasattr(model_admin, name):\n                 attr = getattr(model_admin, name)\n             elif hasattr(model, name):\n                 attr = getattr(model, name)\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..2b89e09c6a 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -517,6 +517,7 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E107\",\n         )\n \n+\n     def test_missing_field(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"non_existent_field\",)\n@@ -530,6 +531,20 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E108\",\n         )\n \n+    def test_missing_field_choice_scenario(self):\n+        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = (\"choice\",)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin,\n+            ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'choice', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n+            \"admin.E108\",\n+        )\n+\n     def test_invalid_field_type(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"users\",)\n",
    "variant_1": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..0f9f03e568 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -890,14 +890,19 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                 )\n             )\n \n+\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n-            return []\n+        \n+        # Check if it's a model field\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n+            # Check if it's an attribute of the ModelAdmin\n+            if hasattr(obj, item):\n+                return []\n+            # Check if it's an attribute/method of the model\n             try:\n                 field = getattr(obj.model, item)\n             except AttributeError:\n@@ -916,6 +921,8 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                         id=\"admin.E108\",\n                     )\n                 ]\n+            else:\n+                return []\n         if isinstance(field, models.ManyToManyField) or (\n             getattr(field, \"rel\", None) and field.rel.field.many_to_one\n         ):\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 5e6a400b6c..e5b810fd3b 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -337,6 +337,7 @@ def _get_non_gfk_field(opts, name):\n     return field\n \n \n+\n def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\n@@ -360,7 +361,7 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n         else:\n             if callable(name):\n                 attr = name\n-            elif hasattr(model_admin, name):\n+            elif model_admin and hasattr(model_admin, name):\n                 attr = getattr(model_admin, name)\n             elif hasattr(model, name):\n                 attr = getattr(model, name)\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..41f17bce1c 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -517,6 +517,7 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E107\",\n         )\n \n+\n     def test_missing_field(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"non_existent_field\",)\n@@ -530,6 +531,23 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E108\",\n         )\n \n+    def test_missing_field_choice_scenario(self):\n+        \"\"\"\n+        Test that list_display validation catches non-existent fields that\n+        would fail at runtime, specifically the 'choice' scenario.\n+        \"\"\"\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = (\"choice\",)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin,\n+            ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'choice', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n+            \"admin.E108\",\n+        )\n+\n     def test_invalid_field_type(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"users\",)\n",
    "variant_2": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..3ddafb8642 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -890,14 +890,19 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                 )\n             )\n \n+\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n-            return []\n+        \n+        # Check if it's a model field\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n+            # Check if it's an admin attribute\n+            if hasattr(obj, item):\n+                return []\n+            # Check if it's a model attribute\n             try:\n                 field = getattr(obj.model, item)\n             except AttributeError:\n@@ -916,6 +921,9 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                         id=\"admin.E108\",\n                     )\n                 ]\n+            else:\n+                # Found model attribute, return empty list (no error)\n+                return []\n         if isinstance(field, models.ManyToManyField) or (\n             getattr(field, \"rel\", None) and field.rel.field.many_to_one\n         ):\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 5e6a400b6c..e5b810fd3b 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -337,6 +337,7 @@ def _get_non_gfk_field(opts, name):\n     return field\n \n \n+\n def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\n@@ -360,7 +361,7 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n         else:\n             if callable(name):\n                 attr = name\n-            elif hasattr(model_admin, name):\n+            elif model_admin and hasattr(model_admin, name):\n                 attr = getattr(model_admin, name)\n             elif hasattr(model, name):\n                 attr = getattr(model, name)\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..e481252a19 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -517,6 +517,7 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E107\",\n         )\n \n+\n     def test_missing_field(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"non_existent_field\",)\n@@ -530,6 +531,20 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E108\",\n         )\n \n+    def test_missing_field_choice_scenario(self):\n+        \"\"\"Test the specific scenario where 'choice' field doesn't exist.\"\"\"\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = (\"choice\",)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin,\n+            ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'choice', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n+            \"admin.E108\",\n+        )\n+\n     def test_invalid_field_type(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"users\",)\n",
    "variant_3": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..d20b433291 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -890,14 +890,19 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                 )\n             )\n \n+\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n-            return []\n+        \n+        # Check if it's a model field\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n+            # Check if it's an attribute of the ModelAdmin\n+            if hasattr(obj, item):\n+                return []\n+            # Check if it's an attribute of the model\n             try:\n                 field = getattr(obj.model, item)\n             except AttributeError:\n@@ -916,6 +921,12 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                         id=\"admin.E108\",\n                     )\n                 ]\n+            else:\n+                # Model attribute exists, return no errors\n+                return []\n+        else:\n+            # Model field exists, continue with field validation\n+            pass\n         if isinstance(field, models.ManyToManyField) or (\n             getattr(field, \"rel\", None) and field.rel.field.many_to_one\n         ):\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 5e6a400b6c..e5b810fd3b 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -337,6 +337,7 @@ def _get_non_gfk_field(opts, name):\n     return field\n \n \n+\n def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\n@@ -360,7 +361,7 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n         else:\n             if callable(name):\n                 attr = name\n-            elif hasattr(model_admin, name):\n+            elif model_admin and hasattr(model_admin, name):\n                 attr = getattr(model_admin, name)\n             elif hasattr(model, name):\n                 attr = getattr(model, name)\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..2b89e09c6a 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -517,6 +517,7 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E107\",\n         )\n \n+\n     def test_missing_field(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"non_existent_field\",)\n@@ -530,6 +531,20 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E108\",\n         )\n \n+    def test_missing_field_choice_scenario(self):\n+        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = (\"choice\",)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin,\n+            ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'choice', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n+            \"admin.E108\",\n+        )\n+\n     def test_invalid_field_type(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"users\",)\n",
    "variant_4": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..19fd318272 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -890,14 +890,20 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                 )\n             )\n \n+\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n-            return []\n+        \n+        # First check if it's a model field\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n+            # Then check if it's an attribute of the ModelAdmin\n+            if hasattr(obj, item):\n+                return []\n+            \n+            # Finally check if it's an attribute of the model\n             try:\n                 field = getattr(obj.model, item)\n             except AttributeError:\n@@ -916,6 +922,9 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                         id=\"admin.E108\",\n                     )\n                 ]\n+            else:\n+                # If we found it on the model, return no errors\n+                return []\n         if isinstance(field, models.ManyToManyField) or (\n             getattr(field, \"rel\", None) and field.rel.field.many_to_one\n         ):\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 5e6a400b6c..e5b810fd3b 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -337,6 +337,7 @@ def _get_non_gfk_field(opts, name):\n     return field\n \n \n+\n def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\n@@ -360,7 +361,7 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n         else:\n             if callable(name):\n                 attr = name\n-            elif hasattr(model_admin, name):\n+            elif model_admin and hasattr(model_admin, name):\n                 attr = getattr(model_admin, name)\n             elif hasattr(model, name):\n                 attr = getattr(model, name)\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..e481252a19 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -517,6 +517,7 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E107\",\n         )\n \n+\n     def test_missing_field(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"non_existent_field\",)\n@@ -530,6 +531,20 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E108\",\n         )\n \n+    def test_missing_field_choice_scenario(self):\n+        \"\"\"Test the specific scenario where 'choice' field doesn't exist.\"\"\"\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = (\"choice\",)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin,\n+            ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'choice', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n+            \"admin.E108\",\n+        )\n+\n     def test_invalid_field_type(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"users\",)\n",
    "variant_5": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..5132780f85 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -890,32 +890,43 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                 )\n             )\n \n-    def _check_list_display_item(self, obj, item, label):\n-        if callable(item):\n-            return []\n-        elif hasattr(obj, item):\n+\n+def _check_list_display_item(self, obj, item, label):\n+    if callable(item):\n+        return []\n+    \n+    # First check if it's a model field\n+    try:\n+        field = obj.model._meta.get_field(item)\n+    except FieldDoesNotExist:\n+        # Not a model field, check if it's an attribute of the ModelAdmin\n+        if hasattr(obj, item):\n             return []\n+        # Finally check if it's an attribute of the model\n         try:\n-            field = obj.model._meta.get_field(item)\n-        except FieldDoesNotExist:\n-            try:\n-                field = getattr(obj.model, item)\n-            except AttributeError:\n-                return [\n-                    checks.Error(\n-                        \"The value of '%s' refers to '%s', which is not a \"\n-                        \"callable, an attribute of '%s', or an attribute or \"\n-                        \"method on '%s'.\"\n-                        % (\n-                            label,\n-                            item,\n-                            obj.__class__.__name__,\n-                            obj.model._meta.label,\n-                        ),\n-                        obj=obj.__class__,\n-                        id=\"admin.E108\",\n-                    )\n-                ]\n+            field = getattr(obj.model, item)\n+        except AttributeError:\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n+                    \"method on '%s'.\"\n+                    % (\n+                        label,\n+                        item,\n+                        obj.__class__.__name__,\n+                        obj.model._meta.label,\n+                    ),\n+                    obj=obj.__class__,\n+                    id=\"admin.E108\",\n+                )\n+            ]\n+        else:\n+            # It's a model attribute, return empty list (no error)\n+            return []\n+    else:\n+        # It's a model field, continue with existing field validation logic\n+        pass\n         if isinstance(field, models.ManyToManyField) or (\n             getattr(field, \"rel\", None) and field.rel.field.many_to_one\n         ):\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 5e6a400b6c..e5b810fd3b 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -337,6 +337,7 @@ def _get_non_gfk_field(opts, name):\n     return field\n \n \n+\n def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\n@@ -360,7 +361,7 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n         else:\n             if callable(name):\n                 attr = name\n-            elif hasattr(model_admin, name):\n+            elif model_admin and hasattr(model_admin, name):\n                 attr = getattr(model_admin, name)\n             elif hasattr(model, name):\n                 attr = getattr(model, name)\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..2b89e09c6a 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -517,6 +517,7 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E107\",\n         )\n \n+\n     def test_missing_field(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"non_existent_field\",)\n@@ -530,6 +531,20 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E108\",\n         )\n \n+    def test_missing_field_choice_scenario(self):\n+        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = (\"choice\",)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin,\n+            ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'choice', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n+            \"admin.E108\",\n+        )\n+\n     def test_invalid_field_type(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"users\",)\n",
    "variant_6": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..e8767819c5 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -890,14 +890,20 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                 )\n             )\n \n+\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n-            return []\n+        \n+        # Check if it's a model field\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n+            # Check if it's an admin attribute\n+            if hasattr(obj, item):\n+                return []\n+            \n+            # Check if it's a model attribute/method\n             try:\n                 field = getattr(obj.model, item)\n             except AttributeError:\n@@ -916,6 +922,12 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                         id=\"admin.E108\",\n                     )\n                 ]\n+            else:\n+                # Found on model, continue with field validation\n+                pass\n+        else:\n+            # Found as model field, continue with field validation\n+            pass\n         if isinstance(field, models.ManyToManyField) or (\n             getattr(field, \"rel\", None) and field.rel.field.many_to_one\n         ):\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 5e6a400b6c..e5b810fd3b 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -337,6 +337,7 @@ def _get_non_gfk_field(opts, name):\n     return field\n \n \n+\n def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\n@@ -360,7 +361,7 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n         else:\n             if callable(name):\n                 attr = name\n-            elif hasattr(model_admin, name):\n+            elif model_admin and hasattr(model_admin, name):\n                 attr = getattr(model_admin, name)\n             elif hasattr(model, name):\n                 attr = getattr(model, name)\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..c98fc3dbf9 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -517,6 +517,7 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E107\",\n         )\n \n+\n     def test_missing_field(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"non_existent_field\",)\n@@ -530,6 +531,20 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E108\",\n         )\n \n+    def test_missing_field_choice_scenario(self):\n+        \"\"\"Test the specific scenario where list_display contains a non-existent field like 'choice'\"\"\"\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = (\"choice\",)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin,\n+            ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'choice', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n+            \"admin.E108\",\n+        )\n+\n     def test_invalid_field_type(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"users\",)\n",
    "variant_7": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..ef04010101 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -890,14 +890,20 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                 )\n             )\n \n+\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n-            return []\n+        \n+        # Check if it's a model field first\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n+            # Check if it's an attribute of the ModelAdmin class\n+            if hasattr(obj, item):\n+                return []\n+            \n+            # Check if it's an attribute or method on the model\n             try:\n                 field = getattr(obj.model, item)\n             except AttributeError:\n@@ -916,6 +922,9 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                         id=\"admin.E108\",\n                     )\n                 ]\n+            else:\n+                # Found it on the model, so it's valid\n+                return []\n         if isinstance(field, models.ManyToManyField) or (\n             getattr(field, \"rel\", None) and field.rel.field.many_to_one\n         ):\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 5e6a400b6c..e5b810fd3b 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -337,6 +337,7 @@ def _get_non_gfk_field(opts, name):\n     return field\n \n \n+\n def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\n@@ -360,7 +361,7 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n         else:\n             if callable(name):\n                 attr = name\n-            elif hasattr(model_admin, name):\n+            elif model_admin and hasattr(model_admin, name):\n                 attr = getattr(model_admin, name)\n             elif hasattr(model, name):\n                 attr = getattr(model, name)\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..2b89e09c6a 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -517,6 +517,7 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E107\",\n         )\n \n+\n     def test_missing_field(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"non_existent_field\",)\n@@ -530,6 +531,20 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E108\",\n         )\n \n+    def test_missing_field_choice_scenario(self):\n+        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = (\"choice\",)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin,\n+            ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'choice', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n+            \"admin.E108\",\n+        )\n+\n     def test_invalid_field_type(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"users\",)\n",
    "variant_8": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..3ce283ff87 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -890,14 +890,20 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                 )\n             )\n \n+\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n-            return []\n+        \n+        # Check if it's a model field first\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n+            # Check if it's an admin attribute\n+            if hasattr(obj, item):\n+                return []\n+            \n+            # Check if it's a model attribute/method\n             try:\n                 field = getattr(obj.model, item)\n             except AttributeError:\n@@ -916,6 +922,8 @@ class ModelAdminChecks(BaseModelAdminChecks):\n                         id=\"admin.E108\",\n                     )\n                 ]\n+            else:\n+                return []\n         if isinstance(field, models.ManyToManyField) or (\n             getattr(field, \"rel\", None) and field.rel.field.many_to_one\n         ):\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 5e6a400b6c..e5b810fd3b 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -337,6 +337,7 @@ def _get_non_gfk_field(opts, name):\n     return field\n \n \n+\n def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n     \"\"\"\n     Return a sensible label for a field name. The name can be a callable,\n@@ -360,7 +361,7 @@ def label_for_field(name, model, model_admin=None, return_attr=False, form=None)\n         else:\n             if callable(name):\n                 attr = name\n-            elif hasattr(model_admin, name):\n+            elif model_admin and hasattr(model_admin, name):\n                 attr = getattr(model_admin, name)\n             elif hasattr(model, name):\n                 attr = getattr(model, name)\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex 85f2eda69e..2b89e09c6a 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -517,6 +517,7 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E107\",\n         )\n \n+\n     def test_missing_field(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"non_existent_field\",)\n@@ -530,6 +531,20 @@ class ListDisplayTests(CheckTestCase):\n             \"admin.E108\",\n         )\n \n+    def test_missing_field_choice_scenario(self):\n+        \"\"\"Test the specific bug scenario where 'choice' field doesn't exist.\"\"\"\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = (\"choice\",)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin,\n+            ValidationTestModel,\n+            \"The value of 'list_display[0]' refers to 'choice', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'modeladmin.ValidationTestModel'.\",\n+            \"admin.E108\",\n+        )\n+\n     def test_invalid_field_type(self):\n         class TestModelAdmin(ModelAdmin):\n             list_display = (\"users\",)\n"
  }
}