{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/typehints.py lines 114-128)": "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
    "Location 2 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/typehints.py lines 96-106)": "\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                      suppress_rtype: bool = False) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                arg = arguments.setdefault(param_name, {})\n                arg['param'] = True\n                \n                # Handle *args/**kwargs bidirectional mapping\n                if param_name == '*args':\n                    arguments.setdefault('args', {})['param'] = True\n                elif param_name == '**kwargs':\n                    arguments.setdefault('kwargs', {})['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            arg = arguments.setdefault(name, {})\n            arg['type'] = True\n        elif parts[0] == 'rtype':\n            arguments['return'] = {'type': True}\n\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n\n    if not suppress_rtype and 'return' in annotations:\n        rtype = arguments.get('return', {})\n        if not rtype.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'rtype')\n            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n            node += field\n",
    "Location 3 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/typehints.py lines 118-123)": "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        display_name = name\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                if possible_name.startswith('*'):\n                    display_name = possible_name\n                break\n\n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/typehints.py lines 114-128)": [
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n        \n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        display_name = name\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                if possible_name.startswith('*'):\n                    display_name = possible_name\n                break\n        \n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n        \n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n        \n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n        \n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n"
    ],
    "Location 2 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/typehints.py lines 96-106)": [
      "\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                      suppress_rtype: bool = False) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                arg = arguments.setdefault(param_name, {})\n                arg['param'] = True\n                \n                # Handle *args/**kwargs bidirectional mapping\n                if param_name == '*args':\n                    arguments.setdefault('args', {})['param'] = True\n                elif param_name == '**kwargs':\n                    arguments.setdefault('kwargs', {})['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            arg = arguments.setdefault(name, {})\n            arg['type'] = True\n        elif parts[0] == 'rtype':\n            arguments['return'] = {'type': True}\n\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        elif not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n\n    if not suppress_rtype and 'return' in annotations:\n        rtype = arguments.get('return', {})\n        if not rtype.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'rtype')\n            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n            node += field\n",
      "\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                      suppress_rtype: bool = False) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                arg = arguments.setdefault(param_name, {})\n                arg['param'] = True\n                \n                # Handle *args/**kwargs bidirectional mapping\n                if param_name == '*args':\n                    arguments.setdefault('args', {})['param'] = True\n                elif param_name == '**kwargs':\n                    arguments.setdefault('kwargs', {})['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            arg = arguments.setdefault(name, {})\n            arg['type'] = True\n        elif parts[0] == 'rtype':\n            arguments['return'] = {'type': True}\n\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n\n    if not suppress_rtype and 'return' in annotations:\n        rtype = arguments.get('return', {})\n        if not rtype.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'rtype')\n            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n            node += field\n",
      "\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                      suppress_rtype: bool = False) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                arg = arguments.setdefault(param_name, {})\n                arg['param'] = True\n                \n                # Handle *args/**kwargs bidirectional mapping\n                if param_name == '*args':\n                    arguments.setdefault('args', {})['param'] = True\n                elif param_name == '**kwargs':\n                    arguments.setdefault('kwargs', {})['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            arg = arguments.setdefault(name, {})\n            arg['type'] = True\n        elif parts[0] == 'rtype':\n            arguments['return'] = {'type': True}\n\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n\n    if not suppress_rtype and 'return' in annotations:\n        rtype = arguments.get('return', {})\n        if not rtype.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'rtype')\n            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n            node += field\n",
      "\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                      suppress_rtype: bool = False) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                arg = arguments.setdefault(param_name, {})\n                arg['param'] = True\n                \n                # Handle *args/**kwargs bidirectional mapping\n                if param_name == '*args':\n                    arguments.setdefault('args', {})['param'] = True\n                elif param_name == '**kwargs':\n                    arguments.setdefault('kwargs', {})['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            arg = arguments.setdefault(name, {})\n            arg['type'] = True\n        elif parts[0] == 'rtype':\n            arguments['return'] = {'type': True}\n\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n\n    if not suppress_rtype and 'return' in annotations:\n        rtype = arguments.get('return', {})\n        if not rtype.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'rtype')\n            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n            node += field\n",
      "\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                      suppress_rtype: bool = False) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                arg = arguments.setdefault(param_name, {})\n                arg['param'] = True\n                \n                # Handle *args/**kwargs bidirectional mapping\n                if param_name == '*args':\n                    arguments.setdefault('args', {})['param'] = True\n                elif param_name == '**kwargs':\n                    arguments.setdefault('kwargs', {})['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                      suppress_rtype: bool = False) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                arg = arguments.setdefault(param_name, {})\n                arg['param'] = True\n                \n                # Handle *args/**kwargs bidirectional mapping\n                if param_name == '*args':\n                    arguments.setdefault('args', {})['param'] = True\n                elif param_name == '**kwargs':\n                    arguments.setdefault('kwargs', {})['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n",
      "\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                      suppress_rtype: bool = False) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                arg = arguments.setdefault(param_name, {})\n                arg['param'] = True\n                \n                # Handle *args/**kwargs bidirectional mapping\n                if param_name == '*args':\n                    arguments.setdefault('args', {})['param'] = True\n                elif param_name == '**kwargs':\n                    arguments.setdefault('kwargs', {})['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            arg = arguments.setdefault(name, {})\n            arg['type'] = True\n        elif parts[0] == 'rtype':\n            arguments['return'] = {'type': True}\n\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n\n    if not suppress_rtype and 'return' in annotations:\n        rtype = arguments.get('return', {})\n        if not rtype.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'rtype')\n            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n            node += field\n",
      "\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                      suppress_rtype: bool = False) -> None:\n    arguments: Dict[str, Dict[str, bool]] = {}\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                arg = arguments.setdefault(param_name, {})\n                arg['param'] = True\n                \n                # Handle *args/**kwargs bidirectional mapping\n                if param_name == '*args':\n                    arguments.setdefault('args', {})['param'] = True\n                elif param_name == '**kwargs':\n                    arguments.setdefault('kwargs', {})['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            arg = arguments.setdefault(name, {})\n            arg['type'] = True\n        elif parts[0] == 'rtype':\n            arguments['return'] = {'type': True}\n\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n\n    if not suppress_rtype and 'return' in annotations:\n        rtype = arguments.get('return', {})\n        if not rtype.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'rtype')\n            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n            node += field\n"
    ],
    "Location 3 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/typehints.py lines 118-123)": [
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n",
      "\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        # Try multiple name variations to handle *args/**kwargs mismatch\n        possible_names = [name]\n        if name == 'args':\n            possible_names.append('*args')\n        elif name == 'kwargs':\n            possible_names.append('**kwargs')\n        \n        arg = {}\n        for possible_name in possible_names:\n            if possible_name in arguments:\n                arg = arguments[possible_name]\n                break\n\n        if not arg.get('type'):\n            # Use the documented parameter name format if available\n            display_name = name\n            if name == 'args' and '*args' in arguments:\n                display_name = '*args'\n            elif name == 'kwargs' and '**kwargs' in arguments:\n                display_name = '**kwargs'\n            \n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..a2e8e8d5c 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -93,11 +93,19 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n     for field in fields:\n         field_name = field[0].astext()\n         parts = re.split(' +', field_name)\n+\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                arg = arguments.setdefault(parts[1], {})\n+                param_name = parts[1]\n+                arg = arguments.setdefault(param_name, {})\n                 arg['param'] = True\n+                \n+                # Handle *args/**kwargs bidirectional mapping\n+                if param_name == '*args':\n+                    arguments.setdefault('args', {})['param'] = True\n+                elif param_name == '**kwargs':\n+                    arguments.setdefault('kwargs', {})['param'] = True\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n@@ -111,14 +119,44 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        documented_name = name\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                documented_name = possible_name\n+                break\n+        \n         if not arg.get('type'):\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + documented_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + documented_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                documented_name = possible_name\n+                break\n+        \n+        if not arg.get('type'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + documented_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n         if not arg.get('param'):\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..2b4df5fca 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -86,6 +86,14 @@ def insert_field_list(node: Element) -> nodes.field_list:\n     return field_list\n \n \n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n+                      suppress_rtype: bool = False) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                       suppress_rtype: bool = False) -> None:\n     arguments: Dict[str, Dict[str, bool]] = {}\n@@ -96,8 +104,15 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                arg = arguments.setdefault(parts[1], {})\n+                param_name = parts[1]\n+                arg = arguments.setdefault(param_name, {})\n                 arg['param'] = True\n+                \n+                # Handle *args/**kwargs bidirectional mapping\n+                if param_name == '*args':\n+                    arguments.setdefault('args', {})['param'] = True\n+                elif param_name == '**kwargs':\n+                    arguments.setdefault('kwargs', {})['param'] = True\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n@@ -115,10 +130,107 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+\n         if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+\n+    if not suppress_rtype and 'return' in annotations:\n+        rtype = arguments.get('return', {})\n+        if not rtype.get('type'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'rtype')\n+            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n+            node += field\n+        elif parts[0] == 'type':\n+            name = ' '.join(parts[1:])\n+            arg = arguments.setdefault(name, {})\n+            arg['type'] = True\n+        elif parts[0] == 'rtype':\n+            arguments['return'] = {'type': True}\n+\n+\n+    for name, annotation in annotations.items():\n+        if name == 'return':\n+            continue\n+\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+        \n+        arg = {}\n+        display_name = name\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                if possible_name.startswith('*'):\n+                    display_name = possible_name\n+                break\n+\n+        if not arg.get('type'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n         if not arg.get('param'):\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..a46dccac6 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -86,6 +86,14 @@ def insert_field_list(node: Element) -> nodes.field_list:\n     return field_list\n \n \n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n+                      suppress_rtype: bool = False) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                       suppress_rtype: bool = False) -> None:\n     arguments: Dict[str, Dict[str, bool]] = {}\n@@ -96,8 +104,15 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                arg = arguments.setdefault(parts[1], {})\n+                param_name = parts[1]\n+                arg = arguments.setdefault(param_name, {})\n                 arg['param'] = True\n+                \n+                # Handle *args/**kwargs bidirectional mapping\n+                if param_name == '*args':\n+                    arguments.setdefault('args', {})['param'] = True\n+                elif param_name == '**kwargs':\n+                    arguments.setdefault('kwargs', {})['param'] = True\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n@@ -115,10 +130,110 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        elif not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+\n+    if not suppress_rtype and 'return' in annotations:\n+        rtype = arguments.get('return', {})\n+        if not rtype.get('type'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'rtype')\n+            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n+            node += field\n+        elif parts[0] == 'type':\n+            name = ' '.join(parts[1:])\n+            arg = arguments.setdefault(name, {})\n+            arg['type'] = True\n+        elif parts[0] == 'rtype':\n+            arguments['return'] = {'type': True}\n+\n+\n+    for name, annotation in annotations.items():\n+        if name == 'return':\n+            continue\n+\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n         if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n         if not arg.get('param'):\n@@ -126,6 +241,11 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n             field += nodes.field_name('', 'param ' + name)\n             field += nodes.field_body('', nodes.paragraph('', ''))\n             node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n \n     if 'return' in annotations and 'return' not in arguments:\n         annotation = annotations['return']\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..12defb74f 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -86,6 +86,14 @@ def insert_field_list(node: Element) -> nodes.field_list:\n     return field_list\n \n \n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n+                      suppress_rtype: bool = False) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                       suppress_rtype: bool = False) -> None:\n     arguments: Dict[str, Dict[str, bool]] = {}\n@@ -96,8 +104,15 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                arg = arguments.setdefault(parts[1], {})\n+                param_name = parts[1]\n+                arg = arguments.setdefault(param_name, {})\n                 arg['param'] = True\n+                \n+                # Handle *args/**kwargs bidirectional mapping\n+                if param_name == '*args':\n+                    arguments.setdefault('args', {})['param'] = True\n+                elif param_name == '**kwargs':\n+                    arguments.setdefault('kwargs', {})['param'] = True\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n@@ -115,12 +130,118 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+\n         if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n+\n+    if not suppress_rtype and 'return' in annotations:\n+        rtype = arguments.get('return', {})\n+        if not rtype.get('type'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'rtype')\n+            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n+            node += field\n+        elif parts[0] == 'type':\n+            name = ' '.join(parts[1:])\n+            arg = arguments.setdefault(name, {})\n+            arg['type'] = True\n+        elif parts[0] == 'rtype':\n+            arguments['return'] = {'type': True}\n+\n+\n+    for name, annotation in annotations.items():\n+        if name == 'return':\n+            continue\n+\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n         if not arg.get('param'):\n             field = nodes.field()\n             field += nodes.field_name('', 'param ' + name)\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..a0b90d538 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -86,6 +86,14 @@ def insert_field_list(node: Element) -> nodes.field_list:\n     return field_list\n \n \n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n+                      suppress_rtype: bool = False) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                       suppress_rtype: bool = False) -> None:\n     arguments: Dict[str, Dict[str, bool]] = {}\n@@ -96,8 +104,15 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                arg = arguments.setdefault(parts[1], {})\n+                param_name = parts[1]\n+                arg = arguments.setdefault(param_name, {})\n                 arg['param'] = True\n+                \n+                # Handle *args/**kwargs bidirectional mapping\n+                if param_name == '*args':\n+                    arguments.setdefault('args', {})['param'] = True\n+                elif param_name == '**kwargs':\n+                    arguments.setdefault('kwargs', {})['param'] = True\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n@@ -115,12 +130,118 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+\n         if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+\n+    if not suppress_rtype and 'return' in annotations:\n+        rtype = arguments.get('return', {})\n+        if not rtype.get('type'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'rtype')\n+            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n+            node += field\n+        elif parts[0] == 'type':\n+            name = ' '.join(parts[1:])\n+            arg = arguments.setdefault(name, {})\n+            arg['type'] = True\n+        elif parts[0] == 'rtype':\n+            arguments['return'] = {'type': True}\n+\n+\n+    for name, annotation in annotations.items():\n+        if name == 'return':\n+            continue\n+\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+        \n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n+        if not arg.get('param'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n         if not arg.get('param'):\n             field = nodes.field()\n             field += nodes.field_name('', 'param ' + name)\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..022e67b07 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -86,6 +86,14 @@ def insert_field_list(node: Element) -> nodes.field_list:\n     return field_list\n \n \n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n+                      suppress_rtype: bool = False) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                       suppress_rtype: bool = False) -> None:\n     arguments: Dict[str, Dict[str, bool]] = {}\n@@ -96,8 +104,15 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                arg = arguments.setdefault(parts[1], {})\n+                param_name = parts[1]\n+                arg = arguments.setdefault(param_name, {})\n                 arg['param'] = True\n+                \n+                # Handle *args/**kwargs bidirectional mapping\n+                if param_name == '*args':\n+                    arguments.setdefault('args', {})['param'] = True\n+                elif param_name == '**kwargs':\n+                    arguments.setdefault('kwargs', {})['param'] = True\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n@@ -115,12 +130,107 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+\n         if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+\n+    if not suppress_rtype and 'return' in annotations:\n+        rtype = arguments.get('return', {})\n+        if not rtype.get('type'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'rtype')\n+            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n+            node += field\n+        elif parts[0] == 'type':\n+            name = ' '.join(parts[1:])\n+            arg = arguments.setdefault(name, {})\n+            arg['type'] = True\n+        elif parts[0] == 'rtype':\n+            arguments['return'] = {'type': True}\n+\n+\n+    for name, annotation in annotations.items():\n+        if name == 'return':\n+            continue\n+\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        display_name = name\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                if possible_name.startswith('*'):\n+                    display_name = possible_name\n+                break\n+        \n+        if not arg.get('type'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n         if not arg.get('param'):\n             field = nodes.field()\n             field += nodes.field_name('', 'param ' + name)\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..bf99d62e5 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -86,6 +86,14 @@ def insert_field_list(node: Element) -> nodes.field_list:\n     return field_list\n \n \n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n+                      suppress_rtype: bool = False) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                       suppress_rtype: bool = False) -> None:\n     arguments: Dict[str, Dict[str, bool]] = {}\n@@ -96,8 +104,15 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                arg = arguments.setdefault(parts[1], {})\n+                param_name = parts[1]\n+                arg = arguments.setdefault(param_name, {})\n                 arg['param'] = True\n+                \n+                # Handle *args/**kwargs bidirectional mapping\n+                if param_name == '*args':\n+                    arguments.setdefault('args', {})['param'] = True\n+                elif param_name == '**kwargs':\n+                    arguments.setdefault('kwargs', {})['param'] = True\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n@@ -111,14 +126,65 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+        \n         if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n         if not arg.get('param'):\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..ee9ddcaa2 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -86,6 +86,14 @@ def insert_field_list(node: Element) -> nodes.field_list:\n     return field_list\n \n \n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n+                      suppress_rtype: bool = False) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                       suppress_rtype: bool = False) -> None:\n     arguments: Dict[str, Dict[str, bool]] = {}\n@@ -96,8 +104,15 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                arg = arguments.setdefault(parts[1], {})\n+                param_name = parts[1]\n+                arg = arguments.setdefault(param_name, {})\n                 arg['param'] = True\n+                \n+                # Handle *args/**kwargs bidirectional mapping\n+                if param_name == '*args':\n+                    arguments.setdefault('args', {})['param'] = True\n+                elif param_name == '**kwargs':\n+                    arguments.setdefault('kwargs', {})['param'] = True\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n@@ -111,16 +126,72 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         elif parts[0] == 'rtype':\n             arguments['return'] = {'type': True}\n \n+\n     for name, annotation in annotations.items():\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n         if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n+        if not arg.get('param'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n         if not arg.get('param'):\n             field = nodes.field()\n             field += nodes.field_name('', 'param ' + name)\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..a0b90d538 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -86,6 +86,14 @@ def insert_field_list(node: Element) -> nodes.field_list:\n     return field_list\n \n \n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n+                      suppress_rtype: bool = False) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                       suppress_rtype: bool = False) -> None:\n     arguments: Dict[str, Dict[str, bool]] = {}\n@@ -96,8 +104,15 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                arg = arguments.setdefault(parts[1], {})\n+                param_name = parts[1]\n+                arg = arguments.setdefault(param_name, {})\n                 arg['param'] = True\n+                \n+                # Handle *args/**kwargs bidirectional mapping\n+                if param_name == '*args':\n+                    arguments.setdefault('args', {})['param'] = True\n+                elif param_name == '**kwargs':\n+                    arguments.setdefault('kwargs', {})['param'] = True\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n@@ -115,12 +130,118 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+\n         if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+\n+    if not suppress_rtype and 'return' in annotations:\n+        rtype = arguments.get('return', {})\n+        if not rtype.get('type'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'rtype')\n+            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n+            node += field\n+        elif parts[0] == 'type':\n+            name = ' '.join(parts[1:])\n+            arg = arguments.setdefault(name, {})\n+            arg['type'] = True\n+        elif parts[0] == 'rtype':\n+            arguments['return'] = {'type': True}\n+\n+\n+    for name, annotation in annotations.items():\n+        if name == 'return':\n+            continue\n+\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+        \n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n+        if not arg.get('param'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n         if not arg.get('param'):\n             field = nodes.field()\n             field += nodes.field_name('', 'param ' + name)\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..a0b90d538 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -86,6 +86,14 @@ def insert_field_list(node: Element) -> nodes.field_list:\n     return field_list\n \n \n+def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n+                      suppress_rtype: bool = False) -> None:\n+    arguments: Dict[str, Dict[str, bool]] = {}\n+    fields = cast(Iterable[nodes.field], node)\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n                       suppress_rtype: bool = False) -> None:\n     arguments: Dict[str, Dict[str, bool]] = {}\n@@ -96,8 +104,15 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                arg = arguments.setdefault(parts[1], {})\n+                param_name = parts[1]\n+                arg = arguments.setdefault(param_name, {})\n                 arg['param'] = True\n+                \n+                # Handle *args/**kwargs bidirectional mapping\n+                if param_name == '*args':\n+                    arguments.setdefault('args', {})['param'] = True\n+                elif param_name == '**kwargs':\n+                    arguments.setdefault('kwargs', {})['param'] = True\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n@@ -115,12 +130,118 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n         if name == 'return':\n             continue\n \n-        arg = arguments.get(name, {})\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+\n         if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+\n+    if not suppress_rtype and 'return' in annotations:\n+        rtype = arguments.get('return', {})\n+        if not rtype.get('type'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'rtype')\n+            field += nodes.field_body('', nodes.paragraph('', annotations['return']))\n+            node += field\n+        elif parts[0] == 'type':\n+            name = ' '.join(parts[1:])\n+            arg = arguments.setdefault(name, {})\n+            arg['type'] = True\n+        elif parts[0] == 'rtype':\n+            arguments['return'] = {'type': True}\n+\n+\n+    for name, annotation in annotations.items():\n+        if name == 'return':\n+            continue\n+\n+        # Try multiple name variations to handle *args/**kwargs mismatch\n+        possible_names = [name]\n+        if name == 'args':\n+            possible_names.append('*args')\n+        elif name == 'kwargs':\n+            possible_names.append('**kwargs')\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+        \n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotation))\n             node += field\n+        if not arg.get('param'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n+        \n+        arg = {}\n+        for possible_name in possible_names:\n+            if possible_name in arguments:\n+                arg = arguments[possible_name]\n+                break\n+\n+        if not arg.get('type'):\n+            # Use the documented parameter name format if available\n+            display_name = name\n+            if name == 'args' and '*args' in arguments:\n+                display_name = '*args'\n+            elif name == 'kwargs' and '**kwargs' in arguments:\n+                display_name = '**kwargs'\n+            \n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + display_name)\n+            field += nodes.field_body('', nodes.paragraph('', annotation))\n+            node += field\n+        if not arg.get('param'):\n+            field = nodes.field()\n+            field += nodes.field_name('', 'param ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', ''))\n+            node += field\n         if not arg.get('param'):\n             field = nodes.field()\n             field += nodes.field_name('', 'param ' + name)\n"
  }
}